! "serpqteh" === description  synergy erp  Quote entry/edit system
!
! loadsave -w -n 100,10 -o prog/dxport/serpqteh.dl4 src/serpqteh.src
!  
!
! ******** PLEASE MAKE ANY CHANGES ON SERPORDH ALSO - IF APPLICABLE!! ***
! ******** ANY FIELD ADDED HERE NEEDS TO BE IN SERPORDH ALSO **********
!******************************************************************************
! taken from serpordh and modified for quotes
!
include "src/copyright.inc"
!
include "src/inc/filecust.inc" ! customer
include "src/inc/filesaract.inc" ! a/r file ! for credit checking
include "src/inc/fileqordhead.inc" ! order header, order shipto, order rot
include "src/inc/fileartermcode.inc" ! a/r term codes
include "src/inc/filedeptfle.inc" ! department file
include "src/inc/filewhinfoz.inc" ! warehouse
include "src/inc/fileentdby.inc" ! enterby file 
include "src/inc/filezonefle.inc" ! zone file
include "src/inc/filedivifle.inc" ! division file
include "src/inc/filesorce.inc" ! source file
include "src/inc/filesslsmz.inc" ! slsm file
include "src/inc/fileprtdefault.inc" ! port default
include "src/inc/fileshiplist.inc" ! ship list file
Include "src/inc/filecustnotes.inc" ! customer notes file  
Include "src/inc/fileqom.inc" ! order message file
Include "src/inc/fileqolz.inc" ! order lines file
Include "src/inc/filemiscchrg.inc" ! misc charge file
Include "src/inc/filetaxcode.inc" ! tax code file
Include "src/inc/filecusttax.inc" ! customer tax type file
Include "src/inc/filespecmsg.inc" ! special message  file
! Include "src/inc/filesordcash.inc" ! cash order file
Include "src/inc/filea80vm.inc" ! vendor file
include "src/inc/fileedittrack.inc" ! edit tracking
! for multicurrency
include "src/inc/filecurrency.inc" ! currency exchange file

External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus
Declare External Sub CustInfoHeading,CustInfoRecord

!
 External Lib "libdroplist.lib"
 Declare External sub CustDropList,CMTypeDropList
 Declare External sub OrdTypeDropList,RoutingDropList,ShipTermDropList
!
 External Lib "libtable.lib"
 Declare External Function GetARTypeDesc$
!
External Lib "ubsfunc.dl4"
Declare External Sub getportdefault,GetCostLevels,LogAccess
Declare External Function OpenFile,PDate$,FormatDate2$,getuidinfo$,JDate$
Declare External Function chkDteFrmt$,clrtxtc$,CHKBADCHARS
!
External Lib "libedittrack.lib"
Declare External Sub MakeEdittrack
!
External lib "libshipldisplay.lib"
Declare External Sub GetCustShipL
!
External Lib "getcredcdd.lib"
Declare External Function Getcredcdd$
!
External Lib "gettaxcdd.lib"
Declare External Function GetTaxCdd$
External Lib "getartermd.lib"
Declare External Function GetArTermd$
External Lib "getslsmname.lib"
Declare External Function GetSlsmname$
External Lib "getordtypd.lib"
Declare External Function Getordtypd$
External Lib "ubscredck.dl4"
Declare External Sub GetCredCk
External Lib "getcusttaxtyd.lib"
Declare External Function Getcusttaxtyd$

External Lib "ubsprconv.dl4"     
Declare External Function XUnit$
External Lib "libprodconv.lib"          
Declare External Function ConvProdAmount

External Lib "libimaging.lib"
Declare External Sub GetImage

Declare Intrinsic Sub DateToJulian,JulianToDate,VerifyDate,CheckNumber,Time
Declare Intrinsic sub programdump,sortinstring,FindF
Declare Intrinsic function findchannel
!
!
Declare sub OpenFiles,GetLists
Declare Sub VerifyCustomer,ShipInfo
Declare Sub getheader,MainCust
Declare Sub OrdHLabel,SavHdr,DoZone
Declare Sub Ordlist,OTypeProcess
Declare Sub OrdWhDroplist,OrdTypelist
Declare Sub CalcShipDate,OTMSDTIN
Declare Sub FindShiplist,edttrk
Declare Sub OrdHCreditCheck,gethold
Declare Sub CalcFreightCharge,savhold
Declare Sub CalcDeliveryCharge,DelvyChg,verifystat
Declare Sub DeleteOrd,Creditchk,OnHoldChk
Declare Sub Gettotals,SavTotals
Declare Sub CheckImages,SlsmComm
Declare Sub DiffOT,SavOTData,fut208
Declare Sub GetMessg,SavMessg,lp1chk
Declare Sub AddQteLP,CustQuote,CQSrch
Declare Sub showmillitems,CHKREBILLORDER,CurrConvUP,CurrConvDown

Declare Function chkDateFrmt$,getnteflgs$,getmillitmflag$
!--------------------------------------------------------------------
!
!
! ** main procedure
!
!
OPTION GOSUB NESTING 12  ! Default is 8
try
	Option String Redim is legal ! in case subs dim/use same names
  !
  dim 1%,cnvcu[10],3%,cnvca[10],keycurr$[10],1%,ch_curr,3%,rec_curr,currfact
  dim 1%,ch_curr,3%,rec_curr,Currkey$[10],3%,amount
  dim 3%,dsp_totordamt,currfact
  dim e$[500],buttonlist$[5,50],nextlist$[5,100] ! error handling variables
  dim bsdel$[20],esdel$[20],rdel$[20],fdel$[20],rstr$[3000]
  dim Section$[30],Field$[10,30],miflag$[5]
  dim mergedir$[60],action$[20],action1$[20],options$[20],Action2$[20]
  dim Company$[2],UserID$[8],keycust$[60],keyroh$[60],keyrom$[60]
  dim xdate$[10],keyship$[60],shipkey$[60],keyrol$[60],keyslsm$[40]
  dim rohkey3$[60],holddesc$[12,16],holdpswd$[12,16],holdcodeflag[12]
  dim msglist$[200],statword$[200]
  let msglist$=" ",msglist$ ! ONLY 200 & 800 Message types!
  !let msglist$[1,16]=   "Invoice        "
  let msglist$[33,48]=  "Quote          " ! 2
  !let msglist$[65,80]=  "Invoice/Order  " ! 4 
  !let msglist$[97,112]= "Bill of Lading " ! 6
  let msglist$[129,144]="Internal       " ! 8 
  LET STATWORD$="ENTERED   PRINTED   REGISTEREDORD CREATE"
  
  ! dim for order totals
  dim 1%,ch[99],dclvl,mctxbl[9],2%,s9[9],t1[1],mcode[9],3%,h1,v1,r5,param[20],t2[25],mcharge[9,1],tot[4],cfin[8]
  dim 1%,editstatus,gencm,newxfer,cost_lev[4]
  dim 1%,ua5[10],x1[9],TCB,dispcomm$[1],SCType
  dim 1%,ordedit,nolines,ch[99],ot[38]
  dim 1%,tmp1,intCo,intSls,CTLC,errflag,WH,Div,portnum,chan[25],flag
  dim 2%,tmp2,maxcnt \ maxcnt=100 ! max records in arrays
  dim 3%,tmp3,JDepositDate,DocNo,rec_uac
  dim 2%,custid,custid$[6],shipcustid,shipcustid$[6],shipcode$[6],shipcode
  dim 2%,orderid,orderid$[6],billcustid,billcustid$[6],ordnum
  dim 3%,ordamt,OrderAmt$[20],arbal,openordamt,CURTIM[10]
  dim 2%,conswh,maxwh,currdate,scandate,canday,X2[9],CustSec[1]
  dim 2%,taxcode,taxtype,delchglvl,salesarea,source
  dim 3%,tmprec[10],EX[18],linetax,rec_rol,invnum,3%,X3[9]
  dim 4%,tmp4
  dim taxcoded$[20],custtaxtyped$[16],x$[100]
  dim tmppo$[20],chkpo$[20],3%,rec_tmp
  dim credcoded$[16],clsdpswd$[8],ordtyped$[20],WORK$[600]
  dim whlist$[100,100],etlist$[100,100],atlist$[100,100],divlist$[100,100]
  dim srclist$[100,100],slsmlist$[100,100],deptlist$[100,100],zonelist$[100,100]
  dim ordtypelist$[100,100],routinglist$[100,100],shiptermlist$[100,100],shiptyped$[16],tmpkey$[50],zndsc$[10]
  Dim CMTypeList$[100,100]
  dim custid$[6],orderno$[6],billtoid$[6],userid$[8]
  dim p60$[50],p61$[256],P9$[50],UCF$[10]
  dim List$[maxcnt,1000],sdate$[50],Msg$[200]
  dim SList$[maxcnt,800] ! for .net selector(drop down) list
  dim logfname$[50],Custom_customer$[30]
  dim CustNo$[6],SearKey$[64],BegKey$[64],mode$[3],UA2$[50]
  dim Desc$[50],PayFlag$[1],RecType$[1],DocNo$[10],ARInvKey$[64],InvType$[3]
  dim tmp$[400],tmp1$[400],WebStr$[2000],Message$[200],artermd$[16],slsmname$[30],overpswd$[30]
  dim blank$[200] \ blank$=" ",blank$
  dim M3$[3] \ M3$="###"
  dim M6$[6] \ M6$="######"
  dim M10$[10] \ M10$="##########"
  dim 3%
  let tmp$=tim(4) using "&&&&&&"
  let work$=tmp$[5,6],tmp$[1,2],tmp$[3,4]
  let currdate=work$
 
  !!! define structures !!! 
  dim Cust. as cust ! customer
  dim billto. as cust ! bill to customer
  dim AR. as saract ! a/r file
  dim roh. as qoh ! order header ! keep roh name but is qoh (less replacing)
  dim ros. as qos ! order ship to file
  dim rot. as qot ! order total file
  dim rom. as qom ! order message file
  dim rol. as qol ! order lines
  dim dept. as deptfle ! dept file
  dim wh. as whinfo ! warehouse file
  dim et. as entdby ! entered by file
  dim zn. as zonefle ! zone file
  dim os. as sorce ! order source file
  dim div. as divifle ! division file
  dim Sslsm. as sslsm ! salesman file
  dim Term. as artermcode ! a/r term codes
  dim prt. as prtdefault ! port defaults
  dim sh. as shiplist ! shiplist file
  dim cnotes. as custnotes ! customer note file
  dim misc. as miscchrg ! misc charges
  dim tax. as taxcode ! tax code file
  dim ctax. as custtax ! customer tax type file
  ! dim roc. as sordcash ! sale order cash file NO CASH ON QUOTES!
  dim vend. as a80vm ! vendor file
  Dim ETR. as edittrack ! EDITTRACKING
  ! for currency exchange
  dim curr. as currency

  Def FNR(H) = Int(Abs(H) * 100 + .5) * .01 * Sgn(H)
  Def FNS(H) = Int(Abs(H) * 100) * .01 * Sgn(H) ! rounding to nearest penny
  !
  call dxopen()

  call GetSession(e$,CTLC,options$,action$,UserID$,intCo,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$,action1$,action2$)
  call LogAccess(e$)
  call GetPortDefault(e$,IntCO,UserID$,portnum,rec_uac,prt.) ! get port default
  Call GetCostLevels(e$,cost_lev[],IntCo,Userid$)
  !call dxget("u_custom_customer", custom_customer$)
  mat read #ctlc,60,50;p60$; ! system flag variable
  mat read #ctlc,61,0;p61$;
  ! let p61$[136,136]="N" ! turn off multicurrency
  mat read #ctlc,19,50;p9$;
  read #ctlc,60,0;canday; ! cancel days
  read #ctlc,60,16;conswh;
  mat read #ctlc,115,60;custom_customer$;
  custom_customer$=UCase$(rtrim$(custom_customer$))
  SCType = 0
  ! split commissions by category take priority and do not play
  ! nice with the other types
  if p9$[21,21] <> "Y"
	let SCType=p61$[72,72] \ if p61$[72,72] = "Y" SCType=1
  end if
  !Call dxsave(0,"/tmp/rob.txt!")
  ! We use action1$ or 2$ to determine what we working on: none=ORDERS, CREDIT=credits, INVOICE=invoice
  Action$=UCase$(RTrim$(action$)) ! uppercase & trim
  Action1$=UCase$(RTrim$(action1$)) ! uc & trim
  Action2$=UCase$(RTrim$(action2$))
  Credit=0;Invoice=0 ! NO CREDITS/INVOICES - JUST QUOTES!
  ! set up programmed ot list 
  !ot[1]=1;ot[2]=1;ot[3]=1;ot[6]=1;ot[9]=1;ot[10]=1;ot[12]=1
  !ot[15]=1;ot[5]=1;ot[11]=1;ot[24]=1
  ot[1]=1;ot[2]=1;ot[3]=1;ot[4]=1;ot[5]=1;ot[6]=1;ot[7]=1;ot[8]=1;ot[9]=1;ot[10]=1
  ot[11]=1;ot[12]=1;ot[13]=0;ot[14]=1;ot[15]=1;ot[16]=1;ot[17]=1;ot[18]=1;ot[19]=0
  ot[20]=1;ot[21]=1;ot[22]=1;ot[23]=1;OT[24]=1
  ot[16]=0;OT[19]=0;OT[20]=0 ! ;ot[21]=0;ot[22]=0  ! OT's NOT ON QUOTES!
  for x=25 to 34 \ let ot[x]=1 \ next x ! per dd ot 25-34 same as ot[1]
  if p60$[25,25]<>"Y" let ot[21]=0;ot[22]=0
  ot[36]=0;ot[37]=0 ! evap Quotes - let's not
  ot[38]=0 ! custom
  ! ot: 14,17,18,23 are active and treated as ot[1] even though not labelled on std/native
  ! as of 06/20: not active are ot 13 and 35+
  CALL dxget("SOURCE",tmp$)
  source=tmp$ ! s/b program #
  ch_usrctl=findchannel()
	Ropen #CH_USRCTL,"cntrl/usercntrl"
	Try
		MAT READ #CH_USRCTL,REC_UAC,386;UA5;
		mat read #ch_usrctl,rec_uac,336;UA2$;
	Else
		clear ua5[]
		UA2$=" ",Ua2$
	End try
	Try Close #ch_usrctl Else Rem
  ! calc cancel date
  if canday<0 let canday=0
  if canday>999 let canday=0
  x2=Tim(6)+canday ! today + uddays
  tmp$=X2 Using "#####"
  call juliantodate(1,tmp$,X$,E)
  let tmp$=x$[7,8]+x$[1,2]+x$[4,5] ! mm/dd/yy to yymmdd
  scandate=tmp$
  call OpenFiles()

  !
  select case action$

  case "DROPLIST" !   send droplists 
    Call GetLists()
	! done
	Goto SQdone ! no status sent
  CASE "ORDHLABEL" ! send labels/flags						doc=QTH-OrdHLabel.doc
	call ordhlabel()
	Goto SQdone ! no status sent
  CASE "ORDHOPEN" ! send cust data							doc=QTH-OrdHOpen.doc
	Call MainCust()
	! done
	
  Case "GETSHIPLIST" ! is an internal sub
	
	Call GetCustShipL(e$,List$[],SList$[],maxcnt,intCo,ReturnStatus,Message$)
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string

  case "GETSHIPINFO"  !										doc=QTH-GetShipInfo.doc
	Call shipinfo()
	! done
  case "SUBMITORDHDR" ! submit header plus ot 9 & 15		doc=QTH-SubmitOrdHdr.doc
	Call Savhdr()
	! done
  case "CREDITCHK" !										doc=QTH-CreditChk.doc
	! This call will check credit limits and past due a/r balances
	call creditchk()
	! done
  case "GETORDERHDR" ! plus ot9 & 15						doc=QTH-GetOrderHdr.doc
	! get the order data
	Call GetHeader()
	! done
  case "GETZONEINFO" !										doc=QTH-GetZoneInfo.doc
	Call DoZone()
	! done
	
  case "SUBMITORDMSG" !										doc=QTH-SubmitOrdMsg.doc
	Call SavMessg()
	! done
	
  case "GETORDMSG" !										doc=QTH-GetOrdMsg.doc
	Call GetMessg()
	! done
  case  "GETORDHOLD" ! NO HOLDS ON QUOTES!
	Call GetHold()
	! done
  case "SUBMITORDHOLD" ! ISN'T HOLD ON QUOTE!
	Call SavHold()
	! done
  case "GETORDTOT" !										doc=QTH-GetOrdtot.doc
	Call GetTotals()
	! done
	
  Case "GETSLSMCOMM"! get saleman commission NOT ON QUOTES
	Call SlsmComm()
	! done

  Case "GETFREIGHTCHARGE" !									doc=QTH-getfreightcharge.doc
	let returnstatus=1
	let message$="OK"
	call dxget ("custid",Custid$)
	call dxget ("orderid",orderid$)
	let custid=custid$
	let orderid=orderid$
	LET returnstatus=1
	let message$="OK"
	keyroh$=" ",keyroh$
	keyroh$[1,7]=custid using "#######" 
	keyroh$[8,13]=orderid using "######"
	KEYROH$[14]="" ! no space
	mode$="=" ! search mode 2
	dir=2
	clear chan[]
	clear roh.
	clear rot.
	CHAN[0]=CH_ROH
	CHAN[1]=CH_ROS
	CHAN[2]=CH_ROT
	Rec_roh=filegetqohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
	if rec_roh<0
		let returnstatus=0
		let message$="Quote Number ",keyroh$[8,13]," Not On File"
	endif
	if returnstatus
		call calcfreightcharge()
	endif
	List$[0]=bsdel$,"CalcFreight",fdel$
	WebStr$="FreightChrg",fdel$
	WebStr$=webstr$,"FreightCost",fdel$
	let list$[1]=webstr$
	Let amount=rot.frgtchrg
	If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$= Rtrim$(amount Using "----------.##") + fdel$ !rot.frgtchrg
	Let amount=rot.frgtcost
	If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$+ Rtrim$(rot.frgtcost Using "----------.##") + fdel$ ! rot.frgtcost
	LIST$[2]=Webstr$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
  Case "GETDELIVERYCHARGE" !								doc=QTH-GetDeliveryCharge.doc
	Call DelvyChg()
	! done

  Case "SUBMITORDTOT" !										doc=QTH-SubmitOrdTot.doc
	Call SavTotals()
	! done
  case "DELETEORD" ! delete order/invoice					doc=QTH-DeleteOrd.doc
	Call DELETEORD()
	
	! end Deleteord

  case "GETCUSTDFLT" ! ! CUSTOMER/Order Get and OUT???
	call dxget ("custid",CustId$)
	call dxget ("orderno",OrderNo$)
	! then sends web status?
  case "GETCUSTOMER" ! create customer selected
	
	  call dxget ("custid",SearKey$)
	  SearKey$=ucase$(SearKey$)
	
	  isnumber=1 ! 1 = numeric   0 = alpha
	  Try call CheckNumber(SearKey$) else isnumber=0
	    
	  if action1$="VERIFYCUSTOMER" call VerifyCustomer() 
	  call SetOutput(e$,rstr$)
	  Goto SQdone ! no status sent
  Case "GETOTFLDS" ! send OT data not sent in header			doc=QTH-GetOTFlds.doc
	Call DiffOT()
	! done
	
  Case "SUBMITOTFLDS" ! update ot 9,16,4,15,24 (if done as separate window/call)
	Call SavOTData()
	! done
  Case "CUSTQUOTE" ! multiple custs for quote - see routine for docs
	! with multiple selections / actions
	Call CUSTQUOTE()
	! done
  Case "QUOTE117" ! add last price (from totals scrn)			doc=QTH-SubmitQuote117.doc
	Call ADDQTELP()
	! done
  CASE "CREATEMIPO"  ! call to create PO's for Mill items on the order
	returnstatus=0
	message$="Can not create PO from a quote"
  Case "GETTOTORD"
  ! for cc on Mid-Atlantic - need ordered totals - not shipped
	Dim 3%,OOTOT
	call dxget ("CUSTID",Custid$)
	call dxget ("ORDERID",orderid$)
	let custid=custid$
	let orderid=orderid$
	!call dxget ("SOURCE",tmp$)
	!let source=tmp$
	LET returnstatus=1
	let message$="OK"
	keyroh$=" ",keyroh$
	keyroh$[1,7]=custid using "#######" 
	keyroh$[8,13]=orderid using "######"
	KEYROH$[14]="" ! no space
	mode$="=" ! search mode 2
	dir=2
	clear chan[]
	CHAN[0]=CH_ROH
	CHAN[1]=CH_ROS
	CHAN[2]=CH_ROT
	Rec_roh=filegetqohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
	if rec_roh<0
		let returnstatus=99
		let message$="Quote Number ",keyroh$[7,12]," Not On File"
		goto GTOTDone
	endif
	!call programdump("/tmp/ordh2!","")
	! T2[0] = T2[1] - T2[3] + T2[4] + T2[5] + T2[6] + T2[7]
	Clear List$[]
	List$[0]=bsdel$,"TOTORDERED",fdel$
	List$[1]="ORDERTOTO",fdel$ ! that's all we need? !,"
	OOTOT=rot.MdseOrdAmt-rot.OrdDisc+rot.MiscChrg+rot.FrgtChrg+rot.OthChrg+rot.TaxAmt
	list$[2]=Str$(OOTOT),fdel$
	List$[3]=esdel$
	call AddToStr(e$,rstr$,List$[])

	GTOTDONE:  !finished
	
  ! End of qty ord totals
  Case "CHKREBILLORDER"
  ! not used on quotes? orders chk Inv history!
  returnstatus=1;message$="OK"
  ! end of it

end select
    !
  ! status section on all cases except as goto SQDone
  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
  call AddToStr(e$,rstr$,WebStr$)
	! done with it
  call SetOutPut(e$,rstr$)
  SQDone: ! done - bypass status
  ! call dxclose()
else
  include "src/callmainerrnet.inc"
  ! call dxclose()
end try
end
 
!--------------------------------------------------------------------
sub OpenFiles()
  
  ! Open files for order entry
  
  Try
    !
   
    Ch_Cust = OpenFile(1808,intCo) \ If Ch_Cust = -1 Error 42  ! customer
    Ch_Ar = OpenFile(-1504,intCo) \ If Ch_Ar = -1 Error 42  ! a/r invoice
    Ch_Terms = OpenFile(-9981,intCo) \ If Ch_Terms = -1 Error 42  ! a/r term codes
    Ch_Misc = OpenFile(-2032,intCo) \ If ch_misc = -1 Error 42  !misc charge 
    Ch_Ship = OpenFile(-2112,intCo) \ If Ch_Ship = -1 Error 42  !shiplist
    Ch_Zone = OpenFile(-1920,intCo) \ If Ch_Zone = -1 Error 42  !zone file              
    Ch_CSZ = openfile(-9997,intCo) \ If  Ch_CSZ  = -1 Error 42 !"cust/ship zone file  
    Ch_Prod = OpenFile(1792,intCo) \ If Ch_Prod = -1 Error 42  !product file 
    Ch_PrWh = OpenFile(1744,intCo) \ If Ch_PrWh = -1 Error 42  !"product warehouse file
    Ch_Wh = OpenFile(-2768,intCo) \ If Ch_Wh = -1 Error 42  !" warehouse file
    Ch_Ccode = OpenFile(-1728,intCo) \ If Ch_Ccode = -1 Error 42  !u/m codes file   
    Ch_Dept = openfile(-1632,intCo) \ If Ch_Dept = -1 Error 42   !dept file 
    Ch_Roh = openfile(1280,intCo) \ If Ch_Roh = -1 Error 42     !"order header file
    Ch_RoL = openfile(1344,intCo) \ If Ch_Rol = -1 Error 42     !"order lines file
    Ch_Ros = openfile(1392,intCo) \ If Ch_Ros = -1 Error 42     !"order shipto file
    Ch_Rot = openfile(2656,intCo) \ If Ch_Rot = -1 Error 42     !"order total file
    Ch_Rom = openfile(2672,intCo) \ If Ch_Rom = -1 Error 42     !"order message file
    Ch_Tax = openfile(-2176,intCo) \ If Ch_Tax = -1 Error 42   !"tax code file
    Ch_Ctax = openfile(-928,intCo) \ If Ch_Ctax = -1 Error 42    !"cust tax type file
    Ch_sslsm= OpenFile(-1824,intCo) \ If Ch_sslsm = -1 Error 42 !salesman 
    Ch_lstpr=OpenFile(1376,intCo) \ If Ch_lstpr = -1 Error 42 !LAST PRICE
    Ch_slstpr=OpenFile(9982,intCo) \ If Ch_slstpr = -1 Error 42 !SHIP TO LAST PRICE
    Ch_Et=OpenFile(-1664,intCo) \ If Ch_et = -1 Error 42 !ENTERBY
    Ch_Div=OpenFile(-688,intCo) \ If Ch_div = -1 Error 42 !DIVISION 
    Ch_Src=OpenFile(-1216,intCo) \ If Ch_src = -1 Error 42 !order source
    Ch_Cnotes=OpenFile(-720,intCo) \ If Ch_cnotes = -1 Error 42 !order source
    ch_comcde=OpenFile(-2288,intCo) \ If Ch_comcde = -1 Error 42 !commodity code
    ch_sproddesc=OpenFile(1424,intCo) \ If Ch_sproddesc = -1 Error 42 ! nonstock product
    ch_sprodlot=OpenFile(2528,intCo) \ If Ch_sprodlot = -1 Error 42 !sprodlot file
    ch_sordlot=OpenFile(2320,intCo) \ If Ch_sordlot = -1 Error 42 !sordlot file
	If p61$[136,136]="Y"
		ch_curr=OpenFile(-9712,IntCo) \ if ch_curr = -1 Error 42 
	endif

    !
  else
    include "src/callsuberr.inc"
  end try
end sub ! openfiles
! 
!--------------------------------------------------------------------
Sub MainCust()
! main customer data
  Try
	call dxget ("custid",CustId$)
	let custid=custid$
	
	! section 1 -- shiplist - should be after cust check - but front end wants it here!
	!let shipcustid$=custid$
	! call dxset ("shipcustid",shipCustId$)
	Call GetCustShipL(e$,List$[],SList$[],maxcnt,intCo,ReturnStatus,Message$)
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	! call AddToStr(e$,rstr$,esdel$) ! end of section already in list
	ctlc = OpenFile(9999,intCo) \ If ctlc = -1 Error 42 !control   ! openning with read/write

	! section 2 - bill to name
	
	SearKey$=custid using M6$
	mode$="="
	dirno=1
	if custid>0
		CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,SearKey$,cust.)
	else
		custrec=-1
	Endif
	if CustRec>=0 ! record found
		Custsec[0]=custid;custsec[1]=1 ! id & NO ALERT
		call "custsec.dl4",Custsec[],ctlc,userid$,e$,rstr$
		if custsec[0]=-1 ! not allowed
			returnstatus=0
			message$="You do not have access this customer"
			goto MCDone
		Endif
		! task 51372 - POS ONLY CUSTOMER CHECK
		if custom_customer$ <> "REUTHER" ! Reuther wants to enter quote, but stop from order convert
			if cust.PrepaidMin=1 ! yes it has wrong label but it's a Y
				returnstatus=0
				message$="This customer is Point of Sale Only"
				goto MCDone
			Endif
		end if
		let tmp3=custid
		if cust.customerbillto<>0 and cust.customerbillto<>custid
			let keycust$=" ",keycust$
			let keycust$[1,6]=cust.customerbillto using "######"
			search #ch_cust,2,1;keycust$,rec_cust,e
			if e
				let returnstatus=0
				Message$="Bill To Customer "+keycust$+" Not On File"
				Goto MCDone
			endif
			read record #ch_cust,rec_cust;billto.;
		else
			let billto. = cust.
		endif
	else
		let returnstatus=0
		Message$="Customer "+SearKey$+" Not On File"
		goto MCDone
	endif
	
	clear list$[]
	
	List$[0]=bsdel$,"Billing Customer",fdel$
	WebStr$="BILLTOID",fdel$,"Name",fdel$
	WebStr$=WebStr$,"Addr1",fdel$,"Addr2",fdel$
	WebStr$=WebStr$,"City",fdel$,"State",fdel$,"ZipCode",fdel$
	WebStr$=WebStr$,"Country",fdel$,"SNOTES",fdel$,"WNOTES",fdel$
    List$[1]=WebStr$
	if custrec>0
		webstr$=str$(billto.CustomerCode)+fdel$		! custcode
		webstr$=webstr$+rtrim$(billto.Name$)+fdel$		! custname
		webstr$=webstr$+rtrim$(billto.Addr1$)+fdel$		! add1
		webstr$=webstr$+rtrim$(billto.Addr2$)+fdel$		! add2
		webstr$=webstr$+rtrim$(billto.City$)+fdel$		! city
		webstr$=webstr$+rtrim$(billto.State$)+fdel$		! state
		webstr$=webstr$+rtrim$(billto.Zip4$)+fdel$	! zipcode
		webstr$=webstr$+RTrim$(billto.Country$)+fdel$		! country
		webstr$=getnteflgs$(webstr$) ! suppt & win notes
		let list$[2]=webstr$
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! section 3 - open order list
	call ordlist ()
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! section 4 - account closed
	clear list$[]
	List$[0]=bsdel$,"CLOSED ACCOUNT",fdel$
	WebStr$="Closed",fdel$,"Password",fdel$
	List$[1]=WebStr$
	If cust.CreditCode>0 and cust.CreditCode<=16
		let credcoded$=getcredcdd$(ctlc,cust.CreditCode,intco)
		read #ctlc,182,44;clsdpswd$;
		tmp$="0" ! closed = no
		if credcoded$[1,1]="*" let tmp$="1" ! closed - yes
		if clsdpswd$="" 
			let tmp$="0" ! no password -- no closed
		endif
	
		if clsdpswd$[1,8]="        "
			let tmp$="0"
		endif
		if tmp$="0"
			let clsdpswd$=" ",clsdpswd$
		endif
		webstr$=tmp$+fdel$  ! closed account flag
		webstr$=webstr$+rtrim$(clsdpswd$)+fdel$ ! closed account password	
		let list$[2]=webstr$
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	MCDone: ! finished
	! section 5 - status/error section
  else
    include "src/callsuberr.inc"
  end try
end sub ! MainCust
! 
!--------------------------------------------------------------------
Sub SavHdr()
! submit & save header
 Try
	Close #CTLC ! close read only (only routine to write control - new quote #)
	ctlc = OpenFile(9999,intCo) \ If ctlc = -1 Error 42 !control   ! openning with read/write
	call dxget ("custid",Custid$)
	let custid=custid$
	call dxget ("orderid",orderid$)
	let orderid=orderid$
	call dxget ("shipcustid",shipcustid$)
	let shipcustid=shipcustid$
	call dxget ("billcustid",BillCustId$)
	let billcustid=billcustid$
	!call dxget ("shipcode",shipcode$)
	!let shipcode=shipcode$
	 Call DXGet("SOURCE",TMP$)  
	 source = TMP$   \ if credit let source=0 ! source not used in action1$="CREDIT"           
	let returnstatus=1
	let message$="" ! null need to append with errors 
	! check if customer exists
	KeyCust$=custid using "######"
	mode$="="
	dirno=1
	if custid>0
		Rec_Cust=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
	Else
		rec_cust=-1
	Endif
	if rec_cust<=0
		let returnstatus=0
		Let message$=message$+"Customer is not on file. "
		goto endsubordhdr:
	endif
	if (cust.CommissionByCategory) let SCType = 0 ! force override
	if orderid<>0
		keyroh$=" ",keyroh$
		keyroh$[1,7]=custid using "#######" 
		keyroh$[8,13]=orderid using "######"
		KEYROH$[14]="" ! no space
		mode$="=" ! search mode 2
		dir=2
		clear chan[]
		CHAN[0]=CH_ROH
		CHAN[1]=CH_ROS
		CHAN[2]=CH_ROT
		Rec_roh=filegetqohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
		if rec_roh<0
			let returnstatus=0
			let message$=message$+"Quote Number "+str$(orderid)+" Not On File. "
			goto endsubordhdr:
		endif
		if returnstatus<>0
			call verifystat()
			if returnstatus=99 goto endsubordhdr:
		endif
		if roh.taxcode<1 or roh.taxcode>7999
			let roh.taxcode=cust.taxcode
		endif
		let taxcode=roh.taxcode
		let taxtype=ros.shiptaxtype
		let origslsm=roh.slsmnum! save the slsmnum
		let tmppo$=roh.custpo$ ! save the customer po #
		! save the po num 
		let neworderflag=0
	else
		let neworderflag=99
		clear roh.
		let roh.SpareNu$=Blank$[1,10] ! " ",roh.SpareNu$
		clear rot.
		clear ros.
		let tmppo$=" ",tmppo$
				If p61$[136,136]="Y"
				let keycust$=custid using "######"
				mode$="="
				dirno=1
				CNoteRec=FileGetCustNotes(e$,Ch_CNotes,mode$,dirno,KeyCust$,cnotes.)
				if cnoterec<=0
					clear cnotes.
				endif
				let roh.currid=cnotes.currid
				if p61$[136,136]="Y"  and roh.currid<>0		 
					let keycurr$=" ",keycurr$
					let keycurr$=roh.currid using "####"
					search #ch_curr,2,1;keycurr$,rec_curr,e
					if not(e)
						Read Record #ch_curr,rec_curr;curr.;
					else
						let curr.ExcRate=0
						let roh.currid=0
					endif
					let roh.currfact=curr.ExcRate			
				else
					let roh.currfact=0
				endif
			else
				let roh.currid=0
				let roh.currfact=0
			endif					
		! get an order #
	endif
	call dxget ("PO",tmp$)
	strgok=CHKBADCHARS(e$,tmp$)
	if not(strgok) ! 
		let returnstatus=0
		let message$="Invalid Characters in Customer PO"
		goto endsubordhdr
	Endif
	tmppo$=roh.custpo$ ! save orig po
	let roh.custpo$=tmp$+"                             "
	Goto BYPPOCHK ! Quotes - no po check!  mx281a & mx283a do not CHECK on native/R9!
	if cust.porequiredflag <>0 and cust.porequiredflag<>2 
		if rtrim$(roh.custpo$)=""
			let returnstatus=0
			let message$=message$+"Purchase Order is required by this Customer. "
			goto endsubordhdr:
		endif
		if rtrim$(roh.custpo$)="VERBAL"
			let returnstatus=0
			let message$=message$+"Purchase Order is required by this Customer. "
			goto endsubordhdr:
		endif
	endif
	if returnstatus<>0 and cust.porequiredflag>1 and UCase$(tmppo$[1,20])<>UCase$(roh.custpo$[1,20])
		    Dim filename$[50]
		Ch_tmproh=findchannel()
		read #ctlc,88,1280;filename$;
		filename$=rtrim$(filename$)
		ropen #ch_tmproh,filename$
		let keyroh$=" ",keyroh$
		let keyroh$[1,7]=custid using "#######"
		DO
			search #ch_tmproh,3,2;keyroh$,rec_tmp,e ! do not use rec_roh
			if e>0 exit do
			let tmp3=keyroh$[1,7]\if tmp3<>custid exit do
			let tmp3=keyroh$[8,13]
			if orderid<>tmp3
				mat read #ch_tmproh,rec_tmp,446;chkpo$;
				if UCase$(chkpo$[1,20])=UCase$(roh.custpo$[1,20])
					let returnstatus=0
					let message$=message$+"Purchase Order in used on Quote "+keyroh$[8,13]+". "
					try close #ch_tmproh else rem
					goto endsubordhdr:
					exit do
				endif
			endif
		loop
		try close #ch_tmproh else rem
		! NOW CHECK ORDERS TOO!
		Ch_tmproh=findchannel()
		read #ctlc,88,1840;filename$;
		filename$=rtrim$(filename$)
		ropen #ch_tmproh,filename$
		let keyroh$=" ",keyroh$
		let keyroh$[1,6]=custid using "######"
		DO
			search #ch_tmproh,3,2;keyroh$,rec_tmp,e ! do not use rec_roh
			if e>0 exit do
			let tmp3=keyroh$[1,6]\if tmp3<>custid exit do
			let tmp3=keyroh$[7,12]
			if orderid<>tmp3
				mat read #ch_tmproh,rec_tmp,446;chkpo$;
				if UCase$(chkpo$[1,20])=UCase$(roh.custpo$[1,20])
					let returnstatus=0
					let message$=message$+"Purchase Order in used on Order "+keyroh$[7,12]+". "
					try close #ch_tmproh else rem
					goto endsubordhdr:
					exit do
				endif
			endif
		loop
		try close #ch_tmproh else rem
	endif
	BYPPOCHK: ! no quote / po check - per TDest - until order created
	call dxget ("droplistzonefle",tmp$)
	let ros.zone$=tmp$+"  "
	let mode$="=" ! on submit - CHECK THE ZONE!!
	let dirno=1
	clear zn.
	ZoneRec=FileGetZonefle(e$,Ch_Zone,mode$,dirno,ros.zone$,zn.)
	if zonerec<=0
		let returnstatus=0
		let message$=message$+"Zone "+ros.zone$+" not found "
		goto endsubordhdr:
	endif
	call dxget ("droplistordwh",tmp$)
	let roh.wh=tmp$
		call dxget ("shipdate",tmp$)
	if tmp$<>"999999"
		xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
		roh.shipdate=xdate$[3,8]
	else
		let roh.shipdate=999999
	endif
		call dxget ("candate",tmp$)
		xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
		roh.CancelDate=xdate$[3,8]
	call dxget ("droplistsslsm",tmp$)
	let roh.slsmnum=tmp$
	let roh.slsm[0]=tmp$
		call dxget ("orderdate",tmp$) ! in mm/dd/yyyy
		xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
		let roh.orddate=xdate$[3,8]
	call dxget ("Attn",tmp$)
	strgok=CHKBADCHARS(e$,tmp$)
	if not(strgok) ! 
		let returnstatus=0
		let message$="Invalid Characters in Contact Name"
		goto endsubordhdr
	Endif
	let roh.contact$=tmp$+"                    " ! add spaces
	call dxget ("Truck",tmp$)
	let ros.truck=tmp$
	call dxget ("Stopnum",tmp$)
	let roh.stopnum=tmp$
	call dxget ("TaxCode",tmp$)
	let tmp3=tmp$
	if tmp3<1 or tmp3>7999
		let tmp3=roh.taxcode! save previous header tax code
	endif
	let roh.taxcode=tmp3
	if roh.taxcode<1 or roh.taxcode>7999
		let roh.taxcode=cust.taxcode
	endif
	call dxget ("TaxType",tmp$)
	let tmp3=tmp$
	if tmp3>0
		let ros.shiptaxtype=tmp3
	endif
	call dxget ("dclvl",tmp$)
	let rot.delivChrgLvl=tmp$
	call dxget ("salesarea",tmp$)
	let roh.salesarea=tmp$
	call dxget ("shipedit",tmp$)
	let ros.shipedit=tmp$
	if p61$[109,109]="Y" ! RUTHERFORD
		if ros.shipedit=5 ! manual edit
			let rot.delivchrglvl=0
		else
			!if ros.mastdelvcust<1 or ros.mastdelvcust>999999
			!	if p61$[109,109]="Y"
			!		if cust.mastdelvcust<1 or cust.mastdelvcust>999999
			!			let cust.mastdelvcust=cust.CustomerCode
			!		endif
			!		let ros.mastdelvcust=cust.MASTDELVCUST
			!		let ros.mastdelvship=0
			!		let rot.delivchrglvl=0 !
			!	endif
			!endif
		endif
	endif
	call dxget ("routinglist",tmp$)
	strgok=CHKBADCHARS(e$,tmp$)
	if not(strgok) ! 
		let returnstatus=0
		let message$="Invalid Characters in Routing Name"
		goto endsubordhdr
	Endif
	let roh.shipvia$=tmp$+"                          "
	call dxget ("droplistdeptfle",tmp$)
	let roh.dept=tmp$
		call dxget ("droplistartermcode",tmp$)
		let roh.terms=tmp$
	if not(Credit)	call dxget ("ShipTermList",tmp$)
	If Credit Call dxget("CMTypeList",tmp$)
	let roh.shiptype=tmp$
	call dxget ("droplistentdby",tmp$)
	let roh.entby=tmp$
	call dxget ("droplistordtype",tmp$)
	if not(neworderflag) let x2=roh.ordtype ELSE let x2=tmp$ ! retain old one!
	let roh.ordtype=tmp$;otchange=0
	If roh.ordtype<1 or roh.ordtype>38
		let returnstatus=0
		let message$="Invalid Order Type "
		goto endsubordhdr
	endif
	if not (ot[roh.ordtype])
		let returnstatus=0
		let message$="Order Type "+str$(roh.ordtype)+" Not Available At This Time"
		goto endsubordhdr:
	endif
	! process order type
	if x2<>roh.ordtype let otchange=x2 ! set to original otype
	! do for all - whether change or not
	Call OTypeProcess(flag,otchange) ! all checks (allowed, etc) done
	if flag goto endsubordhdr ! found a problem
	! comes back with ot 7,8,16 fields filled
	call dxget("droplistdivifle",tmp$)
	let roh.div=tmp$
	if roh.div<=0 or roh.div>99
			let returnstatus=0
			let message$=message$+"Invalid Division Submitted. "
			goto endsubordhdr:
	endif
	call dxget("droplistsorce",tmp$)
	let roh.source=tmp$
	call dxget ("shipkey",tmp$)
	let shipkey$=""
	let shipcode=0
	if rtrim$(tmp$)<>""
		let shipkey$=tmp$
		let tmp4=shipkey$
		if not (shipcustid) let shipcustid=int(shipkey$)
		let shipcode=int(fra(tmp4)*10^6)
	endif
	! let roh.custnum=custid
	let ros.shipcode=shipcode
	let ros.shipcust=shipcustid
	if not (ros.shipcust) let ros.shipcust=roh.custnum
	call dxget("ShipName",tmp$)
	strgok=CHKBADCHARS(e$,tmp$)
	if not(strgok) ! 
		let returnstatus=0
		let message$="Invalid Characters in Ship to Name"
		goto endsubordhdr
	Endif
	let ros.name$=tmp$+Blank$
	call dxget("ShipAddr1",tmp$)
	strgok=CHKBADCHARS(e$,tmp$)
	if not(strgok) ! 
		let returnstatus=0
		let message$="Invalid Characters in Ship to Addr 1"
		goto endsubordhdr
	Endif
	let ros.address$=tmp$+Blank$
	call dxget("ShipAddr2",tmp$)
	strgok=CHKBADCHARS(e$,tmp$)
	if not(strgok) ! 
		let returnstatus=0
		let message$="Invalid Characters in Ship to Addr 2"
		goto endsubordhdr
	Endif
	let ros.address2$=tmp$+Blank$      
	call dxget("ShipCity",tmp$)
	strgok=CHKBADCHARS(e$,tmp$)
	if not(strgok) ! 
		let returnstatus=0
		let message$="Invalid Characters in Ship to City"
		goto endsubordhdr
	Endif
	let ros.city$=tmp$+Blank$
	call dxget("ShipState",tmp$)
	strgok=CHKBADCHARS(e$,tmp$)
	if not(strgok) ! 
		let returnstatus=0
		let message$="Invalid Characters in Ship to State"
		goto endsubordhdr
	Endif
	let ros.state$=tmp$+Blank$
	call dxget("ShipZip",tmp$)
	let ros.zipcode$=tmp$+Blank$
	if len(tmp$)>5
		let ros.zip4$=tmp$[6]+Blank$
	else
		let ros.zip4$=" ",ros.zip4$
	endif
	call dxget("Country",tmp$)
	strgok=CHKBADCHARS(e$,tmp$)
	if not(strgok) ! 
		let returnstatus=0
		let message$="Invalid Characters in Ship to Country"
		goto endsubordhdr
	Endif
	let ros.country$=tmp$+Blank$
	! ot 16 variables
	! conswh gotten previously in call otypeprocess()
	If roh.ordtype=16 ! NO OT 16 on QUOTES!!
		newxfer=0
		call dxget("XFERAUTH",tmp$)
		if UCase$(RTrim$(tmp$))="Y"
			If roh.XFERAUTH=0 ! not previously authorized
				let newxfer=1
				let roh.XferAuth=1
				roh.AuthBy=rec_uac
				roh.AuthDate=CurrDate
			Endif
		Endif ! if "N" or previously auth - leave alone
	Else ! not ot 16 - clear auth fields (leave conswh for ot 7&8)
		newxfer=0
		roh.XferAuth=0
		roh.AuthBy=0
		roh.AuthDate=0
	Endif
	if roh.ordtype=9 ! get field							doc=QTH-SubmitOrdHdr9.doc
		call dxget("STAGINGAREA",tmp$)
		strgok=CHKBADCHARS(e$,tmp$)
		if not(strgok) ! 
			let returnstatus=0
			let message$="Invalid Characters in Staging Name"
			goto endsubordhdr
		Endif
		roh.WhStage$=tmp$+Blank$
	Else ! not ot 9 - clear field
		roh.WhStage$=blank$
	Endif
	if roh.ordtype=4 or roh.ordtype=15 or roh.ordtype=24 !  doc=QTH-SubmitOrdHdr15.doc
		! has ship term & (shipdatelist[] if shipterm=0
		CALL dxget("SHIPTERM",tmp$)
		x2=tmp$  ! options ###=every # days, -## = that day every month
		if x2<0 and x2<-31
			let returnstatus=0
			let message$=message$+"Ship on days Invalid"
			goto endsubordhdr:
		Endif
		ROH.ShipTerm=x2
		if roh.shipterm=0 ! means entered individual dates
			! call OTMSDTIN() ! get in / arrange s3[23] (SEPARATE CALL)
		Else
			Clear roh.shipdatelist[]
		Endif
	Else
		roh.shipterm=0
		Clear roh.shipdatelist[]
	Endif
	if roh.ordtype=5 ! future - add allocate stock date
		call dxget("ALCSTKDATE",tmp$) ! allow zero - sys date
		tmp1$=chkDateFrmt$(tmp$) ! chk/convert to mm/dd/yyyy
		if tmp1$[1,1]<"0" and tmp1$[1,1]>"9" let tmp1$=""
		x$=formatdate2$(tmp1$) ! from mm/dd/yyyy to yyyymmdd
		roh.CmInvHist=x$[3,8] ! H5[10] on native
		if roh.CmInvHist<101 or roh.CmInvHist>991231 let roh.CmInvHist=0
	Endif
	if returnstatus<>0 ! okay up to now
		! get commission splits from cust/shipto - for quotes
		! always reload every time they are saved as there is no
		! edit
		If SCType>0 ! "commission SPLITTING
			Let tmp$=custID Using "######";Flag=0! "custcode and mode=edit
			if ros.ShipEdit = 1 or ros.ShipEdit = 2
				Let tmp$=ros.ShipCust Using "######";tmp$[7,7]="."
				Let tmp$[8,13]=ros.ShipCode Using "&&&&&&"
			Endif
			Call "MXORDSLSM",tmp$,roh.,ch_Sslsm,Flag
			if roh.Slsm[0] <> roh.SlsmNum
				roh.SlsmNum = roh.Slsm[0]
			end if
		End if
		if orderid<>0
			if origslsm<>roh.slsmnum
				let rohkey3$=" ",rohkey3$
				let rohkey3$[1,3]=roh.slsmnum using "###"
				let rohkey3$[4,9]=orderid using "######"
				rohkey3$[11]="" ! cut at 10
				search #ch_roh,4,3;rohkey3$,rec_roh,e
				let rohkey3$[1,3]=origslsm using "###"
				rohkey3$[10]="" ! cut last space
				search #ch_roh,2,3;rohkey3$,rec_tmp,e ! look for no space first
				let rec_tmp=rec_roh
				search #ch_roh,5,3;rohkey3$,rec_tmp,e
				
			endif
			if ros.NU$="" Let ros.NU$=Blank$ ! NO Nulls!
			if roh.PriceType=0 let roh.PriceType=cust.PriceType
			write record #ch_roh,rec_roh;roh.;
			write record #ch_ros,roh.shiprec;ros.;
			write record #ch_rot,roh.totrec;rot.;
			if taxcode<>roh.taxcode or taxtype<>ros.shiptaxtype
				clear chan[]
				let chan[1]=ctlc
				let chan[2]=ch_prod !  2 = Product       1792
				let chan[3]=ch_cust !  3 = Customer      1808
				let chan[4]=ch_ros!  4 = order shipto  1856
				let chan[5]=ch_roh!  5 = order header  1840
				let chan[6]=ch_rot!  6 = order total   1872
				let chan[7]=ch_rol!  7 = order lines   1888
				let chan[8]=0     !  8 = product desc  2128(not opened)
				let chan[9]=ch_ctax!  9 = customer tax   928
				let chan[10]=ch_tax! 10 = tax code      2176
				let chan[11]=ch_ccode! 11 = ccodes        1728
				call "mxcalctax",chan[],rec_roh,intco
			endif
			!If not(credit) and source<>207 ! record header access
			  !If P60$[44,44]="Y" ! edittracking
				!clear etr.
				!if source let etr.ProdCode$=Str$(Source)+" ACCESS"+Blank$
				!If not(source) let etr.ProdCode$="HDR ACCESS"+Blank$
				!etr.EtAction=14
				!call edttrk()
			  !Endif
			!Endif
		else ! new order
			returnstatus=1
			unlock #ctlc
			Let NDisp=66 ! \ if credit let NDisp=58
			READ #ctlc,20,ndisp;ordnum ! ; ! LOCK IT!!
			! loop after reading - don't reread same # if fails!!
			DO
				LET ORDNUM=ORDNUM+1
				 IF ORDNUM>999998
					LET RETURNSTATUS=0
					LET MESSAGE$="Quote Number have exceeded 999999"
					unlock #ctlc
					goto endsubordhdr:
					exit do
				endif
				let flag=0
				LET keyroh$=" ",keyroh$ \ LET keyroh$[3,8]=ordnum USING "######"        
				FOR ctr=1 TO 99                                        
					LET keyroh$[1,2]=ctr USING "##"                           
					SEARCH #ch_roh,2,1;keyroh$,rec_tmp,E  
					if not(e) let flag=99
				next ctr
				if not (flag) 
					write #ctlc,20,ndisp;ordnum;
					let orderid=ordnum
					exit do
				endif
			loop
			unlock #ctlc
			IF returnstatus=1 ! is okay
				let roh.status=95
				call dxget ("billcustid",BillCustId$)
				let billcustid=billcustid$
				! if billcustid let roh.billto=billcustid else roh.billto=custid
				if billcustid>0 and billcustid<=999999
					let roh.billto=billcustid
				else
					if cust.customerbillto>0 and cust.customerbillto<=999999
						let roh.billto=cust.customerbillto
					else
						roh.billto=custid
					endif
				endif
				let roh.custnum=custid
				let roh.ordnum=orderid
				If Not(Credit)
					if roh.shipdate>0 and roh.shipdate<999999
						let roh.invdate=roh.shipdate
					endif
				Else
					If roh.InvNum<=0 let roh.InvNum=roh.ordnum
				Endif
				let roh.lockport=rec_uac ! this should be the user access record #
				let roh.dateent=currdate
				!Call Time(SDATE$) 
				! CURTM[0] = SDATE$[15,16]                               
				! CURTM[1] = SDATE$[18,19]                               
				! CURTM[2] = SDATE$[21,22]                               
				! CURTM[3] = CURTM[0] * 10000 + CURTM[1] * 100 + CURTM[2]
				
				!let roh.timeent=CURTM[0]+(CURTM[1]/100) ! CURTM[3] sb HH.MM
				
				Call Time(SDATE$) 
				CURTM[0] = SDATE$[15,16] 
				Let roh.timeent=curtm[0] 
				CURTM[1] =SDATE$[18,19]
				Let roh.timeent=roh.timeent+(curtm[1]/100) ! make same as order
				let roh.PriceType=cust.PriceType
				let roh.orgstatus=0 ! set to 0 - for hold credit check
				! ship to file ! 
				let ros.status=31 \ if credit let ros.status=32
				let ros.ordnum=orderid
				let rot.status=21 \ IF credit let rot.status=22
				let rot.ordnum=orderid
				clear chan[]
				CHAN[0]=CH_ROH
				CHAN[1]=CH_ROS
				CHAN[2]=CH_ROT
				clear tmprec[]

				mode$="a"
				! Write the file
				roh.Blankforkey$=blank$
				ros.NU$=Blank$
				roh.SpareNu$=blank$[1,10]
				let upstatus=fileupdateqohz(e$,chan[],mode$,tmprec[],roh.,ros.,rot.)
				let rec_roh=tmprec[0]
				let rec_ros=tmprec[1]
				let rec_rot=tmprec[2]
			endif
		endif ! ! order id
		! if OTChange - add code to do ot conversion
		! If not(credit) ! otchange=orig otype if diff from new otype (credits no onorder update!)
		  if otchange or newxfer ! changed or authorized a whse xfer
			clear chan[]
			clear tmprec[]
			chan[1]=ctlc
			chan[2]=ch_prod
			chan[3]=ch_prwh
			chan[4]=ch_cust
			chan[5]=ch_rol
			chan[6]=ch_roh
			tmprec[5]=rec_cust
			tmprec[8]=rec_roh
			call "mx283cnv5.dl4",tmprec[],otchange,chan[],IntCo
			! all it does is change prod/prodwhse update stock flags 
		  Endif
		! Endif ! CREDITS DO CHANGE STOCK UPDATE FLAG
	endif ! returnstatus=ok!
	endsubordhdr: ! end getting data for submit ord header
	clear list$[]
	List$[0]=bsdel$,"OrderSubmit",fdel$
	WebStr$="OrderId",fdel$
	! Webstr$=webstr$,"InvoiceId",fdel$
	Webstr$=webstr$,"",fdel$
	webstr$=webstr$,"ORDERAMT",fdel$
	webstr$=webstr$,"ORDERCOST",fdel$
	List$[1]=WebStr$
	WebStr$=str$(orderid),fdel$
	! Webstr$=webstr$,str$(roh.invnum),fdel$
	Webstr$=webstr$,"",fdel$
	webstr$=webstr$,str$(rot.mdseordamt),fdel$
	webstr$=webstr$,str$(rot.totordcost),fdel$
	LIST$[2]=Webstr$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
   else
    include "src/callsuberr.inc"
  end try
end sub ! savhdr
! 
!--------------------------------------------------------------------
Sub GetHeader()
! get header data & send
 Try
	
	Dim 2%,invdate, D4SHIP, D4ROUTING
 
	Dim 3%
	call dxget ("custid",Custid$)
	call dxget ("orderid",orderid$)
	call dxget ("shipcustid",shipcustid$)
	!call dxget ("shipcode",shipcode$)
	call dxget ("editstatus",tmp$)
	let editstatus=tmp$
	call dxget ("Source",tmp$)
	let Source=tmp$
	if credit let source=0;editstatus=0 ! not used as source# in credits & editstatus n/a & n/g
	call dxget ("shipkey",tmp$)
	let shipkey$=""
	if rtrim$(tmp$)
		let tmp4=tmp$
		if not(shipcustid) let shipcustid=int(tmp4)
		let shipcode=int(fra(tmp4)*10^6)
		let shipkey$[1,6]=shipcustid using "######"
		let shipkey$[7,7]="."
		let shipkey$[8,13]=shipcode using "&&&&&&"
		shipkey$[14]=""
	endif
	let custid=custid$
	let orderid=orderid$
	
	LET returnstatus=1
	let message$="OK"
	clear roh.
	let roh.SpareNu$=Blank$[1,10] ! " ",roh.SpareNu$
	clear rot.
	clear ros.
	let linesexist=0
	let ordwh=0
	let ordtype=0
	if source=286 and orderid=0
		returnstatus=0
		message$="Quote ID is missing"
		goto endgetordhdr
	Endif
	if not (orderid) ! new order 
		let shipcustid=shipcustid$
		let shipcode=0 ! shipcode$
		if rtrim$(shipkey$)<>""
			let shipcustid=shipkey$[1,6]
			let shipcode=shipkey$[8,13]
			roh.orddate = CurrDate   ! task 32992
		endif
		roh.custnum=custid
		roh.ordnum=0
		ros.shipedit=0
		if not (shipcustid)
			let shipcustid=custid
			let shipcode=0
			let ros.shipedit=0
		endif
		let ros.shipcust=shipcustid
		let keycust$=custid using "######"
		let mode$="="
		let dirno=1
		if custid>0
		CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
		else
			custrec=-1
		Endif
		if custrec<=0
			let returnstatus=0
			if editstatus<>0 let returnstatus=99
			let message$="Customer "+str$(custid)+" Not on File"
			goto endgetordhdr: 
		else ! customer is on file
			IF credit ! check for whse xfer customer
				if cust.ConsignWh>0 and cust.ConsignWh<consWh
					let returnstatus=0
					if editstatus<>0 let returnstatus=99
					let message$="Customer "+str$(custid)+" Not on valid for Credit"
					goto endgetordhdr: 
				Endif
			Endif
			clear sh.
		    call findshiplist()
			if sh.ddiv>0 and sh.ddiv<100
				let roh.div=sh.ddiv
			else
				if prt.div>0
					let roh.div=prt.div ! port default priority
				else
					if cust.division>0
						let roh.div=cust.division 
					endif
				endif
			endif
			if roh.div<=0 let roh.div=1
			if shiprec<=0 ! shiprec not found default
				let ros.shipedit=0 ! used the bill to
				let ros.shipcode=shipcode
				let ros.name$=cust.name$
				let ros.address$=cust.addr1$
				let ros.address2$=cust.addr2$
				let ros.city$=cust.city$
				let ros.state$=cust.state$
				let ros.zipcode$=cust.zip4$[1,6]
				let ros.zip4$=cust.zip4$[7,10]
				let ros.country$=cust.country$
				LET ros.truck=0
				let ros.zone$=" ",ros.zone$
				let roh.shipvia$="OUR TRUCK"
				if p61$[34,34]="Y" ! multi-zone customer
					if not (shipcustid) let shipcustid=custid
					if not (roh.shipdate) let roh.shipdate=roh.orddate
					call "MXOHCSZONE",ros.shipcust,ros.shipcode,roh.orddate,roh.div,roh.wh,roh.shipdate,ros.zone$,roh.stopnum,IntCo
					if rtrim$(ros.zone$)<>""
						let cust.zonenumber$=ros.zone$
						! if source=251 let roh.shipdate=roh.orddate ! POS - no lead
						! let roh.duedate=roh.shipdate
					endif
				endif
				let mode$="="
				let dirno=1
				clear zn.
				ZoneRec=FileGetZonefle(e$,Ch_Zone,mode$,dirno,cust.zonenumber$,zn.)
				if zonerec>0
					let ros.truck=zn.trucknum
					let ros.zone$=cust.zonenumber$
					if trim$(zn.shipvia$)<>""
						let roh.shipvia$=zn.shipvia$
					endif
				Else
					let ros.zone$="  " ! "00" ! default zone?
				endif
				let roh.taxcode=cust.taxcode
				let ros.shiptaxtype=cust.taxtype
				let roh.contact$=cust.contact$
				let roh.slsmnum=cust.salesmancode
				if cust.defaultwhse<>0
					let roh.wh=cust.defaultwhse
				else
					let roh.wh=prt.wh
				endif

				let roh.stopnum=cust.sStop
				if cust.CustomerDiscount
					let roh.orddisc=cust.CustomerDiscount
				endif
				let roh.salesarea=cust.custsaleszone
				let rot.delivchrglvl= cust.deliverchglevel

				
			endif ! ship list not found
			if sh.ddiv>0 and sh.ddiv<100
				let roh.div=sh.ddiv
			else
				if prt.div>0
					let roh.div=prt.div ! port default priority
				else
					if cust.division>0
						let roh.div=cust.division 
					endif
				endif
			endif
			if roh.div<=0 let roh.div=1
			if cust.defaultordertype>0 and cust.defaultordertype<39 ! check order type
			  let x2=cust.defaultordertype;otv=0
			  if NOT(credit) If ot[x2]=1 let otv=1 ! valid programmed types (eventually ALL)
			  if credit and (x2<4 or x2=6 or x2=10 or x2>27) let otv=1 ! only certain types on credits
			  If otv ! valid - can use it
				let roh.ordtype=cust.defaultordertype
			  Else 
				let roh.ordtype=1
			  Endif
			else 
				let roh.ordtype=1
			endif
			If cust.ConsignWh>0 and cust.ConsignWh<ConsWh
				let roh.ordtype=16 ! force the issue
				roh.ConsWh=cust.ConsignWh
				linesexist=9;ordtype=16 ! force ot list to 16 only
				if p61$[54,54]="N"
				  If roh.xferauth=0 ! only if not already auth
					roh.xferauth=1;roh.authdate=Currdate;roh.authby=rec_uac
				  Endif
				Endif
			Endif
			roh.Source=1
			roh.ShipType=1
			if prt.entby let roh.entby=prt.entby
			if roh.entby<=0 or roh.entby>999 let roh.entby=999
			if cust.porequiredflag=0 or cust.porequiredflag=2
				let roh.custpo$="VERBAL"
			endif
			roh.dept=0 ! department
			! custnotes always (for 62459)
			let keycust$=custid using "######"
				mode$="="
				dirno=1
				CNoteRec=FileGetCustNotes(e$,Ch_CNotes,mode$,dirno,KeyCust$,cnotes.)
				if cnoterec<=0
					clear cnotes.
				endif
				If p61$[136,136]="Y"
				let roh.currid=cnotes.currid
				if p61$[136,136]="Y" and roh.currid<>0		 
					let keycurr$=" ",keycurr$
					let keycurr$=roh.currid using "####"
					search #ch_curr,2,1;keycurr$,rec_curr,e
					if not(e)
						Read Record #ch_curr,rec_curr;curr.;
					else
						let curr.ExcRate=0
						let roh.currid=0
					endif
					let roh.currfact=curr.ExcRate			
				else
					let roh.currfact=0
				endif
			else
				let roh.currid=0
				let roh.currfact=0
			endif				
		
			let roh.terms=cust.terms
			let roh.orddate=currdate
			let roh.CancelDate=Scandate ! currdate
			let roh.shipdate=currdate
			if credit let roh.invdate=currdate
			shipdateedit=0
			if not(credit) call calcshipdate()
		endif ! end of customer search
		goto endgetordhdr:
	endif ! of new order
	if orderid<>0
		if not(custid) ! and source=207
			keyroh$=" ",keyroh$
			keyroh$[3]=orderid using "######"
			For ctr=1 to 99
				let keyroh$[1,2]=ctr using "##"
				search #ch_roh,2,1;keyroh$,rec_roh,e
				if not (e)
					read record #ch_roh,rec_roh;roh.;
					let custid=roh.CustNum
					If custid<>prt.CashSaleCustNum
						 Custsec[0]=custid;custsec[1]=1 ! id & NO ALERT
						 call "custsec.dl4",Custsec[],ctlc,userid$,e$,rstr$
						 if custsec[0]=-1 ! not allowed
							returnstatus=0 ! ! or is it 99? (99 sends back to MAIN MENU!)
							message$="You do not have access this customer"
							goto endgetordhdr
						Endif
					Endif
					if roh.ordtype<1 or roh.ordtype>38
						let returnstatus=99
						let message$="Order has an invalid order type"
						goto endgetordhdr:
					endif
					if not (ot[roh.ordtype])
						let returnstatus=99
						let message$="Order Type "+str$(roh.ordtype)+" Not Available At This Time"
						goto endgetordhdr:
					endif
					let editstatus=0
					if roh.status=95 and roh.lockport = rec_uac
						let editstatus=1
					Endif
					linesexist=99
					goto orderidfound:
				endif
			next ctr
			let returnstatus=0
			if editstatus<>0 let returnstatus=99
			let message$="Quote Number ",STR$(ORDERID)," Not On File"
			goto endgetordhdr:
			orderidfound: ! ok
			if ctr=97 let credit=99 ! status for credit memo
			if ctr>8 and ctr<12 let credit=99
			if source=207 let credit=0 ! no diff than order!
		endif ! no custid
		keyroh$=" ",keyroh$
		keyroh$[1,7]=custid using "#######" 
		keyroh$[8,13]=orderid using "######"
		KEYROH$[14]="" ! no space
		mode$="=" ! search mode 2
		dir=2
		clear chan[]
		CHAN[0]=CH_ROH
		CHAN[1]=CH_ROS
		CHAN[2]=CH_ROT
		Rec_roh=filegetqohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
		if rec_roh<0
			let returnstatus=0
			if editstatus<>0 let returnstatus=99
			let message$="Quote Number ",STR$(ORDERID)," Not On File"
			goto endgetordhdr:
		endif
		if custid<=0 let custid=roh.Custnum
		if custid<>roh.CustNum and roh.custnum>0 let custid=roh.custnum ! use order customer!
		let keycust$=custid using "######"
		let mode$="="
		let dirno=1
		if custid>0
			CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
		else
			custrec=-1
		Endif
		if custrec<=0
			let returnstatus=0
			if editstatus<>0 let returnstatus=99
			let message$="Customer "+str$(custid)+" Not on File"
			goto endgetordhdr: 
		endif ! customer is on file
		if ros.status=32 let Credit=99
		if source=207 let credit=0 ! use order send
		If source=207 goto sethdrfields:
		if editstatus<>0 ! it MUST BE 90+
			if not(credit) and roh.status<>95
				let returnstatus=0
				if editstatus<>0 let returnstatus=99
				let message$="Quote Number ",str$(orderid)," Is not in Edit Status"
				goto endgetordhdr:
			endif
		else ! check if is 90+?
			if roh.status=95 and roh.lockport=rec_uac
				let editstatus=1
				goto checkordtype:
			endif
			if not(credit) and roh.status>4 
				let returnstatus=0
				if editstatus<>0 let returnstatus=99
				let message$="Quote Number ",str$(orderid)," May Not Be Editted"
				goto endgetordhdr:
			endif
		endif
		checkordtype: ! check the order type
		if roh.ordtype>38 ! 4
			let returnstatus=0
			if editstatus<>0 let returnstatus=99
			let message$="Quote Number ",str$(orderid)," Invalid Type for Edit"
			goto endgetordhdr:
		endif
		if editstatus=0 ! 
		  if source<>286 ! ord create no status change
			let OStat=roh.status ! curr key status
			let roh.lockport=rec_uac
			roh.orgstatus=roh.status ! orig status
			let roh.status=95
			let keyroh$=" ",keyroh$
			let keyroh$[1,2]=roh.status using "##"
			let keyroh$[3,8]=orderid using "######"
			search #ch_roh,4,1;keyroh$,rec_roh,e
			let keyroh$[1,2]=OStat using "##"
			if OStat<>roh.status
			search #ch_roh,5,1;keyroh$,rec_tmp,e
			endif
		  Endif	
			write record #ch_roh,rec_roh;roh.;
		endif
		linesexist=0
		let keyrol$=" ",keyrol$;keyrol$=orderid using "######"
		search #ch_rol,3,1;keyrol$,rec_rol,e
		if not (e)
			let tmp3=keyrol$[1,6]
			if tmp3=orderid let linesexist=99
		endif
		sethdrfields: ! set header fields
		let ordwh=roh.wh
		let ordtype=roh.ordtype
		let shipkey$=""
		if ros.shipedit>0 and ros.shipedit<5
			let shipkey$[1,6]=ros.shipcust using "######"
			let shipkey$[7,7]="."
			let shipkey$[8,13]=ros.shipcode using "&&&&&&"
			shipkey$[14]=""
		endif
		if ros.shipedit=4 and ros.shipcode=0
			let shipkey$="" ! bill to another customer code
		endif
		endgetordhdr: ! ***** stop here for sections ****
	else ! of order<>0?
		! load defaults
	endif
	if ordwh<=0 let ordwh=roh.wh
	if ordtype<=0 let ordtype=roh.ordtype
	! section 1 - warehouse droplist
	call OrdWhDroplist(List$[],orderid,linesexist,ordtype,ordwh)
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	!Call AddToStr(e$,rstr$,esdel$) ! end of section
	! section 2 - order type droplist
	call OrdTypelist(List$[],orderid,linesexist,ordtype,ordwh)
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	! section 3 - order header detail
	Clear List$[]                                                         
	List$[0] = bsdel$ + "OrdHShipInfo" + fdel$ ! section name
	webstr$="CustId",fdel$
	webstr$=webstr$,"ShipCustId",fdel$
	webstr$=webstr$,"OrderId",fdel$
	!webstr$=webstr$,"ShipCode",fdel$
	webstr$=webstr$,"ShipName",fdel$
	webstr$=webstr$,"ShipAddr1",fdel$
	webstr$=webstr$,"ShipAddr2",fdel$
	webstr$=webstr$,"ShipCity",fdel$
	webstr$=webstr$,"ShipState",fdel$
	webstr$=webstr$,"ShipZip",fdel$
	webstr$=webstr$,"Country",fdel$
	webstr$=webstr$,"ShipEdit",fdel$
	webstr$=webstr$,"Truck",fdel$
	webstr$=webstr$,"droplistdzonefle",fdel$ ! zone
	webstr$=webstr$,"TaxCode",fdel$
	webstr$=webstr$,"TaxDesc",fdel$
	webstr$=webstr$,"TaxType",fdel$ 
	webstr$=webstr$,"Shipkey",fdel$
	webstr$=webstr$,"TaxTypeDesc",fdel$
	webstr$=webstr$,"allowshipedit",fdel$
	webstr$=webstr$,"HOLDSCRN",fdel$ ! now system flag for Quote Holds
	webstr$=webstr$,"ALLOWDELETE",fdel$ ! so same as orders
	webstr$=webstr$,"SHIPREQ",fdel$ ! added to orders
	webstr$=webstr$,"ALLOWEDIT",fdel$ ! can user edit the order
	WebStr$=WebStr$,"PREMIERCUST",fdel$ ! is a premier customer Y/N
	let list$[1]=webstr$
	if returnstatus<>0 ! no errors send over the data
		webstr$=str$(roh.custnum),fdel$
		if not (ros.shipcust) let ros.shipcust=roh.custnum
		webstr$=webstr$,str$(ros.shipcust),fdel$
		webstr$=webstr$,str$(roh.ordnum),fdel$
		!webstr$=webstr$,str$(ros.shipcode),fdel$
		tmp$=clrtxtc$(e$,ros.name$)
		webstr$=webstr$,tmp$,fdel$
		tmp$=clrtxtc$(e$,ros.address$)
		webstr$=webstr$,tmp$,fdel$
		tmp$=clrtxtc$(e$,ros.address2$)
		webstr$=webstr$,tmp$,fdel$
		tmp$=clrtxtc$(e$,ros.city$)
		webstr$=webstr$,tmp$,fdel$
		tmp$=clrtxtc$(e$,ros.state$)
		webstr$=webstr$,tmp$,fdel$
		webstr$=webstr$,ros.zipcode$,ros.zip4$,fdel$
		tmp$=clrtxtc$(e$,ros.country$)
		webstr$=webstr$,tmp$,fdel$
		webstr$=webstr$,str$(ros.shipedit),fdel$
		webstr$=webstr$,str$(ros.truck),fdel$
		webstr$=webstr$,ros.zone$,fdel$
		if roh.taxcode<1 or roh.taxcode>7999
			let roh.taxcode=cust.taxcode
		endif
		webstr$=webstr$,str$(roh.taxcode),fdel$
		taxcoded$=gettaxcdd$(ch_tax,roh.TaxCode,intco)
		webstr$=webstr$,taxcoded$,fdel$
		webstr$=webstr$,str$(ros.shiptaxtype),fdel$ 
		webstr$=webstr$,shipkey$,fdel$
		custtaxtyped$=getcusttaxtyd$(ch_ctax,ros.shipTaxType,intco)
		webstr$=webstr$,custtaxtyped$,fdel$
		let tmp$="N"
		if cust.ManualShiplist<>0 let tmp$="Y"
		webstr$=webstr$,tmp$,fdel$
		tmp$="N"
		if p61$[106,106]="Y" let tmp$="Y" ! Quote Holds
		webstr$=webstr$,tmp$,fdel$
		tmp$="Y" ! can always delete quotes
		webstr$=webstr$,tmp$,fdel$
		let tmp$="N" ! shiplist required
		if not(orderid) and not(credit) and p61$[44,44]="Y" and ros.shipcode=0 and roh.custnum=ros.shipcust and ros.shipedit<>5
			! check if multiple shiplist exists
			shipkey$=" ",shipkey$
			let shipkey$[1,6]=ros.shipcust using "######"
			let shipkey$[7,7]="."
			let shipkey$[8,13]="000000"
			search #ch_ship,3,1;shipkey$,tmp3,e
			if not(e)
				let tmp3=shipkey$[1,6]
				if tmp3=ros.shipcust
					let tmp$="Y"
				endif
			endif
		endif
		webstr$=webstr$,tmp$,fdel$
		! allow edit
		let tmp$="Y"
		webstr$=webstr$,tmp$,fdel$
		! premier customer flag
		tmp$="N" \ if cnotes.PRMCUST$="A" or cnotes.PRMCUST$="S" let tmp$="Y"
		webstr$=webstr$,tmp$,fdel$
		let list$[2]=webstr$
	endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	! section 5 - order header field
	Clear List$[]                                                         
	List$[0] = bsdel$ + "OrdHeaderInfo" + fdel$ ! section name
	webstr$="CustId",fdel$
	webstr$=webstr$,"OrderId",fdel$
	webstr$=webstr$,"OrderDate",fdel$
	webstr$=webstr$,"PO",fdel$
	webstr$=webstr$,"droplistsslsm",fdel$ ! sslsm
	webstr$=webstr$,"droplistartermcode",fdel$
	webstr$=webstr$,"Attn",fdel$
	webstr$=webstr$,"ShipDate",fdel$
	webstr$=webstr$,"droplistdeptfle",fdel$
	webstr$=webstr$,"droplistordwh",fdel$
	webstr$=webstr$,"CanDate",fdel$
	webstr$=webstr$,"ShipTermList",fdel$
	webstr$=webstr$,"RoutingList",fdel$
	webstr$=webstr$,"droplistentdby",fdel$
	webstr$=webstr$,"StopNum",fdel$
	webstr$=webstr$,"droplistordtype",fdel$
	webstr$=webstr$,"droplistdivifle",fdel$
	webstr$=webstr$,"droplistsorce",fdel$
	webstr$=webstr$,"SalesArea",fdel$
	webstr$=webstr$,"Dclvl",fdel$
	! webstr$=webstr$,"InvoiceId",fdel$ ! NO INV ON QUOTES
	! Per Web team - if ot 16 send fields now
	If roh.ordtype=16 ! add the header	NO ORDER TYPE 16 on QUOTES
		webstr$=webstr$,"XFRTOWH",fdel$
		webstr$=webStr$,"XFERAUTH",fdel$
		webStr$=WebStr$,"XADATE",fdel$
		webstr$=webStr$,"XAUSER",fdel$
	Endif
	! if new "std" fields added - will need to be after the ot16 fields!
	if roh.ordtype=9 ! add header fields					doc=QTH-GetOrderHdr9.doc
		webStr$=webstr$,"STAGINGAREA",fdel$
	Endif
	if roh.ordtype=4 or roh.ordtype=15 or roh.ordtype=24 !  doc=QTH-GetOrderHdr15.doc
		webstr$=webstr$,"SHIPTERM",fdel$
		! shipping dates?? are separate call
	Endif
	IF roh.ordtype=5 ! future
		webstr$=webstr$,"ALCSTKDATE",fdel$
	Endif
	webstr$=webstr$,"Status",fdel$ !
	webstr$=webstr$,"ORIGORDID",fdel$ ! original order # - 2890
	webstr$=webstr$,"ABC",fdel$ ! task #21596 Rutherford !
	webstr$=webstr$,"CreditCode",fdel$ ! task#24516 
	Webstr$=Webstr$,"REBILLORDER",fdel$ ! task 45120
	let webstr$=webstr$,"CURRENCY",fdel$
	let list$[1]=webstr$
	if returnstatus<>0 ! no errors send over the data
		webstr$=str$(roh.custnum),fdel$
		webstr$=webstr$,str$(roh.ordnum),fdel$
			if roh.orddate
				let xdate$=pdate$(roh.orddate)
			else
				let xdate$=" ",xdate$
			endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! order date or invoice date
		WebStr$=WebStr$,RTrim$(roh.custpo$),fdel$ ! po#
		WebStr$=WebStr$,Str$(roh.slsmnum),fdel$ ! salesman number
		Webstr$=webstr$,str$(roh.terms),fdel$ ! terms
		tmp$=clrtxtc$(e$,roh.contact$)
		Webstr$=webstr$,tmp$,fdel$ ! contact
		if roh.shipdate
			if roh.shipdate<>999999
				let xdate$=pdate$(roh.shipdate)
			else
				let xdate$="999999"
			endif
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! ship date (date inv'd - credit)
		Webstr$=WebStr$,str$(roh.dept),fdel$ ! department
		webstr$=webstr$,str$(roh.wh),fdel$ ! warehouse
			if roh.CancelDate
				let xdate$=pdate$(roh.CancelDate)
			else
				let xdate$=" ",xdate$
			endif
			WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! cancel date
		webstr$=webstr$,str$(roh.ShipType),fdel$
		if trim$(roh.shipvia$)="" let roh.shipvia$="OUR TRUCK"
		webstr$=webstr$,rtrim$(roh.shipvia$),fdel$
		webstr$=webstr$,str$(roh.EntBy),fdel$
		webstr$=webstr$,str$(roh.stopnum),fdel$
		webstr$=webstr$,str$(roh.OrdType),fdel$
		webstr$=webstr$,str$(roh.div),fdel$
		webstr$=webstr$,str$(roh.Source),fdel$
		webstr$=webstr$,str$(roh.salesarea),fdel$
		webstr$=webstr$,str$(rot.delivchrglvl),fdel$
		! webstr$=webstr$,str$(roh.InvNum),fdel$
		! now send the ot16 fields
		if roh.ordtype=16 ! send the data
			webstr$=webStr$,Str$(roh.ConsWh),fdel$
			if p61$[54,54]="N" ! NOT USING
			  if roh.xferauth=0 ! only if not prev auth
				roh.xferauth=1;roh.authdate=Currdate;roh.authby=rec_uac
			  Endif
			Endif
			tmp$="N" \ if roh.XferAuth let tmp$="Y"
			webstr$=webstr$,tmp$,fdel$
			let tmp$="0" \ if roh.XferAuth and roh.AuthDate let tmp$=PDate$(roh.AuthDate)
			webstr$=webstr$,tmp$,fdel$
			tmp$=" " \  if roh.XferAuth and roh.AuthBy let tmp$=Getuidinfo$(E$,IntCo,roh.AuthBy)
			webstr$=webStr$,RTrim$(tmp$[21]),fdel$
		Endif
		If roh.ordtype=9 ! send data
			webstr$=Webstr$,RTrim$(roh.WhStage$),fdel$
		Endif
		if roh.ordtype=4 or roh.ordtype=15 or roh.ordtype=24
			webstr$=webstr$,Str$(roh.shipterm),fdel$
			! dates? are sep call
		Endif
		if roh.ordtype=5 ! future
			tmp$=""
			if roh.CmInvHist let tmp$=Pdate$(roh.CmInvHist)
			webstr$=webstr$,tmp$,fdel$
		Endif
		let tmp3=roh.status
		if source<>207 and roh.status>94 and roh.OrgStatus<94
			if roh.OrgStatus let tmp3=roh.OrgStatus
		endif
		tmp$=tmp3 using "&&"
		if tmp3>=1 and tmp3<12
			let x2=tmp3
			tmp$=tmp$+"-"+STATWORD$[x2*10-9,x2*10]
		else
			if tmp3=58 let tmp$=tmp$+ "-Order Being Picked"
			if tmp3=59 let tmp$=tmp$+ "-Order Is On Hold"
			if tmp3=94 let tmp$=tmp$+ "-POS Ord Erp Proc"
			if tmp3=95 let tmp$=tmp$+ "-Order Erp Proc"
			if tmp3=96 let tmp$=tmp$+ "-Invoice Erp Proc"
			if tmp3=97 let tmp$=tmp$+ "-Credit Erp Proc"
		Endif
		webstr$=webstr$,tmp$,fdel$ ! status
		webstr$=webstr$,"",fdel$ ! orig order on quotes?
		!if custom_customer$="RUTHERFORD"
			WEBSTR$=webstr$,str$(cust.AbcScore),fdel$
		!else
		!	webstr$=webstr$,"",fdel$
		!endif
		If cust.CreditCode>0 and cust.CreditCode<=16
			let credcoded$=getcredcdd$(ctlc,cust.CreditCode,intco)
			let webstr$=webstr$,str$(cust.creditcode),"-",credcoded$,fdel$
		else
			let webstr$=webstr$,"",fdel$
		endif
		webstr$=webstr$,Str$(roh.OrgOrd1),fdel$ ! task 45120 - need to send on quotes
		if p61$[136,136]="Y" and roh.currid<>0
			let keycurr$=" ",keycurr$
			let keycurr$=roh.currid using "####"
			search #ch_curr,2,1;keycurr$,rec_curr,e
			if not(e)
				Read Record #ch_curr,rec_curr;curr.;
				let tmp$=roh.currid using "####"
				let tmp$=tmp$+" "
				let tmp$=tmp$+rtrim$(curr.desc$)
				let webstr$=webstr$,tmp$,fdel$
			else
				let webstr$=webstr$,"",fdel$
			endif
		else
			let webstr$=webstr$,"",fdel$ ! currency
		endif
		let list$[2]=webstr$
	endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	! Call dxsave(0,"/tmp/md.txt!")
	! status section *** last section ***
  else
    include "src/callsuberr.inc"
  end try
end sub ! getheader
!
!--------------------------------------------------------------------
sub VerifyCustomer()
  !
  ! Checks customer text from web or customer # for verifydocument call
  ! if found changes action1$ to VerifyCustomer
  ! if not sends error message back to web
  !
  Try
    let returnstatus=1
    let message$="OK"
    if isnumber=1 ! customer number
	  tmp3=SearKey$ \ SearKey$=tmp3 using M6$
	  mode$="="
	  dirno=1
	  if tmp3>0
	  CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,SearKey$,cust.)
	  else
		custrec=-1
	  Endif
	  if CustRec>=0 ! record found
	       let custid=tmp3
	       if cust.customerbillto<>0 and cust.customerbillto<>custid
			  mode$="="
			 dirno=1
			 let searkey$=cust.customerbillto using "######"
			 BCustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,SearKey$,billto.)
			 if BCustRec>=0 ! record found
				let action1$="AcctClsd"
			 else
				let returnstatus=0
				Message$="Bill To Customer "+str$(cust.customerbillto)+" Not On File"
			 endif       
  	       else
	        let billto. = cust. 
	       endif 
	  else ! if custrec
	  ReturnStatus=0 ! error not found
	    Message$="Customer ",str$(tmp3)," not found"
	  endif ! if custrec
   endif ! isnumber=1
   ! need customer info header !!!
   ! if returnstatus  ! customer was found 
   !!! send over data section
   !!! 
   ! endif
   ! status section
   
	  
  else
    include "src/callsuberr.inc"
  end try
end sub ! verifycustomer
!
!--------------------------------------------------------------------
Sub CreditChk()
! do a credit check
 Try
	call dxget ("custid",CustId$)
	let custid=custid$
	call dxget ("billcustid",BillCustId$)
	let billcustid=billcustid$
	call dxget ("orderid",OrderId$)
	let orderid=Orderid$
!	call dxget ("orderamt",OrderAmt$)
!	let ordamt=orderamt$
!if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
!		factor=roh.currfact
!		call currconvdown(amount,factor)
!		amount=fnr(amount)
!	endif
	let returnstatus=1
	let message$="OK"
	if billcustid<=0
		let keycust$=custid using "######"
		mode$="="
		dirno=1
		if custid>0
		CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
		Else
			custrec=-1
		Endif
		if CustRec>=0 ! record found
			let billcustid=cust.customerbillto
	    else ! if custrec
			ReturnStatus=0 ! error not found
			Message$="Customer ",keycust$," not found"
			let billcustid=custid
		endif ! if custrec	!! file get !!
        endif
	let shipcustid=0
	if orderid>0 and orderid<999999
		let keyroh$=" ",keyroh$
		let keyroh$[1,7]=custid using "#######"
		let keyroh$[8,13]=orderid using "######"
		KEYROH$[14]="" ! no space
		mode$="="
		dirno=2
		!clear chan[]
		!CHAN[0]=CH_ROH
		!CHAN[1]=CH_ROS
		!CHAN[2]=CH_ROT
		!Rec_roh=filegetqohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
		SEARCH #CH_ROH,2,2;KEYROH$,REC_ROh,E
		IF E LET REC_ROH=0
		If Rec_roh>0
			
			Read Record #CH_ROH,Rec_roh;roh.;
			Read Record #ch_ros,roh.shiprec;ros.;
			Read Record #CH_ROT,roh.totrec;rot.; 
			if not (ros.shipcust) let ros.shipcust=roh.custnum
			let shipcustid=ros.shipcust
		endif
	endif
	if shipcustid=0 let shipcustid=custid
	clear chan[]
	chan[1] =ctlc    ! cntrl file
        chan[2] =ch_cust ! customer file
	chan[3] = 0	 ! saract file ** not opened **
	chan[4] = 0      ! credit check file ** not opened ** ch_credck
	chan[5] =ch_roh	 ! order header
	chan[6] =ch_rot	 ! order total
	chan[7] =ch_ros	 ! order ship to
	work$=""
	flag=0;ordamt=0 ! send as 0 = no custonord update
	call getcredck(chan[],shipcustid,billcustid,rec_roh,ordamt,intCo,ReturnStatus,Message$,flag,work$)
	clear list$[]
	List$[0]=bsdel$,"CreditCheck",fdel$
	WebStr$="Chktype",fdel$,"Message$",fdel$,"AR Balance",fdel$
	WebStr$=Webstr$,"Open Order Amt",fdel$
	Webstr$=Webstr$,"Standard Terms",fdel$
	Webstr$=Webstr$,"Payment History",fdel$
	Webstr$=Webstr$,"Note1",fdel$
	Webstr$=Webstr$,"Note2",fdel$
	List$[1]=WebStr$
	clear cnotes.
        let arbal=0
	let openordamt=0
	credcoded$=" ",credcoded$
	artermd$=" ",artermd$
	let tmp$=flag using "#"
	let Webstr$=tmp$,fdel$
	let webstr$=webstr$,work$,fdel$
	if flag
		clear cust.
		let keycust$=billcustid using "######"
		mode$="="
		dirno=1
		if billcustid>0
		CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
		else
			custrec=-1
		Endif
		if CustRec>=0 ! record found
			If cust.CreditCode>0 and cust.CreditCode<=16
				let credcoded$=getcredcdd$(ctlc,cust.CreditCode,intco)
			endif
			let openordamt=cust.openorder+ordamt
			let arbal=cust.currentaragebal-cust.unappliedcredit+cust.agearamt1
			let arbal=arbal+cust.agearamt2+cust.agearamt3+cust.agearamt4
			if cust.terms>0 and cust.terms<=99
				let artermd$=getartermd$(ch_terms,cust.terms,intco)	
			endif
		endif
		let keycust$=billcustid using "######"
		mode$="="
		dirno=1
		if billcustid>0
		CNoteRec=FileGetCustNotes(e$,Ch_CNotes,mode$,dirno,KeyCust$,cnotes.)
		Else
			cnoterec=-1
		Endif
		if cnoterec<=0
			clear cnotes.
		endif
	endif
	let tmp$=arbal using  "-$$$$,$$$,$$#.##"
	webstr$=webstr$,tmp$,fdel$
	let tmp$=openordamt using  "-$$$$,$$$,$$#.##"
	webstr$=webstr$,tmp$,fdel$
	webstr$=webstr$,artermd$,fdel$
	webstr$=webstr$,credcoded$,fdel$
	webstr$=webstr$,cnotes.notesline1$,fdel$
	webstr$=webstr$,cnotes.notesline2$,fdel$
	list$[2]=webstr$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! status section
else
    include "src/callsuberr.inc"
  end try
end sub ! creditchk
!
!--------------------------------------------------------------------
Sub Deleteord()
! as it says delete
 try
	DIM 1%,CH_CARTQOH
	Dim 2%,stat[10]
	dim 3%,REC_CARTQOH,quotenum
	dim delmsg$[20],key_cartqoh$[18]
	ReturnStatus=1
	Message$="OK"
	Call dxget("ORDERID",tmp$)                                   
	If tmp$ = ""                                                 
		Message$ = "Quote # MISSING"                               
		ReturnStatus = 0                                           
		Goto EndDelOrd:
	End If
	orderid = tmp$  
	call dxget ("custid",Custid$)
	let custid=custid$
	If orderid > 0 And orderid < 999999 And Not(Fra(orderid))    
		keyroh$ = " ",keyroh$                                             
		keyroh$[1,7] = custid Using "#######"                              
		keyroh$[8,13] = orderid Using "######" 
		KEYROH$[14]="" ! no space
		mode$ = "=" ! search mode 2                                       
		dir = 2                                                           
		Clear chan[]                                                      
		chan[0] = ch_roh                                                  
		chan[1] = ch_ros                                                  
		chan[2] = ch_rot                                                  
		rec_roh = filegetqohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.) 
		If rec_roh <= 0 ! no order found                               
			Message$ = "Quote # NOT FOUND"                           
			ReturnStatus = 0                                         
			Goto EndDelOrd:                                        
		 End If 
	else
		Message$ = "Invalid Quote Number " +str$(orderid)                          
		ReturnStatus = 0                                         
		Goto EndDelOrd:       
	End If 
	IF Roh.ordtype=15 and roh.boctr<>0
		returnstatus=0
		message$="CANNOT DELETE...ALREADY BEEN BILLED!!!!"
		goto enddelord
	Endif
	searkey$=CustiD using "######"
	if custid>0
	CustRec = FileGetCust(e$,Ch_Cust,"=",1,SearKey$,cust.)
	Else
		custrec=-1
	Endif
	if custrec<0
		message$="Customer "+str$(custid)+" Not on File"
		returnstatus=0
		goto EndDelORd:
	endif

!	Ch_CARTQOH = OpenFile(-10011,intCo) \ If Ch_CARTQOH = -1 Error 42  ! sfcartqoh
!	KEY_CARTQOH$=" ",KEY_CARTQOH$
!cartqoh_loop: SEARCH #CH_CARTQOH,3,1;KEY_CARTQOH$,REC_CARTQOH,E
!	IF NOT(E)
!		! UUUUUUUUCCCCCCCCCC
!		tmp$=str$(custid)
!		IF KEY$_cartqoh$[9,len(tmp$)]=tmp$
!			mat read #ch_cartqoh,rec_cartqoh,386;quotenum;
!			if quotenum=orderid
!				! quote is in salespro file to be edited there
!				message$="This quote is being edited in Salespro by user "+key_cartqoh$[1,8]+". Submit the quote or delete it in Salespro."
!				returnstatus=0
!				goto EndDelOrd:
!			endif
!		endif
!		goto cartqoh_loop:
!	endif
!	CLOSE #CH_CARTQOH

	call dxget ("SOURCE",tmp$)
	let source=tmp$
	if source=0 and credit let source=241
	call dxget ("DELREASON",tmp$)
	let DELMSG$=tmp$+BLANK$
	! verify if ok to delete
	
	if not(returnstatus) goto endDelOrd: ! cannot delete
	! set up parameters for call
	CLEAR STAT[]
	STAT[0] = intco !  company #
	STAT[1] = custrec ! customer record # (S9[1])
    STAT[2] = rec_roh !   (S9[2])
    STAT[3] = 284 ! 
	! if source=223 goto justreset ! reset to status4 - no order delete
	STAT[4] = source ! program #
	CLEAR CH[]
	CH[0]=ctlc ! control file
	CH[1]=CH_CUST ! Customer file
	ch[2]=ch_prod
	ch[3]=ch_roh! order header #8
	ch[4]=ch_rol! order lines #11
	ch[5]=ch_ros! order ship file #9
	ch[6]=ch_rom ! order message file
	ch[7]=CH_SPRODDESC ! order nonstock
	ch[8]=ch_rot! order total
	ch[9]=ch_roc ! order cash screen 
	ch[10]=0 ! order acknowledgement
	ch[11]=0 ! - not used
	ch[12]=ch_prwh
	ch[13]=0 ! trace delete
	ch[14]=0 ! edit track
	ch[15]=ch_sordlot ! order lot file
	ch[16]=ch_sprodlot ! product lot file
	Call "mx281e.dl4",Ch[],STAT[],rec_uac,delmsg$,e$,rstr$,returnstatus,message$
	Justreset: ! no delete - reset to printed
	If source=223 ! reset to status 4 from 5 or 6
	  If P60$[44,44]="Y" ! edittracking
		clear etr.
		etr.ProdCode$="INV DELETED"+Blank$
		etr.EtAction=10
		! call edttrk()
	  Endif
	  ! deleted inv track
	  ! Call Trkdel()
	    ! ok - change to status 4
		OStat=roh.status ! status of curr key
		roh.status=4
		let keyroh$=" ",keyroh$
		let keyroh$[1,2]=roh.status using "##"
		let keyroh$[3,8]=orderid using "######"
		search #ch_roh,4,1;keyroh$,rec_roh,e
		let keyroh$[1,2]=roh.orgstatus using "##"
		if OStat<>roh.status
		Search #ch_roh,2,1;keyroh$,rec_tmp,e
		if not(E)
			search #ch_roh,5,1;keyroh$,rec_tmp,e
		Endif
		Endif
		roh.orgstatus=0
		write record #ch_roh,rec_roh;roh.;
		if E>0
			returnstatus=0
			message$="Search Error "+Str$(E)+" Resetting Invoice"
		Else
			returnstatus=1
			Message$="Invoice was reset to an order"
		Endif
	Endif ! of justreset

	EndDelOrd: ! end of section 
	
	
 else
	include "src/callsuberr.inc"
 end try
End sub !delorder



!!!! end deleteorder !!!!!

! ------------------------------------------------------------------------
Sub OrdHLabel()
  !
  ! Create order header Labels for .net
  !
try
  dim head$[10],keyprog$[30],retval$[512]
  dim 3%,ch_prgd,rec_prgd,e,ctr
 
   !get the specific order detail
     Call DXGet("SOURCE",TMP$)  
    source = TMP$              
    Ch_prgd = OpenFile(-9940,intCo) \ If Ch_prgd = -1 Error 42  ! progdflt file
    let retval$=" ",retval$
    if ch_prgd>0
		let keyprog$=" ",keyprog$
		let keyprog$[1,4]="281A"
		if source=283 let keyprog$[1,4]="283A"
		search #ch_prgd,2,1;keyprog$,rec_prgd,e
		if not(e)
			mat read #ch_prgd,rec_prgd,0;retval$;
		endif
		try close #ch_prgd  ELSE REM
    endif
    returnstatus=1
    message$="OK"
   
 Clear List$[]                                                         
 List$[0] = bsdel$ + "OrdHLabels" + fdel$ ! section name                 
 tmp$ = "Std Name" + fdel$                                            
 tmp$ = tmp$ + "Label" + fdel$ 
 tmp$ = tmp$ + "Req" +fdel$
 tmp$ = tmp$ + "Droplist" + fdel$
 List$[1] = tmp$ ! put header into rstr$                            
 row = 2 ! starting row for data   
  If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])                  
           
 let tmp$="SHIPNAME"+fdel$ ! #1   
 let tmp$=tmp$+"ShipName"+fdel$ ! #1
 if retval$[1,1]="F"
	let tmp$=tmp$+"Y" +fdel$! #1
 else
	let tmp$=tmp$+"N" +fdel$! #1
 endif
 let tmp$=tmp$," ",fdel$ ! droplist name
 list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 

let tmp$="SHIPADDR1"+fdel$ ! #2
let tmp$=tmp$+"ShipAddr1"+fdel$ ! #2
if retval$[2,2]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
 let tmp$=tmp$," ",fdel$ ! droplist name
 list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

let tmp$="SHIPADDR2"+fdel$ ! #3
let tmp$=tmp$+"ShipAddr2"+fdel$ ! #3
if retval$[3,3]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
 let tmp$=tmp$," ",fdel$ ! droplist name
 list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

let tmp$="SHIPCITY"+fdel$ ! #4
let tmp$=tmp$+"ShipCity"+fdel$ ! #4
if retval$[4,4]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
 let tmp$=tmp$," ",fdel$ ! droplist name
 list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

let tmp$="SHIPST"+fdel$ ! #5
let tmp$=tmp$+"ShipState"+fdel$ ! #5
if retval$[5,5]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
 let tmp$=tmp$," ",fdel$ ! droplist name
 list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

let tmp$="SHIPZIP"+fdel$ ! #6
let tmp$=tmp$+"ShipZip"+fdel$ ! #6
if retval$[6,6]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
 let tmp$=tmp$," ",fdel$ ! droplist name
 list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
 
tmp$="ORDDATE"+fdel$  !#7
	tmp$=tmp$+"QUOTE DATE"+fdel$  !#7
 if retval$[7,7]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
 let tmp$=tmp$," ",fdel$ ! droplist name
 list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])


tmp$="PO"+fdel$	!#8
tmp$=tmp$+"PO"+fdel$	!#8
 if retval$[8,8]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
 let tmp$=tmp$," ",fdel$ ! droplist name
 list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])


tmp$="SLSMNO"+fdel$	!#9
read #ctlc,18,60;head$; ! salesman name head
tmp$=tmp$+head$+fdel$	!#9
if retval$[9,9]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
 let tmp$=tmp$,"droplistsslsm",fdel$ ! droplist name **** for the salesperson
 list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 

	tmp$="TERMS"+fdel$ !#10
	tmp$=tmp$+"TERMS"+fdel$ !#10
if retval$[10,10]="F" or (Credit and GENCM=1) ! force it
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
 If Not(Credit) let tmp$=tmp$,"droplistartermcode ",fdel$ 
 If Credit let tmp$=tmp$," ",fdel$ ! droplist name
 list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

tmp$="ATTN"+fdel$	!#11
tmp$=tmp$+"ATTN"+fdel$	!#11
if retval$[11,11]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
let tmp$=tmp$," ",fdel$ ! droplist name
list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

tmp$="SHIPDATE"+fdel$ ! #12
tmp$=tmp$+"SHIP DATE"+fdel$ ! #12
if retval$[12,12]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
let tmp$=tmp$," ",fdel$ ! droplist name
list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

tmp$="DEPT"+fdel$      ! #13
tmp$=tmp$+"DEPT"+fdel$      ! #13
if retval$[13,13]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
let tmp$=tmp$,"droplistdeptfle",fdel$ ! droplist name
list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

tmp$="WHSE"+fdel$
read #ctlc,18,30;head$;     ! warehouse name head 
tmp$=tmp$+head$+fdel$       ! #14 
IF retval$[14,14]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
If Not(Credit) let tmp$=tmp$,"droplistordwh",fdel$ ! droplist name
if credit let tmp$=tmp$,"droplistentdby",fdel$ ! droplist name 
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

If not(credit)
tmp$="CANDATE"+fdel$  ! #15
tmp$=tmp$+"CANCEL DT"+fdel$  ! #15
Else
	tmp$="WEIGHT"+fdel$
	tmp$=tmp$+"WEIGHT"+fdel$ ! #15
Endif
IF retval$[15,15]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
let tmp$=tmp$," ",fdel$ ! droplist name
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
	
tmp$="SHIPNO"+fdel$   ! #16
tmp$=tmp$+"SHIP#"+fdel$   ! #16
IF retval$[16,16]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
  If not(credit) let tmp$=tmp$,"ShipTermList",fdel$ 
  If Credit let tmp$=tmp$+"CMTypeList"+fdel$
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

tmp$="ROUTING"+fdel$ ! #17
tmp$=tmp$+"ROUTING"+fdel$ ! #17
IF retval$[17,17]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
 let tmp$=tmp$,"RoutingList",fdel$
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

tmp$="ENTBY"+fdel$ ! #18
read #ctlc,18,80;head$;
	tmp$=tmp$+head$+fdel$	 ! #18 ! entered by

IF retval$[18,18]="f"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
If Not(Credit) let tmp$=tmp$,"droplistentdby",fdel$ ! droplist name 
if credit let tmp$=tmp$," ",fdel$ ! droplist name 
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

tmp$="ZONE"+fdel$   ! #19 
tmp$=tmp$+"ZONE"+fdel$   ! #19 
IF retval$[19,19]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
If Not(Credit) let tmp$=tmp$,"droplistzonefle",fdel$ ! droplist name 
If Credit let tmp$=tmp$,"droplistordtype",fdel$ ! droplist name
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

tmp$="TRUCK"+fdel$  ! #20
tmp$=tmp$+"TRUCK"+fdel$  ! #20 
IF retval$[20,20]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
If Not(Credit) let tmp$=tmp$," ",fdel$ ! droplist name
if credit let tmp$=tmp$,"droplistdivifle",fdel$ ! droplist name
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

tmp$="STOP"+fdel$   ! #21
tmp$=tmp$+"STOP"+fdel$   ! #21
IF retval$[21,21]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
If Not(Credit) let tmp$=tmp$," ",fdel$ ! droplist name
IF credit let tmp$=tmp$,"droplistordwh",fdel$ ! droplist name
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

tmp$="ORDTYPE"+fdel$   ! #22
tmp$=tmp$+"TYPE"+fdel$   ! #22
IF retval$[22,22]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
If Not(Credit) let tmp$=tmp$,"droplistordtype",fdel$ ! droplist name
if credit let tmp$=tmp$,"droplistzonefle",fdel$ ! droplist name 
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

tmp$="DIV"+fdel$  ! #23
tmp$=tmp$+"DIVISION"+fdel$  ! #23
IF retval$[23,23]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
if not(Credit) let tmp$=tmp$,"droplistdivifle",fdel$ ! droplist name
if credit let tmp$=tmp$," ",fdel$ ! droplist name
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

tmp$="SRCE"+fdel$ ! #24
tmp$=tmp$+"SOURCE"+fdel$ ! #24
IF retval$[24,24]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
If Not(Credit) let tmp$=tmp$,"droplistsorce",fdel$ ! droplist name
If Credit let tmp$=tmp$," ",fdel$ ! droplist name
list$[row]=tmp$

Call AddToStr(e$,rstr$,List$[])  ! put header into rstr$  
Call AddToStr(e$,rstr$,esdel$) ! end of section

call SetOutput(e$,rstr$)
ELSE
include "src/callsuberr.inc"
END TRY

End sub ! ordhlabel
!----------------------------------------------------------------------------------
Sub OrdList()  
!! this get a list of the open orders for the customer !!
try
	Dim cust$[60],keyroh$[60],xdate$[10],statword$[200]
	dim 2%,bo,3%
	! need in read only mode to prevent record locking
	Try close #ch_roh Else Rem
	Try close #ch_ros Else Rem
	Try close #ch_rot Else Rem
	Ch_Roh = openfile(-1280,intCo) \ If Ch_Roh = -1 Error 42     !"order header file
  	Ch_Ros = openfile(-1392,intCo) \ If Ch_Ros = -1 Error 42     !"order shipto file
	Ch_Rot = openfile(-2656,intCo) \ If Ch_Rot = -1 Error 42     !"order total file
	
	LET STATWORD$="ENTERED   PRINTED   REGISTEREDORD CREATE"
	!STATWORD$=STATWORD$+"INV ENTRD INV PRNTD INV REGD            "
	!STATWORD$=STATWORD$+"C/M ENTRD C/M PRNTD C/M REGD            "
	Call DXGet("custid",cust$) \ custid=cust$
	cust$=custid using "######"
	cust$ = cust$+"            "
	cust$[7]="" ! "cut after 6 chars
	clear List$[]
	keyroh$=" ",keyroh$
	keyroh$=cust$
	Call DXGet("SOURCE",tmp$) 
	source=tmp$ \ if credit let source=0
	List$[0]=bsdel$,"OpenOrderList",fdel$
	WebStr$="OrderID",fdel$
	WebStr$=WebStr$,"Date",fdel$,"Status",fdel$
	WebStr$=WebStr$,"PO#",fdel$,"Ship To Name",fdel$,"Type",fdel$,"BackOrder",fdel$
	Webstr$=webstr$,"Ship Date",fdel$,"Whse",fdel$
	List$[1]=WebStr$
	row=2
	if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	keyroh$=" ",keyroh$
	keyroh$[2]=cust$+"      " ! starts with customer
	mode$=">" ! search mode 3
	dir=2
	clear chan[]
	CHAN[0]=CH_ROH
	CHAN[1]=CH_ROS
	CHAN[2]=CH_ROT
	Do
		Rec_roh=filegetqohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
		If Rec_roh<0 or keyroh$[2,7]<>Cust$[1,6] Exit Do
		! if source=231 exit do ! NO OPENS (or treat as inv edit?)
		if not(ot[roh.ordtype]) goto getnxtcustord: ! not set up serp
		if not(source) Or source=281 or source=283 ! regular order 201/208
		  If Not(Credit) and Not(Invoice)
			if roh.status>4 and roh.status<>95 goto getnxtcustord:
			if roh.status=95
				if roh.lockport<>rec_uac goto getnxtcustord:! check if being entered by the same user
				!goto getnxtcustord:
			endif
		  Endif
			
		endif
		WebStr$=str$(roh.ordnum),fdel$ ! order ID 
		if roh.orddate
			let xdate$=pdate$(roh.orddate)
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! order date
		LET tmp$=" ",tmp$
		if not(source) Or source=281 or source=283
		  If Not(Credit) and Not(Invoice)
			if roh.status<=4
				tmp$=STATWORD$[roh.status*10-9,roh.status*10]
			else
				if roh.status=95
					tmp$="Quote Erp Proc"
				endif
			endif
		   Endif
		else
			if source=207 ! 
				if roh.status>=1 and roh.status<12
					let x2=roh.status
					tmp$=STATWORD$[x2*10-9,x2*10]
				else
					tmp$="In Edit Proc"
					if roh.status=58 let tmp$="Order Being Picked"
					if roh.status=59 let tmp$="Order Is On Hold"
					if roh.status=94 let tmp$="POS Ord Erp Proc"
					if roh.status=95 let tmp$="Order Erp Proc"
					if roh.status=96 let tmp$="Invoice Erp Proc"
					if roh.status=97 let tmp$="Credit Erp Proc"
				Endif
			Endif
			
		endif
		WebStr$=WebStr$,RTrim$(tmp$),fdel$ ! status
		WebStr$=WebStr$,RTrim$(roh.custpo$),fdel$ ! po#
		read record #ch_ros,roh.shiprec;ros.;
		WebStr$=WebStr$,RTrim$(ros.name$),fdel$ ! ship to name
		let ordtyped$=getordtypd$(ctlc,roh.ordtype,intco)
		tmp$=ordtyped$
		Webstr$=Webstr$,rtrim$(tmp$),fdel$ ! order type
		let bo=0
		let keyrol$=" ",keyrol$;keyrol$=roh.ordnum using "######"
		do
			search #ch_rol,3,1;keyrol$,rec_rol,e
			if e>0 exit do
			let tmp3=keyrol$[1,6]
			if tmp3<>roh.ordnum exit do
			read #ch_rol,rec_rol,186;bo;
			if bo exit do
		loop
		tmp$=""
		if bo let tmp$=tmp$+"*"
		Webstr$=Webstr$,rtrim$(tmp$),fdel$ ! backorder
		if roh.ShipDate>0 and roh.ShipDate<>999999
			let xdate$=pdate$(roh.ShipDate)
		else
			let xdate$=" ",xdate$
			if roh.ShipDate=999999 let xdate$="99/99/9999"
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! order ship date
		! need to have check for backorders ! -- done above in bo
		webstr$=webstr$,Str$(roh.wh),fdel$
		List$[row]=WebStr$
		row=row+1
		if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
		getnxtcustord: ! get the next customer order
	Loop ! of open orders for customer
else
	include "src/callsuberr.inc"
end try
end sub ! ordlist
!------ ordwhdroplist ------
! filter eligible warehouse number for customer/order type
! need customer cons whs, order edit flag, 
Sub OrdWhdroplist(list$[],orderid,linesexist,ORDTYPE,ordwh) 

  ! creates a drop list
  !
   ! filter eligible warehouse number for customer/order type
  ! need customer cons whs, order edit flag, 
  Try
     read #ctlc,60,16;conswh;
     read #ctlc,115,20;maxwh;

    tmpcnt=99
    !
    ! beginning section
    List$[0]=bsdel$,"droplistordwh",fdel$ ! beginning section
 
    ! heading section for .net
    List$[1]="ID",fdel$,"WhName",fdel$

    ! create data section
    row=2
    if maxwh<>0
		if maxwh< (chf(ch_wh)-1) let maxwh=(chf(ch_wh)-1)
    endif
    if conswh>0 and orderid<>0
      if ordtype<>7 and ordtype<>8 ! ot 7/8 gets ALL WHSES
		if maxwh>conswh let maxwh=conswh-1
      endif
	Endif
	If Orderid=0 and conswh>0 ! not known what ot yet!
		if cust.ConsignWh<conswh ! not consign - transfer?
			if maxwh>conswh let maxwh=conswh-1
		Endif
	Endif
    for cnt=0 to maxwh  ! warehouse 1 starts at record 0
		!!! check to see if valid !!!
		read record #ch_wh,cnt;wh.;
		if row>tmpcnt let tmpcnt=expandarray(E$,List$[])
		let webstr$=""
		if wh.whname$[1,5]<>"     " and wh.whname$<>"" ! needs to have a description to be valid
			if orderid<>0 ! orderid -- then it is an edit
				if linesexist<>0
					if (cnt+1)=ordwh ! same warehouse include in list
						let tmp$=(cnt+1) using "##"
						let webstr$=tmp$,fdel$,wh.whname$,fdel$
					else
						if ordtype=2 or (ordtype=3 and p60$[22,22]="N")
						! direct order or indirect and update stock=N then change warehouse
							let tmp$=(cnt+1) using "##"
							let webstr$=tmp$,fdel$,wh.whname$,fdel$
						endif
					endif
				else
					! no lines exist -- can change the warehouse
					let tmp$=(cnt+1) using "##"
					let webstr$=tmp$,fdel$,wh.whname$,fdel$
				endif
			else
				! new order 
				let tmp$=(cnt+1) using "##"
				let webstr$=tmp$,fdel$,wh.whname$,fdel$
			endif
		endif
		if webstr$
			 List$[row]=webstr$
			row=row+1
		endif
        !
    next cnt
    !
    if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
    List$[row]=esdel$ ! end of section delimiter
    !
  else
    if spc(8) <> 10000
      e$="error in filedroplist whinfo"
    if spc(8) = 123 let e$=" record locked"
      if spc(8)<10000 if spc(8)<>123 call suberr(e$,Spc(8),Spc(10),Msc$(2))
    end if
    error 10000
  end try
end sub ! ordwhdroplist 
! ----------------------------------------------------------------------------------
Sub OrdTypelist(list$[],orderid,linesexist,ORDTYPE,ordwh) 
 !*** Currently For types 1, 2, and 3 only ****
 ! added 6, 9, 10, 12, 16, 21, 22
 try
	Clear list$[]
 	tmpcnt=maxcnt
	List$[0]=bsdel$,"droplistordtype",fdel$ ! beginning section!
	
	!
	List$[1]="ID",fdel$,"Description",fdel$
    !
	if cust.ConsignWh>0 and orderid=0 and ordtype=16 let orderid=-1;linesexist=9 ! only ot for customer
	if cust.ConsignWh>0 and orderid<>0 and ordtype=16 let linesexist=9 ! only ot for customer
	ostat=roh.status \ if ostat>89 let ostat=roh.OrgStatus
	!
	row=2
	for cnt=1 to 38 ! include all - parse valid
	   if not(ot[cnt]) goto excltype ! not set up
	   if credit and (cnt=9 or cnt=12 or cnt=16) goto excltype ! not on cm's
	   if ostat>1 and ordtype<>9 and cnt=9 goto excltype ! orderstat>1 - no to ot9
	   IF cust.ConsignWh=0 and (cnt=16 or cnt=7 or cnt=8) goto excltype ! no cons whs
		let dsp=(cnt-1)*20
	        read #ctlc,62,dsp;desc$[1,20];
		let webstr$=""
		if rtrim$(desc$)<>"" ! we have a description
			if orderid <>0 ! come from order edit
				if linesexist<>0 ! there are lines on this order
					if ordtype=cnt ! include same order type always
						webstr$=str$(cnt),fdel$
						webstr$=webstr$,rtrim$(Desc$),fdel$
					else
						! WE'LL USE MX208A AS A GUIDE
						if ordtype>=1 and ordtype<=3 ! can chg to any (use otypeprocess() to check)
						  IF cnt<>4 and cnt<>8 and cnt<>15 and cnt<>16 and cnt<>20 and cnt<>21 and cnt<>22
							webstr$=str$(cnt),fdel$
							webstr$=webstr$,rtrim$(Desc$),fdel$
						  Endif
						Endif
						if ordtype=21 or ordtype=22 ! can only go from 21 to 22 or 22 to 21
							if cnt=21 or cnt=22
								webstr$=str$(cnt),fdel$
								webstr$=webstr$,rtrim$(Desc$),fdel$
							endif
						endif
						if ordtype=5 or ordtype=11 ! can chg to any (use otypeprocess() to check)
						  IF cnt<>4 and cnt<>8 and cnt<>15 and cnt<>16 and cnt<>20 and cnt<>21 and cnt<>22
							webstr$=str$(cnt),fdel$
							webstr$=webstr$,rtrim$(Desc$),fdel$
						  Endif
						Endif
						if ordtype=6 or ordtype=9 or ordtype=10 or ordtype=12 ! allowed change to any
						  IF cnt<>4 and cnt<>8 and cnt<>15 and cnt<>16 and cnt<>20 and cnt<>21 and cnt<>22
							webstr$=str$(cnt),fdel$
							webstr$=webstr$,rtrim$(Desc$),fdel$
						  Endif
						Endif
						! if ordtype= ! future use - allow change of ordtypes
					endif ! same/diff ot
				else
					! no lines on order can edit this
					webstr$=str$(cnt),fdel$
					webstr$=webstr$,rtrim$(Desc$),fdel$
				endif
			else
				! new order can use any type
				webstr$=str$(cnt),fdel$
				webstr$=webstr$,rtrim$(Desc$),fdel$
			endif
		
		endif ! has desc
		if webstr$
			if row>tmpcnt let tmpcnt=expandarray(E$,List$[])
			let list$[row]=Webstr$
			row=row+1
		endif
	excltype: ! exclude type
	next cnt
	!
	if row>tmpcnt let tmpcnt=expandarray(E$,List$[])
	List$[row]=esdel$ ! end section delimiter
	if orderid=-1 let orderid=0 ! reset
	!
  else
    include "src/callsuberr.inc"
  end try
end sub ! OrdTypeList
! ---------------------------------------------------------------------------------
Sub CalcShipDate() 
try
	
	dim keyzone$[40],SDATE$[50],t2$[7]
	dim 1%,flag,stat,warn
	dim 2%, cuttime,dt3[1],CURTIM[9]
	dim 3%,vdate,param[5] 
	MAT  READ #ctlc,182,84;CUTTIME;
	if cuttime<=0 let cuttime=24 ! always a day away -- from build order
	If credit exit sub
	clear zn.
	let keyzone$=ros.zone$
	if shipdateedit=0 ! ok to calc the shipdate
		let roh.shipdate=roh.orddate
	endif
	search #ch_zone,2,1;keyzone$,rec_zone,e
	if not(e)
		read record #ch_zone,rec_zone;zn.;
		let ros.truck=zn.trucknum
		if shipdateedit=0
			IF P61$[34,34]<>"Y" ! "cust/shiplist multi-zone 
		 		 let roh.shipdate=roh.orddate
				 if zn.leadtime<0 let zn.leadtime=1 ! always a day away NOT ACCORD TO 666
				 LET TMP$=roh.shipdate USING "&&&&&&"  ! yymmdd format                        
				 Call DateToJulian(1,tmp$,tmp$,e)
				 LET TMP3=TMP$[1,5] 
				 if orderid=0
					LET  sdate$="" 
					Call Time(SDATE$)
					LET CURTIM[0]=SDATE$[15,16] ! HOUR                                      
					LET CURTIM[1]=SDATE$[18,19]  ! MINUTER                                    
					LET CURTIM[2]=SDATE$[21,22]  ! SECOND                                    
					LET CURTIM[3]=CURTIM[0]*10000+CURTIM[1]*100+CURTIM[2]  ! TIME CALC                 
					IF CURTIM[3]>CUTTIME 
						LET TMP3=TMP3+1 ! a day away 
					Endif
				 endif ! check cut off on new order
				 LET TMP3=TMP3+zn.leadtime                                   
				 LET VDATE=TMP3;STAT=0;WARN=0;PARAM[0]=roh.wh;PARAM[1]=roh.div
				 CALL "validdate",vdate,STAT,WARN,PARAM[]  
				 let tmp3=vdate ! 1st check - see if lead time is on a holiday
	 			 if P60$[16,16]="Y" ! CALC SHIPDATE BY zone days
					if roh.ordtype<>4 and roh.ordtype<>15 and roh.ordtype<>16
						mat read #ch_zone,rec_zone,36;t2$; ! zone days
						x=0;x1=0;x1[1]=0 ! first see if any days ship!! avoid eloop
						for i=1 to 7 ! use matrix - not individ
						  if t2$[i,I]="Y" let x=x+1
						next i
						if x>0 ! has at least 1 day!
						ZNNXTDAY: ! loop until shipping day for zone
							x1=x1+1
						ZNNXTCHK: ! check it if holiday change
							x$=TMP3 USING "&&&&&"
							Call JulianToDate(1,X$,X$,E)
							IF NOT(E)
								J1 = X$[7,8] \ J2 = X$[1,2] \ J3 = X$[4,5]
								If J1 < 85 Let J1 = J1 + 100
								Z4 = J2 + 1 \ Z5 = Int(1 / Z4 + .7) \ Z6 = J1 - Z5 \ Z7 = Z4 + 12 * Z5
								Z8 = Int(Z7 * 30.6001) + Int(Z6 * 365.25) + J3 \ Z9 = Z8 - 7 * (Int(Z8 / 7))
								I = Z9 + 1
								If T2$[I,I] = "N"
									if x1>14 goto bpdloop ! give 14 tries - give up
									let tmp3=tmp3+1
									goto znnxtday
								 BPDLoop: ! end or bypass
								endif ! if Y - ok
								LET VDATE=TMP3;STAT=0;WARN=0;PARAM[0]=roh.wh;PARAM[1]=roh.div
								CALL "validdate",vdate,STAT,WARN,PARAM[]  
								If tmp3<>vdate and x1[1]<15 ! 2nd chk
									let tmp3=vdate ! 2nd check
									let x1[1]=x1[1]+1
									goto ZNNXTCHK
								Endif
							endif
						Endif ! zone has ship days
					Endif ! valid order type
				 Endif ! calc ship date
				 LET DT3[0]=tmp3 \ LET DT3[1]=tmp3\ LET FLAG=0              
				 CALL "JULIANUTIL",DT3[],TMP$,FLAG   ! julian to yymmdd                      
				 LET TMP3=TMP$      
				 LET roh.shipdate=TMP3  ! should be valid zone date too
				 !let roh.duedate=TMP3 
			endif ! multi-zone - no calc!
			if roh.shipdate<=0 let roh.shipdate=roh.orddate
			if roh.shipdate=0 exit sub ! no date - no calc!
			if roh.shipdate=999999 exit sub ! backorder - no calc!
			LET VDATE=roh.shipdate;STAT=1;WARN=0;PARAM[0]=roh.wh;PARAM[1]=roh.div
			CALL "validdate",vdate,STAT,WARN,PARAM[]  
		        let roh.shipdate=vdate
		        !let roh.duedate=vdate
		endif ! emd shipdate edit flag
	 endif ! end zone record on file
	
else
	include "src/callsuberr.inc"
end try
end sub ! calcshipdate
! ------------------------------------------------------------------
Sub findshiplist() ! getshiplistinfo **** subroutine
! need to have custid,orderid,shipcustid,shipcode
! customer file should have been read already 
try
	dim 2%,taxcode,taxtype,delchglvl,salesarea
	dim 2%,staxcode,staxtype
	dim 3%,rec_ship1,rec_sslsm
	dim keyship1$[40],keyslsm$[40]
	let taxcode=0;taxtype=0;delchglvl=0;salesarea=0
	keyship$=(shipcustid+(shipcode/10^6)) using "######.######"
	shipkey$=""
	mode$="="
	dirno=1
	ShipRec=FileGetShiplist(e$,Ch_Ship,mode$,dirno,KeyShip$,sh.)
	if shiprec>0 ! ship list found
		if not (orderid) 
			clear ros. ! initialize the ship variable
		endif
		let ros.ordnum=orderid
		let ros.name$=sh.name$
		let ros.address$=sh.address$
		let ros.address2$=sh.optaddress$
		let ros.city$=sh.city$
		let ros.state$=sh.state$
		let ros.zipcode$=sh.zipcode$[1,6]
		let ros.zip4$=sh.zipcode$[7,10]
		let ros.country$=sh.country$
		if not(shipcustid)
			let shipcustid=ros.shipcust
			if not (shipcustid)
				let shipcustid=roh.custnum
			endif
		endif
		let ros.shipedit=0
		if shipcode=0 let ros.shipedit=1 
  		if shipcode<>0 let ros.shipedit=2
		if shipcustid<>custid let ros.shipedit=4
		roh.shipvia$=sh.Routing$
		if TRIM$(ROH.shipvia$)="" let roh.shipvia$="OUR TRUCK"
		let ros.shipcode=shipcode
		let ros.shipcust=shipcustid
		let shipkey$=sh.shiplistnumber using "######.######"
		if rtrim$(sh.contact$)<>""
			let roh.contact$=sh.contact$+"                   "
		else
			if not(orderid)
				let roh.contact$=cust.contact$+"                    "
			endif
		endif
		if p61$[34,34]<>"Y" or orderid=0 ! not multi zone customer 
			let roh.StopNum=sh.sstop$
		endif
		if sh.saleszone<>0
			let roh.salesarea=sh.saleszone
			if ros.shipcust<>custid
				let roh.salesarea=0 ! 
			endif
		else
			if ros.shipcust=custid
				if not(roh.salesarea) let roh.salesarea=cust.custsaleszone
			endif
		endif
		if custid<>shipcustid
			if sh.zone$=" 0" or sh.zone$="  "
				let ros.truck=0
			endif
		endif
		let taxcode=sh.taxcode
		let taxtype=sh.taxtype
		let delchglvl=sh.deliverychrglvl
		if taxtype=0 or taxcode=0 ! no tax code let check default ship cust
			!if shipcode<>0 ! lets look in default
			!	let keyship1$=" ",keyship1$
			!	let keyship1$=shipcustid using "######.######"
			!	search #ch_ship,2,1;keyship1$,rec_ship1,e
			!	if not (e)
			!		if not(taxtype)
			!			read #ch_ship,rec_ship1,498;staxtype;
			!			let taxtype=staxtype
			!		endif
			!		if not(taxcode)
			!			read #ch_ship,rec_ship1,184;staxcode;
			!			let taxcode=staxcode
			!		endif
			!	endif
			!endif
		endif
		if not (taxcode) let taxcode=cust.taxcode
		if not (taxtype) let taxtype=cust.taxtype
		let roh.taxcode=taxcode
		let ros.shiptaxtype=taxtype
		if not (orderid) ! new order ! set the warehouse #
			if sh.ddiv>0 and sh.ddiv<100
				let roh.div=sh.ddiv
			endif
			if sh.defaultwhse<>0
				let roh.wh=sh.defaultwhse
			endif
		endif
		if roh.div<=0 let roh.div=1
		if not (roh.wh)
			let roh.wh=cust.defaultwhse
		endif
		if not (roh.wh)
			let roh.wh=prt.wh
		endif
		if not (roh.wh) let roh.wh=1 ! 
		let rot.delivchrglvl = sh.deliverychrglvl
		if sh.slsm<>0
			let keyslsm$=" ",keyslsm$
			let keyslsm$[1,3]=sh.slsm using "###"
			keyslsm$[5]=""
			search #ch_Sslsm,2,1;keyslsm$,rec_slsm,e
			if not(e)
				let roh.slsmnum=sh.slsm
			endif
		endif
		if not(roh.slsmnum) let roh.slsmnum=cust.salesmancode
		let roh.stopnum=sh.sStop$
		let ros.zone$=sh.zone$
		if not(orderid) and rtrim$(ros.zone$)=""
			let ros.zone$=cust.zonenumber$
		endif
		let ros.zone$=ros.zone$+"  "
		if p61$[34,34]="Y" ! multi-zone customer
			if not (shipcustid) let shipcustid=custid
			if not (roh.shipdate) let roh.shipdate=roh.orddate
			call "MXOHCSZONE",ros.shipcust,ros.shipcode,roh.orddate,roh.div,roh.wh,roh.shipdate,ros.zone$,roh.stopnum,IntCo
		endif				
		! now let's get the zone 
		let mode$="="
		let dirno=1
		clear zn.
		ZoneRec=FileGetZonefle(e$,Ch_Zone,mode$,dirno,ros.zone$,zn.)
		if zonerec>0
			let ros.truck=zn.trucknum
!			let ros.zone$=sh.zone$    task32992
			if trim$(zn.shipvia$)<>""
				let roh.shipvia$=zn.shipvia$
			endif
		else
			let ros.zone$="  " ! "00"? " 0"? what's default?
		endif
		if trim$(roh.shipvia$)=""
			LET ROH.SHIPVIA$="OUR TRUCK"+"       "
		endif
		
	else
		let shiprec=0
	endif ! end of shiprec
else
	include "src/callsuberr.inc"
end try
end sub
! ---------------------------------------------------------------------------------
Sub OrdHCreditCheck() 
try
	
	if shipcustid=0 let shipcustid=custid
	clear chan[]
	chan[1] =ctlc    ! cntrl file
	chan[2] =ch_cust ! customer file
	chan[3] = 0	 ! saract file ** not opened **
	chan[4] = 0      ! credit check file ** not opened ** ch_credck
	chan[5] =ch_roh	 ! order header
	chan[6] =ch_rot	 ! order total
	chan[7] =ch_ros	 ! order ship to
	work$=""
	flag=0
	if credit exit sub
	ordamt=0
	call getcredck(chan[],shipcustid,billcustid,rec_roh,ordamt,intCo,ReturnStatus,Message$,flag,work$)! need gp check	
	if flag
		clear cust.
		let keycust$=billcustid using "######"
		mode$="="
		dirno=1
		if billcustid>0
		CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
		else
			custrec=-1
		endif
		if CustRec>=0 ! record found
			If cust.CreditCode>0 and cust.CreditCode<=16
				let credcoded$=getcredcdd$(ctlc,cust.CreditCode,intco)
			endif
			let openordamt=cust.openorder+ordamt
			let arbal=cust.currentaragebal-cust.unappliedcredit+cust.agearamt1
			let arbal=arbal+cust.agearamt2+cust.agearamt3+cust.agearamt4
			if cust.terms>0 and cust.terms<=99
				let artermd$=getartermd$(ch_terms,cust.terms,intco)	
			endif
		endif
		let keycust$=billcustid using "######"
		mode$="="
		dirno=1
		CNoteRec=FileGetCustNotes(e$,Ch_CNotes,mode$,dirno,KeyCust$,cnotes.)
		if cnoterec<=0
			clear cnotes.
		endif
	endif
else
	include "src/callsuberr.inc"
end try
end sub ! ordhcreditcheck    
! ================== CalcFreightCharge =========================
Sub CalcFreightCharge() 
! should already have the order type and totals
! need dim for the the routine
dim 1%,calcfrgtflag,ftflg
dim 2%,maxwgt[11],dfltcost[11],mincost[11],maxcost[11],dfltchg[11]
dim 3%,wgt
try
	! calculate freight from tables                            
	calcfrgtflag=99                                            
	IF roh.ordtype=16 OR roh.ordtype=14 let calcfrgtflag=0     
	IF rot.subtot=0 let calcfrgtflag=0                         
	IF rot.totwgt=0 let calcfrgtflag=0                         
	IF roh.ordtype=8 let calcfrgtflag=0                        
	if calcfrgtflag<>0                                         
		IF roh.ordtype=2                                   
		      LET rec_tmp=174                            
		 ELSE                                               
			LET rec_tmp=173                            
		ENDIF                                              
		 MAT  READ #ctlc,rec_tmp,0;MAXWGT;                  
		MAT  READ #ctlc,rec_tmp,48;DFLTCOST;               
		MAT  READ #ctlc,rec_tmp,96;MINCOST;                
		MAT  READ #ctlc,rec_tmp,144;MAXCOST;               
		MAT  READ #ctlc,rec_tmp,192;DFLTCHG;               
		MAT  READ #ctlc,rec_tmp,240;FTFLG;                 
		LET WGT=rot.totwgt                                 
		FOR LEVEL=0 TO 6                                   
		  IF WGT<=MAXWGT[LEVEL] GOTO FOUND_LEVEL:    
		NEXT LEVEL                                         
		IF LEVEL>6 LET LEVEL=6
		FOUND_LEVEL: ! level found REM   
		IF FTFLG=-1 ! cwt                                                       
			 LET rot.frgtchrg=DFLTCHG[LEVEL]*(WGT/100)                       
			 LET rot.frgtcost=DFLTCOST[LEVEL]*(WGT/100)                      
		ELSE  !flat                                                            
				LET rot.frgtchrg=DFLTCHG[LEVEL]                                 
				LET rot.frgtcost=DFLTCOST[LEVEL]                                
		ENDIF                                                                   
		IF MINCOST[LEVEL] AND rot.frgtcost<MINCOST[LEVEL] LET rot.frgtcost=MINCOST[LEVEL]                                                                       
		IF MAXCOST[LEVEL] AND rot.frgtcost>MAXCOST[LEVEL] LET rot.frgtcost=MAXCOST[LEVEL]                                                                       
        ! send back freight charge --- rot.frgtchrg                             
        ! send back freight cost --- rot.frgtcost                               
	endif                                                                           
                                                                              
else
	include "src/callsuberr.inc"
end try
end sub ! calcfreightcharge      
!========= CALCDELIVERYCHARGE =========

Sub CalcDeliveryCharge() 
! should already have the order type and totals
! need dim for the the routine
dim 1%,calcflag,dflag[4]
dim 2%,dcost[11],dchrg[11]
Dim 3%
try
	let calcflag=99                                                                 
	IF P61$[36,36]="Y" let calcflag=0 ! deliv calc at invoice time                  
	if calcflag ! need to delete previous misc charge/cost                          
		FOR ctr=0 TO 9                                                          
			IF INT(FRA(rot.MiscChrgCode[ctr]*10)*10)=9 !syscalc deliv chrg  
			  LET rot.MiscChrg=rot.MiscChrg-rot.Mcharge[ctr,0]        
			  LET rot.TotMiscCost=rot.TotMiscCost-rot.Mcharge[ctr,1]
			endif
                        IF INT(FRA(rot.MiscChrgCode[ctr])*10) ! flagged for gp  
                                LET rot.MiscChrg4Prof=rot.MiscChrg4Prof-rot.Mcharge[ctr,0]                                                                      
                                LET rot.MiscCost4Prof=rot.MiscCost4Prof-rot.Mcharge[ctr,1]                                                                      
                        ENDIF                                                   
                        LET rot.MiscChrgCode[ctr]=0;rot.Mcharge[ctr,0]=0;rot.Mcharge[ctr,1]=0                                                                   
                                                                         
		NEXT ctr                                                                
	endif ! end deleting of previous charges                                        
	IF P61$[53,53]="N" ! if don't do backorders                                     
	  IF roh.BOctr<>0 OR roh.OrgOrd<>0 let calcflag=0!roh.spare4=h5[6]org ord#
	ENDIF                                                                           
	IF roh.shipvia$[1,1]="+" let calcflag= 0  
	if custom_customer$="GPG" or custom_customer$="ACME" ! jliu 202985
		if roh.shipvia$[1,3]<>"OUR" let calcflag=0
	Endif
	IF roh.OrdType=16 OR roh.OrdType=8 let calcflag=0                               
	if  Rot.DelivChrgLvl=0 let calcflag=0                                           
	if roh.OrdType<1 let calcflag=0                                                 
	if roh.OrdType>2 let calcflag=0    ! on pm native IF H5[7]>0 AND H5[7]<3 do calc
	if calcflag<>0                                                                  
		IF roh.OrdType=1                                                        
		     LET rec_tmp=172                                                     
		 ELSE                                                                    
		    LET rec_tmp=171                                                     
		ENDIF                                                                   
		 MAT  READ #1,rec_tmp,48;DCHRG;                                              
		MAT  READ #1,rec_tmp,96;DCOST;                                              
		MAT  READ #1,rec_tmp,240;DFLAG;                                             
		FOR ctr=0 TO 9 ! check to see if charge was manually calculated         
		IF INT(rot.MiscChrgCode[ctr])=DFLAG[1] let calcflag=0                 
		NEXT ctr                                                                
		REM! check for next avail misc code                                     
		FOR ctr=0 TO 9                                                          
			IF INT(rot.MiscChrgCode[ctr])=0 GOTO CALCDELIVCHG:                    
		NEXT ctr                                                                
		let calcflag=0                                                          
		CALCDELIVCHG: REM ok to calc delivery chargs                            
		 if ctr<0 let calcflag=0                                                 
		 if ctr>9 let calcflag=0                                                 
         if calcflag <>0                                                            
			 LET rot.MiscChrgCode[ctr]=DFLAG[1]+.09                          
			 IF INT(rot.MiscChrgCode[ctr])                                   
				read record #ch_misc,(INT(rot.MiscChrgCode[ctr]));misc.;        
				IF misc.distgp ! flag in gp calc                        
					LET rot.MiscChrgCode[ctr]=rot.MiscChrgCode[ctr]+.1      
				endif                                                                                             
				 IF DFLAG[0]=-3 ! flat rate                                      
					LET rot.Mcharge[ctr,0]=DCHRG[rot.DelivChrgLvl-1]        
					LET rot.Mcharge[ctr,1]=DCOST[rot.DelivChrgLvl-1]        
				 ELSE  ! CWT                                                    
					 LET rot.Mcharge[ctr,0]=FNR(DCHRG[rot.DelivChrgLvl-1]*(rot.TotWgt/100))                                                                  
					 LET rot.Mcharge[ctr,1]=FNR(DCOST[rot.DelivChrgLvl-1]*(rot.TotWgt/100))                                                                  
				 ENDIF                                                           
                                
				  LET rot.MCTXBL[ctr]=misc.taxable                              
				  IF ctax.mtax =0 LET rot.MCTXBL[ctr]=0
				  if rot.Subtot<>0 and rot.TaxMdseAmt=0 let rot.MCTXBL[ctr]=0 ! not taxable if no taxable mdse
			ENDIF                                                           
			 LET rot.MiscChrg=rot.MiscChrg+rot.Mcharge[ctr,0]                
			 LET rot.TotMiscCost=rot.TotMiscCost+rot.Mcharge[ctr,1]  
		     IF INT(FRA(rot.MiscChrgCode)*10) ! include in gross profit      
				 LET rot.MiscChrg4Prof=rot.MiscChrg4Prof+rot.Mcharge[ctr,0]                                                                              
				 LET rot.MiscCost4Prof=rot.MiscCost4Prof+rot.Mcharge[ctr,1]                                                                              
			ENDIF                                                           
		 ENDIF                                                                   
	Endif                                                                       
                                                                                                                                                                                                                                                             
                                                                              
else
	include "src/callsuberr.inc"
end try
end sub ! calcdeliverycharge                                           
!-----------------------------------------------------------------------
Sub OTypeProcess(flag,otchange)
! checking of order type - first whse/conswhse and ot 7,8,16
! flag=status of check: 0=okay, 1=no good
! otchange= if changed the ot - otchange=original Ordertype on file
! need to verify if products are allowed on the new order type - chkmtg
Try
 dim k2$[60],K3$[60]
	Dim 1%,PGOT[38]
	Dim 3%,WHMISC2[7]
	let ch_pgp=0
	flag=0 ! no problems
	if otchange=4 or otchange=8 or otchange=15 or otchange=16 or otchange=24 ! can never change from
		let returnstatus=0
		Let message$=message$+"Cannot change from order type "+Str$(OTChange)+". "
		goto OtChkDone ! once entered, you're stuck with it!?
	Endif
	If cust.ConsignWh>0 And cust.ConsignWh<100 ! whoops only ot 16 allowed!
		if cust.ConsignWh<conswh and roh.ordtype<>16
			let returnstatus=0
			Let message$=message$+"Customer may only be used for transfers. "
			goto OtChkDone
		Endif
	Endif
	If (roh.ordtype=7 or roh.ordtype=8) and cust.consignwh=0
		ReturnStatus=0
		Message$=Message$+"Customer not set up for consignment warehouse. "
		goto otchkdone
	Endif
	If roh.ordtype=16 and (cust.ConsignWh=0 or cust.ConsignWh>=ConswH) ! whoops no ot 16 allowed!
		let returnstatus=0
		Let message$=message$+"Customer is not set up for transfers. "
		goto OtChkDone
	Endif
	if (roh.ordtype=7 or roh.ordtype=8 or roh.ordtype=16) and cust.ConsignWh>0
		if roh.conswh=0 let roh.ConsWh=cust.ConsignWh ! only if not there already?
	Endif
	if (roh.ordtype=8 or roh.ordtype=16) and roh.ConsWh=roh.wh
		let returnstatus=0
		Let message$=message$+"Cannot transfer to same warehouse. "
		goto OtChkDone
	Endif
	IF P61$[54,54]="N" AND roh.ordtype=16 ! auto authorize
	  If roh.xferauth=0 ! not prev auth
		let roh.XferAuth=1;roh.AuthBy=-1;roh.AuthDate=currdate
	  Endif
	Endif
	if roh.ordtype<>7 and roh.ordtype<>8 and roh.ordtype<>16 let roh.ConsWh=0
	if credit ! only ot 1,2,3,6,10 and >27 allowed
		let x2=roh.ordtype ! new
		if x2=4 or x2=5 or x2=7 or x2=8 or x2=9 or (x2>10 and x2<27)
			let returnstatus=0
			Let message$=message$+"Invalid Order Type for Credits. "
			goto OtChkDone
		Endif
	Endif
	ostat=roh.status \ if ostat>80 let ostat=roh.OrgStatus
	! if orderid=6226 call programdump("/tmp/ordhtc!","")
	if ostat>1 ! see it ot9 from / to
		if otchange>0 and otchange<>9 and roh.ordtype=9 ! from any ot to 9
			returnstatus=0
			message$=message$+"Can not change to Order type 9 - Order is not status 1"
			goto OtChkDone
		Endif
		! can add more status driven checks here!
	Endif
	If not(otchange) goto otchkdone ! all new orders have no previous ot
IF roh.ordtype<0 or roh.ordtype>38 goto endchkotlines:
	CH_PGP=OpenFile(-9965,IntCo) \ if ch_pgp=-1 error 42 ! prodgrp
	let keyrol$=" ",keyrol$;keyrol$=orderid using "######"
	chkotlines: ! check if lines on sales order can go on for this group
	search #ch_rol,3,1;keyrol$,rec_rol,e
	if e<>0 goto endchkotlines:
	let tmp3=keyrol$[1,6]
	if tmp3<>orderid goto endchkotlines:
	read record #CH_ROl,rec_rol,0;rol.;
	if rol.NStkItem goto chkotlines: ! no nonstocks
	k2$=rol.ProdCode$+Blank$
	k2$[13]=rol.whse using "##"
	search #ch_prwh,2,1;k2$,rec_prwh,E
	if e goto chkotlines: ! no prodwhse rec
	mat read #ch_prwh,rec_prwh,846;WHMISC2;
	if whmisc2[0]>0 and whmisc2[0]<1000 ! if no prodgrp - it's not a millitem
		K3$=" ",k3$
		k3$=whmisc2[0] using "###" ! 3
		search #ch_pgp,2,1;k3$,r[4],e
		if not(e)
			mat read #ch_pgp,r[4],30;pgot;
			if not (pgot[roh.ordtype])
				returnstatus=0
				message$=message$+"Product "+rtrim$(rol.prodcode$)+" not allowed this type"
				goto OtChkDone		
			endif
		endif
	endif
	goto chkotlines:
	endchkotlines: ! 
	If not(otchange) goto otchkdone ! all new orders have no previous ot
	! now the changed ot code
	linesexist=0
	let keyrol$=" ",keyrol$;keyrol$=orderid using "######"
	search #ch_rol,3,1;keyrol$,rec_rol,e
	if not (e)
		let tmp3=keyrol$[1,6]
		if tmp3=orderid let linesexist=99
	endif
	let x2=roh.ordtype ! to make for less typing - x2=NEW ORDERTYPE
	Let returnstatus=1 ! ok so far
	IF X2=20 AND otchange<>20 let returnstatus=0
	IF P60$[25,25]<>"Y" AND (x2=21 OR x2=22) let returnstatus=0
	IF (x2<>6 AND x2<>10) AND (otchange=6 OR otchange=10) ! change from sample/donation
		roh.OrdDisc=0
		rot.OrdDisc=0;rot.OthChrg=0
	Endif
	If Linesexist ! first see if change allowed  X2=new ot, otchange=old ot
		IF x2=15 AND OTCHANGE<>15 let returnstatus=0
		IF X2=4 AND OTCHANGE<>4 let returnstatus=0
		IF (X2=21 OR X2=22) AND (otchange<>21 AND otchange<>22) let returnstatus=0
		IF (X2<>21 AND X2<>22) AND (otchange=21 OR otchange=22) let returnstatus=0
		IF (X2=7 OR X2=8) let returnstatus=0
		! any other lines exist and ot changed exceptions?
	Endif	
	if returnstatus=0 Let message$=message$+"Cannot change from order type "+Str$(OTChange)+". "
	OtChkDone: ! done
	if returnstatus=0 let flag=1 ! found a problem
else
	Flag=1 ! a problem
end try
end sub ! OTypeProcess                                           
!-----------------------------------------------------------------------
Sub ShipInfo()
! do shipping data
Try
	Dim 2%,InvDate,d4ship,D4ROUTING
	call dxget ("custid",Custid$)
	let custid=custid$
	call dxget ("orderid",orderid$)
	let orderid=orderid$
	call dxget ("shipcustid",shipcustid$)
	let shipcustid=shipcustid$
	!call dxget ("shipcode",shipcode$)
	!let shipcode=shipcode$
	call dxget ("shipdateedit",tmp$)
	let shipdateedit=tmp$ !(0- recalc, 1- do not recalc)
	call dxget ("droplistzonefle",tmp$)
	let ros.zone$=tmp$+"  "
	call dxget ("droplistordwh",tmp$)
	let roh.wh=tmp$
		call dxget ("shipdate",tmp$)
	if tmp$<>"999999"
		xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
		roh.shipdate=xdate$[3,8]
	else
		let roh.shipdate=999999
	endif
		call dxget ("candate",tmp$) ! quote=cancel not due
		xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
		roh.CancelDate=xdate$[3,8]
	call dxget ("droplistsslsm",tmp$)
	let roh.slsmnum=tmp$

	call dxget ("orderdate",tmp$) ! in mm/dd/yyyy
	xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
	let roh.orddate=xdate$[3,8]

	call dxget ("Attn",tmp$)
	let roh.contact$=tmp$+"                    " ! add spaces
	call dxget ("Truck",tmp$)
	let ros.truck=tmp$
	call dxget ("Stopnum",tmp$)
	let roh.stopnum=tmp$
        call dxget ("TaxCode",tmp$)
	let tmp3=tmp$
	if tmp3<1 or tmp3>7999
		let tmp3=roh.taxcode! save previous header tax code
	endif
	let roh.taxcode=tmp3
	if roh.taxcode<1 or roh.taxcode>7999
		let roh.taxcode=cust.taxcode
	endif
	call dxget ("TaxType",tmp$)
	let tmp3=tmp$
	if tmp3>0
		let ros.shiptaxtype=tmp3
	endif
	call dxget ("dclvl",tmp$)
	let rot.delivChrgLvl=tmp$
	call dxget ("salesarea",tmp$)
	let roh.salesarea=tmp$
	call dxget ("shipedit",tmp$)
	let ros.shipedit=tmp$
	call dxget ("routinglist",tmp$)
	let roh.shipvia$=tmp$+"                          "
	call dxget("PO",tmp$)
	let tmppo$=UCase$(tmp$)+Blank$
	if orderid and custid and Trim$(tmppo$)="" ! needs a po try for one
		let keycust$=custid using "######"
		let mode$="="
		let dirno=1
		let returnstatus=1
		let message$="OK"
		if custid>0
			CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
		Else
			clear cust.
		Endif
		keyroh$=" ",keyroh$
		keyroh$[1,7]=custid using "#######" 
		keyroh$[8,13]=orderid using "######"
		KEYROH$[14]="" ! no space
		mode$="=" ! search mode 2
		dir=2
		clear chan[]
		CHAN[0]=CH_ROH
		CHAN[1]=CH_ROS
		CHAN[2]=CH_ROT
		Rec_roh=filegetqohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
		if rec_roh<0
			if cust.porequiredflag=0 or cust.porequiredflag=2
				let tmppo$="VERBAL"
			endif
		else
			let tmppo$=roh.custpo$
		Endif
	Endif ! no po sent
	call dxget ("shipkey",tmp$)
	let shipkey$=""
	if rtrim$(tmp$)<>""
		let tmp4=tmp$
		if shipcustid=0 let shipcustid=int(tmp4)
		if shipcode=0 let shipcode=int(fra(tmp4)*10^6)
		if shipcode=0 let shipcode=int(fra(tmp4)*10^6)
		let shipkey$[1,6]=shipcustid using "######"
		let shipkey$[7,7]="."
		let shipkey$[8,13]=shipcode using "&&&&&&"
		shipkey$[14]=""
	endif
	if shipcustid=0
		let shipcustid=custid
		let shipcode=0
		let shipedit=0
	endif
	let keycust$=shipcustid using "######"
	let mode$="="
	let dirno=1
	let returnstatus=1
	let message$="OK"
	if shipcustid>0
	CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
	Else
		custrec=-1
	Endif
	if custrec<=0
		let returnstatus=0
		let message$="Customer "+str$(shipcustid)+" Not on File"
	else ! customer is on file
		if orderid=0 let roh.CustNum=custid
		call findshiplist()
		if sh.ddiv>0 and sh.ddiv<100
			let roh.div=sh.ddiv
		else
			if prt.div>0
				let roh.div=prt.div ! port default priority
			else
				if cust.division>0
					let roh.div=cust.division 
				endif
			endif
		endif

		if roh.div<=0 let roh.div=1
		if shiprec<=0
			if shipcode<>0
				let returnstatus=0
				let message$="Shiplist Customer "+keyship$+" Not on File"
			endif
			if shipcode=0 and shipedit=1
				let returnstatus=0
				let message$="Shiplist Customer "+keyship$+" Not on File"
			endif
			if returnstatus<>0
				if not(shipcustid) let shipcustid=roh.custnum
				if shipcustid<>custid let ros.shipedit=4 else let ros.shipedit=0
				let ros.shipcust=roh.custnum
				let ros.shipcust=shipcustid
				let ros.shipcode=shipcode
				let ros.name$=cust.name$
				let ros.address$=cust.addr1$
				let ros.address2$=cust.addr2$
				let ros.city$=cust.city$
				let ros.state$=cust.state$
				let ros.zipcode$=cust.zip4$[1,6]
				let ros.zip4$=cust.zip4$[7,10]
				let ros.country$=cust.country$
				LET ros.truck=0
				let ros.zone$=" ",ros.zone$
				let roh.shipvia$="OUR TRUCK"
				if p61$[34,34]="Y" ! multi-zone customer
					if not (shipcustid) let shipcustid=custid
					if not (roh.shipdate) let roh.shipdate=roh.orddate
					call "MXOHCSZONE",ros.shipcust,ros.shipcode,roh.orddate,roh.div,roh.wh,roh.shipdate,ros.zone$,roh.stopnum,IntCo
					if rtrim$(ros.zone$)<>""
						let cust.zonenumber$=ros.zone$
						!if source=251 let roh.shipdate=roh.orddate ! POS - no lead
						!let roh.duedate=roh.shipdate
					endif
				endif
				let mode$="="
				let dirno=1
				clear zn.
				ZoneRec=FileGetZonefle(e$,Ch_Zone,mode$,dirno,cust.zonenumber$,zn.)
				if zonerec>0
					let ros.truck=zn.trucknum
					let ros.zone$=cust.zonenumber$
					if trim$(zn.shipvia$)<>""
						let roh.shipvia$=zn.shipvia$
					endif
				else
					let ros.zone$="  " ! what's default? "00"? " 0"?
				endif
				let roh.taxcode=cust.taxcode
				let ros.shiptaxtype=cust.taxtype
				let roh.contact$=cust.contact$
				let roh.slsmnum=cust.salesmancode
				if not(ordnum)
					if cust.defaultwhse<>0
						let roh.wh=cust.defaultwhse
					else
						let roh.wh=prt.wh
					endif
				endif
				let roh.stopnum=cust.sStop
				if cust.CustomerDiscount
					let roh.orddisc=cust.CustomerDiscount
				endif
			endif ! *** end ship cust <> custid
		endif ! 
	endif ! customer on file
	if returnstatus<>0
		If roh.shipdate<>999999 and Not(Credit) call calcshipdate()
		!If Not(Credit) call calcshipdate()
	endif
	!!! send over headings
	Clear List$[]                                                         
	List$[0] = bsdel$ + "ShipInfo" + fdel$ ! section name
	webstr$="CustId",fdel$
	webstr$=webstr$,"ShipCustId",fdel$
	webstr$=webstr$,"OrderId",fdel$
	!webstr$=webstr$,"ShipCode",fdel$
	webstr$=webstr$,"ShipEdit",fdel$
	webstr$=webstr$,"Truck",fdel$
	webstr$=webstr$,"droplistdzonefle",fdel$ ! zone
	webstr$=webstr$,"TaxCode",fdel$
	webstr$=webstr$,"TaxDesc",fdel$
	webstr$=webstr$,"TaxType",fdel$ 
	webstr$=webstr$,"droplistsslsm",fdel$ ! sslsm
	webstr$=webstr$,"Attn",fdel$
		webstr$=webstr$,"ShipDate",fdel$
	webstr$=webstr$,"droplistordwh",fdel$
		webstr$=webstr$,"CanDate",fdel$
	webstr$=webstr$,"RoutingList",fdel$
	webstr$=webstr$,"StopNum",fdel$
	webstr$=webstr$,"SalesArea",fdel$
	webstr$=webstr$,"Dclvl",fdel$
	webstr$=webstr$,"Shipkey",fdel$
	webstr$=webstr$,"TaxTypeDesc",fdel$ ! customer tax type desc
	webstr$=webstr$,"droplistdivifle",fdel$
	webstr$=webstr$,"PO",fdel$
	let list$[1]=webstr$
	if returnstatus<>0 ! no errors send over the data
		webstr$=str$(roh.custnum),fdel$
		if not (ros.shipcust) let ros.shipcust=roh.custnum
		webstr$=webstr$,str$(ros.shipcust),fdel$
		webstr$=webstr$,str$(roh.ordnum),fdel$
		!webstr$=webstr$,str$(ros.shipcode),fdel$
		webstr$=webstr$,str$(ros.shipedit),fdel$
		webstr$=webstr$,str$(ros.truck),fdel$
		webstr$=webstr$,ros.zone$,fdel$
		if roh.taxcode<1 or roh.taxcode>7999
			let roh.taxcode=cust.taxcode
		endif
		webstr$=webstr$,str$(roh.taxcode),fdel$
		taxcoded$=gettaxcdd$(ch_tax,roh.TaxCode,intco)
		webstr$=webstr$,taxcoded$,fdel$
		webstr$=webstr$,str$(ros.shiptaxtype),fdel$
		WebStr$=WebStr$,Str$(roh.slsmnum),fdel$ ! salesman number
		Webstr$=webstr$,(roh.contact$),fdel$ ! contact
		if roh.shipdate
			if roh.shipdate<>999999
				let xdate$=pdate$(roh.shipdate)
			else
				let xdate$="999999"
			endif
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! ship date
		webstr$=webstr$,str$(roh.wh),fdel$ ! warehouse
		Let X2=roh.CancelDate
		if x2
			let xdate$=pdate$(x2)
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! due date
		if trim$(roh.shipvia$)="" let roh.shipvia$="OUR TRUCK"
		webstr$=webstr$,rtrim$(roh.shipvia$),fdel$
		webstr$=webstr$,str$(roh.stopnum),fdel$
		webstr$=webstr$,str$(roh.salesarea),fdel$
		webstr$=webstr$,str$(rot.delivchrglvl),fdel$
		webstr$=webstr$,shipkey$,fdel$
		custtaxtyped$=getcusttaxtyd$(ch_ctax,ros.shipTaxType,intco)
		webstr$=webstr$,custtaxtyped$,fdel$
		webstr$=webstr$,roh.div,fdel$
		webstr$=webstr$,tmppo$,fdel$ ! cust po
		let list$[2]=webstr$
	endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	               
	! status section *** last section ***
	!!! send over fields
else
	include "src/callsuberr.inc"! ERROR 
end try
end sub ! shipinfo
!----------------------------------------
Sub CheckImages()
Try 
	Dim keyvar$[50],itype$[2],image$[255]
	!
	clear list$[]
	List$[0]=bsdel$,"Images",fdel$
	List$[1]="keyvar",fdel$,"type",fdel$
	row=2
	!
	itype$="DR"	! scanned delivery receipt
	mode=0		! just check for existance
	!keyvar$[1,8]=invh.ordnum using "DR######"
	!keyvar$[9,14]=invh.custnum using "######"
	!tmp$=invh.orddate using "&&&&&&"
	Call DatetoJulian(1,tmp$,xdate$,e)
	if not(e) keyvar$[15,20]=Val(xdate$) using "######"	! julian orddate
	!
	Call GetImage(e$, intCo, IType$, mode, keyvar$, image$)
	!
	if image$
		list$[row]=keyvar$,fdel$,"Del Recpt",fdel$
		row=row+1
	end if
	!
	! add additional doc type here and add to list$ if needed
	!
	Call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
else
	include "src/callsuberr.inc"! ERROR 
end try
end sub !  checkimage
!--------------------------------------------------------------------------------
Sub OTMSDTIN()
! for ot 4 & 15 & 24 - up to 24 shipping dates coming in
 Try
	clear roh.shipdatelist[] ! clear 0-23 (pm s3[1-24])
	if roh.ShipTerm<>0 exit sub ! only for zero
	if roh.OrdType<>4 and roh.OrdType<>15 and roh.OrdType<>24 exit sub
	dim SPDate$[10],RSTRG$[150],WStrg$[160]
	dim 2%,spos,dpos
	dim 3%
	! we are getting this as ???
	call dxget("MSDATENT",tmp$) ! one string? comma sep?
	if Len(tmp$)<5 exit sub ! nothing in there
	SPOS=0;x=0;x1=0
	do
		SPDate$=tmp$[spos+1] to ",":DPOS  ! for some reason dpos always zero?
		let dpos=spos+Len(spdate$)+1  ! ie: 0+10+1=11, 11+10+1=22
		if len(spdate$)>5 ! had better be mm/dd/yyyy
			tmp1$=chkDateFrmt$(SPDate$) ! chk/convert to mm/dd/yyyy
			if tmp1$[1,1]<"0" and tmp1$[1,1]>"9" let tmp1$=""
			x$=formatdate2$(tmp1$) ! from mm/dd/yyyy to yyyymmdd
			Call DateToJulian(5,x$,tmp1$,e) ! from yyyymmdd to jjjjj
			If not(e) ! date ok
				RStrg$[x+1]=tmp1$[1,5]+" " ! set julian date into rstr$
				x=x+6;x1=x1+1
			Endif
		Endif
		if dpos>len(tmp$) exit do
		spos=dpos
	Loop
	if x=0 exit sub ! no dates recv'd
	call sortinstring(e,x1,6,rstrg$,wstrg$) ! will sort string lowest first
	if not(e) ! no problems  (x1 fields at 6 chars each)
		x=0;x1=0
		do
			tmp$=rstrg$[x+1,x+5]
			x2=tmp$
			if x2>0
				x$=jdate$(x2) ! from julian to MM/dd/yyyy
				tmp1$=x$[9,10]+x$[1,2]+X$[4,5]
				x2=tmp1$
				if x2>100
					roh.shipdatelist[x1]=x2
					x1=x1+1
				endif
			Endif ! of has jdate
			x=x+6 ! next sorted date
			if x>=Len(rstrg$) exit do ! all done
		Loop
	Endif
 else
	include "src/callsuberr.inc"! ERROR 
end try
End Sub ! OTMSDTIN
!--------------------------------------------------------------------------------
Function chkDateFrmt$(DIn$)
! see if date in is MM/DD/YY or MM/DD/YYYY
! if not make it MM/DD/YYYY
Try
	Dim DOut$[10]
	Dim 1%,Mth,Day
	Dim 3%,Yr
	If DIn$[1,2]="00" or UCase$(DIn$[1,4])="NONE" or DIn$="0"
	  Let DOut$=UCase$(DIn$)
	  Exit Function DOut$ ! no reformat - send back as is
	Endif
	Mth=DIn$[1,2];Day=Din$[4,5];Yr=DIn$[7]
	if Din$[2,2]="/" or DIn$[2,2]="-" ! 1 digit month
	  Let Mth=DIn$[1,1]
	  If DIn$[4,4]="/" or DIn$[4,4]="-" ! 1 digit day
	     Let Day=DIn$[3,3]
		 Let Yr=DIn$[5]
	  Else
	     Let Day=Din$[3,4] ! try 2 digit
		 Let Yr=DIn$[6]
	  Endif
	Endif
	X$=Mth Using "&&"
	X$[3,4]=Day Using "&&"
	If Yr>1000 ! 4
		X$[5]=Yr Using "&&&&"
	Else ! 2 digit
		If YR<67 let yr=2000+yr Else Let Yr=yr+1900
		X$[5]=Yr Using "####"
	Endif
	Dout$=X$[1,2]+"/"+X$[3,4]+"/"+X$[5]
 else
    include "src/callsuberr.inc"
  end try
end Function DOut$ ! chkDateFrmt$
!--------------------------------------------------------------------------------
Sub edttrk()
! pm records header access in edittrack
! Have etr.etaction & etr.prodcode$ SET UP ALREADY
! etr.prodcode$ = source prog or reason
  Try
	If etr.EtAction=0 EXIT SUB ! no action
	etr.OrdNum=roh.OrdNum
	etr.Status=roh.OrgStatus
	if etr.status<=0 let etr.status=roh.Status
	! etr.ProdCode$=whatever reason here
	etr.AccessCode$=Userid$+Blank$
	!	etr.EtAction=  10=delete, 14=access
	etr.InvNum=roh.InvNum
	etr.CustNum=roh.CustNum
	etr.Slsm=roh.SlsmNum
	etr.OrgOrdTot=rot.OrdTot
	etr.SpareNU$=blank$
	X1[0]=-1;X1[1]=-1 ! no files open - etrack/usercntrl
	Call MakeEdittrack(e$,IntCo,X1[],etr.)
  else
    include "src/callsuberr.inc"
  end try
end Sub ! edttrk
!--------------------------------------------------------------------------------
Sub GetHold()
  Try
	! call dxsave(0,"tmp/qhck.txt!")
	call dxget ("custid",Custid$)
	call dxget ("orderid",orderid$)
	let custid=custid$
	let orderid=orderid$
	LET returnstatus=1
	let message$="OK"
	If p61$[106,106]<>"Y" GOTO BYPGHLD ! NO HOLDS ON QUOTES
	keyroh$=" ",keyroh$
	keyroh$[1,7]=custid using "#######" 
	keyroh$[8,13]=orderid using "######"
	KEYROH$[14]="" ! no space
	mode$="=" ! search mode 2
	dir=2
	clear chan[]
	CHAN[0]=CH_ROH
	CHAN[1]=CH_ROS
	CHAN[2]=CH_ROT
	Rec_roh=filegetqohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
	if rec_roh<0
		let returnstatus=0
		let message$="Quote Number ",keyroh$[8,13]," Not On File"
	endif
	clear cust.
	let keycust$=custid using "######"
	mode$="="
	dirno=1
	if custid>0
		CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
	endif
	clear holddesc$[]
	clear holdpswd$[]
	clear holdcodeflag[]
	let orgamt=rot.MdseOrdAmt
	let orgcost=rot.TotOrdCost
	if returnstatus<>0 ! no errors have occured
		let billcustid=roh.billto
		for ctr=1 to 12
			read #ctlc,65,((ctr*16)-16);holddesc$[ctr];
			read #ctlc,66,((ctr*16)-16);holdpswd$[ctr];
		next ctr
		clear ex[]
		overpswd$=""
		Ch_exlist = openfile(1760,intCo) \ If Ch_exlist = -1 Error 42     !"order lines file
		if ch_exlist>0
			mat read #ch_exlist,0,0;overpswd$;
			mat read #ch_exlist,roh.ordtype,0;ex;
			try close #ch_exlist  Else Rem
		endif
		! unpack the holdcode into flag from bit flag field
		  tmp3=rot.holdcode 
		  !for ctr=1 to 12  ! start with ALL HOLDS CLEARED 
 			!LET holdcodeflag[ctr]=SGN(FRA(tmp3/2))
			!LET tmp3=INT(tmp3/2)
			!if ctr<>2 let holdcodeflag[ctr]=0 ! ONLY GP CHECK
		  !next ctr
		  call dxget ("orderamt",OrderAmt$) !!! MOTE
		  let amount=OrderAmt$
		  If p61$[136,136]="Y"  and roh.currfact<>0 and amount<>0
			factor=roh.currfact
			call currconvdown(amount,factor)
			amount=fnr(amount)
		  endif
		  let ordamt=amount
		  call dxget ("ordercost",tmp$) !!! MOTE
		  let amount=tmp$
		  If p61$[136,136]="Y"  and roh.currfact<>0 and amount<>0
			factor=roh.currfact
			call currconvdown(amount,factor)
			amount=fnr(amount)
		  endif
		  let tmp3=amount
		  let rot.subtot=ordamt
		  let rot.totshipcost=tmp3
 		if not (roh.holdover) ! and not(rot.holdcode) and roh.orgstatus=0! not in hold over ride 
		! do credit check - NOT ON QUOTES
			!call ordhcreditcheck()	
			!if flag
			!	let holdcodeflag[1]=1  ! failed credit check
			!endif
		! per the group - only flag[2] is used!?
		! do Total Quote gross profit check ! need ex variable
			if rtrim$(holdpswd$[2])<>"" ! has a password check for gp  
				if rot.subtot>0                                   
					let tmp3=0 ! for setting gtm
					if rot.subtot let tmp3=(rot.subtot-rot.TotShipCost)/rot.subtot*100                            
					if ex[15] if tmp3<ex[15] let holdcodeflag[2]=1
					if ex[16] if tmp3>ex[16] let holdcodeflag[2]=1                         
 					IF EX[1] IF (rot.subtot-rot.totshipcost)<EX[1] LET holdcodeflag[2]=1                  
					IF EX[2] IF (rot.subtot-rot.totshipcost)>EX[2] LET holdcodeflag[2]=1
				endif
			else
				let holdcodeflag[2]=0
			endif  
			let keyrol$=" ",keyrol$
			let keyrol$=orderid using "######"
			dir=1
			mode$=">"
			DO	! get gp on lines
				rec_tmp=filegetqolz(e$,ch_rol,mode$,dir,keyrol$,rol.)
				if rec_tmp<=0 exit do
				let tmp3=keyrol$[1,6]\if tmp3<>orderid exit do
				if rol.QtyShip<=0 goto bpgpln:
				if (roh.ordtype=21 or roh.ordtype=22) and keyrol$[7,9]="   " goto bpgpln
				let tmp3=rol.extshipamt-rol.extloadship
				if ex[3] if tmp3<ex[3] let holdcodeflag[2]=1
				if ex[4] if tmp3>ex[4] let holdcodeflag[2]=1
				if ex[17]<>0 if rol.extshipamt=0 let holdcodeflag[2]=1
				if rol.extshipamt<>0
					if ex[17] if fnr((tmp3/rol.extshipamt)*100)<ex[17] let holdcodeflag[2]=1
					if ex[18] if fnr((tmp3/rol.extshipamt)*100)>ex[18] let holdcodeflag[2]=1
				endif
				! check roh.orgstatus for invoice/credit memo hold
				if holdcodeflag[2]=0
					CALL LP1Chk()
				endif
			BPGPLN: ! BYPASS
			LOOP
			if rtrim$(holdpswd$[2])="" let holdcodeflag[2]=0
			if rtrim$(holdpswd$[7])="" let holdcodeflag[7]=0
			if rtrim$(holdpswd$[8])="" let holdcodeflag[8]=0
		endif
	endif
	if credit clear holdcodeflag[] ! no holds on credit
	if roh.ordtype=16 clear holdcodeflag[] ! no hold on wh xfer
	! section 1 - order header detail
	Clear List$[]                                                         
	List$[0] = bsdel$ + "OrdHoldHdr" + fdel$ ! section name
	webstr$="CustId",fdel$
	webstr$=webstr$,"OrderId",fdel$
	webstr$=webstr$,"HoldOverRide",fdel$
	webstr$=webstr$,"OverRidePassword",fdel$
	let list$[1]=webstr$
	if returnstatus<>0 ! no errors send over the data
		webstr$=str$(roh.custnum),fdel$
		webstr$=webstr$,str$(roh.ordnum),fdel$
		webstr$=webstr$,str$(roh.holdover),fdel$
		webstr$=webstr$,rtrim$(overpswd$),fdel$
		let list$[2]=webstr$
	endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	! section 2 - order hold code  fields
	Clear List$[]                                                         
	List$[0] = bsdel$ + "OrdHoldDet" + fdel$ ! section name
	webstr$="ID",fdel$
	webstr$=webstr$,"Description",fdel$
	webstr$=webstr$,"Password",fdel$
	webstr$=webstr$,"Value",fdel$
	let list$[1]=webstr$
	if returnstatus<>0 ! no errors send over the data
		for ctr=1 to 12
			webstr$=str$(ctr),fdel$
			webstr$=webstr$,holddesc$[ctr],fdel$ ! hold code description
			webstr$=webstr$,rtrim$(holdpswd$[ctr]),fdel$ ! hold code password
			webstr$=webstr$,str$(holdcodeflag[ctr]),fdel$ ! hold code value
			let list$[ctr+1]=webstr$
		next ctr
	endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	BYPGHLD: ! bypass hold
	! status section *** last section ***
 else
    include "src/callsuberr.inc"
  end try
end Sub ! gethold
!--------------------------------------------------------------------------------
Sub SavHold()
  Try
	call dxget ("SOURCE",tmp$)
	if p61$[106,106]<>"Y" let source=207 ! tmp$ ! force no update!
	if source=207
		let returnstatus=0
		message$="No Update. No Quote Holds" ! Inquiry Only"
		goto EndOrdHoldSubmit
	endif
	call dxget ("custid",Custid$)
	call dxget ("orderid",orderid$)
	call dxget ("HoldOverRide",tmp$)
	
	let custid=custid$
	let orderid=orderid$
	LET returnstatus=1
	let message$="OK"
	keyroh$=" ",keyroh$
	keyroh$[1,7]=custid using "#######" 
	keyroh$[8,13]=orderid using "######"
	KEYROH$[14]="" ! no space
	mode$="=" ! search mode 2
	dir=2
	clear chan[]
	CHAN[0]=CH_ROH
	CHAN[1]=CH_ROS
	CHAN[2]=CH_ROT
	Rec_roh=filegetqohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
	if rec_roh<0
		let returnstatus=0
		let message$="Quote Number ",keyroh$[8,13]," Not On File"
	else
		if returnstatus<>0
			call verifystat()
			IF returnstatus=99 GOTO ENDORDHOLDSUBMIT
		endif
		call dxget ("HoldOverRide",tmp$)
		let roh.holdover=tmp$
		if roh.orgstatus=0 and roh.spare2=0
			let roh.spare2=1 ! edit status
		endif
		Write Record # ch_roh,rec_roh;roh.;
		clear holdcodeflag[]
		for ctr=1 to 12
			call dxget ("HoldValue"+str$(ctr),tmp$)
			let holdcodeflag[ctr]=tmp$
		next ctr
		! REM PACK CHAIN TYPE FROM HOLDCODEFLAG[] 
		if credit clear holdcodeflag[]
		if roh.ordtype=16 clear holdcodeflag[]
		let tmp3=0
		for ctr=0 to 11
			IF holdcodeflag[ctr+1] LET tmp3=tmp3+2^ctr   
		next ctr
		let rot.holdcode=tmp3
		Write Record #ch_rot,roh.totrec;rot.;
	endif            
    EndOrdHoldSubmit: !     	
	clear list$[]
	List$[0]=bsdel$,"OrdHoldSubmit",fdel$
	WebStr$="OrderId",fdel$
	Webstr$=webstr$,"",fdel$
	webstr$=webstr$,"ORDERAMT",fdel$
	webstr$=webstr$,"ORDERCOST",fdel$
	List$[1]=WebStr$
	WebStr$=str$(orderid),fdel$
	wEBSTR$=WEBSTR$,"",FDEL$
	let amount=rot.MdseOrdAmt
	If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$,str$(amount),fdel$ ! let amount=rot.MdseOrdAmt
	amount=rot.totordcost
	If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$,str$(amount),fdel$ !rot.totordcost
	LIST$[2]=Webstr$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! status section
  else
    include "src/callsuberr.inc"
  end try
end Sub ! Savhold
!--------------------------------------------------------------------------------
Sub GetTotals()
! get the totals
  Try
	dim keyroc$[50],FRTOVRRD$[8],2%,FRTADDON
	Dim 3%
	let returnstatus=1
	let message$="OK"
	clear list$[]
	!call programdump("/tmp/ordh0!","")
	! section 1 - Misc Charges Droplist
	List$[0]=bsdel$,"MiscChargeDroplist",fdel$
	WebStr$="ID",fdel$
	WebStr$=Webstr$,"Desc",fdel$
	Webstr$=Webstr$,"Taxable",fdel$
	Webstr$=Webstr$,"GP",fdel$
	List$[1]=WebStr$
	let ctr=2
	let tmpcnt=maxcnt
	let rec_tmp=(chf(ch_misc))-1
	for rec_misc=1 to rec_tmp
		read record #ch_misc,rec_misc;misc.;
		if misc.type=2 ! order -- not for po's
			if rtrim$(misc.desc$)<>""
				let webstr$=str$(rec_misc),fdel$
				let webstr$=webstr$,RTrim$(misc.desc$),fdel$
				let tmp$="N"
				if misc.taxable<>0 let tmp$="Y"
				let webstr$=webstr$,tmp$,fdel$
				let tmp$="N"
				if misc.distgp<>0 let tmp$="Y"
				let webstr$=webstr$,tmp$,fdel$
				let list$[ctr]=Webstr$
				let ctr=ctr+1
				If ctr > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
				! check the count  neex to expand variable
			 endif
		endif
	next rec_misc
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	! section 2 - tax code droplist
	! tmpline$="ID",fdel$,"Desc",fdel$,"TaxRate",fdel$ 
	 Call FileDropListTaxCode(e$,List$[],maxcnt,Ch_Tax) 
	 Call AddToStr(e$,rstr$,List$[])  
	! Call AddToStr(e$,rstr$,esdel$) ! end of section
	! section 3 - Order Total
	call dxget ("CUSTID",Custid$)
	call dxget ("ORDERID",orderid$)
	let custid=custid$
	let orderid=orderid$
	call dxget ("SOURCE",tmp$)
	let source=tmp$
	LET returnstatus=1
	let message$="OK"
	keyroh$=" ",keyroh$
	keyroh$[1,7]=custid using "#######" 
	keyroh$[8,13]=orderid using "######"
	KEYROH$[14]="" ! no space
	mode$="=" ! search mode 2
	dir=2
	clear chan[]
	CHAN[0]=CH_ROH
	CHAN[1]=CH_ROS
	CHAN[2]=CH_ROT
	Rec_roh=filegetqohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
	if rec_roh<0
		let returnstatus=0
		let message$="Quote Number ",keyroh$[8,13]," Not On File"
	endif
	!call programdump("/tmp/ordh2!","")
	if returnstatus<>0
		clear cust.
		let keycust$=custid using "######"
		mode$="="
		dirno=1
		if custid>0
		CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
		else
			custrec=-1
		endif
		if CustRec<0! record found
			 let returnstatus=0
			 let message$="Customer "+str$(custid)+" Not on File"
		else
			  Mat Read #ch_cust,custrec,544;CFIN;
		endif
		let keyslsm$=" ",keyslsm$
		let keyslsm$[1,3]=roh.slsmnum using "###"
		keyslsm$[5]=""
		let mode="="
		dirno=1
		SlsmRec=FileGetsSlsmz(e$, Ch_sslsm , mode$ ,dirno ,KeySlsm$ ,Sslsm.)
		if slsmrec<0
			let returnstatus=0
			let message$="SalesPerson "+str$(roh.slsm)+" Not on File"
		endif
		if returnstatus<>0
			clear ch[] ! channels for files sent to order total
			LET CH[2]=CH_ZONE;CH[3]=CH_PROD;CH[4]=CH_COMCDE;CH[5]=CH_CUST             
			LET CH[6]=CH_PRWH;CH[7]=CH_ROS;CH[8]=CH_ROH;CH[9]=CH_ROT;CH[10]=CH_ROL    
			LET CH[11]=CH_SPRODDESC;CH[12]=CH_CTAX;CH[13]=CH_SSLSM;CH[14]=CH_TAX
			LET CH[15]=CH_SPRODLOT;CH[16]=CH_SORDLOT;CH[17]=CH_CCODE;ch[19]=ch_misc
			clear s9[]
			let s9[0]=orderid
			let s9[1]=intco
			let s9[2]=roh.slsm
			let s9[4]=source ! order entry program #
			If S9[4]=0 and roh.orgstatus=0 and roh.spare2=0
				let S9[4]=281 ! new order (could be 207!)
			endif
			if roh.orgstatus>0 and roh.orgstatus<5 let S9[4]=283 ! NOT ENTRY
			IF S9[4]=0 LET S9[4]=283
			R5 = custrec ;H1 = REC_ROH;V1 = slsmrec
			clear param[]
			param[0]=0 !cred check 
			param[1]= 0 ! no credit check 0 !no cred check
			! If roh.orgstatus=0 let param[1]=1 ! credit check new order
			param[2]=0 !no exception check
			param[3]=1 !write total data out
			param[4]=0 !no retotal of customer on order
			! if p60$[40,40]="S" let param[4]=1! retotal on order if based on shipped
			param[5]=0 !do no clear manual edits
			param[6]=1 !you can clear cash stuff
			Param[9]=0 ! ok to calc delivery
			If S9[4]=283 let Param[9]=99 ! edit - no calc
			Param[9]=99 ! per task 35678 - NO DEL CHRG ON QUOTES?
			PARAM[10] = 99! ar term misc cost charge   - bypass 
			MAT  READ #CH_ROT,roh.totrec,0;T1       
			MAT  READ #CH_ROT,roh.totrec,8;T2       
			MAT  READ #CH_ROT,roh.totrec,168;MCODE  
			MAT  READ #CH_ROT,roh.totrec,208;MCHARGE
			MAT  READ #CH_ROT,roh.totrec,328;TOT    
			MAT  READ #CH_ROT,roh.totrec,358;MCTXBL 
			MAT  READ #CH_ROT,roh.totrec,378;DCLVL  
			if s9[4]=281 and t2[24]<>0 let param[9]=99 ! edit in entry
			let orgamt=t2[24]
			let orgcost=t2[14]
			!call programdump("/tmp/ordh3!","")
			Call "ORDERTOTAL",S9[],H1,PARAM[],ch[],T1[],T2[],MCODE[],MCHARGE[],TOT[],MCTXBL[],DCLVL,R5,V1,CFIN[]
			read record #ch_roh,rec_roh;roh.
			read record #ch_rot,roh.totrec;rot.
			read record #ch_ros,roh.shiprec;ros.
			if roh.ordtype=16 ! whse xfer - no totals!
				let rot.TaxPct=0;rot.OrdDisc=0;rot.MiscChrg=0 ! 2-4
				rot.FrgtChrg=0;rot.OthChrg=0;rot.TaxAmt=0 ! 5-7
				rot.PrepaidFrgt=0;rot.FrgtCost=0 ! 19,20
				rot.OrdTot=0;rot.Subtot=0 ! 0,1
				rot.TotMiscCost=0;rot.MiscChrg4Prof=0;rot.MiscCost4Prof=0
				rot.TotChrgTax=0
				clear rot.MiscChrgCode[]
				clear rot.MCharge[]
				clear rot.MCTxbl[]
			Endif
			if roh.ordtype=6 or roh.ordtype=10 ! sample/donation
				let rot.OthChrg=0-rot.TaxAmt
				roh.OrdDisc=100;rot.OrdDisc=rot.Subtot
			Endif
			! calculate the commission 
			! IF source<>207 ! NOT ON QUOTES!
			!	clear s9[]
			!	let s9[0]=orderid
			!	let s9[1]=intco
			!	let s9[2]=roh.slsm
			!	let s9[4]=201 ! order entry program #
			!	if credit let s9[4]=241
			!	if roh.status=96 let s9[4]=223
			!	if roh.status=94 let s9[4]=231
			!	R5 = custrec ;H1 = REC_ROH;V1 = slsmrec
			!	Clear Ch[] ! channels for files sent to mxslscom5                   
			!	Ch[1] = ctlc;Ch[3] = Ch_prod;Ch[4] = Ch_comcde;Ch[5] = ch_cust      
			!	Ch[6] = ch_prwh;Ch[7] = ch_ros;Ch[8] = ch_roh;Ch[9] = ch_rot;Ch[10]=CH_ROL                                          
			!	Ch[11] = CH_SPRODDESC;Ch[12] = ch_ctax;Ch[13] = ch_sslsm            
			!	Call "MXSLSCOM5",S9[],Ch[],R5,H1,V1,CFIN[]
			!endif
			if roh.ordtype=5 and roh.CmInvHist=0
				!if not(credit)
					call fut208()
				!Endif
			Endif
		endif ! returnstatus<>0
		!call programdump("/tmp/ordh4!","")
	endif
	dochchk=1 ! do it 
    if credit let dochchk=0
    if roh.ordtype=20 or roh.ordtype=16 or roh.ordtype=8 let dochchk=0 ! not on frgt/xfer
    if roh.holdover<>0 let dochck=0
	if source=207 let dochchk=0
	if custom_customer$="ACME" and source=231 and roh.ordtype=2 let dochchk=0 ! 128990 - no credit check on directs
	Read Record #ch_rot,roh.totrec;rot.;
	if orgamt>=rot.mdseordamt let dochck=0
	if rot.mdseordamt<0 let dochck=0
	if dochck<>0
		! unpack the holdcode into flag from bit flag field
		tmp3=rot.holdcode 
		for ctr=1 to 12   
 			LET holdcodeflag[ctr]=SGN(FRA(tmp3/2))
			LET tmp3=INT(tmp3/2)
		next ctr   
		!if not(param[1]) ! no credit check prior
		!	read #ctlc,66,0;holdpswd$[1];! credit check
		!	if rtrim$(holdpswd$[1])<>"" ! ! do credit check
		!		call ordhcreditcheck()	
		!		if flag and rtrim$(holdpswd$[1])<>"" ! has a password check for credit
		!			let holdcodeflag[1]=1;aflag[1]=1  ! failed credit check
		!		endif
		!	else
		!		let holdcodeflag[1]=0;aflag[1]=0
		!	endif
		!endif
		call OnHoldChk()
		tmp3 = 0                                            
		For ctr = 0 To 11                                   
			If holdcodeflag[ctr + 1] Let tmp3 = tmp3 + 2 ^ ctr
		Next ctr                                            
		rot.holdcode = tmp3
		Write Record #ch_rot,roh.totrec;rot.;
	else
		if roh.holdover=0 and source<>207! no override
			if orgamt<>rot.mdseordamt or orgcost<>rot.totordcost
				! need to check if amt or cost changes for gp
				call onholdchk()
				tmp3 = 0                                            
				For ctr = 0 To 11                                   
					If holdcodeflag[ctr + 1] Let tmp3 = tmp3 + 2 ^ ctr
				Next ctr                                            
				rot.holdcode = tmp3
				Write Record #ch_rot,roh.totrec;rot.;
			endif
		endif
	endif ! dochck
	clear list$[]
	List$[0]=bsdel$,"OrderTotalDisp",fdel$
	WebStr$="OrderId",fdel$
	WebStr$=webstr$,"TotUnitsOrd",fdel$
	WebStr$=webstr$,"TotUnitsSell",fdel$
	WebStr$=webstr$,"TotWeight",fdel$
	WebStr$=Webstr$,"TotCubes",fdel$
	Webstr$=Webstr$,"Totcharge4prof",fdel$
	Webstr$=Webstr$,"Totcost4prof",fdel$
	Webstr$=webstr$,"HoldStatus",fdel$
	Webstr$=webstr$,"ShipDate",fdel$
	Webstr$=webstr$,"Zone",fdel$
	webstr$=webstr$,"ZoneDesc",fdel$
	webstr$=webstr$,"Subtotal",fdel$
	webstr$=webstr$,"TaxableMerch",fdel$
	webstr$=webstr$,"TaxableTotCharges",fdel$
	webstr$=webstr$,"TaxPct",Fdel$
	webstr$=webstr$,"TaxAmt",fdel$
	webstr$=webstr$,"TotShipMerchCost",fdel$
	webstr$=webstr$,"TotFrgtCost",fdel$
	webstr$=webstr$,"TotMiscCost",fdel$
	webstr$=webstr$,"TotFrgtAdd",fdel$
	
	webstr$=webstr$,"DelivChrgLvl",fdel$
	webstr$=webstr$,"LineTax",fdel$
	! need to add morrisette (now std) fields
	WebStr$=webstr$,"MINGPDol",fdel$ ! min gp$ (hard code & custom morrisette)
	Webstr$=webstr$,"CUSTOMCUST",fdel$ ! - per 16805 - send custom customer
	Webstr$=webstr$,"CUSTQUOTE",fdel$ ! multi-customer quotes
	webstr$=webstr$,"DepositAmt",fdel$ !
	webstr$=webstr$,"Currency",fdel$
	List$[1]=WebStr$
	WebStr$=str$(orderid),fdel$
	Webstr$=webstr$+LTrim$(rot.totordqty Using "----------.##") + fdel$   
	Webstr$=webstr$+LTrim$(roh.totsellunits Using "----------.##") + fdel$ 
	Webstr$=webstr$+LTrim$(rot.totwgt Using "----------.##") + fdel$ 
	Webstr$=webstr$+LTrim$(rot.totcubes Using "----------.##") + fdel$ 
	!Webstr$=webstr$+LTrim$(roh.totdol4prof Using "----------.##") + fdel$
	!Webstr$=webstr$+LTrim$(roh.totcost4prof Using "----------.##") + fdel$
	let amount=roh.totdol4prof
	If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	Webstr$=webstr$+RTrim$(amount Using "----------.##") + fdel$ ! roh.totdol4prof
	let amount=roh.totcost4prof
	If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	Webstr$=webstr$+RTrim$(amount Using "----------.##") + fdel$ ! roh.totcost4prof
	if credit let rot.holdcode=0 ! no holds on credit
	if roh.ordtype=16 let rot.holdcode=0 ! no holds on whs xfer
	If p61$[106,106]<>"Y" let rot.holdcode=0 ! no holds
	If rot.holdcode<>0
		Webstr$=webstr$+"On Hold",fdel$
	else
		Webstr$=webstr$+" "+fdel$
	endif
	If roh.shipdate <> 999999                          
	  xdate$ = pdate$(roh.shipdate)                    
	Else                                               
	  xdate$ = "999999"                                
	End If                                                              
	Webstr$ = Webstr$,RTrim$(xdate$),fdel$ ! ship date 
	Webstr$=webstr$+ros.zone$,fdel$! zone
	zonerec = FileGetZonefle(e$,Ch_Zone,mode$,dirno,ros.zone$,zn.)
	If zonerec < 0                                               
		let zn.desc$="Zone Not On File"
	endif
	webstr$=webstr$+zn.desc$+fdel$
	let amount=rot.subtot
	If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	Webstr$=webstr$+LTrim$((amount) Using "----------.##") + fdel$ ! rot.subtot
	let amount=rot.taxmdseamt
	If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0 
		factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	Webstr$=webstr$+LTrim$((amount) Using "----------.##") + fdel$ ! rot.taxmdseamt
	let amount=(rot.taxable-rot.taxmdseamt)
	If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	Webstr$=webstr$+LTrim$((amount) Using "----------.##") + fdel$ ! (rot.taxable-rot.taxmdseamt)
	Webstr$=webstr$+LTrim$((rot.taxpct) Using "---.####%") + fdel$
	let amount=rot.taxamt
	If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	Webstr$=webstr$+LTrim$((amount) Using "----------.##") + fdel$ ! rot.taxamt
	! total cost ! need to check security
		let amount=rot.totshipcost
    If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$+ Ltrim$(amount Using "----------.##") + fdel$ ! rot.totshipcost
	let amount=rot.frgtcost
	If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$+ Ltrim$(amount Using "----------.##") + fdel$ ! rot.frgtcost
	let amount=rot.totmisccost
	If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$+ Ltrim$(amount Using "----------.##") + fdel$ ! rot.totmisccost
	let amount=roh.totfrgtadd
	If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$+ Ltrim$(amount Using "----------.##") + fdel$ ! roh.totfrgtadd
	Webstr$=webstr$+RTrim$(rot.delivchrglvl using "##")+fdel$
	let linetax=0
	let amount=0
	if P60$[42,42]="Y" and rot.subtot<>0  ! tax by line
		linetax=rot.taxamt-rot.totchrgtax
		let amount=linetax
		If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			factor=roh.currfact
			call currconvup(amount,factor)
			let amount=fns(amount)
		endif
	endif
	webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! linetax
	webstr$=webstr$,"",fdel$ ! min gp% - NOT ON QUOTES
	webstr$=webstr$,Custom_customer$,fdel$ ! per 16805 - send customer
	tmp$="N" \ if p61$[75,75]="Y" let tmp$="Y"
	webstr$=webstr$,tmp$,fdel$ ! multi-cust quotes
	webstr$=webstr$,"",fdel$ ! deposit
	If p61$[136,136]="Y" and roh.currid<>0
		let keycurr$=" ",keycurr$
		!let keycurr$=roh.currid using "####"
		search #ch_curr,2,1;keycurr$,rec_curr,e
		if not(e)
			Read Record #ch_curr,rec_curr;curr.;
			! let tmp$=roh.currid using "####"
			let tmp$=tmp$+" "
			let tmp$=tmp$+rtrim$(curr.desc$)
			let webstr$=webstr$,tmp$,fdel$
		else
			let webstr$=webstr$,"",fdel$
		endif
	else
		let webstr$=webstr$,"",fdel$ ! currency
	endif


	LIST$[2]=Webstr$
	
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	! salesman section
	clear list$[]
	List$[0]=bsdel$,"OrdTotSlsmComm",fdel$
	webstr$="SlsmID",fdel$
	webstr$=webstr$,"SlsmName",fdel$
	webstr$=webstr$,"SlsmCommPct",fdel$
	webstr$=webstr$,"SlsmCommAmt",fdel$
	!if p61$[79,79]="Y" ! native conditional - web always send header
		webstr$=webstr$,"SlsmCommGPDol",fdel$
		webstr$=webstr$,"SlsmCommGPPct",fdel$
	!Else
	!Endif ! SENT ONLY BECAUSE THEY ARE ON ORDERS
	list$[1]=webstr$
	let row=2
	!for ctr=0 to 4 ! salesperson code
	!	if roh.slsm[ctr]<>0
	!		webstr$=Rtrim$(roh.slsm[ctr] Using "###") + fdel$
	!		let slsmname$=""	
	!		if roh.slsm[ctr]>0 and roh.slsm[ctr]<=999
	!			let slsmname$=getslsmname$(ch_sslsm,roh.slsm[ctr],intco)	
	!		endif
	!		webstr$=webstr$+rtrim$(slsmname$)+fdel$
	!		webstr$=webstr$+Rtrim$(roh.slsmpct[ctr] Using "###.##%") + fdel$
	!		webstr$=webstr$+Rtrim$(roh.slsmcomm[ctr] using "--------#.##")+fdel$
	!		let list$[row]=webstr$
	!		let row=row+1
	!	endif
	! next ctr
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	! end salesman section
	!call programdump("/tmp/ordh5!","")
	! section for edit fields
	clear list$[]
	List$[0]=bsdel$,"OrderTotalEdit",fdel$
	WebStr$="TaxCode",fdel$
	WebStr$=webstr$,"TaxDesc",fdel$
	Webstr$=webstr$,"FrgtChrg",fdel$
	Webstr$=webstr$,"OrdDisc",fdel$
	
	Webstr$=webstr$,"Other",fdel$
	Webstr$=webstr$,"PrepaidFrgt",fdel$
	Webstr$=webstr$,"FrgtCost",fdel$
	Webstr$=webstr$,"OrdDiscPct",fdel$	
	! add here - morrisette (now standard fields) ORDERS ONLY-NOT QUOTES!!!
	webstr$=webstr$,"FrgtAddonPct",fdel$ !! freight addon % - exc ot 2,6,8,16
	let list$[1]=webstr$
	! edits fields
	if roh.taxcode<1 or roh.taxcode>7999
		let roh.taxcode=cust.taxcode
	endif
	Webstr$=str$(roh.taxcode),fdel$
	taxcoded$=gettaxcdd$(ch_tax,roh.TaxCode,intco)
	webstr$=webstr$,taxcoded$,fdel$
	let amount=rot.frgtChrg
	If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$ + Rtrim$(amount Using "----------.##") + fdel$ ! rot.frgtChrg
	if roh.ordtype=6 or roh.ordtype=10
		let rot.orddisc=rot.subtot ! donation/sample 100% discount
		roh.orddisc=100
	Endif
	if roh.orddisc<>0 ! discount % - recalc the discount amount
		let rot.orddisc=ABS(FNR(roh.orddisc*rot.subtot/100))*SGN(rot.subtot)
	endif
	let amount=rot.orddisc
	If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! rot.orddisc
	let amount=rot.othchrg
	If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! rot.othchrg
	let amount=rot.prepaidfrgt
	If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! rot.prepaidfrgt
	let amount=rot.frgtcost
	If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! rot.frgtcost
	let amount=roh.orddisc
	If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$+ str$(amount)+fdel$ ! roh.orddisc
	x3=0 ! FrtAddon ! NOT ON QUOTES
	if credit let x3=0 ! NOT ON CREDITS
	If roh.ordtype=2 or roh.ordtype=6 or roh.ordtype=8 or roh.ordtype=16 let x3=0
	let amount=x3
	If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$,Str$(amount),fdel$ ! freight addon 
	LIST$[2]=Webstr$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! misc charge section
	clear list$[]
	List$[0]=bsdel$,"OrderTotMisc",fdel$
	webstr$=""
	webstr$=webstr$,"MiscId",fdel$
	webstr$=webstr$,"MiscDesc",fdel$
	webstr$=webstr$,"MiscChrg",fdel$
	webstr$=webstr$,"MiscCost",fdel$
	webstr$=webstr$,"MiscTax",fdel$
	webstr$=webstr$,"MiscGP",fdel$ ! not edittable
	webstr$=webstr$,"MiscDel",fdel$ ! not edittable
	list$[1]=Webstr$
	let row=2
	mat read #ch_rot,roh.totrec,208;mcharge;
	mat read #ch_rot,roh.totrec,168;MCODE; 
	mat read #ch_rot,roh.totrec,358;MCTXBL;
	!call programdump("/tmp/ordh6!","")
	for ctr=0 to 9
		if mcode[ctr]>0
			webstr$=""
			webstr$=Rtrim$(mcode[ctr] Using "###") + fdel$
			let tmp$=""
			read record #ch_misc,mcode[ctr];misc.;
			let tmp$=misc.desc$
			webstr$=webstr$+Rtrim$(tmp$)+fdel$
			let amount=mcharge[ctr,0] 
			If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
				factor=roh.currfact
				call currconvup(amount,factor)
				let amount=fns(amount)
			endif
			webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! mcharge[ctr,0] 
			let amount=mcharge[ctr,1] 
			If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
				factor=roh.currfact
				call currconvup(amount,factor)
				let amount=fns(amount)
			endif
			webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! mcharge[ctr,1]
			let tmp$="N"
			if mctxbl[ctr]<>0 let tmp$="Y"
			webstr$=webstr$+tmp$+fdel$ ! tax
			let tmp$="N"
			if int(fra(mcode[ctr])*10) let tmp$="Y"
			webstr$=webstr$+tmp$+fdel$ ! gp
			let tmp$="N"
			IF INT(FRA(MCODE[ctr]*10)*10)=9 let tmp$="Y"
			webstr$=webstr$+tmp$+fdel$ ! del charge
			list$[row]=webstr$
			let row=row+1
		endif
	next ctr
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! flag status for calculating taxes and commissions
	clear list$[]
	List$[0]=bsdel$,"OrderTotFlags",fdel$
	WebStr$="TaxByLine",fdel$
	WebStr$=webstr$,"MiscTaxable",fdel$
	Webstr$=webstr$,"FreightTaxable",fdel$
	Webstr$=webstr$,"DiscTaxable",fdel$
	Webstr$=Webstr$,"OtherTaxable",fdel$
	Webstr$=Webstr$,"TaxRoundFlag",fdel$
	Webstr$=Webstr$,"DisplayCommiss",fdel$
	Webstr$=Webstr$,"CommCalc",fdel$
	Webstr$=Webstr$,"GPFrtChrg",fdel$
	Webstr$=Webstr$,"GPDisc",fdel$
	Webstr$=Webstr$,"GPFrtCost",fdel$
	Webstr$=Webstr$,"GPOther",fdel$
	Webstr$=Webstr$,"DelChrgCalc",fdel$
	WebStr$ = WebStr$,"CostSecurity",fdel$
	webstr$ = webstr$,"NonPrtFlag",fdel$
	webstr$=webstr$,"ThirdPtyTax",fdel$ ! tax calc'd by 3rd party (don't do it here!)
    webstr$=webstr$,"SpecFrgttax",fdel$
	webstr$=webstr$,"SpecFrgtTaxRate",fdel$
	! need to add in morrisette (now std) fields
	webstr$=webstr$,"FRGTOVRRD",fdel$ ! user flag
	webstr$=webstr$,"FOVRRDPWD",fdel$ ! override password
	! frght override Y/n, FOverride passwd
	webstr$=webstr$,"MiscCostSec",fdel$
	webstr$=webstr$,"FrtCostSec",fdel$
	webstr$=webstr$,"EDITCOMM",fdel$ ! can edit commission
	webstr$=webstr$,"COMMOVRRD",fdel$ ! commission override flag
	webstr$=webstr$,"DepositFlag",fdel$ ! not used in quotes but made to match order 
	webstr$=webstr$,"BlockTaxEdit",fdel$
	webstr$=webstr$,"MILLITEMS",fdel$ ! mill item flag
	webstr$=webstr$,"BOPROCESS",fdel$ ! auto bo whsxfer
	let list$[1]=webstr$
	webstr$=""
	let tmp$="N"
	if p60$[42,42]="Y" let tmp$="Y"
	if p60$[42,42]="T" let tmp$="T"
	Webstr$=tmp$,fdel$!  taxby line
	clear ctax.
	if ros.shiptaxtype
		read record #ch_ctax,ros.shiptaxtype;ctax.;
	endif
	let tmp$="N"
	if ctax.mtax let tmp$="Y"
	Webstr$=webstr$,tmp$,fdel$ ! misc tax
	let tmp$="N"
	if ctax.ftax let tmp$="Y"
	Webstr$=webstr$,tmp$,fdel$ !freight tax 
	let tmp$="N"
	if ctax.dtax let tmp$="Y"
	if roh.ordtype=6 or roh.ordtype=10 let tmp$="N" ! NOT TAXABLE!!
	Webstr$=webstr$,tmp$,fdel$ ! disc tax
	let tmp$="N"
	if ctax.htax let tmp$="Y"
	if roh.ordtype=6 or roh.ordtype=10 let tmp$="N" ! NOT TAXABLE!!
	Webstr$=webstr$,tmp$,fdel$ ! other tax
	clear tax.
	let tmp$="N"
	if roh.taxcode
		read record #ch_tax,roh.taxcode;tax.;
		if tax.roundtype$="U" leT tmp$="U"
	endif
	Webstr$=webstr$,tmp$,fdel$ ! tax round
	! display commission
	let dispcomm$="Y"
	!IF P9$[31,31]="N" OR P9$[45,45]="N"  let dispcomm$="N"
	!IF P9$[14,14]="N" let dispcomm$="N"
	if rec_uac>0 ! check user cntrl
			UCC = OpenFile(-9988, intCo)
			if ucc>=0! open user cntrl file
				mat read #ucc,rec_uac,386;ua5;	
			endif
			Try Close #UCC  Else Rem
	endif
	if dispcomm$="Y"
		if ua5[4]<>0 ! verify the salesman
			if ua5[4]=roh.slsmnum let dispcomm$="Y"
		endif
	endif
	Webstr$=webstr$,dispcomm$,fdel$ ! display commission yes or no
	Webstr$=webstr$,p9$[14,14],fdel$  !  Commis Calc. N=no L or P = Load (GP) S= merchandise Dollars
	let tmp$="N" 
	If p9$[35,35]="Y" let tmp$="Y"
	Webstr$=webstr$,tmp$,fdel$ ! gp freight charge flag
	let tmp$="N"
	if p9$[36,36]="Y" let tmp$="Y" ! 
	Webstr$=webstr$,tmp$,fdel$ ! gp discount flag
	let tmp$="N"
	if p9$[37,37]="Y" let tmp$="Y"
	Webstr$=webstr$,tmp$,fdel$ ! gp freight cost flag
	let tmp$="N"
	if p9$[38,38]="Y" let tmp$="Y"
	Webstr$=webstr$,tmp$,fdel$ ! gpother
	let tmp$="N" ! delivery charge flag
	if rot.delivchrglvl<>0 let tmp$="Y"
	if P61$[36,36]="Y" let tmp$="N" ! calc on invoice
	Webstr$=webstr$,tmp$,fdel$ ! del calc
	webstr$ = webstr$,Str$(COST_LEV[1]),fdel$ ! load cost security 
	tmp$="Y" ! allow reset to printed
	webstr$=webstr$,tmp$,fdel$! line print status
	TCB=0
	Read #ch_tax,roh.TaxCode,412;TCB;
	tmp$="N" ! \ if tcb=1 let tmp$="C" ! cch does it
	if custom_customer$="HTBERRY" or p61$[140,140]="Y" ! custom_customer$="PIEDMONT"
		if tcb=1 let tmp$="C" ! cch does it
		if tcb=2 let tmp$="A" ! avalara
	endif
	webstr$=webstr$,tmp$,fdel$ ! third party tax calc
	let tmp$="N"
	let tmp3=0
	if ctax.ftax<>0
			read record #ch_tax,roh.taxcode;tax.;
			if tax.desc$[1,1]="+" ! special tax use level 1
				let tmp$="Y"
				let tmp3=tax.Brkdn1Pct
			endif
	endif
	webstr$=webstr$,tmp$,fdel$ ! special freight tax
	Webstr$=webstr$+RTrim$((tmp3) Using "---.####") + fdel$
	tmp$="Y" !\ if not(credit) and ua2$[45,45]="N" let tmp$="N" ! YES IS DEFAULT!!!
	webstr$=webstr$,tmp$,fdel$ ! user override
	clear FrtOVRRD$ ! NOT ON QUOTES If credit 
	webstr$=webstr$,FrtOVRRD$,fdel$ ! override password
	! misc cost security
	let tmp3=ua2$[18,18]
	if tmp3<0 let tmp3=0
	if tmp3>2 let tmp3=2
	if rtrim$(ua2$[18,18])="" let tmp3=2
	Webstr$=webstr$,str$(tmp3),fdel$
	! freight cost security
	let tmp3=ua2$[17,17]
	if tmp3<0 let tmp3=0
	if tmp3>2 let tmp3=2
	if rtrim$(ua2$[17,17])="" let tmp3=2
	Webstr$=webstr$,str$(tmp3),fdel$
	!webstr$=webstr$,"MiscCostSec",fdel$
	!webstr$=webstr$,"FrtCostSec",fdel$
	webstr$=webstr$,"N",fdel$ ! no commiss on quotes!
	webstr$=webstr$,"0",fdel$ ! comm override not on quotes
	webstr$=webstr$,"N",fdel$ ! deposits not on quotes
	let tmp$="N"
	if ua2$[32,32]="Y" let tmp$="Y" ! edit tax - flag in file is to block tax 
	webstr$=webstr$,tmp$,fdel$
	miflag$="N" ! NO AUTO PO CREATE MILL ITEMS ON QUOTES
	miflag$=getmillitmflag$() ! see if any mill items (N/H/D) ! quotes no Y
	webstr$=webstr$,miflag$,fdel$
	webstr$=webstr$,"N",fdel$
    List$[2]=Webstr$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	!new section - show any mill item po's
	call showmillitems(miflag$) ! checks source & miflag$
	call AddToStr(e$,rstr$,List$[]) ! "add the list
	! status section
	!call programdump("/tmp/ordh7!","")
  else
    include "src/callsuberr.inc"
  end try
end Sub ! Gettotals
!--------------------------------------------------------------------------------
Sub SavTotals()
  Try
	let returnstatus=1
	let message$="OK"
	let message$=""
	eflag=0
	call dxget ("custid",Custid$)
	call dxget ("orderid",orderid$)
	call dxget ("editstatus",tmp$)
	let editstatus=tmp$
	let custid=custid$
	let orderid=orderid$
	call dxget ("SOURCE",tmp$)
	let source=tmp$ \ if credit let source=0
	LET returnstatus=1
	!let message$="OK"
	keyroh$=" ",keyroh$
	keyroh$[1,7]=custid using "#######" 
	keyroh$[8,13]=orderid using "######"
	KEYROH$[14]="" ! no space
	mode$="=" ! search mode 2
	dir=2
	clear chan[]
	CHAN[0]=CH_ROH
	CHAN[1]=CH_ROS
	CHAN[2]=CH_ROT
	Rec_roh=filegetqohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
	if rec_roh<0
		eflag=eflag+1
		let returnstatus=0
		let message$="Quote Number ",keyroh$[8,13]," Not On File"
	endif
	if returnstatus<>0
		call verifystat()
		if returnstatus=99 goto endsubmitordtot
	endif
	if returnstatus<>0
		clear cust.
		let keycust$=custid using "######"
		mode$="="
		dirno=1
		if custid>0
		CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
		Else
			custrec=-1
		Endif
		if CustRec<0 ! record not found
			 eflag=eflag+1
			 let returnstatus=0
			 let message$=message$+"Customer "+str$(custid)+" Not on File"
		else
			  Mat Read #ch_cust,custrec,544;CFIN;
		endif
		let keyslsm$=" ",keyslsm$
		let keyslsm$[1,3]=roh.slsmnum using "###"
		keyslsm$[5]=""
		let mode="="
		dirno=1
		SlsmRec=FileGetsSlsmz(e$,Ch_sslsm,mode$,dirno,KeySlsm$,Sslsm.)
		if slsmrec<0
			eflag=eflag+1
			let returnstatus=0
			let message$=message$+"SalesPerson "+str$(roh.slsm)+" Not on File"
		endif
		if returnstatus<>0
		clear ch[] ! channels for files sent to order total
		LET CH[2]=CH_ZONE;CH[3]=CH_PROD;CH[4]=CH_COMCDE;CH[5]=CH_CUST             
		LET CH[6]=CH_PRWH;CH[7]=CH_ROS;CH[8]=CH_ROH;CH[9]=CH_ROT;CH[10]=CH_ROL    
		LET CH[11]=CH_SPRODDESC;CH[12]=CH_CTAX;CH[13]=CH_SSLSM;CH[14]=CH_TAX
		LET CH[15]=CH_SPRODLOT;CH[16]=CH_SORDLOT;CH[17]=CH_CCODE 
		clear s9[]
		let s9[0]=orderid
		let s9[1]=intco
		let s9[2]=roh.slsm
		let s9[4]=source ! order entry program #
		If source=0 let source=283
		R5 = custrec ;H1 = REC_ROH;V1 = slsmrec
		MAT  READ #CH_ROT,roh.totrec,0;T1       
		MAT  READ #CH_ROT,roh.totrec,8;T2       
		MAT  READ #CH_ROT,roh.totrec,168;MCODE  
		MAT  READ #CH_ROT,roh.totrec,208;MCHARGE
		MAT  READ #CH_ROT,roh.totrec,328;TOT    
		MAT  READ #CH_ROT,roh.totrec,358;MCTXBL 
		MAT  READ #CH_ROT,roh.totrec,378;DCLVL  
		! start the dxgets here
		TOT[0]=0;TOT[1]=0;TOT[2]=0;T2[4]=0 ! CLEAR MISC VARIABLES
		if roh.ordtype=16 goto OTBYPTS
		clear param[]
		let param[9]=99 ! bypass delivery calc on submit
		orgdelcode=0
		orgdelamt=0
		for ctr=0 to 9
			if mcode[ctr]<>0
				if int(fra(mcode[ctr]*10)*10)=9
					let orgdelcode=int(mcode[ctr])
					let orgdelamt=mcharge[ctr]
					let param[9]=88 ! originally had a freight code
				endif
			endif
		next ctr
		let newdelcode=0
		let newdelamt=0
		for ctr=1 to 10 ! for misc charges
			LET MCODE[ctr-1]=0;MCHARGE[(CTR-1),0]=0;MCHARGE[(CTR-1),1]=0;MCTXBL[CTR-1]=0
			call dxget ("MiscCode"+str$(ctr),tmp$)

			let mcode[ctr-1]=tmp$
			if mcode[ctr-1]
				call dxget("MiscChrg"+str$(ctr),tmp$)
				amount=tmp$
				if fra(amount*100)<>0
					let eflag=eflag+1
					let returnstatus=0
					let message$=message$+" Misc Charge "+str$(ctr)+" Exceeds 2 decimal places "
					! Goto endsubmitordtot
				endif
				If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
					factor=roh.currfact
					call currconvdown(amount,factor)
					let amount=fnr(amount)
				endif
				let mcharge[(ctr-1),0]=amount
				T2[4]=T2[4]+ MCHARGE[(CTR-1),0]
				call dxget("MiscCost"+str$(ctr),tmp$)
				!let mcharge[(ctr-1),1]=tmp$
				let amount=tmp$
				If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
					factor=roh.currfact
					call currconvdown(amount,factor)
					let amount=fnr(amount)
				endif
				let mcharge[(ctr-1),1]=amount
				TOT[0]=TOT[0]+MCHARGE[(CTR-1),1]
				call dxget("MiscTax"+str$(ctr),tmp$)
				if tmp$="Y" 
					let mctxbl[ctr-1]=1 
				else
					let mctxbl[ctr-1]=0
				endif
				
				call dxget("MiscGP"+str$(ctr),tmp$)
				if tmp$="Y"
					LET MCODE[CTR-1]=MCODE[CTR-1]+.1 
					LET TOT[1]=TOT[1]+MCHARGE[(CTR-1),0]
					LET TOT[2]=TOT[2]+MCHARGE[(CTR-1),1]
				endif
				call dxget("MiscDel"+str$(ctr),tmp$)
				if tmp$="Y"
					let newdelamt=mcharge[ctr-1]
					let newdelcode=mcode[ctr-1]
					if newdelamt=orgdelamt and newdelcode=orgdelcode
						let mcode[ctr-1]=mcode[ctr-1]+.09
						let param[9]=99
					endif
				endif
			endif
		next ctr
		call dxget("FrgtChrg",tmp$)
		let amount=tmp$
		if amount<>0
			if fra(amount*100)<>0
				eflag=eflag+1
				let returnstatus=0
				let message$=message$+" Freight Exceeds 2 decimals places "
				!Goto endsubmitordtot
			endif
		endif
		If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			factor=roh.currfact
			call currconvdown(amount,factor)	
			let amount=fnr(amount)
		endif
		let t2[5]=fnr(amount)
		call dxget("OrdDisc",tmp$)
		let amount=tmp$
		if amount<>0
			if fra(amount*100)<>0
				eflag=eflag+1
				let returnstatus=0
				let message$=message$+" Discount Exceeds 2 decimals places "
				!Goto endsubmitordtot
			endif
		endif
		If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			factor=roh.currfact
			call currconvdown(amount,factor)
			let amount=fnr(amount)
		endif
		let t2[3]=amount
		call dxget("OrdDiscPct",tmp$)
		let roh.orddisc=tmp$
		if not(t2[3]) let roh.orddisc=0
		if roh.ordtype=6 or roh.ordtype=10 let roh.orddisc=100
		write #ch_roh,rec_roh,436;roh.orddisc
		call dxget("Other",tmp$)
		let amount=tmp$
		if amount<>0
			if fra(amount*100)<>0
				eflag=eflag+1
				let returnstatus=0
				let message$=message$+" Other Chrg Exceeds 2 decimals places "
				!Goto endsubmitordtot
			endif
		endif	
		If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			factor=roh.currfact
			call currconvdown(amount,factor)
			let amount=fnr(amount)
		endif
		let t2[6]=amount
		call dxget("PrepaidFrgt",tmp$)
		let amount=tmp$
		If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			factor=roh.currfact
			call currconvdown(amount,factor)
			let amount=fnr(amount)
		endif
		let t2[19]=amount ! prepaid freight
		call dxget("FrgtCost",tmp$)
		let amount=tmp$
		If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			factor=roh.currfact
			call currconvdown(amount,factor)
			let amount=fnr(amount)
		endif
		let t2[20]=amount
		call dxget("TaxAmt",tmp$)
		let amount=tmp$
		If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			factor=roh.currfact
			call currconvdown(amount,factor)
			let amount=fnr(amount)
		endif
		let t2[7]=amount
		call dxget("TaxCode",tmp$)
		let tmp3=tmp$
		if tmp3<1 or tmp3>7999
			let returnstatus=0
			eflag=eflag+1
			let message$=message$+"Invalid Tax Code Submitted "+str$(tmp3)
			goto endsubmitordtot:
		endif
		let roh.taxcode=tmp$
		call dxget("TaxPct",tmp$)
		let t2[2]=tmp$
		if eflag<>0
			let returnstatus=0
			goto endsubmitordtot:
		endif
		if returnstatus=0 goto endsubmitordtot:
		let message$="OK"
		OTBYPTS: ! no totals change comes here
		IF roh.ordtype=6 or roh.ordtype=10
			t2[6]=0-t2[7] ! oth=neg tax
			t2[3]=t2[1] ! disc=subtotal
		Endif
		! third party tax calc run/check
		if custom_customer$="HTBERRY" or p61$[140,140]="Y" ! custom_customer$="PIEDMONT" ! as it should only do upon totals accept
			read #ch_tax,roh.taxcode,412;tcb; ! tax calcby
			If tcb=2 ! tax calc'd by CCH/AvaTax - go get it now BERRY NO QUOTES was tcb=1 or
				Let OrderRec=rec_roh ! header rec # - orders/credits same? Y
				Chan[1]=CH_cust;Chan[2]=CH_ROH;Chan[3]=CH_ROS;Chan[4]=CH_ROT ! cust,roh,ros,rot
				Chan[5]=CH_ROL;Chan[6]=CH_TAX;Chan[7]=CH_CTAX ! " ROL, TAXCODE, CTAXTYPE
				! if tcb=1 Call "cch.calc.dsout.dl4",OrderRec,Chan[],Intco,rstr$ ! NOT ON QUOTES FOR BERRY!!
				if tcb=2 Call "ava.qgettaxout.dl4",OrderRec,Chan[],Intco,rstr$
				MAT  READ #CH_ROT,roh.totrec,8;T2 ! re-read totals & tax t2[0]&t2[7](/t2[6])
			Endif
		Endif ! custom berry/piedmont tax calc by third party
		! write out the totals
		MAT  write #CH_ROT,roh.totrec,8;T2       
		MAT  write #CH_ROT,roh.totrec,168;MCODE  
		MAT  write #CH_ROT,roh.totrec,208;MCHARGE
		MAT  write #CH_ROT,roh.totrec,328;TOT    
		MAT  write #CH_ROT,roh.totrec,358;MCTXBL 
		! calc for profit fields
		LET roh.totdol4prof=T2[1]-roh.totfrgtadd \ LET roh.totcost4prof=T2[17]     
		IF P9$[35,35]="Y" LET roh.totdol4prof=roh.totdol4prof+T2[5]+roh.totfrgtadd
		IF P9$[36,36]="Y" LET roh.totdol4prof=roh.totdol4prof-T2[3]      
		IF P9$[37,37]="Y" LET roh.totcost4prof=roh.totcost4prof+T2[20]     
		IF P9$[38,38]="Y" LET roh.totdol4prof=roh.totdol4prof+T2[6]      
		LET roh.totdol4prof=roh.totdol4prof+TOT[1];roh.totcost4prof=roh.totcost4prof+TOT[2] 
		write #ch_roh,rec_roh,154;roh.totdol4prof;
		write #ch_roh,rec_roh,160;roh.totcost4prof;
		write #ch_roh,rec_roh,78;roh.taxcode;
		! for order total 
		clear ch[] ! channels for files sent to order total
		LET CH[2]=CH_ZONE;CH[3]=CH_PROD;CH[4]=CH_COMCDE;CH[5]=CH_CUST             
		LET CH[6]=CH_PRWH;CH[7]=CH_ROS;CH[8]=CH_ROH;CH[9]=CH_ROT;CH[10]=CH_ROL    
		LET CH[11]=CH_SPRODDESC;CH[12]=CH_CTAX;CH[13]=CH_SSLSM;CH[14]=CH_TAX
		LET CH[15]=CH_SPRODLOT;CH[16]=CH_SORDLOT;CH[17]=CH_CCODE;ch[19]=ch_misc
		clear s9[]
		let s9[0]=orderid
		let s9[1]=intco
		let s9[2]=roh.slsm
		let s9[4]=SOURCE ! order entry program #
		If S9[4]=0 and roh.orgstatus=0 and spare2=0
			let S9[4]=281 ! new order (could be 207!)
		endif
		if roh.orgstatus>0 and roh.orgstatus<5 let S9[4]=283 ! NOT ENTRY
		IF S9[4]=0 LET S9[4]=283
		R5 = custrec ;H1 = REC_ROH;V1 = slsmrec
		clear param[]
		param[0]=0 !cred check 
		!param[1]=1 !no cred check
		param[1]= 0 ! no credit check 0 !no cred check
		! If roh.orgstatus=0 let param[1]=1 ! credit check new order
		param[2]=0 !no exception check
		param[3]=1 !write total data out
		param[4]=0 !no retotal of customer on order
		! if p60$[40,40]="S" let param[4]=1! retotal on order if based on shipped
		param[5]=0 !do no clear manual edits
		param[6]=1 !you can clear cash stuff
		MAT  READ #CH_ROT,roh.totrec,0;T1       
		MAT  READ #CH_ROT,roh.totrec,8;T2       
		MAT  READ #CH_ROT,roh.totrec,168;MCODE  
		MAT  READ #CH_ROT,roh.totrec,208;MCHARGE
		MAT  READ #CH_ROT,roh.totrec,328;TOT    
		MAT  READ #CH_ROT,roh.totrec,358;MCTXBL 
		MAT  READ #CH_ROT,roh.totrec,378;DCLVL 
		Param[9]=0
		if s9[4]=281 and T2[24]<>0 let Param[9]=99;s9[4]=283 ! edit in entry
		If s9[4]=284 let param[9]=99 ! bypass on edit
		Param[9]=99 ! submit - no calc
		PARAM[10] = 99! ar term misc cost charge   - bypass 
		Call "ORDERTOTAL",S9[],H1,PARAM[],ch[],T1[],T2[],MCODE[],MCHARGE[],TOT[],MCTXBL[],DCLVL,R5,V1,CFIN[]
		read record #ch_roh,rec_roh;roh.
		read record #ch_rot,roh.totrec;rot.
		read record #ch_ros,roh.shiprec;ros.
	
		! reset status !
		if editstatus=9  ! order completed
			OStat=roh.status ! curr key stat
			let roh.status=roh.orgstatus
			if roh.status<1 or roh.status>4
				let roh.status=1
			endif
			! new order is original status = 0, current status in process
				! if we get here, we know the original status is 0, if not in process
				! this means 2 people must've edited the order at the same time and this
				! is the second session submitting the order
				if (OStat < 90) ! current status is not in process!
					returnstatus=2
					message$="ERROR!! Original status: "+str$(ostat)+"  - Order Reset to Status: "+str$(roh.status)
				end if
			call dxget("RESETPRTSTAT",tmp$)
			if rtrim$(ucase$(tmp$))="Y"
				let roh.status=1
			Endif
			let keyroh$=" ",keyroh$
			let keyroh$[1,2]=roh.status using "##"
			let keyroh$[3,8]=orderid using "######"
			search #ch_roh,4,1;keyroh$,rec_roh,e
			let keyroh$[1,2]=OStat using "##"
			if ostat<>roh.status
				search #ch_roh,5,1;keyroh$,rec_tmp,e
			endif
			roh.orgstatus=0
			write record #ch_roh,rec_roh;roh.; ! order complete
			read record #ch_rot,roh.totrec;rot.;
			read record #ch_ros,roh.shiprec;ros.; 
		endif
		! endif order total
		! add order & line alerts
		!if not(credit)
		!	clear ch[] ! channels for files sent to MXLINEPT
		!	LET CH[2]=CH_ZONE;CH[3]=CH_PROD;CH[4]=CH_COMCDE;CH[5]=CH_CUST             
		!	LET CH[6]=CH_PRWH;CH[7]=CH_ROS;CH[8]=CH_ROH;CH[9]=CH_ROT;CH[10]=CH_ROL    
		!	LET CH[11]=CH_SPRODDESC;CH[12]=CH_CTAX;CH[13]=CH_SSLSM;CH[14]=CH_TAX
		!	LET CH[15]=CH_SPRODLOT;CH[16]=CH_SORDLOT;CH[17]=CH_CCODE;ch[19]=ch_misc
		!	clear s9[]
		!	S9[2]=rec_roh
		!	call "mxlinept.dl4",CH[],s9[],IntCo ! ttlavl<linept/min chk (whole order)
		!Endif
	   endif ! order data ok
	endif ! of order ok
	endsubmitordtot: ! end submit of order totals
	clear list$[]
	List$[0]=bsdel$,"SubmitTotal",fdel$
	webstr$="OrderId",fdel$
	If (custom_customer$="HTBERRY" and tcb=1) or (p61$[140,140]="Y" and tcb=2) ! cch/avalaracustom_customer$="PIEDMONT"
		webstr$=webstr$,"TaxAmt",fdel$,"Other",fdel$,"OrderTotal",fdel$
	else
		webstr$=webstr$,"",fdel$,"",fdel$,"",fdel$
	Endif
	webstr$=webstr$,"PROMPTPRICES",FDEL$,"PRNTPRICEDEF",fdel$
	Webstr$=webstr$,"",fdel$ ! INVOICE ID
	webstr$=webstr$,"ORDERAMT",fdel$
	webstr$=webstr$,"ORDERCOST",fdel$
	List$[1]=WebStr$
	List$[1]=webstr$
	WebStr$=str$(orderid),fdel$
	! return status of 2 is now used to indicate a message possibly needs to
	! be displayed in addition to the CCH stuff. so, here's how it works:
	! returnstatus=2 means:
	! if messsage in status section is not null, display it, otherwise don't
	! if additional columns needed by CCH are present, use them, otherwise don't
	If (custom_customer$="HTBERRY" and tcb=1) or (p61$[140,140]="Y" and tcb=2) ! cch flds changedcustom_customer$="PIEDMONT"
	  if returnstatus=1 or returnstatus=2  ! ok so far
		!webstr$=webstr$,"TaxAmt",fdel$,"Other",fdel$,"OrderTotal",fdel$
		Webstr$=webstr$+RTrim$((rot.taxamt) Using "----------.##") + fdel$
		Webstr$=webstr$+RTrim$((rot.OthChrg) Using "----------.##") + fdel$
		Webstr$=webstr$+RTrim$((rot.OrdTot) Using "----------.##") + fdel$
		let returnstatus=2 ! message to webside
	  else
		webstr$=webstr$,"",fdel$,"",fdel$,"",fdel$
	  Endif ! of ok and third party tax
	else
		webstr$=webstr$,"",fdel$,"",fdel$,"",fdel$
	Endif
	let tmp$="N"
	if custom_customer$="SWP"
		IF not(source) !if source=208 or source=243
			let tmp$="Y" ! prompt to print prices
		endif
	endif
	webstr$=webstr$,tmp$,fdel$
	let tmp$="0" ! for no
	if cust.PrintOrderPrices<>0 let tmp$="1" !  for yes customer's default
	webstr$=webstr$,tmp$,fdel$
	Webstr$=webstr$,"",fdel$
    let amount=rot.MdseOrdAmt
	If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$,str$(amount),fdel$ ! rot.mdseordamount
	let amount=rot.totordcost 
	If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$,str$(amount),fdel$ ! rot.totordcost
	LIST$[2]=Webstr$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	 !       LIST$[2]=Webstr$
	SOTDone: ! finished
	!If (custom_customer$="HTBERRY" and tcb=1) or (custom_customer$="PIEDMONT" and tcb=2) ! cch flds changed
	If (p61$[140,140]="Y" and tcb=2) ! cch flds changed - BERRY NO QUOTES!!custom_customer$="PIEDMONT"
	  ! so do what order/inv print does - check for transid in ordtrans file!
	  If returnstatus=1 or returnstatus=2 ! ok so far
		tchan=findchannel()
		!if tcb=1 ! cch
		!	tmp$="7/cchordtrans"+Str$(intco)
		!endif
		if tcb=2 ! avalara
			tmp$="7/avaqtetrans"+Str$(Intco)
		endif
		if tmp$[1,2]="7/" ! ok continue - got filename
			Try 
				ROpen #tchan,tmp$
			Else
				message$="No Order trans file for tptc"
				goto tptccdone
			End try
			tmp$=" ",tmp$
			tmp$=roh.ordnum using "######"
			Search #tchan,2,1;tmp$,R,E
			if e let tmp$=" ",tmp$
			if tmp$[7,9]="   " or Rtrim$(tmp$)=""
				let message$="NO TAX CALCULATION - SEE LOG"
				! hopefully this makes it to the user!
			endif
			try close #tchan else rem
			tptccdone: ! finished
		Endif ! of got filename
	  Endif ! of status of action is ok
	Endif ! of tptc
	! status section
  else
    include "src/callsuberr.inc"
  end try
end Sub ! Savtotals
!--------------------------------------------------------------------------------
Sub SlsmComm()
! salesman Commission
  Try
	Source=207 ! force exit
	if source=207
		let returnstatus=0
		message$="No Update. Quotes have no commission"
		goto EndGetSlsmComm
	endif
	let returnstatus=1
	let message$="OK"
	GOTO BYPGSCOM ! NO COMMISSIONS ON QUOTES!
	call dxget ("custid",Custid$)
	call dxget ("orderid",orderid$)
	let custid=custid$
	let orderid=orderid$
	
	keyroh$=" ",keyroh$
	keyroh$[1,7]=custid using "#######" 
	keyroh$[8,13]=orderid using "######"
	KEYROH$[14]="" ! no space
	mode$="=" ! search mode 2
	dir=2
	clear chan[]
	CHAN[0]=CH_ROH
	CHAN[1]=CH_ROS
	CHAN[2]=CH_ROT
	Rec_roh=filegetqohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
	if rec_roh<0
		let returnstatus=0
		let message$="Quote Number ",keyroh$[8,13]," Not On File"
		goto EndGetSlsmComm
	endif
	if returnstatus<>0
		clear cust.
		let keycust$=custid using "######"
		mode$="="
		dirno=1
		if custid>0
		CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
		Else
			custrec=-1
		Endif
		if CustRec<0 ! record not found
			 let returnstatus=0
			 let message$="Customer "+str$(custid)+" Not on File"
			 goto EndGetSlsmComm
		else
			  Mat Read #ch_cust,custrec,544;CFIN;
		endif
		let keyslsm$=" ",keyslsm$
		let keyslsm$[1,3]=roh.slsmnum using "###"
		keyslsm$[5]=""
		let mode="="
		dirno=1
		SlsmRec=FileGetsSlsmz(e$,Ch_sslsm,mode$,dirno,KeySlsm$,Sslsm.)
		if slsmrec<0
			let returnstatus=0
			let message$="SalesPerson "+str$(roh.slsm)+" Not on File"
			goto EndGetSlsmComm
		endif
		if returnstatus<>0
		clear ch[] ! channels for files sent to order total
		LET CH[2]=CH_ZONE;CH[3]=CH_PROD;CH[4]=CH_COMCDE;CH[5]=CH_CUST             
		LET CH[6]=CH_PRWH;CH[7]=CH_ROS;CH[8]=CH_ROH;CH[9]=CH_ROT;CH[10]=CH_ROL    
		LET CH[11]=CH_SPRODDESC;CH[12]=CH_CTAX;CH[13]=CH_SSLSM;CH[14]=CH_TAX
		LET CH[15]=CH_SPRODLOT;CH[16]=CH_SORDLOT;CH[17]=CH_CCODE 
		clear s9[]
		let s9[0]=orderid
		let s9[1]=intco
		let s9[2]=roh.slsm
		let s9[4]=201 ! order entry program #
		if credit let s9[4]=241
		if roh.status=96 Let s9[4]=223
		if roh.status=94 let s9[4]=231
		R5 = custrec ;H1 = REC_ROH;V1 = slsmrec
		MAT  READ #CH_ROT,roh.totrec,0;T1       
		MAT  READ #CH_ROT,roh.totrec,8;T2       
		MAT  READ #CH_ROT,roh.totrec,168;MCODE  
		MAT  READ #CH_ROT,roh.totrec,208;MCHARGE
		MAT  READ #CH_ROT,roh.totrec,328;TOT    
		MAT  READ #CH_ROT,roh.totrec,358;MCTXBL 
		MAT  READ #CH_ROT,roh.totrec,378;DCLVL  
		! start the dxgets here
		TOT[0]=0;TOT[1]=0;TOT[2]=0;T2[4]=0 ! CLEAR MISC VARIABLES
		if roh.ordtype=16 goto OTBYPS
		for ctr=1 to 10 ! for misc charges
			LET MCODE[ctr-1]=0;MCHARGE[(CTR-1),0]=0;MCHARGE[(CTR-1),1]=0;MCTXBL[CTR-1]=0
			call dxget ("MiscCode"+str$(ctr),tmp$)
			let mcode[ctr-1]=tmp$
			if mcode[ctr-1]
				call dxget("MiscChrg"+str$(ctr),tmp$)
				amount=tmp$
				If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
					factor=roh.currfact
					call currconvdown(amount,factor)
					let amount=fnr(amount)
				endif
				let mcharge[(ctr-1),0]=amount
				T2[4]=T2[4]+MCHARGE[(CTR-1),0]
				call dxget("MiscCost"+str$(ctr),tmp$)
				amount=tmp$
				If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
					factor=roh.currfact
					call currconvdown(amount,factor)
					let amount=fnr(amount)
				endif
				let mcharge[(ctr-1),1]=amount
				TOT[0]=TOT[0]+MCHARGE[(CTR-1),1]
				call dxget("MiscTax"+str$(ctr),tmp$)
				if tmp$="Y" 
					let mctxbl[ctr-1]=1 
				else
					let mctxbl[ctr-1]=0
				endif
				call dxget("MiscGP"+str$(ctr),tmp$)
				if tmp$="Y"
					LET MCODE[CTR-1]=MCODE[CTR-1]+.1 
					LET TOT[1]=TOT[1]+MCHARGE[(CTR-1),0]
					LET TOT[2]=TOT[2]+MCHARGE[(CTR-1),1]
				endif
				call dxget("MiscDel"+str$(ctr),tmp$)
				if tmp$="Y"
					let mcode[ctr-1]=mcode[ctr-1]+.09 
				endif
			endif
		next ctr
		call dxget("FrgtChrg",tmp$)
		amount=tmp$
		If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			factor=roh.currfact
			call currconvdown(amount,factor)
			let amount=fnr(amount)
		endif
		let t2[5]=amount
		call dxget("OrdDisc",tmp$)
		amount=tmp$
		If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			factor=roh.currfact
			call currconvdown(amount,factor)
			let amount=fnr(amount)
		endif
		let t2[3]=amount
		call dxget("Other",tmp$)
		amount=tmp$
		If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			factor=roh.currfact
			call currconvdown(amount,factor)
			let amount=fnr(amount)
		endif
		let t2[6]=amount
		call dxget("PrepaidFrgt",tmp$)
		amount=tmp$
		If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			factor=roh.currfact
			call currconvdown(amount,factor)
			let amount=fnr(amount)
		endif
		let t2[19]=amount ! prepaid freight
		call dxget("FrgtCost",tmp$)
		amount=tmp$
		If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			factor=roh.currfact
			call currconvdown(amount,factor)
			let amount=fnr(amount)
		endif
		let t2[20]=amount
		OTBYPS: ! bypass - NO Get for ordertype
		! write out the totals
		MAT  write #CH_ROT,roh.totrec,8;T2       
		MAT  write #CH_ROT,roh.totrec,168;MCODE  
		MAT  write #CH_ROT,roh.totrec,208;MCHARGE
		MAT  write #CH_ROT,roh.totrec,328;TOT    
		MAT  write #CH_ROT,roh.totrec,358;MCTXBL 
		! calc for profit fields
		LET roh.totdol4prof=T2[1]-roh.totfrgtadd \ LET roh.totcost4prof=T2[17]     
		IF P9$[35,35]="Y" LET roh.totdol4prof=roh.totdol4prof+T2[5]+roh.totfrgtadd
		IF P9$[36,36]="Y" LET roh.totdol4prof=roh.totdol4prof-T2[3]      
		IF P9$[37,37]="Y" LET roh.totcost4prof=roh.totcost4prof+T2[20]     
		IF P9$[38,38]="Y" LET roh.totdol4prof=roh.totdol4prof+T2[6]      
		LET roh.totdol4prof=roh.totdol4prof+TOT[1];roh.totcost4prof=roh.totcost4prof+TOT[2] 
		write #ch_roh,rec_roh,154;roh.totdol4prof;
		write #ch_roh,rec_roh,160;roh.totcost4prof;
		
		! calculate the commission
		!clear ch[] ! channels for files sent to mxslscom5
		!LET CH[1]=CTLC;CH[3]=CH_PROD;CH[4]=CH_COMCDE;CH[5]=CH_CUST             
		!LET CH[6]=CH_PRWH;CH[7]=CH_ROS;CH[8]=CH_ROH;CH[9]=CH_ROT;CH[10]=CH_ROL    
		!LET CH[11]=CH_SPRODDESC;CH[12]=CH_CTAX;CH[13]=CH_SSLSM
		!Call "MXSLSCOM5",S9[],CH[],R5,H1,V1,CFIN[] 
	   endif ! of 2nd status<>0
	endif ! of 1st status<>0
	EndGetSlsmComm: ! 
	List$[0]=bsdel$,"SlsmComm",fdel$
	webstr$="SlsmID",fdel$
	webstr$=webstr$,"SlsmName",fdel$
	webstr$=webstr$,"SlsmCommPct",fdel$
	webstr$=webstr$,"SlsmCommAmt",fdel$
	!if p61$[79,79]="Y" ! native conditional - web always send header
		webstr$=webstr$,"SlsmCommGPDol",fdel$
		webstr$=webstr$,"SlsmCommGPPct",fdel$
	!Else
	!Endif ! SENT ONLY TO KEEP SAME AS ORDERS (NO COMMISS ON QUOTES)
	list$[1]=webstr$
	let row=2
	!for ctr=0 to 4 ! salesperson code
	!	if roh.slsm[ctr]<>0
	!		webstr$=Rtrim$(roh.slsm[ctr] Using "###") + fdel$
	!		let slsmname$=""	
	!		if roh.slsm[ctr]>0 and roh.slsm[ctr]<=999
	!			let slsmname$=getslsmname$(ch_Sslsm,roh.slsm[ctr],intco)	
	!		endif
	!		webstr$=webstr$+rtrim$(slsmname$)+fdel$
	!		webstr$=webstr$+Rtrim$(roh.slsmpct[ctr] Using "###.##%") + fdel$
	!		webstr$=webstr$+Rtrim$(roh.slsmcomm[ctr] using "--------#.##")+fdel$
	!		let list$[row]=webstr$
	!		let row=row+1
	!	endif
	!next ctr
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	! end salesman section
	!call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	!Call AddToStr(e$,rstr$,esdel$) ! end of section 
	BYPGSCOM: ! bypass as are no commissions
	! status section
  else
    include "src/callsuberr.inc"
  end try
end Sub ! SlsmComm
!--------------------------------------------------------------------------------
Sub DelvyChg()
  Try
	
	let returnstatus=1
	let message$="OK"
	call dxget ("custid",Custid$)
	call dxget ("orderid",orderid$)
	let custid=custid$
	let orderid=orderid$
	LET returnstatus=1
	let message$="OK"
	keyroh$=" ",keyroh$
	keyroh$[1,7]=custid using "#######" 
	keyroh$[8,13]=orderid using "######"
	KEYROH$[14]="" ! no space
	mode$="=" ! search mode 2
	dir=2
	clear chan[]
	CHAN[0]=CH_ROH
	CHAN[1]=CH_ROS
	CHAN[2]=CH_ROT
	Rec_roh=filegetqohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
	if rec_roh<0
		let returnstatus=0
		let message$="Quote Number ",keyroh$[8,13]," Not On File"
	endif
	clear ctax.
	clear rot.
	if roh.ordtype=16 let returnstatus=0 ! no changes allowed!
	if returnstatus<>0
		if ros.shiptaxtype<>0
			read record #ch_ctax,ros.shiptaxtype;ctax.;
		endif
		rot.miscchrg=0;rot.totmisccost=0;rot.miscchrg4prof=0;rot.misccost4prof=0
		for ctr=0 to 9
			let rot.mcharge[ctr,0]=0;rot.mcharge[ctr,1]=0
			let rot.MiscChrgCode[ctr]=0
			let rot.mctxbl[ctr]=0
		next ctr
		call dxget ("DelivChrgLvl",tmp$)
		let rot.delivchrglvl=tmp$
		rot.miscchrg4prof=0
		for ctr=1 to 10 ! for misc charges
			call dxget ("MiscId"+str$(ctr),tmp$)
			let rot.MiscChrgCode[ctr-1]=tmp$
			if rot.MiscChrgCode[ctr-1]
				call dxget("MiscChrg"+str$(ctr),tmp$)
				amount=tmp$
				If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
					factor=roh.currfact
					call currconvdown(amount,factor)
					let amount=fnr(amount)
				endif
				let rot.mcharge[(ctr-1),0]=amount
				rot.miscchrg=rot.miscchrg+rot.MCHARGE[(CTR-1),0]
				call dxget("MiscCost"+str$(ctr),tmp$)
				amount=tmp$
				If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
					factor=roh.currfact
					call currconvdown(amount,factor)
					let amount=fnr(amount)
				endif
				let rot.mcharge[(ctr-1),1]=amount
				rot.totmisccost=rot.totmisccost+rot.MCHARGE[(CTR-1),1]
				call dxget("MiscTax"+str$(ctr),tmp$)
				if tmp$="Y" 
					let rot.mctxbl[ctr-1]=1 
				else
					let rot.mctxbl[ctr-1]=0
				endif
				
				call dxget("MiscGP"+str$(ctr),tmp$)
				
				if tmp$="Y"
					LET rot.MiscChrgCode[ctr-1]=rot.MiscChrgCode[ctr-1]+.1 
					LET rot.miscchrg4prof=rot.miscchrg4prof+rot.MCHARGE[(CTR-1),0]
					LET rot.misccost4prof=rot.misccost4prof+rot.MCHARGE[(CTR-1),1]
				endif
				call dxget("MiscDel"+str$(ctr),tmp$)
				if tmp$="Y"
					let rot.MiscChrgCode[ctr-1] = rot.MiscChrgCode[ctr-1]+.09 
				endif
			endif
		next ctr
		call calcdeliverycharge()
		Write Record #ch_rot,roh.totrec;rot.;
	endif	
	List$[0]=bsdel$,"DeliveryCharge",fdel$
	webstr$=""
	webstr$=webstr$,"DelivChrgLvl",fdel$
	Webstr$=Webstr$,"Totcharge4prof",fdel$
	Webstr$=Webstr$,"Totcost4prof",fdel$
	webstr$=webstr$,"TotMiscCost",fdel$
	let list$[1]=webstr$
	let webstr$=""
	if returnstatus=1
		Webstr$=webstr$+RTrim$(rot.delivchrglvl using "##")+fdel$
		let amount=roh.totdol4prof
		If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			factor=roh.currfact
			call currconvup(amount,factor)
			let amount=fns(amount)
		endif
		Webstr$=webstr$+RTrim$(amount Using "----------.##") + fdel$ !roh.totdol4prof
		let amount=roh.totcost4prof
		If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			factor=roh.currfact
			call currconvup(amount,factor)
			let amount=fns(amount)
		endif
		Webstr$=webstr$+RTrim$(amount Using "----------.##") + fdel$ ! roh.totcost4prof
		let amount=rot.totmisccost
		If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			factor=roh.currfact
			call currconvup(amount,factor)
			let amount=fns(amount)
		endif
		webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! rot.totmisccost
	    LIST$[2]=Webstr$
	endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! section 2 - misc charge section
	! misc charge section
	clear list$[]
	List$[0]=bsdel$,"DeliveryMisc",fdel$
	webstr$=""
	webstr$=webstr$,"MiscId",fdel$
	webstr$=webstr$,"MiscDesc",fdel$
	webstr$=webstr$,"MiscChrg",fdel$
	webstr$=webstr$,"MiscCost",fdel$
	webstr$=webstr$,"MiscTax",fdel$
	webstr$=webstr$,"MiscGP",fdel$ ! not edittable
	webstr$=webstr$,"MiscDel",fdel$ ! not edittable
	list$[1]=Webstr$
	let row=2
	mat read #ch_rot,roh.totrec,208;mcharge;
	mat read #ch_rot,roh.totrec,168;MCODE; 
	mat read #ch_rot,roh.totrec,358;MCTXBL;
	for ctr=0 to 9
		if mcode[ctr]>0
			webstr$=""
			webstr$=Rtrim$(mcode[ctr] Using "###") + fdel$
			let tmp$=""
			read record #ch_misc,mcode[ctr];misc.;
			let tmp$=misc.desc$
			webstr$=webstr$+Rtrim$(tmp$)+fdel$
			let amount=mcharge[ctr,0] 
			If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
				factor=roh.currfact
				call currconvup(amount,factor)
				let amount=fns(amount)
			endif
			webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! mcharge[ctr,0] 
			let amount=mcharge[ctr,1] 
			If p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
				factor=roh.currfact
				call currconvup(amount,factor)
				let amount=fns(amount)
			endif
			webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! mcharge[ctr,1]
			let tmp$="N"
			if mctxbl[ctr]<>0 let tmp$="Y"
			webstr$=webstr$+tmp$+fdel$ ! tax
			let tmp$="N"
			if int(fra(mcode[ctr])*10) let tmp$="Y"
			webstr$=webstr$+tmp$+fdel$ ! gp
			let tmp$="N"
			IF INT(FRA(MCODE[ctr]*10)*10)=9 let tmp$="Y"
			webstr$=webstr$+tmp$+fdel$ ! del charge
			list$[row]=webstr$
			let row=row+1
		endif
	next ctr
	
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! status section
  else
    include "src/callsuberr.inc"
  end try
end Sub ! DelvyChg
!--------------------------------------------------------------------------------
Sub DoZone()
! zone info
  Try
	call dxget ("custid",Custid$)
	let custid=custid$
	call dxget ("orderid",orderid$)
	let orderid=orderid$
	call dxget ("shipdateedit",tmp$)
	let shipdateedit=tmp$ !(0- recalc, 1- do not recalc)
	call dxget ("droplistzonefle",tmp$)
	let ros.zone$=tmp$+"  "
	call dxget ("shipdate",tmp$)
	if tmp$<>"999999"
		xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
		roh.shipdate=xdate$[3,8]
	else
		let roh.shipdate=999999
	endif
	!call dxget ("duedate",tmp$)
	!xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
	!roh.CancelDate=xdate$[3,8]
	call dxget ("orderdate",tmp$) ! in mm/dd/yyyy
	xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
	let roh.orddate=xdate$[3,8]
	call dxget ("Truck",tmp$)
	let ros.truck=tmp$
	call dxget ("routinglist",tmp$)
	let roh.shipvia$=tmp$+"                          "
	let returnstatus=1
	let message$="OK"
	clear zn.
	let mode$="="
	let dirno=1
	ZoneRec=FileGetZonefle(e$,Ch_Zone,mode$,dirno,ros.zone$,zn.)
	if zonerec>0
		let ros.truck=zn.trucknum
		if trim$(zn.shipvia$)<>""
			let roh.shipvia$=zn.shipvia$
		endif
		if shipdateedit=0
			call calcshipdate()	
		endif
	else
		let returnstatus=0
		let message$="Zone "+ros.zone$+" Not On File"
	endif
	!!! send over headings
	Clear List$[]                                                         
	List$[0] = bsdel$ + "ZoneInfo" + fdel$ ! section name
	webstr$="Truck",fdel$
	webstr$=webstr$,"droplistdzonefle",fdel$ ! zone
	webstr$=webstr$,"ShipDate",fdel$
	webstr$=webstr$,"CanDate",fdel$
	webstr$=webstr$,"RoutingList",fdel$
	let list$[1]=webstr$
	if returnstatus<>0 ! no errors send over the data
		webstr$=str$(ros.truck),fdel$
		webstr$=webstr$,ros.zone$,fdel$
		if roh.shipdate
			if roh.shipdate<>999999
				let xdate$=pdate$(roh.shipdate)
			else
				let xdate$="999999"
			endif
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! ship date
		if roh.CancelDate
			let xdate$=pdate$(roh.CancelDate)
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! due date
		webstr$=webstr$,rtrim$(roh.shipvia$),fdel$
		let list$[2]=webstr$
	endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	               
	! status section *** last section ***
	!!! send over fields
  else
    include "src/callsuberr.inc"
  end try
end Sub ! DoZone
!--------------------------------------------------------------------------------
Sub GetLists()
 Try
	!================================= Begin Action Droplist ================================================
	  if action1$="ORDHLISTS"		!						doc=QTH-droplistordhlists.doc
		call FileDropListEntdby(e$,etList$[],100,ch_et) ! ENTBY
		call AddToStr(e$,rstr$,etList$[])
		call FileDropListArtermcode(e$,atList$[],100,ch_terms) ! AR TERMS
		call AddToStr(e$,rstr$,atList$[]) !
		call FileDropListDivifle(e$,divList$[],100,ch_div) ! DIVISION LIST 
		call AddToStr(e$,rstr$,divList$[])
		call FileDropListSorce(e$,srcList$[],100,ch_src) ! SOURCE LIST
		call AddToStr(e$,rstr$,srcList$[])
		call FileDropListDeptfle(e$,deptList$[],100,ch_dept) ! DEPTFLE
		call AddToStr(e$,rstr$,deptList$[])
		call FileDropListZonefle(e$,ZoneList$[],100,ch_zone) ! ZONE FILE
		call AddToStr(e$,rstr$,ZoneList$[])
			call ShipTermDropList(e$,ShipTermList$[],bsdel$,esdel$,fdel$,100,ctlc) ! SHIP TERMS
			call AddToStr(e$,rstr$,ShipTermList$[])
		call RoutingDropList(e$,RoutingList$[],bsdel$,esdel$,fdel$,100,ctlc) ! ROUTING
		call AddToStr(e$,rstr$,RoutingList$[])
		call FileDropListSSlsmz(e$,SLSMList$[],100,ch_Sslsm) ! slsm list
		call AddToStr(e$,rstr$,SlsmList$[])
	   endif
	  !
	  if action1$="WHINFO"
		  call FileDropListWhinfoz(e$,whList$[],100,ch_wh)
		 call AddToStr(e$,rstr$,whList$[])
	  endif
	  if action1$="ENTDBY"
		call FileDropListEntdby(e$,etList$[],100,ch_et)
		call AddToStr(e$,rstr$,etList$[])
	  endif
	  if action1$="ARTERM"
		call  FileDropListArtermcode(e$,atList$[],100,ch_terms)
		call AddToStr(e$,rstr$,atList$[])
	  endif
	  if action1$="DIVIFLE"
		call FileDropListDivifle(e$,divList$[],100,ch_div)
		call AddToStr(e$,rstr$,divList$[])
	  endif
	  If action1$="SORCE"
		call FileDropListSorce(e$,srcList$[],100,ch_src)
		call AddToStr(e$,rstr$,srcList$[])
	  endif
	  If action1$="SSLSM"
		call FileDropListSslsmz(e$,slsmList$[],100,ch_sslsm)
		call AddToStr(e$,rstr$,slsmList$[])
	  endif
	  If action1$="DEPT"
		call FileDropListDeptfle(e$,deptList$[],100,ch_dept)
		call AddToStr(e$,rstr$,deptList$[])
	  endif	 
	  If action1$="ZONE"
		call FileDropListZonefle(e$,ZoneList$[],100,ch_zone)
		call AddToStr(e$,rstr$,ZoneList$[])
	  endif	
	  if action1$="ORDTYPE"
		call OrdTypeDropList(e$,OrdTypeList$[],bsdel$,esdel$,fdel$,100,ctlc)
		call AddToStr(e$,rstr$,OrdTypeList$[])
	  endif
	  if action1$="SHIPTERM"
		call ShipTermDropList(e$,ShipTermList$[],bsdel$,esdel$,fdel$,100,ctlc)
		call AddToStr(e$,rstr$,ShipTermList$[])
	  endif
	  !if action1$="ROUTING"
		!call RoutingDropList(e$,RoutingList$[],bsdel$,esdel$,fdel$,100,ctlc)
		!call AddToStr(e$,rstr$,RoutingList$[])
	  !endif
	  if action1$="CUSTOMER"
		Section$="CustInfo"
		Field$[0]="CustomerCode" ! customer #
		Field$[1]="CustomerBillTo" ! bill to customer #
		Field$[2]="Name$" ! customer name
		Field$[3]="Contact$" ! contact
		Field$[4]="Addr1$" ! address line 1
		Field$[5]="Addr2$" ! address line 2
		Field$[6]="City$" ! city
		Field$[7]="State$" ! state
		Field$[8]="Zip4$" ! zip code
		Field$[9]="Phone$" ! telephone #
		
		clear List$[]
		Dir=2
		call filedroplistcust(e$,list$[],maxcnt,Ch_Cust,Section$,Field$[],Dir,SearKey$)
		call AddToStr(e$,rstr$,List$[])
	endif
      call SetOutput(e$,rstr$)
  else
    include "src/callsuberr.inc"
  end try
end Sub ! GetLists
!--------------------------------------------------------------------------------
Sub DiffOT()
! changing Order type
  Try
	! due to changing from default to a diff ordertype
	let returnstatus=1
	let message$="OK"
	call dxget ("custid",Custid$)
	let custid=custid$
	call dxget ("orderid",orderid$)
	let orderid=orderid$
	call dxget ("ordtype",tmp$)
	let ordtype=tmp$
	let keycust$=custid using "######"
	let mode$="="
	let dirno=1
	if custid>0
		CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
	else
		custrec=-1
	Endif
	if custrec<=0
		let returnstatus=0
		let message$="Customer "+str$(custid)+" Not on File"
	Else ! okay
		if orderid<>0
			keyroh$=" ",keyroh$
			keyroh$[1,7]=custid using "#######" 
			keyroh$[8,13]=orderid using "######"
			KEYROH$[14]="" ! no space
			mode$="=" ! search mode 2
			dir=2
			clear chan[]
			CHAN[0]=CH_ROH
			CHAN[1]=CH_ROS
			CHAN[2]=CH_ROT
			Rec_roh=filegetqohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
			if rec_roh<0
				let returnstatus=0
				let message$=message$+"Quote Number "+str$(orderid)+" Not On File. "
				goto endgetotdata:
			endif
		Else ! new - need ordtype to decide
			if ordtype=16
				if cust.ConsignWh>0 and cust.ConsignWh<conswh
					let roh.ConsWh=cust.ConsignWh
					roh.Xferauth=0;roh.Authdate=0;roh.authby=0
					if p61$[54,54]="N"
						roh.xferauth=1;roh.authdate=Currdate;roh.authby=rec_uac
					Endif
				Else
					Returnstatus=0
					Message$=Message$+"Customer is not a transfer customer. "
					Goto Endgetotdata
				Endif
			Endif
		Endif
		if ordtype=0 let ordtype=roh.OrdType
		! now the individual order type data sends
		clear list$[]
		List$[0]=bsdel$,"ORDTYPE"+Str$(Ordtype),fdel$
		row=1
		List$[1]="FLDS",fdel$ ! default no fields
		List$[2]="NONE",fdel$ ! default no data
		row=3 ! the above are for no changes needed
		if ordtype<1 or ordtype>38 goto OTDDone
		If ordtype=16 ! add the header
			webstr$="XFRTOWH",fdel$
			webstr$=webStr$,"XFERAUTH",fdel$
			webStr$=WebStr$,"XADATE",fdel$
			webstr$=webStr$,"XAUSER",fdel$
			List$[1]=WebStr$
			webstr$=Str$(roh.ConsWh),fdel$
			tmp$="N" \ if roh.XferAuth let tmp$="Y"
			webstr$=webstr$,tmp$,fdel$
			let tmp$="0" \ if roh.XferAuth and roh.AuthDate let tmp$=PDate$(roh.AuthDate)
			webstr$=webstr$,tmp$,fdel$
			tmp$=" " \  if roh.XferAuth and roh.AuthBy let tmp$=Getuidinfo$(E$,IntCo,roh.AuthBy)
			webstr$=webStr$,RTrim$(tmp$[21]),fdel$
			List$[2]=WebStr$
			row=3
		Endif
		If ordtype=9 ! 
			List$[1]="STAGINGAREA",fdel$
			List$[2]=roh.WhStage$,fdel$
			row=3
		Endif
		if ordtype=4 or ordtype=15 or ordtype=24
			List$[1]="SHIPTERM",fdel$,"MSDATENT",fdel$
			webstr$=" ",webstr$ ! clear all first
			Webstr$=Str$(roh.shipterm),fdel$
			for x=0 to 23
				x2=roh.shipdatelist[x]
				if x2>100 ! valid dates are start at 000101 (01/01/2000)
					tmp$=PDate$(X2)
					Webstr$=Webstr$,tmp$,","
				Endif
			Next X
			if webstr$[len(webstr$)]="," let webstr$[len(webstr$)]="" ! remove last ","
			webstr$=webstr$,fdel$ ! add fld delim
			List$[2]=webstr$
			row=3
		Endif
		IF ordtype=5 ! future
			LIST$[1]="ALCSTKDATE",fdel$
			tmp$=""
			if roh.CmInvHist let tmp$=PDate$(roh.CmInvHist)
			list$[2]=tmp$,fdel$
			row=3
		Endif
		OTDDone: ! finished
	  List$[row]=esdel$
	  call AddToStr(e$,rstr$,list$[])	
	Endif ! of valid or invalid custid
	endgetotdata: ! done
	! end of GETOTFLDS
  else
    include "src/callsuberr.inc"
  end try
end Sub ! DiffOT
!--------------------------------------------------------------------------------
Sub SavOTData()
  Try
	let returnstatus=1
	let message$="OK"
	call dxget ("custid",Custid$)
	let custid=custid$
	call dxget ("orderid",orderid$)
	let orderid=orderid$
	call dxget ("ordtype",tmp$)
	let ordtype=tmp$
	let keycust$=custid using "######"
	let mode$="="
	let dirno=1
	if custid>0
		CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
	else
		custrec=-1
	Endif
	if custrec<=0
		let returnstatus=0
		let message$="Customer "+str$(custid)+" Not on File"
	Else ! okay
		!if orderid<>0 ! HAS TO HAVE ORDER ID!!
			keyroh$=" ",keyroh$
			keyroh$[1,7]=custid using "#######" 
			keyroh$[8,13]=orderid using "######"
			KEYROH$[14]="" ! no space
			mode$="=" ! search mode 2
			dir=2
			clear chan[]
			CHAN[0]=CH_ROH
			CHAN[1]=CH_ROS
			CHAN[2]=CH_ROT
			Rec_roh=filegetqohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
			if rec_roh<0
				let returnstatus=0
				let message$=message$+"Quote Number "+str$(orderid)+" Not On File. "
				goto SPendgetotdata:
			endif
		!Else ! new - need ordtype to decide
		!Endif
		if ordtype=0 let ordtype=roh.OrdType
		roh.ordtype=ordtype
		! now the individual order type data sends
		if roh.ordtype=9
			call dxget("STAGINGAREA",tmp$)
			let roh.WhStage$=tmp$+Blank$
		Endif
		if roh.ordtype=5 ! future
			call dxget("ALCSTKDATE",tmp$) ! allow zero - sys date
			tmp1$=chkDateFrmt$(tmp$) ! chk/convert to mm/dd/yyyy
			if tmp1$[1,1]<"0" and tmp1$[1,1]>"9" let tmp1$=""
			x$=formatdate2$(tmp1$) ! from mm/dd/yyyy to yyyymmdd
			roh.CmInvHist=x$[3,8] ! H5[10] on native
			if roh.CmInvHist<101 or roh.CmInvHist>991231 let roh.CmInvHist=0
		Endif
		If roh.ordtype=16
			call dxget("XFERAUTH",tmp$)
			if UCase$(RTrim$(tmp$))="Y"
				If roh.XFERAUTH=0 ! not previously authorized
					let roh.XferAuth=1
					roh.AuthBy=rec_uac
					roh.AuthDate=CurrDate
				Endif
			Endif ! if "N" or previously auth - leave alone
		Else
			roh.XferAuth=0
			roh.AuthBy=0
			roh.AuthDate=0
		Endif
		if roh.ordtype=4 or roh.ordtype=15 or roh.ordtype=24 ! doc=QTH-SubmitOT15Flds.doc
			! has ship term & (shipdatelist[] if shipterm=0
			CALL dxget("SHIPTERM",tmp$)
			x2=tmp$  ! options ###=every # days, -## = that day every month
			if x2<0 and x2<-31
				let returnstatus=0
				let message$=message$+"Ship on day Invalid"
				goto SPendgetotdata:
			Endif
			ROH.ShipTerm=x2
			if roh.shipterm=0 ! means entered individual dates
				call OTMSDTIN() ! get in / arrange S3[23]
			Else ! no dates
				Clear roh.shipdatelist[]
			Endif
		Else
			roh.shipterm=0
			Clear roh.shipdatelist[]
		Endif
		WRITE RECORD #CH_ROH,REC_ROH,0;roh.;
	Endif
	SPendgetotdata: 
	! end of SUBMITOTFLDS
  else
    include "src/callsuberr.inc"
  end try
end Sub ! SavOTData
!--------------------------------------------------------------------------------
Sub SavMessg()
  Try
	call dxget ("SOURCE",tmp$)
	let source=tmp$
	if source=207
		let returnstatus=0
		message$="No Update. Inquiry Only"
		goto EndOrdMsgSubmit
	endif
	call dxget ("orderid",orderid$)
	let orderid=orderid$
	let returnstatus=1
	let message$="OK" ! null need to append with errors 
	if not(orderid)
		let returnstatus=0
		let message$="Quote Number "+str$(orderid)+" Not on File"
		goto EndOrdMsgSubmit:
	else
		keyroh$=" ",keyroh$
		keyroh$[3]=orderid using "######"
		For ctr=94 to 97 
			let keyroh$[1,2]=ctr using "##"
			search #ch_roh,2,1;keyroh$,rec_roh,e
			if not (e)
				read record #ch_roh,rec_roh;roh.;
				goto chkordmsgstat:
			endif
		next ctr
		For ctr=1 to 93
			  If ctr<20 or ctr>25 ! skip delete
				let keyroh$[1,2]=ctr using "##"
				search #ch_roh,2,1;keyroh$,rec_roh,e
				if not (e)
					read record #ch_roh,rec_roh;roh.;
					goto chkordmsgstat:
				endif
			endif
		next ctr
		let returnstatus=99
		let message$="Order Number "+str$(orderid)+" Not on File"
		goto EndOrdMsgSubmit:
		chkordmsgstat: !!!!
		if returnstatus<>0
			call verifystat()
			if returnstatus=99 goto EndOrdMsgSubmit:
		endif
		let keyrom$=" ",keyrom$
		let keyrom$=orderid using "######"
		dir=1
		mode$=">"
		DO	! removes existing message lines
			dir=1
			mode$=">"
			rec_tmp=filegetqom(e$,ch_rom,mode$,dir,keyrom$,rom.)
			if rec_tmp<=0 exit do
			let tmp3=keyrom$[1,6]\if tmp3<>orderid exit do
			if rom.ordnum<>orderid
				let rom.ordnum=orderid
				let rom.space$=" ",rom.space$
				write record#ch_rom,rec_tmp;rom.;
			endif
	        mode$ = "d" ! delete                                              
			UpdStatus = fileupdateqom(e$,ch_rom,mode$,rec_tmp,rom.)
		loop
	
		call dxget("ttlmsg",tmp$)
		let totctr=tmp$
		If totctr>=1
		for ctr=1 to totctr
			clear rom.
			call dxget ("message"+str$(ctr),tmp$)
			tmp1$=clrtxtc$(e$,tmp$) ! chk/clr control chars
			let rom.message$=tmp1$+Blank$
			call dxget ("messagetypeid"+str$(ctr),tmp$)
			let msgtype=tmp$
			let rom.ordnum=orderid
			let rom.messageline=((msgtype*100)+1)
			let rom.space$=" ",rom.space$
			let keyrom$=" ",keyrom$
			let keyrom$[1,6]=orderid using "######"
			do
				let keyrom$[7,9]=rom.messageline using "###"
				search #ch_rom,2,1;keyrom$,rec_tmp,e
				if e exit do
				let tmp3=keyrom$[1,6]
				if tmp3<>orderid exit do
				let rom.messageline=rom.messageline+1
				if rom.messageline>999
					let returnstatus=0
					let message$="Message Line Number Exceeds Limit of 999"
					exit do
				endif
				if msgtype<>9
					if rom.messageline>=((msgtype*100)+201) ! 
						let returnstatus=0
						let message$="Message Line Number Exceeds Parameters"
						exit do
					endif
				endif
			loop
			If returnstatus<>0 ! no error add it in
				mode$ = "a" ! delete                                              
				UpdStatus = fileupdateqom(e$,ch_rom,mode$,rec_tmp,rom.)		
			endif
		next ctr
		endif ! === if totctr>=1
	endif
	EndOrdMsgSubmit: ! 
	clear list$[]
	List$[0]=bsdel$,"OrdMsgSubmit",fdel$
	WebStr$="OrderId",fdel$
	List$[1]=WebStr$
	WebStr$=str$(orderid),fdel$
	LIST$[2]=Webstr$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! status section
  else
    include "src/callsuberr.inc"
  end try
end Sub ! SavMessg
!--------------------------------------------------------------------------------
Sub GetMessg()
  Try
	! section 1 - Message Type Droplist
	call dxget ("SOURCE",TMP$)
	let source=tmp$
	clear list$[]
	List$[0]=bsdel$,"MessageTypeDroplist",fdel$
	WebStr$="ID",fdel$
	WebStr$=Webstr$,"Desc",fdel$
	List$[1]=WebStr$
	let row=2
	! if source<>207 ! not inquiry
	for ctr=0 to 9
		let tmp$=rtrim$(msglist$[((ctr*16)+1),((ctr*16)+16)])
		if tmp$<>""
			webstr$=str$(ctr),fdel$
			webstr$=webstr$,tmp$,fdel$
			List$[row]=WebStr$
			let row=row+1
		endif
	next ctr
        ! endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! section 2 - Order Messages
	call dxget ("orderid",orderid$)
	let orderid=orderid$
	let returnstatus=1
	let message$="OK" ! null need to append with errors 
	if not(orderid)
		let returnstatus=0
		let message$="Quote Number "+str$(orderid)+" Not on File"
	else
		For ctr=1 to 99
			If ctr<20 or ctr>25 ! skip delete
				let keyroh$[1,2]=ctr using "##"
				search #ch_roh,2,1;keyroh$,rec_roh,e
				if not (e)
					read record #ch_roh,rec_roh;roh.;
					goto endordmsgchk:
				endif
			endif
		next ctr
		let returnstatus=99
		let message$="Quote Number "+str$(orderid)+" Not on File"	
	endif
	endordmsgchk: ! end checking for the order message
	clear list$[]
	List$[0]=bsdel$,"OrderMessages",fdel$
	WebStr$="Message",fdel$
	WebStr$=Webstr$,"MessageTypeID",fdel$
	Webstr$=Webstr$,"MessageTypeDesc",fdel$
	List$[1]=WebStr$
	let ctr=2
	if returnstatus<>0
		let keyrom$=" ",keyrom$
		let keyrom$=orderid using "######"
		dir=1
		mode$=">"
		DO	! removes existing message lines
			rec_tmp=filegetqom(e$,ch_rom,mode$,dir,keyrom$,rom.)
			if rec_tmp<=0 exit do
			let tmp3=keyrom$[1,6]\if tmp3<>orderid exit do
	                let msgtype=0 ! invoice
			if rom.messageline>200 and rom.messageline<401
				let msgtype=2 ! order
			endif
			if rom.messageline>400 and rom.messageline<601
				let msgtype=4 ! invoice/order
			endif
			if rom.messageline>600 and rom.messageline<801
				let msgtype=6 ! Bill of Lading
			endif
			if rom.messageline>800 and rom.messageline<1001
				let msgtype=8 ! Internal
			endif
			tmp$=clrtxtc$(e$,rom.message$) ! chk/clr control chars
			WebStr$=RTrim$(tmp$),fdel$ ! rom.message$,fdel$
			WebStr$=Webstr$+str$(msgtype),fdel$
			let tmp$=rtrim$(msglist$[((msgtype*16)+1),((msgtype*16)+16)])
			Webstr$=Webstr$,tmp$,fdel$
			List$[ctr]=WebStr$
			let ctr=ctr+1
		loop
	endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! special message section
	clear list$[]
		Ch_spmsg = OpenFile(-1776,intCo) \ If ch_spmsg = -1 Error 42
		Call FileDropListSpecMsg(e$,List$[],maxcnt,Ch_spmsg)
		Try Close #ch_spmsg Else Rem
	 Call AddToStr(e$,rstr$,List$[])  
	 !Call AddToStr(e$,rstr$,esdel$) ! end of section
	 
	! status section
  else
    include "src/callsuberr.inc"
  end try
end Sub ! GetMessg
!--------------------------------------------------------------------------------
Sub AddQteLP()
! add all lines to last price - PM="quote117" program
 Try
	Dim ContKey$[60]
	Dim 2%,TmpH0[12],H5[16]
	Dim 3%
	if p61$[75,75]<>"Y" ! not active
		let returnstatus=0
		let message$="Option is not active"
		goto AQLPDone:
	endif
	! QOL Open as ch_rol
	CH_CQ=OpenFile(9937,IntCo) \ if ch_cq=-1 error 42
	call dxget ("CUSTID",Custid$)
	Custid=custid$
	call dxget ("ORDERID",orderid$)
	let orderid=orderid$
	let returnstatus=1
	let message$="OK"
	keyroh$=" ",keyroh$
	keyroh$[1,7]=custid using "#######" 
	keyroh$[8,13]=orderid using "######"
	KEYROH$[14]="" ! no space
	mode$="=" ! search mode 2
	dir=2
	clear chan[]
	CHAN[0]=CH_ROH
	CHAN[1]=CH_ROS
	CHAN[2]=CH_ROT
	Rec_roh=filegetqohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
	if rec_roh<0
		let returnstatus=0
		let message$="Quote Number ",STR$(ORDERID)," Not On File"
		goto AQLPDone:
	endif
	if p61$[106,106]="Y" and rot.HoldCode<>0 and roh.HoldOver=0
		let returnstatus=0
		let message$="Quote Number ",STR$(ORDERID)," is on Hold"
		goto AQLPDone:
	endif
	MAT READ #CH_ROH,REC_ROH,0;TMPH0;
	mat read #ch_roh,rec_roh,104;H5; ! uses pm vars in call
	let keyrol$=" ",keyrol$;keyrol$=orderid using "######"
	REM CK FIRST IF IN CUST QUOTE FILE- IF NOT - ADD IT
	LET CONTKEY$=KeyRol$[1,6]
	LET CONTKEY$[7]=""
	SEARCH #CH_CQ,2,1;CONTKEY$,REC[1],E
	IF E>1 Goto AQLPDone ! file bad - exit NOW
	IF E
	  LET CONTKEY$=" ",CONTKEY$              
		LET CONTKEY$[1,6]=ROH.CustNum USING "######" 
		LET CONTKEY$[7,12]=roh.OrdNum USING "######"
		SEARCH #CH_CQ,4,2;CONTKEY$,REC_ROH,E
		LET CONTKEY$=" ",CONTKEY$
		LET CONTKEY$[1,6]=ROH.OrdNum USING "######" 
		LET CONTKEY$[7,12]=ROH.CustNum USING "######"
		SEARCH #CH_CQ,4,1;CONTKEY$,REC_ROH,E
	ENDIF
	QOUNTER=0
	Loop_QOL: ! loop all quote lines
	search #ch_rol,3,1;keyrol$,rec_rol,e
	x2=keyrol$[1,6] \  if x2<>orderid let e=2
	if not (e)
		LET CONTKEY$=KeyRol$[1,6]
		Do
			SEARCH #CH_CQ,3,1;CONTKEY$,REC_CQ,E
			IF E  Exit do
			LET X2=CONTKEY$[1,6] \ IF X2<>roh.OrdNum Exit do
			LET QOUNTER=QOUNTER+1
			LET TMPH0[4]=CONTKEY$[7,12] ! change customer
			LET REC_LASTPR=0
			LET X2[0]=ch_roh ! 8
			LET X2[1]=ch_rol ! 11
			LET X2[2]=CH_LSTPR ! 19
			LET X2[3]=CH_PROD ! 3
			LET X2[4]=CH_SPRODDESC ! 12
			let x2[5]=ch_cq ! 
			let x2[6]=Ch_slstpr
			let x2[7]=ch_ros
			let x2[8]=ch_ccode
			let x2[9]=rec_roh
			CALL "build117",TMPH0[],H5[],REC_LASTPR,REC_ROL,X2[],"",IntCo
		LOOP
		Goto Loop_QOL:
	endif
	Returnstatus=1
	message$="Added "+Str$(QOUNTER)+" Last Price records"
	AQLPDone: ! finished
 else
    include "src/callsuberr.inc"
 end try
end Sub ! AddQteLP
!--------------------------------------------------------------------------------
Sub CustQuote()
! add/delete 3/custquote# file (Index Only)
 Try
	Dim CCDesc$[30],PTDesc$[24]
	dim 3%,R[99]
	Returnstatus=0
	Message$="Action 1 not valid"
	if p61$[75,75]<>"Y" ! not active
		let returnstatus=0
		let message$="Option is not active"
		goto CQDone:
	endif
	StartCQHere: ! we're off
	If Action1$="GETLISTS" ! the CustCtgy & PriceType Lists	doc=QTH-CQGetLists.doc
		RETURNSTATUS=1
		Message$="OK"
		! use standard Customer Search/Lookup for Cust/billto
		CCTC=Openfile(-2096,IntCo) \ if cctc=-1 Error 42 ! custctgy
		CPTC=OpenFile(-752,IntCo) \ if cptc=-1 Error 42 ! prictype
		Clear List$[]
		List$[0]=bsdel$,"CUSTCTGY",fdel$
		List$[1]="ID",fdel$,"DESC",fdel$
		row=2
		tmpcnt=maxcnt
		for R=1 to CHF(cctc)-1
			Read #cctc,r,0;CCDesc$;
			tmp$=RTrim$(CCDesc$)
			if tmp$<>""
				Webstr$=Str$(R),fdel$,tmp$,fdel$
				List$[row]=webstr$
				row=row+1
				If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
			Endif
		Next R
		list$[row]=esdel$
		call AddToStr(e$,rstr$,List$[]) ! "add the list to string 
		Clear List$[]
		list$[0]=bsdel$,"PRICETYPE",fdel$
		List$[1]="ID",fdel$,"DESC",fdel$
		row=2
		for r=1 to CHF(cptc)-1
			Read #cptc,r,0;PTDesc$;
			tmp$=RTrim$(PTDESC$)
			if tmp$<>""
				Webstr$=Str$(R),fdel$,tmp$,fdel$
				List$[row]=webstr$
				row=row+1
				If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
			Endif
		Next R
		list$[row]=esdel$
		call AddToStr(e$,rstr$,List$[]) ! "add the list to string 
	Endif
	If Action1$="GETDATA" ! get current list				doc=QTH-CQGetData.doc
		CQC=OpenFile(-9937,IntCo) \ if cqc=-1 Error 42
		! first get/check Quote
		call dxget ("CUSTID",Custid$)
		Custid=custid$
		call dxget ("ORDERID",orderid$)
		let orderid=orderid$
		let returnstatus=1
		let message$="OK"
		keyroh$=" ",keyroh$
		keyroh$[1,7]=custid using "#######" 
		keyroh$[8,13]=orderid using "######"
		keyroh$[14]=""
		mode$="=" ! search mode 2
		dir=2
		clear chan[]
		CHAN[0]=CH_ROH
		CHAN[1]=CH_ROS
		CHAN[2]=CH_ROT
		Rec_roh=filegetqohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
		if rec_roh<0
			let returnstatus=0
			let message$="Quote Number ",STR$(ORDERID)," Not On File"
			goto CQDone:
		endif
		if p61$[106,106]="Y" and rot.holdcode<>0 and roh.HoldOver=0 ! ON HOLD - NO
			let returnstatus=0
			let message$="Quote Number ",STR$(ORDERID)," is on HOLD"
			goto CQDone:
		endif
		keyroh$=" ",keyroh$ ! use same var
		KEYROH$=orderid using "######"
		list$[0]=bsdel$,"CUSTQUOTE",fdel$
		List$[1]="CUSTID",fdel$,"NAME",fdel$
		row=2;ffnd=0
		tmpcnt=maxcnt
		If ffnd=0 ! First Line - Send Quote Customer
			Custid=roh.CustNum ! is always on it!
			SearKey$=custid using M6$
			mode$="="
			dirno=1
			if custid>0
				CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,SearKey$,cust.)
			else
				custrec=-1
				Clear Cust.
			Endif
			Webstr$=Str$(custid),fdel$,RTrim$(cust.name$),fdel$
			List$[row]=webstr$
			row=row+1
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
			ffnd=1
		Endif
		do
			Search #cqc,3,1;KEYROH$,r[1],e
			IF E exit do
			x2=keyroh$[1,6] \ if x2<>orderid exit do
			Custid=keyroh$[7,12]
			if ffnd=1 ! see if same as first one
				if custid=roh.CustNum goto BPCQC
			Endif
			SearKey$=custid using M6$
			mode$="="
			dirno=1
			if custid>0
				CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,SearKey$,cust.)
			else
				custrec=-1
				Clear Cust.
			Endif
			Webstr$=Str$(custid),fdel$,RTrim$(cust.name$),fdel$
			List$[row]=webstr$
			row=row+1
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
			BPCQC: ! allow for bypassing
		Loop
		
		List$[row]=esdel$
		call AddToStr(e$,rstr$,List$[]) ! "add the list to string 
	Endif
	If Action1$="SUBMIT" ! check action2 for what
		CQC=OpenFile(9937,IntCo) \ if cqc=-1 Error 42
		! first get/check Quote
		call dxget ("CUSTID",Custid$)
		Custid=custid$
		call dxget ("ORDERID",orderid$)
		let orderid=orderid$
		let returnstatus=1
		let message$="OK"
		keyroh$=" ",keyroh$
		keyroh$[1,7]=custid using "#######" 
		keyroh$[8,13]=orderid using "######"
		KEYROH$[14]="" ! no space
		mode$="=" ! search mode 2
		dir=2
		clear chan[]
		CHAN[0]=CH_ROH
		CHAN[1]=CH_ROS
		CHAN[2]=CH_ROT
		Rec_roh=filegetqohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
		if rec_roh<0
			let returnstatus=0
			let message$="Quote Number ",STR$(ORDERID)," Not On File"
			goto CQDone:
		endif
		if p61$[106,106]="Y" and rot.holdcode<>0 and roh.HoldOver=0 ! ON HOLD - NO
			let returnstatus=0
			let message$="Quote Number ",STR$(ORDERID)," is on HOLD"
			goto CQDone:
		endif
		Addfld=0;delfld=0
		if action2$="ADDCUST" ! add manual cust				doc=QTH-CQAddCust.doc
			Addfld=1;x1=1
		Endif
		If action2$="DELCUST" ! del manual cust				doc=QTH-CQDelCust.doc
			Delfld=1;x1=1
		Endif
		if action2$="ADDBILLTO" ! add for billto			doc=QTH-CQAddBilltoCusts.doc
			Addfld=2;x1=2
		Endif
		if action2$="DELBILLTO" ! del for billto			doc=QTH-CQDelBilltoCusts.doc
			Delfld=2;x1=2
		Endif
		if action2$="ADDCCTGY" ! add Cust Ctgy				doc=QTH-CQAddCCtgy.doc
			Addfld=3;x1=3
		Endif
		if action2$="DELCCTGY" ! del cust ctgy				doc=QTH-CQDelCCtgy.doc
			DelFld=3;x1=3
		Endif
		if action2$="ADDPTYPE" ! add price type				doc=QTH-CQAddPType.doc
			Addfld=4;x1=4
		Endif
		if action2$="DELPTYPE" ! del price type				doc=QTH-CQDelPType.doc
			DelFld=4;x1=4
		Endif
		if addfld=0 and delfld=0 ! not found
			returnstatus=0
			message$="Action 2 not valid"
			goto CQDone
		Endif
		! get standard field to process
		Call dxget("FLDVAL",tmp$)
		tmp3=tmp$
		if tmp3<=0 ! has to have something!
			returnstatus=0
			message$="NO VALUE WAS SENT TO WORK ON!"
			goto CQDone
		Endif
		If Addfld ! add something
			let x1=addfld ! set to which one (in case)
			If X1=1 ! a single customer
				Searkey$=tmp3 Using "######"
				CustRec=FileGetCust(e$,Ch_Cust,"=",1,SearKey$,cust.)
				if custrec<=0
					returnstatus=0
					message$="Customer not found"
					goto CQDone
				Endif
				If p61$[136,136]="Y"
					let keycust$=tmp3 using "######"
				    mode$="="
					dirno=1
					CNoteRec=FileGetCustNotes(e$,Ch_CNotes,mode$,dirno,KeyCust$,cnotes.)
					if cnoterec<=0
						clear cnotes.
					endif
				    !if roh.currid<>cnotes.currid! need to currency 
					!	returnstatus=0
					!	message$="Customer Is Not The Same Currency"
					!	goto CQDone	
					!endif
				endif
				rem if ua5[5] and ua5[5]<>cust.SalesmanCode
				custspec[0]=cust.customercode
                  	 if p9$[21,21]="N"
					    custsec[0] = tmp3
                       call "custsec.dl4",Custsec[],ctlc,userid$,e$,rstr$
		              ELSE
		           custsec[0]=0
		           endif
				   if custsec[0]=-1
					returnstatus=0
					message$="Customer is for a different Rep"
					goto CQDone
				Endif
				mode=4;cust=tmp3
				call cqsrch(orderid,cust,mode)
			Else ! doing a scan for the field
				Searkey$=" ",Searkey$
				do
					CustRec=FilegetCust(e$,Ch_Cust,">",1,SearKey$,Cust.)
					if custRec<=0 exit do
					if NOT(ua5[5]) OR ua5[5]=Cust.SalesmanCode
						Passgo=0 ! did not match
						if x1=2 and tmp3=cust.CustomerBillTo let passgo=1
						if x1=3 and tmp3=cust.CustomerCategory let passgo=1
						if x1=4 and tmp3=cust.PriceType let passgo=1
						if passgo<>0 and p61$[136,136]="Y"
							let keycust$=CUST.CustomerCode using "######"
							mode$="="
							dirno=1
							CNoteRec=FileGetCustNotes(e$,Ch_CNotes,mode$,dirno,KeyCust$,cnotes.)
							if cnoterec<=0
								clear cnotes.
							endif
							!if roh.currid<>cnotes.currid 
							!	if returnstatus=1
							!		let message$="Currency not the same for some customers"
							!		let returnstatus=0
							!	endif
							!	let passgo=0 ! need to currency 
							! endif

						endif
						If Passgo ! passed the audition
							mode=4;cust=SearKey$[1,6] ! cust.CustomerCode
							call cqsrch(orderid,cust,mode)
						Endif
					Endif ! of slsm sec passed security
				Loop ! custfile scan
			Endif ! of type check
		Endif ! of addfld
		if DelFld ! we are deleting something
			let x1=DelFld ! set to same (in case)
			If X1=1 ! a single customer
				mode=5;cust=tmp3 ! just do it
				call cqsrch(orderid,cust,mode)
			Else ! do a scan for the field
				SearKey$=" ",SearKey$
				SearKey$=Orderid Using "######"
				Do
					Search #cqc,3,1;SearKey$,r[1],E
					if e exit do
					x2=searkey$[1,6] \ if x2<>orderid exit do
					custid=searkey$[7,12]
					tmp$=custid using "######"
					CustRec=FilegetCust(e$,Ch_Cust,"=",1,tmp$,Cust.)
					if custRec>0 ! ok - check
						passgo=0
						if x1=2 and tmp3=cust.CustomerBillTo let passgo=1
						if x1=3 and tmp3=cust.CustomerCategory let passgo=1
						if x1=4 and tmp3=cust.PriceType let passgo=1
						if passgo ! passed the check
							mode=5;cust=custid
							call cqsrch(orderid,cust,mode)
						Endif
					Endif ! custok
				Loop ! next cq key
			Endif ! of fld type
		Endif ! of delete
		! last make sure Quote Customer is ALWAYS there
		Keyroh$=" ",Keyroh$
		Keyroh$[1,6]=OrderId Using "######"
		Keyroh$[7,12]=roh.Custnum Using "######"
		Search #cqc,2,1;keyroh$,r[1],E
		if e ! not found - ADD IT
			R=rec_roh
			Search #cqc,4,1;keyroh$,r,E
		Endif
		! check dir 2 - Cust/Quote
		tmp$=Keyroh$[7,12]+keyroh$[1,6]
		Search #cqc,2,2;tmp$,R[1],E
		if e ! not found dir 2 - ADD IT
			R=rec_roh
			Search #cqc,4,2;tmp$,r,E
		Endif
		! redisplay with new data
		if action1$="SUBMIT" and returnstatus=1
			Try close #cqc Else Rem ! close it as getdata opens it
			Action1$="GETDATA"
			goto StartCQHere
		Endif
	Endif
	CQDone: ! finished
	! status
 else
    include "src/callsuberr.inc"
 end try
end Sub ! CustQuote
!--------------------------------------------------------------------------------
Sub CQSrch(quote,Cust,mode)
! standard add/delete from Custquote file
 Try
	Dim k1$[60],k2$[60]
	K1$=" ",K1$
	K1$[1,6]=Quote using "######"
	K1$[7]=cust using "######"
	R=rec_roh
	Search #cqc,mode,1;k1$,R,E
	k2$=" ",k2$
	K2$[1,6]=cust using "######"
	K2$[7]=quote using "######"
	R=rec_roh
	Search #cqc,mode,2;k2$,R,E
  else
    include "src/callsuberr.inc"
 end try
end Sub ! CQSrch
!--------------------------------------------------------------------------------
function getnteflgs$(webstr$)
! add flags on whether notes exist
  Try
	dim HMDir$[128]
	snote=1
	chan=openfile(-1680,Intco) \ if chan=-1 let snote=0
	if ua2$[31,31]="Y" ! user wants popupnotes
		if snote ! file found
			tmp$=" ",tmp$
			tmp$=custid using "######"
			search #chan,2,1;tmp$,R,E
			if e let snote=0
		Endif
		tmp1$="N" \ if snote let tmp1$="Y"
		let webstr$=webstr$,tmp1$,fdel$ ! has suppt note
		! now the window notes
		!LET tmp1$="HOME" \ SYSTEM 28,tmp1$
		!if tmp1$[1,4]<>"HOME" and tmp1$<>"" ! got it?
		!	HMDir$=tmp1$+"/" ! add trailing /
		!Endif
		!tmp$=HMDir$+"files/notes/C"+Str$(IntCo)+custid using "&&&&&&"+".txt"
		!Call FindF(TMP$,H) ! need full path cause of "C"
		!let wnote=h
		!tmp1$="N" \ if wnote let tmp1$="Y" ! tmp$  ! tmp$=FULL PATH NAME
		tmp1$="N" \ if ua2$[31,31]="Y" let tmp1$="Y" ! just user flag
		webstr$=webstr$,tmp1$,fdel$
	Else ! no popupnotes wanted/avail
		webstr$=webstr$,"N",fdel$,"N",fdel$
	Endif
	try close #chan Else Rem
  else
    include "src/callsuberr.inc"
  end try
end Function webstr$ ! getnteflgs$
!--------------------------------------------------------------------------------
Sub fut208()
! if future order type - get date (mx208fut)
 Try
	dim 1%,Weeks,L3[2]
	Dim 2%,L4[3],B[24],w2[9],H5[16]
	Dim 2%,J9[9]
	Dim 3%,S7[12],j1,r8
	Dim K1$[60],k2$[60],L1$[20],J9$[50]
	let r8=REC_ROH
	READ #Ctlc,60,20;WEEKS;
	!MAT  READ #8,R8,0;H0
	!MAT  READ #8,R8,78;H4
	MAT  READ #Ch_Roh,R8,104;H5 
	if roh.CmInvHist goto foDone ! already date
	if roh.ordtype<>5 goto fodone ! wrong ot
	LET MAXLEAD=0;WHSE=roh.Wh
	LET K1$=roh.OrdNum USING "######"
	L_2010: SEARCH #Ch_RoL,3,1;K1$,R1,E !  \ IF E>2 GOSUB ERR_SEARCH:
	IF E GOTO FOLDone:
	LET X2=K1$[1,6] \ IF X2<>roh.OrdNum GOTO FOLDONE
	MAT  READ #Ch_RoL,R1,16;L4;
	MAT  READ #Ch_RoL,R1,8;L3;
	MAT  READ #Ch_RoL,R1,168;S7;
	 MAT  READ #Ch_RoL,R1,140;L1$;
	 IF L3[0]=1 GOTO L_2010:
	 LET WHSE=L4[3] \ IF WHSE<=0 OR WHSE>99 LET WHSE=roh.Wh
	 MAT  READ #Ch_Prod,L4,156;B;
	 !GOSUB L_2500:
	 !L_2500: REM PRODUCT WAREHOUSE FILE
	 LET K2$=L1$[1,12]
	 LET K2$[13,14]=WHSE USING "##"
	SEARCH #CH_PRWH,2,1;K2$,R0,E !\ IF E>1 GOSUB ERR_SEARCH:
	IF Not(E)
		MAT  READ #CH_PRWH,R0,38;W2; 
	Else
		let w2[0]=0
	Endif
	IF MAXLEAD<W2[0] LET MAXLEAD=W2[0]
	GOTO L_2010: 
	FOLDONE: ! 
	LET D0=(MAXLEAD*30)+(WEEKS*7)
	LET X2=roh.ShipDate \  J9$=PDate$(X2) ! \ GOSUB L_7700:
	X$=J9$[1,6],J9$[9,10] ! no century
	L_8120: LET X9=0 \ LET J9$=X$[1,2],X$[4,5],X$[7,8]
	LET J9[0]=J9$[1,2] \ LET J9[1]=J9$[3,4] \ LET J9[2]=J9$[5,6]
	IF J9[2]<85 LET J9[2]=J9[2]+100
	LET X=J9[0]+1 \ LET X4=INT(1/X+.7) \ LET X2=J9[2]-X4 \ LET X3=X+12*X4
	LET X4=INT(X3*30.6001)+INT(X2*365.25)+J9[1] \ LET X3=X4-7*(INT(X4/7))
	LET J9[2]=J9$[5,6]
	LET J9[1]=J9[1]-D0 \ LET D0=0
	IF J9[1]<=0 LET J9=J9-1
	L_8202: IF J9<1 LET J9=12-ABS(J9) \ LET J9[2]=J9[2]-1
	IF J9[1]>0 GOTO L_8230:
	ON J9 GOTO L_8250:,L_8270:,L_8250:,L_8240:,L_8250:,L_8240:
	ON J9-6 GOTO L_8250:,L_8250:,L_8240:,L_8250:,L_8240:,L_8250:
	L_8230: IF J9>12 LET J9=J9-12 \ LET J9[2]=J9[2]+1 \ LET X9=1 \ GOTO L_8300

	L_8240: IF J9[1]<1 LET J9[1]=J9[1]+30 \ LET X9=1 \ GOTO L_8300:
	L_8250: IF J9[1]<1 LET J9[1]=J9[1]+31 \ LET X9=1 \ GOTO L_8300:
	GOTO L_8300:
	L_8270: IF NOT(FRA(J9[2]/4)) GOTO L_8290:
	IF J9[1]<1 LET J9[1]=J9[1]+28 \ LET X9=1 \ GOTO L_8300:
	IF NOT(FRA(J9[2]/4)) GOTO L_8300:
	L_8290: IF J9[1]<1 LET J9[1]=J9[1]+29 \ LET X9=1 \ GOTO L_8300:
	L_8300: IF J9[1]<1 LET J9=J9-1 \ GOTO L_8202:
	LET J1=J9[2]*10^4+J9*10^2+J9[1] \ LET X2=J1 !\ GOSUB L_7700:
	Let j9$=PDate$(X2) \ let x$=J9$[1,6],J9$[9,10] ! no century
	IF X9 GOTO L_8120:
	LET H5[10]=X2
	MAT  WRITE #ch_roh,R8,104;H5;
	let roh.CmInvHist=h5[10]
	FODONE: ! 
 else
	include "src/callsuberr.inc"
 end try
End sub ! fut208
!--------------------------------------------------------------------------------
Sub verifystat()
! verify status on save data 
! header record needs to read first
  Try
	
	if returnstatus<>1
		goto endverifystat: ! already has error
	endif
	Call dxget("SOURCE",tmp$)
	let tmp3=tmp$
	if tmp3=207 goto endverifystat: ! inquiry
	if credit<>0
		if roh.status<>97
			let returnstatus=99
			let message$="Credit is no longer in an edit status. Data is not saved. "	
		endif
		goto endverifystat:
	endif
	if tmp3=251 or tmp3=231
		if roh.status<>94
			let returnstatus=99
			let message$="Invoice is not longer in an edit status. Data is not saved. "
		endif
		goto endverifystat:
	endif
	if tmp3=223 
		if roh.status<>96 and roh.status<>95
			let returnstatus=99
			let message$="Invoice is no longer in an edit status. Data is not saved. "
		endif
		goto endverifystat:
	endif
	If not(tmp3) 
		if roh.status<94  or roh.status>96
			let returnstatus=99
			let message$="Order is no longer in an edit status. Data is not saved. "
		endif
		goto endverifystat:
	endif
	if roh.status<>95
		let returnstatus=99
		let message$="Order is no longer in an edit status. Data is not saved. "
	endif
	endverifystat: ! end the status check
		

	! status section
	e$=""
	!
	!  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	!  call AddToStr(e$,rstr$,WebStr$)
	!  call SetOutPut(e$,rstr$)
  else
    include "src/callsuberr.inc"
 end try
end sub ! verifystat
! 
!--------------------------------------------------------------------
Sub OnHoldChk()
	! does gp exceptions - returns flags set
	! roh/rot files should have already been read
	! holdcode flag should already have been read and set prior
Try
	Dim PrFlg$[10]
	if p61$[106,106]<>"Y" goto ONHChkDone  ! no holds on quotes
	if credit<>0 goto ONHChkDone  ! no holds on credit
	if roh.ordtype=16 goto ONHChkDone ! no hold on warehouse transfer
    if roh.ordtype=20 goto ONHChkDone ! no hold on Future orders
	if roh.ordtype=8  goto ONHChkDone ! no hold on consignments
	if roh.holdover<>0 goto ONHChkDone ! hold override in effect
	clear holddesc$[]
	clear holdpswd$[]
	clear holdcodeflag[]
	
	for ctr=1 to 12
		read #ctlc,65,((ctr*16)-16);holddesc$[ctr];
		read #ctlc,66,((ctr*16)-16);holdpswd$[ctr];
	next ctr
	clear ex[]
	overpswd$=""
	Ch_exlist = openfile(1760,intCo) \ If Ch_exlist = -1 Error 42     !"order lines file
	if ch_exlist>0
		mat read #ch_exlist,0,0;overpswd$;
		mat read #ch_exlist,roh.ordtype,0;ex;
		try close #ch_exlist  Else Rem
	endif
	! unpack the holdcode into flag from bit flag field
	tmp3=rot.holdcode 
	!for ctr=1 to 12  ! always start with no holds 
 	!	if ctr<>1 LET holdcodeflag[ctr]=SGN(FRA(tmp3/2))
	!	LET tmp3=INT(tmp3/2)
	!next ctr   
 	! do total quote gross profit check ! need ex variable
	if rtrim$(holdpswd$[2])<>"" ! has a password check for gp  
		if rot.subtot>0                                   
			let tmp3=0 ! for setting gtm
			if rot.subtot let tmp3=(rot.subtot-rot.TotShipCost)/rot.subtot*100                            
			if ex[15]<>0 and  tmp3<ex[15] let holdcodeflag[2]=1
			if ex[16]<>0 and tmp3>ex[16] let holdcodeflag[2]=1                         
 			IF EX[1] and (rot.subtot-rot.totshipcost)<EX[1] LET holdcodeflag[2]=1                  
			IF EX[2] and (rot.subtot-rot.totshipcost)>EX[2] LET holdcodeflag[2]=1
		endif
	else
		let holdcodeflag[2]=0
	endif  
	let keyrol$=" ",keyrol$
	let keyrol$=orderid using "######"
	dir=1
	let merchamt=0
	mode$=">"
	DO	! get gp on lines
		rec_tmp=filegetqolz(e$,ch_rol,mode$,dir,keyrol$,rol.)
		if rec_tmp<=0 exit do
		let tmp3=keyrol$[1,6]\if tmp3<>orderid exit do
		if rol.QtyShip<=0 goto bpgplne ! no or neg shipping
		IF rol.LineType=3 goto bpgplne ! message
		if rol.NStkItem=0 ! product
			Mat read #CH_PROD,rol.PDRecNum,1056;prflg$;
		Else
			prflg$=" ",prflg$
		Endif
		let merchamt=merchamt+ROL.ExtOrdAmt
		if (roh.ordtype=21 or roh.ordtype=22) and keyrol$[7,9]="   " goto bpgplne
		let tmp3=rol.extshipamt-rol.extloadship
		If prflg$[2,2]="Y" Goto BPLNEGP ! let holdcodeflag[2]=0;holdcodeflag[7]=0
		! gp amd gp%
		if ex[3]<>0 and tmp3<ex[3] let holdcodeflag[2]=1 ! gp
		if ex[4]<>0 and tmp3>ex[4] let holdcodeflag[2]=1 ! gp
		if ex[17]<>0 and rol.extshipamt=0 let holdcodeflag[2]=1
		if rol.extshipamt<>0
			if ex[17]<>0 and  fnr((tmp3/rol.extshipamt)*100)<ex[17] let holdcodeflag[2]=1
			if ex[18]<>0 and  fnr((tmp3/rol.extshipamt)*100)>ex[18] let holdcodeflag[2]=1
		endif
		if holdcodeflag[2]=0
			call LP1Chk()
		Endif
		BPLNEGP: ! flagged no check
		! for invoices only ! merchandise exception
		!if source>=221 and source<241 ! invoice status only
		!	if rtrim$(holdpswd$[7])<>"" and prflg$[2,2]<>"Y" ! merchandise exception
		!		IF EX[9]<>0 and rol.ExtOrdAmt<EX[9] LET holdcodeflag[7]=1     
		!		IF EX[10]<>0 and rol.ExtOrdAmt>EX[10] LET holdcodeflag[7]=1
		!	endif
		!	if rtrim$(holdpswd$[8])<>"" ! cost exception
		!		IF EX[13]<>0 and rol.ExtLoadOrd<EX[13] LET holdcodeflag[8]=1  
		!		IF EX[14]<>0 and  rol.ExtLoadOrd>EX[14] LET holdcodeflag[8]=1
		!	endif
		!endif
		
		! check roh.orgstatus for invoice/credit memo hold
		BPGPLNE: ! BYPASS	
	LOOP
	!if source>=221 and source<241 ! INVOICES ONL		
	!	if rtrim$(holdpswd$[7])<>"" ! has a password merchandise exception                            
	!		IF EX[7]<>0 and rot.subtot<EX[7] LET holdcodeflag[7]=1                           
	!		IF EX[8]<>0 and rot.subtot>EX[8] LET holdcodeflag[7]=1 
	!	else
	!		let holdcodeflag[7]=0
	!	endif
	!	if rtrim$(holdpswd$[8])<>"" ! has a password merchandise exception
	!		IF EX[11]<>0 and rot.TotShipCost<EX[11] LET holdcodeflag[8]=1                        
	!		IF EX[12]<>0 and rot.TotShipCost>EX[12] LET holdcodeflag[8]=1 
	!	else
	!		let holdcodeflag[8]=0
	!	endif
	!	if rtrim$(holdpswd$[4])<>"" ! freight exception
	!		IF EX[5]<>0 and rot.FrgtChrg+H6[6]<EX[5] LET holdcodeflag[4]=1                                               
	!		IF EX[6]<>0 and rot.FrgtChrg+H6[6]>EX[6] LET holdcodeflag[4]=1 
	!	else
	!		let holdcodeflag[4]=0
	!	endif
	!	if rtrim$(holdpswd$[2])<>"" ! gp exception
	!		LET tmp3=roh.TotDol4Prof - roh.TotCost4Prof ! H5[13]-H5[14]
	!		IF EX[15]<>0 and not(roh.TotDol4Prof) LET holdcodeflag[2]=1 
	!		IF roh.TotDol4Prof<>0 and EX[15]<>0 
	!			if FNR((tmp3/roh.TotDol4Prof)*100)<EX[15] LET holdcodeflag[2]=1
	!		endif
	!		IF roh.TotDol4Prof<>0 and EX[16]<>0
	!			if FNR((tmp3/roh.TotDol4Prof)*100)>EX[16] LET holdcodeflag[2]=1
	!		endif
	!	else
	!		let holdcodeflag[2]=0
	!	endif
	!endif ! 
	if rtrim$(holdpswd$[2])="" let holdcodeflag[2]=0
	if rtrim$(holdpswd$[6])="" let holdcodeflag[6]=0
	if rtrim$(holdpswd$[7])="" let holdcodeflag[7]=0
	if rtrim$(holdpswd$[8])="" let holdcodeflag[8]=0
	ONHChkDone: ! finished
else
    include "src/callsuberr.inc"
end try
end sub ! onholdchk
! 
!--------------------------------------------------------------------
SUB lp1chk()
	! see if over % allowed
  Try
	Dim k1$[60],k2$[60]
	Dim 2%,disccap
	Dim 3%,A[33],w3[24],r[99]
	if rol.NStkItem goto LP1CDone ! no lp1 on nonstks!
	Spcl=1
	if rol.PriceOrigin<0 or rol.PriceOrigin=1 OR rol.PriceOrigin=4 OR rol.PriceOrigin=5 LET SPCL=0
	IF rol.PriceOrigin=9 OR rol.PriceOrigin=10 OR rol.PriceOrigin=14 LET SPCL=0
	IF spcl goto LP1CDone ! special/contract price - no check!
	! got prod already - during process_line (need to recalc list 1? - hope not)
	Mat read #Ch_Prod,rol.PDRecNum,256;a;
	k1$=" ",k1$;k1$=rol.ComdtyCode$
	search #ch_comcde,2,1;k1$,r[80],E
	if e Goto LP1CDone ! no commcode - no percent!
	read #ch_comcde,r[80],58;disccap;
	if disccap<=0 or disccap>100 goto LP1CDone ! no need to check further - no/invalid min %
	LPRc1=a[20] ! list 1
	if p9$[32,32]="Y" ! whse pricing
		let k2$=" ",k2$;k2$[1,12]=rol.ProdCode$;k2$[13]=rol.Whse using "##"
		Search #Ch_PrWh,2,1;k2$,r[81],e
		if not(e)
			mat read #ch_prwh,r[81],78;w3;
			if w3[19]>0 let LPRC1=w3[19] ! only if non-zero
		Endif
	Endif
	! got list 1 - check percent lowest price allowed
	let DLP1=LPRC1-(LPRC1*(DISCCAP/100)) ! min price allowed (lp1-(lp1*disc))
	if rol.NetPrice<DLP1 let holdcodeflag[2]=1 ! fail - put gp hold ! Net or unit? let's use NET
	LP1CDone: ! finished
  else
    include "src/callsuberr.inc"
end try
end sub ! lp1chk
! 
!--------------------------------------------------------------------
function getmillitmflag$()
! see if any line on order has mill items
  Try
	Dim Key1$[60],k5$[60],l0$[20],k2$[60],k3$[60],F$[20]
	DIM 1%,ordl3[3],pgmlit,APMI,PRW1[2],miflag[9],flags[15]
	Dim 1%,pg1[3]
	dim 2%,ordl4[3],prw2[9]
	Dim 3%,WHMISC2[7],ordl7[12],R[99]
	let miflag$="N" ! none = default
	clear miflag[]
	CH_PGP=OpenFile(-9965,IntCo) \ if ch_pgp=-1 error 42 ! prodgrp
	ch_sot=findchannel()
	F$="3/SORDTYPE"+Str$(IntCo) \ ROpen #ch_sot,F$
	!GOTO MIDONE ! NOT ON QUOTES?
	!if source<>201 and source<>208 goto MIDone ! Only orders
	! first the sordtype check
	LET X3=rot.HoldCode ! unpack hold flags
	FOR CTR=1 TO 12                          
		LET FLags[CTR]=SGN(FRA(X3/2));X3=INT(X3/2)
	NEXT CTR 
	! if flags[1] goto MIdone ! credit hold - still chk for any mill items anyway
	! 2,4,5,7,8,9,15,16,20,21,22 = ORDER TYPES TO EXCLUDE
	!IF H5[7]=2 OR H5[7]=4 OR H5[7]=5 OR H5[7]=7 GOTO MIDone
	!IF H5[7]=8 OR H5[7]=9 OR H5[7]=15 OR H5[7]=16 OR H5[7]=20 GOTO MIDone
	!IF H5[7]=21 OR H5[7]=22 GOTO MIDone
	! now in sordtype file
	Key1$=" ",Key1$
	Key1$=roh.OrdType using "##"
	search #ch_sot,2,1;Key1$,R[2],E
	if e goto MIdone ! not there - not allowed!
	read #ch_sot,r[2],48;APMI;
	IF APMI<>1 GOTO MIdone ! NOT A Y - no po for this ordtype
	LET K5$=" ",K5$
	K5$[1,6]=roh.ordnum USING "######"
	CHK_ROLLOOP: ! 
	SEARCH #CH_ROL,3,1;K5$,R[5],e 
	IF E GOTO MIdone
	X2=K5$[1,6] \ IF X2<>roh.ordnum GOTO MIdone
	MAT READ #CH_ROL,R[5],8;ORDL3;
	IF ORDL3[0]=1 GOTO CHK_ROLLOOP ! NO PRDGRP ON NON-STOCKS!!
	if ordl3[1]=1 goto chk_rolloop ! updates stock - that is not mill
	mat read #ch_rol,r[5],16;ordl4; ! rec/po/whse
	if ordl4[3]<1 or ordl4[3]>99 or fra(ordl4[3]) let ordl4[3]=roh.Wh ! whse check
	mat read #ch_rol,r[5],140;l0$; ! prodcode
	mat read #ch_rol,r[5],168;ordl7; ! quantity
	if ordl7[2]<=0 goto chk_rolloop ! no order qty - ignore
	let k2$=" ",k2$
	k2$[1,12]=l0$[1,12] ! prodwhse for prodgroup
	k2$[13]=ordl4[3] using "##"
	search #ch_prwh,2,1;k2$,r[3],e
	if e goto chk_rolloop ! not found = no prodgrp!
	mat read #ch_prwh,r[3],32;prw1;
	mat read #ch_prwh,r[3],38;prw2;
	mat read #ch_prwh,r[3],846;WHMISC2;
	pgmlit=0
	if whmisc2[0]>0 and whmisc2[0]<1000 ! if no prodgrp - it's not a millitem
		K3$=" ",k3$
		k3$=whmisc2[0] using "###" ! 3
		search #ch_pgp,2,1;k3$,r[4],e
		if not(e)
			mat read #ch_pgp,r[4],122;pg1;
			read #ch_pgp,r[4],136;pgmlit;
			if pg1[1]=1 let pgmlit=0 ! quotes never updt stk - so check pgrp flag
		endif
	endif
	if pgmlit<>1 goto chk_rolloop ! not a mill item!
	miflag[0]=miflag[0]+1 ! number of mill items
	if ordl4[2]<>0 let miflag[1]=miflag[1]+1 ! already on po 
	miflag$="Y" ! there are mill items
	goto chk_rolloop
	MIdone:! done
	try close #ch_pgp else rem
	try close #ch_sot else rem
	if miflag$="Y" and flags[1] let miflag$="H" ! on hold with mill items
	if miflag$="Y" Let miflag$="D" ! and miflag[0]>0 and miflag[0]=miflag[1] let miflag$="D" ! just display po's
  else
    include "src/callsuberr.inc"
  end try
end Function miflag$ ! getmillitmflag$
!--------------------------------------------------------------------------------
Sub showmillitems(miflag$)
! section in getordtot to show mill items on po already
  try
	Dim k2$[60],k3$[60]
	Dim 1%,PGMLit,PG1[3]
	dim 3%,WHMisc2[7],R[99]
	clear list$[]
	list$[0]=bsdel$,"MILLITEMS",fdel$
	list$[1]="LINENO",fdel$,"PRODID",fdel$,"DESC",fdel$,"PONUM",fdel$
	let row=2;tmpcnt=maxcnt
	CH_PGP=OpenFile(-9965,IntCo) \ if ch_pgp=-1 error 42 ! prodgrp
	if miflag$="N" or miflag$="" goto smidone ! no mill items!
	let keyrol$=" ",keyrol$;keyrol$=roh.ordnum using "######"
	SMILoop: ! loop it
	search #ch_rol,3,1;keyrol$,rec_rol,e
	if e goto smidone
	x2=keyrol$[1,6] \ if x2<>roh.ordnum goto smidone
	read record #CH_ROl,rec_rol,0;rol.;
	if rol.NStkItem goto SMILoop ! no nonstocks
	if rol.UpdtStk goto SMILoop ! if update stk - not mill item
	if rol.QtyOrd<=0 goto SMILoop ! no order qty - not mill item
	if rol.Whse<1 or rol.Whse>99 or fra(rol.Whse) let rol.whse=roh.wh
	k2$=" ",k2$
	k2$=rol.ProdCode$+Blank$
	k2$[13]=rol.whse using "##"
	search #ch_prwh,2,1;k2$,rec_prwh,E
	if e goto SMILoop ! no prodwhse rec - no prodgroup - not mill item
	mat read #ch_prwh,rec_prwh,846;WHMISC2;
	pgmlit=0
	if whmisc2[0]>0 and whmisc2[0]<1000 ! if no prodgrp - it's not a millitem
		K3$=" ",k3$
		k3$=whmisc2[0] using "###" ! 3
		search #ch_pgp,2,1;k3$,r[4],e
		if not(e)
			mat read #ch_pgp,r[4],122;pg1;
			read #ch_pgp,r[4],136;pgmlit;
			if pg1[1]=1 let pgmlit=0 ! quote never updt stock - check pgrp flag
		endif
	endif
	if pgmlit<>1 goto SMIloop ! not a mill item!
	! it's a mill item - send data
	webstr$=Str$(rol.LineNum),fdel$
	webstr$=webstr$,RTrim$(rol.ProdCode$),fdel$
	webstr$=webstr$,RTrim$(rol.Desc1$)," ",RTrim$(rol.Desc2$),fdel$
	if rol.PONum
		webstr$=webstr$,Str$(rol.PONum),fdel$
	Else
		webstr$=webstr$,"None yet",fdel$
	endif
	list$[row]=webstr$
	row=row+1 \ If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
	goto SMILoop ! next line
	SMIDone: ! finished
	list$[row]=esdel$
	try close #ch_pgp else rem
  else
    include "src/callsuberr.inc"
  end try
end Sub ! showmillitems

!--------------------------------------------------------------------------------
Sub currconvup(amount,factor)
! 
  try
	If p61$[136,136]="Y"and factor<>0 and amount<>0! going for base to costing um
		let cnvcu[0]=1
		let cnvca[0]=amount
		let cnvca[1]=factor
		call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
		let amount=cnvca[0]
	endif
  else
    include "src/callsuberr.inc"
  end try
end Sub ! 

!--------------------------------------------------------------------------------
Sub currconvdown(amount,factor)
! 
  try
	if p61$[136,136]="Y" and factor<>0 and amount<>0! going from currency to base
		let cnvcu[0]=2
		let cnvca[0]=amount
		let cnvca[1]=factor
		call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
		let amount=cnvca[0]
	endif
  else
    include "src/callsuberr.inc"
  end try
end Sub ! 
!---------------------------------------------------------------------------