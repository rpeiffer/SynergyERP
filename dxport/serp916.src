! serp916.dl4 - Order Audit log view
! 1.0 02/11/2010 - initial conversion
!
! loadsave -w -n 100,10 -o prog/dxport/serp916.dl4 src/serp916.src
!
Rem edittrack.s  Inquiry/purge for edit tracking file
Rem rev:   04/29/96 -kmm- created.
Rem      09/26/96 -kmm- add fields: invoice, origtot, cust
!           09/29/97 -vst cct106925 changed dimension of "OPT" from 1% to 3%
!           11/04/97 -ac cct107830 fix page break
!           08/14/98 -jliu cct115282 check the entry in sort_quest subroutine
!           02/01/02 -zyc cct139606 display status changes in 229 when "RESET"
!           10/11/02 -zyc cct161532 problem with etaction = 3
!           08/29/03 -zyc cct170971 add etaction = 9  "ORDER DELETED"
!                                   add etaction = 10 "INVOICE DELETED"
! 8/10/05 - jliu cct192662 tracking when a line item was added, order was
!           on hold, hold code was remove and the header access
! 8/20/05 - vst cct193752 - in code under label "LINE 3" changed the PRINT stmts
!           to PRINT #0 were just PRINT
! 08/22/05 -swu cct193976 salespro, add directory 4 for 2/edittrack#,
!          add etaction = 15
! 7/27/07 - jliu cct216729 add the starting and ending status code
! 10/23/07 - jliu cct219560 - add new selection - select the action 
! 01/22/09 - vst cct231234 - fix blank out of screen if user accesses the
! 						     window lookup for field #7 ACTION: 
!						   - also prints "Printing..." - for all outputs
! Feb 2010 - SERP - Per committee is A PRINT - NO SCREEN(xml) OPTION!
! will definitely get timeout if run to screen(xml) and a large file!!
!
! Apr 2012 - add custom change for Acme (on hand,location)
! ---------------   NOTES FOR UPGRADE TO REV10 FOR WALTER E NELSON --------------
!                        -  'etaction=22' "PICKING TICKET PRINTED"
! ------------------------------------------------------------------------------
!
Rem BEDIT Version: 2.2 OBJECT CODE     Created: APR  7, 2009  13:28:33
Rem /w2/papermaster/r2005//usr/acct/bill/work/r2005/misc/edittrack.src (univ2) [bill] {42534}
Rem  Copyright (c) 2009 Universal Business Systems, Inc.
Rem    **** ALL CHANGES MUST BE MADE IN SOURCE!!! ****
Rem
include "src/copyright.inc"
External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus
Declare External Function getmsg$,expandarray
Declare External Function AddToMYReports
Declare External Function openprinter

External Lib "dxblockcustom.lib"
Declare External Sub blockPrintersDropList
External Lib "ubsfunc.dl4"
Declare External Sub getportdefault,GetCostLevels
Declare External Function OpenFile,PDate$,FormatDate2$,getuidinfo$,JDate$
Declare External Function GetUIDRec,ChkAltItem$,chkDteFrmt$
Declare Intrinsic Sub Date,DateToJulian,InpBuf,JulianToDate,String
Declare Intrinsic Sub programdump
! Option Default Dialect IRIS1
If Err 0 Gosub ERR_TRAP
DIM KEYCN$[6],CN1$[10],3%,REC_CNOTE,CNAME$[31]
dim 1%,PFU1[20],CNVTU[2],COST_LEV[3]
Dim 3%,PFU2[6],CNVTA,A[33]
Dim 1%,CH_ET,CH_CNTRL,CH_CCODES,CH_PROD,CH_CUST,CH_CNTRLLPT
Dim 1%,TOSCREEN,CHNL,CHNLFREE,PURGE,MAXLN,WANNAQUIT
Dim 1%,TARGETLINE,OT9[11],NT9[11],PL1[1],H4[2]
Dim 2%,SDATE,EDATE,STIME,ETIME,ORDER,H0[12]
Dim 3%,SCR,REC_ET,REC_PROD,REC_CUST,ETOQTY1[2],ETNQTY1[2],OPT
Dim 3%,ETUNITPRICE1[1],ETLOADCOST1[1],R[30],PAGE
Dim MASK$[14],P2$[20],F$[16],TMPET$[50],custom_customer$[30]
Dim SCRATCH$[90],ET$[50],ACCESS$[10],SORT$[1],UM$[4],Y$[80]
Dim HOLD$[90],PUNIT$[4],CUNIT$[4],K7$[50],K9$[50]
Dim PLOC$[18],K12$[30],K2$[80]
Rem {begin dim.rtn.input}
Dim J$[70],J0$[18],J1$[70],J2$[20],J3$[40],J4$[60],J5$[80],J7$[80],J9$[70]
Dim X$[100],1%,J0,J2,J3,J4,J5,J7[2],J8,X1[9]
Dim 2%,J9[9],X2[9],4%,J1
Rem {end dim.rtn.input}
Rem {begin src/inc/dim.edittrack.i}
Dim 1%,ETLINE,ETSTAT,ETUNIT,ETNONSTOCK,ETPRINT,ETPUNIT[2]
Dim 2%,ETORDER,ETDATE,ETTIME,ETPORT,ETACTION,ETCUST,ETSLS
Dim 3%,ETINVOICE,ETOQTY[2],ETNQTY[2],ETORIGTOT,ETUNITPRICE[1]
Dim 3%,ETLOADCOST[1],ETWGT[1]
Dim ETPROD$[12],ETUSER$[10]
Rem {end dim.edittrack.i}
Rem {begin src/inc/dim.prod.i}
Dim A$[156],HZ$[90],PR_A2$[30],C1$[32],PSN$[20],U3$[60]
Dim PRFLG$[10],PRMKUPTYP$[4],PIC$[50],PRIML$[12]
Dim 1%,LLC,PFTB[3],PFU1[20],LM[1],UPCT,PR_PO[1]
Dim 1%,PRBASE,PRPARC2[3],PRD1[4],AGEDAY
Dim 2%,A2,A3[2],B[24],PR_C4[10],PFCO[3],PLC[3],PSN[1],U2,U4[1]
Dim 2%,STK[2],FDT[1],PRMKUP[3],PRD0[2]
Dim 3%,A1[7],A[33],PF_LOAD2,PFU2[6],PLV[1],PRPARC[3],U3,PFN[1]
Dim 3%,LBSORD,FUT[1],PRREDI[1],PRD2[3]
Rem {end dim.prod.i}
Rem {begin src/inc/dim.cust.i}
Dim A3$[22],BT$[20],U2$[60],A2$[30],A1$[142]
Dim 2%,A0[3],C1[12],REC,C3[1]
Dim 1%,S0[20],SUB_,SZN,C7[4],C0,C2[2],C8,C11[2]
Dim 3%,C4[6],C10[5],CFIN[8],U1,C9,C5[5],C6[9],C12[1],bad_rec
Dim e$[500],buttonlist$[5,50],nextlist$[5,100] ! dx error handling variables
dim tmp$[800],tmp1$[800],tmp2$[800],Message$[600],msg$[100],rstr$[2000],webstr$[2000]
dim action$[30],options$[30],userid$[8],3%,fdel$[10],bsdel$[10],esdel$[10],rdel$[10]
Dim ReportDir$[128],BaseName1$[128],Statusfile$[128],action1$[30],action2$[30]
Dim 2%,maxcnt,3% 
maxcnt=50 ! init max records in arrays for list
dim List$[maxcnt,1200] ! for .net (larger size - ZLines)
Dim Blank$[100]
Blank$=" ",Blank$
! call dxopen() ! for standalone run (not from oemenu)
Call getsession(e$,CTLC,options$,action$,userid$,intCO,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$,Action1$,Action2$)
action$=UCase$(action$) ! used in oemenu!
 action$=RTrim$(Action$) ! "trim spaces from end
 action1$=UCase$(action1$)
 action1$=RTrim$(Action1$) ! "trim spaces from end
 action2$=UCase$(action2$)
 action2$=RTrim$(Action2$) ! "trim spaces from end
 Call GetCostLevels(e$,cost_lev[],IntCo,Userid$)
URec=GetUIDRec(e$,IntCo,Userid$)
Rem {end dim.cust.i}
! Call dxsave(0,"tmp/916in.txt!")
CH_CNTRL = 1
CH_ET = 2
CH_PROD = 3
CH_CCODES = 4
CH_CUST = 5
ch_CNOTE=55
CH_CNTRLLPT = 6
CH_ROH = 7
CH_SORT = 9
LET CH_INVH=10
LET CH_SPWH=11
LET CH_PRODLOC=12
SSTATUS = 0
ESTATUS = 99
BLANK$ = " ",BLANK$
MASK$ = "#",MASK$
SCR = Len(MASK$) - 2
MASK$[SCR,SCR] = "."
! Gosub OPEN_FILES
OPEN_FILES: Rem
SCRATCH$ = Str$(IntCo) ! Str$(Int((Spc(5) - Int(Spc(5) / 16384) * 16384) / 64))
CHNL = CH_CNTRL
Gosub CHNLFREE
If CHNLFREE Open #CH_CNTRL,"cntrl/cntrl" + SCRATCH$

Open #CH_ET,"2/edittrack" + SCRATCH$
Ropen #CH_PROD,"2/sprod" + SCRATCH$
Ropen #CH_CCODES,"2/ccodes"
Ropen #CH_CUST,"2/scustomer" + SCRATCH$
Ropen #CH_CNTRLLPT,"cntrl/cntrl.lpt"
Ropen #CH_ROH,"3/SORDFLEH" + SCRATCH$
ROPEN #CH_INVH,"4/sordflehh"+SCRATCH$
ROPEN #CH_SPWH,"2/sprodwhse"+SCRATCH$
ROPEN #CH_PRODLOC,"2/prodloc"+SCRATCH$
rOPEN #CH_CNOTE,"2/CUSTNOTES"+SCRATCH$
Mat read #ch_cntrl,115,60;Custom_Customer$;
Custom_Customer$=UCase$(Trim$(custom_customer$))
! Custom_Customer$="ACME" ! test
  MAXLN = 62 ! toscreen no maxln
If Err 0 Gosub ERR_TRAP
returnstatus=0
message$="Action 1 not found"
Select Case Action1$
	case "LISTS" ! wants droplists
		returnstatus=1
		message$="OK"
		Clear List$[]
		List$[0]=bsdel$,"ACTIONTYPE",fdel$ ! only 16 allowed?
		List$[1]="ATYPEID",fdel$,"DESC",fdel$
		List$[2]="0",fdel$,"ALL",fdel$
	  List$[3]="1",fdel$,"1 = LINE WAS EDITED",fdel$
	  List$[4]="2",fdel$,"2 = LINE WAS DELETED",fdel$
	  List$[5]="3",fdel$,"3 = ORDER WAS DELETED",fdel$
	  List$[6]="4",fdel$,"4 = LINE DELETED (from 229 - bad data)",fdel$
	  List$[7]="5",fdel$,"5 = ORDER ENTERED ",fdel$
	  List$[8]="6",fdel$,"6 = ORDER PRINTED ",fdel$
	  List$[9]="7",fdel$,"7 = ORDER SCANNED ",fdel$
	  List$[10]="8",fdel$,"8 = INVOICE PRINTED ",fdel$
	  List$[11]="9",fdel$,"9 = ORDER DELETED FROM 225 ",fdel$
	  List$[12]="10",fdel$,"10= INVOICE DELETED FROM 225",fdel$
	  List$[13]="11",fdel$,"11= LINE WAS ADDED",fdel$
	  List$[14]="12",fdel$,"12= HOLD CODE WAS EDITED",fdel$
	  List$[15]="13",fdel$,"13= HOLD CODE WAS EDITED BY SYSTEM",fdel$
	  List$[16]="14",fdel$,"14= THE ORDER HEADER ACCESS",fdel$
	  List$[17]="15",fdel$,"15= PRICE CHANGE FROM SALESPRO",fdel$
	  List$[18]="16",fdel$,"16= PRICE OR COST CHANGE FROM MX066",fdel$
	  List$[19]="22",fdel$,"22= TICKET PRINTED",fdel$
	  List$[20]="23",fdel$,"23= PRICE CHANGE IN LINE EDIT",FDEL$
	  LIST$[21]="24",FDEL$,"24= COST CHANGE IN LINE EDIT",FDEL$
	  list$[22]="26",fdel$,"26= CREDIT MEMO DELETED",FDEL$
	  LIST$[23]="65",fdel$,"65= CREDIT CARD",FDEL$
	  List$[24]=esdel$
	  call addtostr(e$,rstr$,list$[])
	  clear list$[]
	  List$[0]=bsdel$,"SORTOPT",fdel$
	  List$[1]="SORTID",fdel$,"DESC",fdel$
	  List$[2]="O",fdel$,"O= Order ID",fdel$
	  List$[3]="A",fdel$,"A= Access ID",fdel$
	  List$[4]="D",fdel$,"D= Date",fdel$
	  List$[5]=esdel$
	  call addtostr(e$,rstr$,list$[])
	  ! access code - Not
	  ! print section
		clear list$[]
		list$[0]=bsdel$,"Printers",fdel$
		List$[1]="Name",fdel$,"Id",fdel$,"Default",fdel$
		call AddToStr(e$,rstr$,List$[])
		pdfoption=1
		xmloption=0 ! BROWSER NOT OK  (MULTIPLE PRINT FORMATS for diff status!)
		Call blockPrintersDropList(rstr$,xmloption,pdfoption)
		Call AddToStr(e$,rstr$,esdel$) ! end of section 
		
		goto Done
	Case "PURGE"
		returnstatus=1
		message$="OK"
		PURGE = 1
	Case "PRINT"
		returnstatus=1
		message$="OK"
		PURGE = 0
End select
if returnstatus=0 goto Done
! Print or purge fall on thru
MAIN: Rem
!Gosub DISP_BACKGROUND
DISP_BACKGROUND: Rem

DISPLAY_TOSCREEN: Rem "if running report to the screen
e$=""
ASK_QUEST: Rem

ACCESS_QUEST: Rem

CALL DXGET("ACCESS",TMP$)
J$=UCase$(RTRIM$(tmp$))+Blank$
If J$ = "A"
  ACCESS$ = blank$ ! "" ?? a=null??
Else 
  ACCESS$ = J$
End If 

ORDER_QUEST: Rem

call dxget("ORDERID",tmp$)
j1=tmp$
ORDER = J1
if order<0 or order>999999 or fra(order)
	eflag=eflag+1
	e$=e$+" Invalid Order Number "
Endif
SORT_QUEST: Rem

CALL DXGET("SORTID",TMP$)
if tmp$="" let tmp$="O"
J$=UCase$(RTRIM$(tmp$))
SORT$ = J$
Call String(1,SORT$)
If SORT$ <> "O" And SORT$ <> "A" And SORT$ <> "D" !Goto SORT_QUEST
	eflag=eflag+1
	e$=E$+" Invalid Sort Option "
Endif ! Return 
DATE_QUEST: Rem
SDATE_QUEST: Rem

call dxget("SDATE",tmp$)
tmp$=RTrim$(tmp$)
if tmp$="0" let tmp$=""
If tmp$ = ""
  SDATE = 0
  !Print @50,1;"FIRST    ";
Else 
  tmp$=chkDteFrmt$(e$,tmp$)
  if tmp$[1,1]<"0" and tmp$[1,1]>"9" let tmp$=""
  if tmp$<>""
	tmp1$=formatdate2$(tmp$) ! mm/dd/yyyy to yyyymmdd
	J4$=tmp1$[3,8]
  Else
	let j4$=""
  Endif

  Scratch$=J4$
  Call DateToJulian(1,SCRATCH$,X$,E)
  If E ! Print 'RB'; \ Goto SDATE_QUEST
	eflag=eflag+1
	e$=e$+" Invalid start date "
  Endif
  SDATE = X$
  Call JulianToDate(1,X$,SCRATCH$,E)
  ! Print @50,1;SCRATCH$;
End If 
EDATE_QUEST: Rem

call dxget("EDATE",tmp$)
tmp$=rtrim$(tmp$)
if tmp$="0" let tmp$=""
If tmp$ = ""
  EDATE = 0
  !Print @64,1;"LAST      ";
Else 
  tmp$=chkDteFrmt$(e$,tmp$)
  if tmp$[1,1]<"0" and tmp$[1,1]>"9" let tmp$=""
  if tmp$<>""
	tmp1$=formatdate2$(tmp$) ! mm/dd/yyyy to yyyymmdd
	J4$=tmp1$[3,8]
  Else
	let j4$=""
  Endif
  !Call Date(J$,SCRATCH$,6,E)
  !If E Print 'RB'; \ Goto EDATE_QUEST
  Scratch$=J4$
  Call DateToJulian(1,SCRATCH$,X$,E)
  If E ! Print 'RB'; \ Goto EDATE_QUEST
	eflag=eflag+1
	e$=e$+" Invalid End date "
  Endif
  EDATE = X$
  Call JulianToDate(1,X$,SCRATCH$,E)
  ! Print @64,1;SCRATCH$;
End If 
If EDATE And EDATE < SDATE ! Print 'RB'; \ Goto DATE_QUEST
	eflag=eflag+1
	e$=E$+" Invalid Date Range "
Endif ! Return 
TIME_QUEST: Rem
STIME_QUEST: Rem

call dxget("STIME",tmp$)
if tmp$="" let tmp$=Str$(STIME)
for j1=1 to len(tmp$)
	if tmp$[j1,j1]<"0" or tmp$[j1,j1]>"9" then tmp$[j1,j1]="0"
next j1
J1=tmp$
HH = Int(J1 / 10000)
MM = Int(J1 / 100) - HH * 100
SS = J1 - (HH * 10000) - MM * 100
If HH > 24 Or MM > 60 Or SS > 60 !Print 'RB'; \ STIME = 0 \ Goto STIME_QUEST
	eflag=eflag+1
	e$=e$+" Invalid Start time "
Endif
STIME = J1
! Print Using "&&:&&:&&";@50,2;HH;MM;SS;
ETIME_QUEST: Rem

call dxget("ETIME",tmp$)
if tmp$="" let tmp$=STR$(ETIME)
for j1=1 to len(tmp$)
	if tmp$[j1,j1]<"0" or tmp$[j1,j1]>"9" then tmp$[j1,j1]="0"
next j1
J1=TMP$
HH = Int(J1 / 10000)
MM = Int(J1 / 100) - HH * 100
SS = J1 - (HH * 10000) - MM * 100
If HH > 24 Or MM > 60 Or SS > 60 ! Print 'RB'; \ ETIME = 0 \ Goto ETIME_QUEST
	eflag=eflag+1
	e$=e$+" Invalid End time "
Endif
ETIME = J1
! Print Using "&&:&&:&&";@64,2;HH;MM;SS;
If ETIME < STIME ! Print 'RB'; \ Goto TIME_QUEST
	eflag=eflag+1
	e$=e$+" Invalid time range "
Endif ! Return 
STATUS_QUEST: Rem cct#216729

call dxget("SSTATUS",tmp$)
if tmp$="" or tmp$="0" let tmp$=Str$(SSTATUS)
SSTATUS=tmp$
If SSTATUS<0 or SSTATUS > 99
  
  eflag=eflag+1
  e$=e$+" Invalid start status "
End If 
ESTATUS_QUEST: Rem"ending order status

call dxget("ESTATUS",tmp$)
if tmp$="" or tmp$="0" let tmp$=Str$(EStatus)
ESTATUS=tmp$
If ESTATUS<0 or ESTATUS > 99
  
  eflag=eflag+1
  e$=e$+" Invalid end status "
End If 
If ESTATUS < SSTATUS
  
  eflag=eflag+1
  e$=e$+" Invalid status range"
End If 
If SSTATUS = 0 And ESTATUS = 99 Let RANGEFLAG = 0 Else Let RANGEFLAG = 1
If SSTATUS = 30 Or SSTATUS = 31 Let RANGEFLAG = 0
! Return 
ACTION_QUEST: Rem cct#219560
call dxget("ATYPEID",tmp$)
J1=tmp$
If J1 = 0
  EDITFLAG = 0
  ! Print @16,4;"ALL";
End If 
!If J1 > 24 Goto ACTION_QUEST ! so no 17+ allowed? (20-21, 217, 374? only on all?)
If J1
  !Print Using "###";@16,4;J1
  EDITFLAG = 1
  EDITTYPE = J1
End If 
!Return 
PURGE_QUEST: Rem Overrides print/toscreen & PURGE ONLY

if eflag ! something bad
	goto err_Msg
Endif
printchan=0
If not(purge) ! purge doesn't need printer!
	! open printer
	call dxget("Printer",tmp$) ! let's see if 1 selected (-- = NONE)
	tmp$=rtrim$(tmp$)
	IF not(Purge) ! if no print - ignore
		if tmp$[1,2]="--"
			Returnstatus=0
			Message$="NO PRINTER SELECTED"
			goto Done
		Endif
		onchannelno=0 ! zero for channel 
		printchan = openprinter(e$,onchannelno) 
	Endif
Endif
	Toscreen=0
	if printchan=-1 let Toscreen=1 ! to browser
SETUP4MAINLOOP: Rem
If TOSCREEN ! cannot happen - timeout issue!! - 1 order lookup took over 2 minutes!
	! note: if allowing toscreen - rem next few lines
	Returnstatus=0
	message$="Can not print to screen"
	goto Done
	! this starts the toscreen header load
	Clear List$[]
	tmpcnt=maxcnt
	List$[0]=bsdel$,"AUDITDATA",FDEL$
	! load header - 1 field per print field
	! several multi-use fields - ETPROD$, OrigOrd, NewOrd, ETACTION
	! PER ERaffo - just send all fields in file - let web figure it out!
	webstr$="" ! if you can figure a better way - go for it
	webstr$="ORDID",FDEL$,"LINENUM",FDEL$,"STATUS",FDEL$
	webstr$=webstr$,"PRODID",fdel$,"ORIGORDQTY",fdel$,"ORIGSHIPQTY",fdel$
	webstr$=webstr$,"ORIGBOQTY",FDEL$,"NEWORDQTY",FDEL$,"NEWSHIPQTY",FDEL$
	webstr$=webstr$,"NEWBOQTY",FDEL$,"SELLUM",FDEL$
	WEBSTR$=WEBSTR$,"EDITDATE",FDEL$,"EDITTIME",FDEL$
	WEBSTR$=WEBSTR$,"PORTNUM",FDEL$,"ACCODE",FDEL$
	WEBSTR$=WEBSTR$,"ACTIONID",FDEL$,"OLDSTAT",FDEL$,"NSTKFLAG",FDEL$
	WEBSTR$=WEBSTR$,"ORIGORDTOT",FDEL$,"CUSTID",FDEL$,"CUSTNAME",fdel$
	WEBSTR$=WEBSTR$,"PRINTERID",FDEL$,"PRNTNAME",fdel$,"INVNUM",FDEL$
	WEBSTR$=WEBSTR$,"SLSMID",FDEL$,"ORIGPRICE",FDEL$
	WEBSTR$=WEBSTR$,"NEWPRICE",FDEL$,"PRCUM",FDEL$
	WEBSTR$=WEBSTR$,"ORIGCOST",FDEL$,"NEWCOST",FDEL$,"COSTUM",FDEL$
	WEBSTR$=WEBSTR$,"LBSUNIT",FDEL$,"LBSFACT",FDEL$,"ACTIONDESC",fdel$
	List$[1]=webstr$
	row=2
Else ! STILL PRINTER STUFF!
  if not(purge)
  Call setoutput(e$,rstr$,2) !2 flag puts 0 status section in w/print in process msg, puts </page> in
  try call dxclose() else rem
  Gosub HEADER
!  Print @0,23;'CL';"Printing...";
  Else ! purge in process - not print
	message$="Purging range entered. Please check later"
	returnstatus=1
	Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)     
	Call AddToStr(e$,rstr$,WebStr$)                            
	Call SetOutPut(e$,rstr$)
	try call dxclose() else rem
   Endif
End If 
ET$ = " ",ET$
If SORT$ = "O"
  DIR = 1
  ET$ = ORDER Using "######"
End If 
If SORT$ = "A"
  DIR = 2
  ET$ = ACCESS$
  ET$[11,16] = ORDER Using "######"
End If 
If SORT$ = "D"
  DIR = 3
  ET$ = SDATE Using "########"
  ET$[9] = STIME Using "######"
End If 
! Return 
RANGE_LOOP: Rem  
SORTKEY = 0
Gosub CLEAR_SORT  ! just in case needed
If RANGEFLAG And Not(ORDER)
  Gosub DO_SORT
End If 
If RANGEFLAG And Not(SORTKEY) And Not(ORDER) Goto END_MAIN_LOOP ! NADA FOUND/SORTED
If RANGEFLAG And SORTKEY
  CH = 9
  ET$ = " ",ET
  DIR = 1
Else 
  CH = 2
End If 
COUNT = 0
MAIN_LOOP: Rem
Search #CH,3,DIR;ET$,REC_ET,E \ If E > 2 Gosub ERR_SEARCH
If E GOTO END_MAIN_LOOP ! Not(E)
  Rem {begin src/inc/read.edittrack.i}
  Mat Read #CH_ET,REC_ET,0;ETORDER
  Mat Read #CH_ET,REC_ET,4;ETLINE
  Mat Read #CH_ET,REC_ET,6;ETSTAT
  Mat Read #CH_ET,REC_ET,8;ETPROD$
  Mat Read #CH_ET,REC_ET,20;ETOQTY
  Mat Read #CH_ET,REC_ET,38;ETNQTY
  Mat Read #CH_ET,REC_ET,56;ETDATE
  Mat Read #CH_ET,REC_ET,60;ETTIME
  Mat Read #CH_ET,REC_ET,64;ETPORT
  Mat Read #CH_ET,REC_ET,68;ETUSER$
  Mat Read #CH_ET,REC_ET,78;ETACTION
  Mat Read #CH_ET,REC_ET,82;ETUNIT
  Mat Read #CH_ET,REC_ET,84;ETNONSTOCK
  Mat Read #CH_ET,REC_ET,90;ETORIGTOT
  Mat Read #CH_ET,REC_ET,96;ETCUST
  Mat Read #CH_ET,REC_ET,100;ETPRINT
  Mat Read #CH_ET,REC_ET,102;ETINVOICE
  Mat Read #CH_ET,REC_ET,108;ETSLS
  Mat Read #CH_ET,REC_ET,112;ETUNITPRICE
  Mat Read #CH_ET,REC_ET,124;ETPUNIT
  Mat Read #CH_ET,REC_ET,128;ETLOADCOST
  Mat Read #CH_ET,REC_ET,140;ETWGT;
  Rem {end read.edittrack.i}
  Mat Read #CH_ET,REC_ET,108;ETSLS;
  Mat Read #CH_ET,REC_ET,112;ETUNITPRICE;
  Mat Read #CH_ET,REC_ET,124;ETPUNIT;
  Unlock #CH_ET
  COUNT = COUNT + 1
  if len(etuser$)<10 let etuser$=etuser$+blank$ ! MUST BE 10!!
  !If Not(Fra(COUNT / 10000))
    !Print @0,23;"PROCESSING, PLEASE WAIT .. . ";COUNT;"Records Processed.";'CE'; \ Signal 3,0
    !If TOSCREEN Print @0,LN;'CL';
  !End If 
  If EDITFLAG If ETACTION <> EDITTYPE Goto MAIN_LOOP
  If ORDER
    If ETORDER < ORDER Goto MAIN_LOOP
    If ETORDER > ORDER
      If SORT$ = "O" Goto END_MAIN_LOOP
      If SORT$ = "A"
        ET$[11,16] = "999999"
        Goto MAIN_LOOP
      End If 
      If SORT$ = "D"
        ET$[15,21] = "999999"
        Goto MAIN_LOOP
      End If 
    End If 
  End If 
  If Not(RANGEFLAG) If ACCESS$ <> "" And ACCESS$ <> "          "
    If ETUSER$ < ACCESS$ Goto MAIN_LOOP
    If ETUSER$ > ACCESS$ If SORT$ = "A" Goto END_MAIN_LOOP
    If ETUSER$ > ACCESS$ If SORT$ = "O" Goto MAIN_LOOP
    If ETUSER$ > ACCESS$ If SORT$ = "D" Goto MAIN_LOOP
  End If 
  If Not(RANGEFLAG) If SDATE Or EDATE
    If SDATE And ETDATE < SDATE Goto MAIN_LOOP
    If EDATE And ETDATE > EDATE
      If SORT$ = "O"
        ET$[13,20] = "99999999"
        Goto MAIN_LOOP
      End If 
      If SORT$ = "A"
        ET$[23,30] = "99999999"
        Goto MAIN_LOOP
      End If 
      If SORT$ = "D" Goto END_MAIN_LOOP
    End If 
  End If 
  If Not(RANGEFLAG) If STIME Or ETIME
    If ETTIME < STIME Goto MAIN_LOOP
    If ETTIME > ETIME
      If SORT$ = "O"
        ET$[21,26] = "999999"
        Goto MAIN_LOOP
      End If 
      If SORT$ = "A"
        ET$[31,36] = "999999"
        Goto MAIN_LOOP
      End If 
      If SORT$ = "D"
        ET$[9,14] = "999999"
        Goto MAIN_LOOP
      End If 
    End If 
  End If 
  if PURGE ! split into purge or print - SERP per committee
	Gosub DO_PURGE
  Else ! printing
	  Gosub GET_CUST
	  If ETPROD$[1,10] <> "STATUS CHG" And ETPROD$[1,7] <> "DELETED" and ETACTION<>65
	    if custom_customer$="ACME"
			GOSUB GET_WHSE:
			LET K12$=" ",K12$ \ LET K12$[1,12]=ETPROD$[1,12]
			GOSUB GET_LOCATION:
		Endif
		Gosub GET_PROD                                     
		Gosub GET_UM
		Gosub DO_CONVERSIONS
	  End If 
	Gosub PRINT_LINE
  Endif! If PURGE Gosub DO_PURGE
  !If Not(WANNAQUIT) Goto MAIN_LOOP
Goto MAIN_LOOP ! End If !of not(e) removed
END_MAIN_LOOP: Rem
if not(Purge)
  If toscreen
	List$[row]=esdel$ ! add end of section
	call addtostr(e$,rstr$,list$[])
  Endif
Endif

Goto DONE

DO_PURGE: Rem
X$ = " ",X$
X$ = ETORDER Using "######"
X$[7] = ETLINE Using "######"
X$[13] = ETDATE Using "########"
X$[21] = ETTIME Using "######"
if ch=2 and dir=1 let x$=ET$
Search #CH_ET,5,1;X$,REC,E \ If E>1 Gosub ERR_SEARCH
if e=1 
	gosub save_bad_key
	goto exit_purge
endif
SCRATCH$ = " ",SCRATCH$
SCRATCH$[1,10] = ETUSER$ + BLANK$
SCRATCH$[11,36] = X$
if ch=2 and dir=2 let scratch$=et$
Search #CH_ET,5,2;SCRATCH$,REC,E \ If E>1 Gosub ERR_SEARCH
if e=1 
	gosub save_bad_key
	goto exit_purge
endif
SCRATCH$ = " ",SCRATCH$
SCRATCH$ = X$[13,26] + X$[1,12]
if ch=2 and dir=3 let scratch$=et$
Search #CH_ET,5,3;SCRATCH$,REC,E \ If E>1 Gosub ERR_SEARCH
if e=1 
	gosub save_bad_key
	goto exit_purge
endif
HOLD$ = " ",HOLD$;HOLD$ = SCRATCH$
SCRATCH$ = " ",SCRATCH$
SCRATCH$[1,3] = ETSLS Using "###"
SCRATCH$[4,29] = HOLD$
SCRATCH$[30,30] = " "
if ch=2 and dir=4 let scratch$=ET$ ! may not always be there!!
Search #CH_ET,5,4;SCRATCH$,REC,E \ If E>1 Gosub ERR_SEARCH
if e=1 
	gosub save_bad_key
	goto exit_purge
endif
E = 3
Search #CH_ET,1,0;X$,REC_ET,E \ If E>1 Gosub ERR_SEARCH
exit_purge: Return 

PRINT_LINE: Rem
If PURGE RETURN
If ToScreen
	!load printed fields
	Webstr$="" ! so many options - what fields are sent?
	! Per ERR - Send whole file as is & let web sort it out!
	webstr$=Str$(ETORDER),FDEL$,sTR$(ETLINE),FDEL$,STR$(ETSTAT),FDEL$
	WEBSTR$=WEBSTR$,RTRIM$(ETPROD$),FDEL$,STR$(ETOQTY1[0]),FDEL$
	WEBSTR$=WEBSTR$,STR$(ETOQTY1[1]),FDEL$,sTR$(ETOQTY1[2]),FDEL$
	WEBSTR$=WEBSTR$,STR$(ETNQTY1[0]),FDEL$,STR$(ETNQTY1[1]),FDEL$
	WEBSTR$=WEBSTR$,sTR$(ETNQTY1[2]),FDEL$,UM$,FDEL$
	X$ = ETDATE Using "########"
	Call JulianToDate(1,X$,SCRATCH$,E)
	WEBSTR$=WEBSTR$,SCRATCH$,FDEL$
	HH = Int(ETTIME / 10000)
	MM = Int(ETTIME / 100) - HH * 100
	SS = ETTIME - (HH * 10000) - MM * 100
	TMP$=HH USING "&&",":",MM USING "&&",":",SS Using "&&"
	WEBSTR$=WEBSTR$,TMP$,FDEL$,STR$(ETPORT),FDEL$
	WEBSTR$=WEBSTR$,ETUSER$,FDEL$,Str$(Int(ETACTION)),fdel$
	x2=fra(ETACTION)*100
	webstr$=webstr$,Str$(X2),fdel$
	tmp$="N" \ if ETNONSTOCK let tmp$="Y"
	webstr$=webstr$,tmp$,fdel$
	IF ETACTION=65 LET WEBSTR$=WEBSTR$+"CCAMT:"
	webstr$=webstr$,LTrim$(ETORIGTOT using mask$),fdel$
	webstr$=webstr$,Str$(ETCUST),fdel$,RTrim$(CNAME$),fdel$
	webstr$=webstr$,Str$(ETPRINT),fdel$
	tmp$=""
	If ETPRINT <= 0
		If ETPRINT = 0 tmp$="UNKNOWN"
		If ETPRINT = -5 tmp$="FAXED"
		If ETPRINT = -4 tmp$="PROGRAM SPECIFIED"
		If ETPRINT = -3 tmp$="EMAILED"
		If ETPRINT = -2 tmp$="ARCHIVED"
		If ETPRINT = -1 tmp$="DISK FILE"
	Else 
		Read #CH_CNTRLLPT,ETPRINT,10;P2$
		tmp$=P2$[1,16]
	End If 
	webstr$=webstr$,RTrim$(tmp$),fdel$
	webstr$=webstr$,Str$(ETINVOICE),fdel$,Str$(ETSLS),fdel$
	webstr$=webstr$,LTrim$(ETUNITPRICE1[0] using mask$),fdel$
	webstr$=webstr$,LTrim$(ETUNITPRICE1[1] using mask$),fdel$
	webstr$=webstr$,PUNIT$,fdel$
	if cost_Lev[1] 
		webstr$=webstr$,LTrim$(ETLOADCOST1[0] using mask$),fdel$
		webstr$=webstr$,LTrim$(ETLOADCOST1[1] using mask$),fdel$
	else
		webstr$=webstr$,fdel$,fdel$
	Endif
	webstr$=webstr$,CUNIT$,fdel$
	webstr$=webstr$,LTrim$(ETWGT[0] using mask$),fdel$
	webstr$=webstr$,LTrim$(ETWGT[1] using mask$),fdel$
	! send action desc
	tmp$=""
	If ETACTION = 1 Or ETACTION = 374 or ETACTION=371 or etaction=512 or etaction=234 or etaction=205
	  tmp$="*** ORDER LINE CHANGED ****"
	End If 
	if etaction = 26                                     
		tmp$="*** CREDIT MEMO DELETED ***" 
	endif                                                
	If ETACTION = 2
	  tmp$="*** LINE DELETED ***"
	End If 
	If ETACTION = 3 
	  IF ETPROD$[1,12] = "DEL OR-BAD D"
	    tmp$="***ORDER DELETED FROM 229- BAD DATA ***"
	  ELSE
          IF etprod$[1,12]="DELETED -201" ! 5
		    tmp$="*** ORDER DELETED FROM 201 ***"
          ELSE
            IF etprod$[1,12]="DELETED -231" ! 4
		      tmp$="*** ORDER DELETED FROM 231 ***"
            ELSE
             IF etprod$[1,12]="DELETED -251" ! 3
		       tmp$="*** ORDER DELETED FROM 251 ***"
             ELSE
              IF etprod$[1,12]="DELETED223CS" ! 2
		        tmp$="**ORDER DELETED FROM 223-CASH SCRN**"
              ELSE
               IF etprod$[1,12]="DELETED221CS" ! 1
		         tmp$="**ORDER DELETED FROM 221-CASH SCRN**"
               ELSE
			     tmp$="*** ORDER DELETED FROM 206 ***"
               ENDIF ! 1	
              ENDIF	! 2
             ENDIF	! 3
            ENDIF	! 4
          ENDIF	! 5
	  ENDIF
	End If 
	!If ETACTION = 3 And ETPROD$[1,12] <> "DEL OR-BAD D"
	!  tmp$="*** ORDER DELETED FROM 206 ***"
	!End If 
	If ETACTION = 4
	  tmp$="*** LINE DELETED FROM 229- BAD DATA ***"
	End If 
	If ETACTION = 5
	  tmp$="*** ORDER ENTERED ***"
	End If 
	If ETACTION = 6
	  tmp$="*** ORDER/PICKUP PRINTED ***"
	End If 
	If ETACTION = 7
	  tmp$="*** ORDER SCANNED ***"
	End If 
	If ETACTION = 8
	  tmp$="*** INV/CM PRINTED ***"
	End If 
	If ETACTION = 9
	  tmp$="*** ORDER DELETED FROM 225 ***"
	End If 
	If ETACTION = 10
	  tmp$="*** INVOICE DELETED FROM 225 ***"
	End If 
	If ETACTION = 11
	  tmp$="*** LINE WAS ADDED ***"
	End If 
	If ETACTION = 12
	  MENUNUM = ETPROD$
	  If MENUNUM
		tmp$="*** WAS EDITED IN ",Str$(MENUNUM)," ***"
	  Else 
		tmp$="***HOLD CODE(S) WAS EDITED***"
	  End If 
	End If 
	If ETACTION = 13
	  tmp$="*** WAS EDITED BY SYSTEM ***"
	End If 
	If ETACTION = 14
	  tmp$="*** ORDER HEADER ACCESS ***"
	End If
	If ETACTION = 15
	  tmp$="*** PRICE CHANGE FROM SALESPRO ***"
	End If 
	If ETACTION = 16
	  tmp$="** PRICE/COST CHANGE FROM PROG 66 **"
	End If 
	If ETACTION = 20
	  tmp$="** SENT TO ROADNET **"
	End If 
	If ETACTION = 21
	  tmp$="** RETURNED FROM ROADNET **"
	End If 
	if etaction = 22
	   tmp$="*** PICKING TICKET PRINTED ***"
    endif
	if etaction=23
		tmp$="** PRICE CHANGE ON LINE **"
	endif
	if etaction=24
		tmp$="** COST CHANGED ON LINE **"
	endif
	IF ETACTION=25
		tmp$="** EXTENDED SHIP WEIGHT **"
	ENDIF
	if etaction=217
		tmp$="*** CUSTOMER CHANGED ***"
	Endif
	if etaction=374
		tmp$="*** RECEIPTS TO STOCK ACCEPT ***"
	Endif
	If etaction=371
		tmp$="*** RECEIPTS TO STOCK ENTRY ***"
	endif
	if etaction=512
		tmp$="*** A/P Purchase Journal ***"
	endif
	if etaction=234 or etaction=205
		tmp$="*** Order Invoiced ***"
	endif
	IF ETACTION=65
		tmp$="**Credit Card Process**"
	endif
	webstr$=webstr$,tmp$,fdel$
	List$[row]=webstr$
	row=row+1 \ If row>tmpcnt let tmpcnt=expandarray(e$,List$[])
Else ! to printer
	If LN  > MAXLN Gosub PAGEBREAK ! + 4
	! if custom_customer$="ACME" and LN+5>maxln gosub pagebreak
	If WANNAQUIT Return 
	If ETACTION <> 7 !* order scans are for entire order only - no line info!
	  Print #0; Using "###### #### #### ";ETORDER;ETLINE;ETSTAT;
	Else 
	  Print #0; Using "###### #### #### ";ETORDER;ETLINE;ETSTAT;
	End If 
	If ETPROD$[1,10] <> "STATUS CHG" And ETPROD$[1,7] <> "DELETED" And ETACTION <> 7 And ETACTION <> 14
		IF  etaction=65 
			print #0;"Credit Card";
			if etunit=63 print #0;" Manual Pre-Auth Override";
			if etunit=65 print #0;" Submit for Post Auth";
			if etunit=67 print #0;" Response from Post Auth";
			if etunit<>63
				print #0;": ";
				Print #0;etprod$;
			endif
			Print #0;tab 60;"CC Amt:";
			Print #0; Using MASK$ + " "; Tab (68);ETORIGTOT;
			print #0;""
			ln=ln+1
			goto GetTimeLine:
		endif
	  If ETACTION = 12 Or ETACTION = 13
		PRNTFLAG = 0 \ PRNTFLAG2 = 0
		Print #0;"HOLD CODE: ";
		X2 = ETOQTY[0]
		For K = 0 To 11
		  OT9[K] = Sgn(Fra(X2 / 2)) \ X2 = Int(X2 / 2)
		Next K
		X2 = ETNQTY[0]
		For K = 0 To 11
		  NT9[K] = Sgn(Fra(X2 / 2)) \ X2 = Int(X2 / 2)
		Next K
		For K = 0 To 11
		  If OT9[K] > NT9[K]
			If PRNTFLAG = 1 Print #0;",";
			Print #0; Using "##";K + 1;
			PRNTFLAG = 1
		  End If 
		  If PRNTFLAG If K = 11 Print #0;" WAS REMOVED";
		Next K
		For K = 0 To 11
		  If OT9[K] < NT9[K]
			If PRNTFLAG = 1
			  Print #0;"" \ ln=ln+1
			  Print #0; Tab 17;"HOLD CODE: ";
			End If 
			If PRNTFLAG2 = 1 Print #0;",";
			Print #0; Using "##";K + 1;
			PRNTFLAG2 = 1
		  End If 
		  If PRNTFLAG2 If K = 11 Print #0;" WAS ON HOLD";
		Next K
	  Else 
		Print #0;ETPROD$;
		If custom_customer$="ACME"
			PRINT #0; TAB 30;A$[9,38];
			PRINT #0; USING MASK$+" ";ONHANDQTY;
			PRINT #0;" ";PLOC$[13,18] \ ln=ln+1
		Endif
		IF TOSCREEN PRINT 'BD';
		If ETACTION = 15 Or ETACTION = 16 or etaction=23
		  Print #0; Using MASK$ + " "; Tab (31);ETUNITPRICE1[0];
		  Print #0;PUNIT$;
		  If (ETACTION = 16 or etaction=24) And COST_LEV[1] ! "this has COST too
			Print #0; Using MASK$ + " "; Tab (46);ETLOADCOST1[0];
			Print #0;CUNIT$;
		  End If 
		Else 
		  If (etaction=24) And COST_LEV[1] ! "this has COST too
			Print #0; Using MASK$ + " "; Tab (46);ETLOADCOST1[0];
			Print #0;CUNIT$;
		 Else
		  Print #0; Using MASK$ + " "; Tab (31);ETOQTY1[0];ETOQTY1[1];ETOQTY1[2];
		  Print #0;UM$;
		 Endif
		End If 
		Print #0; Using MASK$ + " "; Tab (68);ETORIGTOT;
	  End If 
	Else ! was = to a bunch of diff checks on etprod & actions
	  If ETACTION <> 7 If ETACTION <> 14 Print #0;"[";ETPROD$;"]";
	  If ETACTION = 14
		MENUNUM = ETPROD$
		If MENUNUM Print #0; Tab 31;"FROM MENU ";ETPROD$;
	  End If 
	End If 
	Print #0;"" \ ln=ln+1
	!If TOSCREEN Print 'BD';
	GetTimeLine: ! get time line
	Print #0; Using "######## ";ETINVOICE;
	X$ = ETDATE Using "########"
	Call JulianToDate(1,X$,SCRATCH$,E)
	Print #0;SCRATCH$;
	HH = Int(ETTIME / 10000)
	MM = Int(ETTIME / 100) - HH * 100
	SS = ETTIME - (HH * 10000) - MM * 100
	Print #0; Using "&&:&&:&&"; Tab (16);HH;MM;SS;
	Print #0; Using "####"; Tab (25);ETPORT;
	If ETACTION = 1 Or ETACTION = 374 or ETACTION=371 or etaction=512 or etaction=234 or etaction=205
	  Print #0; Using MASK$ + " "; Tab (31);ETNQTY1[0];ETNQTY1[1];ETNQTY1[2];
	End If 
	If ETACTION = 2
	  Print #0; Tab (31);"*** LINE DELETED ***";
	End If 
	if etaction = 26                                     
		print #0; tab(31);"*** CREDIT MEMO DELETED ***"; 
	endif                                                
	If ETACTION = 3 
	  IF  ETPROD$[1,12] = "DEL OR-BAD D"
		Print #0; Tab (31);"***ORDER DELETED FROM 229- BAD DATA ***";
	  ELSE
          IF etprod$[1,12]="DELETED -201" ! 1
		    print #0; tab(31);"*** ORDER DELETED FROM 201 ***";
          ELSE
            IF etprod$[1,12]="DELETED -231" ! 2
		      print #0; tab(31);"*** ORDER DELETED FROM 231 ***";
            ELSE
             IF etprod$[1,12]="DELETED -251" ! 3
		       print #0; tab(31);"*** ORDER DELETED FROM 251 ***";
             ELSE
              IF etprod$[1,12]="DELETED223CS" ! 4
		        print #0; tab(31);"**ORDER DELETED FROM 223-CASH SCRN**";
              ELSE
               IF etprod$[1,12]="DELETED221CS" ! 5
		         print #0; tab(31);"**ORDER DELETED FROM 221-CASH SCRN**";
               ELSE
			     print #0; tab(31);"*** ORDER DELETED FROM 206 ***";
               ENDIF ! 5
              ENDIF	! 4
             ENDIF	! 3
            ENDIF	! 2
          ENDIF	! 1
		ENDIF
	End If 
	!If ETACTION = 3 And ETPROD$[1,12] <> "DEL OR-BAD D"
	!  Print #0; Tab (31);"*** ORDER DELETED FROM 206 ***";
	!End If 
	If ETACTION = 4
	  Print #0; Tab (31);"*** LINE DELETED FROM 229- BAD DATA ***";
	End If 
	If ETACTION = 5
	  Print #0; Tab (31);"*** ORDER ENTERED ***";
	End If 
	If ETACTION = 6
	  Print #0; Tab (31);"*** ORDER/PICKUP PRINTED ***";
	End If 
	If ETACTION = 7
	  Print #0; Tab (31);"*** ORDER SCANNED ***";
	End If 
	If ETACTION = 8
	  Print #0; Tab (31);"*** INV/CM PRINTED ***";
	End If 
	If ETACTION = 9
	  Print #0; Tab (31);"*** ORDER DELETED FROM 225 ***";
	End If 
	If ETACTION = 10
	  Print #0; Tab (31);"*** INVOICE DELETED FROM 225 ***";
	End If 
	If ETACTION = 11
	  Print #0; Tab (31);"*** LINE WAS ADDED ***";
	End If 
	If ETACTION = 12
	  MENUNUM = ETPROD$
	  If MENUNUM
		Print #0; Tab (31);"*** WAS EDITED IN ";Str$(MENUNUM);" ***";
	  Else 
		Print #0; Tab (31);"***HOLD CODE(S) WAS EDITED***";
	  End If 
	End If 
	If ETACTION = 13
	  Print #0; Tab (31);"*** WAS EDITED BY SYSTEM ***";
	End If 
	If ETACTION = 14
	  Print #0; Tab (31);"*** ORDER HEADER ACCESS ***";
	End If 
	If ETACTION = 15 Or ETACTION = 16 or etaction=23
	  Print #0; Using MASK$ + " "; Tab (31);ETUNITPRICE1[1];
	  Print #0;PUNIT$;
	  If (ETACTION = 16 or etaction=24) And COST_LEV[1] ! "new cost
		Print #0; Using MASK$ + " "; Tab (46);ETLOADCOST1[1];
		Print #0;CUNIT$;
	  End If 
	End If 
	If (etaction=24) And COST_LEV[1] ! "new cost
		Print #0; Using MASK$ + " "; Tab (46);ETLOADCOST1[1];
		Print #0;CUNIT$;
	End If 
	If Fra(ETACTION) Or ETPROD$[1,10] = "STATUS CHG"
	  Print #0; Tab (31);"*** STATUS CHG FRM";Int(ETACTION);
	  Print #0;"TO";Fra(ETACTION) * 100;"***";
	End If 
	If (ETACTION < 1 Or ETACTION > 16) And ETPROD$[1,10] <> "STATUS CHG" 
	 if etaction<>23 and etaction<>24 and etaction<>22
	  If ETACTION = 217
		Print #0; Tab (31);"*CUSTOMER CHANGE(217)*";
	  Else 
		!If ETACTION <> 20 And ETACTION <> 21 And ETACTION <> 374 AND ETACTION<>26 AND ETACTION<>371 and etaction<>512
		flagdk=99
		if etaction=512 let flagdk=0
		if etaction=20  let flagdk=0
		if ETACTION=21  let flagdk=0 
		if ETACTION=374 let flagdk=0
		if ETACTION=371 let flagdk=0 
		if ETACTION=25  let flagdk=0 
		if etaction=234 let flagdk=0
		if etaction=205 let flagdk=0
		if custom_customer$="HTBERRY"
			if etaction=23 let flagdk=0 
			if etaction=24 let flagdk=0 
		endif
		if flagdk<>0
			  Print #0; Tab (31);"*** ACTION UNKNOWN ***";
		End If 
	  End If
	 Endif ! 23/24 price/cost
	End If 
	if etaction = 22
	   print #0;  tab(31);"*** PICKING TICKET PRINTED ***";
    endif
	if etaction=512
		Print #0; Tab (64);"AP JRNL";
	endif
	if etaction=234 or etaction=205
		Print #0; Tab (64);"INVOICED";
	endif
	If ETACTION = 374
		Print #0; Tab (64);  "PROG 374";
	ELSE
		If ETACTION = 371
			Print #0; Tab (64);"RTS ENTRY";
		Else 
			Print #0; Tab (64);ETUSER$;
		ENDIF
	End If 
	Print #0;"" \ ln=ln+1
	If ETACTION = 15
	  Print #0; Tab (31);"*** PRICE CHANGE FROM SALESPRO ***"
	  ln=ln+1
	End If 
	If ETACTION = 16
	  Print #0; Tab (31);"** PRICE/COST CHANGE FROM PROG 66 **"
	  ln=ln+1
	End If 
	If ETACTION = 20
	  Print #0; Tab (31);"** SENT TO ROADNET **"
	  ln=ln+1
	End If 
	If ETACTION = 21
	  Print #0; Tab (31);"** RETURNED FROM ROADNET **"
	  ln=ln+1
	End If 
	if etaction=23
		Print #0; Tab (31);"** PRICE CHANGE FROM LINE EDIT **"
		ln=ln+1
	Endif
	if etaction=24
		Print #0; Tab (31);"** COST CHANGE FROM LINE EDIT **"
		ln=ln+1
	Endif
	If (ETACTION = 6 Or ETACTION = 8)
	  If ETPRINT <= 0
		If ETPRINT = 0 Print #0;"UNKNOWN";
		If ETPRINT = -5 Print #0;"FAXED";
		If ETPRINT = -4 Print #0;"PROGRAM SPECIFIED";
		If ETPRINT = -3 Print #0;"EMAILED";
		If ETPRINT = -2 Print #0;"ARCHIVED";
		If ETPRINT = -1 Print #0;"DISK FILE";
	  Else 
		Read #CH_CNTRLLPT,ETPRINT,10;P2$;
		Print #0;P2$[1,16];
	  End If 
	End If 
	IF ETACTION=22                          
    	IF ETPRINT<=0                                        
   			IF ETPRINT=0 PRINT #0;"SCREEN";                   
			IF ETPRINT=-4 PRINT #0;"EMAILED";        
			IF ETPRINT=-3 PRINT #0;"FAXED";                  
			IF ETPRINT=-2 PRINT #0;"ARCHIVED";                 
			IF ETPRINT=-1 PRINT #0;"DISK FILE";                
		ELSE                                                 
			READ #CH_CNTRLLPT,ETPRINT,10;P2$                   
	 		PRINT #0;P2$[1,16];                                
	  	ENDIF                                                
		print #0;" "
	!Else                                                  
	!	print #0; using "###### "; tab(17); etcust;
	!	print #0; tab(32);a1$[31,60];"          " 
	endif
	costchg=0
	if cost_lev[1]<>0
		if etloadcost1[0]<>etloacost1[1]
			if etaction=374 let costchg=99
			if etuser$="PROG 264  " let costchg=99
			if etuser$="PROG 264NS" let costchg=99
			if etuser$="PROG266   " let costchg=99
			if etaction=512 let costchg=99
			If etaction=234 let costchg=99
			If etaction=205 let costchg=99
		endif
	endif
	if costchg<>0
		print #0;tab(17);"Cost Chg From:";
		print #0; using mask$+" "; tab(31); etloadcost1[0];
		print #0;" To ";
		print #0; using mask$+" "; tab(46); etloadcost1[1];
		print #0; cunit$; ! was punit -- need costing um
		print #0;" "
		ln=ln+1	
		let costchg=0
	endif
	If ETACTION = 217 ! Customer changed
	  Print #0; Tab 1;"NEW CUSTOMER: ";
	End If 
	Print #0; Using "###### "; Tab (17);ETCUST;
	Print #0; Tab (32);CNAME$[1,30] ! A1$[31,60]
	!If TOSCREEN Print 'ED';
	Print #0;""
	!If (ETACTION = 15 Or ETACTION = 16 or etaction=23 or etaction=24) Let LN = LN + 5 Else Let LN = LN + 4
	ln=ln+2 ! keep track as done
Endif ! of to screen or printer
Return 
PAGEBREAK: Rem
if purge return ! no print

If Not(TOSCREEN)
  Gosub TOF
  WANNAQUIT = 0
  Gosub HEADER
End If 

Return 
HEADER: Rem for report
if PURGE Return ! no print
if toscreen return ! no header
if page>0 print #0;"" ! so at bol
PAGE = PAGE + 1
Print #0;"-edittrack-";
Print #0; Tab (30);"Order Edit Tracking Report";
Print #0; Using "Page: #######"; Tab (66);PAGE
If SORT$ = "O"
  X$ = "ORDER"
Else 
  If SORT$ = "A"
    X$ = "ACCESS CODE"
  Else 
    X$ = "DATE"
  End If 
End If 
Print #0; Tab (5);"IN ";X$;" Sequence";
If ACCESS$ <> "          " Print #0;", Access: ";ACCESS$;
If ORDER Print #0;", ORDER#: ";Str$(ORDER);
If SDATE Or EDATE
  If SDATE
    X$ = SDATE Using "########"
    Call JulianToDate(1,X$,SCRATCH$,E)
  Else 
    SCRATCH$ = "First"
  End If 
  If EDATE
    X$ = EDATE Using "########"
    Call JulianToDate(1,X$,Y$,E)
  Else 
    Y$ = "Last"
  End If 
  Print #0;", Date: ";SCRATCH$;" to ";Y$;
End If 
If STIME Or ETIME
  If STIME
    HH = Int(STIME / 10000)
    MM = Int(STIME / 100) - HH * 100
    SS = STIME - (HH * 10000) - MM * 100
    LET SCRATCH$=HH using "&&",":",MM using "&&",":",SS USING "&&"
  Else 
    SCRATCH$ = "First"
  End If 
  If ETIME
    HH = Int(ETIME / 10000)
    MM = Int(ETIME / 100) - HH * 100
    SS = ETIME - (HH * 10000) - MM * 100
    LET Y$=HH using "&&",":",MM using "&&",":",SS USING "&&"
  Else 
    Y$ = "First"
  End If 
  Print #0;SCRATCH$;" to ";Y$;
End If 
If PURGE Print #0;" ***WITH PURGE***";
Print #0;"\15\"
if custom_customer$="ACME"
	PRINT #0;"ORDER# LINE STAT PRODUCT      DESCRIPTION";
	PRINT #0;"                 ONHAND QTY LOCATION "
	PRINT #0;"                               ORIG ORDER"; ! "/PRICE";
Else
	Print #0;"ORDER# LINE STAT PRODUCT       ORIG ORDER";
Endif
Print #0;"       SHIP         BO UNIT ORIG AMT  "
Print #0;"INVOICE DATE     TIME     PORT  NEW ORDER";
Print #0;"       SHIP         BO ACCESS         "
Print #0;"PRINTER #        CUST#          CUST NAME"
SCRATCH$ = "-",SCRATCH$
Print #0;SCRATCH$
LN = 9
if custom_customer$="ACME" let ln=10
Return 
TOF: Rem top of form
if purge or toscreen return
Print #0;"\14\";
LN = 1
Return 
CLEAR_SORT: Rem ==========================clear the sort file
CHNL = 9 \ Gosub CHNLFREE
If CHNLFREE
  Gosub OPEN_SORT
Else 
  K9$ = " ",K9$
CLEARSORT_LOOP: Rem
  Search #9,3,1;K9$,V1,E \ If E > 2 Gosub ERR_SEARCH
  If Not(E)
    Search #9,5,1;K9$,V1,E
    Goto CLEARSORT_LOOP
  End If 
End If 
Return 
OPEN_SORT: Rem
SCRATCH$ = "[1:1] 6/SORTWORK" + Str$(Spc(6)) + "!"
Build #9,SCRATCH$
R[9] = 25 \ Search #9,0,1;F$,R[9],E \ If E Gosub ERR_SEARCH
R[9] = 1 \ Search #9,0,0;F$,R[9],E \ If E Gosub ERR_SEARCH
R[9] = 0 \ Search #9,1,0;F$,R[9],E \ If E Gosub ERR_SEARCH
Return 
DO_SORT: Rem sort by order/access/date, status
SORTKEY = 0
COUNT = 0
K7$ = " ",K7$
K7$[1,2] = SSTATUS Using "##"
SORT_LOOP: Rem
Search #CH_ROH,3,1;K7$,R7,E
If E > 2 Gosub ERR_SEARCH
If E Goto END_SORTLOOP
COUNT = COUNT + 1
!If Not(Fra(COUNT / 100))
  !Print @0,23;"SORTING, PLEASE WAIT . . .  ";COUNT;"Records Processed.";'CE'; \ Signal 3,0
  !If TOSCREEN Print @0,9;'CL';
!End If 
ORDSTATUS = K7$[1,2]
If ORDSTATUS > ESTATUS Goto END_SORTLOOP
TMPET$ = " ",TMPET$
TMPET$[1,6] = K7$[3,8]
Search #CH_ET,3,1;TMPET$,REC_ET,E
If E > 2 Gosub ERR_SEARCH
If E Goto SORT_LOOP
If TMPET$[1,6] <> K7$[3,8] Goto SORT_LOOP
If Not(E) And TMPET$[1,6] = K7$[3,8]
  Mat Read #CH_ET,REC_ET,0;ETORDER;
  Mat Read #CH_ET,REC_ET,56;ETDATE;
  Mat Read #CH_ET,REC_ET,60;ETTIME;
  Mat Read #CH_ET,REC_ET,68;ETUSER$;
  if len(etuser$)<10 let etuser$=etuser$+Blank$
  If SDATE And ETDATE < SDATE Goto SORT_LOOP
  If EDATE And ETDATE > EDATE Goto SORT_LOOP
  If STIME And ETTIME < STIME Goto SORT_LOOP
  If ETIME And ETTIME > ETIME Goto SORT_LOOP
  If ACCESS$ <> "" And ACCESS$ <> "          "
    If ETUSER$ <> ACCESS$ Goto SORT_LOOP
  End If 
  K9$ = " ",K9$
  If SORT$ = "O"
    K9$[1,26] = TMPET$[1,26]
    K9$[27,28] = K7$[1,2]
  End If 
  If SORT$ = "A"
    K9$[1,10] = ETUSER$
    K9$[11,36] = TMPET$[1,26]
    K9$[37,38] = K7$[1,2]
  End If 
  If SORT$ = "D"
    K9$[1,8] = ETDATE Using "&&&&&&&&"
    K9$[9,14] = TMPET$[21,26]
    K9$[15,20] = TMPET$[1,6]
    K9$[21,26] = TMPET$[7,12]
    K9$[27,28] = K7$[1,2]
  End If 
  Search #9,4,1;K9$,REC_ET,E
  SORTKEY = SORTKEY + 1
  If E Gosub ERR_SEARCH
  Goto SORT_LOOP
End If 
Goto SORT_LOOP
END_SORTLOOP: Rem
Return 
GET_PROD: Rem
SCRATCH$ = " ",SCRATCH$
SCRATCH$ = ETPROD$
Search #CH_PROD,2,1;SCRATCH$,REC_PROD,E
If Not(E)
  Rem {begin src/inc/read.prod.i}
  Mat Read #CH_PROD,REC_PROD,0;A$;
  Mat Read #CH_PROD,REC_PROD,256;A;
  Mat Read #CH_PROD,REC_PROD,512;PFU1;
  Mat Read #CH_PROD,REC_PROD,554;PFU2;
ELSE 
	LET A$=" ",A$
	LET A$[9,30]="*** Non-Stock Item ***"
	FOR I=0 TO 33
		LET A[I]=0
		IF I<=20 LET PFU1[I]=0
		IF I<=6 LET PFU2[I]=0
	NEXT I
	LET PFU1[0]=ETUNIT
End If 
Return 
GET_UM: Rem
LET UM$=" ",UM$
If ETUNIT > 0 AND ETUNIT <= Chf(CH_CCODES) 
  Mat Read #CH_CCODES,ETUNIT,10;UM$;
Else 
  If ETUNIT = 0 Let UM$ = "Base"
  If ETUNIT = -1 Let UM$ = "CWT "
  If ETUNIT = -2 Let UM$ = "LOT "
  If ETUNIT = -3 Let UM$ = "LB  "
End If 
If ETPUNIT = 0 Let PUNIT$ = "Base"
If ETPUNIT = -1 Let PUNIT$ = "CWT "
If ETPUNIT = -2 Let PUNIT$ = "LOT "
If ETPUNIT = -3 Let PUNIT$ = "LB  "
If ETPUNIT > 0 Mat Read #CH_CCODES,ETPUNIT,10;PUNIT$;
If ETPUNIT[1] = 0 Let CUNIT$ = "Base"
If ETPUNIT[1] = -1 Let CUNIT$ = "CWT "
If ETPUNIT[1] = -2 Let CUNIT$ = "LOT "
If ETPUNIT[1] = -3 Let CUNIT$ = "LB  "
If ETPUNIT[1] > 0 Mat Read #CH_CCODES,ETPUNIT[1],10;CUNIT$;
Return 
DO_CONVERSIONS: Rem
OnhandQty=0
If ETWGT[0] Let A[6] = ETWGT[0]
If ETWGT[1] Let A[5] = ETWGT[1]
If ETNONSTOCK
  For SCR = 0 To 2
    ETOQTY1[SCR] = ETOQTY[SCR]
    ETNQTY1[SCR] = ETNQTY[SCR]
  Next SCR
  For SCR = 0 To 1
    ETUNITPRICE1[SCR] = ETUNITPRICE[SCR]
    ETLOADCOST1[SCR] = ETLOADCOST[SCR]
  Next SCR
Else 
  CNVTU[0] = 0
  CNVTU[1] = ETUNIT
  CNVTU[2] = 1
  For SCR = 0 To 2
    CNVTA = ETOQTY[SCR]
    Gosub CONVERT
    ETOQTY1[SCR] = AMOUNT
    CNVTA = ETNQTY[SCR]
    Gosub CONVERT
    ETNQTY1[SCR] = AMOUNT
  Next SCR
  LET CNVTA=A[0]      
  GOSUB CONVERT:      
  LET ONHANDQTY=AMOUNT
  CNVTU[0] = 0
  CNVTU[1] = ETPUNIT
  CNVTU[2] = 2
  For SCR = 0 To 1
    CNVTA = ETUNITPRICE[SCR]
    Gosub CONVERT
    ETUNITPRICE1[SCR] = AMOUNT
  Next SCR
  CNVTU[0] = 0
  CNVTU[1] = ETPUNIT[1]
  CNVTU[2] = 2
  For SCR = 0 To 1
    CNVTA = ETLOADCOST[SCR]
    Gosub CONVERT
    ETLOADCOST1[SCR] = AMOUNT
  Next SCR
End If 
Return 

GET_CUST: Rem
cn1$=" ",cn1$
SCRATCH$ = " ",SCRATCH$
SCRATCH$ = ETCUST Using "######"
Search #CH_CUST,2,1;SCRATCH$,REC_CUST,E
If E
  A1$[31,60] = "NOT FOUND"
Else 
  Rem {begin src/inc/read.cust.i}
  Mat Read #CH_CUST,REC_CUST,0;A1$;
  search #ch_cnote,2,1;scratch$,rec_cnote,e
  if not(e)
	mat read #ch_cnote,rec_cnote,436;cn1$;
  endif
End If 
LET CNAME$=A1$[31,60]
IF ucase$(CN1$[1,1])="A" let cname$="*"+a1$[31,59]
if ucase$(CN1$[1,1])="S" let cname$="*"+a1$[31,59]
Return
! acme custom gosubs
GET_WHSE: REM  get the whse from order
LET PASS=0
LET HISTPASS=0
FOR STATUS=1 TO 9
	LET K2$[1,2]=STATUS USING "##"
	LET K2$[3,8]=ETORDER USING "######"
	SEARCH #CH_ROH,2,1;K2$,REC_ROH,E
	IF E>1 GOSUB ERR_SEARCH:
	IF NOT(E)
		LET PASS=1
		LET STATUS=9
	ENDIF 
NEXT STATUS
IF NOT(PASS)
	LET K2$[1,2]=30 USING "##"
	LET K2$[3]=ETINVOICE USING "##########"
	SEARCH #CH_INVH,2,1;K2$,REC_INVH,E
	IF E>1 GOSUB ERR_SEARCH:
	IF NOT(E)
		LET HISTPASS=1
	ELSE 
		LET K2$[1,2]=31 USING "##"
		LET K2$[3]=ETORDER USING "##########"
		SEARCH #CH_INVH,2,1;K2$,REC_INVH,E
		IF E>1 GOSUB ERR_SEARCH:
		IF NOT(E) LET HISTPASS=1
	ENDIF 
ENDIF 
IF PASS
	MAT  READ #CH_ROH,REC_ROH,78;H4;
ENDIF 
IF HISTPASS
	MAT  READ #CH_INVH,REC_INVH,78;H4;
ENDIF 
IF NOT(PASS) AND NOT(HISTPASS) LET H4[2]=1
IF NOT(H4[2]) LET H4[2]=1
RETURN 
!------------------------------------------------------------------------
GET_LOCATION: REM =================   read product location record
	SEARCH #CH_PRODLOC,3,1;K12$,R12,E
	LET PLOC$=" ",PLOC$
	IF E=2 GOTO END_GET_LOCATION:
	IF E GOSUB ERR_SEARCH:
	IF K12$[1,12]<>ETPROD$[1,12] GOTO END_GET_LOCATION:
	LET WHSENO=K12$[13,14]
	IF WHSENO<>H4[2] GOTO GET_LOCATION:
	MAT  READ #CH_PRODLOC,R12,0;PLOC$;
	MAT  READ #CH_PRODLOC,R12,18;PL1;
	IF PL1[1]<>1 GOTO GET_LOCATION:
	END_GET_LOCATION: REM
RETURN 

CHNLFREE: Rem check to see if a channel is being used
If Err 0 Let CHNLFREE = Spc(8)
CHNLFREE = 0
E = Chf(CHNL)
If Err 0 Gosub ERR_TRAP
If CHNLFREE And CHNLFREE <> 49 Gosub ERR_TRAP
END_CHNLFREE: Rem
Return 

Rem {begin rtn.convert.s}
CONVERT: Rem "UNIT CONVERSION RETURNS AMOUNT  (rev 01/07/1992)   ! 20040 REM
If CNVTU[2] = 3 Or CNVTU[2] = 4 Goto CVTSTARTA
If CNVTU[2] = 1 And CNVTU[1] = CNVTU[0] Let AMOUNT = CNVTA \ Goto CVTDONE
If CNVTU[0] = -2 Or CNVTU[1] = -2 Let AMOUNT = CNVTA \ Goto CVTDONE
If CNVTU[2] = 0 Goto CVTSTARTA
If Not(CNVTA) Let AMOUNT = 0 \ Goto CVTDONE
CVTSTARTA: Rem ALL UB 5+!!  IF SPC 4>1280 GOTO cvtstartb: ! "unibasic 5+

CVTSTARTB: Rem "====== unibasic 5+ logic
!Call "MXPRCONV5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
Call "MXPRCONV5.dl4",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG,e$,rstr$
If CNVTU[2] = 0 Goto CVTDONE
If FLAG Let E = FLAG \ Gosub ERR_SEARCH
AMOUNT = CNVTA
CVTDONE: Return 
Rem {end rtn.convert.s}

save_bad_key: ! save key number if error in purge
scratch$=" ",scratch$
scratch$[1,24]=rec_et using "Bad Key Rec ############"
search #9,4,1;scratch$,rec_et,e \ if e >1 gosub err_search
return

fix_errors: ! if any bad keys hunt and remove slowly
scratch$=" ",scratch$
scratch$[1,12]="Bad Key Rec "
search #9,3,1;scratch$,bad_rec,e \ if e>2 gosub err_search
if e or scratch$[1,12]<>"Bad Key Rec " goto exit_fix
for dir=1 to 4
	scratch$=" ",scratch$
fix_err_loop:search #ch_et,3,dir;scratch$,rec_et,e \ if e>2 gosub err_search
	if e=0
		hold$=" ",hold$
		hold$[1,24]=rec_et using "Bad Key Rec ############"
		search #9,2,1;hold$,bad_rec,e \ if e>1 gosub err_search
		if e=0 and bad_rec=rec_et
			search #ch_et,5,dir;scratch$,rec_et,e \ if e gosub err_search
		endif
		!! let it go all the way thru, want to be sure we get everything
	goto fix_err_loop
	endif
next dir
!! put record on freelist
scratch$=" ",scratch$                                      
scratch$[1,12]="Bad Key Rec "                               
fix_err_loop2: search #9,3,1;scratch$,bad_rec,e \ if e>2 gosub err_search
if e=0 and scratch$[1,12]="Bad Key Rec "
e=3
	hold$=" ",hold$
	search #2,1,1;hold$,bad_rec,e \ if e>1 gosub err_search
	goto fix_err_loop2
endif
exit_fix: return 


DONE: Rem send status
if purge gosub fix_errors
Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)     
Call AddToStr(e$,rstr$,WebStr$)                            
Call SetOutPut(e$,rstr$)
OUTEND: Rem
!Close 
!Chain "mx000"
END
ERR_SEARCH: Rem                                            
ENUM = E;ELINE = Spc(16);CTERR = 0                         
If E = 5 Let CTERR = Err(8)                                
e$ = "RETURN STATUS",(E + (CTERR * .001))                  
e$ = e$,"/ STATEMENT",ELINE," IN PROGRAM " + Msc$(4)       
Call programdump("tmp/916se!","")                        
Goto ERR_MSG ! Error 10000                                 
Return ! End

ERR_MSG: ! send message                                    
ReturnStatus = 0 ! no good 
Message$ = e$                                              
Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)     
Call AddToStr(e$,rstr$,WebStr$)                            
Call SetOutPut(e$,rstr$)                                   
End              
Rem {begin rtn.error.s}
ERR_TRAP: Rem *Error routine (escape trap)   V3.1 8/94 G.DOSCHER/REK
!
include "src/callmainerrnet.inc"
End