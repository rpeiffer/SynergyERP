! >>> Program serpamalg
!
! description Price Amalgamation for web (NO ORDER YET)
!
! loadsave -w -n 100,10 -o prog/dxport/serpamalg.dl4 src/serpamalg.src
!
! 1.0 mm/dd/yyyy change??
!
include "src/copyright.inc" ! dx
! ORIGINAL FROM:
Rem MX201WT   ORDER LINE ADD-ON CHARGES AND AMALGAMATION
Rem DOES NOT DO NON STOCK ITEMS -- SKIPS OVER THEM!
Rem REK  10/12/92     from mx201b1
! Last Update: 11/92 rek for amalgamations - swap from mxline
!               04/02/1997 - DATE COMPARES JULIAN
! IT's a CALL ON ERP, SWAP on Classic
Rem BEDIT Version: 2.5 OBJECT CODE     Created: FEB 11, 2014  11:10:06
Rem /x/w2/pm/r2005//x/usracct/jcs/work/custom/xrev9/mx201wt.src (synergyux.synergy.n) [jcs] {22297}
Rem  Copyright (c) 2014 Universal Business Systems, Inc.
Rem    **** ALL CHANGES MUST BE MADE IN SOURCE!!! ****
Rem
! THIS WILL GET ALL NEW PRICES FOR THE LINES ALSO - does ORDERS,CREDITS,QUOTES
!
! send 1%,H4[2],SO[20],P3,2%,N0,H5[16],H0[12],R[50],S9[9]
!  h4 - orderheader, so - customer multislsm, p3 - PRICE TYPE(H6[0])
!  N0 - order#, H5 & H0 - order header
!  R[]=record #'s [50]=type, s9[] - misc flags (only [4] used)
!
! AS THIS IS A WEB PAGE CALL & NO ORDER IS ON BACK END
! WEB WILL PASS AS MUCH AS THEY CAN
! We build/create a "rol" type file for every line(product) passed
! IT WILL HAVE SAME LAYOUT AS ROL JUST TO MAKE IT EASY
! ORDER NUMBER IS SET TO JULIAN DATE (5 digits)
! CALL SHEET DOCUMENT = CM-VolDiscount.doc   (in calls/orders)

External Lib "librebates.lib"
Declare External Sub rebates
!
External Lib "ubsfunc.dl4"
Declare External Function OpenFile
!
External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus
!
Declare Intrinsic Sub DateToJulian,InpBuf,String,VerifyDate
Declare Intrinsic Function findchannel
!Option Default Dialect IRIS1


If Err 0 Gosub ERR_TRAP
! Chain Read H4,SO,P3,N0,H5,H0,R,S9 ! dl4 doesn't like com's w/chain read!
! Enter H4[],SO[],P3,N0,H5[],H0[],R[],S9[],Intco,PChan[]
Dim 1%,PFU1[20],CNVTU[2],UN[2],WH,H4[2],P3,PCHAN[99]
Dim 2%,C4[8],SEL,SEL$[5],AXCESS,N0,H5[16],H0[12],s0[20]
Dim 3%,PRODREC,PFU2[6],CNVTA,A[33],UWORK[20],FIELD,BASEC,AMOUNT
Dim CUST$[142],3%,R1[20],r[99],s9[9]
Dim 1%,ADDUM,CHANNEL_[9],FLG,SPBRK[1],CHNL,SRC,CHNLFREE,2%,WT[5],3%,TORDWT
Dim SUM$[4],PUM$[4],KCUST$[50],1%,TYPE,RB[2],RBL1[1],RBWH,RBUM[1]
Dim 2%,ADDON[9,5],RB1[5],3%,RBCOST,RBSLCOST,RB5[2],RP_COST,PREC[1]
Dim 1%,C7[1],E8,I1,L,L1,L3[3],P0,P1,T0,X,X1,SPWH,L9TMP,LINK[9],STATUS
Dim 1%,X9,Y9,P9,P6[100],P[4],U2$[3],F6,M8,M5[3],T7[11],C8,TAX[100],C3[2]
Dim 1%,DWH,2%,C13
Dim 2%,C,D,I4,I5,I2,D2,R9,I3,R3,H6[8],SPMIN,1%,X5[9],B3,LM[1],WHLM[1]
Dim 2%,B[24],C1[12],I,L2[1],L4[3],L6[5],L7[2],JODATE,JWDATE
Dim 2%,R4,V1,V2,Z7[3],Z8,Z9,SPCOM,3%,SPC5[4],ORDWT,X2[9]
Dim 2%,U3,D8,R6,T1,R5,U2,M6[3],B4,Q0[1],A3[2],SPC1[5],DT3[1]
Dim 1%,SC,SR,NC,NR,PROD$[12],SPCUM[1],PROD,COMDY,ALLPROD,EUN[2]
Dim 3%,A1[5],C2[2],L5[3],L8[4],P4[4],Q1[2],S5[3],X3,X4,B2[10,2],M7,A5[33]
Dim 3%,OLM[6],LPQTY,LPRICE,LPUNIT$[4],LSUNIT$[4],LPDATE$[8],PN$[16]
Dim 3%,W3[24],AMOUNT,FLAG,UNITV,XX$[22],DESC$[10],J4$[50],PMASK$[30]
Dim 1%,SPC6[4],APTYPE[8],ABTYPE[8],AMTYPE[8],3%,APFACT[8],AMQTY[8],ORDQTY ! add'l spcl prices2-9
Dim 1%,WHSE,PM5[5,4],whparc[5],3%,SRN[4],PRPARC[3],WHMISC[6],PF_LOAD2
Dim P60$[50],SUNIT$[4],PUNIT$[4],CUNIT$[4],UNIT$[4],1%,OU[2]
Dim 3%,P5[3],A2[7],S7[12],S1[20],C5[3],T3,SPC4[6],QTOT,B1[9,2],UNF[6],SPSLCOST
Dim A$[60],A1$[156],F$[16],I$[60],I1$[30],K1$[30],K5$[65],FLG$[4],K9$[30]
Dim BUNIT$[4],3%,IUNIT,DUNIT,BUNIT,BRFLAG,CHBASE,QDOL,BRKAMT
Dim L$[30],L1$[30],L2$[20],L3$[30],L4$[30],L9$[13],P1$[80],P9$[50],LOC$[6]
Dim 2%,L9[1],P2$[92],P3$[16],S$[30],CUST,A2$[12],MT$[2],LCO[1]
Dim S0$[36],X$[20],D1$[10],L7$[6],2%,J1$[16],F1$[16],W$[50],W9
Dim X6$[20],D6$[20],K7$[50],P$[50],K6$[50],U5$[50],M1$[30],U9$[50],1%,T9,T8,O1
Dim 3%,A2[7],SYSTEM_PRICE,SGPRICE,2%,D4[2],D3[2],D$[16],L0,X7,F7
Dim 3%,S3[17],REBATE_ARGS[10,3],CST,1%,S2[1],WT1,2%,S3$[33],W
Dim E$[500],Msg$[500],V$[60],filename$[64],filename2$[128]
Dim buttonlist$[5,50],nextlist$[5,100] !error handling variables
dim action$[30],options$[30],userid$[8],b$[200],action1$[30],Action2$[30]
Dim bsdel$[10],esdel$[10],rdel$[10],fdel$[10],rstr$[3000]
dim tmp$[1200],tmp1$[300],Msgdesc$[150],List$[1000,1000]
Dim Webstr$[200],Message$[200]
Dim 3%
! call dxopen() ! already done in oemenu
call GetSession(e$,CTLC,options$,action$,UserID$,intCo,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$,action1$,action2$)
B$=" ",B$	
!Chain Read H4,SO,P3,N0,H5,H0,R,S9
! Open any files needed - unless they're passed
! chan[1]=prod,[2]=commod,[3]=rol,[4]=brktbl,[5]=proddesc,[6]=prodwh
! [7]=ccode,[8]=pcontrh,[9]=specprice,[10]=CUST,[11]=roh
!
! FLG - evidently it's 1,2,3 ONLY - 1=ORDER, 2=CREDIT, 3=QUOTE
! WEB IS ALWAYS ORDER!
COID = IntCo ! Int((Spc(5) - Int(Spc(5) / 16384) * 16384) / 64)
! CALL SHEET DOCUMENT = CM-VolDiscount.doc   (in calls/orders)
FLG = 1;R[50] = 0 \ If FLG < 1 Or FLG > 3 Let E = 0 \ Gosub ERR_SEARCH
let ch_prod=pchan[1] ! was #3
if ch_prod<=0
	CH_prod=OpenFile(-1792,Intco) \ if ch_prod=-1 error 42
Endif
ch_commd=pchan[2] ! was #4
if ch_commd<=0
	ch_commd=OpenFile(-2288,intco) \ if ch_commd=-1 error 42
Endif
ch_rol=findchannel() ! pchan[3] ! was #11
! build a temp "rol" file - same size (320W)/1dir(5W)
filename$="6/amroltemp"+Str$(SPC(6))
filename2$ = "<660> [10:320] ",filename$,"!"
   Build #ch_rol,filename2$ As "Universal Indexed-Contiguous"
   Rem key lengths in words
   r = 5 ! keylen (oooooollll) = 10 chars
   Search #ch_rol,0,1;v$,r,e
   If e
     Close #ch_rol
     ch_rol = e * -1 \ Error 11000
   Endif
   v$="";r=0;e=0
   Search #ch_rol,0,0;v$,r,e
   If e
     Close #ch_rol
     ch_rol = e * -1 \ Error 11000
   Else ! close & reopen to make permanent
     Close #ch_rol
     Open #ch_rol,filename$
   End If
ch_brktbl=pchan[4] ! was #6
if ch_brktbl<=0
	ch_brktbl=OpenFile(-1952,IntCo) \ if ch_brktbl=-1 error 42
endif
!ch_proddesc=pchan[5] ! was #12
!if ch_proddesc<=0 !
!	if flg<>3 let ch_proddesc=OpenFile(-2128,Intco) \ if ch_proddesc=-1 error 42
!	if flg=3 let ch_proddesc=Openfile(-1424,IntCo) \ if ch_proddesc=-1 error 42 ! quote
!endif
ch_prodwh=pchan[6] ! was #30
if ch_prodwh<=0
	ch_prodwh=OpenFile(-1744,Intco) \ if ch_prodwh=-1 error 42
endif
ch_ccode=pchan[7] ! was #26
if ch_ccode<=0
	ch_ccode=OpenFile(-1728,Intco) \ if ch_ccode=-1 error 42
endif
ch_pch=pchan[8] ! was #25
if ch_pch<=0
	ch_pch=OpenFile(-2880,IntCo) \ if ch_pch=-1 error 42
endif
ch_spc=pchan[9] ! was #28
if ch_spc<=0
	ch_spc=OpenFile(-1936,IntCo) \ if ch_spc=-1 error 42
endif
ch_cust=pchan[10] ! was #5
if ch_cust<=0
	ch_cust=OpenFile(-1808,IntCo) \ if ch_cust=-1 error 42
Endif
!ch_roh=pchan[11] ! was #8
!if ch_roh<=0
!	if flg<>3 let ch_roh=OpenFile(-1840,Intco) \ if ch_roh=-1 error 42
!	if flg=3 let ch_roh=Openfile(-1280,IntCo) \ if ch_roh = -1 Error 42 ! quote header
!endif
returnstatus=0;message$="NO AMALGAMATION" ! for if flags=N
Mat Read #1,115,40;Q0; ! "need for 20000 routine
X2 = tim(6) \ gosub jultodate ! H0[9] \ Gosub L_7820 \ X2 = 0
H0[9]=x2
JODATE = Tim(6) ! X2
N0= TIM(6) ! order 
tmp$="#",tmp$;tmp$[q0[1]+1]="" ! cut at # decimals
let pmask$="###########."+tmp$
Def FNR(X) = Sgn(X) * (Int(Abs(X) * 100 + .5) * .01)
Def FNU(H) = Int(Abs(H)) + Sgn(Fra(Abs(H))) * Sgn(H)
Def FNP(X) = Sgn(X) * (Int(Abs(X) * 10000 + .5) * .0001)
Mat Read #1,19,50;P9$; \ Mat Read #1,60,50;P60$;
COST2 = Val(P60$[38,38])
If P60$[39,39] = "Y" Let COST2RBT = 1
! OK - LET THE LOADING BEGIN!!
Call dxget("CUSTID",tmp$)
Let H0[4]=tmp$
if H0[4]<=0 or h0[4]>999999 or fra(h0[4]) let H0[4]=999999 ! in case no cust# yet
! WHSE = H4[2] ! "default from Header Whse
! as multi-slsm list may not be sent - get it (classic gets it in mx2xxb)
!if p9$[21,21]="Y" ! always get cust data!
! found an issue with serpordh/serpqteh - they NEVER SET PRICE TYPE
	KCUST$=" ",KCUST$
	LET KCUST$=H0[4] USING "######"
	SEARCH #CH_CUST,2,1;KCUST$,R1[1],E
	IF NOT(E)
		MAT READ #CH_CUST,R1[1],142;C1;
		MAT  READ #CH_CUST,R1[1],502;SO;
		Read #ch_cust,R1[1],692;C13;
		Read #ch_cust,R1[1],696;DWH;
	ELSE
		CLEAR SO[]
		CLEAR C1[]
		LET P9$[21,21]="N" ! NO CUSTOMER - NO M-SLSM
		dwh=0;c13=0
	ENDIF
!ENDIF  
IF P3<=0 AND C1[7]<>0 LET P3=C1[7] ! PRICE TYPE! GOTTA HAVE IT!!!
if p3<=0 let p3=1 ! FINAL - USE 1 as ZERO DOES NOT WORK!! leave zero so we can find why
H6[0]=p3
Whse=DWH \ if whse<1 or whse>99 or fra(whse) let whse=1
let h4[2]=whse
H5[7]=c13 \ if h5[7]<1 or h5[7]>38 or fra(h5[7]) let h5[7]=1 ! ORDER TYPE
Gosub L_8000 ! "get table
If Not(ADDUM) And P60$[12,12] <> "Y" Goto L_360 ! "no table set-up, don't waste time

! NOW LOAD PRODUCTS
call dxget("NUMPRODS",tmp$)
let numprods=tmp$
if numprods<1 or numprods>999 or fra(numprods) 
	returnstatus=0;message$="NO PRODUCTS - NUMPRODS"
	goto L_360 ! can't do it!!
endif
! loop for every prod to be sent
returnstatus=1
message$="OK"
for xpr=1 to numprods
	! possible: discount fields? upcharge?
	gosub L_7880 ! clear all rol fields
	Call dxget("PRODID"+Str$(XPR),tmp$)
	if rtrim$(tmp$)="" goto BPPROD ! no prod - NEXT
	prod$=UCase$(RTrim$(tmp$))+B$
	search #CH_PROD,2,1;Prod$,R,e
	if e 
		returnstatus=0
		message$="PRODUCT "+Str$(XPR)+" "+Prod$+" NOT FOUND"
		goto BPPROD
	Endif
	Let l4[0]=R;l3[0]=0;l3[1]=1;s2[0]=0 ! line types
	L4[3]=H4[2]
	gosub L_7000 ! read prod/prodwhse
	L2$[1,12]=prod$;l2$[17,20]=a1$[152,155]+B$
	L$[1,30]=a1$[9,38];l1$[1,30]=a1$[63,92]
	mt$[1,1]=a1$[156,156];lco[0]=2
	call dxget("QTY"+Str$(XPR),tmp$)
	uwork[0]=tmp$
	call dxget("QTYUM"+Str$(XPR),tmp$)
	SUM$=tmp$+B$
	let tmp$=sum$ \ gosub L_8500 ! get rec#
	UN[0]=r
	call dxget("PRICE"+Str$(XPR),tmp$)
	UPrice=tmp$;l9[0]=1 ! MATRIX price
	uwork[3]=uprice;uwork[15]=uprice ! prices in price um
	call dxget("PRCUM"+str$(XPR),tmp$)
	PUM$=tmp$+B$
	let tmp$=pum$ \ gosub L_8500 ! get rec#
	un[1]=r
	gosub L_29000 ! set up rol conversion values
	let l2[0]=11;l2[1]=n0
	let l3[2]=xPR;l3[3]=B[11]
	! convert to rol vars
	cnvtu[0]=un[0];cnvtu[1]=0;cnvtu[2]=1;cnvta=uwork[0]
	gosub L_20000
	let s7[2]=amount;s7[4]=amount ! qty order/ship (NO BO)
	let cnvtu[0]=un[1];cnvtu[1]=0;cnvtu[2]=2;cnvta=uprice
	gosub L_20000
	let l5[2]=amount;s7[6]=amount ! unit & orig price
	let olm[3]=amount ! net price
	let l5[1]=B[8] ! use load for cost so we have it
	gosub L_13300 ! extend
	! load in to "std" rol vars
	k5$=" ",k5$
	k5$=N0 Using "######"
	k5$[7]=xPR using "####" ! yes 4
	let e=2 ! get record
	search #ch_rol,1,0;k5$,r,e
	if e error 11000
	search #ch_rol,4,1;k5$,r,e
	if e error 11000
	let R1[3]=R
	gosub L_3200 ! write rol
BPPROD: ! fail or get next
Next XPR
! do it
Gosub L_14000 ! "get total order weight and redo lines
! all processing happens in L_14000 so return is DONE
! load string for Return to web
clear List$[]
List$[0]=bsdel$,"VOLPRICE",fdel$
tmp$="PRODID",fdel$,"BASEPRICE",fdel$
tmp$=tmp$,"PRICEUOM",fdel$,"DISCPCT",fdel$,"DISCDOL",fdel$
tmp$=tmp$,"UCTYPE",fdel$,"UPCHRG",fdel$,"FRTADD",fdel$
tmp$=tmp$,"NETPRICE",fdel$,"EXTPRC",fdel$
list$[1]=tmp$
row=2
k5$=" ",k5$
	k5$=N0 Using "######"
LNRECAP: ! 
SEARCH #CH_ROL,3,1;K5$,R1[3],E
IF E GOTO RCLineDone
! and thru lines one last time
Gosub L_7100 ! read rol & put into uwork
gosub L_13300 ! recalc extensions
tmp$=L2$[1,12],fdel$
tmp$=tmp$,LTrim$(UWORK[3] using PMask$),fdel$
UnitV = UN[1] \ Gosub L_10700 ! "get product price u/m
tmp$=tmp$,UNIT$,fdel$
tmp$=tmp$,LTrim$(L6[0] using "#####.##"),fdel$
tmp$=tmp$,LTrim$(UWork[11] using PMask$),fdel$
if s7[8]>=0
	tmp$=tmp$,"PCT",fdel$,LTrim$(S7[8] using "#####.##"),fdel$
else
	tmp$=tmp$,"DOL",fdel$,LTrim$(UWork[14] using PMask$),fdel$
endif
tmp$=tmp$,LTrim$(UWORK[8] using PMask$),fdel$ ! fght addon
tmp$=tmp$,LTrim$(UWork[15] using PMask$),fdel$
tmp$=tmp$,LTrim$(L5[3] using "###########.##"),fdel$
list$[row]=tmp$
row=row+1
goto LNReCap

RCLineDone: ! finished
List$[row]=esdel$
call AddToStr(e$,rstr$,List$[])

L_360: ! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
Goto OUTEND
L_2500: Rem PRT
If H5[7] = 8 Or H5[7] = 16 Let UWORK[4] = 0 \ UWORK[3] = 0 \ L5[1] = 0 \ L5[2] = 0
Gosub L_3950 ! "perform conversions
! Gosub L_10400 ! "msds check
CNVTU[0] = 0 \ CNVTU[1] = UN[0] \ CNVTU[2] = 1 \ CNVTA = S7[0] \ Gosub L_20000 \ UWORK[9] = AMOUNT
CNVTU[0] = 0 \ CNVTU[1] = UN[0] \ CNVTU[2] = 1 \ CNVTA = S7[12] \ Gosub L_20000 \ UWORK[10] = AMOUNT
Return 
L_3000: Rem FINISH UP
!I$ = ""
!If I$ = "" Let I$ = "Y"
!If I$ = "Y" Goto L_3200
L_3200: Rem READ LINE
If P9$[21,21] = "Y" Let L4[1] = SO[L3[3]] Else Let L4[1] = H0[11]
Mat Write #ch_rol,R1[3];L2;
Mat Write #ch_rol,R1[3],8;L3;
Mat Write #ch_rol,R1[3],16;L4;
Mat Write #ch_rol,R1[3],32;L5;
Mat Write #ch_rol,R1[3],56;L6;
Mat Write #ch_rol,R1[3],80;L$;
Mat Write #ch_rol,R1[3],110;L1$;
Mat Write #ch_rol,R1[3],140;L2$;
Mat Write #ch_rol,R1[3],168;S7;
Mat Write #ch_rol,R1[3],160;L9; \ Mat Write #ch_rol,R1[3],368;MT$;
Mat Write #ch_rol,R1[3],250;UN; \ Mat Write #ch_rol,R1[3],404;OLM;
Mat Write #ch_rol,R1[3],256;S2; \ Mat Write #ch_rol,R1[3],260;S3;
Mat Write #ch_rol,R1[3],446;EUN;
Mat Write #ch_rol,R1[3],452;UNF
Mat Write #ch_rol,R1[3],494;LCO
Mat Write #ch_rol,R1[3],502;CST;
X9 = 0 \ Gosub L_4600
Return 
L_3465: Rem "============ extended weight
If A[5] <= 0 Let A[5] = 1
S3[4] = (L6[4] * S7[4]) / A[5]
ORDWT = (L6[4] * S7[2]) / A[5] ! "extended weight ordered
Return 
L_3765: Rem "=============================== 10 bracket price calc
Gosub L_13000 ! "load into S7 array *************************** TEMP FIX
If P9$[32,32] = "Y" If W3[18] Let C4[4] = W3[18] ! "whse base cost
Gosub L_3465 ! "ext weight
!If Spc(4) > 1280 Goto L_3785
!Swap 1,"MX208BRK"
!Chain Write B,S7,S3,C4,Z7,PFU1,PFU2,A,C3
!E = Spc(6)
!L_3780: Signal 2,E,X3,X2,5 \ If E = -1 Let E = 0 \ Gosub ERR_SEARCH
!If E <> Spc(6) Goto L_3780
!Goto L_3788
! need to add to erp? Let's (calc 10 bracket price)
L_3785: Call "MX208BRK5.dl4",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG,B[],S7[],ORDWT,C4[],C3[],W3[],ch_brktbl
X2 = FLAG;X3 = CNVTA
L_3788: If X3 Let L9[0] = 5;OLM[2] = 0 ! "price origin
Return 
L_3950: Rem "=========================== perform conversions
X1 = 0
If S2[0] = 1 If S2[1] = 0 Let S2[1] = 1 ! "check # out (cut)
Gosub L_11700 \ Gosub L_13120
Gosub L_13300 ! "extension calcs
WT1 = 0 ! "NO, don't calc ext weight
Return 
L_4000: Rem "=================== QTY BREAK (NON-STANDARD)
L6 = 0;L6[1] = 0;UWORK[11] = 0
T0 = R33 ! "break table #
If T0 <= 0 Goto L_4180
If T0 > Chf(ch_brktbl) - 1 Goto L_4180
Mat Read #ch_brktbl,T0;B1; ! "break table record
Read #ch_brktbl,T0,200;B3; \ If B3 = 1 Or B3 = 3 Goto L_4060
Goto L_4190 ! "not a break table
L_4060: X4 = 0;T0 = 99;I1 = 9
UWORK[5] = QTOT ! "total quantity in stocking units
If B3 = 1 Let BRKAMT = QTOT
If B3 = 3 Let BRKAMT = QDOL
For I = I1 To 0 Step -1
  If B1[I,0] < 0 Goto L_4190 ! "bad table
  If I > 0 And B1[I,0] = 0 Goto L_4085 ! "work your way up
  If BRKAMT >= B1[I,0] Goto L_4090 ! "got one
L_4085: Next I
Goto L_4190 ! "no break
L_4090: X4 = B1[I,2];T0 = B1[I,1]
If Not(X4) And I > 0 ! "try again
  I = I - 1 ! "next level down
  Goto L_4090
End If 
If Not(X4) Goto L_4190 ! "no brewak
L_4180: If Not(T0) Let L6[0] = X4 ! "percent discount
If T0 = 1 Let L6[1] = X4 ! "dollar discount
L_4190: Return 
L_4408: Rem BASE TYPE
If P9$[32,32] = "Y" Gosub L_10200
If P9$[32,32] = "Y" Return 
FIELD = 0
If C3[1] = 2 Let FIELD = 0
If C3[1] > 3 If C3[1] < 10 Let FIELD = C3[1] - 3
If FIELD Gosub L_12000
If C3[1] = 1 Let BASEC = C4[4]
If C3[1] = 2 Let BASEC = B[8]
If C3[1] = 3 Let BASEC = B[10]
If C3[1] = 4 Let BASEC = A[20]
If C3[1] = 5 Let BASEC = A[21]
If C3[1] = 6 Let BASEC = A[22]
If C3[1] = 7 Let BASEC = A[23]
If C3[1] = 8 Let BASEC = A[24]
If C3[1] = 9 Let BASEC = A[25]
If C3[1] = 10 Let BASEC = RBCOST
If C3[1] = 11 Let BASEC = SPSLCOST \ If SPC5[3] = 4 Let BASEC = L5[1]
If C3[1] = 12 Let BASEC = L5[2]
Return 
L_4500: Rem "============== get commodity
K1$ = " ",K1$ \ K1$ = L2$[17,20]
Search #ch_commd,2,1;K1$,Z8,E
If E Gosub ERR_SEARCH
K1$ = K1$ + P3 Using "### "
Search #CHANNEL_[2],2,1;K1$,Z8,E \ If E > 1 Gosub ERR_SEARCH
If Not(E)
  Mat Read #CHANNEL_[2],Z8,53;P0; ! "brktbl flag 0/1
Else 
  P0 = 0
End If 
Return 
L_4600: Rem MODIFY SHIP REC QTY CHG OR FLAG LINE DELETED
Return ! not for web order
If FLG <> 1 Return ! "only for orders
!If Err 0 Rem
!Close #22
TChan=Findchannel()
Mat Read #1,60,6;FLG$;
If FLG$[1,1] <> "Y" Return 
Mat Read #1,88,2496;F$;
If Err 0 Gosub ERR_TRAP
Open #TCHAN,F$ ! was on #22 - let system find a channel
Read #1,3,172;D8;
K6$ = " ",K6$ \ K6$[1,6] = H0[4] Using "######" \ K6$[7,12] = H0[7] Using "######"
K6$[13,15] = L3[2] Using "###" \ K6$[16,21] = "000000"
L_4710: Search #TCHAN,3,1;K6$,R6,E
If E Return 
X2 = K6$[7,12]
If Not(H5[6]) If X2 <> H0[7] Return 
X2 = K6$[12,14]
If X2 <> L3[2] Return 
X2 = K6$[16,21]
If X2 Return 
Mat Read #TCHAN,R6,30;S1;
If S1[10] Goto L_4710 ! LINE ALREADY DELETED LOOK FOR NEXT
If S1[6] <> 0 Goto L_4710 ! SHIP REC
If X9 = 99 Let S1[10] = 99 \ S1[11] = D8
If S1[4] <> UWORK[0] Let S1[4] = UWORK[0]
S1[15] = UWORK[1]
If S1[8] <> L5[0] Let S1[8] = L5[0]
Mat Write #TCHAN,R6,30;S1;
Close #TCHAN
Return 
L_5120: Rem RECALCULATE LINE
Gosub L_2500
Gosub L_3000
Return ! "get next line to do
L_6000: Rem CALC LOADS FROM LOAD MARKUP
If P9$[32,32] = "Y"
  If WHLM[0]
    WH = WHSE;LTBL = WHLM[0];CNVTA = L5[1]
    Gosub L_6210 \ W3[17] = CNVTA
  End If 
  If WHLM[1]
    WH = WHSE;LTBL = WHLM[1];CNVTA = L5[1]
    Gosub L_6210 \ W3[14] = CNVTA
  End If 
Else 
  If LM[0]
    WH = 0;LTBL = LM[0];CNVTA = L5[1] ! (WH=0 FOR SPROD)
    Gosub L_6210 \ B[8] = CNVTA
  End If 
  If LM[1]
    WH = 0;LTBL = LM[1];CNVTA = L5[1]
    Gosub L_6210 \ PF_LOAD2 = CNVTA
  End If 
End If 
Return 
L_6210: Rem CALL
Call "MXLOAD5.dl4",H5[7],WH,LTBL,PREC[],CNVTA,Intco,e$,rstr$
Return 
L_7000: ! read prod
Mat Read #ch_prod,L4;A1$; \ Mat Read #ch_prod,L4,156;B; \ Mat Read #ch_prod,L4,256;A;
Mat Read #ch_prod,L4,894;C4; \ Mat Read #ch_prod,L4,834;A3; \ Read #ch_prod,L4,502;A1[5];
Mat Read #ch_prod,L4,512;PFU1; \ Mat Read #ch_prod,L4,554;PFU2; \ Mat Read #ch_prod,L4,944;A2$;
Mat Read #ch_prod,L4,620;LM; \ Mat Read #ch_prod,L4,834;A3;
Mat Read #ch_prod,L4,596;PRPARC; \ Read #ch_prod,L4,938;PF_LOAD2;
If P9$[32,32] = "Y" Gosub L_10000 ! prodwhse
Return
L_7100: Rem "================ read in line
Mat Read #ch_rol,R1[3];L2;
Mat Read #ch_rol,R1[3],8;L3;
If (H5[7] = 21 Or H5[7] = 22) And L3[2] = 0 Return ! "bypass repair info
Mat Read #ch_rol,R1[3],16;L4;
Mat Read #ch_rol,R1[3],32;L5;
Mat Read #ch_rol,R1[3],56;L6;
Mat Read #ch_rol,R1[3],80;L$; \ Mat Read #ch_rol,R1[3],446;EUN;
Mat Read #ch_rol,R1[3],110;L1$; \ Mat Read #ch_rol,R1[3],452;UNF;
Mat Read #ch_rol,R1[3],140;L2$; \ Mat Read #ch_rol,R1[3],404;OLM;
Mat Read #ch_rol,R1[3],160;L9; \ Mat Read #ch_rol,R1[3],368;MT$;
Mat Read #ch_rol,R1[3],168;S7; \ Mat Read #ch_rol,R1[3],260;S3;
Mat Read #ch_rol,R1[3],250;UN; \ Mat Read #ch_rol,R1[3],256;S2;
Mat Read #ch_rol,R1[3],370;S3$;
Mat Read #ch_rol,R1[3],494;LCO \ Mat Read #ch_rol,R1[3],502;CST;
WHSE = L4[3]
If WHSE <= 0 Or WHSE > 99 Let WHSE = H4[2]
If L3[0] Goto L_7210
Mat Read #ch_prod,L4;A1$; \ Mat Read #ch_prod,L4,156;B; \ Mat Read #ch_prod,L4,256;A;
Mat Read #ch_prod,L4,894;C4; \ Mat Read #ch_prod,L4,834;A3; \ Read #ch_prod,L4,502;A1[5];
Mat Read #ch_prod,L4,512;PFU1; \ Mat Read #ch_prod,L4,554;PFU2; \ Mat Read #ch_prod,L4,944;A2$;
Mat Read #ch_prod,L4,620;LM; \ Mat Read #ch_prod,L4,834;A3;
Mat Read #ch_prod,L4,596;PRPARC; \ Read #ch_prod,L4,938;PF_LOAD2;
PREC[0] = L4 ! "for MXLOAD
If P9$[32,32] = "Y" Gosub L_10000
Gosub L_6000 ! "calc loads
L_7210: If H5[7] = 2 Let L3[1] = 0
If L3[0] = 0 Goto L_7280
If S2[0] = 3 Goto L_7280
!R1[4] = L4 ! "sproddesc file
!Mat Read #ch_proddesc,R1[4],12;L3$;
!Mat Read #ch_proddesc,R1[4],42;L4$;
! Gosub L_30000 ! "load product defaults USE PRODUCT!!
L_7280: Gosub L_11700 ! "load into UWORK
Return 
X$ = " ",X$ \ X$[10] = ""
X$[1,3] = Int(X2 / 10 ^ 2 - Int(X2 / 10 ^ 4) * 10 ^ 2) + 10 ^ 2 Using "###"
X$[4,6] = Fra(X2 / 10 ^ 2) * 10 ^ 2 + 10 ^ 2 Using "###"
X$[7,9] = Int(X2 / 10 ^ 4) + 10 ^ 2 Using "###"
X$[4,4] = "/" \ X$[7,7] = "/" \ X$ = X$[2]
Return
JultoDate: ! julian to string then to number
DT3[0] = X2;FLAG = 1;X$ = " "
Call "JULIANUTIL",DT3[],X$,FLAG
! date to num  Return 
Call VerifyDate(X$,X$,E) \ If E Let X$ = "    "
X2 = X$[1,6] \ Return 
L_7820: Rem  CONVERT YYMMDD TO JULIAN (RETURN=NOGOOD, +1=OKAY)
X$ = X2 Using "&&&&&&"
Call DateToJulian(1,X$,X$,E) \ If E Return 
X2 = X$[1,5] \ Return 1
DT3[0] = X2;DT3[1] = X2;FLAG = 0
Call "JULIANUTIL",DT3[],X$,FLAG
Return 
L_7880: Rem clear
CNVTU[0] = 0 \ CNVTA = 0
X4 = 0
For I = 0 To 17 !RESTART
  If I < 6 Let L6[I] = 0;OLM[I] = 0
  If I < 2 Let SPBRK[I] = 0
  If I < 16 Let UWORK[I] = 0
  If I <= 4 Let L8[I] = 0
  S3[I] = 0
  If I > 3 Goto L_7955
  If I < 5 Let L5[I] = 0 \ L4[I] = 0
  If I <> 2 Let L3[I] = 0
  If I <= 2 Let L7[I] = 0
  If I <= 1 Let L2[I] = 0
L_7955: Next I
L9 = 0 \ S2[0] = 0 \ S2[1] = 0
For X = 0 To 12 \ S7[X] = 0 \ Next X
X2 = 0 \ BRFLAG = 0;ORDWT = 0
S3$ = " ",S3$ \ PUNIT$ = "" \ SUNIT$ = "" \ CUNIT$ = "" \ UNIT$ = ""
L$ = " ",L$ \ L1$ = " ",L1$ \ L2$ = " ",L2$ \ T0 = 0 \ X3 = 0 \ L7$ = " ",L7$
P1 = 0
Return 
L_8000: Rem GET TABLE
L = 0;I1 = 0
I1$ = " ",I1$ \ Read #1,88,2864;I1$;
channel_[1]=findchannel()
Open #CHANNEL_[1],I1$ ! "break link file
channel_[2]=findchannel()
Open #CHANNEL_[2],"2/COMMODITY" + Str$(COID)
channel_[3]=findchannel()
Open #CHANNEL_[3],"2/SPRICEMARK" + Str$(COID)
I1$ = " ",I1$ \ Read #1,88,2832;I1$;
channel_[0]=findchannel()
Open #CHANNEL_[0],I1$ ! "add-on table
I1$ = " ",I1$;I1$ = "     0" ! "default record
Search #CHANNEL_[0],2,1;I1$,V1,E \ If E > 1 Gosub ERR_SEARCH
If E Goto L_8260 ! "no table set up
Read #CHANNEL_[0],V1,0;ADDUM;
Mat Read #CHANNEL_[0],V1,2;WT;
Mat Read #CHANNEL_[0],V1,126;ADDON;
I1$ = " ",I1$;I1$ = H0[4] Using "######" ! "check for customer record
Search #CHANNEL_[0],2,1;I1$,V1,E \ If E > 1 Gosub ERR_SEARCH
If E Goto L_8260 ! "no customer record/use default
Mat Read #CHANNEL_[0],V1,2;WT;
Mat Read #CHANNEL_[0],V1,126;ADDON;
L_8260: Close #CHANNEL_[0]
Return 
L_8500: ! get um rec
i1$=tmp$
search #ch_ccode,2,1;i1$,r,e
if e error 11000
Return
OUTEND: Rem EXIT - close any channels opened in this program
Close #CHANNEL_[1] ! brk links  [0]=addon(already closed)
Close #CHANNEL_[2] ! "commodity?
Close #CHANNEL_[3] ! "pricemark?
If pchan[1]<=0 close #ch_prod
if pchan[2]<=0 close #ch_commd
if pchan[3]<=0 close #ch_rol
if pchan[4]<=0 close #ch_brktbl
! if pchan[5]<=0 close #ch_proddesc
if pchan[6]<=0 close #ch_prodwh
if pchan[7]<=0 close #ch_ccode
if pchan[8]<=0 close #ch_pch
if pchan[9]<=0 close #ch_spc
if pchan[10]<=0 close #ch_cust
kill filename$ ! kill temp rol file
END
E = 0 \ Gosub ERR_SEARCH
Stop 
L_10000: Rem "============================== get whse rec for product
For W = 0 To 24 \ W3[W] = 0 \ Next W
WHLM[0] = 0;WHLM[1] = 0;WHMISC[2] = 0
If P9$[33,33] = "N" Return ! "no whse screen
X1 = 0
W$ = " ",W$;W$[1,12] = L2$[1,12] ! "prod code
If H5[7] <> 7 Let W$[13,14] = WHSE Using "##" Else Let W$[13,14] = H5[11] Using "##" ! "whse
Search #ch_prodwh,2,1;W$,W9,E \ If E > 1 Gosub ERR_SEARCH
If E Let W9 = 0 \ Goto L_10075 ! "whse not found
Mat Read #ch_prodwh,W9,78;W3
mat read #ch_prodwh,w9,384;whparc;
Mat Read #ch_prodwh,W9,842;WHLM;
Mat Read #ch_prodwh,W9,800;WHMISC;
If H5[7] <> 4 And H5[7] <> 15 If X1 Let W3[2] = W3[2] + (S7[4] * X1) ! "on order
If H5[7] = 4 Or H5[7] = 15 If X1 Let W3[2] = W3[2] + ((S7[2] - S7[0] - S7[3]) * X1) ! "on order
L_10075: If P9$[32,32] = "Y" Gosub L_69000
Return 
L_10200: Rem BASE TYPE FROM WHSE FILE
BASEC = 0
FIELD = 0
If C3[1] = 2 Let FIELD = 0
If C3[1] > 3 If C3[1] < 10 Let FIELD = C3[1] - 3
If FIELD Gosub L_12200
If C3[1] = 1 Let BASEC = W3[18]
If C3[1] = 2 Let BASEC = W3[17]
If C3[1] = 3 Let BASEC = W3[16]
If C3[1] = 4 Let BASEC = W3[19]
If C3[1] = 5 Let BASEC = W3[20]
If C3[1] = 6 Let BASEC = W3[21]
If C3[1] = 7 Let BASEC = W3[22]
If C3[1] = 8 Let BASEC = W3[23]
If C3[1] = 9 Let BASEC = W3[24]
If C3[1] = 10 Let BASEC = RBCOST
If C3[1] = 11 Let BASEC = SPSLCOST \ If SPC5[3] = 4 Let BASEC = L5[1]
If C3[1] = 12 Let BASEC = L5[2]
Return 
L_10400: Rem MSD CHECK
return ! DONE IN SERPORDL!
!If L3 Or A3[1] = 0 Return 
!If S3[17] Return 
!Mat Write #ch_rol ,R1[3],260;S3;
!Mat Read #9,H0[2],154;SRN;
!Call "MX208MSD5",H0[],L1$,S3[],A3[],SRN[]
!Mat Write #ch_rol,R1[3],260;S3;
!Return 
L_10700: Rem FIND UNIT ABBR
If S2[0] = 3 Return ! "message
If UnitV = -1 Let UNIT$ = "CWT "
If UnitV = -2 Let UNIT$ = "LOT "
If UnitV = -3 Let UNIT$ = "LB  "
If UNITV < 0 Goto L_10790
Mat Read #ch_ccode,UNITV,10;UNIT$;
Mat Read #ch_ccode,UNITV,0;DESC$;
For X = 10 To 1 Step -1 \ If DESC$[X,X] = " " Let DESC$[X,X] = "" \ Next X
L_10790: Return 
L_11700: Rem LOAD SELLING QTY, PRICE,COST IN THERE UNITS INTO UWORK
CNVTU[0] = 0
CNVTU[1] = UN[0]
CNVTU[2] = 1
For X = 2 To 4
  If S2[1] Let CNVTA = S7[X] * S2[1] Else Let CNVTA = S7[X]
  If X = 4 If S7[2] = S7[4] Let AMOUNT = UWORK[0] \ Goto L_11770
  Gosub L_20000
L_11770: UWORK[X - 2] = AMOUNT
Next X
If H5[7] <> 4 And H5[7] <> 15 Goto L_11790
CNVTA = S3[7] \ Gosub L_20000 \ UWORK[7] = AMOUNT
L_11790: CNVTU[1] = UN[1]
CNVTU[2] = 2
CHBASE = 0
If S3[8] = -3 Let CHBASE = (S3[0] / S7[2]) Else Let CHBASE = S3[0]
If UN[1] > 0 If S2[1] Let CNVTA = (L5[2] / S2[1]) Else Let CNVTA = L5[2]
Gosub L_20000
UWORK[3] = AMOUNT
If Not(S2[1]) Let S2[1] = 1
If CHBASE Let CNVTA = CHBASE / S2[1] Else Let CNVTA = 0
If S3[8] = -1 If UN[1] = -1 If CHBASE Let CNVTA = CHBASE
If CHBASE And UN[1] < 0 Let CNVTA = CHBASE
Gosub L_20000 \ UWORK[6] = AMOUNT
CNVTU[1] = UN[2]
CNVTA = L5[1]
Gosub L_20000
UWORK[4] = AMOUNT
If Not(L6[1]) Let UWORK[11] = 0 \ Goto L_11880
CNVTU[1] = UN[1];CNVTU[2] = 2;CNVTA = L6[1]
Gosub L_20000
UWORK[11] = AMOUNT ! "discount
L_11880: CNVTU[1] = UN[1];CNVTU[2] = 2;CNVTA = S3[15]
Gosub L_20000 \ UWORK[8] = AMOUNT ! "addon
CNVTU[0] = 0;CNVTU[1] = UN[1];CNVTU[2] = 2
If UN[1] > 0 And S2[1] Let CNVTA = ((L5[2] - L6[1]) / S2[1]) Else Let CNVTA = L5[2] - L6[1]
If S3[8] = -3 Let CHBASE = (S3[0] / S7[2]) Else Let CHBASE = S3[0]
If UN[1] > 0 And S2[1] Let CNVTA = CNVTA + (CHBASE / S2[1]) Else Let CNVTA = CNVTA + CHBASE
CNVTA = CNVTA - (CNVTA * (L6[0] / 100))
IF S7[8]>0 LET CNVTA = CNVTA + (CNVTA * (S7[8] / 100)) ! % up
IF S7[8]<0 ! $ UPCHARGE
	LET CNVTA=CNVTA+(0-S7[8]) ! "up charge $ (is negative)
ENDIF
Gosub L_20000 \ UWORK[15] = AMOUNT ! "net unit price in pricing unit
IF S7[8]<0 ! $ UPCHARGE
	LET CNVTU[0]=0;CNVTU[1]=UN[1];CNVTU[2]=2;CNVTA=ABS(S7[8])
	GOSUB L_20000 \ LET UWORK[14]=AMOUNT
ENDIF
Return 
L_12000: Rem CALC   L PRICES FROM TABLE FOR PRODUCT RECORD
If FIELD < 1 Or FIELD > 6 Return ! "invalid
If C4[2] <> 1 Return ! "not matrix
If Not(C4[3]) Return ! "no mark up table
Mat Read #CHANNEL_[3],C4[3],18;PM5;
BASEC = C4[4] ! "base cost
If PM5[FIELD - 1,4] = 1 Let BASEC = B[10]
If PM5[FIELD - 1,4] = 2 Let BASEC = B[8]
If PM5[FIELD - 1,4] = 3 Let BASEC = PF_LOAD2
If PM5[FIELD - 1,4] = 4 Let BASEC = B[21]
If PM5[FIELD - 1,4] = 5 Let BASEC = PRPARC[2]
Gosub L_19000
A[19 + FIELD] = X4 ! "set list prices
Return 
L_12200: Rem CALC  L PRICES FROM TABLE FOR WHSE RECORD
If FIELD < 1 Or FIELD > 6 Return ! "invalid
If C4[2] <> 1 Return ! "not matrix
If Not(C4[3]) Return ! "no mark up table
If P9$[32,32] = "N" Return 
Mat Read #CHANNEL_[3],C4[3],18;PM5;
If W3[18] Let BASEC = W3[18] Else Let BASEC = C4[4] ! "whse base cost
If PM5[FIELD - 1,4] = 1 ! "last cost
  If W3[16] Let BASEC = W3[16] Else Let BASEC = B[10]
End If 
If PM5[FIELD - 1,4] = 2 ! "load
  If W3[17] Let BASEC = W3[17] Else Let BASEC = B[8]
End If 
If PM5[FIELD - 1,4] = 3 ! "load2
  If W3[14] Let BASEC = W3[14] Else Let BASEC = B[10]
End If 
If PM5[FIELD - 1,4] = 4 ! "aver.
  If W3[15] Let BASEC = W3[15] Else Let BASEC = B[21]
End If 
If PM5[FIELD - 1,4] = 5 ! "net po
  If WHMISC[2] Let BASEC = WHMISC[2] Else Let BASEC = PRPARC[2]
End If 
Gosub L_19000
W3[18 + FIELD] = X4 ! "set whse list prices
Return 
L_13000: Rem LOAD SELLING QTY, PRICE,COST IN TO L7 IN BASE UNITS
CNVTU[0] = UN[0]
CNVTU[1] = 0
CNVTU[2] = 1
For X = 0 To 2
  If S2[1] Let CNVTA = UWORK[X] / S2[1] Else Let CNVTA = UWORK[X]
  If X = 2 If UWORK[2] = UWORK[0] Let AMOUNT = S7[2] \ Goto L_13070
  Gosub L_20000
L_13070: S7[X + 2] = AMOUNT
Next X
If S2[1] Let S7[5] = FNU(S7[4] / S2[1])
If Not(S2[1]) Let S7[5] = S7[4]
Return 
L_13120: CNVTU[0] = UN[1]
CNVTU[1] = 0
CNVTU[2] = 2
If Not(UWORK[3]) Goto L_13155
If UN[1] > 0 If S2[1] Let CNVTA = UWORK[3] * S2[1] Else Let CNVTA = UWORK[3]
Gosub L_20000 \ L5[2] = AMOUNT
L_13155: If UN[1] > 0 If S2[1] Let CNVTA = UWORK[15] * S2[1] Else Let CNVTA = UWORK[15]
Gosub L_20000 \ OLM[3] = AMOUNT ! "net base price
If Not(UWORK[4]) Goto L_13210
CNVTU[0] = UN[2]
CNVTA = UWORK[4]
Gosub L_20000
L5[1] = AMOUNT
L_13210: CNVTU[0] = UN[1];CNVTU[2] = 2;CNVTA = UWORK[8]
Gosub L_20000 \ S3[15] = AMOUNT ! "addon
Return 
L_13300: Rem "========= extension calculations
If S3[8] = -3 Let CHBASE = (S3[0] / S7[2]) Else Let CHBASE = S3[0] ! "cut chg
Gosub L_3465 ! "ext weight
S3[13] = S7[2] * L5[1] ! "ext cost ordered
OLM[0] = FNR(S7[2] * S3[15]) ! "extended freight add-on ordered
CNVTU[0] = UN[1];CNVTU[1] = 0;CNVTU[2] = 2;CNVTA = UWORK[15] \ Gosub L_20000
If UN[1] > 0 And S2[1] Let AMOUNT = AMOUNT * S2[1]
L5[0] = FNR(S7[2] * AMOUNT) ! "extended amount ordered
If H5[7] <> 4 And H5[7] <> 15 Let L5[3] = FNR(S7[4] * AMOUNT) Else Let L5[3] = FNR(S3[7] * AMOUNT) ! "extended amount shipped
If H5[7] = 4 Or H5[7] = 15 Let OLM[1] = FNR(S3[7] * S3[15]) Else Let OLM[1] = FNR(S7[4] * S3[15])
If UN[1] = -2 Let L5[0] = L5[2];L5[3] = L5[2] ! "lot price
If H5[7] <> 4 Let S3[12] = FNR((S7[4] * L5[1]) + S3[10]) ! "ext cost ship not bill/hold
If H5[7] = 4 Let S3[12] = FNR((S3[7] * L5[1]) + S3[10]) ! "ext cost ship bill/hold
If S3[8] = -3 Let S3[9] = S3[0] Else Let S3[9] = S3[0] * S7[4]
If S3[11] = -3 Let S3[10] = S3[1] Else Let S3[10] = FNR(S3[1] * S7[4])
Return 
L_14000: Rem GET TOTAL ORDER WEIGHT AND REDO LINES
! Print @0,22;'CE';"Please wait... re-calculating line items...";
TORDWT = 0
If P60$[12,12] = "Y" Gosub L_14400 ! "open temp work file
If Not(H5[12]) Or Not(ADDUM) Goto L_14100 ! "no freight table setup
I1$ = " ",I1$
I1$ = N0 Using "######"
L_14030: Search #ch_rol,3,1;I1$,V1,E \ If E And E <> 2 Gosub ERR_SEARCH
If E = 2 Goto L_14100 ! "done
X2 = I1$[1,6]
If X2 <> N0 Goto L_14100 ! "done
R1[3] = V1
Gosub L_7100 ! "read line
If (H5[7] = 21 Or H5[7] = 22) And L3[2] = 0 Goto L_14030 ! "bypass repair info
If S2[0] = 3 Or L3 Goto L_14030 ! "skip this item
If Not(A[5]) Let A[5] = 1
If A[5] Let TORDWT = TORDWT + ((L6[4] * S7[2]) / A[5]) ! "extended weight ordered
Goto L_14030
L_14100: Rem NOW ADD FREIGHT MARKUP TO LINES
TORDWT = FNU(TORDWT) \ If TORDWT < 1 Let TORDWT = 1 ! "min wt
If Not(H5[12]) And P60$[12,12] <> "Y" Goto L_14330 ! "no markup table used
I1$ = " ",I1$
I1$ = N0 Using "######"
L_14130: Search #ch_rol,3,1;I1$,V1,E \ If E And E <> 2 Gosub ERR_SEARCH
If E = 2 Goto L_14330 ! "done
X2 = I1$[1,6]
If X2 <> N0 Goto L_14330 ! "done
R1[3] = V1
Gosub L_7100 ! "read line
S3[15] = 0
If (H5[7] = 21 Or H5[7] = 22) And L3[2] = 0 Goto L_14130 ! "bypass repair info
If S2[0] = 3 Or L3 Goto L_14130 ! "skip this line
If L9[0] < 0 Or L9[0] = 10 Goto L_14302 ! "price editted line - don't add-on
AMOUNT = 0 \ If Not(H5[12]) Or Not(ADDUM) Goto L_14295
For X = 0 To 7 ! "check valid u/m
  If ADDUM = PFU1[X] Goto L_14230 ! "good unit
Next X
Goto L_14295 ! "bad unit code this product
L_14230: For X = 6 To 1 Step -1
  If Not(WT[X - 1]) Goto L_14260 ! "no weight/go on
  If TORDWT >= WT[X - 1] Goto L_14270 ! "got one
L_14260: Next X
Goto L_14295 ! "no add-on
L_14270: CNVTA = ADDON[H5[12] - 1,X - 1] \ If Not(CNVTA) Goto L_14295 ! "no add-on
CNVTU[0] = ADDUM;CNVTU[1] = 0;CNVTU[2] = 2
Gosub L_20000
S3[15] = AMOUNT ! "addon in base
L_14295: L5[2] = S7[6] ! "revert back to original unit price
L5[2] = L5[2] + S3[15] ! "add markup (in base) to unit price
L_14302: Gosub L_4500 ! "get commodity
If P60$[12,12] = "Y" Gosub L_14600 ! "amalgamation stack
Gosub L_5120 ! "re-extend line
Gosub L_7880
Goto L_14130 ! "on to next
L_14330: If P60$[12,12] = "Y" Gosub L_14800 \ Gosub L_14500
! Print @0,22;'CE';
Return 
L_14400: Rem OPEN TEMP FILE FOR AMALGAMATION
I1$ = " ",I1$
I1$ = "[1:16] 6/AMTEMP";I1$[Len(I1$) + 1] = Spc(6) Using "&&&&","!"
ch_amtmp=findchannel()
Build #ch_amtmp,I1$
QTOT = 0;L6[0] = 0;L6[1] = 0;QDOL = 0
For X2 = 1 To 999
  Write #ch_amtmp,X2,0;QTOT;
  Write #ch_amtmp,X2,6;L6[0];
  Write #ch_amtmp,X2,10;L6[1];
  Write #ch_amtmp,X2,14;QDOL;
Next X2
Return 
L_14500: Rem KILL TEMP FILE
Close #ch_amtmp
I1$ = " ",I1$;I1$ = "6/AMTEMP";I1$[Len(I1$) + 1] = Spc(6) Using "&&&&"
Kill I1$
Return 
L_14600: Rem AMALGAMATION STACK
If L9[0] < 0 Or L9[0] = 10 Goto L_14680 ! "editted price
L9TMP = L9[0];L6[3] = 0 ! "break type indicator
Gosub L_25000 ! "check for special price
If X3 = -2 Let X3 = 0;L9[0] = 0
If Not(L9[0]) Let L9[0] = L9TMP ! "no sp
If X3 > 0 Let L5[2] = X3;L6[3] = SPBRK[0] + (SPBRK[1] / 10) \ Goto L_14680
Read #ch_prod,L4,244;B[22]; ! whse pricing??
IF P9$[32,32]="Y"
	IF W9
		mat read #ch_prodwh,w9,384;whparc;
		IF WHPARC[0] LET B[22]=WHPARC[0]
	ENDIF
ENDIF
If P9$[10,10] = "Y" And Not(P0) Let L6[3] = .3 ! "no accum/no break
If P9$[10,10] = "Y" And P0 Let L6[3] = B[22] + .2 ! "accum/break
If P9$[10,10] <> "Y" Let L6[3] = .3
L_14680: If Not(L6[3]) Let L6[3] = .3 ! "no break at all
If Not(Int(L6[3])) Goto L_14760 ! "bypass
R33 = Int(L6[3]);CT = Int(Fra(L6[3]) * 10)
If CT <> 1 And CT <> 2 Goto L_14760 ! "no accumulation
CNVTU[0] = UN[0];CNVTU[1] = PFU1[8];CNVTU[2] = 1;CNVTA = UWORK[0]
Gosub L_20000 \ UWORK[5] = AMOUNT ! "quantity ordered in stock units
L6[0] = 0;L6[1] = 0;UWORK[11] = 0 \ Gosub L_3950 ! "extend b4 link
Gosub L_15100 ! "get break links/accumulate
L_14760: Return 
L_14800: Rem NOW GET QUANTITY BREAKS
For R33 = 1 To 999
  Read #ch_amtmp,R33,0;QTOT;
  Read #ch_amtmp,R33,14;QDOL;
  If Not(QTOT) And Not(QDOL) Goto L_14870 ! "no break
  Gosub L_4000 ! "get break
  Write #ch_amtmp,R33,6;L6[0];
  Write #ch_amtmp,R33,10;L6[1];
L_14870: Next R33
I1$ = " ",I1$
I1$ = N0 Using "######"
L_14900: Search #ch_rol,3,1;I1$,V1,E \ If E And E <> 2 Gosub ERR_SEARCH
If E = 2 Goto L_15080 ! "done
X2 = I1$[1,6]
If X2 <> N0 Goto L_15080 ! "done
R1[3] = V1
Gosub L_7100 ! "get line
If L9[0] = 10 Goto L_15065 ! "don't redo editted line
L6[0] = 0;L6[1] = 0
If L9[0] < 0 Goto L_15060 ! "don't redo editted line
If (H5[7] = 21 Or H5[7] = 22) And L3[2] = 0 Goto L_14900 ! "bypass repair info
If L3 Or S2[0] = 3 Goto L_15065 ! "skip line
If Not(Int(L6[3])) Goto L_15060 ! "no break
If Int(Fra(L6[3]) * 10) = 1 Or Int(Fra(L6[3]) * 10) = 3 Goto L_15060 ! "no break
R33 = Int(L6[3]) ! "break table #
Read #ch_amtmp,R33,6;L6[0];
Read #ch_amtmp,R33,10;L6[1];
If Not(L6[1]) Goto L_15050
CNVTU[0] = PFU1[8];CNVTU[1] = 0;CNVTU[2] = 2;CNVTA = L6[1]
Gosub L_20000 \ L6[1] = AMOUNT \ If L6[1] > L5[2] Let L6[1] = L5[2] ! "no negative
L_15050: If L6[0] Or L6[1] Let L9[0] = 9;OLM[2] = 0 ! "set last price flag
L_15060: Gosub L_5120 ! "recalc line
L_15065: Gosub L_7880
Goto L_14900
L_15080: Return 
L_15100: Rem GET BREAK LINKS
For CT = 1 To Chf(CHANNEL_[1]) - 1
  Mat Read #CHANNEL_[1],CT,0;LINK;
  For CT1 = 0 To 9
    If R33 = LINK[CT1] Goto L_15200 ! "have a link
  Next CT1
Next CT
For CT1 = 0 To 9 \ LINK[CT1] = 0 \ Next CT1 ! "no links
LINK[0] = R33 ! "default for one
L_15200: For CT1 = 0 To 9
  If Not(LINK[CT1]) Goto L_15260 ! "done
  Read #ch_amtmp,LINK[CT1],0;QTOT
  QTOT = QTOT + UWORK[5]
  Write #ch_amtmp,LINK[CT1],0;QTOT;
  Read #ch_amtmp,LINK[CT1],14;QDOL
  QDOL = QDOL + L5[0]
  Write #ch_amtmp,LINK[CT1],14;QDOL;
Next CT1
L_15260: Return 
L_19000: Rem MATRIX PRICING, RETURNS X4
Call "MX671BRK5.dl4",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG,C4[],FIELD,BASEC,E$,Rstr$
If FLAG Let E = FLAG \ Gosub ERR_SEARCH
X4 = CNVTA
Return 
L_20000: Rem   MXPRCONV    PRODUCT FILE UNITS CONVERT UNIBASIC 4<
Def FNN(H) = Int(Abs(H) * 10 ^ Q0[1] + .5) * 10 ^ - Q0[1] * Sgn(H) ! "normal round
Def FNT(H) = Int(Abs(H) * 10 ^ Q0[1]) * 10 ^ - Q0[1] * Sgn(H) ! "truncate to lower
Def FNV(H) = Int(Abs(H) * 10 ^ Q0[1] + .9999999) * 10 ^ - Q0[1] * Sgn(H) ! "vound up
BUNIT = 0
If CNVTU[2] <> 5 Goto L_20170 ! not right type
BUNIT = 1 ! do not round flag
CNVTU[2] = 1 ! switch back to qty
Goto L_20180
L_20170: BUNIT = 0
L_20180: Rem
If SC = 0 Let SC = 10
If SR = 0 Let SR = 8
Mat Read #1,19,50;P9$;
On CNVTU[2] + 1 Goto L_20250,L_20350,L_20350,L_20640
Gosub ERR_SEARCH
L_20250: Rem CHECK IF VALID CONVERSION
For X5[1] = 0 To 1
  If CNVTU[X5[1]] = 0 Goto L_20330
  If CNVTU[X5[1]] = -1 Or CNVTU[X5[1]] = -3 Goto L_20330
  For X5[2] = 0 To 7
    If CNVTU[X5[1]] = PFU1[X5[2]] Goto L_20330
  Next X5[2]
  FLAG = 1 \ Goto L_20650 ! INVALID CONVERSION
L_20330: Next X5[1]
FLAG = 0 \ Goto L_20650 ! OKAY
L_20350: Rem CONVERT COST/PRICE/QTY
AMOUNT = CNVTA
For X5[1] = 0 To 1
  CMODE = 1 \ If X5[1] Let CMODE = -1
  If CNVTU[X5[1]] = 0 Goto L_20530 ! ALREADY BASE UNITS
  If CNVTU[X5[1]] = -1 Or CNVTU[X5[1]] = -3 Goto L_20460
  For CUNIT = 0 To 7
    If PFU1[CUNIT] = CNVTU[X5[1]] Goto L_20450
  Next CUNIT
  FLAG = 0 \ Goto L_20650 ! INVALID UNIT
L_20450: If CUNIT = 0 Goto L_20530 ! ALREADY BASE
L_20460: If CNVTU[2] = 2 Let CMODE = - CMODE
  If CNVTU[X5[1]] = -1 ! " <>-1 GOTO L_20510: ! ITS CWT
    If A[5] If CMODE < 0 Let AMOUNT = (AMOUNT * (A[6] / A[5])) / 100
    If A[6] If A[5] If CMODE > 0 Let AMOUNT = AMOUNT * 100 / (A[6] / A[5])
  Else 
    If CNVTU[X5[1]] = -3 ! "Catch Weight Item
      If A[5] If CMODE < 0 Let AMOUNT = (AMOUNT * (A[6] / A[5]))
      If A[6] If A[5] If CMODE > 0 Let AMOUNT = AMOUNT / (A[6] / A[5])
    Else 
      If CMODE > 0 Let AMOUNT = AMOUNT * PFU2[CUNIT - 1]
      If PFU2[CUNIT - 1] If CMODE < 0 Let AMOUNT = AMOUNT / PFU2[CUNIT - 1]
    End If 
  End If 
L_20530: Next X5[1]
If CNVTU[2] <> 1 Goto L_20580 ! "not doing qty's
If BUNIT Goto L_20580 !! "not rounding units
If CNVTU[1] If CNVTU[1] <> PFU1[0] Let AMOUNT = FNR(AMOUNT) ! "round qty if not going to base units
If Fra(AMOUNT) If Not(CNVTU[1]) Or CNVTU[1] = PFU1[0] Let AMOUNT = FNU(AMOUNT) ! "be sure base is not a fraction
L_20580: If CNVTU[2] <> 2 Goto L_20630 ! "not doing costs/prices
If Not(CNVTU[1]) Goto L_20630 ! "going to base
If P9$[42,42] = "N" Let AMOUNT = FNN(AMOUNT) ! "normal round
If P9$[42,42] = "T" Let AMOUNT = FNT(AMOUNT) ! "truncate
If P9$[42,42] = "U" Let AMOUNT = FNV(AMOUNT) ! "vound up
L_20630: FLAG = 0 \ Goto L_20650
L_20640: Rem
L_20650: Rem RETURN FROM MODES 0-2
Return 
L_23000: Rem CHECK FOR REBATE
!CH_PROD = 3;CH_PRWH = 30
!CH_VENDTAG = 36;CH_RCONTRACTH = 34;CH_REBATEDTL = 33
RBCOST = 0 \ RBSLCOST = 0
!If Err 0 Rem
!Close #CH_REBATEDTL
!!Close #CH_RCONTRACTH
!Close #CH_VENDTAG
If Err 0 Gosub ERR_TRAP
Read #1,88,320;F1$;
CH_REBATEDTL=Findchannel()
Ropen #CH_REBATEDTL,F1$ ! REBATE DETAIL
Read #1,88,304;F1$;
CH_RCONTRACTH=Findchannel()
Ropen #CH_RCONTRACTH,F1$ ! REBATE HEADER
Read #1,88,1120;F1$;
CH_VENDTAG=Findchannel()
Ropen #CH_VENDTAG,F1$ ! VENDTAG
Mat REBATE_ARGS = Zer
REBATE_ARGS[1,0] = CH_PROD
REBATE_ARGS[2,0] = CH_PRODWH
REBATE_ARGS[3,0] = CH_VENDTAG
REBATE_ARGS[4,0] = CH_RCONTRACTH
REBATE_ARGS[5,0] = CH_REBATEDTL
If Not(L3[0]) Let REBATE_ARGS[1,1] = L4 Else Let REBATE_ARGS[1,1] = 0 !"product record #
REBATE_ARGS[2,1] = W9 !"product whse record #
REBATE_ARGS[1,2] = WHSE
REBATE_ARGS[2,2] = H0[4]
REBATE_ARGS[3,2] = 0
REBATE_ARGS[4,2] = H0[9]
REBATE_ARGS[5,2] = P3
! Call "rebates",REBATE_ARGS[],L2$[1,12],STATUS
call rebates(e$,REBATE_ARGS[],L2$[1,12],status)
If Not(STATUS) !"indicates call was successful in finding rebate
  RBCOST = REBATE_ARGS[1,3]
  RBSLCOST = REBATE_ARGS[2,3]
  REBATE_TYPE = REBATE_ARGS[7,3]
  REC_REBATEDTL = REBATE_ARGS[5,1]
  Gosub L_24000 !"read in rebatedtl record
  LCO[1] = RB1[0]
  If COST2RBT !"use lower of default 2nd line cost and rebate cost
    If RBCOST And RBCOST < CST Let CST = RBCOST
  End If 
  If COST2 = 6 Let CST = RBCOST
  If RBSLCOST And (Not(L5[1]) Or RBSLCOST < L5[1])
    L5[1] = RBSLCOST
    LCO[0] = 10
  End If 
Else 
  RBCOST = 0;RBSLCOST = 0;LCO[1] = 0
End If 
Close #CH_VENDTAG
Close #CH_REBATEDTL
Close #CH_RCONTRACTH
Return 
L_24000: Rem read in rebate detail record
Mat Read #CH_REBATEDTL,REC_REBATEDTL,12;RB1
Mat Read #CH_REBATEDTL,REC_REBATEDTL,36;RBUM
Mat Read #CH_REBATEDTL,REC_REBATEDTL,40;RB
Mat Read #CH_REBATEDTL,REC_REBATEDTL,118;RBWH
Mat Read #CH_REBATEDTL,REC_REBATEDTL,126;RBL1
Mat Read #CH_REBATEDTL,REC_REBATEDTL,138;RB5
Return 
L_24800: Rem Valid unit for product (special price)?
For X = 0 To 7
  If UnitV = PFU1[X] Return 1 ! "unit o.k.
Next X
Return ! "bad unit code
L_24900: Rem ===== Check for cust/contract ======
I$ = " ",I$;I$[1,6] = H0[4] Using "######"
If H6[8] Let I$[7] = (H6[8] - 1) Using "C#####" ! "optional single contract/order
L_24920: Search #ch_pch,3,2;I$,R[25],E \ If E Return 
X2 = I$[1,6] \ If X2 <> H0[4] Return ! "no more for cust
If H6[8] Let X2 = I$[8,12] \ If X2 <> H6[8] Return ! "no single contr match
K9$[1,6] = I$[7,12] ! "substitute contract for customer
Search #ch_spc,2,1;K9$,R[28],E
If Not(E) Gosub L_25410 \ If X3 Goto L_24980
Goto L_24920 ! "try another contract for customer
L_24980: OLM[2] = I$[8,12] ! "retain contract #
Return 
L_25000: Rem Special Pricing (rek - 01/21/93 ~ 03/29/93) / STANDARD VERSION
SPSLCOST = 0
Gosub L_23000
X3 = 0 ! "clear variables
PROD = 99;L9[0] = 2 ! "signal single product search
K9$ = " ",K9$;K9$[1,6] = H0[4] Using "######";K9$[7,18] = L2$[1,12];K9$[19] = ""
Search #ch_spc,2,1;K9$,R[28],E \ If E > 1 Gosub ERR_SEARCH ! "single customer/product
If Not(E) Gosub L_25410 \ If X3 Goto L_29980 ! "check for price/exit if one
Gosub L_24900 \ If X3 Goto L_29980 ! "chk contract/exit if one
K9$[1,6] = "999999";L9[0] = 3 ! "single product promotion
Search #ch_spc,2,1;K9$,R[28],E \ If E > 1 Gosub ERR_SEARCH
If Not(E) Gosub L_25410 \ If X3 Goto L_29980
PROD = 0;L9[0] = 15 ! "customer/cost grp price
K9$ = " ",K9$;K9$[1,6] = H0[4] Using "######";K9$[7,7] = "-"
K9$[8,18] = A1$[116,126];K9$[19] = ""
Search #ch_spc,2,1;K9$,R[28],E \ If E > 1 Gosub ERR_SEARCH
If Not(E) Gosub L_25410 \ If X3 Goto L_29980
Gosub L_24900 \ If X3 Goto L_29980 ! "chk contract/exit if one
K9$[1,6] = "999999";L9[0] = 16 ! "cost grp promotion
Search #ch_spc,2,1;K9$,R[28],E \ If E > 1 Gosub ERR_SEARCH
If Not(E) Gosub L_25410 \ If X3 Goto L_29980
PROD = 0;L9[0] = 4 ! "customer/commodity price
K9$ = " ",K9$;K9$[1,6] = H0[4] Using "######";K9$[7,7] = "*"
K9$[8,11] = L2$[17,20];K9$[19] = ""
Search #ch_spc,2,1;K9$,R[28],E \ If E > 1 Gosub ERR_SEARCH
If Not(E) Gosub L_25410 \ If X3 Goto L_29980
Gosub L_24900 \ If X3 Goto L_29980 ! "chk contract/exit if one
K9$[1,6] = "999999";L9[0] = 7 ! "commodity promotion
Search #ch_spc,2,1;K9$,R[28],E \ If E > 1 Gosub ERR_SEARCH
If Not(E) Gosub L_25410 \ If X3 Goto L_29980
L9[0] = 12 ! "customer/size price
UnitV = PFU1[19] \ Gosub L_10700 ! "get product size u/m
K9$ = " ",K9$;K9$[1,6] = H0[4] Using "######";K9$[7,7] = "&"
K9$[8,11] = UNIT$[1,4];K9$[12,15] = UNITV Using "####";K9$[19] = ""
Search #ch_spc,2,1;K9$,R[28],E \ If E > 1 Gosub ERR_SEARCH
If Not(E) Gosub L_25410 \ If X3 Goto L_29980
Gosub L_24900 \ If X3 Goto L_29980 ! "chk contract/exit if one
K9$[1,6] = "999999";L9[0] = 11 ! "size promotion
Search #ch_spc,2,1;K9$,R[28],E \ If E > 1 Gosub ERR_SEARCH
If Not(E) Gosub L_25410 \ If X3 Goto L_29980
L9[0] = 6 ! "customer/all product
K9$ = " ",K9$;K9$[1,6] = H0[4] Using "######";K9$[7,7] = "#";K9$[19] = ""
Search #ch_spc,2,1;K9$,R[28],E \ If E > 1 Gosub ERR_SEARCH
If Not(E) Gosub L_25410 \ If X3 Goto L_29980
Gosub L_24900 \ If X3 Goto L_29980 ! "chk contract/exit if one
K9$[1,6] = "999999";L9[0] = 8 ! "all product promotion
Search #ch_spc,2,1;K9$,R[28],E \ If E > 1 Gosub ERR_SEARCH
If Not(E) Gosub L_25410 \ If X3 Goto L_29980
C3[0] = 0;C3[1] = 0;C3[2] = 0
X3 = 0;L9[0] = 0 \ Goto L_29980 ! "no special price/go back
L_25410: Rem Now get special price
Mat Read #ch_spc,R[28],12;SPC1;
Mat Read #ch_spc,R[28],36;SPCUM;
Mat Read #ch_spc,R[28],40;C3;
Mat Read #ch_spc,R[28],46;SPC4;
Mat Read #ch_spc,R[28],126;SPBRK; ! DEFINED BRK&TBL
Mat Read #ch_spc,R[28],138;SPC5;
Read #ch_spc,R[28],118;SPWH;
Read #ch_spc,R[28],134;SPCOM;
Mat Read #ch_spc,R[28],168;SPC6; ! this & below - 9 add'l prices
Mat Read #ch_spc,R[28],178;APTYPE;
Mat Read #ch_spc,R[28],196;ABTYPE;
Mat Read #ch_spc,R[28],214;AMTYPE;
Mat Read #ch_spc,R[28],232;APFACT;
Mat Read #ch_spc,R[28],286;AMQTY;
X2 = SPC1[2] \ Gosub L_7820 \ X2 = 0
JWDATE = X2
If JWDATE > JODATE Goto L_29970 ! "sp hasn't started yet
X2 = SPC1[4] \ Gosub L_7820 \ X2 = 0
JWDATE = X2
If SPC1[4] And JWDATE < JODATE Goto L_29970 ! "expired
If P9$[32,32] = "Y" And SPWH And SPWH <> WHSE Goto L_29970 ! "wrong warehouse
If (C3[0] = 4 Or C3[0] = 5) And C4[2] <> 2 Goto L_29970 ! "no bracket for matrix
If SPC6[1] <> 1 And SPC6[1] <> 2 Let SPC6[1] = 1 ! default = qty min
MLVL = 0 ! no multiple levels yet
For X = 0 To 8 \ If APTYPE[X] Let MLVL = 1 \ Next X ! has a type (use prctype as decider)
If MLVL ! has levels - find right one - if not use main (orig)
  Gosub MLVL_SPR
End If 
If SPC6[1] <> 1 And SPC6[1] <> 2 Let SPC6[1] = 1 ! default = qty min
If C3[2] Let UnitV = C3[2] \ Gosub L_24800 \ C3[2] = 0 ! "valid unit for product?
If Not(PROD) Or Not(C3[2]) Let AMOUNT = UWORK[0] \ Goto L_25580
CNVTU[0] = UN[0];CNVTU[1] = C3[2];CNVTU[2] = 1;CNVTA = UWORK[0]
Gosub L_20000
L_25580: Rem chk mins
If SPC6[1] = 1 And SPC4[0] > 0 And AMOUNT < SPC4[0] Goto L_29970 ! "haven't met min quantity
If SPC6[1] = 2 And S3[4] < SPC4[0] Goto L_29970 ! "didn't meet min weight
X3 = 0
If SPC5[3] = 3 And SPC5[1] Let SPSLCOST = SPC5[1] ! "salesman cost
If Not(PROD) If SPC5[3] = 3 And SPSLCOST Let CNVTA = SPSLCOST;CNVTU[0] = UN[2];CNVTU[1] = 0;CNVTU[2] = 2 \ Gosub L_20000 \ SPSLCOST = AMOUNT
If SPC5[4] = 1 Let BASEC = C4[4]
If SPC5[4] = 1 If P9$[32,32] = "Y" Let BASEC = W3[18]
If SPC5[4] = 2 Let BASEC = B[8]
If SPC5[4] = 2 If P9$[32,32] = "Y" Let BASEC = W3[17]
If SPC5[4] = 3 Let BASEC = B[10]
If SPC5[4] = 3 If P9$[32,32] = "Y" Let BASEC = W3[16]
If SPC5[4] = 4 Let BASEC = RBCOST
If SPC5[4] = 5 Let BASEC = PF_LOAD2
If SPC5[4] = 5 If P9$[32,32] = "Y" Let BASEC = W3[14]
If SPC5[4] = 6 Let BASEC = PRPARC[2]
If SPC5[4] = 6 If P9$[32,32] = "Y" Let BASEC = WHMISC[2]
If SPC5[3] = 1 If BASEC Let SPSLCOST = (BASEC * ((100 + SPC5[1]) / 100)) ! "markup/down
AMOUNT = 0
If SPC5[3] = 2 If BASEC Let CNVTU[0] = 0;CNVTU[1] = SPCUM[1];CNVTU[2] = 2;CNVTA = BASEC \ Gosub L_20000
If SPC5[3] = 2 If AMOUNT Let CNVTA = (AMOUNT + SPC5[1]);CNVTU[0] = SPCUM[1];CNVTU[1] = 0 \ Gosub L_20000
If SPC5[3] = 2 If AMOUNT Let SPSLCOST = AMOUNT
If SPSLCOST And (Not(L5[1]) Or SPSLCOST < L5[1]) Let L5[1] = SPSLCOST
If RBSLCOST If Not(SPSLCOST) Let SPSLCOST = RBSLCOST
If COST2RBT If SPC5[2] And SPC5[2] < CST Let CST = SPC5[2] !"lower of special cost and default cost
OLM[4] = SPCOM ! "commission percent (override all others)
X3 = SPC5[0] ! "price/markup
UnitV = SPCUM[0] \ Gosub L_24800 \ SPCUM[0] = UN[1] ! "valid price unit
UnitV = SPCUM[1] \ Gosub L_24800 \ SPCUM[1] = UN[2] ! "valid cost unit?
If PROD Let UN[1] = SPCUM[0];UN[2] = SPCUM[1] ! "price/cost u/m
If H5[7] = 8 Or H5[7] = 16 Let L5[1] = 0 ! "consignment/don't hold cost
If Not(PROD) And C3[0] = 3 ! "fixed price for commdy, allprod or size sp's
  CNVTU[0] = UN[1];CNVTU[1] = 0;CNVTU[2] = 2;CNVTA = X3
  Gosub L_20000 \ X3 = AMOUNT ! "base price
End If 
If Not(SPC5[0]) And (C3[0] = 4 Or C3[0] = 5) Let X3 = -1 \ Goto L_29970 ! "fixed bracket or jump
If C3[0] = 6 Let X3 = -2 \ Goto L_29970 ! "break level jump
If C3[0] = 1 Or C3[0] = 2 Gosub L_4408 ! "get base type for markup/down or gpm
If C3[0] = 3 Goto L_25890 ! "fixed price
If SPC5[0] And (C3[0] = 4 Or C3[0] = 5) Gosub L_3765 \ BASEC = X3;X3 = (BASEC * ((100 + SPC5[0]) / 100))
If C3[0] = 1 Let X3 = (BASEC * ((100 + SPC5[0]) / 100)) ! "markup/down
If C3[0] = 2 Let X3 = (BASEC / ((100 - SPC5[0]) / 100)) ! "gross margin
L_25890: If X3
  If C3[0] = 3 And (L9[0] = 2 Or L9[0] = 4 Or L9[0] = 6 Or L9[0] = 12 Or L9[0] = 15)
    L9[0] = 13 ! "flag as fixed price special in last price
  End If 
Else 
  SPC5[0] = 0;SPC5[1] = 0 ! "flag as special price or not
End If 
L_29970: Return ! "back to key logic
L_29980: Rem Exit from special pricing
Return 
MLVL_SPR: Rem multi level - return mlvl 1-10 (1 default)
If C3[2] ! qty um check
  UnitV = C3[2]
  If Not(UNITV) Let C3[2] = 0 ! "bad unit
End If 
AMOUNT = UWORK[0] ! base
If PROD And C3[2]
  CNVTU[0] = UN[0];CNVTU[1] = C3[2];CNVTU[2] = 1;CNVTA = UWORK[0] ! "convert qty
  Gosub L_20000 ! "get quantity in AMOUNT
End If 
If Not(PROD) And Not(C3[2])
  CNVTU[0] = UN[0];CNVTU[1] = PFU1[9];CNVTU[2] = 1;CNVTA = UWORK[0]
  Gosub L_20000
End If 
ORDQTY = AMOUNT ! for check of min=qty, s3[4]=weight
X2[1] = 0;X2[2] = 0;X2[3] = 0;X2[4] = 0 ! qty/wgt >=
If SPC6[1] = 1 ! main (price 1) - set the bar
  If ORDQTY >= SPC4[0] And X2[1] <= SPC4[0] Let X2[1] = SPC4[0];MLVL = 1
End If 
If SPC6[1] = 2 ! main (price 1) - set the bar
  If S3[4] >= SPC4[0] And X2[2] <= SPC4[0] Let X2[2] = SPC4[0];MLVL = 1
End If 
For X = 0 To 8
  If APTYPE[X] > 0 And APTYPE[X] < 9 ! prctype determines used
    If AMTYPE[X] <> 2 Let AMTYPE[X] = 1 ! default = qty
    If AMTYPE[X] = 1 ! qty
      If ORDQTY >= AMQTY[X] And X2[1] <= AMQTY[X] Let X2[1] = AMQTY[X];X2[3] = X + 2
    End If 
    If AMTYPE[X] = 2 ! wgt
      If S3[4] >= AMQTY[X] And X2[2] <= AMQTY[X] Let X2[2] = AMQTY[X];X2[4] = X + 2
    End If 
  End If 
Next X
If X2[3] = 0 And X2[4] = 0 Return ! no match of any other levels - use 1
If X2[1] = ORDQTY And X2[2] = S3[4] ! tie goes to wgt per specs
  If X2[4]
    MLVL = X2[4]
    Goto MLSPRDONE
  End If ! no wgt lvl - continue
End If 
MLVL = X2[4];X2[9] = 0 ! wgt lvl has priority unless really low wgt lvl
If ORDQTY Let X2[9] = S3[4] / ORDQTY ! unit wgt
If (X2[9] * X2[1]) > X2[2] Let MLVL = X2[3] ! qty lvl wgt>wgt lvl (ie: 20 cs>5 lbs)
If X2[1] And X2[2] = 0 And X2[3] <> 0 Let MLVL = X2[3] ! qty level>0 - wght lvl=0
If X2[1] = 0 And X2[2] = 0 And X2[4] <> 0 Let MLVL = X2[4] ! both zero - use wgt
If MLVL = 0 And X2[3] <> 0 Let MLVL = X2[3] ! no wgt - use qty
MLSPRDONE: Rem done
If MLVL > 1 ! from price 2-10 - move to standard vars
  X = MLVL - 2 ! var displ 0-8
  C3[0] = APTYPE[X];C3[1] = ABTYPE[X]
  SPC4[0] = AMQTY[X];SPC6[1] = AMTYPE[X]
  SPC5[0] = APFACT[X]
End If 
If MLVL < 1 Let MLVL = 1
Return 
L_29000: ! set rol to prod 
let L6[4]=a[6];unf[5]=a[5]
let l6[2]=b[23];unf[4]=a1[3]
let eun[0]=pfu1[0];un[2]=pfu1[11]
let eun[1]=pfu1[10]
UNF[0]=pfu2[0];unf[1]=pfu2[1]
unf[2]=pfu2[2];unf[3]=pfu2[3]
return
L_30000: Rem ===== set units for conversions (stock/nonstock version)
If S2[0] = 3 Goto L_30099 ! "message line (ZLINE)
A[6] = L6[4];A[5] = UNF[5] \ If Not(A[5]) Let A[5] = 1;UNF[5] = 1
B[23] = L6[2];A1[3] = UNF[4] \ If Not(A1[3]) Let A1[3] = 1;UNF[4] = 1
PFU1[0] = EUN[0];PFU1[1] = UN[0] ! "base and selling units
PFU1[2] = UN[1];PFU1[3] = UN[2] ! "pricing and costing
PFU1[4] = EUN[1] ! "purchasing
PFU1[5] = 0;PFU1[6] = 0;PFU1[7] = 0
PFU1[8] = UN[0];PFU1[9] = UN[0];PFU1[10] = EUN[1] ! "stock,sell,purch dflt
PFU1[11] = UN[2];PFU1[12] = UN[1] ! "cost,price dflt
If Not(L3[0]) Goto L_30060 ! "leave as is (NONSTOCK)
PFU1[13] = UN[0];PFU1[16] = EUN[0];PFU1[17] = EUN[0] ! "prod,up,bkn dflt
PFU1[18] = UN[0];PFU1[19] = UN[0] ! "pack,size dflt
L_30060: PFU2[0] = UNF[0];PFU2[1] = UNF[1] ! "selling and pricing factor
PFU2[2] = UNF[2];PFU2[3] = UNF[3] ! "costing and purchasing
PFU2[4] = 0;PFU2[5] = 0;PFU2[6] = 0
For X1 = 1 To 4
  For X2 = 0 To X1 - 1
    If PFU1[X1] = PFU1[X2] Let PFU1[X1] = 0;PFU2[X1 - 1] = 0
  Next X2
Next X1
L_30099: Return 
L_69000: Rem ===== check/set warehouse with valid data
If P9$[32,32] = "Y" ! "warehouse pricing turned on
  X2 = W3[19] + W3[20] + W3[21] + W3[22] + W3[23] + W3[24]
  If WHPARC[1] Let C4[3] = WHPARC[1] Else If X2 Let C4[3] = 0 ! "PR_C4[3]
  For X2 = 20 To 25
    If Not(W3[X2 - 1]) Let W3[X2 - 1] = A[X2] ! "default lists from main
  Next X2
  If Not(WHLM[0]) And Not(W3[17]) Let WHLM[0] = LM[0] ! "load 1 mup
  If Not(W3[17]) Let W3[17] = B[8] ! "load 1
  If Not(WHLM[1]) And Not(W3[14]) Let WHLM[1] = LM[1] ! "load 2 mup
  If Not(W3[14]) Let W3[14] = PF_LOAD2 ! "load 2
  If Not(W3[15]) Let W3[15] = B[21] ! "average cost
  If Not(W3[16]) Let W3[16] = B[10] ! "last cost
  If Not(W3[18]) Let W3[18] = C4[4] ! "base cost (MAY BE PR_C4[4])
  If Not(WHMISC[2]) Let WHMISC[2] = PRPARC[2] ! "p/o cost
  If WHPARC[0] Let B[22] = WHPARC[0] ! "break table to use
  If Not(W2[3]) Let W2[3] = B[24] ! "vendor to use
End If 
Return 
! all done - just error routines below
ERR_SEARCH: Rem
ENUM = E ;ELINE = Spc(16);CTERR = 0
If E = 5 Let CTERR = Err(8)
e$ = "RETURN STATUS",(E + (CTERR * .001))
e$ = e$,"/ STATEMENT",ELINE," IN PROGRAM "+Msc$(4)
error 11000
ERR_TRAP: Rem *Error routine (escape trap)   V3.1 8/94 G.DOSCHER/REK
include "src/callmainerrnet_call.inc"
end