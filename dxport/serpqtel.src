!"serpqtel" === description  synergy erp  quote entry/edit system
!  for line entry/edit
! loadsave -w -n 100,10 -o prog/dxport/serpqtel.dl4 src/serpqtel.src
!  
!
!  ******  DON'T FORGET TO CHANGE SERPORDL - IF APPLICABLE! ******************** ! 
!
!  03/26/2008 started
!  05/07/2008 revised prod & prodwhse structs
!  12/2009 - modify serpordl to serpqtel (dim name same but "as" is quote files)
!  08/17/2011 cutting
! 09/2013 - NEW LASTPRICE FILES AFTER rev1.8.4.0
!
! NOTE: IF WEB SIDE SEES RETURNSTATUS=2 - IT WILL CALL THE KIT PAGE!!
!   SO DO NOT USE RETURNSTATUS=2 EXCEPT FOR KITS! 
!
!
! custom_customer
! OMAHA -default ord type 38 to update stock=N cct176559/task10467
! OMAHA -%Cut/Punch Markup on Cut cct#208465/task#10448  
include "src/copyright.inc"
!
include "src/inc/filecust.inc"
include "src/inc/fileprod.inc"
include "src/inc/fileqordhead.inc" ! combined ros,rot,roh
include "src/inc/fileqolz.inc" ! lines
include "src/inc/fileqproddesc.inc" ! nstk lines
include "src/inc/fileprodwhse.inc" ! prodwhse
include "src/inc/fileccodesz.inc" ! u/m file (custom for System UM's)
include "src/inc/filesordlotz.inc" ! sordlot (fixed dir's)
include "src/inc/filesprodlot.inc" ! sprodlot
include "src/inc/filelastprice.inc" ! last price
include "src/inc/filesllstprice.inc" ! shiplist last price
include "src/inc/filecommodity.inc" ! commodity detail
include "src/inc/filecommhead.inc" ! commodity header
include "src/inc/fileprodgroup.inc" ! prod groups
include "src/inc/filesprodcatgy.inc" ! prod sls ctgy
include "src/inc/filedeptfle.inc" ! dept file
include "src/inc/filematcode.inc" ! mat'l code
include "src/inc/fileentdby.inc" ! entered by
include "src/inc/filewhinfo.inc" ! whse info - for whselist
include "src/inc/filetaxcode.inc" ! tax code file
include "src/inc/filea80vm.inc" ! vendor 
include "src/inc/filespecprice.inc" ! special price file
include "src/inc/filerebatedtlz.inc" ! rebate details
include "src/inc/filebuyer.inc" ! buyer
include "src/inc/filehazname.inc" ! hazname
include "src/inc/fileqoltag.inc" ! rol tag (zlines)
! addon files for line types
include "src/inc/fileqordlkitl.inc" ! kit lines
! serial numbers
! catch weight weights
! PO'S for non-stocks
include "src/inc/fileedittrack.inc" ! edit tracking
! for multicurrency
include "src/inc/filecurrency.inc" ! currency exchange file

! external libs for subs/functions
External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus

External Lib "ubsfunc.dl4"
Declare External Sub getportdefault,taxflag,GetCostLevels,LogAccess
Declare External Function OpenFile,PDate$,taxable,JDate$,FormatDate2$
Declare External Function ChkAltItem$,ChkBadChars,clrtxtc$

External Lib "libprodconv.lib"
Declare External Function ConvProdAmount

External Lib "librasl.lib"
Declare External Sub allocordlot,chkwhrasl

External Lib "libprodwh.lib"
Declare External Sub mxwhcreate,chkrprod
Declare External Function getwhavail

External Lib "libprod.lib"
Declare External Sub ProdList,ProdGroup,UMDList,CompIList
Declare External Sub SubstIList,SPRCIList
Declare External Function ComplFlag,SubItmFlag,SPRCIFlag
Declare External Function getpravail,getumrec,getMSDS,ChkPrdUM

External Lib "ubsprconv.dl4"
Declare External Function XUnit$

External Lib "libedittrack.lib"
Declare External Sub MakeEdittrack

External Lib "librebates.lib"
Declare External Sub rebates

External Lib "libprice.lib"
Declare External Sub SysPriceCalc

!External Lib "turboadd.dl4"  ! let's use just 1 program
!Declare External Sub TurboAdd  ! instead of 2
External Lib "libprodwords.lib"
Declare External Sub apturbo
   
External Lib "serpkitl.dl4"
Declare External Sub DELQKIT

External Lib "libcpi.lib"
Declare External Sub cpiordchk,CPIOrdAlerts

Declare Intrinsic sub programdump,env,Logic,findf
Declare Intrinsic Sub DateToJulian, JulianToDate

! internal subs/function
Declare Sub OpenFiles, GetNewProdDtl,GetPrice,Factorum,WhseList
Declare Sub RePrice,StkUpList,OrdAddlDtl,SetUPSpecs,SetNewRol
Declare Sub SetPRtoRol,LineMainDtl,getordlines,getcomplist,getcust
Declare Sub setpricelist,SetNewProdline,PriceWrkData,CostWrkData,CalcDirLoad
Declare Sub UpdtLines,DELOLINE,EdtTrkDo,updatelog,ProduceCPIAlerts
Declare Sub NSDefault,NSSaveItem,NSGetItem,NSBuildProd,ChkTOWhse
Declare Sub getot15list,getsubstlist,getsupsdlist,ROLTAG,delcqlp
Declare Sub WHSEAVAIL,NSFRMLP,gpsumm,verifystat,prcamalg
Declare Sub GetCutDetails,SubmitCutDetails,dolineextens
Declare Sub GetNetPrcCost,SProdDtl,GETIOLINES,MainDtlHdr
Declare Function GetOrdRec,getrbtcost,UMtoFactor,getnxtline,ChkHldcode
Declare Function Chkkit$,chktagfle$,GetAskLP
OPTION GOSUB NESTING 16  ! Default is 8
Try
	Option String Redim is legal ! in case subs dim/use same names
	! NOTE ALWAYS PRR for Product Rec, PWR for Prodwhse Record!
	! and OHR as header Record
	dim e$[500],buttonlist$[5,50],nextlist$[5,100] !error handling variables
	dim action$[30],options$[30],userid$[8],b$[200],action1$[30],Action2$[30]
	Dim bsdel$[10],esdel$[10],rdel$[10],fdel$[10],rstr$[2000]
	dim tmp$[1200],tmp1$[300],Msgdesc$[150],Field$[1,30]
	dim Message$[200],WebStr$[2500],SessionID$[200],rolkey$[60]
	Dim Prod$[12],ProdKey$[60],P9$[50],P60$[50],P61$[256],p8$[7]
	Dim QMask$[20],PMask$[20],Key1$[60],UA2$[50],TPWKey$[60]
	dim Blank$[100] \ Blank$=" ",Blank$
	dim ucf$[10]
	Dim OrgProd$[12],LPType$[5],tmp2$[200],custom_customer$[30]
	dim 1%,cnvcu[10],3%,cnvca[10],keycurr$[10],3%,rec_curr,currfact
	dim 3%,dsp_extucost,dsp_extncost,dsp_extuprice,dsp_extnprice
	Dim 1%,PRC,PWC,CCC,OHC,OTC,OSC,OLC,CMC,SWUO
	dim 1%,cost_lev[4],Whse,debug,ordpad,2%,Q0[1],cust
	Dim 2%,X2[9],NumProd,OrderNo,LD,UA2[2],RASL[2],Source
	Dim 2%,maxcnt \ maxcnt=50 ! init max records in arrays for list
	Dim 3%,PRR,OHR,OLR,PWR,FChan[30],FRec[99]
	Dim 3%,SUM,SQty,SHQty,BOQty,R[99],O1,UB0[16]
	dim 3%,FlePtr[20,1],Specs[50] ! for price
	dim List$[maxcnt,1200] ! for .net (larger size - ZLines)
	dim slist$[maxcnt,1200] ! second list
	Dim tlist$[maxcnt,1200] ! third list
	dim dmsg$[256],dblog$[60] \ dblog$="files/6/ql.log" ! fields for DEBUG
	Dim 3%,X3[9]

	Dim PR. as prod
	Dim pw. as prodwhse
	dim roh. as qoh ! order header
	dim ros. as qos ! order ship to file
	dim rot. as qot ! order total file
	dim rol. as qol ! order lines
	dim cmc. as commhead ! commodity code
	Dim cust. as cust ! customer master
	dim clp. as lastprice ! customer last price
	dim umc. as ccodes ! um codes file
	dim whi. as whinfo ! whse info file
	Dim Nstk. as qproddesc ! non-stock file
	Dim ETR. as edittrack ! EDITTRACKING
	dim psc. as sprodcatgy ! product category
	dim matc. as matcode ! material code
	dim buy. as buyer ! buyer 
	dim haz. as hazname ! haz material
	dim tax. as taxcode ! taxcode
    ! for currency exchange
	dim curr. as currency

	Def FNR(H) = Int(Abs(H) * 100 + .5) * .01 * Sgn(H)
	Def FNC(H)=Int(abs(H)*10000+.5)*.0001*Sgn(H)
	Def FNS(H) = Int(Abs(H) * 100) * .01 * Sgn(H) ! rounding to nearest penny
	Def FNQ(H) = Int(Abs(H) * 10 ^ Q0[1] + .1) * 10 ^ - Q0[1] * Sgn(H) 

	call dxopen()
	call GetSession(e$,CTLC,options$,action$,UserID$,intCo,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$,action1$,action2$)
	Call dxget("ORDERID",tmp$)                           
	call LogAccess(e$,"QUOTE #: "+tmp$)
	debugDetail=0;debug=0 ! can do debug text by changing both to 1
	If debugDetail
		debug=1
		tmp$="serpqtel"
		dmsg$[1,50]="-",dmsg$ \ Call updatelog(debug)               
		dmsg$="start...program "+tmp$ \ Call updatelog(debug)
	Endif
	Action$=UCase$(Action$)
	ACtion$=RTrim$(Action$) ! make sure UPPERCASE and No blanks at end
	Action1$=UCase$(action1$)
	Action1$=RTrim$(action1$) ! UC and trimmed
	Action2$=UCase$(action2$)
	Action2$=RTrim$(action2$) ! UC and trimmed
	if debugdetail
		dmsg$="SERPQTEL ACTION "+action$
		If Action1$<>"" let dmsg$=dmsg$+" ACTION1 "+action1$ 
		if Action2$<>"" let dmsg$=dmsg$+" ACTION2 "+action2$
		Call updatelog(debug)
	Endif
	Mat Read #ctlc,61,0;P61$;
	! let p61$[136,136]="N" ! set multcurrency to No
	call OpenFiles() ! open all needed files
	call GetCostLevels(e$,Cost_Lev[],IntCO,UserID$) ! get cost security
	Mat Read #ctlc,19,50;P9$;
	mat read #ctlc,52,60;P8$;
	Mat Read #ctlc,60,50;P60$;
	P60$[27,27]="N" ! NO BOREM CHK ON QUOTES! (NO AVAILABLE CHECK/UPDATE)
	! Mat Read #ctlc,61,0;P61$;
	Mat Read #CTLC,115,40;Q0;
	MAT  READ #CTLC,115,60;CUSTOM_CUSTOMER$;
	QMask$="----------#.##"
	tmp$="#",tmp$
	If q0[1]<=0 Let Q0[1]=2
	If Q0[1] Let Pmask$="-----------#.",tmp$[1,Q0[1]]     !price mask
	IF P9$[29,29]="N" LET COST_LEV[1]=0 ! = SHOW COST IN OE
	Custom_customer$=UCase$(Trim$(custom_customer$))
	SWUO=0 ! ship WHOLE sell units only on new order
	IF CUSTOM_CUSTOMER$="SOUTHJERSEY" LET SWUO=1
	if custom_customer$="SAFEWAY" let SWUO=1 ! task 38677
	! get the Usercntrl Rec #
	If Userid$="" or UserID$[1,2]="  "
		Call DXGet("S_USER.ID",tmp$) ! get from system variable
	Else
		tmp$=UserID$
	Endif
	Let UserID$=UCase$(tmp$) ! make sure it's UPPERCASE as that's what PM uses
	Let Key1$=UserID$+"          " ! space fill it
	UCC = OpenFile(-9988, intCo) \ if UCC=-1 Error 42
	Key1$[11]="" ! cut to length
	Search #UCC,2,1;Key1$,Rec,E
	If Not(E)
	  Let SCR=Rec
	  Mat Read #ucc,scr,200;UA2;
	  Mat read #ucc,scr,336;Ua2$;
	  MAT READ #UCC,SCR,652;UCF$;
	Else
	  Let SCR=0 ! 
	  UA2[0]=0;UA2$=" ",UA2$
	  Ucf$=" ",ucf$
	Endif
	Close #UCC
	! GET additional user data flags
	REM UNPACK A2[0] TO B0[]                         
	FOR X1=0 TO 15                                          
		LET O1=2^X1 \ LET M1=1
		! CALL $LOGIC,M1,O1,A2[0],B0[X1] ! ub
		Call Logic(m1,O1,UA2[0],UB0[X1])
		LET UB0[X1]=SGN(UB0[X1])
	NEXT X1 
	CALL LOGIC(1,64,UA2[0],ADELLN)
	UB0[6]=ADELLN
	QUOTE=1 ! flag as a quote
	Call dxget("SOURCE",tmp$)
	Source=tmp$ ! future use?
	select case action$

	case "DROPLIST" !   send droplists 
		
		If Action1$="UMDROPLIST" !							doc = QTL-produmdroplist.doc
			Call DXGet("PRODID",prod$) \ prod$=UCase$(prod$)
			Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
			ProdKey$=Prod$
			Call dxget("LTYPE",tmp$)
			tmp$ = UCase$(tmp$)
			if tmp$[1,4]<>"NSTK" ! LET PRODKEY$[1,6]="ZNSTK " ! set to non-stock
			!If Prodkey$[1,6]<>"ZNSTK "
				PrR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.) ! product mode=2 dir=1
				clear e$
				NonStk=0
			Else
				PRR=0;nonstk=1
				Call dxget("ORDERID",tmp$)                           
				orderno = tmp$  
				If not(orderno) goto EndUMDroplist: ! end um droplist
				If orderno <= 0 Or orderno > 999999 Or Fra(orderno)  
					ReturnStatus = 0                                   
					Message$ = "INVALID ORDER!"  
					 goto EndUMDroplist: ! end um droplist
				End If   
				Call dxget("LN",tmp$) ! +Str$(X1),tmp$)         
				LineNo = tmp$ ! line # (zero on new lines)
				If LineNo <= 0 Or LineNo > 999 Or Fra(lineno)  
					ReturnStatus = 0                                   
					Message$ = "INVALID ORDER LINE!"  
					goto EndUMDroplist: ! end um droplist
				End If   
				rolkey$ = " ",rolkey$                         
				rolkey$[1,6] = orderno Using "######"         
				rolkey$[7,9] = LineNo Using "###"       
				rolkey$[11] = "" ! cut to length (space @ 10) 
				OLR = filegetqolz(e$,OLC,"=",1,rolkey$,rol.)
				clear e$
				if olr<=0
					returnstatus=0
					Message$="Order Line Not Found"
					goto EndUMDroplist: ! end um droplist
				endif
				let prodkey$=rol.prodcode$
				Call SetPRtoRol()
			Endif
			if debugdetail
				dmsg$="UMDROPLIST PROD= "+prodkey$ \ Call updatelog(debug)
			Endif
			!
			! initialize status
		  If PrR<0 ! Product record not found
			 clear PR.
			 ReturnStatus=0
			 Message$="Error, Product not found"
		  else ! continue with list
			E$="" ! clear message
			tmp$=" " ! is passed
			If Not(NonStk)
				Call UMDList(e$,tmp$,PRC,PRR,List$[],IntCo,Pr.)
			Else ! nonstk - send whole list
				if olr>0
					Call UMDList(e$,tmp$,PRC,PRR,List$[],IntCo,Pr.)
				else
					clear tmp$ ! send other flag
					Clear Field$[]
					!if p9$[20,20]="F" let tmp$="F"
					let tmp$="F"
					!call filedroplistccodes(e$,list$[],maxcnt,CCC)
					call filedroplistccodesz(e$,list$[],maxcnt,CCC,"",Field$[],1,"",tmp$)
				endif
			Endif
			Let ReturnStatus=1
			Message$="OK"
			If E$<>""
			  Let ReturnStatus=0
			  Message$=E$
			Endif
		  Endif ! valid prod
		EndUMDroplist: ! end um droplist

		  if debugdetail
				dmsg$="UMDROPLIST sent "+message$ \ Call updatelog(debug)
		  Endif
		Endif ! action1=umdroplist

		If Action1$="WHSELIST" !							doc = QTL-WhseDroplist.doc
			Call DXGet("PRODID",prod$) \ prod$=UCase$(prod$)
			Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
			ProdKey$=Prod$
			Call dxget("LTYPE",tmp$)
			tmp$ = UCase$(tmp$)
			if tmp$[1,4]="NSTK" let Prodkey$[1,6]="ZNSTK "
			If Prodkey$[1,6]<>"ZNSTK "
				PrR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.) ! product mode=2 dir=1
				clear e$
				NonStk=0
			Else
				PRR=0;nonstk=1
			Endif
			if debugdetail
				dmsg$="WHSELIST PROD= "+prodkey$ \ Call updatelog(debug)
			Endif
			!
			! initialize status
		  If PrR<0 ! Product record not found
			 clear PR.
			 ReturnStatus=0
			 Message$="Error, Product not found"
		  else ! continue with list
			If NonStk Let P61$[59,59]="N" ! no prev only on nonstks!
			Call WhseList(e$,List$[],maxcnt,ReturnStatus,Message$)
		  Endif ! valid prod
		  if debugdetail
				dmsg$="WHSELIST sent "+message$ \ Call updatelog(debug)
		  Endif
		Endif ! action1=Whselist

		If Action1$="TAXLIST" ! tax y/n or taxcode list		doc=QTL-taxdroplist.doc
			Let ReturnStatus=1
			Message$="OK"
			Clear List$[]
			Clear e$
			tmp$=Action1$ ! send as section name
			If P60$[42,42]<>"Y" ! NOT tax by line - so it's y/n only
				List$[0]=bsdel$,tmp$,fdel$
				List$[1]="ID",fdel$,"Desc$",fdel$ ! use same names as droplist!
				List$[2]="N",fdel$,"Not Taxable",fdel$
				List$[3]="Y",fdel$,"Taxable",fdel$
				List$[4]=esdel$
			Else ! is tax by line - send whole list
				List$[0]=bsdel$,tmp$,fdel$
				Field$[0]="Desc$"
				List$[1]="ID",fdel$,Field$[0],fdel$
				List$[2]="0",fdel$,"Non taxable",fdel$
				row=3
				Tcc=Openfile(-2176,IntCo) \ if Tcc = -1 Error 42
				!call filedroplisttaxcode(e$,list$[],maxcnt,tcc,tmp$,field$[])
				X4=Chf(tcc)-1
				for x2=1 to x4
					tmp1$=" ",tmp1$
					Read record #tcc,x2,0;tax.;
					tmp$=RTrim$(tax.Desc$)
					if tmp$<>""
						WebStr$=Str$(X2),fdel$,tmp$,fdel$
						List$[row]=webstr$
						row=row+1
						If row>tmpcnt let tmpcnt=expandarray(e$,List$[])
					Endif
				Next X2
				List$[row]=esdel$
				Close #tcc
				if e$<>""
					ReturnStatus=0
					Message$=E$
				Endif
			Endif
			if debugdetail
				dmsg$="TAXLIST p60-42,42= "+p60$[42,42] \ Call updatelog(debug)
			Endif
			!
		Endif ! action1=taxlist

		If Action1$="DEPTLIST" ! tax y/n or taxcode list	doc=QTL-deptdroplist.doc
			Let ReturnStatus=1
			Message$="OK"
			Clear List$[]
			Clear e$
			clear field$[]
			tmp$=Action1$ ! send as section name
			dpc=OpenFile(-1632,IntCo) \ if dpc = -1 Error 42
			call filedroplistdeptfle(e$,List$[],maxcnt,dpc,tmp$,Field$[],"0")
			close #dpc
			if e$<>""
				ReturnStatus=0
				Message$=E$
			Endif
			if debugdetail
				dmsg$="DEPTLIST SENT "+Message$ \ Call updatelog(debug)
			Endif
			!
		Endif ! action1=deptlist

		If Action1$="ORDFLAGS" ! rules for this cust/Order  doc=QTL-OrdFlags.doc
			ReturnStatus=1
			Message$="OK"
			Call DXGet("ORDERID",tmp$)
			OrderNo=tmp$
			If OrderNo<=0 Or OrderNo>999999 Or Fra(OrderNO)
				ReturnStatus=0
				Message$="INVALID ORDER!"
			Endif
			OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
			If OHR<=0
				ReturnStatus=0
				Message$="QUOTE NOT FOUND!"
			Endif
			If OHR>0 ! can only do if found
				Call GetCust() ! need for flags
			Else
				Clear Cust.
			Endif
			Credit=0
			if ros.Status=32 let Credit=1
			if credit and roh.ShipType=3 let cost_Lev[1]=0 ! no cost edit on Price error credit!
			Clear List$[]
			List$[0]=BSDEL$,"ORDERFLAGS",fdel$
			WebStr$="Decimals",fdel$,"Rounding",fdel$ ! add more as needed
			WebStr$=WebStr$,"AllowCut",fdel$,"AllowKit",fdel$
			WebStr$=WebStr$,"Amalg",fdel$,"BOChk",fdel$
			WebStr$=WebStr$,"SPUMEqual",fdel$,"PermPrc",fdel$
			WebStr$=WebStr$,"AllowBrkn",fdel$,"EditQtyUM",fdel$
			WebStr$=WebStr$,"AllowBO",fdel$,"OvrBO",fdel$
			WebStr$=WebStr$,"EditTax",fdel$,"EditPrntFlag",fdel$
			WebStr$=WebStr$,"EditStkUpt",fdel$,"EditQty",fdel$
			WebStr$=WebStr$,"AllowDel",fdel$,"LPPrompt",fdel$
			WebStr$=WebStr$,"AuthBuy",fdel$,"CPUMEqual",fdel$
			WebStr$=WebStr$,"Package",fdel$,"ForceSNinInv",fdel$
			WebStr$=WebStr$,"ExistPW",fdel$,"ProdNotes",fdel$
			WebStr$=WebStr$,"OT16RA",fdel$,"OT16AutoBO",fdel$
			WebStr$=WebStr$,"CostSec",fdel$  ! CAUTION CM FIELD BELOW (AFTER COSTSEC)
			If Credit ! Add only if credit?
				WebStr$=WebStr$,"CPINVONLY",fdel$
			! Else ! if adding flags - send blank before new
			Endif
			if not(Credit) !and roh.ordtype=15 ! needs header field never sent previously
				webstr$=webstr$,"BOCTR",fdel$ ! needs for lines
			Endif
			webstr$=webstr$,"POSPPFLAG",fdel$,"OIPPFLAG",fdel$ ! 6739 
			webstr$=webstr$,"CPIUSED",fdel$,"USEHLD4PO",fdel$
			webstr$=webstr$,"CalcLoadGL",fdel$
			List$[1]=WebStr$
			WebStr$=Str$(Q0[1]),fdel$,P9$[42,42],fdel$ ! add more as needed
			tmp$="N" \ if p9$[20,20]="F" let tmp$="Y" ! version >1.7.5.0
			IF roh.ordtype=16 let tmp$="N" ! not on xfers
			WebStr$=WebStr$,tmp$,fdel$,P9$[22,22],fdel$ ! cutting,kits
			WebStr$=WebStr$,p60$[12,12],fdel$,P60$[27,27],fdel$ ! amalg, BOchk
			WebStr$=WebStr$,p60$[30,30],fdel$,p60$[33,33],fdel$ ! Q=P UM, Perm
			WebStr$=WebStr$,p60$[34,34],fdel$,p60$[35,35],fdel$ ! Broken, edit sell um
			tmp$="N" \ if cust.BoSAllowedFlag=1 tmp$="Y"
			WebStr$=WebStr$,tmp$,fdel$,Ua2$[27,27],fdel$ ! allowBO, override BO
			WebStr$=WebStr$,UA2$[32,32],fdel$,UA2$[15,15],fdel$ ! edit tax, edit line prntd
			tmp$="N" \ if UB0[13] let tmp$="Y"
			tmp1$="N" \ if UB0[5] let tmp1$="Y"
			WebStr$=WebStr$,tmp$,fdel$,tmp1$,fdel$ ! edit stkupt, edit ord qty
			tmp$="N" \ if UB0[6] let tmp$="Y"
			tmp1$="N" \ if p61$[25,25]="P" let tmp1$="Y"
			WebStr$=WebStr$,tmp$,fdel$,tmp1$,fdel$ ! del line, prompt new LP
			WebStr$=WebStr$,cust.AuthBuyList$,fdel$,P61$[61,61],fdel$ ! authbuy,c=p um
			WebStr$=WebStr$,P9$[2,2],fdel$,P9$[46,46],fdel$ ! pkg, sn in inv
			WebStr$=WebStr$,P61$[59,59],fdel$,P61$[43,43],fdel$ ! exist pw, notes
			WebStr$=WebStr$,p61$[54,54],fdel$,p61$[49,49],fdel$ ! ot16 req/auth, auto BO
			WebStr$=WebStr$,Str$(Cost_Lev[1]),fdel$ ! loadcost sec
			If Credit let webstr$=webStr$,P61$[80,80],fdel$ ! ONLY CM FROM INV
			if roh.ordtype=15 let webstr$=webstr$,Str$(roh.boctr),fdel$ ! ord accepted prev
			webstr$=webstr$,"N",fdel$,"N",fdel$ ! NOT USED IN QUOTES! PP flag
			tmp$="N" \ if p61$[111,111]="Y" let tmp$="Y"
			webstr$=webstr$,tmp$[1,1],fdel$ ! CPI FLAG
			webstr$=webstr$,"N",fdel$ ! hold for po - not on quotes!
			let tmp$="N"
			if p61$[116,116]="Y" let tmp$="Y"
			webstr$=webstr$,tmp$,fdel$
			List$[2]=WebStr$
			List$[3]=esdel$
			if debugdetail
				dmsg$="Order Flags sent "+Message$ \ Call updatelog(debug)
			Endif
			
		Endif ! of OrdFlags
		If Action1$="LINEFLAGS" ! rules for this Line		doc=QTL-LineFlags.doc
			ReturnStatus=1  ! now sent as part of line detail!
			Message$="OK"
			Call DXGet("PRODID",tmp$)
			tmp$=UCASE$(tmp$)+Blank$
			Prod$=tmp$[1,12]
			Call DXGET("WHSE",tmp$)
			Whse=tmp$
			Call DXGET("ORDTYPE",tmp$)
			OType=tmp$
			ProdKey$=Prod$
			PRR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.)
			clear e$
			If PRR<=0
				ReturnStatus=0
				Message$="PRODUCT NOT FOUND"
				Clear PR.
			Endif
			tmp$=Prod$+Whse Using "##"
			tmp$[15]=""
			PWR=filegetprodwhse(e$,PWC,"=",1,tmp$,PW.)
			clear e$
			If PWR<=0 Clear pw.
			! any order type specific changes?
			If OType=2 ! direct cannot do s/n, lot, etc
				pr.MBFlg$="B" ! force buy
				pr.SerNoTrack$="N" ! can't do as none
				pr.LotCtrl$="N" ! can't do this either?
				pw.DNReordFlg=0 ! not frozen if direct
			Endif
			Clear List$[]
			List$[0]=BSDEL$,"LINEFLAGS",fdel$
			WebStr$="CHKBrkn",fdel$,"MBFlag",fdel$
			WebStr$=WebStr$,"SerialNo",fdel$,"CatchWeight",fdel$
			WebStr$=WebStr$,"LotControl",fdel$,"RollLB",fdel$
			WebStr$=WebStr$,"DNReord",fdel$,"BrknUM",fdel$
			WebStr$=WebStr$,"BrknUMID",fdel$,"BrknUMFact",fdel$
			Webstr$=webstr$,"HILIGHTPID",fdel$

			List$[1]=WebStr$ ! add more to webstr as needed
			if pw.ChkBrknQty$<>"N" let pw.ChkBrknQty$="Y" ! Y is default
			IF PRR<=0 let pw.ChkBrknQty$="N" ! non-stock?
			WebStr$=pw.ChkBrknQty$,fdel$,pr.MBFlg$,fdel$ ! chk brkn, make/buy
			pr.SerNoTrack$="N" ! can't do as quote
			WebStr$=WebStr$,pr.SerNoTrack$,fdel$,pr.CatchwgtItem$,fdel$ ! s/n, catchwgt
			WebStr$=WebStr$,pr.LotCtrl$,fdel$,pr.RollLbItem$,fdel$ ! lotcontrol, roll/lb
			tmp$=XUNIT$(pr.UMBrknQty,ccc)
			WebStr$=WebStr$,Str$(pw.DNReordFlg),fdel$,RTrim$(tmp$),fdel$ ! DNReord, brkn um
			X3=UMtoFactor(pr.UMBrknQty)
			WebStr$=WebStr$,Str$(pr.UMBrknQty),fdel$,Str$(X3),fdel$ ! um id, um factor
			tmp$="N" \ if custom_customer$="MORRISETTE" and Int(pr.UdNumeric)<>0 let tmp$="Y"
			webstr$=webstr$,tmp$,fdel$ ! hilite on quotes?

			List$[2]=WebStr$ ! add more to webstr as needed
			List$[3]=esdel$
			if debugdetail
				dmsg$="Line Flags sent "+Message$ \ Call updatelog(debug)
			Endif
			
		Endif ! of LineFlags
		! add in droplist for nonstock here 
			
		if action1$="VENDOR" ! can use option=VENDM action=SEARCH 
			Let ReturnStatus=1
			Message$="OK"
			clear e$
			tmp$=Action1$ ! send as section name
			Clear List$[]
			if not(ch_vend)
				ch_vend = OpenFile(-2400,IntCo) \ If CH_vend = -1 Error 42 ! vendor droplist
			endif
			call FileDropListA80vm(e$,List$[],maxcnt,ch_vend) 
			if e$<>""
				ReturnStatus=0
				Message$=E$
			Endif
			if debugdetail
				dmsg$="VENDOR LIST SENT "+Message$ \ Call updatelog(debug)
			Endif
		endif ! droplist vendor
		IF action1$="MATCODE"! material code ---			doc=QTL-Droplistmatcode.doc
			Let ReturnStatus=1
			Message$="OK"
			clear e$
			tmp$=Action1$ ! send as section name
			clear list$[]
			if not (ch_matc)
				ch_matc = OpenFile(-2272,IntCo) \ If CH_matc = -1 Error 42 ! material code
			endif
			call FileDropListMatCode(e$,List$[],maxcnt,ch_matc) 
			if debugdetail
				dmsg$="MATERIAL CODE LIST SENT "+Message$ \ Call updatelog(debug)
			Endif
		endif ! droplist for material codes
		if action1$="PRODCAT" ! product categoery ---		doc=QTL-Droplistprodcat.doc
			Let ReturnStatus=1
			Message$="OK"
			clear e$
			tmp$=Action1$ ! send as section name
			clear list$[]
			if not(ch_psc)
				ch_psc = OpenFile(-1984,IntCo) \ If ch_psc = -1 Error 42 ! prod sales category
			endif
			call FileDropListSProdCatgy(e$,List$[],maxcnt,ch_psc) 
			if debugdetail
				dmsg$="Product Category LIST SENT "+Message$ \ Call updatelog(debug)
			Endif
		endif ! droplist for product category
		if action1$="COMMCODE"  ! commodity code			doc=QTL-droplistcommcode.doc
			Let ReturnStatus=1
			Message$="OK"
			clear e$
			tmp$=Action1$ ! send as section name
			clear list$[]
			if not(cmc)
				cmc = OpenFile(-2288,IntCo) \ If cmc = -1 Error 42 ! commod code(HEAD)
			endif
			Call FileDropListcommhead(e$,List$[],maxcnt,cmc)
			if debugdetail
				dmsg$="Commodity Code  LIST SENT "+Message$ \ Call updatelog(debug)
			Endif
		endif ! droplist for commcode
		if action1$="BUYER" ! buyer code					doc=QTL-droplistbuyer.doc
			Let ReturnStatus=1
			Message$="OK"
			clear e$
			tmp$=Action1$ ! send as section name
			clear list$[]
			if not(ch_buy)
				Ch_buy = OpenFile(-9991,intCo) \ If Ch_buy = -1 Error 42 ! buyer
			endif
			Call FileDropListbuyer(e$,List$[],maxcnt,Ch_buy,"",Field$[],"0") ! 0=none!)
			if debugdetail
				dmsg$="BUYER LIST SENT "+Message$ \ Call updatelog(debug)
			Endif
		endif ! droplist for buyer

		if action1$="CCODE" ! unit of measure droplist		doc=QTL-droplistccodes.doc
			DIM FIELD$[1,30]
			ReturnStatus = 1                                                        
			Message$ = "OK"                                                         
			Clear e$                                                                
			 tmp$ = Action1$ ! send as section name                                  
			Clear List$[]                                                           
			If Not(ccc)                                                             
				ccc = OpenFile(-1728,IntCo) \ If ccc = -1 Error 42 !u/m codes file    
			End If
			clear tmp$ ! send other flag
			Clear Field$[]
			!if p9$[20,20]="F" let tmp$="F"
			let tmp$="F"
			!call filedroplistccodes(e$,list$[],maxcnt,CCC)
			call filedroplistccodesz(e$,list$[],maxcnt,CCC,"",Field$[],1,"",tmp$)
			if debugdetail
				dmsg$="Unit Of Measure LIST SENT "+Message$ \ Call updatelog(debug)
			Endif
		endif  ! droplist for ccode
		if action1$="HAZNAME" ! ! Hazardous name			doc=QTL-Droplisthazname.doc
			Let ReturnStatus=1
			Message$="OK"
			clear e$
			tmp$=Action1$ ! send as section name
			clear list$[]
			if not(ch_haz)
				Ch_haz= OpenFile(-2784,intCo) \ If Ch_haz = -1 Error 42 ! hazardous
			endif
			Call FileDropListHazName(e$,List$[],maxcnt,Ch_Haz)
			if debugdetail
				dmsg$="HAZARDOUS NAME LIST SENT "+Message$ \ Call updatelog(debug)
			Endif
		endif ! droplist for haz mat
		
		! end droplist for nonstock
		If action1$="ALLWHSEAVAIL" ! whse available			doc=OrdL-GetAllWhseAvail.doc
			returnstatus=1
			message$="OK"
			call WHSEAVAIL()
		Endif
	  ! end of droplists
	  call AddToStr(e$,rstr$,List$[]) ! add droplist to string
	  !
	  ! status section
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
	  !
	case "PRODSEARCH" ! product scan						doc = prodscanlist.doc
		!
		Let ReturnStatus=1
		Message$="OK"
		X2=1 ! order scan
		clear list$[]
		if p61$[136,136]="Y" and roh.currid>0 and roh.currfact>0
			let list$[0]=str$(roh.currfact)
		endif
		Call ProdList(e$,IntCo,List$[],maxcnt,ctlc,prc,pwc,x2,debugdetail,dblog$,UserId$)
		If E$<>""
		  Let ReturnStatus=0
		  Message$=E$
		  e$=""
		Endif
		call AddToStr(e$,rstr$,List$[])
		
	  !
	  ! status section
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
	  if debugdetail
			dmsg$="Product Search sent "+Message$ \ Call updatelog(debug)
	  Endif
	  !
	case "PRODDETAIL" !										doc = QTL-newproddetails.doc
		! get details from list(single/quick also)
		Call SetNewProdline()
		!
	case "PRICEWORK" !										doc = QTL-priceworkdtl.doc
		! user clicked [+] next to Net Price
		Call PriceWrkData()
		!
	case "COSTWORK" !										doc = QTL-costworkdtl.doc
		! user clicked [+] next to Cost
		Call CostWrkData()
		!
	case "PRICELIST"   !									doc = QTL-pricelist.doc
		! wants a list of prices (List, Bracket/Break)
		Call setpricelist() ! all handled in routine
		! end of PRICELIST
	case "REPRICE","REPRICESUM" !							doc = QTL-reprice.doc
		! reprice/cost the line
		Call Reprice() ! all handled in the routine
		! end of REPRICE
	case "STKUPDATE" ! stock update flag					doc = QTL-stkupdflag.doc
		! send back list of choices (even if N Only)
		Call StkUpList() ! all handled in routine
		! end of stkupdate
	case "LINEADDLDTLS" ! additional details				doc = QTL-addllinedtl.doc
		! Additional details wanted
		Call OrdAddlDtl()
		! end of prodadddtls
	case "GETLINES" !										doc = QTL-getordlines.doc
		!  get existing ordlines
		let dooneline=0;dopart=0 ! so gets all
		Call getordlines()
		! end of getlines
	case "GETREQLINES" !									doc = QTL-getreqlines.doc
		!  get requested ordlines
		let dooneline=0;dopart=0 ! so gets all
		Call getiolines()
		! end of getreqlines
	case "GETPARTLINES" !									doc = QTL-getpartlines.doc
		!  get existing ordlines
		let dooneline=0;DoPart=1 ! so gets only 50 at a time
		Call getordlines()
		! end of getlines
	case "GETCOMPLIST" ! get list of complementary items  doc=QTL-ComplItemList.doc
		! from product sent
		call getcomplist()
		! end of complist
	case "GETSUBSTLIST" ! get list of subst items			doc=QTL-SubstItemList.doc
		! from product sent
		call getsubstlist()
		! end of getsubstlist
	case "GETSPRSDLIST" ! get list of supersedes			doc=QTL-SprcdItemList.doc
		! from product sent
		call getsupsdlist()
		! end of getsupsdlist
	case "UPDTLINES" ! lines are being submitted			doc=QTL-UpdtLines.doc
		! from web
		call UpdtLines()
		! end of update lines
	case "CALCDIRLOAD" !   ! CALCULATE DIRECT LOAD COST   doc = ordl-calcdirload.doc
		! user clicked [+] next to Cost
		Call CalcDirLoad() 
	case "NSDEFAULT" ! get default info for new nonstock item  doc=QTL-NSDefault.doc
		call NSDefault()
		! end nsdefault
	case "NSSAVEITEM" ! get default info for new nonstock item  doc=QTL-NSsaveitem.doc
		call NSSAVEITEM()
		! end nssaveitem
	case "NSGETITEM" ! get existing non-stock item info		doc=QTL-NSGETITEM.doc
		call NSGETITEM()
		
		! end nsgetitem
	case "NSBUILDPROD" ! create a product from non-stock	doc=QTL-NSBuilldProd.doc
		call NSBUILDPROD()
		if returnstatus=0
			let olr=-1
		else
			call UpdtLines()
		endif
		clear list$[]                                                         
		list$[0]=bsdel$,"NSBUILDPROD",fdel$                                   
		webstr$=webstr$,"PRODID",fdel$                                        
		webstr$=webstr$,"LN",fdel$                                            
		webstr$=webstr$,"DEPT",fdel$                                          
		webstr$=webstr$,"STKUPDT",fdel$                                       
		webstr$=webstr$,"TAX",fdel$                                           
		webstr$=webstr$,"WHSE",fdel$                                          
		List$[1]=webstr$                                                      
		if OLR>0
			Read Record #OLC,OLR,0;rol.;
			webstr$=""                                                    
			webstr$=rtrim$(rol.prodcode$),fdel$                          
			webstr$=webstr$,str$(rol.LineNum),fdel$                       
			webstr$=webstr$,str$(rol.dept),fdel$                          
			let tmp$="N"                                                  
			if rol.UpdtStk let tmp$="Y"                                  
			WebStr$=WebStr$,tmp$,fdel$ ! update stock flag$               
			If P60$[42,42]<>"Y" ! NOT tax by line - so it's y/n only      
				tmp$="N" \ if rol.TaxFlg let tmp$="Y"                
				WebStr$=WebStr$,tmp$,fdel$ ! tax flag                 
			Else ! it's a tax code                                        
				WebStr$=WebStr$,Str$(rol.TaxFlg),fdel$ ! tax code     
			Endif 
			webstr$=webstr$,str$(rol.whse),fdel$     
			list$[2]=webstr$                          
		endif                                             
		Call AddToStr(e$,rstr$,List$[]) ! mtg             
		Call AddToStr(e$,rstr$,esdel$) ! end of section   
		! status section                                                       
		Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)                 
		Call AddToStr(e$,rstr$,WebStr$)                                        
		Call SetOutPut(e$,rstr$)                                    
	    ! end of nsbuildprod	
	Case "LINENOTES" ! see routine for docs
		! using the roltag for zlines(does orders & history)
		returnstatus=1
		message$="OK"
		call ROLTAG()
		! end of linenotes
	Case "OPADQTY" ! some of the additional details			doc=QTL-OrdPadQtyDtl.doc
		! send whse qty list and quantity info
		returnstatus=1
		message$="OK"
		ordpad=1 ! flag to signify it's for orderpad
		Call OrdAddlDtl()
		! end of orderpad qty
	Case "SUBMITSUBST" ! sub/alt							doc=QTL-SubmitSubstituteProduct.doc
		let afrm=1;SHQty=0;BOQty=0
		call dxget("ORGPROD",tmp$)
		OrgProd$=UCase$(tmp$)+Blank$
		Call SetNewProdline()
	Case "SUBMITSUPER" ! supersede							doc=QTL-SubmitSupersedeProduct.doc
		let afrm=2;SHQty=0;BOQty=0
		call dxget("ORGPROD",tmp$)
		OrgProd$=UCase$(tmp$)+Blank$
		Call SetNewProdline()
	Case "SUBMITCOMPL","SUBMITBOPAD" !	compl/opad			doc=QTL-SubmitComplementaryProduct.doc
		let afrm=0;SHQty=0;BOQty=0   !						doc=QTL-SubmitOrderPadProduct.doc
		OrgProd$=Blank$
		Call SetNewProdline()
	Case "GPSUMMARY" ! g/p summary							doc=QTL-GetGPSummary.doc
		returnstatus=1
		message$="OK"
		call gpsumm()
		! end of gpsummary
	Case "GETCUTDTLS" ! get curr cut details				doc=OrdL-GetCutData.doc
		returnstatus=1
		message$="OK"
		recalccut=0
		call GetCutDetails()
		! end of getcutdtls
	Case "SUBMITCUTDTLS" ! submit cuts						doc=QTL-SubmitCutData.doc
		returnstatus=1
		message$="OK"
		call SubmitCutDetails()
		! end of submitcutdtls
	Case "RECALCCUTDTLS" ! recalc qtys/charges				doc=QTL-ReCalcCutData.doc
		returnstatus=1
		message$="OK"
		recalccut=1
		call GetCutDetails()
		! end of RECALCCUTDTLS
	Case "GETNETPRICE" ! get data - calc netprice			doc=QTL-GetNetPrice.doc
		returnstatus=1
		message$="OK"
		NTPRICE=1;NTCOST=0
		call GetNetPrcCost()
		! end of GETNETPRICE
	Case "GETNETCOST" ! get data & calc netcost				doc=QTL-GetNetCost.doc
		returnstatus=1
		message$="OK"
		NTPRICE=0;NTCOST=1
		call GetNetPrcCost()
		! end of GETNETCOST
	Case "GETSPRODDTLS" ! get data for 1 prod(list entry)
		! to be more PM like - data (supersede,broken,avail,um,etc)
		returnstatus=1
		message$="OK"
		call SprodDtl()
		! end of getsproddtls
	Case "AMALGPRICES" !							doc=QTL-amalgprices.doc
		returnstatus=1
		message$="OK"
		call prcamalg()
		! end of amalgprices
	Case "PRODUCECPIALERTS" !				doc=QTL-ProduceCPIAlerts.doc
		! this is called after CPI exceptions have been
		! sent to the web and the operator has approved
		! or not approved the exception lines
		returnstatus=1
		message$="OK"
		call ProduceCPIAlerts()
	! next case
  End Select
  if debugdetail
		dmsg$="End of Program SERPQTEL" \ Call updatelog(debug)
  Endif
else
 include "src/callmainerrnet.inc"
end try
end  ! end of Main
!
!--------------------------------------------------------------------

! subs start now
!------------------------------------------------------------------------------------------
Sub OpenFiles()

 Try
    !
	CTLC = OpenFile(-9999,intCo) \ If CTLC = -1 Error 42 !control
	PRC = OpenFile(1792,intCo) \ If PRC = -1 Error 42 ! prod
	PWC = OpenFile(1744,intCo) \ If PWC = -1 Error 42 ! prodwhse
	CCC = OpenFile(-1728,intCo) \ If CCC = -1 Error 42 ! u/m codes file
	OHC = OpenFile(1280,IntCo) \ if ohc = -1 Error 42 ! order header
	OSC = OpenFile(1392,IntCo) \ if osc = -1 Error 42 ! order shipto
	OTC = OpenFile(2656,IntCo) \ if otc = -1 Error 42 ! order totals
	OLC = OpenFile(1344,IntCo) \ if olc = -1 Error 42 ! order lines
	NSC = OpenFile(1424,IntCo) \ if nsc = -1 Error 42 ! non-stock lines
	CMC = OpenFile(-2288,IntCo) \ if cmc = -1 Error 42 ! commod code(HEAD)
	LPC = OpenFile(-1376,IntCo) \ if lpc = -1 error 42 ! lastprice
	splc = OpenFile(-1936,IntCo) \ if splc=-1 Error 42 ! special price
	cphc = OpenFile(-2880,IntCo) \ if cphc = -1 Error 42 ! contr head
	btc = OpenFile(-1952,IntCo) \ if btc = -1 Error 42 ! break tbl chann
	CUC = OpenFile(1808,IntCo) \ if cuc = -1 Error 42 ! customer
	WHI = OpenFile(-2768,IntCo) \ if whi = -1 Error 42 ! whinfo
	PLTC=OpenFile(2528,IntCo) \ if PLTC = -1 Error 42 ! PRODLOT
	SLTC=OpenFile(2320,IntCo) \ if SLTC = -1 Error 42 ! SORDLOT
	If p61$[136,136]="Y"
		ch_curr=OpenFile(-9712,IntCo) \ if ch_curr = -1 Error 42 
	endif

	! set up fleptr for price
	fleptr[1,0]=prc;fleptr[2,0]=pwc;fleptr[3,0]=cmc
	fleptr[4,0]=lpc;fleptr[5,0]=splc;fleptr[6,0]=cphc
	fleptr[7,0]=ccc;fleptr[8,0]=btc
	if debugdetail
		dmsg$="Files Opened" \ Call updatelog(debug)
    Endif
 else
    include "src/callsuberr.inc"
  end try
end sub ! openfiles


Sub NSDefault()
!-------------------------------------------------------------------
! defaults for nonstock items
 try
	Dim keymat$[2],kcm$[40],field$[1,30]
	Dim udan$[14],WUDAN$[70]
	dim 1%,ch_matc
	dim 3%,rec_mat
	ReturnStatus=1
	Message$="OK"
	mAT rEAD #ctlc,68,182;WUDAN$; ! uda field names
  ! unit of measure droplist  *** keep this section ****
  clear list$[]
  if not (CCC)
	ccc = OpenFile(-1728,intCo) \ If ccc= -1 Error 42  !u/m codes file
  endif
  clear tmp$ ! send other flag
  Clear Field$[]
	!if p9$[20,20]="F" let tmp$="F"
	let tmp$="F"
	!call filedroplistccodes(e$,list$[],maxcnt,CCC)
	call filedroplistccodesz(e$,list$[],maxcnt,CCC,"",Field$[],1,"",tmp$)
  call AddToStr(e$,rstr$,List$[])

  ! section 2
  
  clear list$[]
  List$[0] = bsdel$,"NSDEFAULT",fdel$
  Webstr$="ComId",fdel$,"CommDesc",fdel$
  Webstr$=webstr$,"ProdCatId",fdel$,"ProdCatName",fdel$
  Webstr$=webstr$,"MatID",fdel$,"MatName",fdel$
  webstr$=webstr$,"VendFlag",fdel$
  webstr$=webstr$,"BuildFlag",fdel$
  webstr$=webstr$,"EditProdCat",fdel$
  webstr$=webstr$,"MiscCostSec",fdel$
  webstr$=webstr$,"UDA 1",fdel$ !
  webstr$=webstr$,"UDA 2",fdel$ !
  webstr$=webstr$,"UDA 3",fdel$ !
  webstr$=webstr$,"UDA 4",fdel$ !
  webstr$=webstr$,"UDA 5",fdel$ !
  list$[1]=webstr$
  if not(prc)
	PRC = OpenFile(-1792,intCo) \ If PRC = -1 Error 42  !product file 
  endif
  let prodkey$="Z ZZZZZZZZZZ"
  PRR = filegetprod(e$,PRC,"=",1,Prodkey$,PR.)
  clear e$
  if prr>0
	if not(cmc)
		cmc = OpenFile(-2288,IntCo) \ If cmc = -1 Error 42 ! commod code(HEAD)
	endif
	let kcm$=PR.ComdtyCode$+Blank$[1,4];kcm$[5]="" ! pr.A$[152,155]
	CMR = filegetcommhead(e$,cmc,"=",1,KCM$,cmc.)
	clear e$
	if cmr<=0
		clear cmc.
		returnstatus=0;message$="Default Commodity not found"
	endif
	if not(ch_psc)
		 ch_psc = OpenFile(-1984,IntCo) \ If ch_psc = -1 Error 42 ! prod sales category
	endif
	if pr.ProdCat>0 and pr.ProdCat<=(chf(ch_psc)-1)
		read record #ch_psc,pr.ProdCat;psc.;
	else
		clear psc.
		returnstatus=0;message$="Default Sales Category not found"
	endif
	if not(ch_matc)
		ch_matc = OpenFile(-2272,IntCo) \ If CH_matc = -1 Error 42 ! material code
	endif
	keymat$=pr.MatCode$ ! only 1 character key
	rec_mat= filegetmatcode(e$,ch_matc,"=",1,keymat$,matc.)
	clear e$
	if rec_mat<=0
		clear matc.
		returnstatus=0;message$="Default Mat Code not found"
	endif
  else
	clear pr.
	clear cmc.
	clear psc.
	clear matc.
	returnstatus=0;message$="Non-Stock Default Product not set up!"
  endif
  Webstr$=rtrim$(PR.ComdtyCode$),fdel$ ! "ComId"
  Webstr$=webstr$,rtrim$(cmc.CodeDescription$),fdel$
  Webstr$=webstr$,str$(pr.ProdCat),fdel$ ! "ProdCatId"
  webstr$=webstr$,rtrim$(psc.CategoryDesc$),fdel$
  Webstr$=webstr$,rtrim$(pr.MatCode$),fdel$
  webstr$=webstr$,rtrim$(matc.Description$),fdel$
  webstr$=webstr$,p61$[31,31],fdel$
  tmp$="N" ! quotes - no nonstk to product
  ! if p61$[85,85]="Y" let tmp$="Y"
  if credit or source=239 or source=207 let tmp$="N" ! not on credits or inquiry!
  webstr$=webstr$,tmp$,fdel$
  let tmp$="Y" \if p61$[128,128]="N" let tmp$="N" ! edit prod cat
  webstr$=webstr$,tmp$,fdel$
  let tmp3=0 ! ALWAYS ZERO - NOT USED IN QUOTES
  !if p61$[132,132]="Y" and nsfmcode<>0
  !	let tmp3=cost_lev[1]
  !endif
  webstr$=webstr$,str$(tmp3),fdel$
  ! add 5 uda fields
   udan$=WUDAN$[1,14] \ if rtrim$(udan$)="" let udan$="NS UDA 1"
  webstr$=webstr$,RTrim$(udan$),fdel$ !
	udan$=WUDAN$[15,28] \ if rtrim$(udan$)="" let udan$="NS UDA 2"
  webstr$=webstr$,RTrim$(udan$),fdel$ !
	UDAN$=WUDAN$[29,42] \ if rtrim$(udan$)="" let udan$="NS UDA 3"
  webstr$=webstr$,RTrim$(udan$),fdel$ !
	udan$=WUDAN$[43,56] \ if rtrim$(udan$)="" let udan$="NS UDA 4"
  webstr$=webstr$,RTrim$(udan$),fdel$ !
	udan$=WUDAN$[57,70] \ if rtrim$(udan$)="" let udan$="NS UDA 5"
  webstr$=webstr$,RTrim$(udan$),fdel$ !
  List$[2] = WebStr$
  Call AddToStr(e$,rstr$,List$[])             
  Call AddToStr(e$,rstr$,esdel$) ! end of section   
	if returnstatus=1 let message$="OK" ! set if no other problems
	if debugdetail
		dmsg$="Non-Stock Default "+Message$ \ Call updatelog(debug)
	Endif
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
 else
	include "src/callsuberr.inc"
 end try
End sub !NSDEFAULT
!---------------------------------------------------------------------
Sub NSsaveitem()
!--------------------------------------------------------------------
! save a nonstock item -- adding line **** SHOULD HAVE THE CUSTOMER ALREADY /user id
 try
	dim 1%,tmptax,2%,nsfmcode
	dim 3%,k1$[60]
	dim nrol. as qol
	Dim cnstk. As qproddesc 
	dim tax. as taxcode
	clear rol.
	clear nstk.
	clear nrol.
	clear cnstk.
	Dim x$[20],NSFKey$[60]       
	Dim 1%,CNVTU[2],FLAG[9],X1[9]            
	Dim 1%,NewLn,HFlg[16],CREDIT             
	Dim 2%,X2[9],NumLines,ShipDate,JDATE[5]  
	Dim 3%,CNVTA,Amount,X3[9],V3[99]         
	Dim 3%,Whbld[3],S9[20] 
	let nsfmcode=0
	!if p61$[132,132]="Y"
	!	mat read #ctlc,52,104;nsfmcode;
	!endif
	If debugdetail                                         
		dmsg$ = "Start NonStock Line Update" \ Call updatelog(debug)  
	End If                                                 
	ReturnStatus = 1                                       
	Message$ = "OK"                                        
	Call dxget("ORDERID",tmp$)                             
	If tmp$ = "" Goto NSUDLDone                              
	orderno = tmp$                                         
		If orderno < 1 Or orderno > 999999 Or Fra(orderno)     
		 ReturnStatus = 0                                     
		Message$ = "ORDER NUMBER INVALID"                    
		Goto NSUDLDone                                         
	End If                                                 
	OHR = GetOrdRec(e$,OHC,OSC,otc,orderno,roh.,ros.,rot.) 
	If OHR <= 0 ! not found                                
		ReturnStatus = 99                                     
		Message$ = "ORDER WAS NOT FOUND"                     
		Goto NSUDLDone 
	endif
	if returnstatus<>0
			credit = 0 \ if ros.status=32 let credit=1
			call verifystat()
			if returnstatus=99  Goto NSUDLDone 
	endif
	ZLine = 0;NonStk = 0;stk = 0;delline = 0;cutline=0
	credit = 0 \ if ros.status=32 let credit=1
	Call dxget("LTYPE",tmp$)
	tmp$ = UCase$(tmp$)
	if tmp$<>"NSTK"
		returnstatus=0
		Message$="Order Line has Invalid Line Type. Not a non-stock item."
		goto nsudldone:
	endif
	If tmp$[1,4] = "NSTK" Let NonStk = 1
	let prodkey$="Z ZZZZZZZZZZ" ! let's see if z item is on file!
	PRR = filegetprod(e$,PRC,"=",1,Prodkey$,PR.)
	if prr<=0
		returnstatus=0;message$="Can not update. Non-Stock Default Product not set up!"
		goto nsudldone
	Endif ! of no Z prod / abort
	Call DXGet("LN",tmp$) ! +Str$(X1),tmp$)
	let rol.linenum=tmp$
	If rol.LineNum ! get prev data                 
		rolkey$ = " ",rolkey$                         
		rolkey$[1,6] = orderno Using "######"         
		rolkey$[7,9] = rol.LineNum Using "###"       
		rolkey$[11] = "" ! cut to length (space @ 10) 
		OLR = filegetqolz(e$,OLC,"=",1,rolkey$,rol.)
		clear e$
		If OLR <= 0 ! what do we do if not found?     
			Clear rol.
			Clear nstk.
			Clear nrol.
			clear cnstk.
			!nrol.SpareNU$ = Blank$;X0=LEN(nrol.SpareNU$)
			!IF X0>1
			!	nrol.SpareNU$[X0-1] = ""  ! for the key
			!ENDIF
			NEWLN=1
		 End If                                        
		If OLR > 0  
			read record #olc,olr,0;nrol.
			If rol.NStkItem = 1 And rol.LineType <> 3   
				nsr = rol.PDRecNum                        
				Read Record #nsc,nsr,0;nstk.
				read record #nsc,nsr,0;cnstk.
				PRR = 0;PWR = 0 
			End If
			IF rol.NStkItem <> 1
				returnstatus=0
				Message$="Existing Order Line Is Not A Non-Stock Item."
				goto nsudldone:
			End If  
		Endif
	ELSE
		let olr=-1
		Clear rol.
		Clear nstk.
		Clear nrol.
		clear cnstk.
		!nrol.SpareNU$ = Blank$;X0=LEN(nrol.SpareNU$)
		!	IF X0>1
		!		nrol.SpareNU$[X0-1] = ""  ! for the key
		!	ENDIF
		NEWLN=1
	Endif
	if NEWLN=1 and roh.ordtype=15 and roh.boctr<>0 ! no add
		returnstatus=0
		message$="Invoice has been accepted. No new lines allowed"
		goto nsudldone
	Endif
	 nrol.Status = 11;CREDIT = 0                                               
	If ros.Status = 32 Let nrol.Status = 12;CREDIT = 1 ! determine order/credi
 	nrol.OrdNum = orderno 
	cnstk.OrdNum = orderno
	Call dxget("DESC1",tmp$) ! +Str$(X1),tmp$)  
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Description 1"
		goto nsudldone
	Endif
	nrol.Desc1$ = tmp$ + Blank$
	cnstk.desc1$ = nrol.desc1$
	Call dxget("DESC2",tmp$) ! +Str$(X1),tmp$) 
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Description 2"
		goto nsudldone
	Endif
	nrol.Desc2$ = tmp$ + Blank$  
	cnstk.desc2$=nrol.desc2$
	Call dxget("WHSE",tmp$) ! +Str$(X1),tmp$)                                 
	nrol.Whse = tmp$ \ If nrol.Whse < 1 Or nrol.Whse > 99 Let nrol.Whse = roh.wh
	if roh.OrdType=16 Let nrol.Whse = roh.wh ! NO WHSE CHANGE!
    Let nrol.UpdtStk = 0 ! stock update is 0 for non-stocks
	
	Call dxget("UPRICE",tmp$) ! +Str$(X1),tmp$)   
	V3[1] = tmp$
	If V3[1]<0 or V3[1]>9999999
		e$="Price is out of range"
		returnstatus=0
		goto nsudldone
	Endif
	nrol.PriceOrigin=-7;rol.PriceOrigin=-7 ! manual entry
	Call dxget("UCOST",tmp$) ! +Str$(X1),tmp$)    
	V3[2] = tmp$
	If V3[2]<0 or V3[2]>9999999
		e$="Cost is out of range"
		returnstatus=0
		goto nsudldone
	Endif
	nrol.CostOrigin=-1;rol.CostOrigin=-1 ! manual cost
	Call dxget("LDISC",tmp$) ! +Str$(X1),tmp$)    
	nrol.LineDiscPct = tmp$  
	Call dxget("UNCUBE",tmp$) ! +Str$(X1),tmp$)   
	nrol.CubeUnit = tmp$ \if not(nrol.CubeUnit) let nrol.CubeUnit=1 
	if nrol.cubeunit<0 or nrol.cubeunit>99999
		e$="Cube Unit is out of range"
		returnstatus=0
		goto nsudldone
	Endif
	Call dxget("UNLBS",tmp$) ! +Str$(X1),tmp$)   ! weight 
	nrol.LbsUnit = tmp$ \if not (nrol.LbsUnit) let nrol.Lbsunit=1
	if nrol.lbsunit<0 or nrol.lbsunit>99999
		e$="Pound Unit is out of range"
		returnstatus=0
		goto nsudldone
	Endif
	Call dxget("TAXFLG",tmp$) ! +Str$(X1),tmp$)
	if ucase$(tmp$)="N" let tmp$="0"
	if ucase$(tmp$)="Y" let tmp$="1"
	nrol.TaxFlg = tmp$ ! y/n or code
	if nrol.taxflg<0 
			returnstatus=0
			message$="Tax code is out of range"
			goto nsUDLDone
	Endif
	Call dxget("DEPT",tmp$) ! +Str$(X1),tmp$)      
	nrol.Dept = tmp$                               
	Call dxget("QTYORD",tmp$) ! +Str$(X1),tmp$)    
	V3[3] = tmp$
	X1=roh.ordtype
	if V3[3]<0 and (credit Or (x1=4 or x1=7 or x1=8 or x1=15 or x1=16 or x1=24))
		E$="No Negative Order Quantity allowed"
		returnstatus=0
		goto nsudldone
	Endif
	If ABS(V3[3])>9999999999
		e$="Order Quantity out of range"
		returnstatus=0
		goto nsudldone
	Endif
	Call dxget("QTYBO",tmp$) ! +Str$(X1),tmp$)     
	V3[4] = tmp$ 
	If ABS(V3[4])>9999999999
		e$="Back Order Quantity out of range"
		returnstatus=0
		goto nsudldone
	Endif
	Call dxget("QTYSHIP",tmp$) ! +Str$(X1),tmp$)   
	V3[5] = tmp$  ! for ot15 this is relqty! 
	! if v3[5]<0 and V3[5]<>v3[3] let v3[3]=v3[5] ! no ship more than order
	if v3[3]<0 let v3[4]=0;v3[5]=v3[3] ! always! MAKE SHIP=ORDER/NO BO
	If ABS(V3[5])>9999999999
		e$="Ship Quantity out of range"
		returnstatus=0
		goto nsudldone
	Endif
	if roh.ordtype=4 ! order type 4 - needs BILLQTY
		call dxget("CURRBILL",tmp$)
		if rtrim$(tmp$)<>"" ! sent it - otherwise ignore
			V3[10]=tmp$
			if v3[3]<0 and v3[10]>0 ! neg line - pos bill? NO
				returnstatus=0
				message$="Can not have positive Bill quantities!"
				goto NSUDLDone
			Endif
			if v3[10]<0 ! neg bill allowed
				if nrol.PrevQtyBill<=0 or ABS(v3[10])>nrol.PrevQtyBill
					returnstatus=0
					message$="Negative Bill quantity is invalid!"
					goto nsudldone
				Endif
			Endif
		Endif ! sent data
		! ON PM Native - it allows overbill with just a prompt
		! check it below (when base)
	Endif ! bill qty - OT4
	Call dxget("PUPCHG",tmp$) ! +Str$(X1),tmp$)    
	V3[6] = tmp$                                   
	Call dxget("PUPTYPE",tmp$) ! +sTR$(X1),tmp$)   
	x$ = tmp$                                      
	If x$ = "$" ! $ is <0  percent is >=0          
		nrol.UpChrg = 0 - V3[6] ! may need convert   
	Else                                           
		nrol.UpChrg = V3[6]                          
	End If 
	Call dxget("UMSELL",tmp$) ! +Str$(X1),tmp$)     
    ! If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R <> 0 Let tmp$ = Str$(R)                  
	! End If                                          
	X2 = tmp$
	if x2<0 ! system um - not on Qty
		e$="Sell UM is not valid"
		returnstatus=0
		goto nsudldone
	Endif
	pr.UmSellDefault=x2
	nrol.UMSell = X2 ! tmp$
	Call dxget("UMPRICE",tmp$) ! +Str$(x1),tmp$)                              
	! If tmp$[1,1] > "9" ! sent text?                                           
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)                                     
		If R <> 0 Let tmp$ = Str$(R)                                            
	! End If                                                                    
	X2 = tmp$                                                                 
  	nrol.UMPrice = X2 ! tmp$
	Call dxget("UMCOST",tmp$) ! +Str$(X1),tmp$)      
    ! If tmp$[1,1] > "9" ! sent text?                  
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)            
		If R <> 0 Let tmp$ = Str$(R)                   
	! End If                                           
	X2 = tmp$                                        
        nrol.UMCost = X2 ! tmp$
	Call dxget("VENDITM",tmp$) ! +Str$(X1),tmp$)
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Vendor Item"
		goto nsudldone
	Endif
	nrol.VendItemCode$ = ucase$(tmp$) + Blank$
	Call dxget("NETPRC",tmp$) ! +Str$(x1),tmp$)     
	V3[7] = tmp$ ! nrol.NetPrice
	if v3[7]<0 or ABS(V3[7])>9999999999
		e$="Price is out of range"
		returnstatus=0
		goto nsudldone
	Endif
	Call dxget("PPFLAG",tmp$) ! +Str$(X1),tmp$) 
	if ucase$(tmp$)="FALSE" let tmp$="0"
	if ucase$(tmp$)="TRUE" let tmp$="1"
	tmp$="0" ! NOT USED IN Quotes!
	nrol.NewPPFlg = tmp$ ! (s/b 0 or 1)             
	Call dxget("HIDE291",tmp$) ! +Str$(X1),tmp$)
	If ucase$(tmp$)="Y" let tmp$="1"
	if ucase$(tmp$)="N" let tmp$="0"
	If RTrim$(tmp$)<>"" ! only if sent
		X2 = tmp$                                       
		If X2 = 0 Or X2 = 1 Let nrol.LinePrint = X2     
		If nrol.LinePrint = 0 ! not printed             
		 nrol.PrintDate = 0                            
		 nrol.PrintTime = 0                            
		End If
	Endif
	Call dxget("CUPCHG",tmp$) ! +Str$(X1),tmp$)     
	V3[8] = tmp$                                    
	Call dxget("CUPTYPE",tmp$) ! +Str$(X1),tmp$)    
	x$ = tmp$                                       
	If x$ = "$" ! $ is <0  % is >=0                 
	 nrol.LoadUpchrg = 0 - V3[8]                   
	Else                                            
	nrol.LoadUpchrg = V3[8]                       
	End If

	Call dxget("COMMD",tmp$) ! +Str$(X1),tmp$)  
	nrol.ComdtyCode$ = tmp$ + Blank$            
	Call dxget("BUYER",tmp$) !+Str$(X1),tmp$)   
	Cnstk.Buyer = tmp$                           
	Call dxget("MATCD",tmp$) !+Str$(X1),tmp$)   
	nrol.MatCode$ = tmp$ + Blank$               
	Call dxget("SLSCAT",tmp$) !+Str$(X1),tmp$)  
	nrol.PSlsCat = tmp$                         
	Call dxget("VENDOR",tmp$) ! +Str$(X1),tmp$) 
	nrol.Vendor = tmp$                          
	Call dxget("PONUM",tmp$)                    
	nrol.PONum = tmp$                           
	Call dxget("MSDS",tmp$) ! +Str$(X1),tmp$)   
	nrol.MSDSNo = tmp$                          
	Call dxget("GLCOST",tmp$) !+Str$(X1),tmp$)  
	 V3[9] = tmp$                                
	If V3[9]<0 or ABS(V3[9])>9999999999
		e$="GL Cost is out of range"
		returnstatus=0
		goto nsudldone
	Endif   
	Call dxget("UMBASE",tmp$) !+Str$(X1),tmp$)   
	! If tmp$[1,1] > "9" ! sent text?              
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)        
		If R <> 0 Let tmp$ = Str$(R)               
	! End If                                       
	nrol.UMBase = tmp$                           
	Call dxget("UMPURCH",tmp$) !+Str$(X1),tmp$)  
	! If tmp$[1,1] > "9" ! sent text?              
		 R = getumrec(e$,ccc,tmp$,IntCo,PR.)        
		If R <> 0 Let tmp$ = Str$(R)               
	! End If                                       
	nrol.UMPurch = tmp$                          	
	! end new fields
	 Call dxget("SELLFCTR",tmp$) !+Str$(X1),tmp$)   
	 nrol.SellFactor = tmp$  \if nrol.SellFactor<=0 let nrol.SellFactor=1                       
	Call dxget("PRCFCTR",tmp$) !+Str$(X1),tmp$)    
	 nrol.PriceFactor = tmp$   \if nrol.PriceFactor<=0 let nrol.PriceFactor=1                     
	 Call dxget("COSTFCTR",tmp$) !+Str$(X1),tmp$)   
	 nrol.CostFactor = tmp$    \ if nrol.CostFactor<=0 let nrol.CostFactor=1                     
	 Call dxget("PURCHFCTR",tmp$) !+Str$(X1),tmp$)  
	nrol.PurchFactor = tmp$     \ if nrol.PurchFactor<=0 let nrol.PurchFactor=1 
	
	Call dxget("UMCUBE",tmp$) !+Str$(X1),tmp$)   
	! If tmp$[1,1] > "9" ! sent text?              
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)        
		If R <> 0 Let tmp$ = Str$(R)               
	! End If
	!nrol.CubeFactor=tmp$
	!if nrol.CubeFactor<=0 let nrol.CubeFactor=1
	nrol.cubefactor=1
	if R=nrol.umbase
		let nrol.cubefactor=1
	else
		if r=nrol.UMSELL
			let nrol.cubefactor=nrol.sellfactor
		else
			if r=nrol.umprice
				let nrol.cubefactor=nrol.pricefactor
			else
				if r=nrol.umcost
					let nrol.cubefactor=nrol.costfactor
				else
					if r=nrol.umpurch
						let nrol.cubefactor=nrol.purchfactor
					endif
				endif
			endif
		endif
	endif
        
	Call dxget("UMLBS",tmp$) !+Str$(X1),tmp$)    
	! If tmp$[1,1] > "9" ! sent text?              
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)        
		If R <> 0 Let tmp$ = Str$(R)               
	! End If 
	!nrol.wgtfactor=tmp$
	!if nrol.wgtfactor<=0 let nrol.wgtfactor=1
	nrol.wgtfactor=1
	if R=nrol.umbase
		let nrol.wgtfactor=1
	else
		if r=nrol.UMSELL
			let nrol.wgtfactor=nrol.sellfactor
		else
			if r=nrol.umprice
				let nrol.wgtfactor=nrol.pricefactor
			else
				if r=nrol.umcost
					let nrol.wgtfactor=nrol.costfactor
				else
					if r=nrol.umpurch
						let nrol.wgtfactor=nrol.purchfactor
					endif
				endif
			endif
		endif
	endif
    ! added - 5 UDA Fields!
	Call dxget("UDA1",tmp$)
	let cnstk.NS_UDA1=tmp$ ! whatever sent
	Call dxget("UDA2",tmp$) ! +Str$(X1),tmp$)  
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in UDA 2"
		goto nsudldone
	Endif
	cnstk.NS_UDA2$ = tmp$+Blank$
	Call dxget("UDA3",tmp$) ! +Str$(X1),tmp$)  
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in UDA 3"
		goto nsudldone
	Endif
	cnstk.NS_UDA3$ = tmp$+Blank$
	Call dxget("UDA4",tmp$) ! +Str$(X1),tmp$)  
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in UDA 4"
		goto nsudldone
	Endif
	cnstk.NS_UDA4$ = tmp$+Blank$
	Call dxget("UDA5",tmp$) ! +Str$(X1),tmp$)  
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in UDA 5"
		goto nsudldone
	Endif
	cnstk.NS_UDA5$ = tmp$+Blank$
    cnstk.SpareNU$ = Blank$ ! used for key space
	clear cnstk.Spare$ ! dl4 fix ! cnstk.Spare$ = Blank$  
	! get hazardous info
	CALL DXGET ("HAZFLG",tmp$) ! hazardous flag
	let cnstk.hazflg=0
	if tmp$="Y" let cnstk.hazflg=1 ! yes
	if tmp$="S" let cnstk.hazflg=2 ! shipping
	if not (cnstk.hazflg)
		cnstk.HazFileRecno=0                               
		cnstk.HazClass$=blank$                                   
		cnstk.PackGrp$=blank$                                    
		cnstk.DotID$=blank$                                      
		cnstk.ERGdbk$=blank$                                     
	else
		Call Dxget ("HAZID",tmp$) ! hazardous id
		if not (ch_haz)
			Ch_Haz = openfile(-2784,intCo) \ If Ch_Haz = -1 Error 42 ! hazar
		endif
		let rec_haz=filegethazname(e$,ch_haz,"=",1,tmp$,haz.)
		clear e$
		if rec_haz>0
			cnstk.HazFileRecno=rec_haz
		else
			cnstk.HazFileRecno=0
		endif
		Call Dxget ("HAZCLASS",TMP$) ! HAZ CLASS
		LET cnstk.hazclass$=tmp$+BLANK$
		call dxget ("PACKGROUP",tmp$) ! 
		let cnstk.packgrp$=tmp$+blank$
		call dxget ("DOTID",tmp$)
		let cnstk.dotid$=tmp$+blank$
		call dxget ("ERBOOK",tmp$)
		let cnstk.ERGdbk$=tmp$+blank$
	endif
	If nrol.LineNum = 0 
		let cnstk.CurrFrtCost=0
		let cnstk.PrevFrtCost=0
	endif
	!if p61$[132,132]="Y" and cost_lev[1]<>0 and nsfmcode<>0
	!	call dxget("CURRFRTCOST",tmp$)
	!	let cnstk.CurrFrtCost=tmp$
	!endif
	 If nrol.LineNum = 0 ! new line         
		 nrol.LineNum = getnxtline(orderno)
		 rol.linenum=nrol.linenum
		 rol.Dept=roh.Dept
		 ! nrol.dept=roh.dept
		 rol.NStkItem=1
		 nrol.NStkItem=1
		 nrol.UpdtStk=0 
		 rol.UpdtStk=0
		 rol.slsm=roh.slsm
		 nrol.slsm=roh.slsm
		 etr.EtAction = 11 ! new              
		 rol.UMBase = nrol.UMBase         
		 rol.UMSell = nrol.UMSell         
		 rol.UMCost = nrol.UMCost         
		rol.UMPrice = nrol.UMPrice       
		rol.UMPurch = nrol.UMPurch       
		rol.SellFactor = nrol.SellFactor 
		rol.PriceFactor = nrol.PriceFactor
		rol.CostFactor = nrol.CostFactor 
		rol.PurchFactor = nrol.PurchFactor
		rol.CubeFactor = nrol.CubeFactor 
		rol.WgtFactor = nrol.WgtFactor
		nrol.SpareNU3$=blank$
		nrol.KitDesignation$=blank$
		nrol.LineType=0
		nrol.RepairLine$=blank$
		nrol.OrgProdCode$=blank$
		nrol.HldForPo$=blank$
		nrol.SpareNU1$=blank$
		if p61$[136,136]="Y"
			let rol.currid=roh.currid
			let rol.currfact=roh.currfact
			let nrol.currid=roh.currid
			let nrol.currfact=roh.currfact
		endif
		
		v3[7]=v3[1] ! set the net price to unit price
		v3[5]=v3[3] ! set qty ship = to qty ord
		v3[4]=0 ! set qty bo to zero
		!if p61$[76,76]="Y" and NOT(CREDIT) ! auto bo nonstk
		!	let v3[4]=v3[3];v3[5]=0 ! bo=ord,ship=0
		!Endif - per erg - not on quotes
		PRR = 0;PWR = 0                  
		! set up / add nonstk                                           
		cnstk.OrdNum = nrol.OrdNum                                       
		cnstk.LineNum = nrol.LineNum                                     
		!nstk.OrdLineRec not known yet                                  
		cnstk.Desc1$ = nrol.Desc1$                                       
		cnstk.Desc2$ = nrol.Desc2$                                       
		cnstk.PSlsCat = nrol.PSlsCat                                     
		! nstk.QtyShip  nstk.UnitCost  nstk.UnitPrice                   
		nrol.ProdCode$ = roh.OrdNum Using "######"                      
		nrol.ProdCode$ = nrol.ProdCode$ + "-" + nrol.LineNum Using "&&&"
		nrol.ProdCode$ = nrol.ProdCode$ + Blank$                        
		cnstk.ProdCode$ = nrol.ProdCode$                                 
		cnstk.ComdtyCode$ = nrol.ComdtyCode$                             
		cnstk.Unused$ = Blank$                                           
		cnstk.SpareNU$ = Blank$ 
		! added UDA entry above!	
		clear cnstk.spare$ ! dl4 fix !cnstk.Spare$ = Blank$[1,10]                                            
		nsr = fileupdateqproddesc(e$,nsc,"a",0,cnstk.) 
		If nsr > 0                                                    
			 nrol.PDRecNum = nsr                                         
		 Else                                                          
			 e$ = "NONSTOCK " + nrol.ProdCode$ + " FILE NOT ADDED"       
		 End If                                                        
		if not(prc)
			PRC = OpenFile(-1792,intCo) \ If PRC = -1 Error 42  !product file 
		endif
		  let prodkey$="Z ZZZZZZZZZZ" ! let's set up tax now-as it's new!
		  PRR = filegetprod(e$,PRC,"=",1,Prodkey$,PR.)
		  clear e$
		  if prr>0
			K1$=roh.CustNum Using "######"
			ProdKey$=nrol.ProdCode$
			ProdKey$=nrol.VendItemCode$ ! as it's stored that way in lastprice
			Call TaxFlag(k1$,ProdKey$,ros.ShipCust,ros.ShipCode,rol.Dept,pr.TaxType,intco,roh.TaxCode,ros.ShipTaxType,Taxback)
			Nrol.TaxFlg=Taxback ! contains what's needed
			If P60$[42,42]<>"Y" ! has y/n only - get rate from header tax
				TaxNo=roh.TaxCode
			Else ! is a code
				TaxNo=nrol.TaxFlg
			Endif
			If TaxNo>0
				Tcc=Openfile(-2176,IntCo) \ if Tcc = -1 Error 42
				Read record #tcc,taxno,0;tax.;
				Close #tcc
			Else ! no taxcode
				clear tax.
			Endif
			nrol.TaxPct=tax.TaxRate
		  Else
			returnstatus=0;message$="Can not add. Non-Stock Default Product not set up!"
			goto nsudldone
		  Endif ! of got a Z prod / do tax
	End If ! of newline    
	If rol.WgtFactor <= 0 Let rol.WgtFactor = 1                     
	If nrol.WgtFactor <= 0 Let nrol.WgtFactor = 1                   
	rol.LbsUnit = nrol.LbsUnit ! update to current (lb based items) 
	 ! so nrol. has new, rol. has orig                                  
	Call setprtorol() ! set to rol. factors                            
	! convert sent to base as sent in display um  
	! PRICES
	If p61$[136,136]="Y" and rol.currfact<>0 ! nssave
			if v3[1]<>0 ! unit price
				let cnvcu[0]=2
				let cnvcu[1]=1 ! no rounding 
				let cnvca[0]=v3[1]
				cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[1]=cnvca[0]
			endif
			! convert cost to base
			if v3[2]<>0 ! unit cost
				let cnvcu[0]=2
				let cnvcu[1]=1 ! no rounding 
				let cnvca[0]=v3[2]
				cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[2]=cnvca[0]
			endif
			if v3[6]<0 ! price upcharge $
				let cnvcu[0]=2
				let cnvcu[1]=1 ! no rounding 
				let cnvca[0]=v3[6]
				cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[6]=cnvca[0]
			endif
			if v3[7]<>0 ! net price
				let cnvcu[0]=2
				let cnvcu[1]=1 ! no rounding 
				let cnvca[0]=v3[7]
				cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[7]=cnvca[0]
			endif
			if v3[8]<0 ! cost upcharge $
				let cnvcu[0]=2
				let cnvcu[1]=1 ! no rounding 
				let cnvca[0]=v3[8]
				cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[8]=cnvca[0]
			endif
			if v3[9]<>0 ! gl cost
				let cnvcu[0]=2
				let cnvcu[1]=1 ! no rounding 
				let cnvca[0]=v3[9]
				cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[9]=cnvca[0]
			endif
		endif
	CNVTU[0] = nrol.UMPrice;CNVTU[1] = 0;CNVTU[2] = 6 ! to base no round was =2 
	If v3[1]
		CNVTA = V3[1] \ if nrol.UMPrice>0 and nrol.NumOut>0 let cnvta=v3[1]*nrol.numout                                                       
		nrol.UnitPrice = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)  
	else
		nrol.UnitPrice=0
	endif
	if v3[7]
		CNVTU[0] = nrol.UMPrice;CNVTU[1] = 0;CNVTU[2] = 6 ! to base no round was =2 
		CNVTA = V3[7]  \ if nrol.UMPrice>0 and nrol.NumOut>0 let cnvta=v3[7]*nrol.numout                                                    
		nrol.NetPrice = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	else
		nrol.netprice=0
	endif
	if nrol.upchrg
		If nrol.UpChrg < 0 ! $ amount 
			CNVTU[0] = nrol.UMPrice;CNVTU[1] = 0;CNVTU[2] = 6 ! to base no round was =2 
			 CNVTA = V3[6] ! still +                                          
			X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)              
			nrol.UpChrg = 0 - X3                                             
		End If
	endif
	! costs
	CNVTU[0] = nrol.UMCost;CNVTU[1] = 0;CNVTU[2] = 6 ! to base no round was =2 
	if v3[2]
		CNVTA = V3[2] \ if nrol.UMCost>0 and nrol.NumOut>0 let cnvta=v3[2]*nrol.numout                                                     
		nrol.UnitCost = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	else
		nrol.unitcost =0
	endif
	if nrol.LoadUpchrg  
		If nrol.LoadUpchrg < 0 ! it's a $ up
			CNVTU[0] = nrol.UMCost;CNVTU[1] = 0;CNVTU[2] = 6 ! to base no round was =2 
			CNVTA = V3[8]                                                   
			X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)             
			nrol.LoadUpchrg = 0 - X3                                        
		End If  
	endif
	If V3[9] > 0 ! sent glcost
		CNVTU[0] = nrol.UMCost;CNVTU[1] = 0;CNVTU[2] = 6 ! to base no round was =2 
		CNVTA = V3[9] \ if nrol.UMCost>0 and nrol.NumOut>0 let cnvta=v3[9]*nrol.numout                                                  
		nrol.UnitGLCost = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	else
		nrol.UnitGlCost=0
	End If
	! QUANTITIES
	CNVTU[0] = nrol.UMSell;CNVTU[1] = 0;CNVTU[2] = 1  
	IF V3[3]
		CNVTA = V3[3] \ IF nrol.NumOut>0 let CNVTA=v3[3]/nrol.NumOut                                                    
		nrol.QtyOrd = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	else
		nrol.qtyord =0
	ENDIF
	if v3[4]
		CNVTA = V3[4]  \ IF nrol.NumOut>0 let CNVTA=v3[4]/nrol.NumOut                                                   
		nrol.QtyBO = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	else
		nrol.qtybo=0
	endif
	if v3[5]
		CNVTA = V3[5] \ IF nrol.NumOut>0 let CNVTA=v3[5]/nrol.NumOut                                                    
		nrol.QtyShip = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	else
		let nrol.qtyship=0
	endif
	if v3[3]>0  ! new - ot 4 & 15 can neg relqty - but never neg boqty
	  If v3[4]<0 or (roh.ordtype<>4 and roh.ordtype<>14 and v3[5]<0) ! no mixing
		returnstatus=0
		message$="Can not have negative BO/Ship quantities!"
		goto nsudldone
	  Endif
	  IF V3[5]<0 and (roh.ordtype=4 or roh.ordtype=15)
	    If nrol.PrevQtyShip<=0 or ABS(V3[5])>nrol.PrevQtyShip
			returnstatus=0
			message$="Negative Ship quantity is invalid!"
			goto nsudldone
		Endif
	  Endif
	Endif
	If V3[3]<0 and (v3[4]>0 or V3[5]>0) ! no mixed
		returnstatus=0
		message$="Can not have positive BO/Ship quantities!"
		goto nsudldone
	Endif
	If roh.ordtype=4 ! Curr Billqty
		cnvta=V3[10] \ if nrol.NumOut>0 let cnvta=v3[10]/nrol.numout
		nrol.CurrBillQty=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	Endif
	if roh.ordtype=15 and roh.boctr=0 and olr>0 ! existing line
		!nrol.qtyord=rol.qtyord ! how is new id'd?
		nrol.qtybo=rol.qtybo
		nrol.CurrRelQty=nrol.qtyship ! =rol.qtyship
	Endif
	If roh.ordtype=15 and roh.boctr<>0 ! cannot change qtys,prc/cost,um
		nrol.qtyord=rol.qtyord
		nrol.qtybo=rol.qtybo
		nrol.CurrRelQty=nrol.qtyship ! =rol.qtyship
		nrol.UnitPrice=rol.unitprice
		nrol.netprice=rol.netprice
		nrol.upchrg=rol.upchrg
		nrol.unitcost=rol.unitcost
		nrol.UMPrice=rol.umprice
		nrol.UMCost=rol.umcost
		nrol.UMSell=rol.umsell
		nrol.LoadUpchrg=rol.loadupchrg
	Endif
	If roh.ordtype=4 ! checks are here
		nrol.CurrRelQty=nrol.qtyship ! release is entered as QtyShip
		! PM Native - allows billing>order-prevbill - just an ok Y/N prompt
		! if nrol.currbillqty>nrol.qtyord-nrol.PrevQtyBill ! popup and ok Y/N
		! I guess the front end handles this as we can't here
		if custom_customer$="MORRISETTE"! ques on this
			nrol.CurrBillQty=nrol.CurrRelQty
		Endif
	Endif
	! all sent cost/price/qty now base
	call dolineextens()                             
                                          
	If nrol.UnitPrice <> rol.UnitPrice and nrol.OrgPriceUnit = 0 Let nrol.OrgPriceUnit = rol.UnitPrice  
	If nrol.UnitCost <> rol.UnitCost AND nrol.OrgLoadCost =0 Let nrol.OrgLoadCost = rol.UnitCost      
	If nrol.Whse <> rol.Whse Let nrol.OrgWhse = rol.Whse 
	! SPECIAL TYPE PROCESSING
	if roh.OrdType=8 or roh.OrdType=16 ! cons/trans - no price/cost
		nrol.UnitCost=0;nrol.CostOrigin=0;nrol.RebtContract=0
		nrol.UnitPrice=0;nrol.CutChrg=0;nrol.CutCost=0
		nrol.LineDisc=0;nrol.ExtOrdAmt=0;nrol.ExtShipAmt=0
		nrol.LineDiscPct=0;nrol.ExtCutChg=0;nrol.ExtCutCost=0
		nrol.ExtLoadShip=0;nrol.ExtLoadOrd=0;nrol.NetPrice=0
		nrol.TaxAmt=0;nrol.LoadUpchrg=0;nrol.UpChrg=0
	Endif
	If p61$[46,46]="Y" and Credit and roh.shiptype=3 ! price fix - no cost
		nrol.UnitCost=0;nrol.CostOrigin=0;nrol.RebtContract=0
		nrol.CutCost=0;nrol.ExtCutCost=0;nrol.ExtLoadShip=0;nrol.ExtLoadOrd=0
		nrol.LoadUpchrg=0
	Endif
	if roh.ordtype=15
		!extend in subroutine (was qtybo-borel) - native = bo+borel
		!if nrol.qtyord<>nrol.CurrRelQty+(nrol.QtyBo+nrol.BORelQty)+nrol.PrevQtyShip
		if nrol.qtyord<nrol.CurrRelQty+(nrol.QtyBo-nrol.BORelQty)+nrol.PrevQtyShip
			returnstatus=0
			message$="Quantity is Out of Balance"
			goto nsudldone ! abort update? let's
		Endif
	Endif
	if roh.ordtype=4
		!extend in subroutine (was qtybo-borel) - native = bo+borel
		if nrol.qtyord<nrol.CurrRelQty+(nrol.QtyBo-nrol.BORelQty)+nrol.PrevQtyShip
			returnstatus=0
			message$="Quantity is Over Shipped"
			goto nsudldone ! abort update? let's
		Endif
	Endif
	if custom_customer$="MORRISETTE"
		IF roh.ordtype=4 AND (nrol.CurrRelQty<>0 AND nrol.CurrBillQty=0) ! "CCT 111810 
			LET message$="THERE IS A RELEASE BUT NO BILL AMOUNT"
			returnstatus=0
			goto nsudldone ! abort update? let's
		ENDIF 
	Endif
	If etr.EtAction = 0 ! no check yet                                        
		                   
		If nrol.QtyOrd <> rol.QtyOrd Let etr.EtAction = 1                  
		If nrol.QtyBO <> rol.QtyBO Let etr.EtAction = 1                    
		If nrol.QtyShip <> rol.QtyShip Let etr.EtAction = 1                
		If nrol.UnitPrice <> rol.UnitPrice Let etr.EtAction = 1 ! ;HFlag[4] = 1
	    If nrol.UnitCost <> rol.UnitCost Let etr.EtAction = 1 ! ;HFlag[5] = 1 !
                                                             
	 End If                                                               
	 !If P60$[44,44] = "Y" And etr.EtAction <> 0                           
		! Call EdtTrkDo(rol.,nrol.) ! org, new                               
	 !End If ! of edit tracking                                            
                               
	nrol.PDRecNum = nsr ! non-stk rec #                                
	tmp$ = ShipDate Using "&&&&&&"                                 
	Call DateToJulian(1,tmp$,tmp1$,f)                              
	If f Let tmp1$ = ""                                            
	JDATE[1] = tmp1$;f = 0 ! julian sys shipdate                   
	tmp$ = roh.ShipDate Using "&&&&&&"                             
	If roh.ShipDate <> 999999 Call DateToJulian(1,tmp$,tmp1$,f)    
	If f Let tmp1$ = ""                                            
	JDATE[2] = tmp1$ ! julian ord shipdate                         
     nrol.SpareNU3$=blank$  
	 clear nrol.SpareNu$ ! dl4 fix
	If NewLn ! new line                                            
		OLR = fileupdateqolz(e$,OLC,"a",0,nrol.)               
                        
		 If OLR > 0 ! has to have a record!                           
			cnstk.OrdLineRec = OLR                                           
			If CREDIT Let x = -1 Else Let x = 1                             
			CNVTU[0] = 0;CNVTU[1] = nrol.UMSell;CNVTU[2] = 1                
			CNVTA = nrol.QtyShip                                            
			Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)         
			cnstk.QtyShip = (Amount * x) ! store credits as neg (IN SELL UM!)
			CNVTU[0] = 0;CNVTU[1] = nrol.UMSell;CNVTU[2] = 2                
			CNVTA = nrol.UnitCost                                           
			Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)         
			cnstk.UnitCost = Amount ! nrol.UnitCost (SAYS IN sELL UM)        
			CNVTU[0] = 0;CNVTU[1] = nrol.UMSell;CNVTU[2] = 2                
			CNVTA = nrol.UnitPrice                                          
			Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)         
			cnstk.UnitPrice = Amount ! nrol.UnitPrice (IN SELL UM!)          
			cnstk.ExtShipAmt = (nrol.ExtShipAmt * x) ! store credits as neg  
			Write Record #nsc,nsr,0;cnstk.;                                  
		End If                         
	                       
	 Else ! existing line               
		Write Record #OLC,OLR,0;nrol.; 
		 x = 1 \ If CREDIT Let x = -1                                     
		CNVTU[0] = 0;CNVTU[1] = nrol.UMSell;CNVTU[2] = 1                 
		CNVTA = nrol.QtyShip                                             
		Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)          
		cnstk.QtyShip = (Amount * x) ! store credits as neg (IN SELL UM!) 
		CNVTU[0] = 0;CNVTU[1] = nrol.UMSell;CNVTU[2] = 2                 
		CNVTA = nrol.UnitCost                                            
		Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)          
		cnstk.UnitCost = Amount ! nrol.UnitCost (SAYS IN sELL UM)         
		CNVTU[0] = 0;CNVTU[1] = nrol.UMSell;CNVTU[2] = 2                 
		CNVTA = nrol.UnitPrice                                           
		Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)          
		cnstk.UnitPrice = Amount ! nrol.UnitPrice (IN SELL UM!)           
		cnstk.ExtShipAmt = (nrol.ExtShipAmt * x) ! credits stored as neg  
		Write Record #nsc,nsr,0;cnstk.;  ! was ;nstk.; ?
	endif
	nsUDLDone: ! send status back                                            
	If ReturnStatus = 1 Let Message$ = "OK" ! set if no other problems     
	If debugdetail                                                         
		dmsg$ = "Update NStk Line " + Str$(nrol.OrdNum) + "-" + Str$(nrol.LineNum) +nrol.ProdCode$ + Message$ 
		Call updatelog(debug)                         
	End If 
	
	clear list$[]                                                         
	list$[0]=bsdel$,"NSSAVEITEM",fdel$ 
	webstr$=""
	webstr$=webstr$,"PRODID",fdel$                                        
	webstr$=webstr$,"LN",fdel$                                            
	webstr$=webstr$,"DEPT",fdel$                                          
	webstr$=webstr$,"STKUPDT",fdel$                                       
	webstr$=webstr$,"TAX",fdel$                                           
	webstr$=webstr$,"WHSE",fdel$                                          
	List$[1]=webstr$                                                      
	if OLR>0                                                              
		webstr$=""                                                    
		webstr$=rtrim$(nrol.prodcode$),fdel$                          
		webstr$=webstr$,str$(nrol.LineNum),fdel$                       
		webstr$=webstr$,str$(nrol.dept),fdel$                          
		let tmp$="N"                                                  
		! if nrol.UpdtStk let tmp$="Y"                                  
		WebStr$=WebStr$,tmp$,fdel$ ! update stock flag$               
		If P60$[42,42]<>"Y" ! NOT tax by line - so it's y/n only      
			tmp$="N" \ if nrol.TaxFlg let tmp$="Y"                
			WebStr$=WebStr$,tmp$,fdel$ ! tax flag                 
		Else ! it's a tax code                                        
		   WebStr$=WebStr$,Str$(nrol.TaxFlg),fdel$ ! tax code     
		Endif 
	        webstr$=webstr$,str$(nrol.whse),fdel$     
		list$[2]=webstr$
		elflag=1 ! line exists
	 endif                                             
	Call AddToStr(e$,rstr$,List$[]) ! mtg             
	Call AddToStr(e$,rstr$,esdel$) ! end of section   
	! status section                                                       
	Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)                 
	Call AddToStr(e$,rstr$,WebStr$)                                        
	Call SetOutPut(e$,rstr$)                                               
 else
	 include "src/callsuberr.inc"
 end try
End sub !NSSAveItem
!--------------------------------------------------------------------

Sub nsgetitem()
!--------------------------------------------------------------------

 try
	dim 1%,tmptax, 2%,nsfmcode
	dim KCM$[40],KEYMAT$[2]
	Dim vend. As a80vm
	clear rol.
	clear nstk.
	let nsfmcode=0
	!if p61$[132,132]="Y"
	!	mat read #ctlc,52,104;nsfmcode;
	!endif
	olr=-1
	If debugdetail                                                    
		dmsg$ = "Start Get NonStock Line Detail" \ Call updatelog(debug)    
	End If                                                            
	ReturnStatus = 1                                                  
	Message$ = "OK"                                                   
	Call dxget("ORDERID",tmp$)                                        
	If tmp$ = "" Goto EndNSGetItem                                       
	orderno = tmp$                                                    
		If orderno < 1 Or orderno > 999999 Or Fra(orderno)                
		 ReturnStatus = 0                                                
		 Message$ = "ORDER NUMBER INVALID"                               
		Goto EndNSGetItem                                                 
	End If                                                            
	OHR = GetOrdRec(e$,OHC,OSC,otc,orderno,roh.,ros.,rot.) 
	If OHR <= 0 ! not found                                               
		ReturnStatus = 0                                                    
		Message$ = "ORDER WAS NOT FOUND"                                    
		Goto  EndNSGetItem                                                       
	End If 
	Credit=0
	if ros.Status=32 let Credit=1
	ZLine = 0;NonStk = 0;stk = 0;delline = 0;CutLine = 0                  
	Call dxget("LTYPE",tmp$)                                              
	tmp$ = UCase$(tmp$)                                                   
	If tmp$[1,4] <> "NSTK"                                                     
		 ReturnStatus = 0                                                    
		Message$ = "Order Line has Invalid Line Type. Not a non-stock item."
		Goto EndNSGetItem                                                     
	End If                                                                
	Let NonStk = 1                                  
	Call dxget("LN",tmp$)                              
	rol.LineNum = tmp$ 
	
	If rol.LineNUm < 1 Or rol.lineNum > 999 Or Fra(rol.lineNum)                
		 ReturnStatus = 0                                                
		 Message$ = "ORDER LINE NUMBER INVALID"                               
		Goto EndNSGetItem 
	endif
	rolkey$ = " ",rolkey$                                              
	rolkey$[1,6] = orderno Using "######"                              
	rolkey$[7,9] = rol.LineNum Using "###"                            
	rolkey$[11] = "" ! cut to length (space @ 10)                      
	OLR = filegetqolz(e$,OLC,"=",1,rolkey$,rol.)
	clear e$
	If OLR <= 0 ! what do we do if not found?                          
		 ReturnStatus = 0                                                
		 Message$ = "ORDER LINE NOT ON FILE"                               
		Goto EndNSGetItem 
	endif
    	Read Record #OLC,OLR,0;rol.                                     
	If rol.NStkItem <>1
          	 ReturnStatus = 0                                                
		 Message$ = "ORDER LINE IS NOT A NON-STOCK LINE" 
		 clear rol.
		 olr=-1
		 Goto EndNSGetItem 
	endif
	if rol.LineType = 3  ! it's a zline line  
		ReturnStatus = 0                                                
		 Message$ = "ORDER LINE IS NOT A NON-STOCK LINE" 
		 clear rol.
		 olr=-1
		 Goto EndNSGetItem 
	endif
	nsr = rol.PDRecNum                                             
	Read Record #nsc,nsr,0;nstk.                                   
	Call setprtorol() ! set to rol. factors 
	
	EndNSGetItem: ! load this up for heading
	clear list$[]
	list$[0]=bsdel$,"GETNONSTOCK",fdel$
	webstr$="QTYORD",fdel$
	webstr$=webstr$,"IDBASE",fdel$
	webstr$=webstr$,"UMBASE",fdel$
	webstr$=webstr$,"IDSELL",fdel$
	webstr$=webstr$,"UMSELL",fdel$
	webstr$=webstr$,"SELLFCTR",fdel$
	webstr$=webstr$,"IDPRICE",fdel$
	webstr$=webstr$,"UMPRICE",fdel$
	webstr$=webstr$,"PRCFCTR",fdel$
	webstr$=webstr$,"IDPURCH",fdel$
	webstr$=webstr$,"UMPURCH",fdel$
	webstr$=webstr$,"PURCHFCTR",fdel$
	webstr$=webstr$,"IDCOST",fdel$
	webstr$=webstr$,"UMCOST",fdel$
	webstr$=webstr$,"COSTFCTR",fdel$
	webstr$=webstr$,"UNLBS",fdel$
	webstr$=webstr$,"LBSFCTR",fdel$
	webstr$=webstr$,"UMLBS",fdel$
	webstr$=webstr$,"UNCUBE",fdel$
	webstr$=webstr$,"CUBEFCTR",fdel$
	webstr$=webstr$,"UMCUBE",fdel$
	webstr$=webstr$,"HAZFLAG",fdel$
	webstr$=webstr$,"HAZID",fdel$
	webstr$=webstr$,"HAZNAME",fdel$
	webstr$=webstr$,"HAZCLASS",fdel$ ! HAZ CLASS
	webstr$=webstr$,"PACKGROUP",fdel$
	webstr$=webstr$,"DOTID",fdel$
	webstr$=webstr$,"ERBOOK",fdel$
	webstr$=webstr$,"DESC1",fdel$
	webstr$=webstr$,"DESC2",fdel$
	webstr$=webstr$,"SLSCAT",fdel$
	webstr$=webstr$,"SLSCATDESC",fdel$
	webstr$=webstr$,"COMMD",fdel$
	webstr$=webstr$,"COMMDDESC",fdel$
	webstr$=webstr$,"BUYER",fdel$	
	webstr$=webstr$,"BUYERNAME",fdel$
	webstr$=webstr$,"MATCD",fdel$
	webstr$=webstr$,"MATCDESC",fdel$
	webstr$=webstr$,"VENDITM",fdel$
	webstr$=webstr$,"VENDOR",fdel$
	webstr$=webstr$,"VENDNAME",fdel$
	webstr$=webstr$,"PONUM",fdel$	
	webstr$=webstr$,"GLCOST",fdel$                                      
	webstr$=webstr$,"UCOST",fdel$  
	webstr$=webstr$,"DEPT",fdel$
	webstr$=webstr$,"UPRICE",fdel$
	webstr$=webstr$,"LN",fdel$
	webstr$=webstr$,"BUILDPRODFLAG",fdel$
	webstr$=webstr$,"EditProdCat",fdel$
	webstr$=webstr$,"MiscCostSec",fdel$
	webstr$=webstr$,"CurrFrtCost",fdel$
	webstr$=webstr$,"PrevFrtCost",fdel$
	! Add 5 UDA Fields!
	webstr$=webstr$,"UDA1",FDEL$
	webstr$=webstr$,"UDA2",FDEL$
	webstr$=webstr$,"UDA3",FDEL$
	webstr$=webstr$,"UDA4",FDEL$
	webstr$=webstr$,"UDA5",FDEL$
	List$[1]=webstr$
	if OLR>0
		webstr$=""
		CNVTU[0] = 0;CNVTU[1] = rol.UMSell;CNVTU[2] = 1          
		CNVTA = rol.QtyOrd  \ if rol.numout>0 let CNVTA=rol.qtyord*rol.numout                                     
		X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)      
		WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! Qty Ord
		webstr$ = webstr$,str$(rol.UMBase),fdel$ ! Base rec#/id
		tmp$=XUnit$(rol.UMBase,ccc) ! u/m
		webstr$=webstr$,rtrim$(tmp$),fdel$
		webstr$ = webstr$,str$(rol.UMSell),fdel$ ! Sell rec#/id
		tmp$=XUnit$(rol.UMSell,ccc) ! u/m
		webstr$=webstr$,rtrim$(tmp$),fdel$
		webstr$=webstr$,str$(rol.SellFactor),fdel$
		webstr$ = webstr$,str$(rol.UMPRICE),fdel$ ! Price rec#/id
		tmp$=XUnit$(rol.UMPRICE,ccc) ! u/m
		webstr$=webstr$,rtrim$(tmp$),fdel$
		webstr$=webstr$,str$(rol.PRICEFactor),fdel$
		webstr$ = webstr$,str$(rol.UMPURCH),fdel$ ! PURCH rec#/id
		tmp$=XUnit$(rol.UMPURCH,ccc) ! u/m
		webstr$=webstr$,rtrim$(tmp$),fdel$
		webstr$=webstr$,str$(rol.PURCHFactor),fdel$
		webstr$ = webstr$,str$(rol.UMCost),fdel$ ! Cost rec#/id
		tmp$=XUnit$(rol.UMCost,ccc) ! u/m
		webstr$=webstr$,rtrim$(tmp$),fdel$
		webstr$=webstr$,str$(rol.CostFactor),fdel$
		WebStr$ = WebStr$,LTrim$(rol.LbsUnit Using PMask$),fdel$ ! wgt unit       
		tmp$ = Str$(rol.WgtFactor)                                                
		Call factorum(tmp$) ! get um for factor                                   
		WebStr$ = WebStr$,Str$(rol.WgtFactor),fdel$,RTrim$(tmp$),fdel$ ! wgt facto
	        WebStr$ = WebStr$,LTrim$(rol.CubeUnit Using PMask$),fdel$ ! cube unit     
		 tmp$ = Str$(rol.CubeFactor)                                               
		Call factorum(tmp$) ! get um for factor                                   
		 WebStr$ = WebStr$,Str$(rol.CubeFactor),fdel$
		 webstr$ = webstr$,RTrim$(tmp$),fdel$ ! cube fac
		let tmp$="N"
		if nstk.hazflg=1 let tmp$="Y"
		if nstk.hazflg=2 let tmp$="S"
		webstr$=webstr$,tmp$,fdel$
		let tmp$=""
		clear haz.
		if  nstk.HazFlg<>0 and nstk.HazFileRecno<>0
			if not (ch_haz)
				 Ch_Haz = openfile(-2784,intCo) \ If Ch_Haz = -1 Error 42 ! hazar
			endif
			read record #ch_haz,nstk.HazFileRecno;haz.;
			let tmp$=""
			let tmp$[1,24]=haz.hazshippingname1$[1,24]
			let tmp$[25,30]=nstk.HazFileRecno using "######"
		endif
		webstr$=webstr$,tmp$,fdel$
		webstr$=webstr$,rtrim$(haz.HazShippingName1$),fdel$
		webstr$=webstr$,rtrim$(nstk.hazclass$),fdel$
		webstr$=webstr$,rtrim$(nstk.packgrp$),fdel$
		webstr$=webstr$,rtrim$(nstk.dotid$),fdel$
		webstr$=webstr$,rtrim$(nstk.ERGdbk$),fdel$ 
		tmp$=clrtxtc$(e$,rol.desc1$) ! chk/clr control chars
		webstr$=webstr$,rtrim$(tmp$),fdel$ 
		tmp$=clrtxtc$(e$,rol.desc2$) ! chk/clr control chars
		webstr$=webstr$,rtrim$(tmp$),fdel$ 
		webstr$=webstr$,str$(rol.PSlsCat),fdel$
		clear psc.
		if rol.PSlsCat
			if not(ch_psc)
				ch_psc = openfile(-1984,intCo) \ If ch_psc = -1 Error 42 ! prod 	
			endif
			If rol.PSlsCat > 0 And rol.PSlsCat<=(Chf(ch_psc) - 1)
				Read Record #ch_psc,rol.PSlsCat;psc.; 
			endif
		endif
		webstr$=webstr$,rtrim$(psc.CategoryDesc$),fdel$ 
		webstr$=webstr$,rtrim$(rol.ComdtyCode$),fdel$
		if not(cmc)
			cmc = openfile(-2288,intCo) \ If cmc = -1 Error 42 ! commo
		endif
		KCM$ = " ",KCM$        
		KCM$ = rol.ComdtyCode$+Blank$;kcm$[5]=""
		cmr = filegetcommhead(e$,cmc,"=",1,kcm$,cMC.)
		clear e$
		if cmr<=0
			clear cmc.
		endif
		webstr$=webstr$,rtrim$(cmc.CodeDescription$),fdel$ 
		webstr$=webstr$,str$(nstk.Buyer),fdel$
		clear buy.
		if nstk.buyer
			if not(ch_buy)
				 Ch_buy = openfile(-9991,intCo) \ If Ch_buy = -1 Error 42 ! buyer
			endif
			If nstk.buyer > 0 And nstk.buyer < (Chf(ch_buy) - 1)
				read record #ch_buy,nstk.buyer;buy.;
			endif
		endif
		webstr$=webstr$,rtrim$(buy.BuyerName$),fdel$ 
		webstr$=webstr$,rtrim$(rol.MatCode$),fdel$
		if not (ch_matc)
			ch_matc = openfile(-2272,intCo) \ If ch_matc = -1 Error 42 ! mat
		endif
		let keymat$=rol.MatCode$
		rec_mat=filegetmatcode(e$,ch_matc,"=",1,keymat$,matc.)
		clear e$
		if rec_mat<=0
			clear matc.
		endif
		webstr$=webstr$,rtrim$(matc.Description$),fdel$
		tmp$=clrtxtc$(e$,rol.VendItemCode$) ! chk/clr control chars
		webstr$=webstr$,rtrim$(tmp$),fdel$
		webstr$=webstr$,str$(rol.vendor),fdel$
		clear vend.
		if rol.vendor<>0
			if not(vnc)
				vnc = OpenFile(-2400,IntCo) \ If vnc = -1 Error 42 ! vendor droplist
			endif
			let tmp$=rol.vendor using "######"
			vnr = filegeta80vm(e$,vnc,"=",1,tmp$,vend.) 
			clear e$
			if vnr<0
				clear vend.
			endif
		endif
		
		webstr$=webstr$,rtrim$(vend.name$),fdel$ ! vendor name
		webstr$=webstr$,str$(rol.PONum),fdel$	
		CNVTU[0] = 0;CNVTU[1] = rol.UMCost;CNVTU[2] = 2             
		CNVTA = rol.UnitGLCost                                        
		X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)    
		If p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 ! unit gl cost
			let cnvcu[0]=1
			let cnvca[0]=x3
			cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
		WebStr$ = WebStr$,LTrim$(X3 Using PMask$),fdel$ ! unit gl cost  
		CNVTU[0] = 0;CNVTU[1] = rol.UMCost;CNVTU[2] = 2             
		CNVTA = rol.UnitCost                                        
		X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.) 
		If p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 ! unit cost
			let cnvcu[0]=1
			let cnvca[0]=x3
			cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
		WebStr$ = WebStr$,LTrim$(X3 Using PMask$),fdel$ ! unit cost   
		webstr$=webstr$,str$(rol.dept),fdel$
		CNVTU[0] = 0;CNVTU[1] = rol.UMPrice;CNVTU[2] = 2     
		CNVTA = rol.UnitPrice                                
		X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)  
		If p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 ! unit price
			let cnvcu[0]=1
			let cnvca[0]=x3
			cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
		WebStr$ = webstr$, LTrim$(X3 Using PMask$),fdel$  ! unit price
		webstr$=webstr$,str$(rol.LineNum),fdel$
		let tmp$="N" ! \ if p61$[85,85]="Y" let tmp$="Y" ! NSBUILD ON QUOTES? NO!
		webstr$=webstr$,tmp$,fdel$ 
		let tmp$="Y" \if p61$[128,128]="N" let tmp$="N" ! edit prod cat
		IF source=239 or source=207 let tmp$="N" ! no edit on inquiry
		webstr$=webstr$,tmp$,fdel$
		let tmp3=0
		!if p61$[132,132]="Y" and nsfmcode<>0
		!	let tmp3=cost_lev[1]
		!endif
		webstr$=webstr$,str$(tmp3),fdel$ ! COST SECURITYE
		!if tmp3<>0
		!	webstr$=webstr$,(nstk.CurrFrtCost using "######.##"),fdel$
		!	webstr$=webstr$,(nstk.PrevFrtCost using "######.##"),fdel$
		!else
			webstr$=webstr$,"",fdel$
			webstr$=webstr$,"",fdel$
		!endif
		! and the 5 uda fields
		webstr$=webstr$,LTrim$(nstk.NS_UDA1 using "##########.####"),fdel$
		webstr$=webstr$,Rtrim$(nstk.NS_UDA2$),fdel$
		webstr$=webstr$,Rtrim$(nstk.NS_UDA3$),fdel$
		webstr$=webstr$,Rtrim$(nstk.NS_UDA4$),fdel$
		webstr$=webstr$,Rtrim$(nstk.NS_UDA5$),fdel$
		list$[2]=webstr$
	endif
	Call AddToStr(e$,rstr$,List$[]) ! mtg                   
	Call AddToStr(e$,rstr$,esdel$) ! end of section         
	! status section                                                       
	Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)                 
	Call AddToStr(e$,rstr$,WebStr$)                                        
	Call SetOutPut(e$,rstr$)                      
	
 else
   include "src/callsuberr.inc"
   
 end try
End sub ! nsgetitem

Sub NSBUILDPROD()
!-------------------------------------------------------------------
! BUILD PRODUCT FROM NON-STOCK
 try
	dim nspw. as prodwhse
	Dim keyprod$[12],kcm$[40],field$[1,30]
	dim 1%,ch_matc,errstatus,e$[50]
	dim 2%,currdate,L4
	dim 3%,rec_mat,Rec_Prod
	DIM A$[156],HZ$[90],PR_A2$[30],C1$[32],PSN$[20],U3$[60]        
	DIM PRFLG$[10],PRMKUPTYP$[4],PIC$[50],PRIML$[12]               
	DIM 1%,LLC,PFTB[3],PFU1[20],LM[1],UPCT,PR_PO[1]                
	DIM 1%,PRBASE,PRPARC2[3],PRD1[4],AGEDAY                        
	DIM 2%,A2,A3[2],B[24],PR_C4[10],PFCO[3],PLC[3],PSN[1],U2[1],U4[1] 
	DIM 2%,STK[2],FDT[1],PRMKUP[3],PRD0[2]                         
	DIM 3%,A1[7],A[33],PF_LOAD2,PFU2[6],PLV[1],PRPARC[3],U3,PFN[1] 
	DIM 3%,LBSORD,FUT[1],PRREDI[1],PRD2[3]                         
	REM {end dim.prod.i}                                           
	DIM K1$[25],K2$[20],K3$[40],K4$[40],K5$[45],COPYPROD$[12]      
	DIM PROD$[12],WHKEY$[14]
	DIM 3%,UNWORK[6],UNFWORK[6] 
	DIM 3%,P2[12,2],rec_tmp,FLE[5]
	dim rolkey2$[30],Flg$[6]
	dim 3%,rec_ror,keyroll$[50],keyroll2$[50],F$[16]
	dim nspwkey$[30],3%,rec_nspw
	mat read #1,60,6;flg$;
	ReturnStatus=1
	Message$="OK"
	! verify if build option is avail
	if custom_customer$="HTBERRY" let P61$[85,85]="N" ! custom - no nstk to prod
	P61$[85,85]="N" ! Not on quotes? Yes - not on quotes
	if p61$[85,85]="N"
		let returnstatus=0
		let message$="Build Product for Non-Stock Option Not Available"
		Goto NSBPrdDone
	endif
	Call dxget("ORDERID",tmp$)                             
	If tmp$ = ""  goto NSBPrdDone                            
	orderno = tmp$                                         
	If orderno < 1 Or orderno > 999999 Or Fra(orderno)     
		ReturnStatus = 0                                     
		Message$ = "ORDER NUMBER INVALID"                    
		Goto NSBPrdDone                                       
	End If                                                 
	OHR = GetOrdRec(e$,OHC,OSC,otc,orderno,roh.,ros.,rot.)
	e$=""
	If OHR <= 0 ! not found                                
		ReturnStatus = 99                                     
		Message$ = "ORDER WAS NOT FOUND"                     
		Goto NSBPrdDone
	endif
	if returnstatus<>0
		credit = 0 \ if ros.status=32 let credit=1
		call verifystat()
		if returnstatus=99  Goto NSBPrdDone
	endif
	IF ROH.OrdType=20 ! freight invoice no lines
		ReturnStatus = 0                                     
		Message$ = "ORDER TYPE=Freight Invoice, NO LINES ALLOWED"                     
		Goto NSBPrdDone
	endif
	let keyprod$="Z ZZZZZZZZZZ"
	PRR = filegetprod(e$,PRC,"=",1,keyprod$,PR.)
	clear e$
	if prr<=0
		let returnstatus=0
		let message$="Default Non-Stock Product 'Z ZZZZZZZZZZ' Not On File"
		Goto NSBPrdDone
	endif
	Call dxget("PRODID",tmp$)      
	tmp$ = Trim$(UCase$(tmp$)) + Blank$   
	prod$ = tmp$[1,12]
	if rtrim$(prod$)=""
		let returnstatus=0
		let message$="Invalid Product Code "+Prod$
		Goto NSBPrdDone
	endif
	let keyprod$=Rtrim$(prod$)+Blank$
	rec_prod = filegetprod(e$,PRC,"=",1,keyprod$,PR.)
	clear e$
	if rec_prod>0
		let returnstatus=0
		let message$="Product Id "+Rtrim$(PROD$)+" Already On File "
		Goto NSBPrdDone
	endif
	! get order moved above                                
	Call dxget("LN",tmp$) ! +Str$(X1),tmp$)              
	LineNo = tmp$ ! line # (zero on new lines)           
	If LineNo < 0 Or LineNo > 999 Or Fra(LineNo)        
		ReturnStatus = 0                                   
		Message$ = "INVALID ORDER LINE!"                   
		Goto NSBPrdDone             
	End If 
	if lineno<>0
		rolkey$ = " ",rolkey$                                
		rolkey$[1,6] = orderno Using "######"                
		rolkey$[7,9] = LineNo Using "###"                    
		rolkey$[11] = "" ! cut to length (space @ 10)        
		OLR = filegetqolz(e$,OLC,"=",1,rolkey$,rol.)
		clear e$
		If OLR <= 0                                          
			ReturnStatus = 0 
			Message$ = "Order Line Not Found"  
			Goto NSBPrdDone
		End If
		
		if not(rol.NStkItem) 
			ReturnStatus = 0
			Message$="Order Line is not a Non-Stock Item"
			Goto NSBPrdDone
		endif
	else
		let olr=-1
		clear rol.
	endif
	! open product sales file
	If not(ch_prsls)
		ch_prsls = OpenFile(2080,IntCo) \ If ch_prsls = -1 Error 42 ! prod sales file
	endif
	IF not(CH_PDESCKEY)
		ch_pdesckey = OpenFile(1104,IntCo) \ If ch_pdesckey = -1 Error 42 ! prod sales file
	endif

	! read old product use prr  -- using with old format since I need arrays
	MAT  READ #PRC,PRR,0;A$;          
	MAT  READ #PRC,PRR,156;B;        
	MAT  READ #PRC,PRR,256;A;        
	MAT  READ #PRC,PRR,460;A1;        
	MAT  READ #PRC,PRR,508;A2;       
	MAT  READ #PRC,PRR,512;PFU1;      
	MAT  READ #PRC,PRR,554;PFU2;      
	MAT  READ #PRC,PRR,596;PRPARC;    
	MAT  READ #PRC,PRR,620;LM;   
	MAT  READ #PRC,PRR,624;PR_PO;     
	MAT  READ #PRC,PRR,628;AGEDAY;   
	READ #PRC,PRR,630;LLC;            
	MAT  READ #PRC,PRR,632;PSN$;      
	MAT  READ #PRC,PRR,652;PSN;       
	MAT  READ #PRC,PRR,660;U2;        
	MAT  READ #PRC,PRR,664;LBSORD;
	MAT  READ #PRC,PRR,670;U4;            
	READ #PRC,PRR,678;U3;                 
	MAT  READ #PRC,PRR,684;U3$;           
	MAT  READ #PRC,PRR,744;HZ$;           
	MAT  READ #PRC,PRR,834;A3;            
	MAT  READ #PRC,PRR,846;PFTB;          
	READ #PRC,PRR,854;UPCT;               
	MAT  READ #PRC,PRR,856;C1$;           
	MAT  READ #PRC,PRR,894;PR_C4;         
	MAT  READ #PRC,PRR,938;PF_LOAD2;      
	MAT  READ #PRC,PRR,944;PR_A2$;        
	MAT  READ #PRC,PRR,974;PFCO;          
	MAT  READ #PRC,PRR,990;PLV;           
	MAT  READ #PRC,PRR,1002;PLC;          
	MAT  READ #PRC,PRR,1018;PFN;          
	MAT  READ #PRC,PRR,1030;STK;          
	MAT  READ #PRC,PRR,1048;FDT;          
	MAT  READ #PRC,PRR,1056;PRFLG$;       
	MAT  READ #PRC,PRR,1066;PRBASE;       
	MAT  READ #PRC,PRR,1068;PRMKUP;                     
	MAT  READ #PRC,PRR,1084;PRMKUPTYP$;                       
	MAT  READ #PRC,PRR,1088;FUT;                              
	MAT  READ #PRC,PRR,1100;PRPARC2;                          
	MAT  READ #PRC,PRR,1108;PRREDI;                           
	MAT  READ #PRC,PRR,1120;PIC$;                            
	MAT  READ #PRC,PRR,1270;PRD0;                             
	MAT  READ #PRC,PRR,1282;PRIML$;                           
	MAT  READ #PRC,PRR,1294;PRD1;                            
	MAT  READ #PRC,PRR,1304;PRD2;           
	! clear variables needed ! 
	FOR I=0 TO 33                         
		FOR A2=0 TO 2                       
			IF I<=12 LET P2[I,A2]=0           
		NEXT A2                             
		IF I<=3 LET A[I]=0                  
		IF I>=7 AND I<=19 LET A[I]=0         
		IF I>=26 LET A[I]=0                 
		IF I>=1 AND I<=7 LET B[I]=0          
		IF I>=12 And I<=15 LET B[I]=0        
		IF I<4 LET PFCO[I]=0                
	NEXT I                                
	LET PR_A2$[1,12]=" ",PR_A2$[1,12]     
	LET A1[0]=0 \ LET A1[2]=0 \ LET A2=0
	A3[0]=0;A3[1]=0;A3[2]=0 ! HAZ,MSDS,
	! lm[0]=0;lm[1]=0 keep load markup tables from Z_ZZZZZZ
	hz$=" ",hz$
	Read #ctlc,3,172;currdate;
	LET pr_C4[7]=currdate ! DATE ESTABLISHED
	! U4[0]=0;U4[1]=0 keep Except Sale and Lead Time % from Z_ZZZZZZZ
	! PR_C4[3]=0; keep Price Markup Table
	U2[0]=0;U2[1]=0
	A$[116,126]="           " ! COST GROUP
    Call dxget("DESC1",tmp$)
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Description 1"
		Goto NSBPrdDone
	Endif
	A$[9,38]=rtrim$(tmp$) + Blank$ 
	Call dxget("DESC2",tmp$)
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Description 2"
		Goto NSBPrdDone
	Endif
	A$[63,92] = rtrim$(tmp$) + Blank$                            
	Call dxget("VENDITM",tmp$) 
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Vendor Item"
		Goto NSBPrdDone
	Endif
	A$[93,112] = rtrim$(tmp$) + Blank$ 
	A$[140,151]=prod$
	Call dxget("COMMD",tmp$)              
	A$[152,155]=tmp$+blank$
	Call dxget("MATCD",tmp$)
	a$[156,156]=tmp$+blank$
	let flg$[3,3]="Y"
	if flg$[3,3]="Y"
		Call dxget("HAZFLG",tmp$)
		if rtrim$(tmp$)="Y" let A3[0]=1
		if rtrim$(tmp$)="S" let A3[0]=2
		IF A3[0]<>0
			Call Dxget ("HAZID",tmp$) ! hazardous id
			if not (ch_haz)
				Ch_Haz = openfile(-2784,intCo) \ If Ch_Haz = -1 Error 42 ! hazar
			endif
			let rec_haz=filegethazname(e$,ch_haz,"=",1,tmp$,haz.)
			clear e$
			if rec_haz>0
				a3[2]=rec_haz
			endif
		endif
		Call Dxget ("HAZCLASS",TMP$) ! HAZ CLASS
		LET HZ$[41,64]=rtrim$(tmp$)+BLANK$
		call dxget ("PACKGROUP",tmp$) ! 
		let HZ$[65,70]=rtrim$(tmp$)+blank$
		call dxget ("DOTID",tmp$)
		let hz$[71,80]=rtrim$(tmp$)+blank$
		call dxget ("ERBOOK",tmp$)
		let hz$[81,90]=rtrim$(tmp$)+blank$
	endif
	call dxget("GLCOST",tmp$) !+Str$(X1),tmp$) ! NSBUILD
	V3[9]=tmp$
	if v3[9]<0 or v3[9]>9999999
		returnstatus=0
		message$="GL Cost is out of range"
		Goto NSBPrdDone
	Endif
	! set unit of measures into unwork
	! base unit of measure  ! UNWORK[0]
	Call dxget("UMBASE",tmp$) 
	! If tmp$[1,1] > "9" ! sent text?             
		 R = getumrec(e$,ccc,tmp$,IntCo,PR.)       
		If R <> 0 Let tmp$ = Str$(R)              
	! End If                                      
	UNWORK[0] = tmp$
	if unwork[0]<0
		returnstatus=0
		Message$="Invalid Base UM"
		Goto NSBPrdDone
	Endif
	! selling unit of measure ! unwork[1]
	Call dxget("UMSELL",tmp$) 
	! If tmp$[1,1] > "9" ! sent text?             
		 R = getumrec(e$,ccc,tmp$,IntCo,PR.)       
		If R <> 0 Let tmp$ = Str$(R)              
	! End If                                      
	UNWORK[1] = tmp$
	if unwork[1]<0
		returnstatus=0
		Message$="Invalid Sell UM"
		Goto NSBPrdDone
	Endif
	! Pricing unit of measure ! unwork[2]
	Call dxget("UMPRICE",tmp$) 
	! If tmp$[1,1] > "9" ! sent text?             
		 R = getumrec(e$,ccc,tmp$,IntCo,PR.)       
		If R <> 0 Let tmp$ = Str$(R)              
	! End If                                      
	UNWORK[2] = tmp$
	! Costing unit of measure ! unwork[3]
	Call dxget("UMCOST",tmp$) 
	! If tmp$[1,1] > "9" ! sent text?             
		 R = getumrec(e$,ccc,tmp$,IntCo,PR.)       
		If R <> 0 Let tmp$ = Str$(R)              
	! End If                                      
	UNWORK[3] = tmp$
	NROL.UMCOST=UNWORK[3]
	! Purchasing unit of measure ! unwork[4]
	Call dxget("UMPURCH",tmp$) 
	! If tmp$[1,1] > "9" ! sent text?             
		 R = getumrec(e$,ccc,tmp$,IntCo,PR.)       
		If R <> 0 Let tmp$ = Str$(R)              
	! End If                                      
	UNWORK[4] = tmp$ ! 
	! lbs unit of measure ! unwork[4]
	Call dxget("UMLBS",tmp$)  ! this might be lbs factor
	! If tmp$[1,1] > "9" ! sent text?             
		 R = getumrec(e$,ccc,tmp$,IntCo,PR.)       
		If R <> 0 Let tmp$ = Str$(R)              
	! End If                                      
	UNWORK[5] = tmp$
	
	! let do the factors
	UNFWORK[0]=1
	Call dxget("SELLFCTR",tmp$)                          
	UNFWORK[1]=tmp$ \ If unfwork[1] <= 0 Let unfwork[1] = 1  
	Call dxget("PRCFCTR",tmp$)                               
	UNFWORK[2]=tmp$ \ If unfwork[2] <= 0 Let unfwork[2] = 1
	Call dxget("COSTFCTR",tmp$) 
	UNFWORK[3]=tmp$ \ If unfwork[3] <= 0 Let unfwork[3] = 1
	Call dxget("PURCHFCTR",tmp$)                           
	UNFWORK[4]=tmp$ \ If unfwork[4] <= 0 Let unfwork[4] = 1
	Call dxget("LBSFCTR",tmp$)
	UNFWORK[5]=tmp$ \ If unfwork[5] <= 0 Let unfwork[5] = 1
    Call dxget("CUBEFCTR",tmp$) 
	UNFWORK[6]=tmp$ \ If unfwork[6] <= 0 Let unfwork[6] = 1!+Str$(X1),tmp$)
	! cube unit of measure
	Call dxget("UMCUBE",tmp$) !+Str$(X1),tmp$)   
	! If tmp$[1,1] > "9" ! sent text?              
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)        
		If R <> 0 Let tmp$ = Str$(R)               
	! End If 
	UNWORK[6] =tmp$ ! UNFWORK[6]=tmp$ \ If unfwork[6] <= 0 Let unfwork[6] = 1!+Str$(X1),tmp$)
        unfwork[6]=1
	if R=unwork[0]
		let unfwork[6]=1
	else
		if r=unwork[1]
			let unfwork[6]=unfwork[1]
		else
			if r=unwork[2]
				let unfwork[6]=unfwork[2]
			else
				if r=unwork[3]
					let unfwork[6]=unfwork[3]
				else
					if r=unwork[4]
						let unfwork[6]=unfwork[4]
					endif
				endif
			endif
		endif
	endif
	Call dxget("UMLBS",tmp$) !+Str$(X1),tmp$)    
	! If tmp$[1,1] > "9" ! sent text?              
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)        
		If R <> 0 Let tmp$ = Str$(R)               
	! End If
	unwork[5]=r
	if R=unwork[0]
		let unfwork[6]=1
	else
		if r=unwork[1]
			let unfwork[6]=unfwork[1]
		else
			if r=unwork[2]
				let unfwork[6]=unfwork[2]
			else
				if r=unwork[3]
					let unfwork[6]=unfwork[3]
				else
					if r=unwork[4]
						let unfwork[6]=unfwork[4]
					endif
				endif
			endif
		endif
	endif
       	Call dxget("VENDOR",tmp$)
	LET B[24]=Tmp$! vendor code 
	Call dxget("SLSCAT",tmp$) 
	LET B[11]=tmp$
	Call dxget("UNCUBE",tmp$) 
	LET B[23]=tmp$ ! cube feet
	Call dxget("UNLBS",tmp$) 
	LET A[6]=tmp$ ! cube feet
                  
	LET PFU1[0]=UNWORK[0]               
                               
	LET PFU1[0]=UNWORK[0]                  
	LET K=0                                
	FOR Y=1 TO 4                           
		FOR X=0 TO 7                           
			 IF UNWORK[Y]=PFU1[X] GOTO NEXTY:     
		NEXTX: NEXT X                          
		LET K=K+1                              
		IF UNWORK[Y]>0 LET PFU1[K]=UNWORK[Y]   
		IF UNWORK[Y]>0 LET PFU2[K-1]=UNFWORK[Y]
	NEXTY: NEXT Y                          
	LET PFU1[9]=UNWORK[1]                  
	LET PFU1[10]=UNWORK[4]                 
	LET PFU1[11]=UNWORK[3]                 
	LET PFU1[12]=UNWORK[2] 
	! SET TO PURCHASING UNIT OF MEASURE
	LET PFU1[8]=PFU1[10] ! STOCKING
	LET PFU1[20]=PFU1[10] ! VENDOR ORDER
	LET PFU1[18]=PFU1[10] ! PACKING
	LET PFU1[19]=PFU1[10]  ! PROD SIZE
	! SET TO SELLING UNIT OF MEASURE
	LET PFU1[16]=PFU1[9] ! UPCHARGE
	LET PFU1[17]=PFU1[9] ! BROKEN
	LET PFU1[13]=PFU1[9] ! PROD/POS
	LET A1[3]=UNFWORK[6]                   
	!LET B[23]=UNWORK[6]  ! cube feet                   
	!LET A[6]=UNWORK[5]  ! lbs                   
	LET A[5]=UNFWORK[5]                    
	LET PGWL=A[6];PGWF=A[5] 
	! set vars for program
	pr.BaseUM=PFU1[0]
	pr.UM2=pfu1[1];pr.UM2Fact=PFU2[0]
	pr.UM3=Pfu1[2];pr.UM3Fact=pfu2[1]
	pr.UM4=pfu1[3];pr.UM4Fact=pfu2[2]
	pr.UM5=pfu1[4];pr.UM5Fact=pfu2[3]
	pr.UMStkDefault = PFU1[8] 
	pr.UMSellDefault = PFU1[9] 
	pr.UMPurchDefault= PFU1[10]
	pr.UMCostDefault  = PFU1[11]
	pr.UMPriceDefault  = PFU1[12]
	pr.UMPrdtnDefault  = PFU1[13]
	pr.LbsFact=A[5]
	pr.LbsUnit=A[6]
	! SET COST
	if v3[9]>0 ! sent glcost
		If p61$[136,136]="Y" and rol.currfact<>0 and V3[9]<>0
			let cnvcu[0]=2
			let cnvcu[1]=1
			let cnvca[0]=V3[9]
			cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let v3[9]=cnvca[0]
		endif
		CNVTU[0]=nrol.UMCost;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
		cnvta=v3[9] \ if nrol.UMCost>0 and nrol.NumOut>0 let cnvta=v3[9]*nrol.numout
		nrol.UnitGLCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		LET PR_C4[4]=NROL.UNITGLCOST ! base cost
		let b[10]=nrol.unitglcost ! po cost
		let b[21]=nrol.unitglcost ! average cost
	Endif
	let e=2
	search #prc,1,0;keyprod$,rec_prod,e
	if e
		let returnstatus=0
		let message$="Error in Allocating Product Id "+Rtrim$(PROD$)+" Cannot Add"
		Goto NSBPrdDone
	endif
	LET A[26]=REC_PROD;PRR=REC_PROD
    MAT  WRITE #prc,REC_PROD,0;A$          
	MAT  WRITE #prc,REC_PROD,156;B         
	MAT  WRITE #prc,REC_PROD,256;A         
	MAT  WRITE #prc,REC_PROD,460;A1        
	MAT  WRITE #prc,REC_PROD,508;A2        
	MAT  WRITE #prc,REC_PROD,512;PFU1      
	MAT  WRITE #prc,REC_PROD,554;PFU2      
	MAT  WRITE #prc,REC_PROD,596;PRPARC    
	MAT  WRITE #prc,REC_PROD,620;LM        
	MAT  WRITE #prc,REC_PROD,624;PR_PO     
	MAT  WRITE #prc,REC_PROD,628;AGEDAY    
	WRITE #prc,REC_PROD,630;LLC            
	MAT  WRITE #prc,REC_PROD,632;PSN$      
	MAT  WRITE #prc,REC_PROD,652;PSN       
	MAT  WRITE #prc,REC_PROD,660;U2        
	MAT  WRITE #prc,REC_PROD,664;LBSORD
	MAT  WRITE #prc,REC_PROD,670;U4            
	WRITE #prc,REC_PROD,678;U3                 
	MAT  WRITE #prc,REC_PROD,684;U3$           
	MAT  WRITE #prc,REC_PROD,744;HZ$           
	MAT  WRITE #prc,REC_PROD,834;A3            
	MAT  WRITE #prc,REC_PROD,846;PFTB          
	WRITE #prc,REC_PROD,854;UPCT               
	MAT  WRITE #prc,REC_PROD,856;C1$           
	MAT  WRITE #prc,REC_PROD,894;PR_C4         
	MAT  WRITE #prc,REC_PROD,938;PF_LOAD2      
	MAT  WRITE #prc,REC_PROD,944;PR_A2$        
	MAT  WRITE #prc,REC_PROD,974;PFCO          
	MAT  WRITE #prc,REC_PROD,990;PLV           
	MAT  WRITE #prc,REC_PROD,1002;PLC          
	MAT  WRITE #prc,REC_PROD,1018;PFN          
	MAT  WRITE #prc,REC_PROD,1030;STK          
	MAT  WRITE #prc,REC_PROD,1048;FDT          
	MAT  WRITE #prc,REC_PROD,1056;PRFLG$       
	MAT  WRITE #prc,REC_PROD,1066;PRBASE       
	MAT  WRITE #prc,REC_PROD,1068;PRMKUP	                        
	MAT  WRITE #prc,REC_PROD,1084;PRMKUPTYP$                       
	MAT  WRITE #prc,REC_PROD,1088;FUT                              
	MAT  WRITE #prc,REC_PROD,1100;PRPARC2                          
	MAT  WRITE #prc,REC_PROD,1108;PRREDI                           
	MAT  WRITE #prc,REC_PROD,1120;PIC$                             
	MAT  WRITE #prc,REC_PROD,1270;PRD0                             
	MAT  WRITE #prc,REC_PROD,1282;PRIML$                           
	MAT  WRITE #prc,REC_PROD,1294;PRD1                             
	MAT  WRITE #prc,REC_PROD,1304;PRD2;
	K1$=KEYPROD$
	SEARCH #prc,4,1;K1$,REC_PROD,E
	IF E>1
		let returnstatus=0
		message$="Error in Adding Directory 1 for Product "+Rtrim$(prod$)
		Goto NSBPrdDone
	endif        
	LET K2$=" ",K2$ \ LET K2$[2,2]=A$[139,139] \ LET K2$[3]=K1$        
	SEARCH #prc,4,2;K2$,REC_PROD,E 
	IF E>1
		let returnstatus=0
		message$="Error in Adding Directory 2 for Product "+Rtrim$(prod$)
		Goto NSBPrdDone
	endif     
	LET K3$=" ",K3$ \ LET K3$[1,4]=A$[152,155] \ LET K3$[5]=K1$[1,12]  
	SEARCH #prc,4,3;K3$,REC_PROD,E
	IF E>1
		let returnstatus=0
		message$="Error in Adding Directory 3 for Product "+Rtrim$(prod$)
		Goto NSBPrdDone
	endif       
	LET K4$=" ",K4$ \ LET K4$[1,20]=A$[93,112] \ LET K4$[21]=K1$       
	SEARCH #prc,4,4;K4$,REC_PROD,E
	IF E>1
		let returnstatus=0
		message$="Error in Adding Directory 4 for Product"+Rtrim$(prod$)
		Goto NSBPrdDone
	endif       
	LET K5$[1,30]=UCase$(A$[9,38])+blank$
	Let k5$[31]=A$[140,151]
	! need to open a product description file
	SEARCH #CH_PDESCKEY,4,1;K5$,REC_PROD,E
	IF E>1
		let returnstatus=0
		message$="Error in Adding Product Description Key "+Rtrim$(prod$)
		Goto NSBPrdDone
	endif     
	! UPDATE PROD SALES
	WRITE #CH_PRSLS,REC_PROD,0;A$[140,151]
	MAT  WRITE #CH_PRSLS,REC_PROD,16;P2   
	MAT  WRITE #CH_PRSLS,REC_PROD,256;P2; 
	! UPDATE WAREHOUSE -- GET WAREHOUSE FROM HEADER
	if olr<=0
		let rol.whse = roh.wh
		if not (rol.whse) let rol.Whse = roh.wh
	endif
	if not (rol.whse) let rol.Whse = roh.wh
	if not (rol.whse) let rol.whse=1
	if roh.ordtype=8 or roh.ordtype=16 ! check/bld to whse
	  If Roh.ConsWh>0 and roh.conswh<100
		let TPWKey$=" ",tpwKey$
		TPWkey$[1,12]=prod$[1,12]+Blank$
		TPWKey$[13]=ROH.ConsWh Using "##"
		call chktowhse(TPWKey$,B[24])
	  Endif
	Endif
	let k5$=" ",k5$
	k5$[1,12]=prod$[1,12]
	k5$[13]=rol.Whse Using "##"
	PWR=filegetprodwhse(e$,PWC,"=",1,k5$,pw.)
	clear e$
	if PWR<0 ! not found
		Clear pw.
		Whbld[0] = PWC
		if rol.whse<=0 let rol.whse=roh.wh
		if rol.whse<=0 let rol.whse=1
		! whbld[0] = channel number for prodwhse file
		Whbld[1] = rol.Whse
		Whbld[2] = B[24] ! vednor
		WHBLD[3]=1 ! flag as non-stock
		if rol.Whse<>1 let Whbld[1]=rol.Whse+.01 ! fra=copy whse 1
		Call mxwhcreate(e$,IntCo,Prod$,Whbld[])        
		PWR = Whbld[2];e$ = ""
		read record #pwc,pwr,0;pw.;
		nspwkey$=" ",nspwkey$
		let nspwkey$[1,12]="Z ZZZZZZZZZZ"
		let nspwkey$[13,14]=rol.whse using "##"
		rec_nspw=0
		search #pwc,2,1;nspwkey$,rec_nspw,e
		if not (e)
			read record #pwc,rec_nspw,0;nspw.;
		else
			let rec_nspw=0
			if rol.whse<>1
				let nspwkey$[13,14]=" 1"
				search #pwc,2,1;nspwkey$,rec_nspw,e
				if not(e)
					read record #pwc,rec_nspw,0;nspw.;
				else
					let rec_nspw=0
				endif
			endif
		endif
		if rec_nspw<>0 ! ok
			pw.DNReordFlg=nspw.DNReordFlg! 
			pw.ProdGrp=nspw.ProdGrp 
			pw.FrcstWgtTbl=nspw.FrcstWgtTbl ! Forecase
			pw.CalcSrc=nspw.Calcsrc ! Reorder Table
			if P9$[32,32]="Y" ! warehouse pricing
				Pw.CostAvg=b[21]   
				pw.CostLastPo=b[10]
				pw.CostBase=pr_c4[4]
			endif
			write record #pwc,pwr,0;pw.;
		endif			
		PRR = filegetprod(e$,PRC,"=",1,keyprod$,PR.)
	endif
	Read Record #PWC,PWR,0;pw.;
	! set the buyer from the non-stock screen
	Call dxget("BUYER",tmp$) !+Str$(X1),tmp$)  
	let tmp3=tmp$
	if tmp3<>pw.buyer
		let k3$=" ",k3$
		let k3$[1,2]=pw.whse using "##"
		let k3$[3,5]=pw.buyer using "###"
		let k3$[6,17]=pw.prodcode$
		search #pwc,2,2;k3$,tmprec,e
		if not(e)
			search #pwc,5,2;k3$,tmprec,e
		endif
		let k4$=k3$
		let k4$[3,5]=tmp3 using "###"
		search #pwc,4,2;k4$,pwr,e
	endif
	pw.Buyer = tmp$ 
	write Record #PWC,PWR,0;pw.;
	if P61$[35,35] = "Y"
		Read record #PRC,Rec_Prod,0;pr.; ! reread new rec
		!fle[0]=ctlc
		!fle[1]=prc
		!fle[2]=pwc
		!errstatus=1
		e$=""
		!Call turboadd(intco,prod$,e$,fle[],errstatus)
		call apturbo(e$,CTLC,IntCo,REC_PROD,pr.) ! add new turbo
		E$=""
	endif
	! need to delete the non-stock item
	if lineno<>0 and olr>0
		nsr = rol.PDRecNum ! record                                        
		Read Record #nsc,nsr,0;nstk.;                                      
		X3 = fileupdateqproddesc(e$,nsc,"d",nsr,nstk.) ! delete sproddesc  
		! if x3<0 ! problem deleting 
		! do I need to change ! delete the old non-stock 
		! nonstock items do not have a directory 2 key
		!let rolkey2$=" ",rolkey2$
		!let rolkey2$[1,6]=rol.PDRecNum using "######"
		!let rolkey2$[7,12]=rol.OrdNum using "######"
		!let rolkey2$[13]=rol.LineNum using "###"
		!search #olc,5,2;rolkey2$,rec_tmp,e
	
		rol.PDRecNum=PRR ! rec_prod 
		rol.NStkItem=0 
		rol.ProdCode$=prod$+blank$
		Write Record #OLC,OLR,0;rol.;
		let rolkey2$=" ",rolkey2$
		let rolkey2$[1,6]=rol.PDRecNum using "######"
		let rolkey2$[7,12]=rol.OrdNum using "######"
		let rolkey2$[13,15]=rol.LineNum using "###"
		search #olc,4,2;rolkey2$,olr,e
	endif
	NSBPrdDone: ! finished
	if returnstatus=1 let message$="OK" ! set if no other problems
	if debugdetail
		dmsg$="Product "+rtrim$(Prod$)+" Built "+Str$(rol.OrdNum)+"-"+Str$(rol.LineNum)+" "+Message$ \ Call updatelog(debug)
	Endif
	
 else
	include "src/callsuberr.inc"
 end try
End sub !NSBUILDPROD
!---------------------------------------------------------------------
!--------------------------------------------------------------------
Sub GetCust()
! get customer data (after header read!)
 Try
	Dim KCust$[60]
	Dim 3%,CUR
	KCust$=" ",KCust$
	KCust$=roh.CustNum Using "######"
	CUR=filegetcust(e$,CUC,"=",1,KCust$,Cust.) ! need customer fields
	clear e$
	If CUR<0 clear cust.
	if debugdetail
		dmsg$="Get Customer "+kcust$+" REC="+Str$(CUR) \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
  end try
end sub ! GetCust
! 
!--------------------------------------------------------------------
Function GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh. as qoh, ros. as qos, rot. as qot)
! search thru all status for Order
! ohc,osc,otc = channels for roh, ros, rot
! orderNo = Order # to find
! roh.,ros.,rot. = structs for roh,ros,rot
! returns 
! X3 = order header rec #
	Try
		Dim KOHC$[20]
		Dim 1%,X[9],SCHN[2]
		Dim 2%,X2[9]
		Dim 3%,X3[9],OHR
		SCHN[0]=OHC;SCHN[1]=OSC;SCHN[2]=OTC
		Let X2=OrderNo
		let OHR=-1 ! not found as default
		if debugdetail
			dmsg$="Look for Quote "+Str$(X2) \ Call updatelog(debug)
		Endif
		For X=1 to 99
			If X<20 or x>24 ! skip deleted
				Let KOHC$=" ",KOHC$
				KOHC$[1,2]=X Using "##"
				KOHC$[3]=OrderNo Using "######"
				X3=filegetqohz(e$,SCHN[],"=",1,kohc$,roh.,ros., rot.)
				clear e$ ! we expect a msgqohNOF - It's NOT CAUSE TO BOMB!
				If X3>0 ! found it
				  Exit function X3
				Endif
			Endif
		Next X
		if debugdetail
			dmsg$="Quote NOT FOUND "+Str$(X2) \ Call updatelog(debug)
		Endif
	else
    include "src/callsuberr.inc"
  end try
end Function OHR ! getordrec
! 
!--------------------------------------------------------------------
Sub GetNewProdDtl(e$,List$[],maxcnt,Prod$,Sqty,SUM,OHR,SHQty,BOQty)
! send prod, qty, um, order Rec
! sends back list$ with details (use rol. varnames)
! ALSO CREATE ORDER LINE NOW! allocates & edittrack
! added: 08/17/11 - Option to just load data - NO UPDATE (maxcnt<0)
Try
	Dim KPR$[60],KPW$[60],kcm$[40],k1$[50]
	
	Dim 1%,Cnvtu[2],Flag,E,X[9],Pram[5]
	Dim 1%,FCDays,Zline,NonStk
	Dim 2%,X2[9],TaxBack,JDate[5],FDate,ShipDate
	Dim 2%,nsltbl
	Dim 3%,CNVTA,Amount,x3[9],FutCost,LPR
	Dim 3%,MSHQty,MBOQty,S9[20]
	
	Dim NRol. as qol ! store new sent data
	if debugdetail
		dmsg$="Start New Line" \ Call updatelog(debug)
	Endif
	e$="";ZLine=0;NonStk=0
	Read #ctlc,2,198;FCDays; ! days to check future cost
	Read #ctlc,3,188;ShipDate; ! for inv levels
	If FCDays<1 or FCDays>999 or Fra(FCDays) Let FCDays=30 ! check range
	tmpcnt=maxcnt ! row is passed
	tmpcnt2=maxcnt ! second list
	! add for nonstock lastprice
	if UCase$(RTrim$(LPType$))="NSTK" let nonstk=1
	if nonstk ! additional data from SetNewProdline
		! let lpnstk=1 ! customer(master)
		! let lpnstk=2 ! shiplist(site)
		if lpnstk=2 ! need sllst file
			SLC=OpenFile(-9982,IntCo) \ if slc=-1 Error 42
		Endif
		if lpnstk=0
			Let E$=" No Last Price File Sent" ! +Prod$
			Let ReturnStatus=0
			if debugdetail
				dmsg$=prod$+e$ \ Call updatelog(debug)
			Endif
			Exit Sub
		Endif
		if lpnstk=1 let x3=chf(LPC)-1
		if lpnstk=2 let x3=chf(SLC)-1
		if lprec<=0 or lprec>x3 or fra(lprec)
			Let E$=" Invalid Last Price Record Sent" ! +Prod$
			Let ReturnStatus=0
			if debugdetail
				dmsg$=prod$+e$ \ Call updatelog(debug)
			Endif
			if lpnstk=2 try close #slc Else rem
			Exit Sub
		Endif
		Prod$="Z ZZZZZZZZZZ" ! set for default/missing
		chan=lpc
		if lpnstk=2 let chan=slc
		read record #chan,lprec,0;clp.;
		call NSFRMLP()
		if lpnstk=2
			if slc try close #slc Else rem
		Endif
		goto GotLPNS
	Else ! stock item
		tmp$=ChkAltItem$(e$,IntCo,Prod$,roh.CustNum)
		If tmp$<>"" If tmp$[1,2]<>"  " let prod$=tmp$ ! has alt item
	Endif
	Let kpr$=Prod$
	Let kpr$[13]="";e=0 ! no lock
	If prod$[1,3]="Z  " let Nonstk=1;ZLine=1
	If Prod$[1,3]="Z Z" let nonstk=1
	If Abs(SQty)>9999999 or ABS(SHQTY)>9999999 or ABS(BOQTY)>9999999
		E$="Quantity is out of range"
		returnstatus=0
		Exit Sub
	Endif
	If not(ZLine) ! still get prod for nonstk
	 PRR = filegetprod(e$,PRC,"=",1,KPr$,PR.,e)
	 clear e$
	 If PRR<=0 ! not found
		Let E$="PRODUCT NOT FOUND "+Prod$
		Let ReturnStatus=0
		if debugdetail
			dmsg$=prod$+e$ \ Call updatelog(debug)
		Endif
		Exit Sub
	 Endif
	Endif
	
	Clear rol. ! clear rol. to start
	GotLPNS: ! start for nonstk from lp (rol filled)
	Clear nrol. ! clear new data (as is none yet)
	Clear specs[] ! clear specs vars
	FlePtr[4,1]=0;LPR=0 ! clear last price info! 239790
	
	! check if valid um# sent
	if SUM=0 ! was not(nonstk) and 
		let sum=pr.UMSellDefault
	Endif
	If not(nonstk) and SUM<>0 ! can't check what's not there!
	 Flag=ChkPrdUM(e$,SUM,IntCo,Pr.)
	 If Not(Flag)
		Let E$="INVALID QUANTITY U/M "+Prod$
		Let ReturnStatus=0
		if debugdetail
			dmsg$=e$+" Rec "+Str$(SUM) \ Call updatelog(debug)
		Endif
		Exit Sub
	 Endif
	Endif
	Read Record #OHC,OHR,0;roh.; ! still there from getordrec?
	if p61$[136,136]="Y"
		let nrol.currid=roh.currid
		let nrol.currfact=roh.currfact
		let rol.currid=roh.currid
		let rol.currfact=roh.currfact
	endif
	Credit=0 \ if roh.Status>=8 and roh.Status<=12 Let Credit=1
	If ROH.OrgStatus>=8 AND ROH.OrgStatus<=12 let Credit=1
	if returnstatus<>0
			call verifystat()
			if returnstatus=99
				exit sub
			endif
	endif
	if credit and roh.ShipType=3 let cost_lev[1]=0 ! no cost on cm price error
	OrderNo=roh.OrdNum
	If ZLine ! set needed, rest zero/null
		rol.NStkItem=1
		rol.OrdNum=roh.OrdNum
		rol.Desc1$=Blank$
		rol.Desc2$=Blank$
		rol.whse=roh.wh
		let rol.linetype=3
		rol.ProdCode$="Z"+Blank$
		rol.PSlsCat=20
		rol.ComdtyCode$="MISC"
		goto GNPDDone ! clear & submit nothing for zlines
	Endif
	X1=roh.ordtype
	if SQty<0 and (credit Or (x1=4 or x1=7 or x1=8 or x1=15 or x1=16 or x1=24))
		E$="No Negative Order Quantity allowed"
		returnstatus=0
		Exit sub
	Endif
	! okay, convert qty to BASE
	let cnvtu[0]=SUM;cnvtu[1]=0;cnvtu[2]=1
	let cnvta=SQty
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	Let rol.QtyOrd=Int(Amount) ! always integer base - just cut it
	IF SQTY<0 AND (SHQTY<>0 or BOQTY<>0) ! NO BO AND SHIP SAME!
		SHQTY=SQTY;BOQTY=0
	Endif	
	if SHQty ! order pad detl allows entry
		cnvta=SHQty
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		MSHQty=Amount;rol.QtyShip=Amount
	Endif
	If BOQty ! order pad detl allows entry
		cnvta=BOQty
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		MBOQty=Amount;rol.QtyBO=Amount
	Endif
	If SQTY>0 and (SHQTY<0 or BOQTY<0)
		Let E$="INVALID QUANTITY ENTERED +/- "+Prod$
		Let ReturnStatus=0
		Exit Sub
	Endif
	If SQTY<0 and (SHQTY>0 or BOQTY>0)
		Let E$="INVALID QUANTITY ENTERED -/+ "+Prod$
		Let ReturnStatus=0
		Exit Sub
	Endif
	! set up rol. vars for ease of use
	
	! now get whse
	Let kpw$=" ",kpw$;e=0
	kpw$=prod$+roh.Wh Using "##"
	if roh.ordtype=7 let kpw$=prod$+roh.ConsWh Using "##"
	If Not(NonStk)
	 rol.UpdtStk=1 ! default=Y
	 rol.ComdtyCode$=pr.ComdtyCode$+Blank$
	 if roh.ordtype=8 or roh.ordtype=16 ! see if to whse exists
	   If Roh.ConsWh>0 and roh.conswh<100
		Let TPWKey$=" ",tpwKey$
		TPWkey$[1,12]=prod$[1,12]+Blank$
		TPWKey$[13]=ROH.ConsWh Using "##"
		call chktowhse(TPWKey$,pr.PrimVend)
	   Endif
	 Endif
	 PWR=filegetprodwhse(e$,PWC,"=",1,KPw$,PW.,e)
	 clear e$
	 if pwr<0 ! NOT FOUND
		clear pw.
		If P61$[59,59]="Y" or (Credit and (roh.ordtype=7 or roh.ordtype=8)) ! not allowed new prodwhse
			Let E$="Product "+Prod$+"Not Available In this Warehouse"
			Let ReturnStatus=0
			if debugdetail
				dmsg$=e$+" Sysflag 61-59,59 Y "+Str$(roh.wh) \ Call updatelog(debug)
			Endif
			Exit Sub
		Endif
		If PWR=-1 ! not found - add now?
			x3=kpw$[13,14] ! header/cons whse
			Whbld[0]=PWC;Whbld[1]=x3;WhBld[2]=pr.PrimVend
			if x3<>1 let Whbld[1]=x3+.01 ! fra=copy whse 1
			Call mxwhcreate(e$,IntCo,PROD$,WHBLD[])
			PWR=Whbld[2];E$=""
			Read record #PWC,PWR,0;PW.;
			if debugdetail
				dmsg$="Build new whse  "+kpw$ \ Call updatelog(debug)
			Endif
		Endif
	 Endif ! of whse not found
	Else ! is nonstk
	 Clear pw.
	 rol.UpdtStk=0 ! can't happen!
	Endif
	! Needs a Prodgroup check (in case single entry!)
	If PW.ProdGrp>0 ! has a group
		Pram[0]=ROH.OrdType !  \ if TScan=2 Let Pram[0]=0-OType
		Pram[1]=PW.ProdGrp
		Pram[5]=0 ! file not opened
		![0]=Order or (-)PO Type
		! [1]=Product Group
		! [2]=Allow on Ord/PO (1=y, 0=N)
		! [3]=Update Stock (1=y, 0=N)
		! [4]=On Price List (0/1)
		! [5]=Channel of 2/ProdGrp#
		Call ProdGroup(e$,intco,Pram[])
		If Pram[2]=0  ! not allowed on OType
			E$="Product "+Prod$+"Not Allowed on this Order Type!"
			returnstatus=0
			if debugdetail
				dmsg$=E$+" OT "+Str$(ROH.OrdType)+" PG "+Str$(PW.ProdGrp) \ Call updatelog(debug)
			Endif
			Exit Sub
		Endif
		rol.UpdtStk=Pram[3] ! update Stock
	Endif
	If not(nonStk) and not(credit) ! now a restricted item check
		! set up 
		clear x[]
		clear s9[]
		clear pram[]
		x[1]=PRC;X[2]=CUC ! prod,cust chan
		S9[1]=prr;s9[2]=CUR ! prod,cust records
		pram[2]=roh.wh ! whse to check
		if roh.ordtype=7 let pram[2]=roh.ConsWh ! use consignment?
		Clear tmp2$
		call chkrprod(e$,intco,X[],S9[],PRAM[],Tmp2$)
		if pram[0]=0  ! 0=restrict, <>0=ok
			e$=tmp2$;returnstatus=0
			if debugdetail
				dmsg$=E$ \ Call updatelog(debug)
			Endif
			exit sub
		Endif
	Endif
	Call SetNewRol() ! use std routine to define rol vars
	! remainder = get prices,costs,tax, rbt/sp, wh/ttl avail, last price info, future cost
	if rol.ComdtyCode$="" or rol.ComdtyCode$=Blank$[1,4]
		If Not(NonStk) Let rol.ComdtyCode$=pr.ComdtyCode$
	Endif
	if MSHQty or MBOQty ! entered something manually (and setnewrol defaults to Ordqty)
		let rol.QtyShip=MSHQty ! as entered (override calc)
		let rol.QtyBO=MBOQty ! as entered
	Endif
	rol.UMSell=SUM ! just in case
	rol.AltSupsd=afrm ! where added-0=normal,1=alt,2=supersede
	rol.OrgProdCode$=blank$
	if afrm let rol.OrgProdCode$=OrgProd$+blank$
	! as call prodgroup changes updtstk flag - redo it
	IF CREDIT AND roh.ShipType=3 LET rol.UpdtStk=0
	IF CREDIT AND roh.ShipType=7 LET rol.UpdtStk=0
	IF roh.OrdType=16 and ROH.XferAuth=0 let rol.UpdtStk=0 ! whxfer not auth
	if roh.ordtype=15 or roh.ordtype=4 let Cust.BoSAllowedFlag=1 ! will always allow bo's
	IF roh.ordtype=2 or roh.ordtype=5 let rol.UpdtStk=0
	if roh.ordtype=3 and p60$[22,22]<>"Y" LET rol.UpdtStk=0 ! indir no stk
	if custom_customer$="OMAHA"
        ! default ord type 38 to update stock=N cct176559/task10467
		if roh.ordtype=38 let rol.updtstk=0 
	endif
	tmp$=rol.ComdtyCode$
	if tmp$="LABR" OR tmp$="TIME" OR tmp$="MACH" LET rol.UpdtStk=0 ! comm's no stk
	rol.UpdtStk=0 ! ALWAYS ON QUOTES!!
	If NonStk ! can't call price
		rol.NStkItem=1;rol.UpdtStk=0
		! rol.umsell=0
		FutCost=0
		LPR=0;fleptr[4,1]=0
		tmp$=" ",tmp$;tmp$=Pr.ComdtyCode$+Blank$;tmp$[5]=""
		CMR=filegetcommhead(e$,CMC,"=",1,tmp$,cmc.)
		clear e$
		Goto NSBypass
	Endif
	let HasLPflag=GetAskLP() ! also gets lpr & clp.
	asklpflag=0 ! only used later
	if HaSLPflag=1 let LPR=-1 ! double sure (1=NO LP)
	! task 36848 - make price call with correct(or changed) UM's!
	! sys flag p61$[12,12] (set OE UM = LP UM)
	If P61$[12,12]="Y" and LPR>0 AND PR.CatchwgtItem$<>"Y"
		IF clp.UMSell LET rol.UMSell=clp.UMSell  ! ;SUM=clp.UMSell
		IF clp.UMPrice LET rol.UMPrice=clp.UMPrice
		IF clp.UMCost LET rol.UMCost=clp.UMCost
	Endif
	! sys flag p60$[30,30] = price um = sell um (UN[1]=UN[0])
	If P60$[30,30]="Y" and PR.CatchwgtItem$<>"Y"
		let rol.UMPrice=rol.UMSell
	Endif
	! sys flag p61$[61,61] = cost um = price um
	If P61$[61,61]="Y" Let rol.UMCost=rol.UMPrice
	! and now set specs
	Call SetupSpecs()
	! the above matches a mx299 call (no price/cost/etc
	Call getprice()
	! parse out returned data
	if Specs[0]=0 ! no error - process away
		rol.UpChrg=Specs[16]
		rol.UnitCost=Specs[17]
		rol.LineCost2=Specs[18]
		rol.UnitPrice=Specs[20]
		rol.LineDisc=Specs[21]
		rol.LineDiscPct=Specs[22]
		rol.NetPrice=Specs[23]
		rol.RebtContract=Specs[24]
		rol.PriceOrigin=Specs[25]
		rol.CostOrigin=Specs[26]
		rol.Contract=Specs[27]
		rol.SpCommPct=Specs[28]
		rol.BrkLvl=Specs[29]
		rol.LoadUpchrg=Specs[40]
		! check to see if the price call changed the price or cost unit 
		IF SPECS[14]<>rol.UMPrice ! "price unit changed     
		  let rol.UMPrice=specs[14]
		REM    PUM$=xunit$(ROL.UMPrice,ccc) ! u/m
		ENDIF                                                              
		IF SPECS[15]<>rol.UMCost ! "cost unit changed   
			let rol.UMCost=SPECS[15]
		rem 	CUM$=xunit$(ROL.UMCost,ccc) ! u/m
		ENDIF
		if p61$[116,116]="Y" and roh.ordtype=2 and rol.unitcost=0 and rol.unitglcost<>0
		    !! mtg
			let ltbl=0
			if p9$[32,32]="Y" and pw.load1muptbl>0
				let ltbl=pw.Load1MupTbl
			endif
			if not(ltbl)
				if pr.load1muptbl>=0 
					let ltbl=pr.Load1MupTbl
				endif
			endif
			if not(ltbl)
				Read #1,182,4;nsltbl;
				if nsltbl>0 let ltbl=nsltbl
			endif		
			if ltbl>0
				LET PREC[0]=prr ! product record #    
				if pr.lbsfact<=0 let pr.lbsfact=1
				leT PREC[2]=FNR(ABS((ROL.LbsUnit*ROL.QtyOrd)/pr.LbsFact)) ! ext weight of line (ordered)  
				IF ROL.LbsUnit<>0 AND ROL.LbsUnit<>pr.lbsunit! line lbs different from prod file lbs         
					LET PREC[3]=ROL.LbsUnit                                                      
				ELSE                                                                     
					LET PREC[3]=0                                                          
				ENDIF                                                                    
				LET CNVTA=rol.unitglcost ! use g/l cost                             
				LET SCR=-roh.ordtype ! negative otyp means force the base cost  
				let wh=roL.whse
				CALL "MXLOAD5.DL4",SCR,WH,LTBL,PREC[],CNVTA,IntCo,e$,rstr$                               
				let rol.unitcost=cnvta 
			endif		
		endif
	Endif
	! needs UM check after price call
	Let LPR=fleptr[4,1] ! sent last price record
	If LPR>0
		Read record #LPC,LPR,0;clp.;
		if custom_customer$="SWP"
			if MSGDESC$[1,9]="Permanent"
				if Clp.Umprice<>rol.umprice
					rol.umprice=Clp.UMPrice
					rol.PriceFactor = UMtoFactor(rol.umprice) 
				endif
			endif
		endif
	Else
		! Cust flag a$[138,138] = auth buy list (only if on lastprice file!)
		If cust.AuthBuyList$="Y"
			E$="Product "+Prod$+"Not on the Buy List!"
			if debugdetail
				dmsg$=E$+" "+rol.prodcode$ \ Call updatelog(debug)
			Endif
			Exit Sub
		Endif
		
	Endif
	If LPR<=0 and not(rol.NStkItem) ! no lastprice on stkitem
		if P61$[25,25]="P" and not(credit) ! and rol.AltSupsd=0
			if substitm let rol.AltSupsd=Int(rol.AltSupsd)+.1
		Endif
	Endif ! prompt if not in lastprice and prod
	! sys flag p61$[12,12] (set OE UM = LP UM)
	If P61$[12,12]="Y" and LPR>0 AND PR.CatchwgtItem$<>"Y"
		IF clp.UMSell LET rol.UMSell=clp.UMSell  ! ;SUM=clp.UMSell
		IF clp.UMPrice LET rol.UMPrice=clp.UMPrice
		IF clp.UMCost LET rol.UMCost=clp.UMCost
	Endif
	! sys flag p60$[30,30] = price um = sell um (UN[1]=UN[0])
	If P60$[30,30]="Y" and PR.CatchwgtItem$<>"Y"
		let rol.UMPrice=rol.UMSell
	Endif
	! sys flag p61$[61,61] = cost um = price um
	If P61$[61,61]="Y" Let rol.UMCost=rol.UMPrice
	If Rol.umsell<>SUM ! UM change - reget base
		! okay, reconvert qty to BASE
		let cnvtu[0]=Rol.umsell;cnvtu[1]=0;cnvtu[2]=1
		let cnvta=SQty  ! BIG Q: is cutting known at this point??? *****
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		Let rol.QtyOrd=Int(Amount) ! always integer base - just cut it
		let rol.QtyShip=rol.qtyord
		SUM=Rol.UMSell
	Endif
	rol.SellFactor=UMtoFactor(rol.UMSell) ! reget in case changed!
	rol.PriceFactor=UMtoFactor(rol.UMPrice)
	rol.CostFactor=UMtoFactor(rol.UMCost)
	! future cost = cost as of xx days from today (specs[5] chg)
	JDate=TIM(6)+FCDays ! ## days from today
	tmp$=JDate$(jdate) ! from ddddd to MM/DD/YYYY
	tmp1$=Formatdate2$(tmp$) ! now MM/DD/YYYY to YYYYMMDD
	Let FDate=tmp1$[3,8] ! just need yymmdd
	Let Specs[5]=0-FDate
	Call getprice() ! call price w/all entries above
	If Specs[0]=0 ! okay
		Let X3=Specs[17]
		cnvtu[0]=0;cnvtu[1]=rol.UMCost;cnvtu[2]=2
		Cnvta=X3 \ if rol.numout>0 let cnvta=x3/rol.numout
		FutCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	Endif
	! quick avail check
	x2[9]=rol.whse \ if roh.ordtype=7 let x2[9]=roh.ConsWh
	If RTrim$(rol.ProdCode$)<>""
		X3[1]=getwhavail(e$,intco,PWC,rol.ProdCode$,X2[9])
	Else
		x3[1]=0
	Endif
	! note was dnr AND - causes issue - change to IF (NO CHK ON QUOTES)
	!if pw.DNReordFlg=1 If ((ROL.UpdtStk and x3[1]<=0) or (Not(ROL.UpdtStk))) ! dnr and no avail
	!	E$="Product "+Prod$+"is a Do Not Reorder!"
	!	if debugdetail
	!		dmsg$=E$+" DNR "+Str$(pw.DNReordFlg)+" AVL "+Str$(x3[1]) \ Call updatelog(debug)
	!	Endif
	!	Exit Sub
	!Endif
	kit=0
	If not(nonstk) ! wait for complete to write zline/nonstk
	 IF P9$[2,2]="D" AND P9$[20,20]<>"F" AND pr.MBFlg$="M" 
		IF P9$[22,22]="Y" AND NOT(CREDIT)
			if rol.LineType=0 and rol.qtyship>0 ! only stock items
				LET KIT=1
			Endif
		Endif
	 ENDIF
	Endif
	x=0 \ if p60$[27,27]="S" let x=1
	if p60$[27,27]="B" let x=2
	if p60$[27,27]="E" let x=3
	rol.QtyShip=rol.QtyOrd
	rol.QtyBO=0 ! default to all ship
	!if Not(credit) and X>0 ! has bochk set
	! If rol.qtyord>0 and ROL.UpdtStk and rol.QtyOrd>X3[1] ! order > whavail
	!  if x3[1]>0 ! has some avail
	!	Let rol.QtyShip=X3[1] ! take it all
	!	Let rol.QtyBO=rol.QtyOrd-rol.QtyShip
	!  Else ! zero or <0 avail
	!	Let rol.QtyShip=0
	!	Let rol.QtyBO=rol.QtyOrd ! all backordered
	!  Endif
	! Endif ! of updt and ord>avail
	!Endif
	! added 2/28 - convert shipped/bo to sell 2 dec - 2316
	if rol.qtyship<>0
		cnvtu[0]=0;cnvtu[1]=rol.UMSell;cnvtu[2]=1
		cnvta=rol.qtyship
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		tmp$=LTrim$(amount using "----------#.##")
		amount=tmp$ ! now 2 decimals only
		IF SWUO LET AMOUNT=INT(AMOUNT) ! just cut off decimals (whole sell units only)
		cnvtu[0]=rol.UMSell;cnvtu[1]=0;cnvtu[2]=1
		cnvta=amount
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if amount<>rol.qtyship ! it changed
			rol.qtyship=amount
			if rol.qtyship>x3[1] let rol.qtyship=x3[1] ! no overship!
			Let rol.QtyBO=rol.QtyOrd-rol.QtyShip
		Endif
	Endif ! of recalc qty ship based on 2 dec
	NSBypass: ! can't get price avail etc for non-stk
	if MSHQty or MBOQty ! manually entered this - keep it?
		let rol.QtyShip=MSHQty ! as entered (override calc)
		let rol.QtyBO=MBOQty ! as entered
	Endif
	if roh.ordtype=15 let rol.qtyship=0;rol.qtybo=0 ! starts as zero
	if Cust.BoSAllowedFlag=0 Let rol.QtyBO=0 ! no bo's allowed
	if pw.DNReordFlg=1 and rol.qtybo let rol.qtybo=0 ! no bo
	if roh.ordtype=4 let rol.QtyBO=0 ! no bo's allowed on ot4? - 32160
	GNPDDone: ! go here for zline / nonstk (DO NOT CREATE LINE!)
	! we need to make sure base is correct for display
	cnvtu[0]=0;cnvtu[1]=rol.umprice;cnvtu[2]=2 ! base to display
	cnvta=rol.UnitPrice
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	cnvtu[0]=rol.umprice;cnvtu[1]=0;cnvtu[2]=6 ! display back to base
	cnvta=amount
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	rol.unitprice=amount ! done unit price
	cnvtu[0]=0;cnvtu[1]=rol.umprice;cnvtu[2]=2 ! base to display
	cnvta=rol.NetPrice
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	cnvtu[0]=rol.umprice;cnvtu[1]=0;cnvtu[2]=6 ! display back to base
	cnvta=amount
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	rol.NetPrice=amount ! done net price
	cnvtu[0]=0;cnvtu[1]=rol.UMCost;cnvtu[2]=2 ! base to display
	cnvta=rol.UnitCost
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	cnvtu[0]=rol.UMCost;cnvtu[1]=0;cnvtu[2]=6 ! display back to base
	cnvta=amount
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	rol.UnitCost=amount ! done unit cost
	Let elflag=0 ! NOT an existing line
	! won't be cut or LOT Price here?
	! ADDED - Create line NOW! (unless maxcnt<0)
	! clear / set up misc fields
	IF rol.UMCutCost=-3 AND rol.QtyOrd LET CHBASE=(rol.CutCost/rol.QtyOrd) ELSE  LET CHBASE=rol.CutCost
	X3[4]=rol.UnitCost+CHBase
	X3[3]=X3[4]
	IF rol.LoadUpchrg ! has cost up
		IF rol.LoadUpchrg<0 ! $ amount
			X3[3]=X3[4]+Abs(rol.LoadUpchrg)
		Else ! percent
			X3[3]=X3[4]+(X3[4]*(rol.LoadUpchrg/100))
		Endif
	Endif
	NetCost=X3[3]
	cnvtu[0]=0;cnvtu[1]=rol.UMCost;cnvtu[2]=2 ! base to display
	cnvta=NetCost
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	cnvtu[0]=rol.UMCost;cnvtu[1]=0;cnvtu[2]=6 ! display back to base
	cnvta=amount
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	NetCost=amount ! done net cost
	If roh.OrdType=37  ! "EVAP Ship - NO Price - any order in here
		If Not(Credit) Or (Credit And roh.ShipType=16)
			Let rol.UnitPrice=0;rol.NetPrice=0;rol.CutChrg=0
			Let rol.LineDisc=0;rol.LineDiscPct=0;rol.UpChrg=0
		Endif
	Endif
	If roh.OrdType=36 ! "EVAP Billing - NO Cost - Any type order
		If Not(Credit) Or (Credit And roh.ShipType=16)
			Let rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
			Let rol.CutCost=0;rol.ExtCutCost=0;rol.ExtLoadShip=0;rol.ExtLoadOrd=0
			rol.LoadUpchrg=0;NetCost=0
		ENDIF
	Endif
	LET rol.ExtOrdAmt=FNR(rol.QtyOrd*Rol.NetPrice)
	LET rol.ExtLoadOrd=FNR(rol.QtyOrd*NETCOST)
	IF roh.ordtype=4 OR roh.ordtype=15 ! "bill and hold
	  IF roh.ordtype=15 
		if roh.BOCTR=0 let rol.CurrBillQty=rol.QtyOrd Else let rol.CurrBillQty=0
	  Endif
	  IF roh.ordtype=4 let rol.CurrRelQty=rol.QtyShip
	  If roh.ordtype=4 and custom_Customer$="MORRISETTE" let rol.CurrBillQty=rol.Qtyship
	  LET rol.ExtShipAmt=FNR(rol.CurrBillQty*Rol.NetPrice)
	  LET rol.ExtLoadShip=FNR(rol.CurrBillQty*NETCOST)
	ELSE
	  LET rol.ExtShipAmt=FNR(rol.QtyShip*Rol.NetPrice)
	  LET rol.ExtLoadShip=FNR(rol.QtyShip*NETCOST)
	ENDIF
	IF rol.UMPrice=-2 ! lot
	  LET rol.ExtOrdAmt=FNR(Rol.NetPrice)*SGN(rol.QtyOrd)
	  IF roh.ordtype=4 OR roh.ordtype=15
		LET rol.ExtShipAmt=FNR(SGN(rol.CurrBillQty)*Rol.NetPrice)
	  ELSE
		LET rol.ExtShipAmt=FNR(Rol.NetPrice)*SGN(rol.QtyShip)
	  ENDIF
	ENDIF
	IF rol.UMCost=-2 ! LOT
	  LET rol.ExtLoadOrd=FNR(NETCOST*SGN(rol.QtyOrd))
	  IF roh.ordtype=4 OR roh.ordtype=15
        LET rol.ExtLoadShip=FNR(NETCOST*SGN(rol.CurrBillQty))
	  ELSE
		LET rol.ExtLoadShip=FNR(NETCOST*SGN(rol.QtyShip))
	  ENDIF
	ENDIF
	if rol.WgtFactor<=0 let rol.WgtFactor=1
	rol.ExtNetWgt=FNR(Abs((rol.QtyShip*rol.LbsUnit)/rol.WgtFactor))
	rol.Status=11 \ if credit let rol.Status=12
	rol.KitDesignation$=blank$
	ROL.MWgt=rol.LbsUnit
	rol.RepairLine$=blank$
	rol.HldForPo$=blank$
	rol.SpareNU1$=blank$
	clear rol.SpareNu$ ! dl4 fix
	! rol.AwmDeal$=blank$ not defined on qol
	!rol.SpareNU$ = Blank$;X0=LEN(rol.SpareNU$)
	!		IF X0>1
	!			rol.SpareNU$[X0-1] = ""  ! for the key
	!		ENDIF
	if debugdetail
		dmsg$="New Line Setup "+Str$(Orderno)+" - "+rol.prodcode$ \ Call updatelog(debug)
	Endif
	! special processing here!!!
	if roh.OrdType=8 or roh.OrdType=16 ! cons/trans - no price/cost
			rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
			rol.UnitPrice=0;rol.CutChrg=0;rol.CutCost=0
			rol.LineDisc=0;rol.ExtOrdAmt=0;rol.ExtShipAmt=0
			rol.LineDiscPct=0;rol.ExtCutChg=0;rol.ExtCutCost=0
			rol.ExtLoadShip=0;rol.ExtLoadOrd=0;rol.NetPrice=0
			rol.TaxAmt=0;rol.LoadUpchrg=0;rol.UpChrg=0
	Endif
	If p61$[46,46]="Y" and Credit and roh.shiptype=3 ! price fix - no cost
			rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
			rol.CutCost=0;rol.ExtCutCost=0;rol.ExtLoadShip=0;rol.ExtLoadOrd=0
			rol.LoadUpchrg=0
	Endif
	!if roh.ordtype=15
	!	if roh.BOCTR=0 let rol.CurrBillQty=rol.QtyOrd Else let rol.CurrBillQty=0
	!	rol.ExtShipAmt=FNR(rol.CurrBillQty*rol.NetPrice) ! ext price
	!	rol.ExtLoadShip=FNR(rol.CurrBillQty*X3[3]) ! ext net cost
	!Endif
	If not(nonstk) ! wait for complete to write zline/nonstk
	 IF P9$[2,2]="D" AND P9$[20,20]<>"F" AND pr.MBFlg$="M" 
		IF P9$[22,22]="Y" AND NOT(CREDIT)
			if rol.LineType=0 and rol.qtyship>=0 ! only stock items
				LET rol.KitDesignation$="KIT"
			Endif
		Endif
	 ENDIF
	 if rol.OrgPriceUnit<=0 let rol.OrgPriceUnit=ROL.UnitPrice ! save on entry?
	 IF rol.OrgLoadCost<=0 let rol.OrgLoadCost=rol.UnitCost ! save on entry
	 rol.PDRecNum=PRR
	 rol.SpareNU3$=blank$
	 clear rol.SpareNu$ ! dl4 fix
	 if maxcnt<0 exit sub ! DON'T CREATE A LINE FLAG!!
	 X2=GetNxtLine(orderno) ! GET NEXT LINE# 
	 rol.linenum=x2;E=0;olr=0
	 OLR=fileupdateqolz(e$,OLC,"a",e,rol.) 
	 If Not(nonstk) and rol.UpdtStk and OLR>0
		if debugdetail
			dmsg$="New Line Added "+Str$(Orderno)+"-"+Str$(rol.Linenum) \ Call updatelog(debug)
		Endif
		if Not(Credit) and rol.UpdtStk ! add NEW qty ord to prod & whse
			tmp$=ShipDate Using "&&&&&&"
			Call DateToJulian(1,tmp$,tmp1$,F)
			IF F let tmp1$=""
			JDate[1]=tmp1$;F=0 ! julian sys shipdate
			tmp$=roh.ShipDate Using "&&&&&&"
			if roh.ShipDate<>999999 Call DateToJulian(1,tmp$,tmp1$,F)
			If f let tmp1$=""
			JDate[2]=tmp1$ ! julian ord shipdate
			Read record #PRC,PRR,0;PR.
			If PWR>0 Read Record #PWC,PWR,0;pw.
			X3=ROL.QtyShip
			if roh.OrdType=4 or roh.OrdType=15 or roh.ordtype=19 let x3=rol.QtyOrd-rol.PrevQtyShip-rol.QtyBO
			if custom_customer$="MORRISETTE"
				If roh.OrdType=4 Let x3=ROL.QtyShip ! "cct 129415 - only commit shipping qty
			Endif
			IF roh.OrdType=15 AND roh.BOCTR<>0 LET x3=0        
			IF roh.OrdType=15 AND roh.BOCTR=0 LET x3=rol.QtyOrd
			pr.QtyOnOrd=pr.QtyOnOrd+X3
			pw.QtyOnOrd=pw.QtyOnOrd+x3
			IF JDATE[1]>=JDATE[2]
				LET pr.Lvl1Qty=pr.Lvl1Qty+x3
				Let pw.Lvl1Qty=pw.Lvl1Qty+x3
			ELSE
				LET pr.Lvl2Qty=pr.Lvl2Qty+x3
				Let pw.Lvl2Qty=pw.Lvl2Qty+x3
			Endif
			if pr.CatchwgtItem$="Y"
				X=1 \ if rol.QtyOrd<0 let x=-1 ! neg ord/ship (wgt always +)
				IF roh.OrdType=15 AND roh.BOCTR<>0 LET x=0 ! NO QTY
				pr.LbsOnOrder=pr.LbsOnOrder+(rol.ExtNetWgt*x)
				pw.LbsOnOrder=pw.LbsOnOrder+(rol.ExtNetWgt*x)
			Endif
			! Write Record #PRC,PRR,0;PR.;
			! If PWR>0 Write Record #PWC,PWR,0;pw.;
			! do allocate to none/stock location now!
			! Call ChkWhRasl(e$,intco,Ctlc,WHI,rol.Whse,RASL[])
			Atype=0 \ if credit let Atype=1
			FChan[0]=OHC;FChan[1]=OLC;FChan[2]=SLTC;FChan[3]=PLTC
			FRec[0]=OHR;FRec[1]=OLR
			! call Allocordlot(e$,intCo,AType,FChan[],FRec[],Rasl,Status)
			if debugdetail
				dmsg$="New Line Allocated " \ Call updatelog(debug)
			Endif
		Endif ! write on order to prod/whse
		elflag=1 ! now exists
	 Endif 
	 !If P60$[44,44]="Y" AND olr>0
		!clear etr.
		!etr.EtAction=11 ! send action
		!call EdttrkDO(nrol.,rol.) ! org,new
		!if debugdetail
		!	dmsg$="Line Edittrack " \ Call updatelog(debug)
		!Endif
	 !Endif ! of edit tracking
	 
	Else ! do nonstk update (no zline on erp!)
      If not(ZLine) ! did NSFRMLP above!
		 X2=GetNxtLine(orderno) ! GET NEXT LINE# 
		 rol.linenum=x2;E=0;olr=0
		 nstk.LineNum=x2
		 rol.ProdCode$ = roh.OrdNum Using "######"                      
		 rol.ProdCode$ = rol.ProdCode$ + "-" + rol.LineNum Using "&&&"
		 rol.ProdCode$ = rol.ProdCode$ + Blank$                        
		 nstk.ProdCode$ = rol.ProdCode$ 
		 rol.SpareNU3$=blank$
		 clear rol.SpareNu$ ! dl4 fix
		 OLR=fileupdateqolz(e$,OLC,"a",e,rol.) 
		 If OLR > 0 ! has to have a record!                           
				nstk.OrdLineRec = OLR  
				If CREDIT Let x = -1 Else Let x = 1 
				nstk.QtyShip=rol.QtyShip*x
				nstk.ExtShipAmt = (rol.ExtShipAmt * x) ! store credits as neg
				nstk.SpareNu$=blank$ ! make sure has space for key!
				clear nstk.Spare$ ! dl4 fix
				nsr = fileupdateqproddesc(e$,nsc,"a",0,nstk.) 
				If nsr > 0                                                    
					 rol.PDRecNum = nsr                                         
				Else                                                          
					 e$ = "NONSTOCK " + rol.ProdCode$ + " FILE NOT ADDED"
					 NSR=0 ! neg is no good in file
				End If
				rol.PDRecNum=NSR
				Write Record #olc,olr,0;rol.;
				elflag=1 ! exists
		 Else
			e$="Nonstock Line not added for "+rol.prodcode$
		 End If            
	  Endif ! no zline  
	 
	Endif ! of add stock/nstk line NOW
	Call LineMainDtl() ! generate/write list$ 
	! call programdump("/tmp/ollog1!","")
 else
    include "src/callsuberr.inc"
  end try
end sub ! GetNewProdDtl
! 
!--------------------------------------------------------------------
Sub GetPrice()
! finish price setup & call it
 Try
	dim 1%,dbg,dlog$[50],3%
	!let Debug=0 ! no, 1=yes
	!let Dlog$="/usr/dxport/files/6/dx.log" ! whence the debug log
	!If debugdetail let debug=1;dlog$=dblog$ ! set to this program
	!CALL "price.dl4",FLEPTR[],SPECS[],MSGDESC$,intco,debug,dlog$
	Let dbg=debug;dlog$=dblog$ ! pass what this program uses
	Call SysPriceCalc(e$,FLEPTR[],SPECS[],MSGDESC$,dbg,dlog$)
	if debugdetail
		!debug=1 ! reset
		dmsg$="PRICE CALLED "+Str$(SPECS[0]) \ Call updatelog(debug)
	Endif

	!
 else
    include "src/callsuberr.inc"
  end try
end sub ! GetPrice
! 
!--------------------------------------------------------------------
Sub Factorum(tmp$)
! from sent factor (in tmp$) - get um text for it
! if no match - send factor back as um
 Try
	dim um$[4]
	dim 1%,umrec
	dim 3%,factor
	let factor=tmp$
	if factor<=0 let factor=1
	umrec=0
	if factor=pr.UM2Fact let umrec=PR.UM2
	if factor=pr.UM3Fact let umrec=PR.UM3
	if factor=pr.UM4Fact let umrec=PR.UM4
	if factor=pr.UM5Fact let umrec=PR.UM5
	if factor=pr.UM6Fact let umrec=PR.UM6
	if factor=pr.UM7Fact let umrec=PR.UM7
	if factor=pr.UM8Fact let umrec=PR.UM8
	If factor=1 let umrec=pr.BaseUM
	if umrec>0 and umrec<chf(ccc) ! -1
		Read record #ccc,umrec,0;UMC.;
		let tmp$=umc.Code$ ! send back um attached
	Else
		if factor=1000 ! hardcode an "M"?
			tmp$="M" ! why not
		Else
			Let tmp$=Str$(Factor) ! send back w/no um (factor instead of um)
		Endif
	Endif
	if debugdetail
		dmsg$="Factor to UM" \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
  end try
end sub ! Factorum
! 
!--------------------------------------------------------------------
Sub WhseList(e$,List$[],maxcnt,ReturnStatus,Message$)
! this is determined by system flag P61$[59,59]
! if =Y - ONLY WHSE THAT CURRENTLY EXIST
! if =N - any valid whse
 Try
	Dim PWK$[60],Secname$[40]
	Dim 1%,Whse
	dim 2%,tmpcnt
	Dim 3%,PWR,WHIR
	Let ReturnStatus=1
	Message$="OK"
	Clear List$[]
	tmpcnt=maxcnt
	Secname$="WHSELIST" ! specify section name
	If P61$[59,59]="Y" ! only currently used whses for product
		List$[0]=bsdel$,Secname$,fdel$
		List$[1]="ID",fdel$,"WhName",fdel$ ! use same names as droplist
		row=2
		Pwk$=" ",Pwk$
		Pwk$=Prod$
		Do
			PWR=filegetprodwhse(e$,PWC,">",1,PWK$,PW.)
			clear e$
			If PWK$[1,12]<>Prod$ Let PWR=-2
			If PWR<0 Exit do
			Whse=PWK$[13,14]
			If Whse<1 or Whse>99 Exit do
			WHIR=Whse-1
			Read record #WHI,WHIR,0;WHI.;
			tmp$=RTrim$(WHI.WhName$)
			If tmp$<>"" ! whse defined
				List$[row]=Str$(Whse),fdel$,tmp$,fdel$
				row=row+1
				If row>tmpcnt let tmpcnt=expandarray(e$,List$[])
			Endif
		Loop
		List$[row]=esdel$ ! all done
	Else ! list all
		!Call filedroplistwhinfoz(e$,list$[],tmpcnt,WHI,Secname$) ! not correct - do manually
		List$[0]=bsdel$,Secname$,fdel$
		List$[1]="ID",fdel$,"WhName",fdel$
		row=2
		maxwhse=CHF(WHI)-1 \ if maxwhse>98 let maxwhse=98
		For I=0 to maxwhse ! CHF(WHC)-1 (99 is the ALLWHSE record)
			read record #WHI,I,0;whi.;
			if rtrim$(whi.WhName$)<>"" !indicates active record in non-indexed file
				WebStr$=Str$(I+1),fdel$,rtrim$(whi.WhName$),fdel$
				List$[row]=webstr$
				row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
			Endif
		Next I
		List$[row]=esdel$
		! returns with bsdel$,esdel$
	Endif
	if debugdetail
		dmsg$="Whse List sent p61-59,59 "+p61$[59,59]+" "+prod$ \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
  end try
end sub ! WhseList
! 
!--------------------------------------------------------------------
Sub RePrice()
! user wants complete price/cost get
 Try
	Dim KPR$[60],KPW$[60],kcm$[40],k1$[50]
	Dim SUM$[4],PUM$[4],CUM$[4]
	Dim 1%,Cnvtu[2],Flag,E,X[9],PT[37]
	Dim 2%,X2[9]
	Dim 3%,CNVTA,Amount,x3[9]
	if debugdetail
		dmsg$="Start RePrice" \ Call updatelog(debug)
	Endif
	Call DXGet("PRODID",prod$) \ prod$=UCase$(prod$)
	Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
	ProdKey$=Prod$
	PrR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.) ! product mode=2 dir=1
	clear e$
	If PRR<0
		E$="PRODUCT NOT FOUND"
		ReturnStatus=0
		
	Endif
			!
			! initialize status
	ReturnStatus=1
	Message$="OK"
	If PRR<0 Let ReturnStatus=0
	Call DXGet("ORDERID",tmp$)
	if tmp$="" 
			let e$="ORDER # MISSING"
			Let ReturnStatus=0
			
	Endif
	OrderNo=tmp$
	If OrderNo>0 and OrderNo<999999 and Not(Fra(OrderNo))
		OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
		If OHR<=0 ! no order found
			Let e$="ORDER # NOT FOUND"
			Let ReturnStatus=0
			
		Else
			Call GetCust()
		Endif
	Endif
	
	Call DXGet("WHSE",tmp$) ! if line whse <> header
	Whse=tmp$ \ if whse<1 or Whse>99 Let Whse=roh.wh
	Call DXGet("UMQTY",tmp$) ! Qty um id
	! If tmp$[1,1]>"9" ! sent text?
		R=getumrec(e$,CCC,tmp$,IntCo,PR.)
		If R<>0 let tmp$=Str$(R)
	! Endif
	SUM=tmp$
	Call DXGet("ORDQTY",tmp$)
	Let OrdQty=tmp$
	If ABS(OrdQty)>9999999999
		e$="Order Quantity out of range"
		returnstatus=0
	Endif
	! check if valid um# sent
	Flag=ChkPrdUM(e$,SUM,IntCo,PR.)
	If Not(Flag)
		Let E$="INVALID QUANTITY U/M"
		Let ReturnStatus=0
		
	Endif
	clear tmp$ ! jic not sent
	call dxget("QTYOUT",tmp$)
	pnumout=tmp$
	if pnumout<0 or pnumout>999 or fra(pnumout)
		let e$="INVALID QTY OUT"
		let returnstatus=0
	Endif
	clear tmp$ ! added #41670 - send price/cost UM to keep same
	Call DXGet("UMPRICE",tmp$) \ PUM=0 ! Price um id
	If tmp$<>"" ! sent text?
		R=getumrec(e$,CCC,tmp$,IntCo,PR.)
		If R<>0 let tmp$=Str$(R)
		PUM=tmp$
		! check if valid um# sent
		Flag=ChkPrdUM(e$,PUM,IntCo,PR.)
		If Not(Flag)
			Let E$="INVALID PRICE U/M"
			Let ReturnStatus=0
			
		Endif
	endif
	clear tmp$ ! added #41670 - send price/cost UM to keep same
	Call DXGet("UMCOST",tmp$) \ CSUM=0 ! Cost um id
	If tmp$<>"" ! sent text?
		R=getumrec(e$,CCC,tmp$,IntCo,PR.)
		If R<>0 let tmp$=Str$(R)
		CSUM=tmp$
		! check if valid um# sent
		Flag=ChkPrdUM(e$,CSUM,IntCo,PR.)
		If Not(Flag)
			Let E$="INVALID COST U/M"
			Let ReturnStatus=0
			
		Endif
	endif
	If ReturnStatus=0 ! something failed
		Message$=E$
		Goto RPrcDone:
	Endif
	Clear rol. ! we'll use those names
	Clear specs[] ! clear specs vars
	! okay, convert qty to BASE
	rol.numout=pnumout
	let cnvtu[0]=SUM;cnvtu[1]=0;cnvtu[2]=1
	let cnvta=OrdQty \ if pnumout>0 let cnvta=ordqty/pnumout ! CUTTING??
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	Let rol.QtyOrd=Amount
	Let roh.Wh=Whse
	rol.whse=roh.wh
	rol.prodCode$=ProdKey$
	! now get whse
	Let kpw$=" ",kpw$;e=0
	kpw$=rol.ProdCode$+rol.Whse Using "##"
	if roh.ordtype=7 let kpw$=rol.ProdCode$+roh.ConsWh Using "##"
	PWR=filegetprodwhse(e$,PWC,"=",1,KPw$,PW.,e)
	clear e$
	if pwr<0 clear pw.
	if pum ! sent it - make it default
		pr.UMPriceDefault=pum
	endif
	if csum ! sent it - make it default
		pr.UMCostDefault=csum
	endif
	Call SetNewRol() ! set up default line vars
	if pum ! sent price um
		let rol.umprice=pum
	endif
	if csum ! sent cost um
		let rol.umcost=csum
	endif
	! set up SPECS
	Call SetUpSpecs()
	! the above matches a mx299 call (no price/cost/etc
	Call getprice()
	let rol.currid=roh.currid
	if rol.currid>0 and rol.currid<=9999
		let rol.currfact=roh.currfact
	else
		let rol.currid=0
		let rol.currfact=0
	endif
	
	If Specs[0]=0 ! okay to go
		rol.UpChrg=Specs[16]
		rol.UnitCost=Specs[17]
		rol.LineCost2=Specs[18]
		rol.UnitPrice=Specs[20]
		rol.LineDisc=Specs[21]
		rol.LineDiscPct=Specs[22]
		rol.NetPrice=Specs[23]
		rol.RebtContract=Specs[24]
		rol.PriceOrigin=Specs[25]
		rol.CostOrigin=Specs[26]
		rol.Contract=Specs[27]
		rol.SpCommPct=Specs[28]
		rol.BrkLvl=Specs[29]
		rol.LoadUpchrg=Specs[40]
		IF SPECS[14]<>rol.UMPrice ! "price unit changed     
		  let rol.UMPrice=specs[14]
		  REM  PUM$=xunit$(ROL.UMPrice,ccc) ! u/m
		ENDIF                                                              
		IF SPECS[15]<>rol.UMCost ! "cost unit changed   
			let rol.UMCost=SPECS[15]
		REM	CUM$=xunit$(ROL.UMCost,ccc) ! u/m ok
		ENDIF      
	Endif
	If roh.OrdType=37  ! "EVAP Ship - NO Price - any order in here
		If Not(Credit) Or (Credit And roh.ShipType=16)
			Let rol.UnitPrice=0;rol.NetPrice=0;rol.CutChrg=0
			Let rol.LineDisc=0;rol.LineDiscPct=0;rol.UpChrg=0
			rol.ExtOrdAmt=0;rol.ExtShipAmt=0;rol.ExtCutChg=0
		Endif
	Endif
	If roh.OrdType=36 ! "EVAP Billing - NO Cost - Any type order
		If Not(Credit) Or (Credit And roh.ShipType=16)
			Let rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
			Let rol.CutCost=0;rol.ExtCutCost=0;rol.ExtLoadShip=0;rol.ExtLoadOrd=0
			rol.LoadUpchrg=0;Netcost=0
		ENDIF
	Endif
	List$[0]=bsdel$,"SYSPRICE",fdel$
	WebStr$="Unitprice",fdel$,"PriceUM",fdel$
	WebStr$=WebStr$,"LineDisc%",fdel$,"GP%",fdel$
	WebStr$=WebStr$,"PriceUpchrg",fdel$,"PriceUpType",fdel$
	WebStr$=WebStr$,"NetPrice",fdel$,"UnitCost",fdel$
	WebStr$=WebStr$,"CostUM",fdel$,"CostUpchrg",fdel$
	WebStr$=WebStr$,"CostUpType",fdel$
	webstr$=webstr$,"PRCORGN",fdel$,"CSTORGN",fdel$
	List$[1]=WebStr$
	Row=2
	SUM$=xunit$(ROL.UMSell,ccc) ! u/m
	PUM$=xunit$(ROL.UMPrice,ccc) ! u/m  (Q: what if changed?)
	CUM$=xunit$(ROL.UMCost,ccc) ! u/m   (Q: what if changed/diff?)
	cnvtu[0]=0;cnvtu[1]=rol.UMPrice;cnvtu[2]=2
	Cnvta=rol.UnitPrice \ if rol.umprice>0 and pnumout>0 let cnvta=rol.unitprice/pnumout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)    
	If p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 ! unit/net price
			let cnvcu[0]=1
			let cnvca[0]=x3
			cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
	endif
	WebStr$=LTrim$(X3 Using PMask$),fdel$ ! Unit price
	WebStr$=WebStr$,RTrim$(PUM$),fdel$ ! price um
	WebStr$=WebStr$,LTrim$(rol.LineDiscPct Using "###.##"),fdel$ ! line disc % (what of $?)
	X3[3]=rol.UnitCost ! NEED NET COST!!! for gp%
	IF rol.LoadUpchrg ! has cost up
		IF rol.LoadUpchrg<0 ! $ amount
			X3[3]=rol.UnitCost+Abs(rol.LoadUpchrg)
		Else ! percent
			X3[3]=rol.UnitCost+(rol.UnitCost*(rol.LoadUpchrg/100))
		Endif
	Endif
	x3=0
	if rol.NetPrice ! NEEDS A PRICE for GP
		X3=FNR(((rol.NetPrice-x3[3])/rol.NetPrice)*100)
	Endif   

	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! GP
	! send upcharge as amount & type
	tmp$="%" \ if rol.UpChrg<0 let tmp$="$"
	Let X3=rol.UpChrg
	If tmp$="$" ! need convert to price um
		cnvtu[0]=0;cnvtu[1]=rol.UMPrice;cnvtu[2]=2
		Cnvta=ABS(X3)
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)    
		If p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 ! unit gl cost
			let cnvcu[0]=1
			let cnvca[0]=x3
			cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
	Endif
	WebStr$=WebStr$,Ltrim$(X3 Using PMask$),fdel$,tmp$,fdel$ ! upchrg & type
	cnvtu[0]=0;cnvtu[1]=rol.UMPrice;cnvtu[2]=2
	Cnvta=rol.NetPrice \ if rol.umprice>0 and rol.numout>0 let cnvta=rol.NetPrice/rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)    
		If p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 ! unit gl cost
			let cnvcu[0]=1
			let cnvca[0]=x3
			cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
	WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! net price
	cnvtu[0]=0;cnvtu[1]=rol.UMCost;cnvtu[2]=2
	Cnvta=rol.UnitCost \ if rol.UMCost>0 and rol.numout>0 let cnvta=rol.UnitCost/rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	If p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 ! unit gl cost
			let cnvcu[0]=1
			let cnvca[0]=x3
			cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
	WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! unit cost
	
	WebStr$=WebStr$,RTrim$(CUM$),fdel$ ! Cost um
	! send upcharge as amount & type
	tmp$="%" \ if rol.LoadUpchrg<0 let tmp$="$"
	Let X3=rol.LoadUpchrg
	If tmp$="$" ! need convert to cost um
		cnvtu[0]=0;cnvtu[1]=rol.UMCost;cnvtu[2]=2
		Cnvta=ABS(X3)
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		If p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 ! unit gl cost
			let cnvcu[0]=1
			let cnvca[0]=x3
			cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
	Endif
	WebStr$=WebStr$,Ltrim$(X3 Using PMask$),fdel$,tmp$,fdel$ ! upchrg & type
	webstr$=webstr$,Str$(rol.PriceOrigin),fdel$,Str$(rol.CostOrigin),fdel$
	List$[row]=WebStr$
	Row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	List$[row]=esdel$ ! finished
	call AddToStr(e$,rstr$,List$[])
	
	RPrcDone: ! finished
	if debugdetail
		dmsg$="Reprice "+prod$+" "+Str$(Orderno)+" "+message$ \ Call updatelog(debug)
	Endif
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
  else
    include "src/callsuberr.inc"
  end try
end sub ! REprice
! 
!--------------------------------------------------------------------
Sub StkUpList()
! return options for stock update flag
  Try
	Dim KPW$[60]
	Dim 1%,UpdtStk,Pram[5],Whse
	Dim 2%,OType
	Dim 3%

	Call DXGet("PRODID",prod$) \ prod$=UCase$(prod$)
	Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
	ProdKey$=Prod$
	PrR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.) ! product mode=2 dir=1
	clear e$		!
			! initialize status
	ReturnStatus=1
	Message$="OK"
	If PRR<0 
		Let ReturnStatus=0
		Message$="PRODUCT NOT FOUND"
		Goto SUpDone:
	Endif
	Call DXGet("ORDTYPE",tmp$)
	OType=tmp$
	If OType<1 or OType>38 or Fra(OType)
		ReturnStatus=0
		Message$="INVALID ORDER TYPE!"
		goto SUpDone:
	Endif
	Call DXGet("WHSE",tmp$)
	Whse=tmp$
	If whse<1 or Whse>99 or fra(Whse)
		ReturnStatus=0
		Message$="INVALID WAREHOUSE"
		Goto SUpDone:
	Endif
	Let kpw$=" ",kpw$
	Kpw$=Prod$+Whse Using "##"
	PWR=filegetprodwhse(e$,PWC,"=",1,KPW$,PW.)
	clear e$
	If PWR<0 Clear PW.
	Clear List$[]
	tmpcnt=maxcnt

	List$[0]=bsdel$,"STKUPFLAG",fdel$
	List$[1]="Option",fdel$
	row=2
	! check if normally allowed
	UpdtStk=0 ! NO ON QUOTES!
	! Needs a Prodgroup check 
	If PW.ProdGrp>0 ! has a group
		Pram[0]=OType !  \ if TScan=2 Let Pram[0]=0-OType
		Pram[1]=PW.ProdGrp
		Pram[5]=0 ! file not opened
		![0]=Order or (-)PO Type
		! [1]=Product Group
		! [2]=Allow on Ord/PO (1=y, 0=N)
		! [3]=Update Stock (1=y, 0=N)
		! [4]=On Price List (0/1)
		! [5]=Channel of 2/ProdGrp#
		Call ProdGroup(e$,intco,Pram[])
		UpdtStk=0 ! Pram[3] ! update Stock
	Endif
	X2=OType
	if x2=2 OR X2=5 LET UpdtStk=0 ! not on directs
	if x2=3 and p60$[22,22]<>"Y" LET UpdtStk=0 ! indir no stk 
	tmp$=pr.ComdtyCode$
	if tmp$="LABR" OR tmp$="TIME" OR tmp$="MACH" LET UpdtStk=0 ! comm's no stk
	If UpdtStk=0 ! only answer is N
		WebStr$="N",fdel$
	Else ! can have Y and N
		WebStr$="Y",fdel$
		List$[row]=WebStr$
		Row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
		WebStr$="N",fdel$
	Endif
	List$[row]=WebStr$
	Row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	List$[row]=esdel$ ! finished
	call AddToStr(e$,rstr$,List$[])
	SUpDone: ! finito ! finished
	if debugdetail
		dmsg$="Stock Update flag "+prod$+Message$ \ Call updatelog(debug)
	Endif
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)

  else
    include "src/callsuberr.inc"
  end try
end sub ! StkUpList
! 
!--------------------------------------------------------------------
Sub Ordaddldtl()
! send additional data for complete detail of line
! this can handle new / existing lines for stk/nonstk
  Try
	dim PWKey$[60],VendKey$[60],OLKey$[60],k1$[60]
	Dim kcm$[50],sum$[4],Pum$[4],Cum$[4],lpkey$[60]
	dim lppum$[4],lpcum$[4],lpsum$[4]
	dim 1%,cnvtu[2],NonStk,ZLine
	Dim 2%,OrderNo,LineNo,Whse,TaxNo,Dept
	Dim 3%,OLR,CNVTA,Amount,lpr,spr
	Dim vend. as a80vm
	Dim tax. as taxcode
	Dim spcl. as specprice
	dim rbdt. as rebatedtl
	if debugdetail
		dmsg$="Start Additional Details" \ Call updatelog(debug)
	Endif
	ReturnStatus=1
	Message$="OK"
	Call DXGet("DEPT",tmp$)
	Dept=tmp$ ! as it may be diff from header?
	Call DXGet("ORDERID",tmp$)
	OrderNo=tmp$
	LineNo=0;fleptr[4,1]=0;nonstk=0
	If OrderNo>0 ! sent order
		OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
		Call DXGet("LINENO",tmp$)
		LineNo=tmp$
		If OHR<0 ! can't do much with no order!
			Let lineno=0
			clear roh.
			clear ros.
			clear rot.
			ReturnStatus=0
			Message$="ORDER NOT FOUND"
			goto OPADDone
		Endif
		If LineNo>0 ! sent line - get info from it
			OLKey$=" ",OLKey$
			OLKey$[1,6]=roh.OrdNum Using "######"
			OLKey$[7,9]=LineNo Using "###"
			OLKey$[11]="" ! cut at 11 - 10 blank
			OLR=filegetqolz(e$,OLC,"=",1,OLKey$,rol.)
			clear e$
			If OLR<0 
				Clear rol.
				LineNo=0
			Endif ! did not find line
		Endif
	Else ! NEED AN ORDER!
		ReturnStatus=0
		Message$="ORDER NOT PASSED"
		goto OPADDone
	Endif
	If ReturnStatus=1 and OHR>0
		Call GetCust()
	Endif
	If LineNo<=0 ! no order found / yet
		clear rol. ! have nothing
		nonstk=0
		IF ordpad ! need last price check
			call dxget("LTYPE",tmp$)
			LPType$=UCase$(rtrim$(tmp$))
			if LPtype$="NSTK" ! additional
				call dxget("LPFLE",tmp$) ! last price file used
				lpnstk=0
				if UCase$(RTrim$(tmp$))="C" let lpnstk=1
				if UCase$(RTrim$(tmp$))="S" let lpnstk=2 ! shiplist
				call dxget("LPREC",tmp$) ! last price rec
				LPREC=tmp$
				nonstk=1
				if lpnstk=2 ! need sllst file
					SLC=OpenFile(-9982,IntCo) \ if slc=-1 Error 42
				Endif
				if lpnstk=0
					Let E$=" No Last Price File Sent" ! +Prod$
					Let ReturnStatus=0
					if debugdetail
						dmsg$=prod$+e$ \ Call updatelog(debug)
					Endif
					goto OPADDone
				Endif
				if lpnstk=1 let x3=chf(LPC)-1
				if lpnstk=2 let x3=chf(SLC)-1
				if lprec<=0 or lprec>x3 or fra(lprec)
					Let E$=" Invalid Last Price Record Sent" ! +Prod$
					Let ReturnStatus=0
					if debugdetail
						dmsg$=prod$+e$ \ Call updatelog(debug)
					Endif
					if lpnstk=2 try close #slc Else rem
					Goto OPADDone
				Endif
				chan=lpc
				if lpnstk=2 let chan=slc
				read record #chan,lprec,0;clp.;
				call NSFRMLP()
				if lpnstk=2
					if slc try close #slc Else rem
				Endif
				PRR=0 ! not there, is nonstklp
				Prod$=clp.VendItemCode$ ! set for default/missing
				LPR=LPRec
				goto GotOPLPNS
			Endif ! of lptype=NSTK
		Endif ! of orderpad
		Call DXGet("PRODID",tmp$)
		tmp$=UCase$(tmp$)+Blank$
		Prod$=tmp$[1,12]
		ProdKey$=prod$
		PRR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.)
		clear e$
		If PRR<=0 ! no product found
			Clear Pr.
			ReturnStatus=0
			Message$="PRODUCT NOT FOUND"
			goto OPADDone
		Endif
		GotOPLPNS: ! do not reread/clear pr. as it's from lastprice
		If PRR>=0 ! if =0 it's nonstk lastprice orderpad
			Call DXGet("WHSE",tmp$)
			Whse=tmp$
			if whse>0
				PWKey$=Prod$+Whse using "##"
				if roh.ordtype=7 let PWKey$=Prod$+roh.ConsWh using "##"
				PWR=filegetprodwhse(e$,PWC,"=",1,PWKey$,PW.)
				clear e$
				If PWR<0 Clear PW.
			Else
				Clear PW.
			Endif
			! as no line - set up rol. values to use
			rol.QtyOrd=0 ! don't know or need? (need spcl/rbt #)
			SUM=pr.UMSellDefault ! need to pass to setnewrol
			if ordpad ! from order pad - any qty?
				Call DXGet("UM",tmp$)
				if tmp$<>""
					R=getumrec(e$,CCC,tmp$,IntCo,PR.)
					If R<>0 let tmp$=Str$(R)
					Let SUM=tmp$
				Else
					SUM=0
				Endif
				Flag=ChkPrdUM(e$,SUM,IntCo,Pr.)
				If Not(Flag)
					sum=pr.UMSellDefault
				Endif
				call dxget("ORDQTY",tmp$)
				x3=tmp$
				If ABS(X3)>9999999999
					message$="Order Quantity out of range"
					returnstatus=0
					goto OPADDone
				Endif
				if x3<>0 let SQty=x3
				let cnvtu[0]=SUM;cnvtu[1]=0;cnvtu[2]=1
				let cnvta=SQty
				Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				Let rol.QtyOrd=Int(Amount) ! always integer base - just cut it
			Endif
			Call SETNEWRol() ! set up rol. vars
			rol.dept=Dept ! as passed
			rol.PDRecNum=PRR;rol.whse=whse
			rol.prodcode$=pr.ProdCode$
			if ordpad goto bpprice ! no price on ordpad qty
			! need a price call for special/rebate #
			CALL SETUPSPECS() ! set up specs[] for call
			Call getprice()
			let rol.currid=roh.currid
			if rol.currid>0 and rol.currid<=9999
				let rol.currfact=roh.currfact
			else
				let rol.currid=0
				let rol.currfact=0
			endif
			If Specs[0]=0 ! okay to go
				rol.UpChrg=Specs[16]
				rol.UnitCost=Specs[17]
				rol.LineCost2=Specs[18]
				rol.UnitPrice=Specs[20]
				rol.LineDisc=Specs[21]
				rol.LineDiscPct=Specs[22]
				rol.NetPrice=Specs[23]
				rol.RebtContract=Specs[24]
				rol.PriceOrigin=Specs[25]
				rol.CostOrigin=Specs[26]
				rol.Contract=Specs[27]
				rol.SpCommPct=Specs[28]
				rol.BrkLvl=Specs[29]
				rol.LoadUpchrg=Specs[40]
				IF SPECS[14]<>rol.UMPrice ! "price unit changed     
				  let rol.UMPrice=specs[14]
				  REM  PUM$=xunit$(ROL.UMPrice,ccc) ! u/m
				ENDIF                                                              
				IF SPECS[15]<>rol.UMCost ! "cost unit changed   
					let rol.UMCost=SPECS[15]
				REM	CUM$=xunit$(ROL.UMCost,ccc) ! u/m ok
				ENDIF      
			Endif
		Endif ! found prod
	Endif ! no line
	! okay got line setup - let's go with the list
	NonStk=rol.NStkItem
	ZLine=0 \ if NonStk and rol.LineType=3 let ZLine=1
	! CHECK FOR LastPrice
	LPR=FlePtr[4,1] ! in case called above
	bpprice: ! no need for price call
	If LPR<=0 ! did not find or get yet - look for it
		LPKey$=" ",LPKey$
		LPKey$[1,6]=Roh.CustNum using "######"
		X2=rol.dept \ if P9$[44,44]<>"Y" let x2=0
		LPkey$[7,10]=X2 Using "####"
		If Not(NonStk) let LPKey$[11]=rol.prodcode$
		If NonStk let LPKey$[11]=rol.VendItemCode$
		tmp$=LPKey$
		LPR=filegetlastprice(e$,LPC,">",1,LPKey$,CLP.)
		clear e$
		If lpkey$[1,22]<>tmp$[1,22] let lpr=-1
		If LPR<=0 clear clp.

	Endif ! need for poss sugg price
	prr=rol.PDRecNum
	
	If Not(NonStk) Read record #PRC,prr,0;PR.; ! always read prod!
	If NonStk ! nonstock
		if ordpad goto OPLPBypass ! set up - done clear!!
		Clear pr.
	Endif
	call SetPRtoROL() ! set up prod conv vars
	if rol.comdtycode$="" or rol.comdtycode$=Blank$[1,4]
		If Not(NonStk) Let Rol.Comdtycode$=Pr.ComdtyCode$+blank$
	Endif
	Prod$=rol.prodcode$
	whse=rol.whse
	k1$=rol.ComdtyCode$+Blank$;k1$[5]=""
	cmr=filegetcommhead(e$,cmc,"=",1,K1$,cmc.)
	clear e$
	If cmr<0 clear cmc. ! need for price rounding
	! may need set certain prod vars to rol. for  (catchwgt,cwt)
	! first get avl in all whses
	OPLPBYPASS: ! no pr to rol !! already done
	SUM$=XUnit$(rol.umsell,ccc)
	Pum$=XUnit$(rol.umprice,ccc)
	CUm$=XUnit$(rol.umcost,ccc)
	Clear list$[]
	List$[0]=bsdel$,"WHSEAVAIL",fdel$
	webstr$="WHSE",fdel$,"Available",fdel$
	if ordpad let webstr$="WHSE",fdel$,"Available",fdel$,"UM",fdel$,"WHNAME",fdel$
	List$[1]=Webstr$
	Row=2;tmpcnt=maxcnt
	WHAvl=0;x2[9]=rol.whse
	if roh.ConsWh and roh.ordtype=7 let x2[9]=roh.ConsWh
	If RTrim$(Prod$)<>""
		If Not(NonStk) Let WHAvl=getwhavail(e$,intco,PWC,rol.ProdCode$,X2[9])
	Else
		WHAVL=0
	Endif
	cnvtu[0]=0;cnvtu[1]=rol.umsell;cnvtu[2]=1
	cnvta=WHAvl \ if rol.numout>0 let cnvta=whavl*rol.numout
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	WebStr$=Str$(rol.Whse),fdel$
	if ordpad
	  WHIR=X2[9]-1
	  Read record #WHI,WHIR,0;WHI.;
	  tmp$=RTrim$(WHI.WhName$)
	  WebStr$=WebStr$,LTrim$(Amount Using QMask$),fdel$,RTrim$(SUM$),fdel$ ! as deflt sell?
	  webstr$=webstr$,tmp$,fdel$ ! wants wh name
	Else
	  WebStr$=WebStr$,STR$(WHAVL),fdel$ ! as base (don't know if UMSell changed!
	Endif
	List$[row]=WebStr$
	row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	PWKey$=" ",PWKey$
	PWKey$=rol.ProdCode$+Blank$
	PWKey$[15]="" ! cut to length
	Do
		If NonStk Exit do ! no whse/avl on nonstocks!
		if roh.ordtype=7 exit do ! only the one
		PWR=filegetprodwhse(e$,PWC,">",1,PWKey$,PW.)
		clear e$
		If PWR<0 or Pwkey$[1,12]<>rol.prodcode$ exit do
		X2=pwkey$[13,14]
		If X2<>rol.whse ! already sent line whse #
		  if rtrim$(rol.prodcode$)<>""
			WHAvl=getwhavail(e$,intco,PWC,rol.ProdCode$,X2)
		  Else
		    WHAVL=0
		  Endif
			if WHAvl<>0 ! don't send zero (less than?)
			 cnvtu[0]=0;cnvtu[1]=rol.umsell;cnvtu[2]=1
			 cnvta=WHAvl \ if rol.numout>0 let cnvta=whavl*rol.numout
			 Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			 WebStr$=Str$(X2),fdel$ ! whse #
			 if ordpad
			   WHIR=X2-1
			   Read record #WHI,WHIR,0;WHI.;
	           tmp$=RTrim$(WHI.WhName$)
			   WebStr$=WebStr$,LTrim$(Amount Using QMask$),fdel$,RTrim$(SUM$),fdel$ ! as sell UM
			   webstr$=webstr$,tmp$,fdel$ ! wants wh name
			 Else
				WebStr$=WebStr$,Str$(WHAVL),fdel$ ! as base qty
			 Endif
			 List$[row]=WebStr$
			 row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
			Endif ! no zero avl (shorten list)
		Endif
	Loop
	List$[row]=esdel$ ! finished
	call AddToStr(e$,rstr$,List$[])
	! now any details needed for line
	PWKey$=Prod$+rol.Whse using "##"
	if roh.ordtype=7 let PWKey$=Prod$+roh.ConsWh using "##"
	If Not(NonStk) Let PWR=filegetprodwhse(e$,PWC,"=",1,PWKey$,PW.)
	clear e$
	If PWR<0 Or NonStk Clear PW. ! reread line whse
	Clear list$[]
	List$[0]=bsdel$,"LINEDETAIL",fdel$
	WebStr$="COMPLM",fdel$
	WebStr$=WebStr$,"VENDOR",fdel$,"VENDNAME",fdel$
	WebStr$=WebStr$,"DEPT",fdel$,"PACK",fdel$
	WebStr$=WebStr$,"ALTSUB",fdel$,"ORIGPROD",fdel$
	WebStr$=WebStr$,"FUTEFFDATE",fdel$,"LastDate",fdel$
	WebStr$=WebStr$,"LastPrice",fdel$,"LastCost",fdel$
	WebStr$=WebStr$,"LastGP%",fdel$,"LastQty",fdel$
	WebStr$=WebStr$,"Freq",fdel$,"MSDS",fdel$
	WebStr$=WebStr$,"STKUpt",fdel$,"Whse",fdel$
	WebStr$=WebStr$,"HIDE291",fdel$,"PrintDate",fdel$
	WebStr$=WebStr$,"SPContract",fdel$,"SPExpDate",fdel$
	WebStr$=WebStr$,"RbtContract",fdel$,"RbtCost",fdel$
	WebStr$=WebStr$,"RbtExpDate",fdel$,"SuggPrice",fdel$
	WebStr$=WebStr$,"TaxRate",fdel$
	if roh.ordtype=15 or roh.ordtype=4 ! add'l fields
		webstr$=webstr$,"BILLQTY",fdel$,"PRVBILLQTY",fdel$
		webstr$=webstr$,"PRVBILLDOL",fdel$,"ONBOREL",fdel$
	Endif
	webstr$=webstr$,"GLCOST",fdel$,"PONUM",fdel$
	if ordpad ! order pad much less detail!
		clear list$[]
		List$[0]=bsdel$,"ORDPADQTY",fdel$
		Webstr$="PRODID",fdel$,"DESC1",fdel$,"DESC2",fdel$
		webstr$=webstr$,"ORDQTY",fdel$,"SHIPQTY",fdel$,"BOQTY",fdel$
		webstr$=webstr$,"UM",fdel$,"UMID",fdel$,"PACK",fdel$,"LASTQTY",fdel$
		webstr$=webstr$,"STKUPDT",fdel$,"WHSE",fdel$,"CHKBrkn",fdel$
		WebStr$=WebStr$,"BrknUM",fdel$,"BrknUMID",fdel$,"BrknUMFact",fdel$
	Endif
	List$[1]=WebStr$
	row=2
	X=0
	If ZLine goto OLADone ! zline has none of the below
	X=0 ! for nonstks
	If Not(NonStk) let X=ComplFlag(e$,PRC,IntCo,Prod$)
	Tmp$="N" \ if x let tmp$="Y"
	WebStr$=tmp$,fdel$ ! yes/no 1/0 complementary
	X2=rol.Vendor \ if x2=0 let x2=pr.PrimVend
	tmp$=x2 using "######"
	vnc=OpenFile(-2400,IntCo)
	if vnc>0
		vnr=filegeta80vm(e$,vnc,"=",1,tmp$,Vend.)
		clear e$
		if vnr<=0 clear vend.
		Close #vnc
	Else
		Clear vend.
	Endif
	WebStr$=WebStr$,Str$(x2),fdel$,RTrim$(vend.Name$),fdel$ ! vend & name
	WebStr$=WebStr$,Str$(rol.dept),fdel$,RTrim$(pr.PackSize$),fdel$ ! dept & packsize
	WebStr$=WebStr$,Str$(Int(rol.AltSupsd)),fdel$,RTrim$(rol.OrgProdCode$),fdel$ ! alt/sup & code
	X2=0 ! " clp.PendPermPrdate ! eff date perm price chg?
	if x2=0 let x2=pr.PendBaseDate ! pend future base cost date?
	tmp$=PDate$(x2) ! convert to date
	if x2=0 let tmp$=""
	WebStr$=WebStr$,tmp$,fdel$ ! eff date
	If LPR>0 ! has last price
		read record #LPC,lpr,0;clp.;
		tmp$=PDate$(clp.OrdDate)
		if clp.orddate=0 let tmp$=""
		WebStr$=WebStr$,tmp$,fdel$ ! last date
		cnvtu[0]=0;cnvtu[1]=clp.UMPrice;cnvtu[2]=2
		Cnvta=clp.UnitPrice
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		If p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=amount
			If clp.currid=rol.currid and clp.currfact>0
				let cnvca[1]=clp.currfact
			else
				cnvca[1]=rol.currfact
			endif
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=fnq(cnvca[0])
		endif
		WebStr$=WebStr$,LTrim$(X3 Using PMask$) ! last price
		LPPUM$=xunit$(clp.UMPrice,ccc) ! u/m price
		WebStr$=WebStr$," /",RTrim$(LPPUM$),fdel$ ! lp sell um
		if cost_lev[1]
			cnvtu[0]=0;cnvtu[1]=clp.UMCost;cnvtu[2]=2
			Cnvta=clp.UnitCost
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			If p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 !  
				let cnvcu[0]=1
				let cnvcu[1]=0
				let cnvca[0]=amount
				If clp.currid=rol.currid and clp.currfact>0
					let cnvca[1]=clp.currfact
				else
					cnvca[1]=rol.currfact
				endif
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=fnq(cnvca[0])
			endif
			!!!! last price use last price factors 
			WebStr$=WebStr$,"  ",LTrim$(X3 Using PMask$) ! last cost
			LPCUM$=xunit$(clp.UMCost,ccc) ! u/m cost
			WebStr$=WebStr$," /",RTrim$(LPCUM$),fdel$ ! lp cost um 
		Else
			webstr$=webstr$,fdel$
		Endif
		x3=0
		if clp.UnitPrice! NEEDS A PRICE
			X3=FNR(((clp.UnitPrice-clp.UnitCost)/clp.UnitPrice)*100)
		Endif
		if cost_lev[1]
			WebStr$=WebStr$,"  ",LTrim$(X3 Using QMask$),"%",fdel$ ! GP %
		Else
			webstr$=webstr$,fdel$
		Endif
		cnvtu[0]=0;cnvtu[1]=clp.UMSell;cnvtu[2]=1
		Cnvta=clp.Quantity
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		WebStr$=WebStr$,"  ",LTrim$(X3 Using QMask$) ! last Qty
		LPSUM$=xunit$(clp.UMSell,ccc) ! u/m Sell
		WebStr$=WebStr$," /",RTrim$(LPSUM$),fdel$ ! Qty um 
		WebStr$=WebStr$,Str$(clp.FreqSold),FDEL$ ! frequency
	Else
		clear clp.
		WebStr$=WebStr$," ",fdel$," ",fdel$ ! last price/date
		WebStr$=WebStr$," ",fdel$," ",fdel$ ! last cost/gp
		WebStr$=WebStr$," ",fdel$," ",fdel$ ! last Qty/freq
	Endif
	WebStr$=WebStr$,Str$(rol.MSDSNo),fdel$ ! msds
	tmp$="N" \ if rol.UpdtStk let tmp$="Y"
	WebStr$=WebStr$,tmp$,fdel$ ! update stock flag
	WebStr$=WebStr$,Str$(rol.Whse),fdel$ ! warehouse
	tmp$="N" \ if rol.LinePrint let tmp$="Y"
	WebStr$=WebStr$,tmp$,fdel$ ! line printed
	tmp$="" \ if rol.LinePrint let tmp$=JDate$(rol.PrintDate) ! print date = julian
	WebStr$=WebStr$,tmp$ ! printed date
	tmp$=rol.PrintTime Using "&&&&&&"
	if rol.LinePrint=0
		WebStr$=WebStr$,"",FDEL$
	Else
		WebStr$=WebStr$," ",tmp$[1,2],":",tmp$[3,4],":",tmp$[5,6],fdel$ ! print time HH:MM:SS
	Endif
	If rol.Contract ! has a spcl price
		k1$=rol.ProdCode$+"C"+rol.Contract Using "#####"
		spr=filegetspecprice(e$,splc,"=",2,K1$,spcl.)
		clear e$
		if spr<0 clear spcl. else goto Got_SPR
		! now try cost group contract
		k1$="C"+rol.Contract Using "#####" + "-"+PR.CostUpdGrp$
		spr=filegetspecprice(e$,splc,"=",1,K1$,spcl.)
		clear e$
		if spr<0 clear spcl. else goto Got_SPR
		! now try commodity contract
		k1$="C"+rol.Contract Using "#####" + "*"+PR.ComdtyCode$
		spr=filegetspecprice(e$,splc,"=",1,K1$,spcl.)
		clear e$
		if spr<0 clear spcl. else goto Got_SPR
		! and the rest...when needed
		Got_SPR: ! found the rec
		WebStr$=WebStr$,Str$(rol.Contract),fdel$ ! contr #
		tmp$="" \ if spcl.CancelDate let tmp$=PDate$(spcl.CancelDate)
		if spcl.canceldate=999999 or tmp$="" let tmp$="none"
		WebStr$=WebStr$,RTrim$(tmp$),fdel$ ! exp date
	Else
		WebStr$=WebStr$," ",fdel$," ",fdel$ ! sp contr & exp date
	Endif
	If Not(NonStk) ! rol.RebtContract ! has a rbt contract or always? try always
		RbtCost=getrbtcost() ! gets rbt cost
		rbdc=OpenFile(-320,IntCo)
		If rbdc>0 ! get detail
		  If rbt_args[5,1]>0 ! passed record
		    rbdr=rbt_args[5,1] 
		    Read Record #rbdc,rbdr,0;rbdt.;
		  Else
			K1$=" ",k1$
			K1$=rol.RebtContract Using "######",rol.prodcode$
			! also possible *+Commdty or #  all so hope rec is sent
			rbdr=filegetrebatedtlz(e$,rbdc,"=",1,K1$,rbdt.)
			clear e$
			If Rbdr<=0 clear rbdt.
		  Endif
		  Close #rbdc ! close details
		Else
			clear rbdt.
		Endif
		WebStr$=WebStr$,Str$(rol.RebtContract),fdel$
		CNVTU[0]=0;CNVTU[1]=rol.UMCost;cnvtu[2]=2
		Cnvta=rbtcost \ if rol.umcost>0 and rol.numout>0 let cnvta=rbtcost/rol.numout
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		! WebStr$=WebStr$,LTrim$(amount using PMask$),fdel$ ! needs CUM$ (cost um)?
		WebStr$=WebStr$,Str$(rbtcost),fdel$ ! as base
		tmp$="" \ if rbdt.CancelDate let tmp$=PDate$(rbdt.CancelDate)
		if rbdt.CancelDate=999999 or tmp$="" let tmp$="none"
		WebStr$=WebStr$,RTrim$(tmp$),fdel$ ! exp date
	Else ! no rebates
		WebStr$=WebStr$," ",fdel$," ",fdel$," ",fdel$ ! #, cost, date
	Endif
	IF LPR>0 and (P9$[13,13]="M" or P9$[13,13]="G") ! can only give sugg price if last price!
		x3=0
		IF clp.UnitCost ! must have for sugg price
			! mxline = UWORK[4]*(1+((LPC2[1]-LPC2[2])/LPC2[2]) (Uwork[4]=Unitcost in costum)
			x3=rol.UnitCost*(1+((clp.UnitPrice-clp.UnitCost)/clp.UnitCost)) ! we use base!
		Endif ! of get sugg price
		If rol.UpChrg ! has up - add it in
			If rol.UpChrg<0 ! it's a $
				x3=x3+Abs(rol.UpChrg)
			Else ! it's %
				x3=x3+(x3*(rol.UpChrg/100))
			Endif
		Endif ! of upchrg it
		cnvtu[0]=0;cnvtu[1]=rol.UMPrice;cnvtu[2]=2
		cnvta=x3
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		If p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=amount
			cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=fnq(cnvca[0])
		endif
		IF P61$[50,50]="Y" ! price rounding
			x2=cmc.PriceRoundFactor
			if x2>0 and x2<9
				Call "pricernd",x2,Amount
			Endif
		Endif 
		! WebStr$=WebStr$,LTrim$(Amount using PMask$),fdel$ ! as price um
		
		WebStr$=WebStr$,Str$(X3),fdel$ ! as base (line um chg'd?)
	Else
		WebStr$=WebStr$,"0",fdel$ ! no sugg
	Endif
	If P60$[42,42]<>"Y" ! has y/n only - get rate from header tax
		TaxNo=roh.TaxCode
		rol.TaxPct=rot.TaxPct ! use totals %
	Else ! is a code
		TaxNo=rol.TaxFlg
		If TaxNo>0
			Tcc=Openfile(-2176,IntCo) \ if Tcc = -1 Error 42
			Read record #tcc,taxno,0;tax.;
			Close #tcc
		Else ! no taxcode
			clear tax.
		Endif
		rol.TaxPct=tax.TaxRate
	Endif
	
	WebStr$=WebStr$,LTrim$(rol.TaxPct Using "###.####"),fdel$ ! tax rate
	if roh.ordtype=15 or roh.ordtype=4 ! send add'l fields
		cnvtu[0]=0;cnvtu[1]=rol.umsell;cnvtu[2]=1
		cnvta=rol.CurrBillQty \ if rol.umsell>0 and rol.numout>0 let cnvta=rol.CurrBillQty*rol.numout
		amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		webstr$=webstr$,LTrim$(amount using Qmask$),fdel$ ! currbillqty
		cnvta=rol.PrevQtyBill \ if rol.umsell>0 and rol.numout>0 let cnvta=rol.PrevQtyBill*rol.numout
		amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		webstr$=webstr$,LTrim$(amount using Qmask$),fdel$ ! prevbillqty
		webstr$=webstr$,LTrim$(rol.PrevBill using Qmask$),fdel$ ! prev bill$
		cnvta=rol.BORelQty \ if rol.umsell>0 and rol.numout>0 let cnvta=rol.BORelQty*rol.numout
		amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		webstr$=webstr$,LTrim$(amount using Qmask$),fdel$ ! qty on bo rel
	Endif
	CNVTU[0] = 0;CNVTU[1] = rol.UMCost;CNVTU[2] = 2 
	otok=0 \ if roh.OrdType=2 let otok=1
	if custom_customer$="HTBERRY" and roh.ordtype=25 let otok=1
	if Nonstk or otok or (roh.OrdType=3 and P60$[22,22]="N")
	  !CNVTA = rol.UnitGLCost \ if rol.UMCost>0 and rol.numout>0 let cnvta=rol.UnitGLCost/rol.numout
	  if  Not(nonstock)! task#45231 - need to write it to file, since user may not save screen
			if rol.UnitGLCost<=0 
				let rol.UnitGLCost=pr.CostPO
				write record #olc,olr;rol.;
			endif
	   endif
	  CNVTA = rol.UnitGLCost 
		if rol.UMCost>0 and rol.numout>0 let cnvta=rol.UnitGLCost/rol.numout
	  X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	  If p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=x3
			cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif        
	  WebStr$ = WebStr$,LTrim$(X3 Using PMask$),fdel$ ! unit gl cost 
	Else
	 CNVTA=0 ! not sending
	 webstr$=webstr$," ",fdel$
	Endif
	webstr$=webstr$,"0",fdel$ ! never a po on quotes
	If OrdPad ! order pad - much less detail
		! quick avail check
		x2[9]=rol.whse \ if roh.ordtype=7 let x2[9]=roh.ConsWh
		If RTrim$(rol.prodcode$)<>""
			X3[1]=getwhavail(e$,intco,PWC,rol.ProdCode$,X2[9])
		Else
			X3[1]=0
		Endif
		x=0 \ if p60$[27,27]="S" let x=1
		if p60$[27,27]="B" let x=2
		if p60$[27,27]="E" let x=3
		Let rol.QtyShip=rol.QtyOrd ! take it all
		Let rol.QtyBO=0
		!if Not(credit) and X>0 ! has bochk set
		! If ROL.UpdtStk and rol.QtyOrd>X3[1] ! order > whavail
		!  if x3[1]>0 ! has some avail
		!	Let rol.QtyShip=X3[1] ! take it all
		!	Let rol.QtyBO=rol.QtyOrd-rol.QtyShip
		!  Else ! zero or <0 avail
		!	Let rol.QtyShip=0
		!	Let rol.QtyBO=rol.QtyOrd ! all backordered
		!  Endif
		! Endif ! of updt and ord>avail
		!Endif
		! added 2/28 - convert shipped/bo to sell 2 dec - 2316
		if rol.qtyship<>0
			cnvtu[0]=0;cnvtu[1]=rol.UMSell;cnvtu[2]=1
			cnvta=rol.qtyship \ if rol.numout>0 let cnvta=rol.qtyship*rol.numout
			Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			tmp$=LTrim$(amount using "----------#.##")
			amount=tmp$ ! now 2 decimals only
			cnvtu[0]=rol.UMSell;cnvtu[1]=0;cnvtu[2]=1
			cnvta=amount \ if rol.numout>0 let cnvta=amount/rol.numout
			Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			if amount<>rol.qtyship ! it changed
				rol.qtyship=amount
				if rol.qtyship>x3[1] let rol.qtyship=x3[1] ! no overship
				Let rol.QtyBO=rol.QtyOrd-rol.QtyShip
			Endif
		Endif ! of recalc qty ship based on 2 dec
		if roh.ordtype=15 let rol.qtyship=0;rol.qtybo=0 ! starts as zero
		if Cust.BoSAllowedFlag=0 Let rol.QtyBO=0 ! no bo's allowed
		if roh.ordtype=4 let rol.QtyBO=0 ! no bo's allowed on ot4? - 32160
		if nonstk let rol.UpdtStk=0;pw.chkbrknqty$="N"
		! ok - send data
		tmp$=clrtxtc$(e$,pr.desc1$) ! chk/clr control chars
		Webstr$=Prod$,fdel$,RTrim$(tmp$),fdel$
		tmp$=clrtxtc$(e$,pr.desc2$) ! chk/clr control chars
		webstr$=webstr$,RTrim$(tmp$),fdel$
		cnvtu[0]=0;cnvtu[1]=rol.UMSell;cnvtu[2]=1
		Cnvta=rol.QtyOrd \ if rol.numout>0 let cnvta=rol.qtyord*rol.numout
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! Ord Qty
		Cnvta=rol.QtyShip \ if cnvta=0 and rol.qtybo=0 let cnvta=rol.qtyord
		if rol.numout>0 let cnvta=cnvta*rol.numout
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! Ship Qty
		Cnvta=rol.QtyBO \ if rol.numout>0 let cnvta=rol.qtyBo*rol.numout
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! BO Qty
		tmp$=xunit$(rol.UMSell,ccc) ! u/m sell
		webstr$=webstr$,tmp$,fdel$,Str$(rol.UMSell),fdel$ ! um & rec
		webstr$=webstr$,RTrim$(pr.PackSize$),fdel$ ! pack
		cnvtu[0]=0;cnvtu[1]=clp.UMSell;cnvtu[2]=1
		Cnvta=clp.Quantity
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		WebStr$=WebStr$,LTrim$(X3 Using QMask$) ! last Qty
		LPSum$=""
		if clp.UMSell let LPSUM$=xunit$(clp.UMSell,ccc) ! u/m Sell
		WebStr$=WebStr$," /",RTrim$(LPSUM$),fdel$ ! last Qty um
		tmp$="N" \ if rol.UpdtStk let tmp$="Y"
		WebStr$=WebStr$,tmp$,fdel$ ! update stock flag
		WebStr$=WebStr$,Str$(X2[9]),fdel$ ! warehouse
		tmp$=XUNIT$(pr.UMBrknQty,ccc)
		if pw.chkbrknqty$<>"N" let pw.chkbrknqty$="Y"
		WebStr$=WebStr$,pw.ChkBrknQty$,fdel$,RTrim$(tmp$),fdel$ ! chkbrkn, brkn um
		X3=UMtoFactor(pr.UMBrknQty)
		WebStr$=WebStr$,Str$(pr.UMBrknQty),fdel$,Str$(X3),fdel$ ! um id, um factor
	Endif
	! finished with line details
	List$[row]=WebStr$
	row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	OLADONE: ! finished
	List$[row]=esdel$ ! finished
	call AddToStr(e$,rstr$,List$[])
	! add any flags needed
	Clear list$[]
	List$[0]=bsdel$,"LINEFLAGS",fdel$
	List$[1]="BOPOLINK",fdel$
	webstr$="N",fdel$ ! CHECK sordtype Quotes NO
	List$[2]=webstr$
	list$[3]=esdel$
	call AddToStr(e$,rstr$,List$[])
	if debugdetail
		dmsg$="Addl Detail sent "+Str$(Orderno)+"-"+Str$(LineNo)+" "+rol.prodcode$+Message$ \ Call updatelog(debug)
	Endif
	! status section
	! ReturnStatus=1 (Set above)
	! Message$="OK"
	OPADDone: ! really done
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
	! 
	! call programdump("/tmp/ollog5!","")
  else
    include "src/callsuberr.inc"
  end try
end sub ! Ordaddldtl
! 
!--------------------------------------------------------------------
Sub SetNewROL()
! a routine for setting rol. variables
! this assumes the prod & prodwhse are already read!
! also roh. ros. rot. have been read!
! AND the qtyord is already known and SellUM is in SUM
 Try
	Dim K1$[50]
	dim 1%,PRAM[5]
	Dim 2%,X2[9]
	Dim 3%,X3[9]

	Dim tax. as taxcode
	
	rol.OrdNum=roh.OrdNum
	rol.UpdtStk=0 ! NOT ON QUOTES ! was =1 ! yes
	
	rol.PSlsCat=PR.ProdCat
	rol.Slsm=roh.SlsmNum
	rol.Whse=roh.Wh
	rol.ComdtyCode$=pr.ComdtyCode$+Blank$
	rol.Dept=roh.Dept
	rol.QtyBO=0
	rol.QtyShip=rol.QtyOrd
	rol.MatCode$=pr.MatCode$
	rol.EntBy=ROH.EntBy ! how's this gotten? (MXLINE=PORTDEFAULT) OR H5[0]
	If nonstk 
		!if p61$[76,76]="Y" and NOT(CREDIT) ! auto bo nonstk
		!	let Rol.QtyBO=rol.QtyOrd;rol.QtyShip=0 ! bo=ord,ship=0
		!Endif ! per erg - not on quotes
		goto NStkSUBypass ! don't load the remainder
	Endif
	rol.CubeUnit=PR.CubicFeet
	rol.LbsUnit=pr.LbsUnit
	rol.TaxFlg=0 ! --------- needs setup (below)
	rol.Desc1$=pr.Desc1$
	rol.Desc2$=pr.Desc2$
	rol.ProdCode$=pr.ProdCode$
	rol.UMSell=SUM ! as passed!
	if SUM=0 Let rol.UMSell=pr.UMSellDefault
	rol.UMPrice=pr.UMPriceDefault
	rol.UMCost=pr.UMCostDefault
	rol.Vendor=pr.PrimVend ! may chg to whse
	rol.MSDSNo=getMSDS(e$,IntCo,roh.CustNum,rol.ProdCode$,ros.ShipCust,ros.ShipCode,pr.Msds,pr.DotHazardous)
	rol.VendItemCode$=pr.VendItem$ ! cb whse
	rol.UMBase=pr.BaseUM
	rol.UMPurch=pr.UMPurchDefault
	rol.CubeFactor=PR.CubicFtFactor \ if rol.CubeFactor<=0 Let rol.CubeFactor=1
	rol.WgtFactor=pr.LbsFact \ if rol.WgtFactor<=0 Let rol.WgtFactor=1
	rol.CatchWgtItem=pr.CatchWgtItm
	rol.SellFactor=UMtoFactor(rol.UMSell)
	rol.PriceFactor=UMtoFactor(rol.UMPrice)
	rol.CostFactor=UMtoFactor(rol.UMCost)
	rol.PurchFactor=UMtoFactor(rol.UMPurch)
	let rol.currid=roh.currid
	if rol.currid>0 and rol.currid<=9999
		let rol.currfact=roh.currfact
	else
		let rol.currid=0
		let rol.currfact=0
	endif
	IF P9$[32,32]="Y" ! whse pricing  
	  if pw.CostLastPo let rol.UnitGLCost=pw.CostLastPo
	Endif
	If PW.Vend>0 Let rol.Vendor=pw.vend
	IF PW.VendPN$>"  " let rol.VendItemCode$=pw.VendPN$
	otok=0 \ if roh.OrdType=2 let otok=1
	if custom_customer$="HTBERRY" and roh.ordtype=25 let otok=1
	!if otok or (roh.OrdType=3 and P60$[22,22]="N") ! gl cost
	!	if rol.UnitGLCost<=0 let rol.UnitGLCost=pr.CostPO
	!Else
	!	rol.UnitGLCost=0
	!Endif
	! Needs a Prodgroup check (in case single entry!)
	If PW.ProdGrp>0 ! has a group
		Pram[0]=ROH.OrdType !  \ if TScan=2 Let Pram[0]=0-OType
		Pram[1]=PW.ProdGrp
		Pram[5]=0 ! file not opened
		![0]=Order or (-)PO Type
		! [1]=Product Group
		! [2]=Allow on Ord/PO (1=y, 0=N)
		! [3]=Update Stock (1=y, 0=N)
		! [4]=On Price List (0/1)
		! [5]=Channel of 2/ProdGrp#
		Call ProdGroup(e$,intco,Pram[])
		! If Pram[2]=0  ! not allowed on OType
		!	E$="Product Not Allowed on this Order!"
		!	Exit Sub
		! Endif  ! DO THIS ON ENTRY ONLY!
		rol.UpdtStk=Pram[3] ! update Stock
	Endif ! prodgroup

	X2=roh.OrdType
	if x2=2 OR X2=5 LET rol.UpdtStk=0 ! not on directs
	if x2=3 and p60$[22,22]<>"Y" LET rol.UpdtStk=0 ! indir no stk
	! if x2=16 and roh.XferAuth=0 LET rol.UpdtStk=0 ! whxfer not auth
	tmp$=pr.ComdtyCode$
	if tmp$="LABR" OR tmp$="TIME" OR tmp$="MACH" LET rol.UpdtStk=0 ! comm's no stk
	If nonstk LET rol.UpdtStk=0
	IF CREDIT AND roh.ShipType=3 LET rol.UpdtStk=0
	IF CREDIT AND roh.ShipType=7 LET rol.UpdtStk=0
	LET rol.UpdtStk=0 ! NEVER ON QUOTES
	if otok or (roh.OrdType=3 and P60$[22,22]="N") ! gl cost
		!if source<>207 ! task#45231 - need to write it to file, since user may not save screen
			if rol.UnitGLCost<=0 
				let rol.UnitGLCost=pr.CostPO
				! write record #olc,olr;rol.; ! DONOT WRITE - Maybe a NEW LINE!
			endif
		!endif
	Else
		if roh.Ordtype=1 and rol.Updtstk=0 and p8$[4,4]="Y" and pw.prodgrp>0 and not(nonstk) and not(credit)
			milf=0 ! getmillflg(e$,intco,PWC,prod$,rol.Whse,roh.ordtype)
			if milf>0 ! it is - back order all per dd! need to check if mill item
				!if source<>207 ! task#45231 need to write it to file, since user may not save screen
					if rol.UnitGLCost<=0 
						let rol.UnitGLCost=pr.CostPO
						! write record #olc,olr;rol.; ! cannot write - maybe NEW LINE
					endif
				!endif
			else
				let rol.unitglcost=0
			endif
		else
			rol.UnitGLCost=0
		endif
	Endif
	NStkSUBypass: ! bypass a lot on new nonstk
	! tax flag / rate
	K1$=roh.CustNum Using "######"
	ProdKey$=rol.ProdCode$
	if nonstk let ProdKey$=rol.VendItemCode$ ! nonstk use venditem as key
	Call TaxFlag(k1$,ProdKey$,ros.ShipCust,ros.ShipCode,rol.Dept,pr.TaxType,intco,roh.TaxCode,ros.ShipTaxType,Taxback)
	rol.TaxFlg=Taxback ! contains what's needed
	If P60$[42,42]<>"Y" ! has y/n only - get rate from header tax
		TaxNo=roh.TaxCode
	Else ! is a code
		TaxNo=rol.TaxFlg
	Endif
	If TaxNo>0
		Tcc=Openfile(-2176,IntCo) \ if Tcc = -1 Error 42
		Read record #tcc,taxno,0;tax.;
		Close #tcc
	Else ! no taxcode
		clear tax.
	Endif
	rol.TaxPct=tax.TaxRate
	! extensions, etc to be calculated when sent back!
	! call programdump("/tmp/ollog4!","")
	if debugdetail
		dmsg$="Rol. Setup "+rol.prodcode$+Message$ \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
 end try
end sub ! Setnewrol
! 
!--------------------------------------------------------------------
Sub SetUpSpecs()
! this sets up the specs[]
! the rol has already be set up!
Try 
	Dim KCM$[50],K1$[50]
	Dim 1%,PT[37]
	Dim 3%,ORDQGT

	KCM$=" ",kcm$;kcm$=rol.ComdtyCode$+Blank$;kcm$[5]=""
	CMR=filegetcommhead(e$,CMC,"=",1,kcm$,CMC.) ! need comm rec#
	clear e$
	If CMR<0 Let CMR=0
	Call getcust()
	! send rec #'s
	let x2=Cust.LpPpGrpCust
	! If P60$[33,33]<>"Y" Let X2=0 ! remmed on serpordl
	If CUST.AuthBuyList$="Y" Let X2=0
	If X2=CUST.CustomerCode let x2=0
	if x2<1 or x2>999999 or Fra(X2) Let X2=0
	IF P61$[100,100]<>"Y" let x2=0
	let fleptr[0,1]=X2 ! perm price group
	fleptr[1,1]=PRR;fleptr[2,1]=PWR;fleptr[3,1]=CMR ! prod,prodwh,comm
	if rol.WgtFactor<=1 Let rol.WgtFactor=1
	ORDWGT=(ABS((rol.LbsUnit*rol.QtyOrd)/rol.WgtFactor))
	Specs[0]=0;Specs[1]=rol.QtyOrd;Specs[2]=ORDWGT ! rol.ExtNetWgt
	IF ROL.Numout>0 
		let Specs[1]=rol.qtyord*rol.numout
		let Specs[2]=ORDWGT*rol.numout
	Endif
	Specs[3]=roh.CustNum;Specs[4]=rol.Whse;Specs[5]=roh.OrdDate
	Specs[6]=rol.Dept;Specs[8]=roh.OrdType
	Let Specs[7]=roh.PriceType \ if specs[7]<=0 let Specs[7]=cust.PriceType
	! default cost from prtype file
	cpt=openfile(-752,Intco) \ if cpt=-1 Error 42
	mat read #cpt,specs[7],28;PT;
	Close #cpt ! that's all we needed from file
	X=Specs[8]-1 ! pt[] is 0 to 37
	If X<0 let x=0
	X2=PT[x] \ if x2=0 let x2=P60$[29,29]
	Specs[9]=X2 ! default cost
	Specs[13]=rol.UMSell;Specs[14]=rol.UMPrice;Specs[15]=rol.UMCost
	Specs[16]=rol.UpChrg
	Specs[17]=rol.UnitCost
	Specs[18]=rol.LineCost2
	Specs[20]=rol.UnitPrice
	Specs[21]=rol.LineDisc
	Specs[22]=rol.LineDiscPct
	Specs[23]=rol.NetPrice
	Specs[24]=rol.RebtContract
	Specs[25]=rol.PriceOrigin
	Specs[26]=rol.CostOrigin
	Specs[27]=rol.Contract
	Specs[28]=rol.SpCommPct
	Specs[29]=rol.BrkLvl
	Specs[40]=rol.LoadUpchrg
	if debugdetail
		dmsg$="Price Specs setup "+rol.prodcode$ \ Call updatelog(debug)
	Endif
else
    include "src/callsuberr.inc"
 end try
end sub ! SetupSpecs
! 
!--------------------------------------------------------------------
Function getrbtCost()
! set up vars for call "rebates" & return rbtcost
  Try
	dim 1%,vtgc,rbhc,rbdc
	Dim 3%,Rbt_Args[10,4],rbtcost

	rbtCost=0
	rbt_args[1,0]=PRC ! prod chan
	rbt_args[2,0]=PWC ! prodwhse
	vtgc=OpenFile(1120,Intco) \ if vgtc=-1 goto finrcall
	rbt_args[3,0]=vtgc ! vendtag
	rbhc=OpenFile(304,IntCo) \ if rbhc=-1 goto finrcall
	rbt_args[4,0]=rbhc ! rebate header
	rbdc=OpenFile(320,IntCo) \ if rbdc=-1 goto finrcall
	rbt_args[5,0]=rbdc ! rebate detail
	rbt_args[1,1]=prr ! prod record
	rbt_args[1,2]=rol.whse ! whse
	rbt_args[2,1]=pwr ! prodwhse record
	rbt_args[2,2]=roh.custnum ! customer
	rbt_args[3,2]=0 ! ignore customer?
	rbt_args[4,2]=roh.OrdDate ! order date
	rbt_args[5,2]=roh.PriceType  !Cust price type
	IF P61$[100,100]="Y"
		X2 = Cust.LpPpGrpCust                                         
		If Cust.AuthBuyList$ = "Y" Let X2 = 0          
		If X2 = roh.custnum  Let X2 = 0           
		If X2 < 1 Or X2 > 999999 Or Fra(X2) Let X2 = 0 
		if x2<>0
			rbt_args[2,2]=x2! customer
			call rebates(e$,Rbt_args[],Prod$,Flag,debug,dblog$) ! new external sub
			If Flag=0
				rbtcost=Rbt_args[1,3]
				goto FinRCall:
			Else
				rbtcost=0
			Endif
			rbt_args[2,2]=roh.custnum ! customer
		endif
	endif      
	!Call "rebates",Rbt_args[],Prod$,Flag
	call rebates(e$,Rbt_args[],Prod$,Flag,debug,dblog$) ! new external sub
	If Flag=0
		rbtcost=Rbt_args[1,3]
	Else
		rbtcost=0
	Endif
	FinRCall: ! finished - closefiles
	If vtgc>0 close #vtgc
	if rbhc>0 close #rbhc
	if rbdc>0 close #rbdc
	if debugdetail
		dmsg$="Rebate get "+prod$ \ Call updatelog(debug)
	Endif
  else
    include "src/callsuberr.inc"
  end try
end Function RbtCost ! openfiles
! 
!--------------------------------------------------------------------
Sub SetPRtoRol()
! set up prod (PR.) with line values (stock & NonStock)
 Try
	Dim 1%,PFU1[20]
	Dim 3%,PFU2[6]
	IF ZLINE GOTO L30099:                                          
	LET pr.LbsUnit=rol.LbsUnit;pr.LbsFact=rol.WgtFactor
	IF NOT(pr.LbsUnit) LET pr.LbsUnit=1;rol.WgtFactor=1    
	LET pr.CubicFeet=rol.CubeUnit;pr.CubicFtFactor=rol.CubeFactor
	IF NOT(pr.CubicFtFactor) LET pr.CubicFtFactor=1;rol.CubeFactor=1
	LET pr.BaseUM=rol.UMBase;pr.UM2=rol.UMSell                     
	LET pr.UM3=rol.UMPrice;pr.UM4=rol.UMCost                               
	LET pr.UM5=rol.UMPurch                                          
	LET pr.UM6=0;pr.UM7=0;pr.UM8=0                               
	LET pr.UMStkDefault=rol.UMSell;Pr.UMSellDefault=rol.UMSell;pr.UMPurchDefault=rol.UMPurch             
	LET pr.UMCostDefault=rol.UMCost;pr.UMPriceDefault=rol.UMPrice                              
	IF NOT(NonSTK) GOTO L30060:                                   
	LET pr.UMPrdtnDefault=rol.UMSell;pr.UMUpChrg=rol.UMBase;pr.UMBrknQty=rol.UMBase              
	IF pr.UMCostDefault=-3 OR pr.UMPriceDefault=-3 ! "Catch Wgt Itm N/S              
		LET pr.CatchWgtItm=-3;rol.CatchWgtItem=pr.CatchWgtItm                                 
	ELSE                                                            
		LET pr.CatchWgtItm=0;rol.CatchWgtItem=0                                         
	ENDIF                                                           
	LET pr.UMPack=rol.UMSell;pr.UMSize=rol.UMSell                               
	L30060: LET pr.UM2Fact=rol.SellFactor;pr.UM3Fact=rol.PriceFactor                     
	LET pr.UM4Fact=rol.CostFactor;pr.UM5Fact=rol.PurchFactor                              
	LET pr.UM6Fact=0;pr.UM7Fact=0;pr.UM8Fact=0 
	! below gets rid of dupes - not easy with names - so load into pfu1,pfu2
	PFU1[0]=pr.BaseUM
	pfu1[1]=pr.UM2;PFU2[0]=pr.UM2Fact
	Pfu1[2]=pr.UM3;pfu2[1]=pr.UM3Fact
	pfu1[3]=pr.UM4;pfu2[2]=pr.UM4Fact
	pfu1[4]=pr.UM5;pfu2[3]=pr.UM5Fact
	FOR X1=1 TO 4                                                   
		FOR X2=0 TO X1-1                                              
			IF PFU1[X1]=PFU1[X2] LET PFU1[X1]=0;PFU2[X1-1]=0            
		NEXT X2                                                       
	NEXT X1 
	! now reload checked um's to names
	pr.BaseUM=PFU1[0]
	pr.UM2=pfu1[1];pr.UM2Fact=PFU2[0]
	pr.UM3=Pfu1[2];pr.UM3Fact=pfu2[1]
	pr.UM4=pfu1[3];pr.UM4Fact=pfu2[2]
	pr.UM5=pfu1[4];pr.UM5Fact=pfu2[3]
L30099: ! finito
	if debugdetail
		dmsg$="Put rol. into pr. "+Str$(Orderno)+"-"+Str$(LineNo)+" "+rol.prodcode$ \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
 end try
end sub ! SetPRtoRol
! 
!--------------------------------------------------------------------
Function UMtoFactor(UMRec)
! from sent um # - get um factor for it
! if no match - send factor back as one (base?)
 Try
	
	dim 3%,factor
	let factor=0
	if umrec=-1 let factor=-1 ! web wants umrec in factor
	if umrec=-3 let factor=-3 ! for these
	if umrec<=0 exit function Factor ! 0 ! no um - no factor!
	If umrec=Pr.BaseUM let factor=1
	if umrec=PR.UM2 let factor=pr.UM2Fact
	if umrec=PR.UM3 let factor=pr.UM3Fact
	if umrec=PR.UM4 let factor=pr.UM4Fact
	if umrec=PR.UM5 let factor=pr.UM5Fact
	if umrec=PR.UM6 let factor=pr.UM6Fact
	if umrec=PR.UM7 let factor=pr.UM7Fact
	if umrec=PR.UM8 let factor=pr.UM8Fact
	!if umrec=-1 let factor=-1 ! web wants umrec in factor
	!if umrec=-3 let factor=-3 ! for these
	if debugdetail
		dmsg$="UM to Factor" \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
  end try
end Function Factor ! umtofactor
! 
!--------------------------------------------------------------------
Sub MainDtlHdr()
! send the header for line main details
! so all routines use the same and save searching
Try
	WebStr$="ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$
	WebStr$=WebStr$,"WHAvail",fdel$,"WHAvlUM",fdel$,"WHAvlUMID",fdel$
	WebStr$=WebStr$,"TotAvail",fdel$,"TotAvlUM",fdel$,"TotAvlUMID",fdel$
	WebStr$=WebStr$,"UnitPrice",fdel$,"PriceUpchrg",fdel$
	WebStr$=WebStr$,"PriceUpType",fdel$,"Whse",fdel$
	WebStr$=WebStr$,"NetPrice",fdel$,"PriceUM",fdel$,"PriceUMID",fdel$
	WebStr$=WebStr$,"QtyOrder",fdel$,"QtyUM",fdel$,"QtyUMID",fdel$
	WebStr$=WebStr$,"UnitCost",fdel$,"CostSecurity",fdel$
	WebStr$=WebStr$,"CostUM",fdel$,"CostUMID",fdel$,"CostUpchrg",fdel$
	WebStr$=WebStr$,"CostUpType",fdel$,"ExtCost",fdel$
	WebStr$=WebStr$,"ExtPrice",fdel$,"GP%",fdel$
	WebStr$=WebStr$,"Comm/Desc",fdel$,"QtyBO",fdel$
	WebStr$=WebStr$,"PrevShip",fdel$,"QtyShip",fdel$
	WebStr$=WebStr$,"LastPrc/Cost",fdel$,"LastDate/GP/Qty",fdel$
	WebStr$=WebStr$,"NOTES",fdel$,"Tax",fdel$
	WebStr$=WebStr$,"FutureCost",fdel$,"SPPRContract",fdel$
	WebStr$=WebStr$,"RebateContract",fdel$,"Dept",fdel$
	WebStr$=WebStr$,"Weight",fdel$,"WgtFactor",fdel$,"WgtUM",fdel$
	WebStr$=WebStr$,"ExtWgt",fdel$,"VendorItem",fdel$
	WebStr$=WebStr$,"Cube",fdel$,"CubeFactor",fdel$,"CubeUM",fdel$
	WebStr$=WebStr$,"ExtCube",fdel$,"LineDisc%",fdel$
	WebStr$=WebStr$,"LineNum",fdel$ 
	If elflag=9 let webstr$=webstr$,"NewPermPrc",fdel$ 
	WebStr$=WebStr$,"LTYPE",fdel$ ! include type? ----- ADD WHEN READY  -- ready now
	! added 05/28 - per web send all flags & factors NOW
	webstr$=webstr$,"QTYUMFACT",fdel$,"COSTUMFACT",fdel$,"PRCUMFACT",fdel$
	webstr$=webstr$,"CHKBrkn",fdel$,"MBFlag",fdel$
	WebStr$=WebStr$,"SerialNo",fdel$,"CatchWeight",fdel$
	WebStr$=WebStr$,"LotControl",fdel$,"RollLB",fdel$
	WebStr$=WebStr$,"DNReord",fdel$,"BrknUM",fdel$
	WebStr$=WebStr$,"BrknUMID",fdel$,"BrknUMFact",fdel$
	webstr$=webstr$,"STKUPDT",fdel$,"KIT",fdel$,"KITACTION",fdel$
	webstr$=webstr$,"PRCORGN",fdel$,"CSTORGN",fdel$
	webstr$=webstr$,"BORelQty",fdel$,"QTYOUT",fdel$
	webstr$=webstr$,"NETCOST",fdel$
	webstr$=webstr$,"CURRBILL",fdel$,"PREVBILL",fdel$ ! OT 4 fields!!
	webstr$=webstr$,"HILIGHTPID",fdel$,"HLD4PO",fdel$
	webstr$=webstr$,"RASL",fdel$,"SuggPrice",fdel$ ! added on ordl
	Webstr$=webstr$,"PRCEDIT",fdel$
	! add any new fields here and in LineMainDtl
else
    include "src/callsuberr.inc"
  end try
end sub ! MainDtlHdr
! 
!--------------------------------------------------------------------
Sub LineMainDtl()
! the routine to load string for the web - HEADER IS ABOVE
! all rol. set up already 
! commodity code read
! prod code & prodwhse read or set up
! futcost already gotten
! Fleptr[4,1] is Last Price record (like from price call)
 Try
	Dim SUM$[4],PUM$[4],CUM$[4]
	Dim LPPUM$[4],LPCUM$[4],LPSUM$[4]
	Dim 1%,X1[9]
	Dim 2%,X2[9]
	Dim 3%,LPR,X3[9]

	! generate list
	If rol.NStkItem and elflag=0 ! new nonstk line
		rol.umsell=0;rol.umprice=0;rol.umcost=0
		SUM$=blank$;PUM$=blank$;CUM$=blank$
		rol.prodcode$="NONSTOCK"+Blank$
		if rol.linetype=3 let rol.prodcode$="Z"+blank$
	Else
		SUM$=xunit$(ROL.UMSell,ccc) ! u/m
		PUM$=xunit$(ROL.UMPrice,ccc) ! u/m
		CUM$=xunit$(ROL.UMCost,ccc) ! u/m
	Endif
	If rol.LineType=3 ! ZLINE
		rol.umsell=0;rol.umprice=0;rol.umcost=0
		SUM$=blank$;PUM$=blank$;CUM$=blank$
	Endif
	tmp$=clrtxtc$(e$,rol.desc1$) ! chk/clr control chars
	WebStr$=rol.ProdCode$,fdel$,RTrim$(tmp$),fdel$ ! prod code & desc 1
	tmp$=clrtxtc$(e$,rol.desc2$) ! chk/clr control chars
	WebStr$=WebStr$,RTrim$(tmp$),fdel$
	! whse available
	If rol.NStkItem or rol.LineType=3
		let X3[1]=0
	Else
	   If rtrim$(rol.prodcode$)<>""
		x2[9]=rol.whse \ if roh.ordtype=7 let x2[9]=roh.ConsWh
		X3[1]=getwhavail(e$,intco,PWC,rol.ProdCode$,X2[9])
	   Else
	    X3[1]=0
	   Endif
	Endif
	Cnvtu[0]=0;Cnvtu[1]=rol.UMSell;Cnvtu[2]=1
	CNVTA=X3[1] \ IF ROL.NUMout>0 let cnvta=x3[1]*rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$,RTrim$(SUM$),fdel$ ! whse avail / um
	WebStr$=WebStr$,Str$(ROL.UMSell),fdel$ ! avl um id
	! total(product) available
	If rol.NStkItem or rol.LineType=3
		let X3[2]=0
	Else
		X3[2]=getpravail(e$,intco,PRC,rol.ProdCode$)
	Endif
	Cnvtu[0]=0;Cnvtu[1]=rol.UMSell;Cnvtu[2]=1
	CNVTA=X3[2] \ if rol.numout>0 let cnvta=x3[2]*rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$,RTrim$(SUM$),fdel$ ! Prod avail & um
	WebStr$=WebStr$,Str$(ROL.UMSell),fdel$ ! avl um id
	
	cnvtu[0]=0;cnvtu[1]=rol.UMPrice;cnvtu[2]=2
	Cnvta=rol.UnitPrice \ if rol.umprice>0 and rol.numout>0 let cnvta=rol.unitprice/rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	If p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=x3
			cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
	WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! Unit price
	! send upcharge as amount & type
	tmp$="%" \ if rol.UpChrg<0 let tmp$="$"
	Let X3=rol.UpChrg
	If tmp$="$" ! need convert to price um
		cnvtu[0]=0;cnvtu[1]=rol.UMPrice;cnvtu[2]=2
		Cnvta=ABS(X3)
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		If p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=x3
			cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
	Endif
	WebStr$=WebStr$,Ltrim$(X3 Using PMask$),fdel$,tmp$,fdel$ ! upchrg & type
	WebStr$=WebStr$,Str$(rol.Whse),fdel$ ! warehouse
	cnvtu[0]=0;cnvtu[1]=rol.UMPrice;cnvtu[2]=2
	Cnvta=rol.NetPrice \ if rol.umprice>0 and rol.numout>0 let cnvta=rol.NetPrice/rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	If p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=x3
			cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
	WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! net price
	WebStr$=WebStr$,RTrim$(PUM$),fdel$,Str$(rol.UMPrice),fdel$ ! price um & id
	cnvtu[0]=0;cnvtu[1]=rol.UMSell;cnvtu[2]=1
	Cnvta=rol.QtyOrd \ if rol.numout>0 let cnvta=rol.qtyord*rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! Qty Ord
	WebStr$=WebStr$,RTrim$(SUM$),fdel$,Str$(rol.UMSell),fdel$ ! sell um & id
	cnvtu[0]=0;cnvtu[1]=rol.UMCost;cnvtu[2]=2
	Cnvta=rol.UnitCost \ if rol.UMCost>0 and rol.numout>0 let cnvta=rol.UnitCost/rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	If p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=x3
			cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
	WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! unit cost
	WebStr$=WebStr$,Str$(Cost_Lev[1]),fdel$ ! load cost security
	WebStr$=WebStr$,RTrim$(CUM$),fdel$,Str$(rol.UMCost),fdel$ ! Cost um & id
	! send upcharge as amount & type
	tmp$="%" \ if rol.LoadUpchrg<0 let tmp$="$"
	Let X3=rol.LoadUpchrg
	If tmp$="$" ! need convert to cost um
		cnvtu[0]=0;cnvtu[1]=rol.UMCost;cnvtu[2]=2
		Cnvta=ABS(X3)
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		If p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=x3
			cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
	Endif
	WebStr$=WebStr$,Ltrim$(X3 Using PMask$),fdel$,tmp$,fdel$ ! upchrg & type
	IF rol.UMCutCost=-3 AND rol.QtyOrd LET CHBASE=(rol.CutCost/rol.QtyOrd) ELSE  LET CHBASE=rol.CutCost
	X3[4]=rol.UnitCost+CHBase
	X3[3]=X3[4]
	IF rol.LoadUpchrg ! has cost up
		IF rol.LoadUpchrg<0 ! $ amount
			X3[3]=x3[4]+Abs(rol.LoadUpchrg)
		Else ! percent
			X3[3]=X3[4]+(X3[4]*(rol.LoadUpchrg/100))
		Endif
	Endif ! X3[3]=NETCOST
	NETCOST=X3[3]
	X3=rol.ExtLoadShip ! FNR(rol.QtyShip*X3[3]) ! ext net cost
	If p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=x3
			cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fns(cnvca[0])
		endif
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! net cost exten
	! rol.ExtLoadShip=X3
	! rol.ExtShipAmt=FNR(rol.QtyShip*rol.NetPrice) ! ext price
	Let X3=rol.ExtShipAmt
	If p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=x3
			cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fns(cnvca[0])
		endif
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! net price exten
	x3=0
	if rol.NetPrice ! NEEDS A PRICE
		X3=FNR(((rol.NetPrice-x3[3])/rol.NetPrice)*100)
	Endif
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! GP
	WebStr$=WebStr$,rol.ComdtyCode$," ",RTRIM$(CMC.CodeDescription$),fdel$ ! commod & desc
	cnvtu[0]=0;cnvtu[1]=rol.UMSell;cnvtu[2]=1
	Cnvta=rol.QtyBO \ if rol.numout>0 let cnvta=rol.QtyBo*rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! Qty BO
	cnvtu[0]=0;cnvtu[1]=rol.UMSell;cnvtu[2]=1
	Cnvta=rol.PrevQtyShip \ if rol.numout>0 let cnvta=rol.PrevQtyShip*rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! Qty Prev shipped
	cnvtu[0]=0;cnvtu[1]=rol.UMSell;cnvtu[2]=1
	Cnvta=rol.QtyShip
	if roh.ordtype=15 let cnvta=rol.CurrRelQty ! chg to relqty?
	if rol.numout>0 let cnvta=cnvta*rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! Qty Ship (relqty)
	Let LPR=fleptr[4,1] ! sent last price record
	If LPR>0
		Read record #LPC,LPR,0;clp.;
		cnvtu[0]=0;cnvtu[1]=clp.UMPrice;cnvtu[2]=2
		Cnvta=clp.UnitPrice
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		If p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=x3
			cnvca[1]=rol.currfact
			If clp.currid=rol.currid and clp.currfact>0
				let cnvca[1]=clp.currfact
			else
				cnvca[1]=rol.currfact
			endif
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
		WebStr$=WebStr$,LTrim$(X3 Using PMask$) ! last price
		LPPUM$=xunit$(clp.UMPrice,ccc) ! u/m price
		WebStr$=WebStr$," /",RTrim$(LPPUM$) ! lp sell um
		if cost_lev[1]
			cnvtu[0]=0;cnvtu[1]=clp.UMCost;cnvtu[2]=2
			Cnvta=clp.UnitCost
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			If p61$[136,136]="Y" and rol.currfact<>0 and x3<>0  !! need last price factors!  
				let cnvcu[0]=1
				let cnvcu[1]=0
				let cnvca[0]=x3
				cnvca[1]=rol.currfact
				If clp.currid=rol.currid and clp.currfact>0
					let cnvca[1]=clp.currfact
				else
					cnvca[1]=rol.currfact
				endif
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let x3=fnq(cnvca[0])
			endif
			WebStr$=WebStr$,"  ",LTrim$(X3 Using PMask$) ! last cost
			LPCUM$=xunit$(clp.UMCost,ccc) ! u/m cost
			WebStr$=WebStr$," /",RTrim$(LPCUM$),fdel$ ! lp cost um (price/cost as one field)
		Else
			webstr$=webstr$,fdel$
		Endif
		tmp$=PDate$(clp.OrdDate)
		WebStr$=WebStr$,tmp$ ! last date
		x3=0
		if clp.UnitPrice! NEEDS A PRICE
			X3=FNR(((clp.UnitPrice-clp.UnitCost)/clp.UnitPrice)*100)
		Endif
		if cost_lev[1]
			WebStr$=WebStr$,"  ",LTrim$(X3 Using QMask$),"%" ! GP %
		endif
		cnvtu[0]=0;cnvtu[1]=clp.UMSell;cnvtu[2]=1
		Cnvta=clp.Quantity
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		WebStr$=WebStr$,"  ",LTrim$(X3 Using QMask$) ! last Qty
		LPSUM$=xunit$(clp.UMSell,ccc) ! u/m Sell
		WebStr$=WebStr$," /",RTrim$(LPSUM$),fdel$ ! lp cost um (date/gp/qty as one field)
	Else
		Clear clp.
		tmp$=" ";tmp1$=" "
		if Int(rol.AltSupsd)=1 let tmp$="Substitute";tmp1$=rol.OrgProdCode$
		if Int(rol.AltSupsd)=2 let tmp$="Supersede";tmp1$=rol.OrgProdCode$
		if Int(rol.AltSupsd)=0 and fra(rol.AltSupsd)
			tmp$="Substitute";tmp1$="No LP Update"
		Endif
		WebStr$=WebStr$,tmp$,fdel$,tmp1$,fdel$ ! last price/date
	Endif
	tmp$=blank$;tmp$="" ! clear
	tmp$=chktagfle$()
	WebStr$=WebStr$,tmp$[1,1],fdel$ ! do notes exist!
	If P60$[42,42]<>"Y" ! NOT tax by line - so it's y/n only
		tmp$="N" \ if rol.TaxFlg let tmp$="Y"
		WebStr$=WebStr$,tmp$,fdel$ ! tax flag
	Else ! it's a tax code
		WebStr$=WebStr$,Str$(rol.TaxFlg),fdel$ ! tax code
	Endif
	X3=FUTCOST
	If p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=FutCost
			cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
	WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! future cost
	x=rol.PriceOrigin;tmp$="0"
	IF X>1 AND X<14 AND X<>5 AND X<>9 AND X<>10 
		LET tmp$="Special Price"                                               
	ENDIF 
	If rol.PriceOrigin>82 and rol.PriceOrigin<115
		let x=rol.priceorigin-100
		IF X>1 AND X<14 AND X<>5 AND X<>9 AND X<>10 
			LET tmp$="Special Price"                                               
		ENDIF 
	endif
	if rol.Contract let tmp$=Str$(rol.Contract)
	WebStr$=WebStr$,tmp$,fdel$ ! sp contract
	WebStr$=WebStr$,Str$(rol.RebtContract),fdel$ ! rbt contract
	WebStr$=WebStr$,Str$(rol.Dept),fdel$ ! dept
	WebStr$=WebStr$,LTrim$(rol.LbsUnit Using PMask$),fdel$ ! wgt unit
	tmp$=Str$(rol.WgtFactor)
	call factorum(tmp$) ! get um for factor
	WebStr$=WebStr$,Str$(rol.WgtFactor),fdel$,Rtrim$(tmp$),fdel$ ! wgt factor & um
	WebStr$=WebStr$,LTrim$(rol.ExtNetWgt Using QMask$),fdel$ ! wgt ext
	tmp$=clrtxtc$(e$,rol.VendItemCode$) ! chk/clr control chars
	WebStr$=WebStr$,RTrim$(tmp$),fdel$ ! vend item
	WebStr$=WebStr$,LTrim$(rol.CubeUnit Using PMask$),fdel$ ! cube unit
	tmp$=Str$(rol.CubeFactor)
	call factorum(tmp$) ! get um for factor
	WebStr$=WebStr$,Str$(rol.CubeFactor),fdel$,Rtrim$(tmp$),fdel$ ! cube factor & um
	X3=0
	If rol.CubeFactor let X3=FNR(ABS(rol.QtyShip*rol.CubeUnit/rol.CubeFactor))
	WebStr$=WebStr$,LTRim$(X3 Using QMask$),fdel$ ! cube ext (no rol. var)
	WebStr$=WebStr$,LTrim$(rol.LineDiscPct Using "###.##"),fdel$ ! line disc % (what of $?)
	WebStr$=WebStr$,Str$(rol.LineNum),fdel$ ! line Number (would be zero at first?)
	If elflag=9 ! existing line send flag
		WebStr$=WebStr$,Str$(rol.NewPPFlg),fdel$ ! perm/1 time price
    Endif ! if include type on new also - endif here
		tmp$="STK";X2=rol.LineType
		if rol.NStkItem LET TMP$="NSTK"
		if rol.NStkItem AND X2=3 LET TMP$="MSG"
		IF X2=1 let tmp$="INV"
		If X2=2 LET TMP$="FIN"
		WebStr$=WebStr$,RTRIM$(TMP$),FDEL$ ! line type
	!Endif ! is no type on new line - endif here
	! per web - send all flags & current factors NOW
	
	X3=UMtoFactor(ROL.UMSell)
	Webstr$=Webstr$,Str$(X3),fdel$
	X3=UMtoFactor(ROL.UMCost)
	Webstr$=Webstr$,Str$(X3),fdel$
	X3=UMtoFactor(ROL.UMprice)
	Webstr$=Webstr$,Str$(X3),fdel$
	if rol.NStkItem ! make sure flags correct
		pw.ChkBrknQty$="N";pr.MBFlg$="B"
		pr.SerNoTrack$="N";pr.CatchwgtItem$="N"
		pr.LotCtrl$="N";pr.RollLbItem$="N"
		! pw.DNReordFlg=1
	Endif
	if pw.ChkBrknQty$<>"N" let pw.ChkBrknQty$="Y" ! Y is default
	WebStr$=Webstr$,pw.ChkBrknQty$,fdel$,pr.MBFlg$,fdel$ ! chk brkn, make/buy
	let pr.SerNoTrack$="N";pr.LotCtrl$="N" ! can't do as its a QUOTE
	WebStr$=WebStr$,pr.SerNoTrack$,fdel$,pr.CatchwgtItem$,fdel$ ! s/n, catchwgt
	WebStr$=WebStr$,pr.LotCtrl$,fdel$,pr.RollLbItem$,fdel$ ! lotcontrol, roll/lb
	tmp$=XUNIT$(pr.UMBrknQty,ccc)
	WebStr$=WebStr$,Str$(pw.DNReordFlg),fdel$,RTrim$(tmp$),fdel$ ! DNReord, brkn um
	if not(rol.NStkItem) and prr>0 ! need re-read for brknumfactor
		read record #PRC,PRR,0;pr.; ! as may not be used as a line um
	Endif
	X3=UMtoFactor(pr.UMBrknQty)
	WebStr$=WebStr$,Str$(pr.UMBrknQty),fdel$,Str$(X3),fdel$ ! um id, um factor
	if not(rol.NStkItem) and prr>0 ! need reset for rest of routine back to line ums
		Call SetPRtoRol() ! reset to line details
	Endif
	tmp$="N" \ if rol.UpdtStk=1 let tmp$="Y"
	webstr$=webstr$,tmp$,fdel$	! stock update
	! if roh.ordtype=15 ! send relqty as sep field?
	tmp$="N" \ if rol.KitDesignation$="KIT" let tmp$="Y"
	if credit let tmp$="N"
	webstr$=webstr$,tmp$,fdel$ ! kit y/n
	tmp$="" ! KIT ACTION
	if rol.KitDesignation$="KIT" ! see if action needed
	   if not(credit)
			tmp$=chkkit$() ! function returns string
	   Endif
	Endif
	webstr$=webstr$,tmp$,fdel$ ! kit action - (WEB FLAG)
	webstr$=webstr$,Str$(rol.PriceOrigin),fdel$,Str$(rol.CostOrigin),fdel$
	! 6974 - add bo rel qty - zero on quotes
	Webstr$=webstr$,"0",fdel$
	webstr$=webstr$,Str$(rol.numout),fdel$ ! cutting out
	cnvtu[0]=0;cnvtu[1]=rol.umcost;cnvtu[2]=2
	Cnvta=NETCOST \ if rol.UMCost>0 and rol.numout>0 let cnvta=NETCOST/rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	If p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=x3
			cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
	endif
	WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! net cost
	if roh.ordtype=4 ! send bill fields
		cnvtu[0]=0;cnvtu[1]=rol.umsell;cnvtu[2]=1
		cnvta=rol.CurrBillQty \ if rol.umsell>0 and rol.numout>0 let cnvta=rol.CurrBillQty*rol.numout
		amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		webstr$=webstr$,LTrim$(amount using Qmask$),fdel$ ! currbillqty
		cnvta=rol.PrevQtyBill \ if rol.umsell>0 and rol.numout>0 let cnvta=rol.PrevQtyBill*rol.numout
		amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		webstr$=webstr$,LTrim$(amount using Qmask$),fdel$ ! prevbillqty
	Else
		webstr$=webstr$,"",fdel$,"",fdel$ ! curr/prev bill qty
	Endif
	tmp$="N" \ if custom_customer$="MORRISETTE" and Int(pr.UdNumeric)<>0 let tmp$="Y"
	! If Int(pr.UdNumeric)<>0 tmp$="Y" ! TEMP - FOR .NET TEST ONLY *****************
	webstr$=webstr$,tmp$,fdel$ ! highlight product
	tmp$="N" 
	webstr$=webstr$,tmp$,fdel$ ! hold for po - N ALWAYS!
	tmp$="N" ! RASL - NOT ON QUOTES!!
	webstr$=webstr$,tmp$,fdel$ ! Rasl - N ALWAYS!
	! new - task 56199 - Add Sugg price to Main Detail (for Custom View)
	IF LPR>0 and (P9$[13,13]="M" or P9$[13,13]="G") ! can only give sugg price if last price!
		x3=0
		IF clp.UnitCost ! must have for sugg price
			! mxline = UWORK[4]*(1+((LPC2[1]-LPC2[2])/LPC2[2]) (Uwork[4]=Unitcost in costum)
			x3=rol.UnitCost*(1+((clp.UnitPrice-clp.UnitCost)/clp.UnitCost)) ! we use base!
		Endif ! of get sugg price
		If rol.UpChrg ! has up - add it in
			If rol.UpChrg<0 ! it's a $
				x3=x3+Abs(rol.UpChrg)
			Else ! it's %
				x3=x3+(x3*(rol.UpChrg/100))
			Endif
		Endif ! of upchrg it
		cnvtu[0]=0;cnvtu[1]=rol.UMPrice;cnvtu[2]=2
		cnvta=x3 ! \ if rol.umprice>0 and rol.numout>0 let cnvta=x3/rol.numout
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		If p61$[136,136]="Y" and rol.currfact<>0 and amount<>0 ! 
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=amount
			cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=fnq(cnvca[0])
		endif
		IF P61$[50,50]="Y" ! price rounding
			x2=cmc.PriceRoundFactor
			if x2>0 and x2<9
				Call "pricernd",x2,Amount
			Endif
		Endif 
		WebStr$=WebStr$,LTrim$(Amount using PMask$),fdel$ ! as price um
		! WebStr$=WebStr$,Str$(X3),fdel$ ! as base (line um chg'd?)
	Else
		WebStr$=WebStr$,"0",fdel$ ! no sugg
	Endif
	! edit price 
	let tmp$="Y" ! alway yes for quotes
	!if ucf$[7,7]="N" and roh.ordtype=1 and not(credit)
	!	if rol.priceorigin>82 and rol.priceorigin<115
	!		let tmp$="N"
	!	endif
	!	if rol.priceorigin=3 let tmp$="N" !- promotion (product)                    
    !    if rol.priceorigin=6 let tmp$="N" !- contract/special all products                                     
    !    if rol.priceorigin=7 let tmp$="N" !- promotion (commodity)               
    !    if rol.priceorigin=8 let tmp$="N" !- promotion (all products)            
	!	if rol.priceorigin=11 let tmp$="N" ! - size promotion                                                    
	!	if rol.priceorigin=12 let tmp$="N" !- size special/contract                                             
	!	if rol.priceorigin=13 let tmp$="N" !- fixed price customer contract                                     
	!	if rol.priceorigin=15 let tmp$="N" !- cost grp special price   
	!	if rol.priceorigin=16 let tmp$="N" !- cost grp promotion
	!endif
	webstr$=webstr$,tmp$,fdel$
	List$[row]=WebStr$
	Let row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	if debugdetail
		dmsg$="Main Detail "+Str$(Orderno)+"-"+Str$(LineNo)+" "+rol.prodcode$+Message$ \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
 end try
end sub ! LineMainDtl
! 
!--------------------------------------------------------------------
Sub getordlines()
! go thru passed order and send existing lines back
 Try
	Dim KOL$[60],KPW$[60],KCM$[50],KLP$[60]
	Dim ZOL$[60]
	Dim 1%,FCDays,cnvtu[2],elflag
	Dim 2%,OrderNo,row,tmpcnt,JDate[5],FDate
	Dim 3%,OLR,FutCost,CNVTA,Amount

	Dim ZROL. as qol ! for zlines (get data for it before sending line)
	if debugdetail
		dmsg$="Start get Existing Lines" \ Call updatelog(debug)
	Endif
	MaxLines=50 ! used by dopart
	Read #ctlc,2,198;FCDays; ! days to check future cost
	If FCDays<1 or FCDays>999 or Fra(FCDays) Let FCDays=30 ! check range
	ReturnStatus=1
	Message$="OK"
	Call DXGet("ORDERID",tmp$)
	X2=tmp$
	If X2<1 or X2>999999 or Fra(X2) ! not valid
		ReturnStatus=0
		Message$="ORDER NOT PASSED"
		goto golDone:
	Endif
	OrderNo=x2
	OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
	If OHR<=0 ! not found
		ReturnStatus=0
		Message$="ORDER NOT FOUND"
		goto golDone:
	Endif
	Call GetCust()
	CREDIT=0 \ if ros.status=32 let credit=1
	if credit and roh.ShipType=3 let cost_lev[1]=0 ! no cost on cm price error
	! add a break after x lines - so need a beginning line #
	Call dxget("BEGLINE",tmp$)
	Let StrtLine=tmp$
	if StrtLine<0 or StrtLine>999 or fra(StrtLine)
		ReturnStatus=0
		Message$="Starting Line Invalid"
		goto golDone:
	Endif
	! set list header (SIMILAR TO PRODDETAIL ACTION!)
	elflag=9 ! existing Line Flag (for detail to string) as add'l fields needed
		Clear List$[]
		List$[0]=bsdel$,"LINEDETAIL",fdel$
		call MainDtlHdr() ! set webstr$ for main header/LineMainDtl
		List$[1]=WebStr$
		Row=2;tmpcnt=maxcnt
	! okay - see if lines
	KOL$=" ",KOL$;NumLines=0
	KOL$=OrderNo Using "######"
	if dooneline or (DoPart and StrtLine>0)
		x2=dooneline \ if DoPart and StrtLine>0 let x2=StrtLine
		let KOL$[7]=x2-1 using "###" ! so next line is it
		let kOL$[10]=" "
	Endif
	! what if start with or only zlines on order??
	Do
		OLR=filegetqolz(e$,OLC,">",1,kol$,rol.)
		clear e$
		If OLR<0 exit do
		X2=kol$[1,6] \ if x2<>orderno exit do
		if (roh.OrdType=21 or roh.OrdType=22) and kol$[7,9]="   " goto bpldtl ! ot 21/22
		x2=kol$[7,9] \ if dooneline and x2<>dooneline exit do ! only want 1 line
		if doPart and NumLines>=MaxLines ! web side wants xx lines at a time
			let returnstatus=5 ! signal that more to come - send this lines data
			message$="ORDERID="+Str$(OrderNo)+"&BEGLINE="+Str$(X2)+"&" ! BEGKEY="+Kol$
			Exit do
		Endif
		NonStk=rol.NStkItem
		ZLine=0 \ if rol.LineType=3 and NonStk let ZLine=1 ! need for later
		! get/read appropriate records (prod,prodwhse,comm,lastprice
		If Not(NonStk) ! it's a prod
			PRR=rol.PDRecNum
			Read record #PRC,PRR,0;PR.;
			if roh.ordtype=8 or roh.ordtype=16
			  If Roh.ConsWh>0 and roh.conswh<100
				Let TPWKey$=" ",tpwKey$
				TPWkey$[1,12]=rol.prodcode$+Blank$
				TPWKey$[13]=ROH.ConsWh Using "##"
				call chktowhse(TPWKey$,pr.PrimVend)
			  Endif
			Endif
			KPW$=" ",KPW$
			Kpw$=rol.prodcode$+rol.whse Using "##"
			IF roh.ordtype=7 let Kpw$=rol.prodcode$+ROH.ConsWh Using "##"
			PWR=filegetprodwhse(e$,PWC,"=",1,KPW$,pw.)
			clear e$
			if PWR<0 ! not found
				Clear pw.
				If PWR=-1 ! not found - add?
					E$="";x3=kpw$[13,14]
					if roh.ordtype=7
						x3[1]=rol.whse/100
						x3=x3+x3[1]
					Endif
					Whbld[0]=PWC;Whbld[1]=X3;WhBld[2]=pr.PrimVend
					if x3<>1 let Whbld[1]=x3+.01 ! fra=copy whse 1
					Call mxwhcreate(e$,IntCo,rol.PRODCode$,WHBLD[])
					PWR=Whbld[2]
					Read record #PWC,PWR,0;PW.;
				Endif
			Endif
			If rol.ComdtyCode$="" or rol.ComdtyCode$=Blank$[1,4]
				rol.ComdtyCode$=pr.ComdtyCode$
			Endif
		Else
			Clear pr.
			Clear pw.
		Endif
		! always set up pr. w/line factors
		LineNo=rol.LineNum
		Call SetPRtoRol()
		KCM$=" ",KCM$
		KCM$=rol.ComdtyCode$+Blank$[1,4];kcm$[5]=""
		CMR=filegetcommhead(e$,cmc,"=",1,KCM$,cmc.)
		clear e$
		If CMR<1 Clear cmc.
		KLP$=" ",KLP$ ! look for lastprice record
		klp$[1,6]=ROH.custnum using "######"
		X2=rol.dept \ if P9$[44,44]<>"Y" let x2=0
		KLP$[7,10]=X2 Using "####"
		If Not(NonStk)Let KLP$[11]=rol.prodcode$
		If NonStk Let KLP$[11]=rol.VendItemCode$ ! is diff on nonstks!
		tmp$=KLP$ ! only know/can send up to prod
		LPR=filegetlastprice(e$,LPC,">",1,KLP$,CLP.)
		clear e$
		If klp$[1,22]<>tmp$[1,22] let lpr=-1
		If LPR<=0 clear clp.
		FlePtr[4,1]=LPR ! is used this way elsewhere
		FutCost=0
		If Not(NonStk) ! can only call price for futcost on stock items
			Call SetUpSpecs() ! get specs info for fut cost
			! future cost = cost as of xx days from today (specs[5] chg)
			JDate=TIM(6)+FCDays ! ## days from today
			tmp$=JDate$(jdate) ! from ddddd to MM/DD/YYYY
			tmp1$=Formatdate2$(tmp$) ! now MM/DD/YYYY to YYYYMMDD
			Let FDate=tmp1$[3,8] ! just need yymmdd
			Let Specs[5]=0-FDate
			Call getprice() ! call price w/all entries above
			If Specs[0]=0 ! okay
				Let X3=Specs[17]
				cnvtu[0]=0;cnvtu[1]=rol.UMCost;cnvtu[2]=2
				Cnvta=X3 \ if rol.umcost>0 and rol.numout>0 let cnvta=x3/rol.numout
				FutCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			Endif
		Endif ! of stk item - get future cost
		if roh.OrdType=8 or roh.OrdType=16 ! cons/trans - no price/cost
			rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
			rol.UnitPrice=0;rol.CutChrg=0;rol.CutCost=0
			rol.LineDisc=0;rol.ExtOrdAmt=0;rol.ExtShipAmt=0
			rol.LineDiscPct=0;rol.ExtCutChg=0;rol.ExtCutCost=0
			rol.ExtLoadShip=0;rol.ExtLoadOrd=0;rol.NetPrice=0
			rol.TaxAmt=0;rol.LoadUpchrg=0;rol.UpChrg=0
		Endif
		If p61$[46,46]="Y" and Credit and roh.shiptype=3 ! price fix - no cost
			rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
			rol.CutCost=0;rol.ExtCutCost=0;rol.ExtLoadShip=0;rol.ExtLoadOrd=0
			rol.LoadUpchrg=0
		Endif
		If roh.OrdType=37  ! "EVAP Ship - NO Price - any order in here
			If Not(Credit) Or (Credit And roh.ShipType=16)
				Let rol.UnitPrice=0;rol.NetPrice=0;rol.CutChrg=0
				Let rol.LineDisc=0;rol.LineDiscPct=0;rol.UpChrg=0
				rol.ExtOrdAmt=0;rol.ExtShipAmt=0;rol.ExtCutChg=0
			Endif
		Endif
		If roh.OrdType=36 ! "EVAP Billing - NO Cost - Any type order
			If Not(Credit) Or (Credit And roh.ShipType=16)
				Let rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
				Let rol.CutCost=0;rol.ExtCutCost=0;rol.ExtLoadShip=0;rol.ExtLoadOrd=0
				rol.LoadUpchrg=0;netcost=0
			ENDIF
		Endif
		Call LineMainDtl() ! set up web string
		NumLines=NumLines+1
	 BPLDTL: ! bypass line (ot21/22)
	Loop ! done with order
	List$[row]=esdel$ ! finished
	call AddToStr(e$,rstr$,List$[])
	GolDone: ! finish ord line get
	! status section
	if debugdetail
		dmsg$="Existing Lines "+Str$(Orderno)+" TTL "+Str$(NumLines)+" "+Message$ \ Call updatelog(debug)
	Endif
	if not(dooneline)
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
	Endif ! don't send on one line get
	! 
	! call programdump("/tmp/ollog6!","")
 else
    include "src/callsuberr.inc"
 end try
end sub ! getordlines
! 
!--------------------------------------------------------------------
sub getcomplist()
! get a list of complementary items for a product
! output like scan list

 Try
	Dim 1%,OType
	Dim 2%,Whse
	Dim 3%,tmpcnt
	
	Call DXGet("PRODID",tmp$)
	Prod$=UCase$(tmp$)
	Prod$=Prod$+Blank$
	If Len(Prod$)>12 let prod$[13]=""
	Call DXGet("WHSE",tmp$)
	Whse=tmp$
	
	ReturnStatus=1
	Message$="OK"
	If Whse<1 or whse>99 or Fra(whse)
	  ReturnStatus=0
	  Message$="WAREHOUSE NOT PASSED"
	  Goto ComplDone ! needs to be?
	Endif
	ProdKey$=Prod$
	ProdKey$[13]="" ! cut to length
	PRR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.)
	clear e$
	If PRR<=0 ! has to exist!
		ReturnStatus=0
		Message$="PRODUCT NOT FOUND"
		Goto ComplDone ! has to be
	Endif
	Call DXGet("ORDTYPE",tmp$)
	Let OType=tmp$ \ if otype<0 Or OType>38 Let OType=0

	Call CompIList(e$,IntCo,List$[],maxcnt,ctlc,prc,whc,ccc,Prod$,Whse,OType)
	call AddToStr(e$,rstr$,List$[])
	ComplDone: ! finish Complist get
	! status section
	if debugdetail
		dmsg$="Complementary List "+prod$+Message$ \ Call updatelog(debug)
	Endif
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
	! 
	! call programdump("/tmp/ollog7!","")
 else
    include "src/callsuberr.inc"
 end try
end sub ! getcomplist
! 
!--------------------------------------------------------------------
Sub setpricelist()
! wants a list of prices (List, Bracket/Break)
 Try
	Dim 3%,Bprice[10],UPrice[10]
		Dim 3%,Bupchrg
		Call DXGet("PRODID",prod$) \ prod$=UCase$(prod$)
		Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
		ProdKey$=Prod$
		PrR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.) ! product mode=2 dir=1
		clear e$	!
			! initialize status
		If PrR<0 ! Product record not found
			 clear PR.
			 ReturnStatus=0
			 Message$="Error, Product not found"
		else ! continue with lists
			Returnstatus=1
			Message$="OK"
			Call DXGet("ORDERID",tmp$)
			if tmp$="" 
				let Message$="ORDER # MISSING"
				Let ReturnStatus=0
				Goto PLstSendDone:
			Endif
			OrderNo=tmp$
			If OrderNo>0 and OrderNo<999999 and Not(Fra(OrderNo))
			OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
				If OHR<=0 ! no order found
					Let Message$="ORDER # NOT FOUND"
					Let ReturnStatus=0
					Goto PLstSendDone:
				Endif
			Endif
			if roh.ordtype=15 and roh.boctr<>0 ! no price change
				returnstatus=0
				message$="Cannot change price!"
				Goto PLstSendDone
			Endif
			Call GetCust()
			Call DXGet("WHSE",tmp$) ! if line whse <> header
			Whse=tmp$ \ if whse<1 or Whse>99 Let Whse=roh.wh
			if roh.ordtype=7 let whse=ROH.ConsWh ! prices from "to" whse
			Call DXGet("UMPRC",tmp$) ! price um id
			! If tmp$[1,1]>"9" ! sent text?
				R=getumrec(e$,CCC,tmp$,IntCo,PR.)
				If R<>0 let tmp$=Str$(R)
			! Endif
			let PRUM=tmp$ \ if prum=0 Let prum=pr.UMPriceDefault
			Call DXGet("PTYPE",tmp$)
			tmp$=UCASE$(tmp$)
			tmp$=RTrim$(tmp$) ! uppercase and trimmed
			If tmp$<>"LIST" and tmp$<>"BRACKET" ! other options?
				MessagE$="PRICE OPTION MISSING"
				ReturnStatus=0
				Goto PLstSendDone:
			Endif
			Field$[0]=tmp$
			clear tmp$ ! jic not sent
			call dxget("QTYOUT",tmp$)
			pnumout=tmp$
			if pnumout<0 or pnumout>999 or fra(pnumout)
				returnstatus=0
				message$="INVALID QTY OUT"
				GOTO PLstSendDone
			endif
			! call programdump("/tmp/ollog3!","")
			! okay now get the prices from call price
			Clear specs[] ! clear specs vars
			Clear List$[]
			List$[0]=bsdel$,"PRICES",fdel$
			List$[1]="Name",fdel$,"Price",fdel$,"PricewithUp",fdel$
			Row=2
			tmpcnt=maxcnt
			! need certain records
			tmp$=" ",tmp$;tmp$=prod$
			tmp$[13]=Whse Using "##"
			PWR=filegetprodwhse(e$,pwc,"=",1,tmp$,pw.)
			clear e$
			tmp$=" ",tmp$;tmp$=Pr.ComdtyCode$+Blank$[1,4];tmp$[5]=""
			CMR=filegetcommhead(e$,CMC,"=",1,tmp$,cmc.)
			clear e$
			fleptr[1,1]=PRR;fleptr[2,1]=PWR;fleptr[3,1]=CMR ! prod,prodwh,comm
			if pr.PriceUpchrg ! has data setup bupchrg
				If pr.PriceUpchrgType=0 ! it's %
					Bupchrg=pr.PriceUpchrg
				Endif
				If pr.PriceUpchrgType=1 ! it's $ (in upum)
					cnvtu[0]=pr.UMUpChrg;cnvtu[1]=0;cnvtu[2]=6 ! to base no round was =2
					cnvta=pr.PriceUpchrg
					Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
					Bupchrg=0-amount ! baseum uc
				Endif
			Endif ! has u/c data
			If Field$[0]="LIST"
				! see if specs[0]=6 does as it says (costs & ALL LP's) DOES NOT WORK!
				Specs[0]=1;specs[1]=1;specs[2]=1;Specs[3]=roh.CustNum
				Specs[4]=whse;specs[5]=roh.OrdDate;specs[6]=roh.Dept;specs[7]=roh.PriceType
				Specs[8]=roh.OrdType;Specs[9]=1;Specs[13]=pr.UMSellDefault
				Specs[14]=prum;specs[15]=pr.UMCostDefault
				For X=1 to 6 ! needs mode 1
					Specs[0]=1;Specs[11]=x;Specs[20]=0
					Call GetPrice() ! standard price call
					If Specs[0]=0 let Bprice[x]=Specs[20];UPrice[x]=specs[20]
				Next X
					
			Endif ! want list prices
			If Field$[0]="BRACKET" ! breaks or brackets
				prctype=pr.PriceType
				! specs[0]=2 or 3 and Specs[11]=level (1-10)
				If Prctype=1 ! matrix
					Specs[0]=0;specs[1]=1;specs[2]=1;Specs[3]=roh.CustNum
					Specs[4]=whse;specs[5]=roh.OrdDate;specs[6]=roh.Dept;specs[7]=roh.PriceType
					Specs[8]=roh.OrdType;Specs[9]=1;Specs[13]=pr.UMSellDefault
					Specs[14]=prum;specs[15]=pr.UMCostDefault
					Call GetPrice() ! NEED SYSTEM PRICE/COST?
					BPrice[0]=Specs[20];UPrice[0]=Specs[17]
					For Blvl=1 to 10
						Specs[0]=2;Specs[11]=BLvl;Specs[20]=BPrice[0];specs[23]=0
						Call GetPrice() ! standard price call
						If Specs[0]=0 Let BPrice[blvl]=Specs[23];UPrice[blvl]=Specs[23] ! Net?
						! if blvl=2 call programdump("/tmp/ollog2!","")
					Next Blvl
				Endif
				If Prctype=2 ! 10 bracket
					Specs[0]=3;specs[1]=1;specs[2]=1;Specs[3]=roh.CustNum
					Specs[4]=whse;specs[5]=roh.OrdDate;specs[6]=roh.Dept;specs[7]=roh.PriceType
					Specs[8]=roh.OrdType;Specs[9]=1;Specs[13]=pr.UMSellDefault
					Specs[14]=prum;specs[15]=pr.UMCostDefault
					Call GetPrice() ! NEED SYSTEM PRICE/COST?
					BPrice[0]=Specs[20];UPrice[0]=Specs[17]
					For Blvl=1 to 10
						Specs[0]=3;Specs[11]=BLvl;Specs[20]=BPrice[0]
						Call GetPrice() ! standard price call
						If Specs[0]=0 Let BPrice[blvl]=Specs[23];UPrice[blvl]=Specs[23] ! net?	
					Next Blvl
				Endif
				
			Endif ! break/bracket
			! got prices - now up 'em (UP Was IN BREAKUM, Now BASE)
			If BUpchrg>0 ! apply %
				for x=1 to 10
					If UPrice[x] LET UPrice[x]=UPrice[x]+(UPrice[x]*(Bupchrg/100))
				next x
			Endif
			If BUpchrg<0 ! apply $
				For x=1 to 10
					If UPrice[x] LET UPrice[x]=UPrice[x]+ABS(BUpchrg)
				Next x
			Endif
			SysRnd=0
			if p61$[50,50]="Y" and cmc.PriceRoundFactor Let SysRnd=cmc.PriceRoundFactor
			! finally send it out
			tmp$="LIST PRICE "
			If Field$[0]="BRACKET" let tmp$="LEVEL "
			For X=1 to 10
				WebStr$=tmp$,Str$(x),fdel$ ! name
				cnvtu[0]=0;cnvtu[1]=prUM;cnvtu[2]=2
				cnvta=BPrice[x];Amount=0
				if prum>0 and pnumout>0 let cnvta=bprice[x]/pnumout
				if cnvta let Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				If p61$[136,136]="Y" and rol.currfact<>0 and amount<>0 !
					let cnvcu[0]=1
					!let cnvcu[1]=1
					let cnvca[0]=amount
					cnvca[1]=rol.currfact
					call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
					let x3=fnq(cnvca[0])
				endif
				If SysRnd Call "Pricernd",SysRnd,amount ! needs rounding?
				X3=Amount
				WebStr$=WebStr$,LTrim$(X3 using PMask$),fdel$ ! price
				cnvtu[0]=0;cnvtu[1]=prUM;cnvtu[2]=2
				cnvta=UPrice[x];Amount=0
				if prum>0 and pnumout>0 let cnvta=UPrice[x]/pnumout
				if cnvta let Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				If p61$[136,136]="Y" and rol.currfact<>0 and amount<>0 !
					let cnvcu[0]=1
					!let cnvcu[1]=1
					let cnvca[0]=amount
					cnvca[1]=rol.currfact
					call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
					let x3=fnq(cnvca[0])
				endif
				If SysRnd Call "Pricernd",SysRnd,amount ! needs rounding?
				X3=Amount
				WebStr$=WebStr$,LTrim$(X3 using PMask$),fdel$ ! price w/uc
				List$[row]=WebStr$
				row=row+1
				if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
				If Field$[0]="LIST" and x=6 let x=11 ! only 6 list prices
			Next X
		
			List$[row]=esdel$ ! finished
			call AddToStr(e$,rstr$,List$[])
		PLstSendDone: ! finished
		Endif ! of valid prod
		! status section
	  if debugdetail
		dmsg$="Prices "+Str$(Orderno)+" "+prod$+Field$[0]+" "+Message$ \ Call updatelog(debug)
	  Endif
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
 else
    include "src/callsuberr.inc"
 end try
end sub ! setpricelist
! 
!--------------------------------------------------------------------
Sub SetNewProdline()
! take pad list - send line details
 Try
	Call DXGet("ORDERID",tmp$)
		if tmp$="" 
			let e$="ORDER # MISSING"
			Let ReturnStatus=0
			Goto PDSendDone:
		Endif
		OrderNo=tmp$
		If OrderNo>0 and OrderNo<999999 and Not(Fra(OrderNo))
			OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
			If OHR<=0 ! no order found
				Let e$="ORDER # NOT FOUND"
				Let ReturnStatus=99
				Goto PDSendDone:
			Endif
		Endif
		if roh.ordtype=15 and roh.boctr<>0 ! no add once accepted!
			Returnstatus=0
			Message$="Invoice has been accepted. No new lines allowed"
			Goto PDSendDone:
		Endif
		Call GetCust()
		Call DXGet("TTLPRODS",tmp$)
		Let NumProds=tmp$
		if NumProds<1 ! HAS TO BE AT LEAST 1!
			let e$="NO NUMBER OF ITEMS SENT"
			Let ReturnStatus=0
			Goto PDSendDone:
		Endif
		ReturnStatus=1
		Message$="OK" 
		Credit=0 \ if ros.status=32 let credit=1
		! set list header
		Clear List$[]
		clear slist$[]
		!docpi=0 \ if userid$[1,4]="JIMS" or userid$[1,2]="S8" let docpi=1 ! for testing only
		if p61$[111,111]="Y" and not(credit) ! and docpi=1
			call dxget("CPIFINAL",tmp$)
			if ucase$(rtrim$(tmp$))="Y" GOTO CPIADONE ! final list coming
			cpiflag=0;tmpcnt=maxcnt;Custno=roh.CustNum
			clear list$[]
			! ok - make a call & check results if exceptions - status=11 and results in list$
			Call cpiordchk(e$,intco,cpiflag,tmpcnt,custno,CUC,CUR,NumProds,OHC,OHR,List$[])
			if cpiflag=0 ! all ok
				clear list$[] ! clear whatever is sent
				goto CPIADone ! ALL OK
			Endif
			ReturnStatus=11
			message$="CPI Exceptions"
			call AddToStr(e$,rstr$,List$[])
			goto PDSendDone ! bypass rest
		CPIADONE: ! finished with cpi
		Endif
		ELFlag=0 ! not existing
		List$[0]=bsdel$,"PRODUCTDETAIL",fdel$
		call MainDtlHdr() ! set webstr$ for main header/LineMainDtl
		List$[1]=WebStr$
		Row=2;tmpcnt=maxcnt;tmpcnt2=maxcnt
		! second list 
		slist$[0]=bsdel$,"OT15LIST",fdel$  ! key is PRODID
		SList$[1]="PRODID",fdel$,"ORDERID",fdel$,"LINE",fdel$,"OPENQTY",fdel$,"UM",fdel$
		row2=2
		ReturnStatus=1;Message$=""
		For LD=1 to NumProds
			let e$=""
			Call DXGet("PRODID"+Str$(LD),tmp$)
			tmp$=RTrim$(tmp$)
			If tmp$="" Goto LDPDone: ! NEED A PRODUCT!
			Let PROD$=UCase$(tmp$)+Blank$
			If prod$[1,3]="+  " OR PROD$[1,6]="ZNSTK "! it's nonstock
				prod$="Z ZZZZZZZZZZ"
			Endif ! will not have um or qty for messg or nonstk?
			Call DXGet("QTY"+Str$(LD),tmp$)
			Let SQty=tmp$ ! in sum units
			Call DXGet("UM"+Str$(LD),tmp$)
			Let SUM=tmp$
			! added for order pad detail entry
			call dxget("SHIPQTY"+Str$(LD),tmp$)
			SHQty=tmp$ ! in sum units (ordpad dtl)
			call dxget("BOQTY"+Str$(LD),tmp$)
			let BOQty=tmp$ ! in sum um (ordpad dtl)
			call dxget("SUBSTFLG"+Str$(LD),tmp$)
			tmp$=UCase$(RTrim$(tmp$))
			Substitm=0 \ if tmp$="Y" let substitm=1
			call dxget("LTYPE"+Str$(LD),tmp$)
			LPType$=UCase$(rtrim$(tmp$))
			if LPtype$="NSTK" ! additional
				call dxget("LPFLE"+Str$(LD),tmp$) ! last price file used
				lpnstk=0
				if UCase$(RTrim$(tmp$))="C" let lpnstk=1
				if UCase$(RTrim$(tmp$))="S" let lpnstk=2 ! shiplist
				call dxget("LPREC"+Str$(LD),tmp$) ! last price rec
				LPREC=tmp$
			Endif
			Call GetNewProdDtl(e$,List$[],tmpcnt,Prod$,Sqty,SUM,OHR,SHQty,BOQty)
			If e$<>""  ! a problem!
				Message$=Message$+Prod$+E$+"  " ! send prod & reason
				ReturnStatus=0
			Endif
			cust=roh.CustNum
			If not(credit) call getot15list(e$,SList$[],row2,tmpcnt2,Cust,Prod$,SUM)
		LDPDone: ! bypass
		Next LD ! next sent prod,qty,um
		List$[row]=esdel$
		call AddToStr(e$,rstr$,List$[])
		Slist$[row2]=esdel$
		If Not(Credit) call addtostr(e$,rstr$,SList$[]) ! SEND NEW SECTION!!****
		!
	  PDSendDone: ! finished
	  ! status section
	  If ReturnStatus=1 let message$="OK"
	  if returnstatus<>1 and message$="" let message$=E$
	  if debugdetail
		dmsg$="List Setup "+Str$(Orderno)+" TTL IN "+Str$(NumProds)+" "+Message$ \ Call updatelog(debug)
	  Endif
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
 else
    include "src/callsuberr.inc"
 end try
end sub ! SetNewProdline
! 
!--------------------------------------------------------------------
Sub PriceWrkData()
  Try

	Call DXGet("PRODID",prod$) \ prod$=UCase$(prod$)
			Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
			ProdKey$=Prod$
			Call dxget("LTYPE",tmp$)
			tmp$ = UCase$(tmp$)
			if tmp$[1,4]<>"NSTK" ! LET PRODKEY$[1,6]="ZNSTK " ! set to non-stock
				PrR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.) ! product mode=2 dir=1
				clear e$
				NonStk=0
			Else
				PRR=0;nonstk=1
				Call dxget("ORDERID",tmp$)                           
				orderno = tmp$  
				If not(orderno)
					let prr=-1
					goto endnspricewrk:
				endif
				If orderno <= 0 Or orderno > 999999 Or Fra(orderno)  
					ReturnStatus = 0                                   
					Message$ = "INVALID ORDER!"  
					let prr=-1
					goto endnspricewrk:
				End If   
				Call dxget("LN",tmp$) ! +Str$(X1),tmp$)         
				LineNo = tmp$ ! line # (zero on new lines)
				If LineNo <= 0 Or LineNo > 999 Or Fra(lineno)  
					ReturnStatus = 0                                   
					Message$ = "INVALID ORDER LINE!"
					prr=-1
					goto endnspricewrk:
					
				End If   
				rolkey$ = " ",rolkey$                         
				rolkey$[1,6] = orderno Using "######"         
				rolkey$[7,9] = LineNo Using "###"       
				rolkey$[11] = "" ! cut to length (space @ 10) 
				OLR = filegetqolz(e$,OLC,"=",1,rolkey$,rol.)
				clear e$
				if olr<=0
					returnstatus=0
					Message$="Order Line Not Found"
					prr=-1
					goto endnspricewrk:
				endif
				IF rol.NStkItem <> 1
					returnstatus=0
					message$="Not a NonStock Item"
					prr=-1
					goto endnspricewrk:
				endif
				let prodkey$=rol.prodcode$
				Call SetPRtoRol()
				endnspricewrk: ! end of getting factors for non-stock item
			Endif
			!
			! initialize status
		  If PrR<0 ! Product record not found
			 clear PR.
			 ReturnStatus=0
			 Message$="Error, Product not found"
		  else ! continue with lists
			List$[0]=bsdel$,"UPCHARGE",fdel$
			List$[1]="TEXT",fdel$
			If PR.PriceUpchrgType=0 AND PR.PriceUpchrg>0 ! it's a %
				WebStr$="UP ",LTrim$(PR.PriceUpchrg Using "###.##"),"%"
				WebStr$=WebStr$," if less than "
				tmp$=XUnit$(PR.UMUpChrg,ccc)
				WebStr$=WebStr$,RTrim$(tmp$),fdel$
			Endif
			If PR.PriceUpchrgType=1 AND PR.PriceUpchrg>0 ! IT'S $$
				X3=Abs(PR.PriceUpchrg)
				WebStr$="UP ",LTrim$(X3 Using PMask$)
				tmp$=XUnit$(PR.UMUpChrg,ccc) ! IS in upUM!
				WebStr$=WebStr$,"/",RTrim$(tmp$)," if less than "
				tmp$=XUnit$(PR.UMUpChrg,ccc)
				WebStr$=WebStr$,RTrim$(tmp$),fdel$
			Endif
			If PR.PriceUpchrg=0
				WebStr$="no u/c",fdel$
			Endif
			List$[2]=WebStr$
			List$[3]=esdel$ ! end this section
			call AddToStr(e$,rstr$,List$[]) ! add section 1
			! now 2 UM lists (Qty & Price)
			!Call env(2,"UTYPE","QTY") ! try setting a var?
			tmp$="QTY" ! try a pass
			Clear List$[]
			E$="" ! clear message
			Call UMDList(e$,tmp$,PRC,PRR,List$[],IntCo,Pr.)
			call AddToStr(e$,rstr$,List$[]) ! add section 2
			tmp$="PRICE" ! try a pass
			Clear List$[]
			E$="" ! clear message
			Call UMDList(e$,tmp$,PRC,PRR,List$[],IntCo,Pr.)
			call AddToStr(e$,rstr$,List$[]) ! add section 3
			tmp$="COST" ! try a pass
			Clear List$[]
			E$="" ! clear message
			Call UMDList(e$,tmp$,PRC,PRR,List$[],IntCo,Pr.)
			call AddToStr(e$,rstr$,List$[]) ! add section 4
			! A SECTION ON DECIMALS/ROUNDING
			Clear List$[]
			List$[0]=BSDEL$,"DECIMALROUND",fdel$
			List$[1]="Decimals",fdel$,"Rounding",fdel$
			List$[2]=Str$(Q0[1]),fdel$,P9$[42,42],fdel$
			List$[3]=esdel$
			call AddToStr(e$,rstr$,List$[]) ! add section 5
			Let ReturnStatus=1
			Message$="OK"
			If E$<>""
			  Let ReturnStatus=0
			  Message$=E$
			Endif
		  Endif ! valid prod
	if debugdetail
		dmsg$="Price Detail "+prod$+Message$ \ Call updatelog(debug)
	Endif
	  ! status section
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
 else
    include "src/callsuberr.inc"
 end try
end sub ! PriceWrkData
! 
!--------------------------------------------------------------------
Sub CostWrkData()
 Try

	Call DXGet("PRODID",prod$) \ prod$=UCase$(prod$)
			Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
			ProdKey$=Prod$
			Call dxget("LTYPE",tmp$)
			tmp$ = UCase$(tmp$)
			if tmp$[1,4]<>"NSTK" ! LET PRODKEY$[1,6]="ZNSTK " ! set to non-stock
				PrR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.) ! product mode=2 dir=1
				clear e$
				NonStk=0
			Else
				PRR=0;nonstk=1
				Call dxget("ORDERID",tmp$)                           
				orderno = tmp$  
				If not(orderno)
					let prr=-1
					goto endnscostwrk:
				endif
				If orderno <= 0 Or orderno > 999999 Or Fra(orderno)  
					ReturnStatus = 0                                   
					Message$ = "INVALID ORDER!"  
					let prr=-1
					goto endnscostwrk:
				End If   
				Call dxget("LN",tmp$) ! +Str$(X1),tmp$)         
				LineNo = tmp$ ! line # (zero on new lines)
				If LineNo <= 0 Or LineNo > 999 Or Fra(lineno)  
					ReturnStatus = 0                                   
					Message$ = "INVALID ORDER LINE!"
					prr=-1
					goto endnscostwrk:
					
				End If   
				rolkey$ = " ",rolkey$                         
				rolkey$[1,6] = orderno Using "######"         
				rolkey$[7,9] = LineNo Using "###"       
				rolkey$[11] = "" ! cut to length (space @ 10) 
				OLR = filegetqolz(e$,OLC,"=",1,rolkey$,rol.)
				clear e$
				if olr<=0
					returnstatus=0
					Message$="Order Line Not Found"
					prr=-1
					goto endnscostwrk:
				endif
				if rol.NStkItem <> 1
					returnstatus=0
					Message$="Order Line Not NonStock"
					prr=-1
					goto endnscostwrk:
				endif
				let prodkey$=rol.prodcode$
				Call SetPRtoRol()
				Endnscostwrk: ! end of getting factors for non-stock item
			Endif
			
			!
			! initialize status
		  If PrR<0 ! Product record not found
			 clear PR.
			 ReturnStatus=0
			 Message$="Error, Product not found"
		  else ! continue with lists
			List$[0]=bsdel$,"UPCHARGE",fdel$
			List$[1]="TEXT",fdel$
			If PR.LoadUpchgType=0 and PR.LoadCostUpchrg>0 ! it's a %
				WebStr$="UP ",LTrim$(PR.LoadCostUpchrg Using "###.##"),"%"
				WebStr$=WebStr$," if less than "
				tmp$=XUnit$(PR.UMUpChrg,ccc)
				WebStr$=WebStr$,RTrim$(tmp$),fdel$
			Endif
			If PR.LoadUpchgType=1 and PR.LoadCostUpchrg>0 ! it's $$
				X3=Abs(PR.LoadCostUpchrg)
				WebStr$="UP ",LTrim$(X3 Using PMask$)
				tmp$=XUnit$(PR.UMUpChrg,ccc) ! up$ is in UpUM!
				WebStr$=WebStr$,"/",RTrim$(tmp$)," if less than "
				tmp$=XUnit$(PR.UMUpChrg,ccc)
				WebStr$=WebStr$,RTrim$(tmp$),fdel$
			Endif
			If PR.LoadCostUpchrg=0
				WebStr$="no u/c",fdel$
			Endif
			IF RTRIM$(webstr$)="" let WebStr$="no u/c",fdel$
			List$[2]=WebStr$
			List$[3]=esdel$ ! end this section
			call AddToStr(e$,rstr$,List$[]) ! add section 1
			! now Cost UM list
			!Call env(2,"UTYPE","COST") ! try setting a var?
			tmp$="COST" ! try a pass
			Clear List$[]
			E$="" ! clear message
			Call UMDList(e$,tmp$,PRC,PRR,List$[],IntCo,Pr.)
			call AddToStr(e$,rstr$,List$[]) ! add section 2
			
			Let ReturnStatus=1
			Message$="OK"
			If E$<>""
			  Let ReturnStatus=0
			  Message$=E$
			Endif
		  Endif ! valid prod
	  if debugdetail
		dmsg$="Cost Detail "+prod$+Message$ \ Call updatelog(debug)
	  Endif	
	  ! status section
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
 else
    include "src/callsuberr.inc"
 end try
end sub ! CostWrkData
! 
!--------------------------------------------------------------------
sub UpdtLines()
! lines are being sent back to PM
! rol. = orig values, nrol. = just entered
! changed to 1 at a time (as user leaves line - save it!)
 Try
	Dim X$[20],NSFKey$[60]
	dim holdpswd$[12,16] ! just dim it
	Dim 1%,CNVTU[2],FLAG[9],X1[9]
	Dim 1%,NewLn,HFlg[16],Credit
	Dim 2%,X2[9],NumLines,ShipDate,JDate[5]
	Dim 3%,CNVTA,AMOUNT,X3[9],V3[99]
	Dim 3%,WHBLD[2],S9[20]

	Dim NRol. as qol ! store new sent data
	! call dxsave(0,"tmp/olsv.txt!")
	Read #ctlc,3,188;ShipDate; ! for inv levels
	if debugdetail
		dmsg$="Start Line Update" \ Call updatelog(debug)
	Endif
	ReturnStatus=1
	Message$="OK"
	Call DXGet("ORDERID",tmp$)
	If tmp$="" goto UDLDone:
	OrderNo=tmp$
	If OrderNo<1 or OrderNo>999999 or Fra(OrderNo)
		ReturnStatus=0
		Message$="ORDER NUMBER INVALID"
		Goto UDLDone
	Endif
	OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
	If OHR<=0 ! not found
		ReturnStatus=0
		Message$="ORDER WAS NOT FOUND"
		goto udldone
	Else
		Credit=0 \ if rot.Status=22 let Credit=1 ! instead of roh.status check
		if returnstatus<>0
			call verifystat()
			if returnstatus=99 goto udldone:
		endif
		LET X3=rot.HoldCode ! unpack hold flags
		FOR CTR=0 TO 11                          
			LET HFlg[CTR]=SGN(FRA(X3/2));X3=INT(X3/2)
		NEXT CTR 
		clear holdpswd$[] ! make sure not set
	Endif
	! Call DXGet("TTLLNS",tmp$) ! number of lines sent
	NumLines=1 ! was tmp$ for multiple
	If numlines<1 or NumLines>999 goto udldone ! cant update
	! now read in stuff
	Message$="" ! in case issues in loop
	! For X1=1 to NumLines (was for multiple
		E$="" ! clear for this loop
		OLR=0;NewLn=0;KITCHG=0;kit=0
		Clear nrol.
		Clear pr.
		Clear pw.
		Clear etr.
		Clear nstk.
		!nrol.SpareNU$ = Blank$;X0=LEN(nrol.SpareNU$)
		!	IF X0>1
		!		nrol.SpareNU$[X0-1] = ""  ! for the key
		!	ENDIF
		Call DXGet("LN",tmp$) ! +Str$(X1),tmp$)
		nrol.LineNum=tmp$ ! line # (zero on new lines)
		LineNo=nrol.LineNum
		if nrol.linenum ! get prev data
			rolkey$=" ",rolkey$
			rolkey$[1,6]=OrderNo Using "######"
			rolkey$[7,9]=nrol.linenum using "###"
			rolkey$[11]="" ! cut to length (space @ 10)
			OLR=filegetqolz(e$,OLC,"=",1,rolkey$,rol.)
			clear e$
			if olr<=0 ! what do we do if not found?
				clear rol.
				nrol.LineNum=0 ! treat as new?
			Endif
			If OLR>0
				if rol.NStkItem=1 and rol.LineType<>3
					NSR=rol.PDRecNum
					Read record #NSC,NSR,0;nstk.
					PRR=0;PWR=0
				Endif
				If Not(rol.NStkItem) ! get prod & whse
					PRR=rol.PDRecNum
					Read record #PRC,PRR,0;pr.;
					if roh.ordtype=8 or roh.ordtype=16 ! chk to whse
					  If Roh.ConsWh>0 and roh.conswh<100
						Let TPWKey$=" ",tpwKey$
						TPWkey$[1,12]=pr.prodcode$+Blank$
						TPWKey$[13]=ROH.ConsWh Using "##"
						call chktowhse(TPWKey$,pr.PrimVend)
					  Endif
					Endif
					Tmp$=" ",tmp$
					tmp$=Pr.ProdCode$+rol.Whse Using "##"
					if roh.ordtype=7 let tmp$=Pr.ProdCode$+ROH.ConsWh Using "##"
					PWR=filegetprodwhse(e$,PWC,"=",1,tmp$,pw.)
					clear e$
					if PWR<0 ! not found - add new
						Clear pw.
						If PWR=-1 ! not found
							E$="";x3=tmp$[13,14]
							if roh.ordtype=7
								x3[1]=rol.whse/100
								x3=x3+x3[1]
							Endif
							Whbld[0]=PWC;Whbld[1]=X3;WhBld[2]=pr.PrimVend
							if x3<>1 let Whbld[1]=x3+.01 ! fra=copy whse 1
							Call mxwhcreate(e$,IntCo,PR.PRODCode$,WHBLD[])
							PWR=Whbld[2]
							Read record #PWC,PWR,0;PW.;
						Endif
					Endif
				Endif
			Endif
		Else ! no line
			Clear rol. ! clear
			Clear nstk.
		Endif
		If OLR>0 Read Record #OLC,OLR,0;nrol. ! read / lock with prev values
		If OLR<=0 Let NewLn=1
		if NEWLN=1 and roh.ordtype=15 and roh.boctr<>0 ! no add
			returnstatus=0
			message$="Invoice has been accepted. No new lines allowed"
			goto UDLDone
		Endif
		if credit let nrol.KitDesignation$=blank$
		if nrol.KitDesignation$="KIT" let KIT=1
		clear nrol.SpareNu$ ! dl4 fix
		!nrol.SpareNU$ = Blank$;X0=LEN(nrol.SpareNU$)
		!	IF X0>1
		!		nrol.SpareNU$[X0-1] = ""  ! for the key
		!	ENDIF
		! we assume qty/price/cost are passed in display u/m
		Call DXGet("LTYPE",tmp$) ! +Str$(X1),tmp$) ! line type (stk,nstk,msg,del)
		tmp$=UCase$(tmp$)
		ZLine=0;NonStk=0;Stk=0;Delline=0
		if tmp$="MSG" let ZLine=1;NonStk=1
		If tmp$[1,4]="NSTK" let NonStk=1
		if tmp$[1,3]="STK" let Stk=1
		if tmp$[1,4]="CLSD" goto UDLDone ! no
		if ACTION$="NSBUILDPROD" and olr>0 and not(rol.NStkItem)
			let stk=1;Nonstk=0 ! web could send as NSTK! NO,NO
		endif
		CutLine=0
		if P9$[20,20]="F"
			If tmp$="INV" and not(nonstk) let cutline=1;Stk=1 ! only cut stock lines
			if tmp$="FIN" and not(nonstk) let cutline=2;Stk=1 ! only cut stock lines
		Endif
		if tmp$="DEL" ! deleting line
			let delline=1
			If OLR>0 call DELOLINE(OrderNo,nrol.linenum,OLR)
			goto ELDLine
		Endif
		If not(stk) and not(nonStk) ! has to be one or the other!
			E$="NO LINE TYPE PASSED"
			goto UDLDone
		Endif
		! if olr>0 goto bptest else goto udldone  ! REMOVE WHEN READY!
		nrol.Status=11;Credit=0
		if ros.Status=32 let nrol.Status=12;Credit=1 ! determine order/credit?
		nrol.OrdNum=OrderNo
		Call DXGet("DESC1",tmp$) ! +Str$(X1),tmp$)
		strgok=chkbadchars(e$,tmp$)
		if not(strgok)
			returnstatus=0
			Message$="Invalid Characters in Description 1"
			goto UDLDone
		Endif
		nrol.Desc1$=tmp$+Blank$
		Call DXGet("DESC2",tmp$) ! +Str$(X1),tmp$)
		strgok=chkbadchars(e$,tmp$)
		if not(strgok)
			returnstatus=0
			Message$="Invalid Characters in Description 2"
			goto UDLDone
		Endif
		nrol.Desc2$=tmp$+Blank$
		Call DXGet("WHSE",tmp$) ! +Str$(X1),tmp$)
		nrol.whse=tmp$ \ if nrol.whse<1 or nrol.whse>99 let nrol.whse=roh.wh
		if roh.OrdType=16 let nrol.whse=roh.wh ! CANNOT CHANGE WHSE!!
		if kit and nrol.whse<>rol.whse let kitchg=1
		nrol.LineType=0
		If ZLine ! that's all folks
			let nrol.linetype=3
			nrol.ProdCode$="Z"+Blank$
			nrol.PSlsCat=20
			nrol.ComdtyCode$="MISC"
			Goto SLUChk
		Endif
		Call DXGet("STKUPDT",tmp$) ! +Str$(X1),tmp$)
		if ucase$(tmp$)="Y" let tmp$="1"
		if ucase$(tmp$)="N" let tmp$="0"
		X2=0 ! NEVER ON QUOTES ! tmp$ 
		If X2=0 OR X2=1 let nrol.UpdtStk=X2 ! s/b 0 or 1
		if kit and nrol.UpdtStk<>rol.UpdtStk let kitchg=1
		if ACTION$="NSBUILDPROD" and olr>0 and not(rol.updtStk )
			if roh.ordtype<>2
				let nrol.Updtstk=1 ! set to update stock
				!let stk=1;Nonstk=0 ! web could send as NSTK! NO,NO
				if roh.ordtype=3 and P60$[22,22]="N" let nrol.Updtstk=0
			endif
		endif
		Call DXGet("UPRICE",tmp$) ! +Str$(X1),tmp$)
		V3[1]=tmp$
		if v3[1]<0
			returnstatus=0
			message$="NO NEGATIVE PRICE"
			goto UDLDone
		endif
		If V3[1]>9999999
			returnstatus=0
			message$="Price is out of range"
			goto UDLDone
		endif
		If V3[1] and rol.UMPrice>0 and (rol.LineType=1 or rol.LineType=2)
			call DXGet("PARCUTP",tmp$) ! if Cut - use as is (SCREEN SHOWS CUT!)
			if UCase$(Trim$(tmp$))="P"
				if rol.numout>0 let v3[1]=FNC(v3[1]/rol.numout)
			Endif
		Endif
		Call DXGet("UCOST",tmp$) ! +Str$(X1),tmp$)
		V3[2]=tmp$
		if v3[2]<0
			returnstatus=0
			message$="NO NEGATIVE COST"
			goto UDLDone
		endif
		If V3[2]>9999999
			returnstatus=0
			message$="Cost is out of range"
			goto UDLDone
		endif
		if v3[2] and rol.umcost>0 and (rol.LineType=1 or rol.LineType=2)
			call DXget("PARCUTC",tmp$) ! if Cut - use as is (SCREEN SHOWS CUT!)
			if UCase$(Trim$(tmp$))="P"
				if rol.numout>0 let v3[2]=FNC(v3[2]/rol.numout)
			Endif
		Endif
		Call DXGet("LDISC",tmp$) ! +Str$(X1),tmp$)
		nrol.LineDiscPct=tmp$
		Call DXGet("UNCUBE",tmp$) ! +Str$(X1),tmp$)
		nrol.CubeUnit=tmp$ \ if not(nrol.CubeUnit) let nrol.CubeUnit=1
		if nrol.CubeUnit<0 or nrol.cubeunit>99999
			returnstatus=0
			message$="Cube unit is out of range"
			goto UDLDone
		Endif
		Call DXGet("UNLBS",tmp$) ! +Str$(X1),tmp$)
		nrol.LbsUnit=tmp$ \if not(nrol.LbsUnit) let nrol.LbsUnit=1
		if nrol.LbsUnit<0 or nrol.lbsunit>99999
			returnstatus=0
			message$="Pound unit is out of range"
			goto UDLDone
		Endif
		Call DXGet("TAXFLG",tmp$) ! +Str$(X1),tmp$)
		if ucase$(tmp$)="N" let tmp$="0"
		if ucase$(tmp$)="Y" let tmp$="1"
		nrol.TaxFlg=tmp$ ! y/n or code
		if nrol.taxflg<0 
			returnstatus=0
			message$="Tax code is out of range"
			goto UDLDone
		Endif
		Call DXGet("PRODID",tmp$) ! +Str$(X1),tmp$)
		nrol.ProdCode$=UCase$(tmp$)+Blank$
		If Not(nonStk) ! get product now (for um's)
			Prodkey$=" ",prodkey$
			prodkey$=nrol.ProdCode$
			PRR=filegetprod(e$,PRC,"=",1,ProdKey$,pr.)
			clear e$
			If PRR<0 ! not found
				ReturnStatus=0
				Message$="PRODUCT NOT FOUND!"
				clear pr. ! switch to non-stk? bomb?
				Goto UDLDone
			Endif
		Else ! Nonstk
			if not(zline) ! just + items
			  If rol.ProdCode$<>nrol.ProdCode$ ! code changed!? dropped spaces?
				tmp$=orderno using "######"
				tmp$=tmp$+"-"+lineno using "&&&"
				nrol.prodcode$=tmp$+blank$
				IF ROH.OrgOrd ! is a backorder release
					tmp1$=" ",tmp1$
					tmp1$=ROH.OrgOrd using "######"
					tmp1$=tmp1$+"-"+lineno using "&&&"
					tmp1$=tmp1$+blank$
					tmp1$[13]=""
					if RTrim$(rol.prodcode$)<>"" let tmp1$=rol.prodcode$ ! keep original
				Endif
				if roh.OrgOrd1 ! another orig ord
					tmp2$=" ",tmp2$
					tmp2$=ROH.OrgOrd1 using "######"
					tmp2$=tmp2$+"-"+lineno using "&&&"
					tmp2$=tmp2$+Blank$
					tmp2$[13]=""
					if RTrim$(rol.prodcode$)<>"" let tmp2$=rol.prodcode$ ! keep original
				Endif
			  Endif ! nonstocks - web drops leading spaces - re-add them!
			Endif ! nonstocks
		Endif ! stk/nonstk
		If nrol.LineNum>0 and Trim$(rol.ProdCode$)<>"" ! need a product check?
			If rol.ProdCode$<>nrol.ProdCode$ ! what should we do? code changed!?
				IF not(nonstk) let pcchg=1 ! stk item should never change
				if nonstk ! could be a copy from orig order
					if zline ! should be same
						let pcchg=1
					Else ! check if copied from orig order
						pcchg=1 ! changed is default as we know it did change
						if rol.ProdCode$=tmp1$[1,12] let pcchg=0;nrol.ProdCode$=tmp1$
						if rol.ProdCode$=tmp2$[1,12] let pcchg=0;nrol.prodcode$=tmp2$
					Endif
				Endif
				If PCCHg ! did change
					ReturnStatus=0
					Message$="PRODUCT CODE CHANGE ON LINE!"
					goto UDLDone
				Endif
			Endif
		Endif
		call DXGet("DEPT",tmp$) ! +Str$(X1),tmp$)
		nrol.Dept=tmp$
		call DXGet("QTYORD",tmp$) ! +Str$(X1),tmp$)
		let V3[3]=tmp$
		! at start no negative
		x1=roh.ordtype
		if v3[3]<0 and (credit or (x1=4 or x1=7 or x1=8 or x1=15 or x1=16 or x1=24))
			returnstatus=0
			message$="Can not order negative quantity"
			goto UDLDone
		Endif
		If Abs(V3[3])>9999999
			returnstatus=0
			message$="Order Quantity is out of range"
			goto UDLDone
		Endif
		Call DXGet("QTYBO",tmp$) ! +Str$(X1),tmp$)
		Let V3[4]=tmp$
		If Abs(V3[4])>9999999
			returnstatus=0
			message$="Back Order Quantity is out of range"
			goto UDLDone
		Endif
		Call DXGet("QTYSHIP",tmp$) ! +Str$(X1),tmp$)
		Let V3[5]=tmp$
		If V3[3]>0 ! new - no neg bo ever and ot4/15 can do neg release
		  If V3[4]<0 or (roh.ordtype<>4 and roh.ordtype<>15 and V3[5]<0)
			returnstatus=0
			message$="Can not have negative BO/Ship quantities!"
			goto UDLDone
		  Endif
		  IF V3[5]<0 and (roh.ordtype=4 or roh.ordtype=15)
			If nrol.PrevQtyShip<=0 or ABS(V3[5])>nrol.PrevQtyShip
				returnstatus=0
				message$="Negative Ship quantity is invalid!"
				goto udldone
			Endif
		  Endif
		Endif
		if v3[3]<0 and (V3[4]>0 or V3[5]>0)
			returnstatus=0
			message$="Can not have positive Bo/Ship quantities!"
			goto UDLDone
		Endif
		!if v3[5]<0 and V3[5]<>v3[3] let v3[3]=v3[5] ! no ship more than order
		if v3[3]<0 ! always ship ordered on negative
			v3[5]=v3[3];v3[4]=0
		Endif
		If Abs(V3[5])>9999999
			returnstatus=0
			message$="Ship Quantity is out of range"
			goto UDLDone
		Endif
		if roh.ordtype=4 ! order type 4 - needs BILLQTY
			call dxget("CURRBILL",tmp$)
			if rtrim$(tmp$)<>"" ! sent it - otherwise ignore
				V3[10]=tmp$
				if v3[3]<0 and v3[10]>0 ! neg line - pos bill? NO
					returnstatus=0
					message$="Can not have positive Bill quantities!"
					goto UDLDone
				Endif
				if v3[10]<0 ! neg bill allowed
					if nrol.PrevQtyBill<=0 or ABS(v3[10])>nrol.PrevQtyBill
						returnstatus=0
						message$="Negative Bill quantity is invalid!"
						goto udldone
					Endif
				Endif
			Endif ! sent data
			! ON PM Native - it allows overbill with just a prompt
			! check it below (when base)
		Endif ! bill qty - OT4
		! if roh.ordtype=15 let nrol.CurrRelQty=v3[5] ! is relqty
		Call DXGet("PUPCHG",tmp$) ! +Str$(X1),tmp$)
		V3[6]=tmp$
		Call DXGet("PUPTYPE",tmp$) ! +sTR$(X1),tmp$)
		let x$=tmp$
		if x$="$" ! $ is <0  percent is >=0
			let nrol.UpChrg=0-V3[6] ! may need convert
		Else
			let nrol.UpChrg=V3[6]
		Endif
		Call DXGet("UMSELL",tmp$) ! +Str$(X1),tmp$)
		! call programdump("/tmp/ollog10!","")
		! If tmp$[1,1]>"9" ! sent text?
			R=getumrec(e$,CCC,tmp$,IntCo,PR.)
			If R<>0 let tmp$=Str$(R)
		! Endif
		x2=tmp$
		if x2<0 ! NO System UM for QTY
			ReturnStatus=0
			Message$="INVALID U/M - SELL"
			goto UDLDone
		Endif
		if not(nonstk) ! chk u/m
			Flag=ChkPrdUM(e$,X2,IntCo,Pr.)
			if flag=0 ! let x2=pr.UMSellDefault ! unrem / rem below to just change
				ReturnStatus=0
				Message$="INVALID U/M - SELL"
				goto UDLDone
			Endif
		Endif
		let nrol.UMSell=x2 ! tmp$
		if not(nonStk)
			X3=UMtoFactor(nrol.UMSell)
			rol.SellFactor=X3;nrol.SellFactor=x3
		Endif
		Call DXGet("UMPRICE",tmp$) ! +Str$(x1),tmp$)
		! call programdump("/tmp/ollog11!","")
		! If tmp$[1,1]>"9" ! sent text?
			R=getumrec(e$,CCC,tmp$,IntCo,PR.)
			If R<>0 let tmp$=Str$(R)
		! Endif
		x2=tmp$
		if not(nonstk) ! chk u/m
			Flag=ChkPrdUM(e$,X2,IntCo,Pr.)
			if flag=0 ! let x2=pr.UMPriceDefault ! unrem / rem below to just change
				ReturnStatus=0
				Message$="INVALID U/M - PRICE"
				goto UDLDone
			Endif
		Endif
		nrol.umprice=x2 ! tmp$
		if not(nonStk)
				X3=UMtoFactor(nrol.umprice)
				rol.PriceFactor=X3;nrol.PriceFactor=x3
		Endif
		Call DXGet("UMCOST",tmp$) ! +Str$(X1),tmp$)
		! call programdump("/tmp/ollog12!","")
		! If tmp$[1,1]>"9" ! sent text?
			R=getumrec(e$,CCC,tmp$,IntCo,PR.)
			If R<>0 let tmp$=Str$(R)
		! Endif
		x2=tmp$
		if not(nonstk) ! chk u/m
			Flag=ChkPrdUM(e$,X2,IntCo,Pr.)
			if flag=0 ! let x2=pr.UMCostDefault ! unrem / rem below to just change
				ReturnStatus=0
				Message$="INVALID U/M - COST"
				goto UDLDone
			Endif
		Endif
		nrol.UMCost=x2 ! tmp$
		if not(nonStk)
				X3=UMtoFactor(nrol.UMCost)
				rol.CostFactor=X3;nrol.CostFactor=x3
		Endif
		call dxget("VENDITM",tmp$) ! +Str$(X1),tmp$)
		strgok=chkbadchars(e$,tmp$)
		if not(strgok)
			returnstatus=0
			Message$="Invalid Characters in Vendor Item"
			goto UDLDone
		Endif
		nrol.VendItemCode$=ucase$(tmp$)+Blank$
		call dxget("NETPRC",tmp$) ! +Str$(x1),tmp$)
		V3[7]=tmp$ ! nrol.NetPrice
		If V3[7]<0 or Abs(V3[7])>9999999
			returnstatus=0
			message$="Net Price is out of range"
			goto UDLDone
		Endif
		call dxget("PPFLAG",tmp$) ! +Str$(X1),tmp$)
		if ucase$(tmp$)="FALSE" let tmp$="0"
		if ucase$(tmp$)="TRUE" let tmp$="1"
		tmp$="0" ! NOT ON QUOTES?? Y - ONCE AN ORDER - IT STARTS AS 0
		! AND build117 treats all as new perm if run
		nrol.NewPPFlg=tmp$ ! (s/b 0 or 1)
		call dxget("HIDE291",tmp$) ! +Str$(X1),tmp$)
		if ucase$(tmp$)="N" let tmp$="0"
		if ucase$(tmp$)="Y" let tmp$="1"
		if RTrim$(tmp$)<>"" ! only if sent
			X2=Tmp$
			If X2=0 Or X2=1 let nrol.LinePrint=X2
			if nrol.LinePrint=0 ! not printed
				nrol.PrintDate=0
				nrol.PrintTime=0
			Endif
		Endif
		Call dxget("CUPCHG",tmp$) ! +Str$(X1),tmp$)
		V3[8]=tmp$
		call dxget("CUPTYPE",tmp$) ! +Str$(X1),tmp$)
		X$=tmp$
		if x$="$" ! $ is <0  % is >=0
			nrol.LoadUpchrg=0-V3[8]
		Else
			nrol.LoadUpchrg=V3[8]
		Endif
		! call programdump("/tmp/ollog13!","")
		Call dxget("KIT",tmp$)
		if pr.MBFlg$<>"M" let tmp$="N" ! cannot happen
		if credit or nonstk let tmp$="N" ! no kits on these
		if p9$[22,22]="N" let tmp$="N" ! flag says no kits
		if UCase$(RTRIM$(tmp$))<>"" ! forced or user entered
		 ! if nothing passed - ignore it - leave field as is
			If kit ! started off as kit (set at beginning)
				if tmp$="N" ! now is not kit - delete old
					! call to delete
					FChan[1]=ohc;fchan[2]=osc;fchan[3]=otc
					FChan[4]=prc;fchan[5]=pwc;fchan[6]=sltc;fchan[7]=pltc
					fchan[9]=0;fchan[11]=0;fchan[12]=0
					KTC=openfile(1296,Intco)
					if ktc>0
						FChan[8]=ktc
						S9[7]=roh.ordnum;S9[9]=rol.linenum
						call DELQKIT(e$,IntCo,S9[],FChan[])
						clear e$
						Try close #KTC Else Rem
					Endif
					kit=0;kitchg=0 ! clear kit flags
					nrol.KitDesignation$=blank$
				endif
				! if already a kit - it still is
			else ! not a kit
				if tmp$="Y" ! now it is a kit
					kit=1;kitchg=1
					nrol.KitDesignation$="KIT"
					! near end it does kit code
				endif
				! if not a kit - it still is not
			endif
		Endif ! user did not enter or fld not passed
		tmp$="";v3[9]=0
		otok=0 \ if roh.OrdType=2 let otok=1
		if custom_customer$="HTBERRY" and roh.ordtype=25 let otok=1
		if nonstk or otok OR (roh.OrdType=3 and p60$[22,22]="N")
			call dxget("GLCOST",tmp$) !+Str$(X1),tmp$)
			IF roh.OrdType=15 AND roh.boctr let tmp$="" ! billed - no change
			if nonstk or cost_Lev[0]=2
				V3[9]=tmp$
			  if v3[9]<0 or v3[9]>9999999
				returnstatus=0
				message$="GL Cost is out of range"
				goto UDLDone
			  Endif
			Endif
		Endif
		Call dxget("PRCORGN",tmp$) ! price origin
		if Trim$(tmp$)="" let tmp$=Str$(rol.PriceOrigin) ! not sent - retain orig
		x=tmp$
		if x>-18 and x<15 ! with in range
			nrol.PriceOrigin=iNT(x)
		Endif
        if x>82 and x<118 ! with in range
			nrol.PriceOrigin=iNT(x)
		Endif
		call dxget("CSTORGN",tmp$) ! cost origin (if reprice)
		if Trim$(tmp$)="" let tmp$=Str$(rol.CostOrigin) ! not sent - retain orig
		x=tmp$
		if x>-2 and x<12 ! with in range
			nrol.CostOrigin=Int(x)
		Endif
		! also cut data
		If CutLine ! get cutting info
			nrol.linetype=cutline ! set to orig (chg'd elsewhere)
		Endif
		! nonstk data changed elsewhere
		! now the update work starts
		SLUChk: ! start update
		If ZLine ! just move in descs and done!
			If nrol.LineNum=0
				X2=GetNxtLine(orderno)
				nrol.linenum=x2
				nrol.SpareNU3$=blank$
				clear nrol.SpareNu$ ! dl4 fix
				OLR=fileupdateqolz(e$,OLC,"a",rcdno,nrol.)
			Else ! existing line
				Read record #OLC,OLR,0;rol.
				rol.Desc1$=nrol.Desc1$
				rol.Desc2$=nrol.Desc2$
				clear rol.SpareNu$ ! dl4 fix
				Write record #OLC,OLR,0;rol.;
			Endif
			goto eldline ! finished
		Endif ! ALL for zlines
		! if new or changed - need edittrack  NEW=11, CHG=1
		If nrol.linenum=0 ! new line
			nrol.linenum=getnxtline(orderno)
			if p61$[136,136]="Y"
				let nrol.currid=roh.currid
				let nrol.currfact=roh.currfact
				let rol.currid=roh.currid
				let rol.currfact=roh.currfact
			endif
			etr.EtAction=11 ! new
			If not(nonstk) ! need prod for add'l data
				ProdKey$=nrol.ProdCode$+Blank$
				ProdKey$[13]=""
				PRR=filegetprod(e$,PRC,"=",1,prodkey$,pr.)
				clear e$
				If PRR>0
					nrol.PDRecNum=PRR
				Else
					E$="PRODUCT "+nrol.ProdCode$+"NOT FOUND!"
				Endif
				nrol.ComdtyCode$=pr.ComdtyCode$+Blank$
				if roh.ordtype=8 or roh.ordtype=16
				  If Roh.ConsWh>0 and roh.conswh<100
					Let TPWKey$=" ",tpwKey$
					TPWkey$[1,12]=prodKey$+Blank$
					TPWKey$[13]=ROH.ConsWh Using "##"
					call chktowhse(TPWKey$,pr.PrimVend)
				  Endif
				Endif
				Prodkey$=ProdKey$+nrol.Whse Using "##"
				if roh.ordtype=7 let prodkey$[13]=ROH.ConsWh Using "##"
				PWR=filegetprodwhse(e$,PWC,"=",1,Prodkey$,pw.)
				clear e$
				if PWR<0 ! not found
					Clear pw.
					If PWR=-1 ! add on NOF
						E$="";x3=prodkey$[13,14]
						if roh.ordtype=7
							let x3[1]=nrol.whse/100
							x3=x3+x3[1]
						Endif
						Whbld[0]=PWC;Whbld[1]=x3;WhBld[2]=pr.PrimVend
						if x3<>1 let Whbld[1]=x3+.01 ! fra=copy whse 1
						Call mxwhcreate(e$,IntCo,nrol.PRODCode$,WHBLD[])
						PWR=Whbld[2]
						Read record #PWC,PWR,0;PW.;
					Endif
				Endif
				SUM=nrol.UMSell
				rol.qtyord=V3[3]
				call setnewrol() ! set default values
				rol.dept=nrol.dept
			Else ! nonstks - set rol. to nrol. for converts
				rol.UMBase=nrol.UMBase
				rol.UMSell=nrol.UMSell
				rol.UMCost=nrol.UMCost
				rol.UMPrice=nrol.UMPrice
				rol.UMPurch=nrol.UMPurch
				rol.SellFactor=nrol.SellFactor
				rol.PriceFactor=nrol.PriceFactor
				rol.CostFactor=nrol.CostFactor
				rol.PurchFactor=nrol.PurchFactor
				rol.CubeFactor=nrol.CubeFactor
				rol.WgtFactor=nrol.WgtFactor
				PRR=0;PWR=0
				! set up / add nonstk (no UDA entered on ROL line!)
				Nstk.OrdNum=nrol.OrdNum
				nstk.LineNum=nrol.linenum
				!nstk.OrdLineRec not known yet
				nstk.Desc1$=nrol.Desc1$
				nstk.Desc2$=nrol.Desc2$
				nstk.PSlsCat=nrol.PSlsCat
				! nstk.QtyShip  nstk.UnitCost  nstk.UnitPrice
				nrol.ProdCode$=roh.OrdNum Using "######" ! NOT "&&&&&&"
				nrol.ProdCode$=nrol.ProdCode$+"-"+nrol.LineNum Using "&&&"
				nrol.ProdCode$=nrol.ProdCode$+blank$
				nstk.ProdCode$=nrol.ProdCode$
				nstk.ComdtyCode$=nrol.ComdtyCode$
				nstk.Unused$=blank$
				nstk.SpareNu$=blank$;nstk.NS_UDA1=0;nstk.NS_UDA2$=blank$
				nstk.NS_UDA3$=blank$;nstk.NS_UDA4$=blank$;nstk.NS_UDA5$=blank$
				clear nstk.spare$ ! dl4 fix ! nstk.Spare$=blank$
				NSR=fileupdateqproddesc(e$,NSC,"a",0,Nstk.)
				If NSR>0 
					let nrol.PDRecNum=NSR
				Else
					E$="NONSTOCK "+nrol.ProdCode$+" FILE NOT ADDED"
				Endif
			Endif ! of stk/nonstk
			If rol.WgtFactor<=0 Let rol.WgtFactor=1
			if nrol.WgtFactor<=0 let nrol.WgtFactor=1
			rol.LbsUnit=nrol.LbsUnit ! update to current (lb based items)
		Else ! existing line 
			! as setprtorol uses rol. needs a setup to new values
			rol.UMBase=nrol.UMBase
			rol.UMSell=nrol.UMSell
			rol.UMCost=nrol.UMCost
			rol.UMPrice=nrol.UMPrice
			rol.UMPurch=nrol.UMPurch
			rol.SellFactor=nrol.SellFactor
			rol.PriceFactor=nrol.PriceFactor
			rol.CostFactor=nrol.CostFactor
			rol.PurchFactor=nrol.PurchFactor
			rol.CubeFactor=nrol.CubeFactor
			rol.WgtFactor=nrol.WgtFactor
		endif ! of new line
		! so nrol. has new, rol. has orig
		Call setprtorol() ! set to rol. factors
		PR.LbsUnit = nrol.LbsUnit ! Task 45186 
		! convert sent to base as sent in display um
		If p61$[136,136]="Y" and rol.currfact<>0 ! nssave
			if v3[1]<>0 ! unit price
				let cnvcu[0]=2
				let cnvcu[1]=1 ! no rounding 
				let cnvca[0]=v3[1]
				cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[1]=cnvca[0]
			endif
			! convert cost to base
			if v3[2]<>0 ! unit cost
				let cnvcu[0]=2
				let cnvcu[1]=1 ! no rounding 
				let cnvca[0]=v3[2]
				cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[2]=cnvca[0]
			endif
			if v3[6]<0 ! price upcharge $
				let cnvcu[0]=2
				let cnvcu[1]=1 ! no rounding 
				let cnvca[0]=v3[6]
				cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[6]=cnvca[0]
			endif
			if v3[7]<>0 ! net price
				let cnvcu[0]=2
				let cnvcu[1]=1 ! no rounding 
				let cnvca[0]=v3[7]
				cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[7]=cnvca[0]
			endif
			if v3[8]<0 ! cost upcharge $
				let cnvcu[0]=2
				let cnvcu[1]=1 ! no rounding 
				let cnvca[0]=v3[8]
				cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[8]=cnvca[0]
			endif
			if v3[9]<>0 ! gl cost
				let cnvcu[0]=2
				let cnvcu[1]=1 ! no rounding 
				let cnvca[0]=v3[9]
				cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[9]=cnvca[0]
			endif
		endif
		CNVTU[0]=nrol.UMPrice;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
		cnvta=v3[1] \ if nrol.UMPrice>0 and nrol.NumOut>0 let cnvta=v3[1]*nrol.numout
		nrol.UnitPrice=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		CNVTU[0]=nrol.UMPrice;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
		cnvta=v3[7] \ if nrol.UMPrice>0 and nrol.NumOut>0 let cnvta=v3[7]*nrol.numout
		nrol.NetPrice=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if nrol.UpChrg<0 ! $ amount
			CNVTU[0]=nrol.UMPrice;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
			cnvta=V3[6] ! still +
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			let nrol.UpChrg=0-x3
		Endif
		CNVTU[0]=nrol.UMCost;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
		cnvta=V3[2] \ if nrol.UMCost>0 and nrol.NumOut>0 let cnvta=v3[2]*nrol.numout
		nrol.UnitCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if nrol.LoadUpchrg<0 ! it's a $ up
			CNVTU[0]=nrol.UMCost;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
			cnvta=v3[8]
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			nrol.LoadUpchrg=0-X3
		endif
		if v3[9]>0 ! sent glcost
			CNVTU[0]=nrol.UMCost;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
			cnvta=v3[9] \ if nrol.UMCost>0 and nrol.NumOut>0 let cnvta=v3[9]*nrol.numout
			nrol.UnitGLCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		else
			call dxget("GLCOST",tmp$)
			if rtrim$(tmp$)<>""
				if rtrim$(tmp$)="0" or rtrim$(tmp$)="0.0" or rtrim$(tmp$)="0.00"
					let nrol.unitglcost=0
				endif
			endif
		Endif
		CNVTU[0]=nrol.UMSell;Cnvtu[1]=0;Cnvtu[2]=1
		cnvta=V3[3] \ IF nrol.NumOut>0 let CNVTA=v3[3]/nrol.NumOut
		nrol.QtyOrd=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		cnvta=V3[4] \ IF nrol.NumOut>0 let CNVTA=v3[4]/nrol.NumOut
		nrol.QtyBO=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		cnvta=V3[5] \ IF nrol.NumOut>0 let CNVTA=v3[5]/nrol.NumOut
		nrol.QtyShip=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		If roh.ordtype=4 ! Curr Billqty
			cnvta=V3[10] \ if nrol.NumOut>0 let cnvta=v3[10]/nrol.numout
			nrol.CurrBillQty=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		Endif
		if roh.ordtype=15 and roh.boctr=0 and olr>0 ! existing line
			! nrol.qtyord=rol.qtyord ! can't id new line?
			nrol.qtybo=rol.qtybo
			nrol.CurrRelQty=nrol.qtyship ! =rol.qtyship
		Endif
		If roh.ordtype=15 and roh.boctr<>0 ! cannot change qtys,prc/cost,um
			nrol.qtyord=rol.qtyord ! so set them back to previous
			nrol.qtybo=rol.qtybo  ! as no new lines - use rol. vars
			nrol.CurrRelQty=nrol.qtyship ! =rol.qtyship (rel sent as ship)
			nrol.UnitPrice=rol.unitprice
			nrol.netprice=rol.netprice
			nrol.upchrg=rol.upchrg
			nrol.unitcost=rol.unitcost
			nrol.UMPrice=rol.umprice
			nrol.UMCost=rol.umcost
			nrol.UMSell=rol.umsell
			nrol.LoadUpchrg=rol.loadupchrg
			nrol.UnitGLCost=rol.unitglcost
		Endif
		If roh.ordtype=4 ! checks are here
			nrol.CurrRelQty=nrol.qtyship ! release is entered as QtyShip
			! PM Native - allows billing>order-prevbill - just an ok Y/N prompt
			! if nrol.currbillqty>nrol.qtyord-nrol.PrevQtyBill ! popup and ok Y/N
			! I guess the front end handles this as we can't here
			if custom_customer$="MORRISETTE"! ques on this
				nrol.CurrBillQty=nrol.CurrRelQty
			Endif
		Endif
		! all sent cost/price/qty now base
		call dolineextens()
		if roh.OrdType=8 or roh.OrdType=16 ! cons/trans - no price/cost
			nrol.UnitCost=0;nrol.CostOrigin=0;nrol.RebtContract=0
			nrol.UnitPrice=0;nrol.CutChrg=0;nrol.CutCost=0
			nrol.LineDisc=0;nrol.ExtOrdAmt=0;nrol.ExtShipAmt=0
			nrol.LineDiscPct=0;nrol.ExtCutChg=0;nrol.ExtCutCost=0
			nrol.ExtLoadShip=0;nrol.ExtLoadOrd=0;nrol.NetPrice=0
			nrol.TaxAmt=0;nrol.LoadUpchrg=0;nrol.UpChrg=0
		Endif
		If p61$[46,46]="Y" and Credit and roh.shiptype=3 ! price fix - no cost
			nrol.UnitCost=0;nrol.CostOrigin=0;nrol.RebtContract=0
			nrol.CutCost=0;nrol.ExtCutCost=0;nrol.ExtLoadShip=0;nrol.ExtLoadOrd=0
			nrol.LoadUpchrg=0
		Endif
		if custom_customer$="MORRISETTE"
			IF roh.ordtype=4 AND (nrol.CurrRelQty<>0 AND nrol.CurrBillQty=0) ! "CCT 111810 
				LET message$="THERE IS A RELEASE BUT NO BILL AMOUNT"
				returnstatus=0
				goto udldone ! abort update? let's
			ENDIF 
		Endif
		if roh.ordtype=4
			!extensions in subroutine (was qtybo-borel) - native = bo+borel
			if nrol.qtyord<nrol.CurrRelQty+(nrol.QtyBo-nrol.BORelQty)+nrol.PrevQtyShip
				returnstatus=0
				message$="Quantity is over shipped"
				goto UDLDone ! abort update? let's
			Endif
		Endif
		if roh.ordtype=15
			!extensions in subroutine (was qtybo-borel) - native = bo+borel
			!if nrol.qtyord<>nrol.CurrRelQty+(nrol.QtyBo+nrol.BORelQty)+nrol.PrevQtyShip
			if nrol.qtyord<nrol.CurrRelQty+(nrol.QtyBo-nrol.BORelQty)+nrol.PrevQtyShip
				returnstatus=0
				message$="Quantity is Out of Balance"
				goto UDLDone ! abort update? let's
			Endif
		Endif
		BPTEST: ! a bypass for testing
		if nrol.Unitprice<>rol.unitprice 
			let nrol.OrgPriceUnit=rol.unitprice
		Endif
		if nrol.unitcost<>rol.unitcost 
			let nrol.OrgLoadCost=rol.unitcost
			if nrol.costorigin=0 let nrol.CostOrigin=-1 ! manual?
		Endif
		if nrol.netprice<>rol.netprice
			!let nrol.PriceOrigin=-7 ! quick fix - manual price ******
			if rol.priceorigin=0 let nrol.PriceOrigin=-7 ! make sure it's set!
		Endif
		if nrol.whse<>rol.whse let nrol.OrgWhse=rol.whse
		If ETr.EtAction=0 ! no check yet
			
			!if nrol.UnitPrice<>rol.UnitPrice let ETr.EtAction=1;HFlg[4]=1 ! prc chg/hold
			!if nrol.unitcost<>rol.unitCost let ETr.EtAction=1;Hflg[5]=1 ! cost chg/hold
			If nrol.UnitPrice <> rol.UnitPrice ! diff - but is it rounding?
			  If FNC(nrol.UnitPrice) <> FNC(rol.UnitPrice)
				Let etr.EtAction = 23
				! If rtrim$(holdpswd$[5])<>"" HFlag[4] = 1
			  End if
			endif
			If nrol.UnitCost <> rol.UnitCost ! diff - rounding?
			  If FNC(nrol.UnitCost) <> FNC(rol.UnitCost) ! compare to 4 dec
				Let etr.EtAction = 24
				! If rtrim$(holdpswd$[6])<>"" HFlag[5] = 1 !
			  Endif
			endif
			If nrol.netprice<>rol.netprice ! diff - chk rounding
			  If FNC(nrol.netprice)<>FNC(rol.netprice) ! 4 dec 
				let etr.etaction=23
				! If rtrim$(holdpswd$[5])<>"" hflag[4]=1 
			  Endif
			endif
				! qty change overrides price/cost change
				if nrol.Qtyord<>rol.QtyOrd let ETr.EtAction=1
				if nrol.QtyBO<>rol.QtyBo let ETr.EtAction=1
				if nrol.QtyShip<>rol.QtyShip let ETr.EtAction=1
			Endif
		if KIT and nrol.QtyShip<>rol.QtyShip let KITCHG=1
		!If P60$[44,44]="Y" and etr.EtAction<>0
		!	call edttrkdo(rol.,nrol.) ! org, new
		!Endif ! of edit tracking
		if not(nonstk)
		  IF P9$[2,2]="D" AND P9$[20,20]<>"F" AND pr.MBFlg$="M" 
			IF P9$[22,22]="Y" AND NOT(CREDIT)
				if nrol.LineType=0 and nrol.qtyship>=0 ! only stock items
					if lineno=0 LET nrol.KitDesignation$="KIT" ! only NEW LINES
				Endif
			Endif
		  Endif
		  if nrol.KitDesignation$="KIT"
		    let kit=1
			if kit and nrol.whse<>rol.whse let kitchg=1
			if kit and nrol.UpdtStk<>rol.UpdtStk let kitchg=1
			if KIT and nrol.QtyShip<>rol.QtyShip let KITCHG=1
			if nrol.KitDesignation$<>rol.KitDesignation$ let kitchg=1
		  Endif
		Endif
		Call ChkWhRasl(e$,intco,Ctlc,WHI,nrol.Whse,RASL[])
		If NonStk
			nrol.PDRecNum=NSR ! non-stk rec #
		Endif
		tmp$=ShipDate Using "&&&&&&"
		Call DateToJulian(1,tmp$,tmp1$,F)
		IF F let tmp1$=""
		JDate[1]=tmp1$;F=0 ! julian sys shipdate
		tmp$=roh.ShipDate Using "&&&&&&"
		if roh.ShipDate<>999999 Call DateToJulian(1,tmp$,tmp1$,F)
		If f let tmp1$=""
		JDate[2]=tmp1$ ! julian ord shipdate
		! call programdump("/tmp/ollog14!","")
		! write back
		nrol.SpareNU3$=blank$
		clear nrol.SpareNu$ ! dl4 fix
		If NewLn ! new line
			OLR=fileupdateqolz(e$,OLC,"a",rcdno,nrol.)
			! If OLR<0 ! will pass e$ to bottom
			! set up for new immediate allocation
			If OLR>0 ! has to have a record!
			  If Not(NonStk)
			   If nrol.UpdtStk
				Atype=0 \ if credit let Atype=1
				FChan[0]=OHC;FChan[1]=OLC;FChan[2]=SLTC;FChan[3]=PLTC
				FRec[0]=OHR;FRec[1]=OLR
				! call Allocordlot(e$,intCo,AType,FChan[],FRec[],Rasl,Status)
			   Endif 
			  Else 
				nstk.OrdLineRec=OLR
				if credit let x=-1 else let x=1
				cnvtu[0]=0;cnvtu[1]=nrol.UMSell;cnvtu[2]=1
				cnvta=nrol.QtyShip
				Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				nstk.QtyShip=(Amount*x) ! store credits as neg (IN SELL UM!)
				cnvtu[0]=0;cnvtu[1]=nrol.UMSell;cnvtu[2]=2
				Cnvta=nrol.UnitCost
				Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				nstk.UnitCost=Amount ! nrol.UnitCost (SAYS IN sELL UM)
				cnvtu[0]=0;cnvtu[1]=nrol.UMSell;cnvtu[2]=2
				Cnvta=nrol.UnitPrice
				Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				nstk.UnitPrice=Amount ! nrol.UnitPrice (IN SELL UM!)
				nstk.ExtShipAmt=(nrol.ExtShipAmt*x) ! store credits as neg
				Write record #NSC,NSR,0;nstk.;
			  Endif
			Endif
		Else ! existing line
			Write record #OLC,OLR,0;nrol.;
			if Not(nonStk) ! NO WRITE OCCURS
			  If Not(Credit) and rol.UpdtStk ! back out prev qty ord from prod & whse
				Read record #PRC,PRR,0;PR.
				If PWR>0 Read Record #PWC,PWR,0;pw.
				X3=ROL.QtyShip
				if roh.OrdType=4 or roh.OrdType=15 or roh.ordtype=19 let x3=rol.QtyOrd-rol.PrevQtyShip-rol.QtyBO
				if custom_customer$="MORRISETTE"
					If roh.OrdType=4 Let X3=ROL.QtyShip ! "cct 129415 - only commit shipping qty
				Endif
				IF roh.OrdType=15 AND roh.BOCTR<>0 LET x3=0        
				IF roh.OrdType=15 AND roh.BOCTR=0 LET x3=rol.QtyOrd
				pr.QtyOnOrd=pr.QtyOnOrd-X3
				pw.QtyOnOrd=pw.QtyOnOrd-x3
				IF JDATE[1]>=JDATE[2]
					LET pr.Lvl1Qty=pr.Lvl1Qty-x3
					Let pw.Lvl1Qty=pw.Lvl1Qty-x3
				ELSE
					LET pr.Lvl2Qty=pr.Lvl2Qty-x3
					Let pw.Lvl2Qty=pw.Lvl2Qty-x3
				Endif
				if pr.CatchwgtItem$="Y"
					X=1 \ if rol.QtyOrd<0 let x=-1 ! neg ord/ship (wgt always +)
					IF roh.OrdType=15 AND roh.BOCTR<>0 LET x=0 ! NO QTY
					pr.LbsOnOrder=pr.LbsOnOrder-(rol.ExtNetWgt*x)
					pw.LbsOnOrder=pw.LbsOnOrder-(rol.ExtNetWgt*x)
				Endif
				!Write Record #PRC,PRR,0;PR.;
				!If PWR>0 Write Record #PWC,PWR,0;pw.;
			  Endif ! of updatestk
			Else ! is non-stk & existing line
				X=1 \ if credit let x=-1
				cnvtu[0]=0;cnvtu[1]=nrol.UMSell;cnvtu[2]=1
				cnvta=nrol.QtyShip
				Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				nstk.QtyShip=(Amount*x) ! store credits as neg (IN SELL UM!)
				cnvtu[0]=0;cnvtu[1]=nrol.UMSell;cnvtu[2]=2
				Cnvta=nrol.UnitCost
				Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				nstk.UnitCost=Amount ! nrol.UnitCost (SAYS IN sELL UM)
				cnvtu[0]=0;cnvtu[1]=nrol.UMSell;cnvtu[2]=2
				Cnvta=nrol.UnitPrice
				Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				nstk.UnitPrice=Amount ! nrol.UnitPrice (IN SELL UM!)
				nstk.ExtShipAmt=(nrol.ExtShipAmt*x) ! credits stored as neg
				Write record #NSC,NSR,0;nstk.;
			Endif ! existing
		Endif ! new / existing
		! add qtyord to prod & Whse
		if Not(nonStk) and Not(Credit) and nrol.UpdtStk ! add NEW qty ord to prod & whse
			Read record #PRC,PRR,0;PR.
			! in case whse change - get whse again
			tmp$=" ",tmp$
			tmp$=pr.prodcode$+nrol.whse using "##"
			if roh.ordtype=7 let tmp$=pr.prodcode$+roh.ConsWh using "##"
			PWR=filegetprodwhse(e$,pwc,"=",1,tmp$,pw.,1)! get and LOCK
			clear e$
			If PWR<0 ! search error
			  Clear pw.
			  if PWR=-1 ! new whse not found - add it now
				E$="";x3=tmp$[13,14] ! CLEAR NOF msg
				if roh.ordtype=7
					x3[1]=nrol.whse/100
					x3=x3+x3[1]
				Endif
				Whbld[0]=PWC;Whbld[1]=x3;WhBld[2]=pr.PrimVend
				if x3<>1 let Whbld[1]=x3+.01 ! fra=copy whse 1
				Call mxwhcreate(e$,IntCo,pr.PRODCode$,WHBLD[])
				PWR=Whbld[2]
				Read Record #PWC,PWR,0;pw.
			  Endif
			Endif
			X3=NROL.QtyShip
			if roh.OrdType=4 or roh.OrdType=15 or roh.ordtype=19 let x3=nrol.QtyOrd-nrol.PrevQtyShip-nrol.QtyBO
			if custom_customer$="MORRISETTE"
				If roh.OrdType=4 Let X3=NROL.QtyShip ! "cct 129415 - only commit shipping qty
			Endif
			IF roh.OrdType=15 AND roh.BOCTR<>0 LET x3=0        
			IF roh.OrdType=15 AND roh.BOCTR=0 LET x3=nrol.QtyOrd
			pr.QtyOnOrd=pr.QtyOnOrd+X3
			pw.QtyOnOrd=pw.QtyOnOrd+x3
			IF JDATE[1]>=JDATE[2]
				LET pr.Lvl1Qty=pr.Lvl1Qty+x3
				Let pw.Lvl1Qty=pw.Lvl1Qty+x3
			ELSE
				LET pr.Lvl2Qty=pr.Lvl2Qty+x3
				Let pw.Lvl2Qty=pw.Lvl2Qty+x3
			Endif
			if pr.CatchwgtItem$="Y"
				X=1 \ if nrol.QtyOrd<0 let x=-1 ! neg ord/ship (wgt always +)
				IF roh.OrdType=15 AND roh.BOCTR<>0 LET x=0 ! NO QTY
				pr.LbsOnOrder=pr.LbsOnOrder+(nrol.ExtNetWgt*x)
				pw.LbsOnOrder=pw.LbsOnOrder+(nrol.ExtNetWgt*x)
			Endif
			!Write Record #PRC,PRR,0;PR.;
			!If PWR>0 Write Record #PWC,PWR,0;pw.;
			!IF PW.QtyOnHand-pw.QtyOnOrd<0 LET HFlag[2]=1 ! OOS hold
			!If pr.QtyOnHand-pr.QtyOnOrd<0 LET HFlag[2]=1
		Endif
		ELDLine: ! end of line load
		If E$<>"" ! had an issue
			message$=message$+e$
			ReturnStatus=0
			goto UDLDone
		Endif
		if delline goto UDLDone
	! Next X1 ! process next line sent (was for multiple
	! now any post update work starts
	iF not(roh.HoldOver)
		If HFlag[2] Let HFlg[2]=chkhldcode(2)
		If HFlag[4] let HFlg[4]=chkhldcode(4)
		If HFlag[5] let HFlg[5]=chkhldcode(5)
		
		LET X3=0 ! repack holds                               
		FOR CTR=0 TO 11                         
			IF HFlg[CTR] LET X3=X3+2^CTR            
		NEXT CTR                                
		LET rot.HoldCode=0 ! =X3  NO HOLDS ON QUOTES
		if p61$[106,106]="Y" let rot.holdcode=x3 ! keeps holds
		IF (Credit) LET rot.HoldCode=0
		if roh.ordtype=16 let rot.HoldCode=0
		WRITE Record #otc,roh.TotRec,0;rot.;
	Endif
	! set for mxrasl
	! was after all lines processed - now is single line? do whole order rasl on every line?
	if Not(nonStk) and olr>0 ! don't bother on zline or nonstk line
		S9[2]=OHR;S9[3]=0;S9[4]=208 ! determine program #?
		If credit let S9[3]=4;S9[4]=243 ! credit
		S9[12]=OLR ! PASS THE LINE JUST UPDATED (new single line mxrasl5)?
		FChan[0]=1;FChan[1]=PRC;FCHan[2]=OHC;FChan[3]=OLC
		FChan[4]=0;FChan[5]=ccc;FChan[6]=PLTC;FChan[7]=0
		FChan[8]=SLTC;FChan[9]=0
		! Call dxsave(0,"/tmp/jcs.txt!")
		! Call "MXRASL5.DL4",intco,Ctlc,S9[],FChan[]
	Endif

	UDLDone: ! send status back
	if returnstatus=1 let message$="OK" ! set if no other problems
	if debugdetail
		dmsg$="Update Line "+Str$(rol.OrdNum)+"-"+Str$(rol.LineNum)+" "+rol.ProdCode$+Message$ \ Call updatelog(debug)
	Endif
	IF ACTION$="NSBUILDPROD"
		exit sub ! do not create status section
	endif
	if kit and returnstatus=1 ! ok
		if kitchg ! something changed
			returnstatus=2 ! ok - but kit screen needed
			message$="KITSCREEN"
		Endif
	Endif
	clear list$[]
	List$[0]=bsdel$,"OrderSubmit",fdel$
	WebStr$="OrderId",fdel$
	Webstr$=webstr$,"",fdel$
	webstr$=webstr$,"ORDERAMT",fdel$
	webstr$=webstr$,"ORDERCOST",fdel$
	List$[1]=WebStr$
	WebStr$=str$(orderid),fdel$
	Webstr$=webstr$,"",fdel$
	webstr$=webstr$,str$(rot.mdseordamt),fdel$
	webstr$=webstr$,str$(rot.totordcost),fdel$
	LIST$[2]=Webstr$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	
 else
    include "src/callsuberr.inc"
 end try
end sub ! UpdtLines
! 
!--------------------------------------------------------------------
Function getnxtline(OrderNum)
! get first available order line number
 Try
	Dim OLK$[60]
	Dim 3%,LRec,NRec

	Dim CRol. as qol ! do not use rol. or nrol.!(would overwrite)
	dim cnstk. as qproddesc ! pm also checks nonstk file
	
	
	X2=1
	CHKNXTLN: ! loop til not found (get first available line)
	OLK$=" ",OLK$
	OLK$[1,6]=OrderNum Using "######"
	OLK$[7,9]=X2 Using "###"
	OLK$[11]="" ! cut to length
	LRec=filegetqolz(e$,OLC,"=",1,OLK$,crol.)
	clear e$
	If LRec>0 ! found a line with same number
		x2=x2+1
		if x2>999 Error 10000 ! bomb it!
		goto chknxtln
	Endif ! not found - check sproddesc
	NRec=filegetqproddesc(e$,NSC,"=",1,OLK$,cnstk.)
	clear e$
	If NRec>0 ! found a line with same number
		x2=x2+1
		if x2>999 Error 10000 ! bomb it!
		goto chknxtln
	Endif ! not found - drop thru and send back
	e$="" ! clear any not found messg
	if debugdetail
		dmsg$="Get new Line No "+Str$(rol.OrdNum)+"-"+Str$(X2) \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
  end try
end Function X2 ! getnxtline
! 
!--------------------------------------------------------------------
Sub DELOLINE(ordnum,linenum,OLR)
! delete an order line
 Try
	! all passed from UpdtLines(only place to delete!)
	! ALSO NEEDS EDITTRACK ACTION=2 (DELETE)
	! OLR MAY BE ZERO - SO see if actually there first (and nonstocks)
	! Dim ETR. as edittrack
	! Dim NRol. as qol ! store new sent data

	RTC=OpenFile(9937,IntCo) \ if RTC = -1 Let RTC=0 ! Error 42  ! QOLTAG
	! SLTC=OpenFile(2320,IntCo) \ if SLTC = -1 Error 42
	Dim PLot. as sprodlot
	Dim SLot. as sordlot
	Dim crol. as qol
	Dim rtg. as qoltag

	Dim SLKey$[60],PLKey$[60],PWKey$[60],RTKey$[60]
	Dim SLKey2$[60],SLKey1$[60]
	Dim 1%,L3[3],2%,H0[12],L4[3],3%
	
	Read #ctlc,3,188;ShipDate; ! for inv levels
	if debugdetail
		dmsg$="Delete Line "+Str$(OrdNum)+"-"+Str$(LineNum) \ Call updatelog(debug)
	Endif
	if roh.ordtype=15 and roh.boctr<>0 ! cannot delete
		returnstatus=0
		message$="Cannot delete the line off order if invoiced"
		Exit sub
	Endif
	tmp$=ShipDate Using "&&&&&&"
	Call DateToJulian(1,tmp$,tmp1$,F)
	IF F let tmp1$=""
	JDate[1]=tmp1$;F=0 ! julian sys shipdate
	tmp$=roh.ShipDate Using "&&&&&&"
	if roh.ShipDate<>999999 Call DateToJulian(1,tmp$,tmp1$,F)
	If f let tmp1$=""
	JDate[2]=tmp1$ ! julian ord shipdate
	If OLR<=0 ! no record, see if there!
		PWKey$=" ",PWKey$
		PWKey$[1,6]=OrdNum Using "######"
		PWKey$[7,9]=LineNum Using "###"
		PWKey$[11]=""
		OLR=filegetqolz(e$,OLC,"=",1,PWKey$,nrol.)
		clear e$
		If OLR<0 exit sub ! NO LINE (New?)
		RTKey$=PWKey$ ! keep line key!
	Endif
	Clear crol. ! would have no org nos!
	Read record #OLC,OLR,0;rol.;
	!if (roh.ordtype=4 or roh.ordtype=15) and (rol.PrevQtyShip<>0 or rol.PrevBill<>0 or rol.PrevRelQty<>0)
	!	returnstatus=0
	!	message$="Line has shipments/releases - Cannot delete"
	!	exit sub
	!Endif ! CAN ALWAYS DELETE QUOTE LINE!!
	!If P60$[44,44]="Y" 
	!		etr.EtAction=2 ! delete
	!		Clear crol.
	!		Call EdtTrkDo(crol.,rol.) ! org, new
	!Endif ! of edit tracking
	! back out of sord/sprodlot
	Nonstk=rol.NStkItem
	if Not(nonStk) and rol.UpdtStk ! back out prev qty ord from prod & whse
	  If not(credit)  ! credits = no on ord
		PRR=rol.PDRecNum
		Read record #PRC,PRR,0;PR.
		PWKey$=" ",PWKey$
		PWKey$=rol.ProdCode$+rol.Whse Using "##"
		if roh.ordtype=7 let PWKey$=rol.ProdCode$+roh.ConsWh Using "##"
		PWR=filegetprodwhse(e$,PWC,"=",1,Pwkey$,PW.)
		clear e$
		If PWR<0 Clear pw.
		! no add of whse on delete
		X3=ROL.QtyShip
		if roh.OrdType=4 or roh.OrdType=15 or roh.ordtype=19 let x3=rol.QtyOrd-rol.PrevQtyShip-rol.QtyBO
		if custom_customer$="MORRISETTE"
			If roh.OrdType=4 Let X3=ROL.QtyShip ! "cct 129415 - only commit shipping qty
		Endif
		IF roh.OrdType=15 AND roh.BOCTR<>0 LET x3=0        
		IF roh.OrdType=15 AND roh.BOCTR=0 LET x3=rol.QtyOrd
		pr.QtyOnOrd=pr.QtyOnOrd-X3
		pw.QtyOnOrd=pw.QtyOnOrd-x3
		IF JDATE[1]>=JDATE[2]
			LET pr.Lvl1Qty=pr.Lvl1Qty-x3
			Let pw.Lvl1Qty=pw.Lvl1Qty-x3
		ELSE
			LET pr.Lvl2Qty=pr.Lvl2Qty-x3
			Let pw.Lvl2Qty=pw.Lvl2Qty-x3
		Endif
		if pr.CatchwgtItem$="Y"
			X=1 \ if rol.QtyOrd<0 let x=-1 ! neg ord/ship (wgt always +)
			IF roh.OrdType=15 AND roh.BOCTR<>0 LET x=0 ! NO QTY
			pr.LbsOnOrder=pr.LbsOnOrder-(rol.ExtNetWgt*x)
			pw.LbsOnOrder=pw.LbsOnOrder-(rol.ExtNetWgt*x)
		Endif
		If pr.QtyOnOrd<0 Let pr.QtyOnOrd=0
		If pw.QtyOnOrd<0 let pw.QtyOnOrd=0
		If pr.LbsOnOrder<0 Let pr.LbsOnOrder=0
		If pw.LbsOnOrder<0 Let pw.LbsOnOrder=0
		!Write Record #PRC,PRR,0;PR.;
		!IF PWR>0 Write Record #PWC,PWR,0;pw.; ! in case not found
	  Endif ! of update on order
		! now sord/sprodlot
		Goto NOSTKQTE1
		SLKey$=" ",SLKey$
		SLKey$[1,6]=roh.OrdNum Using "######"
		SLKey$[7,9]=rol.LineNum Using "###"
		tmp$=SLKey$
		Do
			SLTR=filegetsordlotz(e$,SLTC,">",3,SLKey$,slot.)
			clear e$
			If SLTR<0 Exit do
			If SLKey$[1,9]<>tmp$[1,9] exit do
			Whse=slot.Whse
			PLKey$=" ",PLKey$
			PLKey$[1,2]=Whse Using "##"
			PLkey$[3,8]=SLKey$[12,17] ! location
			PLKey$[9,32]=Slot.ProdCode$,Slot.LotNum$
			! PLKey$[33]="" ! Cutting @ stock? (not for struct type!)
			PLKey$[43]="" ! length=42
			PLTR=filegetsprodlot(e$,PLTC,"=",3,PLKey$,plot.)
			clear e$
			If PLTR>0
				LET plot.QtyAlloc=plot.QtyAlloc-slot.QtyAlloc ! WAS S3                                     
				LET plot.QtyBO=plot.QtyBO-slot.QtyOnBO                                                      
				IF plot.QtyBO<0 LET plot.QtyBO=0                                                       
				IF plot.QtyAlloc<0 LET plot.QtyAlloc=0
				WRITE RECORD #pltc,pltr,0;plot.; 
			Endif
			! now delete sordlot
			slot.NU$=Blank$ ! make sure blank for key
			Write record #SLTC,SLTR,0;slot.;
			X3=fileupdatesordlotz(e$,sltc,"d",SLTR,slot.) ! delete sordlot
			! If X3<0 ! error on delete
		Loop
		NoStkQte1: ! NO LOTS or ON ORD for qUOTES
	Endif ! of stk & updatestk
	If NonStk and rol.LineType<>3 ! delete sproddesc (zline none)
		NSR=rol.PDRecNum ! record
		Read Record #NSC,NSR,0;nstk.;
		X3=fileupdateqproddesc(e$,nsc,"d",nsr,nstk.) ! delete sproddesc
		! if x3<0 ! problem deleting
	Endif

	! also delete kits, serial nos, catchwgts, etc
	if rol.KitDesignation$="KIT"
		FChan[1]=ohc;fchan[2]=osc;fchan[3]=otc
		FChan[4]=prc;fchan[5]=pwc;fchan[6]=sltc;fchan[7]=pltc
		fchan[9]=0;fchan[11]=0;fchan[12]=0
		KTC=openfile(1296,Intco)
		if ktc>0
			FChan[8]=ktc
			S9[7]=roh.ordnum;S9[9]=rol.linenum
			call DELQKIT(e$,IntCo,S9[],FChan[])
			e$=""
			Try close #KTC Else Rem
		Endif
	Endif
	! quote management screen (uses old vars)
	Mat read #ohc,ohr,0;H0;
	Mat Read #OLC,OLR,8;L3;
	Mat read #OLC,OLR,16;L4;
	Let R[0]=-199 ! Flag to delete
	Call "QVENDSCRN",R[],h0[],l3[],l4[],Intco ! "quote management
	! as done in mx281e, 287
	If RTC>0 ! roltag file opened
		RTKey$=" ",RTKey$
		RTkey$[1,6]=rol.OrdNum using "######"
		RTKey$[7,9]=rol.LineNum using "###"
		RTKey$[11]="" ! space
		RTR=filegetqoltag(e$,RTC,"=",1,RTKey$,rtg.)
		clear e$
		If RTR>0
			if rtg.Blankforkey$="" ! CANNOT BE NULL (from UB- causes SE)
				rtg.Blankforkey$=" "
				write record #RTC,RTR,0;rtg.;
			Endif
			X3=fileupdateqoltag(e$,RTC,"d",RTR,rtg.)
		Else
			e$=""
		Endif
	Endif
	call DELCQLP() ! delete Quote Last Price recs (before line delete)

	! finally delete the line
	X3=fileupdateqolz(e$,OLC,"d",OLR,rol.)
	! if x3<0 ! problem with delete	
	if debugdetail
		dmsg$="Line "+Str$(rol.OrdNum)+"-"+Str$(rol.LineNum)+" Deleted "+e$ \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
 end try
end sub ! DELOLINE
! 
!--------------------------------------------------------------------
Function Chkhldcode(hldnum)
! pass in hold code
! pass back 0=not used, 1=used
 Try
	Dim f1$[16],Htmp$[16]
	let x1=hldnum
	x=0
	LET F1$=" ",F1$
	READ #ctlc,66,((X1*16)-16);F1$[1,16];
	HTmp$=Trim$(F1$)
	IF HTmp$[1,1]>"" let x=1 ! yes 
	IF QUOTE OR CREDIT X=0
	if debugdetail
		dmsg$="Hold chk "+Str$(hldnum)+" "+Str$(x) \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
 end try
end Function x ! Chkhldcode
! 
!--------------------------------------------------------------------
Sub EdtTrkDo(oorl. as qol, corl. as qol)
! roh. and rot. read PREVIOUSLY  - QUOTES DON'T TRACK
! Have etr.etaction SET UP ALREADY
! oorl. = Original rol data
! corl. = Current/new rol data (CANNOT BE CLEAR!)
 Try
	If Quote EXIT SUB ! no edittrack on quotes
	If etr.EtAction=0 EXIT SUB ! no action
	fChan[0]=-1;fchan[1]=-1 ! no files open - etrack/usercntrl
	etr.OrdNum=corl.OrdNum
	etr.LineNum=corl.LineNum
	etr.Status=roh.OrgStatus \ IF etr.Status<=0 let etr.Status=roh.Status
	etr.ProdCode$=corl.ProdCode$
	etr.OrgQtyOrd=oorl.Qtyord;etr.NewQtyOrd=corl.QtyOrd
	etr.OrgQtyShip=oorl.QtyShip;etr.NewQtyShip=corl.QtyShip
	etr.OrgQtyBO=oorl.QtyBo;etr.NewQtyBO=corl.QtyBO
	e$=""
	! date,time,port,access gotten in call
	etr.AccessCode$=Userid$+Blank$
	etr.UMSell=corl.UMSell
	etr.NstkFlag=corl.NStkItem
	etr.OrgOrdTot=rot.OrdTot
	etr.CustNum=roh.CustNum
	etr.InvNum=roh.InvNum
	etr.Slsm=roh.SlsmNum
	etr.OrgUnitPrice=oorl.UnitPrice
	etr.NewUnitPrice=corl.UnitPrice
	etr.UMPrice=corl.UMPrice
	etr.UMCost=corl.UMCost
	etr.OrgLoadCost=oorl.UnitCost
	etr.NewLoadCost=corl.UnitCost
	etr.UnitNetWgt=corl.LbsUnit
	etr.NetWgtFact=corl.WgtFactor
	etr.SpareNU$=Blank$
	if etr.etaction=11 or etr.etaction=2 ! add SET ORIG=NEW/cURR on ADD or DELETE
		etr.OrgQtyOrd=etr.NewQtyOrd
		etr.OrgQtyShip=etr.NewQtyShip
		etr.OrgQtyBO=etr.NewQtyBO
		etr.OrgUnitPrice=etr.NewUnitPrice
		etr.OrgLoadCost=etr.NewLoadCost
	Endif	
	Call MakeEdittrack(e$,IntCo,fchan[],etr.)
	if debugdetail
		dmsg$="Edittrack "+Str$(etr.OrdNum)+"-"+Str$(etr.LineNum)+" "+Str$(etr.EtAction)+e$ \ Call updatelog(debug)
	Endif
	e$=""
 else
    include "src/callsuberr.inc"
 end try
end sub ! EdtTrkDo
! 
!--------------------------------------------------------------------
Sub updatelog(debug)                                        
    If not(debug) Exit Sub                                    
	System "echo ''" + msc$(0) + " UID "+RTrim$(Userid$)+" " + dmsg$ + "'' >> " + dblog$
End Sub 
! 
!--------------------------------------------------------------------
Sub ChkTOWhse(Tpwkey$,Vendor)
 ! need a check / create of whse going to (OT 8 & 16)
 ! pass in the key to check & Vendor Number
 Try
	dim cpw. as prodwhse ! don't use normal
	dim 1%,TWH
	Dim 3%,TWHBld[5],TPWR
	If tpwkey$[1,1]="" or tpwkey$[1,12]=Blank$[1,12] Exit sub ! NO PROD - NO CHECK
	TWH=tpwkey$[13,14]
	TPWKey$[15]=""
	if TWH>0 and TWH<100 and Not(Fra(TWH)) ! only valid whses
		TPWR=filegetprodwhse(e$,PWC,"=",1,TPWKey$,cpw.)
		clear e$
		If TPWR=-1 ! not found - build it
			TWhbld[0]=PWC;TWhbld[1]=TWH;TWhBld[2]=Vendor
			if TWH<>1 let Whbld[1]=TWH+.01 ! fra=copy whse 1
			Call mxwhcreate(e$,IntCo,TPWKey$[1,12],TWHBLD[])
			IF TWHBLD[2]>0
				if debugdetail
					dmsg$="Build new ConsXfer whse "+tpwkey$ \ Call updatelog(debug)
				Endif
			Else ! error
				if debugdetail
					dmsg$="ERROR "+Str$(TWHBLD[2])+" Build new ConsXfer whse "+tpwkey$ \ Call updatelog(debug)
				Endif
			Endif ! of good build
		Endif ! of no pwhse found
	Endif ! of valid whse
 else
    include "src/callsuberr.inc"
 end try
end sub ! ChkTOWhse
! 
!--------------------------------------------------------------------
Sub getot15list(e$,SList$[],row2,tmpcnt2,Cust,Prod$,SUM)
! send list of ot15's for cust/prod
 Try
	dim croh. as qoh
	dim crol. as qol
	dim TKey$[60],Tkey2$[60]
	tkey$=" ",tkey$
	tkey$[1,6]=Cust Using "######"
	do
		search #OHC,3,2;tkey$,r[2],E
		if e exit do
		X2=TKEY$[1,6] \ IF X2<>Cust Exit do
		read record #OHC,R[2],0;croh.;
		if croh.status>7 goto BPHODone
		if croh.ordtype=15 or (custom_customer$="WHITERIVER" and croh.ordtype=4) ! and croh.OrdNum<>roh.Ordnum
			let tkey2$=" ",tkey2$
			let tkey2$[1,6]=croh.OrdNum using "######"
			do
				search #OLC,3,1;tkey2$,r[3],E
				if e exit do
				x2=tkey2$[1,6] \ if x2<>croh.ordnum exit do
				read record #OLC,R[3],0;crol.;
				if crol.ProdCode$=prod$ ! same - load list
					Webstr$=Prod$,fdel$
					Webstr$=webstr$,str$(CRoh.ordnum)
					if custom_customer$="WHITERIVER" ! add order type
						let webstr$=webstr$," OT ",Str$(croh.ordtype)
					endif
					webstr$=webstr$,fdel$,Str$(crol.LineNum),fdel$
					X3=crol.QtyOrd-crol.QtyShip-crol.PrevQtyShip
					cnvtu[0]=0;cnvtu[1]=SUM;cnvtu[2]=1
					CNVTA=X3
					Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
					Webstr$=WebStr$,LTrim$(Amount using QMask$),fdel$
					tmp$=XUNIT$(SUM,ccc)
					webstr$=webstr$,tmp$,fdel$
					SList$[row2]=webstr$
					row2=row2+1
					If row2>tmpcnt2 let tmpcnt2=expandarray(e$,SList$[])
				Endif
			Loop
		Endif ! of ot15 
	BPHODone: !bypass
	Loop
 else
    include "src/callsuberr.inc"
 end try
end sub ! getot15list
! 
!--------------------------------------------------------------------
sub getsubstlist()
! get a list of substitute items for a product
! output like scan list

 Try
	Dim 1%,OType
	Dim 2%,Whse
	Dim 3%,tmpcnt
	
	Call DXGet("PRODID",tmp$)
	Prod$=UCase$(tmp$)
	Prod$=Prod$+Blank$
	If Len(Prod$)>12 let prod$[13]=""
	Call DXGet("WHSE",tmp$)
	Whse=tmp$
	
	ReturnStatus=1
	Message$="OK"
	If Whse<1 or whse>99 or Fra(whse)
	  ReturnStatus=0
	  Message$="WAREHOUSE NOT PASSED"
	  Goto SubstDone ! needs to be?
	Endif
	ProdKey$=Prod$
	ProdKey$[13]="" ! cut to length
	PRR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.)
	clear e$
	If PRR<=0 ! has to exist!
		ReturnStatus=0
		Message$="PRODUCT NOT FOUND"
		Goto SubstDone ! has to be
	Endif
	Call DXGet("ORDTYPE",tmp$)
	Let OType=tmp$ \ if otype<0 Or OType>38 Let OType=0

	Call SubstIList(e$,IntCo,List$[],maxcnt,ctlc,prc,whc,ccc,Prod$,Whse,OType)
	call AddToStr(e$,rstr$,List$[])
	SubstDone: ! finish Substlist get
	! status section
	if debugdetail
		dmsg$="Substitute List "+prod$+Message$ \ Call updatelog(debug)
	Endif
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
	! 
	! call programdump("/tmp/ollogst!","")
 else
    include "src/callsuberr.inc"
 end try
end sub ! getsubstlist
! 
!--------------------------------------------------------------------
sub getsupsdlist()
! get a list of supersede items for a product
! output like scan list

 Try
	Dim 1%,OType
	Dim 2%,Whse
	Dim 3%,tmpcnt
	
	Call DXGet("PRODID",tmp$)
	Prod$=UCase$(tmp$)
	Prod$=Prod$+Blank$
	If Len(Prod$)>12 let prod$[13]=""
	Call DXGet("WHSE",tmp$)
	Whse=tmp$
	
	ReturnStatus=1
	Message$="OK"
	If Whse<1 or whse>99 or Fra(whse)
	  ReturnStatus=0
	  Message$="WAREHOUSE NOT PASSED"
	  Goto SPRSDDone ! needs to be?
	Endif
	ProdKey$=Prod$
	ProdKey$[13]="" ! cut to length
	PRR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.)
	clear e$
	If PRR<=0 ! has to exist!
		ReturnStatus=0
		Message$="PRODUCT NOT FOUND"
		Goto SPRSDDone ! has to be
	Endif
	Call DXGet("ORDTYPE",tmp$)
	Let OType=tmp$ \ if otype<0 Or OType>38 Let OType=0

	Call SPRCIList(e$,IntCo,List$[],maxcnt,ctlc,prc,whc,ccc,Prod$,Whse,OType)
	call AddToStr(e$,rstr$,List$[])
	SPRSDDone: ! finish supersdlist get
	! status section
	if debugdetail
		dmsg$="Supersede List "+prod$+Message$ \ Call updatelog(debug)
	Endif
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
	! 
	! call programdump("/tmp/ollogsd!","")
 else
    include "src/callsuberr.inc"
 end try
end sub ! getsupsdlist
! 
!--------------------------------------------------------------------
Sub ROLTAG()
! using roltag for zlines - use action1$ for function (GET,DELETE,SAVE)
 Try
	Dim RTKey$[60],UDA$[70],mode$[2]
	Dim 3%,RTR,refno
	Read #ctlc,68,112;uda$;

	Dim RTG. as qoltag
	RTC=OpenFile(9938,IntCo)
	if RTC=-1
		returnstatus=0
		message$="File QOLTAG not found"
		goto RLTDone
	Endif
	Call DXGet("ORDERID",tmp$)
	  if tmp$="" 
		let message$="QUOTE # MISSING"
		Let ReturnStatus=0
		Goto RLTDone:
	  Endif
	  OrderNo=tmp$
	  If OrderNo>0 and OrderNo<=999999 and Not(Fra(OrderNo))
		OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
	  Else
		OHR=-1
	  Endif
	  If OHR<=0 ! no order found
		Let message$="QUOTE # NOT FOUND"
		Let ReturnStatus=0
		Goto RLTDone:
	  Endif
	Call dxget("LN",tmp$) !        
	LineNo = tmp$ ! line # 
	If LineNo <= 0 Or LineNo > 999 Or Fra(lineno)  
		ReturnStatus = 0                                   
		Message$ = "INVALID QUOTE LINE!"  
		goto RLTDone: ! out 
	End If   
	rolkey$ = " ",rolkey$  
		rolkey$[1,6] = orderno Using "######"         
		rolkey$[7,9] = LineNo Using "###"       
		rolkey$[11] = "" ! cut to length (space @ 10) 
		OLR = filegetqolz(e$,OLC,"=",1,rolkey$,rol.)
		clear e$
	if olr<=0
		returnstatus=0
		Message$="Quote Line Not Found"
		goto RLTDone: ! out 
	endif
	! okay order & line exist - now action1
	Select Case Action1$
		case "GET" ! get data for web						doc=OrdL-GetLineTag.doc
			RTKey$=ROLKey$ ! same key as line				
			RTR=filegetqoltag(e$,RTC,"=",1,RTKey$,rtg.) ! hist & ord same layout
			clear e$
			If RTR<=0 ! not found
				clear rtg.
				!let rtg.PONum$=roh.CustPO$ ! default to order po
			Endif
			! send uda names
			Clear List$[]
			List$[0]=bsdel$,"FLDNAMES",fdel$
			List$[1]="FLD1",fdel$,"FLD2",fdel$,"FLD3",fdel$,"FLD4",fdel$,"FLD5",fdel$
			webstr$=RTrim$(UDA$[1,14]),fdel$,RTrim$(UDA$[15,28]),fdel$
			webstr$=webstr$,RTrim$(UDA$[29,42]),fdel$,RTrim$(UDA$[43,56]),fdel$
			webstr$=webstr$,RTrim$(UDA$[57,70]),fdel$
			List$[2]=webstr$
			List$[3]=esdel$
			call addtostr(e$,rstr$,List$[])
			Clear List$[]
			List$[0]=bsdel$,"LINENOTES",fdel$
			tmp$="ORDERID"
			Webstr$=tmp$,fdel$,"LINE",fdel$,"FLD1",FDEL$
			webstr$=webstr$,"FLD2",fdel$,"FLD3",fdel$
			webstr$=webstr$,"FLD4",fdel$,"FLD5",fdel$
			for x=6 to 30 ! now 30 lines!
				tmp$="FLD"+Str$(X)
				webstr$=webstr$,tmp$,fdel$
			Next X
			List$[1]=webstr$
			x3=orderno \ if action2$="HISTORY" let x3=REFNo
			webstr$=Str$(X3),fdel$,Str$(LineNo),fdel$
			webstr$=webstr$,RTrim$(rtg.JobNum$),fdel$,RTrim$(rtg.PONum$),fdel$
			webstr$=webstr$,RTrim$(rtg.PressNum$),fdel$,Rtrim$(rtg.MSGLine1$),fdel$
			webstr$=webstr$,RTrim$(rtg.MSGLine2$),fdel$
			for x=1 to 25 ! send the 25 add'l lines
				x1=(x-1)*30+1
				tmp$=RTrim$(rtg.msgs$[x1,x1+29])
				webstr$=webstr$,tmp$,fdel$
			Next X
			List$[2]=webstr$
			List$[3]=esdel$
			call addtostr(e$,rstr$,List$[])
		case "SUBMIT" ! write to file						doc=OrdL-SubmitLineTag.doc
			RTKey$=ROLKey$ ! same key as line
			RTR=filegetqoltag(e$,RTC,"=",1,RTKey$,rtg.)
			clear e$
			If RTR<=0 
				clear rtg.
				RTR=0
			Else ! existing - check blank for key (NOT NULL!!!)
				if rtg.Blankforkey$="" ! it is - from UB - fill it NOW
					rtg.Blankforkey$=" "
					write record #RTC,RTR,0;rtg.;
				Endif ! not null - ok
			Endif
			rtg.Status=rol.Status
			rtg.OrdNum=Orderno
			rtg.LineNum=LineNo
			call dxget("FLD1",tmp$)
			rtg.JobNum$=tmp$+Blank$
			call dxget("FLD2",tmp$)
			rtg.PONum$=tmp$+Blank$
			call dxget("FLD3",tmp$)
			rtg.PressNum$=tmp$+Blank$
			call dxget("FLD4",tmp$)
			rtg.MSGLine1$=tmp$+Blank$
			call dxget("FLD5",tmp$)
			rtg.MSGLine2$=tmp$+Blank$
			rtg.MSGS$=" ",rtg.MSGS$
			For X=6 to 30 ! 30 total flds
				call dxget("FLD"+str$(x),tmp$)
				tmp$=Rtrim$(tmp$)
				if tmp$<>"" ! sent something
					x1=x-5 ! so is 1 to 25
					x2=(x1-1)*30+1
					rtg.msgs$[x2,x2+29]=tmp$+Blank$
				Endif
			Next X
			rtg.Blankforkey$=" "
			mode$="c" \ if rtr<=0 let mode$="a"
			x3=fileupdateqoltag(e$,RTC,mode$,RTR,rtg.)
			if x3<0 ! problem
				returnstatus=0
				message$="Search Error "+Str$(X3)+" updating roltag file"
			Endif
		case "DELETE" ! delete								doc=OrdL-DeleteLineTag.doc
			RTKey$=ROLKey$ ! same key as line
			RTR=filegetqoltag(e$,RTC,"=",1,RTKey$,rtg.)
			clear e$
			If RTR<=0 goto RLTDone ! no key - no delete
			if rtg.Blankforkey$="" ! it is null - from UB - fill it NOW
				rtg.Blankforkey$=" " ! otherwise "not found"(SE)
				write record #RTC,RTR,0;rtg.;
			Endif ! not null - ok
			mode$="d"
			x3=fileupdateqoltag(e$,RTC,mode$,RTR,rtg.)
			if x3<0 ! problem
				returnstatus=0
				message$="Search Error "+Str$(X3)+" deleting roltag file"
			Endif
	End select
	RLTDone: ! finshed
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
  else
    include "src/callsuberr.inc"
 end try
end sub ! ROLTAG
! 
!--------------------------------------------------------------------
Sub DelCQLP()
! as we can add LP Recs for quotes - delete them with line delete
 Try
	Dim A$[60],Work$[60],LPKey$[60],HoldLP$[60]
	Dim J3$[60],H3$[60],J$[60]
	Dim 2%,LPC1[2],N0
	dim pplog$[60],3%,passinfo[20],permlog[35] ! pass dims to program
	! we only come here if they answered YES to delete
	! go through 3/custquote# getting all custcodes for this quote
	! then gosub del_117: for each customer
	!
	Ch_cq=OpenFile(9937,IntCo) \ if ch_cq=-1 error 42
	trackperm=0! check if they have this feature
	Let work$="2/permpricelog"+Str$(IntCo)
	call findf(work$,trackperm)
	ch_lp=LPC
	N0=OrdNum ! from Deloline
	a$ = " ",a$;work$ = ""
	a$ = n0 using "######"  ! quote#
	loop_cq2: Search #ch_cq,3,1;a$,rec_cq,e 
		if e or val(a$[1,6]) <> n0 GOTO DCQLPDone
		! need to delete lp recs too
		!gosub del_117:
		lpkey$ = " ",lpkey$;holdlp$=" ",holdlp$
		lpkey$[1,6] = a$[7,12]            ! custcode
		x2=rol.dept \ if P9$[44,44]<>"Y" let x2=0
		lpkey$[7,10] = X2 using "####"   ! dept
		lpkey$[11,16] = 0 using "######"  ! frequency-999999
		lpkey$[17,36] = rol.ProdCode$ + "        "  ! prod
		if rol.NStkItem let lpkey$[17,36] = rol.VendItemCode$  ! non-stock
		holdlp$[1,36] = lpkey$[1,36]
		Search #ch_lp,3,3;lpkey$,rec_lp,e 
		if e GOTO Loop_cq2 ! return
		if lpkey$[1,36] = holdlp$[1,36] 
			mat read #ch_lp,rec_lp,16;lpc1;
			if lpc1[1] <> n0 GOTO Loop_cq2 ! return ! make sure the quote# is still here
		else
			GOTO Loop_cq2 ! return
		endif
		! quote matches - delete it
		LET J3$=" ",J3$
		LET J3$[1,6]=lpkey$[1,6]  ! cust
		LET J3$[7,10]=lpkey$[7,10]  ! dept
		LET J3$[11]=lpkey$[17] ! prod +
		SEARCH #ch_lp,5,1;J3$,R1,E ! \ IF E GOSUB Err_Search:
		!
		LET H3$=" ",H3$;H3$=J3$[1,10],J3$[37,40],J3$[11,36]," "
		SEARCH #ch_lp,5,2;H3$,R1,E ! \ IF E GOSUB Err_Search:
		!
		LET H3$=" ",H3$;H3$=lpkey$  ! we used dir 3 above
		SEARCH #ch_lp,5,3;H3$,R1,E ! \ IF E GOSUB Err_Search:
		!
		LET H3$=" ",H3$
		LET H3$[1,10]=J3$[31,40];H3$[11,30]=J3$[11,30]
		LET H3$[31]=J3$[1,10]," "
		SEARCH #ch_lp,5,4;H3$,R1,E ! \ IF E GOSUB Err_Search:
		!
		! if lpdir5 - just try it and ignore SE
			LET h3=" ",h3$;h3$[1,20]=J3$[11,30]
			LET h3$[21,30]=J3$[1,10];h3$[31]=J3$[31]
			SEARCH #ch_lp,5,5;H3$,R1,E ! \ IF E GOSUB Err_Search:
		! end if
		! gosub log_permprice_after:
		if trackperm ! we have this DO BEFORE RECORD RETURN!
			passinfo[0]=ch_lp! do over to be safe
			passinfo[1]=r1 ! lp rec
			passinfo[2]=3 ! delete=flag
			passinfo[3]=13 ! type
			passinfo[4]=SCR ! usrid
			call "logpermprice",intco,pplog$,permlog[],passinfo[],dblog$
		endif
		LET E=3 \ SEARCH #ch_lp,1,0;J3$,R1,E ! \ IF E GOSUB Err_Search:
		! NEEDS SHIPLIST LP?? YES AS BUILD117 DOES!!
		If P61$[64,64] = "Y" ! "ship list last pricing delete
			E = 2 ! delete all shiplists for product
			CUSTNO = J3$[1,6];X2 = 0 ! cust & shiplist
			X1 = 0;J$ = J3$[11,22] ! PRODUCT
			X1[1] = CH_LP;X1[2] = 0;X1[3] = 0 ! Only lp open, no shlp,shiplist
			Call "MX117SLDEL.DL4",CUSTNO,X1,X1,X2,J$,X1[],X1,E,e$,IntCo
		End If 
		!
	goto loop_cq2:
	DCQLPDone: ! finished
	Try Close #ch_cq  Else REM
  else
    include "src/callsuberr.inc"
 end try
end sub ! DelCQLP
! 
!--------------------------------------------------------------------
Sub WHSEAVAIL()
! Separate call to send list of whses with avail
 Try
	dim PWKey$[60],VendKey$[60],OLKey$[60],k1$[60]
	Dim kcm$[50],sum$[4],Pum$[4],Cum$[4],lpkey$[60]
	dim lppum$[4],lpcum$[4],lpsum$[4]
	dim 1%,cnvtu[2],NonStk,ZLine
	Dim 2%,OrderNo,LineNo,Whse,TaxNo,Dept,cwh
	Dim 3%,OLR,CNVTA,Amount,lpr,spr
	READ #CTLC,60,16;CWH; ! start of conswhs
	Call DXGet("ORDERID",tmp$)
	OrderNo=tmp$
	LineNo=0;fleptr[4,1]=0
	If OrderNo>0 ! sent order
		OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
		Call DXGet("LINENO",tmp$)
		LineNo=tmp$
		If OHR<0 ! can't do much with no order!
			Let lineno=0
			clear roh.
			clear ros.
			clear rot.
			ReturnStatus=0
			Message$="ORDER NOT FOUND"
		Endif
		If LineNo>0 ! sent line - get info from it
			OLKey$=" ",OLKey$
			OLKey$[1,6]=roh.OrdNum Using "######"
			OLKey$[7,9]=LineNo Using "###"
			OLKey$[11]="" ! cut at 11 - 10 blank
			OLR=filegetqolz(e$,OLC,"=",1,OLKey$,rol.)
			clear e$
			If OLR<0 
				Clear rol.
				LineNo=0
			Endif ! did not find line
			NonStk = rol.NStkItem
		Endif
	Else ! NEED AN ORDER!
		ReturnStatus=0
		Message$="ORDER NOT PASSED"
	Endif
	If ReturnStatus=1 and OHR>0
		Call GetCust()
	Endif
	if returnstatus=0 goto GWADone ! we'll force a valid order/line
	If LineNo<=0 ! no order found / yet
		clear rol. ! have nothing
		Call DXGet("PRODID",tmp$)
		tmp$=UCase$(tmp$)+Blank$
		Prod$=tmp$[1,12]
		ProdKey$=prod$
		PRR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.)
		clear e$
		If PRR<0 ! no product found
			Clear Pr.
			ReturnStatus=0
			Message$="PRODUCT NOT FOUND"
		Endif
		If PRR>0
			Call DXGet("WHSE",tmp$)
			Whse=tmp$
			if whse>0
				PWKey$=Prod$+Whse using "##"
				PWR=filegetprodwhse(e$,PWC,"=",1,PWKey$,PW.)
				clear e$
				If PWR<0 Clear PW.
			Else
				Clear PW.
			Endif
			! as no line - set up rol. values to use
			rol.QtyOrd=0 ! don't know or need? (need spcl/rbt #)
			SUM=pr.UMSellDefault ! need to pass to setnewrol
			if ordpad ! from order pad - any qty?
				Call DXGet("UM",tmp$)
				if tmp$<>""
					R=getumrec(e$,CCC,tmp$,IntCo,PR.)
					If R<>0 let tmp$=Str$(R)
					Let SUM=tmp$
				Else
					SUM=0
				Endif
				Flag=ChkPrdUM(e$,SUM,IntCo,Pr.)
				If Not(Flag)
					sum=pr.UMSellDefault
				Endif
				call dxget("ORDQTY",tmp$)
				x3=tmp$
				if x3<>0 let SQty=x3
				let cnvtu[0]=SUM;cnvtu[1]=0;cnvtu[2]=1
				let cnvta=SQty
				Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				Let rol.QtyOrd=Int(Amount) ! always integer base - just cut it
			Endif
			Call SETNEWRol() ! set up rol. vars
			rol.dept=Dept ! as passed
			rol.PDRecNum=PRR;rol.whse=whse
		Endif ! Product found
	Endif ! sent line
	prr=rol.PDRecNum
	If returnstatus=0 goto GWADone
	If Not(NonStk) Read record #PRC,prr,0;PR.; ! always read prod!
	If NonStk ! nonstock 
		Clear pr.
	Endif
	call SetPRtoROL() ! set up prod conv vars
	
	Prod$=rol.prodcode$
	whse=rol.whse
	if whse<1 or whse>99 let whse=roh.wh
	! may need set certain prod vars to rol. for  (catchwgt,cwt)
	! first get avl in all whses
	SUM$=XUnit$(rol.umsell,ccc)
	Pum$=XUnit$(rol.umprice,ccc)
	CUm$=XUnit$(rol.umcost,ccc)
	Clear list$[]
	List$[0]=bsdel$,"WHSEAVAIL",fdel$
	webstr$="WHSE",fdel$,"Available",fdel$
	if ordpad let webstr$="WHSE",fdel$,"Available",fdel$,"UM",fdel$,"WHNAME",fdel$
	List$[1]=Webstr$
	Row=2;tmpcnt=maxcnt
	WHAvl=0
	x2[9]=rol.whse \ if roh.ordtype=7 let x2[9]=roh.ConsWh
	If RTrim$(Prod$)<>""
		x2[9]=rol.whse \ if roh.ordtype=7 let x2[9]=roh.ConsWh
		If Not(NonStk) Let WHAvl=getwhavail(e$,intco,PWC,rol.ProdCode$,X2[9])
	Else
		WHAVL=0
	Endif
	cnvtu[0]=0;cnvtu[1]=rol.umsell;cnvtu[2]=1
	cnvta=WHAvl \ if rol.numout>0 let cnvta=whavl*rol.numout
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	WebStr$=Str$(rol.Whse),fdel$
	if ordpad
	  WHIR=X2[9]-1
	  Read record #WHI,WHIR,0;WHI.;
	  tmp$=RTrim$(WHI.WhName$)
	  WebStr$=WebStr$,LTrim$(Amount Using QMask$),fdel$,RTrim$(SUM$),fdel$ ! as deflt sell?
	  webstr$=webstr$,tmp$,fdel$ ! wants wh name
	Else
	  WebStr$=WebStr$,STR$(WHAVL),fdel$ ! as base (don't know if UMSell changed!
	Endif
	List$[row]=WebStr$
	row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	PWKey$=" ",PWKey$
	PWKey$=rol.ProdCode$+Blank$
	PWKey$[15]="" ! cut to length
	Do
		! If NonStk Exit do ! no whse/avl on nonstocks!
		if roh.ordtype=7 exit do ! only one whse!
		If NonStk<>0 ! nonstocks need whse list!!
				maxwhse=CHF(WHI)-1 \ if maxwhse>98 let maxwhse=98
				For I=0 to maxwhse ! CHF(WHC)-1 (99 is the ALLWHSE record)
					if i<>(x2[9]-1)
						read record #WHI,I,0;whi.;
						if rtrim$(whi.WhName$)<>"" !indicates active record in non-indexed file
							WebStr$=Str$(I+1),fdel$ ! whse
							let amount=0 ! nonstock
							WebStr$=WebStr$,Str$(Amount),fdel$ ! available
							if ordpad<>0
								webstr$=webstr$,RTrim$(SUM$),fdel$ ! as sell UM
								webstr$=webstr$,rtrim$(whi.WhName$),fdel$ ! whse, avail
							endif
							List$[row]=webstr$
							row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
						endif
					endif
				next i
			Exit do ! no whse/avl on nonstocks!
		endif	
		PWR=filegetprodwhse(e$,PWC,">",1,PWKey$,PW.)
		clear e$
		If PWR<0 or Pwkey$[1,12]<>rol.prodcode$ exit do
		X2=pwkey$[13,14]
		if roh.ordtype<>8 and x2>=cwh exit do ! no consignments
		If X2<>rol.whse ! already sent line whse #
			If Rtrim$(rol.ProdCode$)<>""
				WHAvl=getwhavail(e$,intco,PWC,rol.ProdCode$,X2)
			Else
				WHAVL=0
			Endif
			! if WHAvl>0 ! don't send zero (less than?) Per DD only avail>0
			 cnvtu[0]=0;cnvtu[1]=rol.umsell;cnvtu[2]=1
			 cnvta=WHAvl \ if rol.numout>0 let cnvta=whavl*rol.numout
			 Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			 WebStr$=Str$(X2),fdel$ ! whse #
			 if ordpad
			   WHIR=X2-1
			   Read record #WHI,WHIR,0;WHI.;
	           tmp$=RTrim$(WHI.WhName$)
			   WebStr$=WebStr$,LTrim$(Amount Using QMask$),fdel$,RTrim$(SUM$),fdel$ ! as sell UM
			   webstr$=webstr$,tmp$,fdel$ ! wants wh name
			 Else
				WebStr$=WebStr$,Str$(WHAVL),fdel$ ! as base qty
			 Endif
			 List$[row]=WebStr$
			 row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
			! Endif ! no zero avl (shorten list)
		Endif
	Loop
	List$[row]=esdel$ ! finished
	GWADone: ! finished
 else
    include "src/callsuberr.inc"
 end try
end sub ! WHSEAVAIL
! 
!--------------------------------------------------------------------
Sub NSFRMLP()
! set up for nonstock from lastprice
 Try
	clear pr.
	clear pw.
	pr.UMSellDefault=clp.UMSell
	pr.UMPriceDefault=clp.UMPrice
	pr.UMCostDefault=clp.UMCost
	pr.VendItem$=clp.VendItemCode$
	pr.Desc1$=clp.LineDesc1$
	pr.Desc2$=clp.LineDesc2$
	pr.ComdtyCode$=clp.ComdtyCode$
	pr.PrimVend=clp.VendNum
	pr.ProdCat=clp.PSCat
	pr.MatCode$=clp.MatCode$
	pr.LbsUnit=clp.UnitWgt
	pr.CubicFeet=clp.UnitCube
	pw.Buyer=clp.Buyer
	pr.BaseUM=clp.UMBase
	pr.UMPurchDefault=clp.UMPurch
	x=2
	clear x2[]
	clear x3[]
	if pr.UMSellDefault and pr.UMSellDefault<>pr.BaseUM
		x2[x]=pr.UMSellDefault;x3[x]=clp.SellUnitFactor
		x=x+1
	Endif
	if pr.UMPriceDefault and pr.UMPriceDefault<>pr.BaseUM 
		x2[x]=pr.UMPriceDefault;x3[x]=clp.PriceUnitFactor
		x=x+1
	Endif
	if pr.UMCostDefault and pr.UMCostDefault<>Pr.BaseUM 
		x2[x]=pr.UMCostDefault;x3[x]=clp.CostUnitFactor
		x=x+1
	Endif
	if pr.UMPurchDefault and pr.UMPurchDefault<>pr.BaseUM
		x2[x]=pr.UMPurchDefault;x3[x]=clp.PurchUnitFactor
		! x=x+1
	Endif
	for x1=2 to x ! start 2 up to 5 max diff um's
		if x2[x1]<>0 ! diff than base
			X2=X2[X1]
			IF pr.UM2=0 ! no um2
				pr.um2=x2;pr.UM2Fact=x3[x1]
			Else ! has 2
				if x2<>pr.um2 ! diff than 2
					if pr.um3=0 ! no um3
						pr.um3=x2;pr.um3fact=x3[x1]
					Else ! has 3
						if x2<>pr.um3
							if pr.um4=0 ! no 4
								pr.um4=x2;pr.um4fact=x3[x1]
							Else ! has 4
								pr.um5=x2;pr.um5fact=x3[x1] ! max 5
							Endif ! of 4
						Endif ! diff 3
					Endif ! of 3
				Endif ! diff 2
			Endif ! of 2
		Endif ! not zero
	Next X1 ! loop
	pr.CubicFtFactor=clp.CubeFactor
	pr.LbsFact=clp.WgtFactor
	! anything else - load rol? nstk?
	clear rol.
	clear nstk.
	! let's load what we can
	! these not loaded by setnewrol
	
	rol.NStkItem=1
	rol.UpdtStk=0
	rol.CubeUnit=PR.CubicFeet
	rol.LbsUnit=pr.LbsUnit
	rol.TaxFlg=0 ! --------- needs setup (below)
	rol.Desc1$=pr.Desc1$
	rol.Desc2$=pr.Desc2$
	rol.ProdCode$=Blank$ ! pr.ProdCode$ (don't know line yet!)
	rol.UMSell=SUM ! as passed!
	if SUM=0 Let rol.UMSell=pr.UMSellDefault
	rol.UMPrice=pr.UMPriceDefault
	rol.UMCost=pr.UMCostDefault
	rol.Vendor=pr.PrimVend ! may chg to whse
	rol.MSDSNo=0
	rol.VendItemCode$=pr.VendItem$ ! cb whse
	rol.UMBase=pr.BaseUM
	rol.UMPurch=pr.UMPurchDefault
	rol.CubeFactor=PR.CubicFtFactor \ if rol.CubeFactor<=0 Let rol.CubeFactor=1
	rol.WgtFactor=pr.LbsFact \ if rol.WgtFactor<=0 Let rol.WgtFactor=1
	rol.CatchWgtItem=pr.CatchWgtItm
	rol.SellFactor=clp.SellUnitFactor ! UMtoFactor(rol.UMSell)
	rol.PriceFactor=clp.PriceUnitFactor ! UMtoFactor(rol.UMPrice)
	rol.CostFactor=clp.CostUnitFactor ! UMtoFactor(rol.UMCost)
	rol.PurchFactor=clp.PurchUnitFactor ! UMtoFactor(rol.UMPurch)
	rol.TaxFlg=clp.TaxCode
	rol.UnitCost=clp.UnitCost
	rol.UnitPrice=clp.UnitPrice
	rol.PriceOrigin=clp.LastPriceType
	rol.UnitGLCost=0 ! not in lp
	rol.NetPrice=rol.UnitPrice ! no upchg in lp - MAKE SAME!
	rol.CostOrigin=clp.LastCostOrg
	rol.LineCost2=clp.LpUnitCost ! loadit
	nstk.OrdNum=roh.OrdNum
	nstk.Desc1$=rol.desc1$
	nstk.Desc2$=rol.Desc2$
	nstk.UnitCost=rol.UnitCost
	nstk.UnitPrice=rol.UnitPrice
	nstk.PSlsCat=pr.ProdCat
	nstk.ComdtyCode$=pr.ComdtyCode$
	nstk.Unused$=blank$
	nstk.Buyer=clp.Buyer
	nstk.HazClass$=blank$ ! no place to get haz info
	nstk.PackGrp$=blank$
	nstk.DotID$=blank$
	nstk.ERGdbk$=blank$
	nstk.SpareNu$=blank$ ! used for key space
	nstk.NS_UDA1=0;nstk.NS_UDA2$=blank$
	nstk.NS_UDA3$=blank$;nstk.NS_UDA4$=blank$;nstk.NS_UDA5$=blank$
	clear nstk.spare$ ! dl4 fix ! nstk.Spare$=blank$
	If p60$[42,42]<>"Y" and p60$[42,42]<>"T" let rol.taxflg=-2 ! tax by line is not set -- need to get tax code
	if rol.taxflg<0
		let prodkey$="Z ZZZZZZZZZZ" ! let's set up tax now-as it's new!
		PRR = filegetprod(e$,PRC,"=",1,Prodkey$,PR.)
		clear e$
		if prr>0
			K1$=roh.CustNum Using "######"
			ProdKey$=nrol.ProdCode$
			ProdKey$=nrol.VendItemCode$ ! as it's stored that way in lastprice
			Call TaxFlag(k1$,ProdKey$,ros.ShipCust,ros.ShipCode,rol.Dept,pr.TaxType,intco,roh.TaxCode,ros.ShipTaxType,Taxback)
			rol.TaxFlg=Taxback ! contains what's needed
			If P60$[42,42]<>"Y" ! has y/n only - get rate from header tax
				TaxNo=roh.TaxCode
			Else ! is a code
				TaxNo=rol.TaxFlg
			Endif
			If TaxNo>0
				Tcc=Openfile(-2176,IntCo) \ if Tcc = -1 Error 42
				Read record #tcc,taxno,0;tax.;
				Close #tcc
			Else ! no taxcode
				clear tax.
			Endif
			rol.TaxPct=tax.TaxRate
		endif
	endif
	! load rest of cnstk at write
 else
    include "src/callsuberr.inc"
 end try
end sub ! NSFRMLP
! 
!--------------------------------------------------------------------
Function Chkkit$()
! see if action needed by web - start with is it there
  try
	dim kflg$[10]
	dim kkey$[60],hkkey$[60]
	kflg$=""
	KTC=OpenFile(-1296,IntCo) \ if ktc=-1 Goto CKDONE ! kit lines
	kkey$=" ",kkey$
	kkey$[1,6]=rol.OrdNum using "######"
	kkey$[7,9]=rol.LineNum using "###"
	hkkey$=kkey$
	search #Ktc,3,1;kkey$,r,e
	if e
		If rol.QtyShip>0 let kflg$="NO KIT"
	Else ! there - right order/line?
		if kkey$[1,9]<>Hkkey$[1,9] ! not this order
			If rol.QtyShip>0 let kflg$="NO KIT"
			goto CKDone
		Endif
		! if other conditions - add below
		if rol.Qtyship<=0
			kflg$="KIT QTY" ! kit exists w/no ship qty
		Endif
	Endif
	CKDone: ! finished
	IF ktc>0
		try close #KTC Else Rem
	Endif
  else
    include "src/callsuberr.inc"
  end try
end Function kflg$ ! Chkkit$
! 
!--------------------------------------------------------------------
Function chktagfle$()
! see if any data for msgline1 in tagfile
  Try
	Dim RTKey$[60],tflg$[1]
	Dim 3%,RTR,refno
	Dim RTG. as qoltag
	tflg$="N"
	RTC=OpenFile(-9938,IntCo)
	if rtc=-1 goto ctfdone
	RTKey$=" ",rtkey$ ! same key as line
	rtkey$[1,6]=roh.OrdNum using "######"
	rtkey$[7,9]=rol.LineNum using "###"
	RTR=filegetqoltag(e$,RTC,"=",1,RTKey$,rtg.) ! hist & ord same layout
	clear e$
	If RTR<=0 ! not found
		tflg$="N"
	Else
		if rtrim$(rtg.MSGLine1$)<>"" let tflg$="Y"
		if rtrim$(rtg.MSGLine2$)<>"" let tflg$="Y"
		if rtrim$(rtg.PONum$)<>"" let tflg$="Y"
		if rtrim$(rtg.JobNum$)<>"" let tflg$="Y"
		if rtrim$(rtg.PressNum$)<>"" let tflg$="Y"
		for x=1 to 25
			x1=(x-1)*30
			let tmp$=rtg.MSGS$[x1+1,x1+30]
			if rtrim$(tmp$)<>"" let tflg$="Y"
		Next X
	Endif
	try close #RTC Else Rem
	Ctfdone: ! finished
	e$=""
  else
    include "src/callsuberr.inc"
  end try
end Function tflg$ ! chktagfle$
! 
!--------------------------------------------------------------------
Sub gpsumm()
! send summary of g/p for lines
  Try
	Dim KOL$[60],KPW$[60],KCM$[50],KLP$[60]
	Dim ZOL$[60]
	Dim 1%,FCDays,cnvtu[2]
	Dim 2%,OrderNo,row,tmpcnt,JDate[5],FDate
	Dim 3%,OLR,FutCost,CNVTA,Amount

	tmpcnt=maxcnt
	if debugdetail
		dmsg$="Start get G/P Summary" \ Call updatelog(debug)
	Endif
	! close rw files - open as ro
	Try close #OHC Else Rem
	Try Close #OSC Else Rem
	Try Close #OTC Else Rem
	Try Close #OLC Else Rem
	OHC = OpenFile(-1280,IntCo) \ if ohc = -1 Error 42 ! order header
	OSC = OpenFile(-1392,IntCo) \ if osc = -1 Error 42 ! order shipto
	OTC = OpenFile(-2656,IntCo) \ if otc = -1 Error 42 ! order totals
	OLC = OpenFile(-1344,IntCo) \ if olc = -1 Error 42 ! order lines
	ReturnStatus=1
	Message$="OK"
	Call DXGet("ORDERID",tmp$)
	X2=tmp$
	If X2<1 or X2>999999 or Fra(X2) ! not valid
		ReturnStatus=0
		Message$="ORDER NOT PASSED"
		goto GGPDone:
	Endif
	OrderNo=x2
	OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
	e$=""
	If OHR<=0 ! not found
		ReturnStatus=0
		Message$="ORDER NOT FOUND"
		goto GGPDone:
	Endif
	! Call GetCust()
	CREDIT=0 \ if ros.status=32 let credit=1
	if credit and roh.ShipType=3 let cost_lev[1]=0 ! no cost on cm price error
	Clear List$[]
		List$[0]=bsdel$,"GPREVIEW",fdel$
		WebStr$="LineNum",fdel$,"ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$
		webstr$=webstr$,"OrdCost",fdel$,"OrdPrice",fdel$,"OrdGPDol",fdel$,"OrdGPPct",fdel$
		webstr$=webstr$,"ShpCost",fdel$,"ShpPrice",fdel$
		webstr$=webstr$,"ShpGPDol",fdel$,"ShpGPPct",fdel$
		List$[1]=webstr$
		Row=2
	! okay - see if lines
	KOL$=" ",KOL$;NumLines=0
	KOL$=OrderNo Using "######"
	! what if start with or only zlines on order??
	Do
		OLR=filegetqolz(e$,OLC,">",1,kol$,rol.)
		clear e$
		If OLR<0 exit do
		X2=kol$[1,6] \ if x2<>orderno exit do
		if (roh.OrdType=21 or roh.OrdType=22) and kol$[7,9]="   " goto bpgpdtl ! ot 21/22
		!x2=kol$[7,9] \ if x2>900 exit do ! as in pm
		NonStk=rol.NStkItem
		ZLine=0 \ if rol.LineType=3 and NonStk let ZLine=1 ! need for later
		! get/read appropriate records (prod,prodwhse,comm,lastprice
		if zline goto bpgpdtl ! no data to send
		!If Not(NonStk) ! it's a prod
		!	PRR=rol.PDRecNum
		!	Read record #PRC,PRR,0;PR.;
		!Else
		!	Clear pr.
		!Endif
		! always set up pr. w/line factors
		LineNo=rol.LineNum
		!Call SetPRtoRol()
		if roh.OrdType=8 or roh.OrdType=16 ! cons/trans - no price/cost
			rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
			rol.UnitPrice=0;rol.CutChrg=0;rol.CutCost=0
			rol.LineDisc=0;rol.ExtOrdAmt=0;rol.ExtShipAmt=0
			rol.LineDiscPct=0;rol.ExtCutChg=0;rol.ExtCutCost=0
			rol.ExtLoadShip=0;rol.ExtLoadOrd=0;rol.NetPrice=0
			rol.TaxAmt=0;rol.LoadUpchrg=0;rol.UpChrg=0
		Endif
		If p61$[46,46]="Y" and Credit and roh.shiptype=3 ! price fix - no cost
			rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
			rol.CutCost=0;rol.ExtCutCost=0;rol.ExtLoadShip=0;rol.ExtLoadOrd=0
			rol.LoadUpchrg=0
		Endif
		If roh.OrdType=37  ! "EVAP Ship - NO Price - any order in here
			If Not(Credit) Or (Credit And roh.ShipType=16)
				Let rol.UnitPrice=0;rol.NetPrice=0;rol.CutChrg=0
				Let rol.LineDisc=0;rol.LineDiscPct=0;rol.UpChrg=0
				rol.ExtOrdAmt=0;rol.ExtShipAmt=0;rol.ExtCutChg=0
			Endif
		Endif
		If roh.OrdType=36 ! "EVAP Billing - NO Cost - Any type order
			If Not(Credit) Or (Credit And roh.ShipType=16)
				Let rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
				Let rol.CutCost=0;rol.ExtCutCost=0;rol.ExtLoadShip=0;rol.ExtLoadOrd=0
				rol.LoadUpchrg=0;Netcost=0
			ENDIF
		Endif
		! load data - NO Conversions needed!
		webstr$=Str$(rol.LineNum),fdel$
		tmp$=clrtxtc$(e$,rol.desc1$) ! chk/clr control chars
		webstr$=webstr$,RTrim$(rol.ProdCode$),fdel$,RTrim$(tmp$),fdel$
		tmp$=clrtxtc$(e$,rol.desc2$) ! chk/clr control chars
		webstr$=webstr$,RTrim$(tmp$),fdel$
		! first ordered
		if cost_lev[1]
			webstr$=webstr$,LTrim$(rol.ExtLoadOrd using QMask$),fdel$
		Else
			webstr$=webstr$,"0",fdel$
		Endif
			webstr$=webstr$,LTrim$(rol.ExtOrdAmt using QMask$),fdel$
			X3=rol.ExtOrdAmt-rol.ExtLoadOrd ! ext'd gp
			X3[1]=0
			if rol.ExtOrdAmt
				let x3[1]=FNR((ABS(x3)/rol.ExtOrdAmt)*100)
			Endif
		if cost_lev[1]=0 let x3=0;x3[1]=0 ! alt - no cost/gp$/%
			webstr$=webstr$,LTrim$(X3 using QMask$),fdel$
			webstr$=webstr$,LTrim$(X3[1] using QMask$),fdel$
		!Else ! no cost sec
		!	webstr$=fdel$,Ltrim$(rol.ExtOrdAmt using QMask$),fdel$
		!	webstr$=webstr$,fdel$,fdel$ ! no cost or gp
		!Endif
		! now shipping
		If cost_Lev[1]
			webstr$=webstr$,LTRim$(rol.ExtLoadShip using QMask$),fdel$
		Else
			webstr$=webstr$,"0",fdel$
		Endif
			webstr$=webstr$,LTrim$(rol.ExtShipAmt using QMask$),fdel$
			X3=rol.ExtShipAmt-rol.ExtLoadShip ! ext'd gp
			X3[1]=0
			if rol.ExtShipAmt
				let x3[1]=FNR((ABS(x3)/rol.ExtShipAmt)*100)
			Endif
		if cost_lev[1]=0 let x3=0;x3[1]=0 ! alt - no cost/gp$/%
			webstr$=webstr$,LTrim$(X3 using QMask$),fdel$
			webstr$=webstr$,LTrim$(X3[1] using QMask$),fdel$
		!Else ! no cost sec
		!	webstr$=fdel$,Ltrim$(rol.ExtShipAmt using QMask$),fdel$
		!	webstr$=webstr$,fdel$,fdel$ ! no cost or gp
		!Endif
		List$[row]=WebStr$
		Let row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	BPGPDtl: ! zlines no gp
	Loop
	LIST$[ROW]=esdel$
	e$=""
	call addtostr(e$,rstr$,List$[])
	GGPDone: ! finished
	! status section
	e$=""
	if debugdetail
		dmsg$="GP Summary Lines "+Str$(Orderno)+" TTL "+Str$(NumLines)+" "+Message$ \ Call updatelog(debug)
	Endif
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
  else
    include "src/callsuberr.inc"
 end try
end sub ! gpsumm
! 
!--------------------------------------------------------------------
Sub verifystat()
! verify status on save data 
! header record needs to read first
  Try
	
	if returnstatus<>1
		goto endverifystat: ! already has error
	endif
	!Call dxget("SOURCE",tmp$)
	let tmp3=source  ! gotten at start tmp$
	if tmp3=207 goto endverifystat: ! inquiry
	
	if credit<>0
		if roh.status<>97
			let returnstatus=99
			let message$="Credit is no longer in an edit status. Data is not saved. "	
		endif
		goto endverifystat:
	endif
	if tmp3=251 or tmp3=231
		if roh.status<>94
			let returnstatus=99
			let message$="Invoice is not longer in an edit status. Data is not saved. "
		endif
		goto endverifystat:
	endif
	if tmp3=223 
		if roh.status<>96 and roh.status<>95
			let returnstatus=99
			let message$="Invoice is no longer in an edit status. Data is not saved. "
		endif
		goto endverifystat:
	endif
	If not(tmp3) 
		if roh.status<94  or roh.status>96
			let returnstatus=99
			let message$="Quote is no longer in an edit status. Data is not saved. "
		endif
		goto endverifystat:
	endif
	if roh.status<>95
		let returnstatus=99
		let message$="Quote is no longer in an edit status. Data is not saved. "
	endif
	endverifystat: ! end the status check
		

	! status section
	e$=""
	!
	!  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	!  call AddToStr(e$,rstr$,WebStr$)
	!  call SetOutPut(e$,rstr$)
  else
    include "src/callsuberr.inc"
 end try
end sub ! verifystat
! 
!--------------------------------------------------------------------
Sub GetCutDetails()
! Send cutting details + get new charge if qtyout chgs
! Also since calcs so different - allow recalc option
  Try
	Dim X$[20],NSFKey$[60]
	dim holdpswd$[12,16]
	Dim 1%,CNVTU[2],FLAG[9],X1[9]
	Dim 1%,NewLn,HFlg[16],HFlag[16],Credit
	DIM 1%,COSTUM,BKNUNIT,CNG
	Dim 2%,X2[9],NumLines,ShipDate,JDate[5]
	DIM 2%,MAXWGT[11],DFLTCHG[11],MINCOST[11],MAXCOST[11],DFLTCOST[11]
	Dim 3%,CNVTA,AMOUNT,X3[9],V3[99]
	Dim 3%,WHBLD[2],S9[20]

	Dim NRol. as qol ! store new sent data
	Dim CPr. as prod ! copy of prod
	if debugdetail
		dmsg$="Start get cut details" \ Call updatelog(debug)
	Endif
	if p9$[20,20]<>"F" ! not fine version
		returnstatus=0
		message$="Not Fine Paper Version"
		goto GCDDONE
	Endif
	! call dxsave(0,"tmp/qlgc.txt!")
	ReturnStatus=1
	Message$="OK"
	Call DXGet("ORDERID",tmp$)
	If tmp$="" goto GCDDone
	OrderNo=tmp$
	If OrderNo<1 or OrderNo>999999 or Fra(OrderNo)
		ReturnStatus=0
		Message$="QUOTE NUMBER INVALID"
		Goto GCDDone
	Endif
	OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
	e$=""
	If OHR<=0 ! not found
		ReturnStatus=99
		Message$="QUOTE WAS NOT FOUND"
		goto GCDDone
	Else
		Credit=0 \ if rot.Status=22 let Credit=1 ! instead of roh.status check
		if returnstatus<>0
			call verifystat()
			if returnstatus=99 goto GCDDone
		endif
		LET X3=rot.HoldCode ! unpack hold flags
		FOR CTR=0 TO 11                          
			LET HFlg[CTR]=SGN(FRA(X3/2));X3=INT(X3/2)
		NEXT CTR 
		for ctr=1 to 12
			read #ctlc,66,((ctr*16)-16);holdpswd$[ctr];
		next ctr
	Endif
	if custom_customer$="OMAHA"!cct#208465/task#10448 %Cut/Punch Markup on Cut 
		IF source<>239 and ohr>0
			Call GetCust() ! need for flags
		endif
	endif
	Call DXGet("LN",tmp$) ! +Str$(X1),tmp$)
	nrol.LineNum=tmp$ ! line # (zero on new lines)
	LineNo=nrol.LineNum;NOLINEYET=0
	! per group - allow for entry on search screens - means no line yet
	if nrol.linenum ! get prev data
		rolkey$=" ",rolkey$
		rolkey$[1,6]=OrderNo Using "######"
		rolkey$[7,9]=nrol.linenum using "###"
		rolkey$[11]="" ! cut to length (space @ 10)
		OLR=filegetqolz(e$,OLC,"=",1,rolkey$,rol.)
		clear e$
		if olr<=0 ! what do we do if not found? if they sent it check it!
			Returnstatus=0
			message$="Line not found"
			e$="" ! clear emsg
			goto GCDDone
		Endif
		If OLR>0
				if rol.NStkItem=1 ! and rol.LineType<>3
					returnstatus=0
					message$="Cut is not allowed on Non-Stocks"
					goto GCDDone
					NSR=rol.PDRecNum
					Read record #NSC,NSR,0;nstk.
					PRR=0;PWR=0
				Endif
				If Not(rol.NStkItem) ! get prod & whse
					PRR=rol.PDRecNum
					Read record #PRC,PRR,0;pr.;
					read record #PRC,PRR,0;cpr.; ! copy of
					Tmp$=" ",tmp$
					tmp$=Pr.ProdCode$+rol.Whse Using "##"
					if roh.ordtype=7 let tmp$=Pr.ProdCode$+ROH.ConsWh Using "##"
					PWR=filegetprodwhse(e$,PWC,"=",1,tmp$,pw.)
					clear e$
					if PWR<0 ! not found - add new
						Clear pw.
						If PWR=-1 ! not found
							E$="";x3=tmp$[13,14]
							if roh.ordtype=7
								x3[1]=rol.whse/100
								x3=x3+x3[1]
							Endif
							Whbld[0]=PWC;Whbld[1]=X3;WhBld[2]=pr.PrimVend
							if x3<>1 let Whbld[1]=X3+.01 ! fra=copy whse 1
							Call mxwhcreate(e$,IntCo,PR.PRODCode$,WHBLD[])
							PWR=Whbld[2]
							Read record #PWC,PWR,0;PW.;
						Endif ! no whse
					Endif ! wh not found
				Endif ! stk item
		Endif ! existing line
	Else ! no line
		Clear rol. ! clear
		Clear nstk.
		! will need to get product, price, and other rol. variables!
		Call DXGet("PRODID",tmp$)
		tmp$=RTrim$(tmp$)
		If tmp$="" Goto GCDDone: ! NEED A PRODUCT!
		Let PROD$=UCase$(tmp$)+Blank$
		Call DXGet("QTY",tmp$)
		Let SQty=tmp$ ! in sum units
		Call DXGet("UM",tmp$)
		Let SUM=tmp$
		! added for order pad detail entry
		call dxget("SHIPQTY",tmp$)
		SHQty=tmp$ ! in sum units (ordpad dtl)
		call dxget("BOQTY",tmp$)
		let BOQty=tmp$ ! in sum um (ordpad dtl)
		E$="";returnstatus=1
		Clear List$[]
		maxcnt=-9 ! only set up variables flag
		call GetNewProdDtl(e$,List$[],maxcnt,Prod$,Sqty,SUM,OHR,SHQty,BOQty)
		if e$<>"" or returnstatus<>1 ! means bad data
			let message$=E$
			goto GCDDone
		Endif
		! ok - data loaded in to rol.
		NOLINEYET=1
	Endif
	If OLR>0 Read Record #OLC,OLR,0;nrol.; ! read with prev values
	if prr>0 read record #PRC,prr,0;cpr.;
	Call GetCust()
	CREDIT=0 \ if ros.status=32 let credit=1
	if credit and roh.ShipType=3 let cost_lev[1]=0 ! no cost on cm price error
	LineNo=rol.LineNum
	IF NOT(NOLINEYET) Call SetPRtoRol()
	call dxget("TYPE",tmp$) ! S I F
	tmp$=UCase$(RTrim$(tmp$))
	if tmp$="" and not(nolineyet) ! use existing
		tmp$="STK"
		if rol.LineType=1 let tmp$="INV"
		if rol.LineType=2 let tmp$="FIN"
	Endif
	if tmp$="" and nolineyet let tmp$="STK"
	if tmp$<>"STK" and tmp$<>"INV" and tmp$<>"FIN"
		returnstatus=0
		message$="Invalid Line Type"
		goto GCDDone
	Endif
	let rol.LineType=0 \ if tmp$="INV" let rol.LineType=1
	if tmp$="FIN" let rol.LineType=2
	if rol.LineType=0 ! stock - clear cut data
		rol.NumOut=0;rol.CutChrg=0;rol.CutCost=0
		rol.CutUnit=0;rol.UMCutChrg=0;rol.ExtCutChg=0
		rol.ExtCutCost=0;rol.UMCutCost=0
		goto Sndcddata ! bypass cut data
	Endif
	clear tmp$ ! jic
	call dxget("QTYOUT",tmp$)
	if tmp$<>"" ! chg'd it or set it?
		x2=tmp$;x2[1]=rol.numout
		if x2<0 or x2>999 or fra(x2)
			returnstatus=0
			message$="INVALID NUMBER OUT"
			goto GCDDone
		Endif
		if x2<>rol.numout let x1=1 else let x1=0
		rol.numout=x2
		if nolineyet ! entered is to customer!
			x3[0]=rol.numout ! entered
			x3[2]=rol.QtyOrd/X3[0];x3[3]=rol.QtyBO/X3[0];x3[4]=rol.QtyShip/X3[0]
		ELSE  ! LINE EXISTS
			if x1 ! changed numout
				if x2[1] ! have orig (ord,etc base = display/ numout
					rol.QtyOrd=rol.QtyOrd*x2[1]
					rol.QtyShip=rol.QtyShip*X2[1]
					rol.QtyBO=rol.QtyBO*X2[1]
				Endif
				if rol.numout ! get new base
					rol.QtyOrd=Rol.QtyOrd/rol.numout
					rol.QtyShip=rol.QtyShip/rol.numout
					rol.QtyBO=rol.QtyBO/rol.numout
				Endif
			Endif
		Endif ! on PM it's parent qtys? 
		if x1 let nolineyet=1 ! so recalc's charg/ccost
		IF nolineyet ! reset lbs
			LET rol.LbsUnit=pr.LbsUnit;rol.WgtFactor=pr.LbsFact
			IF NOT(rol.LbsUnit) LET rol.LbsUnit=1;rol.WgtFactor=1
		Endif
	Endif
	if recalccut ! wants recalc due to changes
		call dxget("CUTCHRG",tmp$)
		if tmp$<>""
			let charg=tmp$
			if charg<0 or charg>99999
				returnstatus=0
				message$="Invalid Cutting Charge"
				goto GCDDone
			Endif
		Endif
		call dxget("CUTCHGUM",tmp$)
		IF UCase$(Trim$(tmp$))="FLAT" 
			let R=-3
		else
			R = getumrec(e$,ccc,tmp$,IntCo,CPR.) 
		Endif          
		If R <> 0 Let tmp$ = Str$(R)                  
		X2 = tmp$
		IF X2>0 ! NOT CWT/FLAT
			Flag=ChkPrdUM(e$,SUM,IntCo,CPr.)
		 If Not(Flag)
			Let E$=" INVALID CUTTING U/M" ! +Prod$
			Let ReturnStatus=0
			GOTO GCDDone
		 Endif
		Endif
		let rol.UMCutChrg=x2
		call dxget("CUTCOST",tmp$)
		if tmp$<>""
			let ccost=tmp$
			if ccost<0 or ccost>99999
				returnstatus=0
				message$="Invalid Cutting Cost"
				goto GCDDone
			Endif
		Endif
		call dxget("CUTCSTUM",tmp$)
		IF UCase$(Trim$(tmp$))="FLAT" 
			let R=-3
		else
			R = getumrec(e$,ccc,tmp$,IntCo,CPR.) 
		Endif
		If R <> 0 Let tmp$ = Str$(R)
		X2 = tmp$
		IF X2>0 ! NOT CWT/FLAT
			Flag=ChkPrdUM(e$,SUM,IntCo,CPr.)
		 If Not(Flag)
			Let E$=" INVALID CUTTING COST U/M" ! +Prod$
			Let ReturnStatus=0
			GOTO GCDDone
		 Endif
		Endif
		let rol.UMCutCost=x2
	Endif ! of recalccut
	! load list
	Sndcddata: ! if new - use prod vars!
	Clear List$[]
	List$[0]=bsdel$,"CUTDETAILS",fdel$
	webstr$="ORDERID",fdel$,"LINEID",fdel$,"PRODID",fdel$
	webstr$=webstr$,"TYPE",fdel$,"QTYOUT",fdel$
	webstr$=webstr$,"INVENTORY",fdel$,"ACTUALINV",fdel$
	webstr$=webstr$,"QTYTOCUST",fdel$,"WEIGHT",fdel$
	webstr$=webstr$,"CUTCHRG",fdel$,"CUTCHGUM",fdel$
	webstr$=webstr$,"CUTCHGUMID",fdel$,"CUTCHGUMFACT",fdel$
	Webstr$=webstr$,"CUTCOST",fdel$,"CUTCSTUM",fdel$
	webstr$=webstr$,"CUTCSTUMID",fdel$,"CUTCSTUMFACT",fdel$
	webstr$=webstr$,"LINEDESC1",fdel$,"LINEDESC2",fdel$
	webstr$=webstr$,"PPRICE",fdel$,"CUTPRICE",fdel$
	webstr$=webstr$,"CUTANDCHRG",FDEL$,"QTYUM",fdel$
	webstr$=webstr$,"PRICEUM",fdel$ ! ,"COSTUM",fdel$
	webstr$=webstr$,"LEVEL",fdel$ ! 
	List$[1]=webstr$
	if rol.numout
		x3[0]=rol.numout
		x3[2]=rol.QtyOrd*X3[0];x3[3]=rol.QtyBO*X3[0];x3[4]=rol.QtyShip*X3[0]
	Else
		x3[2]=rol.QtyOrd;x3[3]=rol.QtyBO;x3[4]=rol.QtyShip
	Endif
	If not(recalccut) ! don't if just sent!
	 if rol.UMCutChrg=-3 ! FLAT
		Charg=rol.CutChrg
	 Else
		cnvtu[0]=0;cnvtu[1]=rol.UMCutChrg;cnvtu[2]=2
		cnvta=rol.CutChrg
		Charg=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	 Endif
	 if rol.UMCutCost=-3 ! FLAT
		CCost=rol.CutCost
	 Else
		cnvtu[0]=0;cnvtu[1]=rol.UMCutCost;cnvtu[2]=2
		cnvta=rol.CutCost
		CCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	 Endif
	Endif
	IF rol.LineType=2 LET X5=137 ELSE  LET X5=138
	MAT  READ #CTLC,X5,0;MAXWGT;             
	MAT  READ #CTLC,X5,48;DFLTCOST;          
	MAT  READ #CTLC,X5,96;MINCOST;           
	MAT  READ #CTLC,X5,144;MAXCOST;          
	MAT  READ #CTLC,X5,192;DFLTCHG;          
	MAT  READ #CTLC,X5,240;COSTUM;   
	! IF rol.numout=1 IF ROL.CutChrg=0 IF rol.CutCost=0 LET rol.numout=0
	IF rol.numout=0 LET rol.numout=1                        
	IF PR.LbsFact=0 LET pr.LbsFact=1                          
	
	cnvtu[0]=0;cnvtu[1]=rol.UMSell;cnvtu[2]=1
	cnvta=x3[2]
	Qtyord=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.) ! to sell um
	LET WGT=FNR(ABS((rol.LbsUnit*X3[2])/(rol.numout*pr.LbsFact))) 
	FOR LEVEL=0 TO 6                              
		IF WGT<=MAXWGT[LEVEL] GOTO END_LEVEL_SEARCH:
	NEXT LEVEL                                    
	IF LEVEL>6 LET LEVEL=6                        
	END_LEVEL_SEARCH: REM  ! level for data
	if rol.linetype=0 let rol.numout=0;level=0
	iF nolineyet ! need add'l data
	  if rol.numout
		ChkFraB: ! see if fra base
		IF FRA(X3[2]/rol.numout)                                               
		  LET X3[2]=INT(X3[2])+1                                         
		  GOTO ChkFraB                                                       
		ENDIF                                                              
		LET CNVTU[0]=0;CNVTU[1]=rol.UMSell;CNVTU[2]=1;CNVTA=X3[2] ! QTYORD
		LET Qtyord=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.) ! to sell um
		! need level if base Qty changed!
		LET WGT=FNR(ABS((rol.LbsUnit*X3[2])/(rol.numout*pr.LbsFact))) 
		FOR LEVEL=0 TO 6                              
			IF WGT<=MAXWGT[LEVEL] GOTO END_LEVEL_SEARCH2
		NEXT LEVEL                                    
		IF LEVEL>6 LET LEVEL=6                        
		END_LEVEL_SEARCH2: REM  ! new level
		if rol.linetype=0 let rol.numout=0;level=0
	  Endif
	  if recalccut=0 and rol.numout>0 ! did not send chrg/cost
		  LET CHARG=DFLTCHG[LEVEL]
		  LET CCOST=DFLTCOST[LEVEL]                                                 
		  LET ROL.UMCutChrg=-1 \ LET ROL.UMCutCost=COSTUM
		  IF ROL.CutCost LET ROL.UMCutCost=-1
		  if custom_customer$="OMAHA"!cct#208465/task#10448 %Cut/Punch Markup on Cut 
			 If cust.OmahaCpMup<>0 And CostUM=-1 ! "has markup % and cwt cost
  				Let X3=CCost ! "use in calc
  				LET X4=X3+((X3*(ABS(cust.OmahaCpMup)/100)))*SGN(cust.OmahaCpMup)
  				Let CHARG=X4 ! "cost plus markup %
  				If Q0[1]=2 Let CHARG=FNR(X4) ! "round @ 2
			endif
		  endif
		  LET ROL.ExtCutChg=CHARG*(WGT/100)
		  LET ROL.ExtCutCost=CCOST*(WGT/100)
		  IF MINCOST[LEVEL] IF ROL.ExtCutCost<MINCOST[LEVEL] LET CCOST=MINCOST[LEVEL] \ LET ROL.UMCutCost=-3                                                                        
		  IF MAXCOST[LEVEL] IF ROL.ExtCutCost>MAXCOST[LEVEL] LET CCOST=MAXCOST[LEVEL] \ LET ROL.UMCutCost=-3                                                                        
	      if custom_customer$="OMAHA"!cct#208465/task#10448 %Cut/Punch Markup on Cut 
			If cust.OmahaCpMup<>0 and ROL.UMCUTCOST=-3 ! "flat cost = flat charge?
 				Let X3=CCost ! "use in calc
  				LET X4=X3+((X3*(ABS(cust.OmahaCpMup)/100)))*SGN(cust.OmahaCpMup)
  				Let CHARG=FNR(X4) ! "cost plus markup %
  				Let ROL.umCUTCHRG=-3 ! "change charge to flat also?
			Endif
		 endif
	  Endif ! only new
	Endif ! of set cut, etc on new line
	
	! calc final cost/price
	cnvtu[0]=rol.umcutcost;cnvtu[1]=0;cnvtu[2]=2
	if cnvtu[0] and cnvtu[0]<>-3
		cnvta=ccost
		rol.cutcost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	Endif
	if rol.umcutcost=-3 let rol.cutcost=CCost
	cnvtu[0]=rol.UMCutChrg;cnvtu[1]=0;cnvtu[2]=2
	if cnvtu[0] and cnvtu[0]<>-3
		cnvta=CHARG
		rol.CutChrg=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	Endif
	if rol.UMCutChrg=-3 let rol.CutChrg=CHARG
	cnvtu[0]=rol.UMSell;cnvtu[1]=0;cnvtu[2]=1
	if rol.numout let cnvta=qtyord/rol.numout Else let cnvta=qtyord
	BaseQ=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	if rol.UMCutChrg=-3 and BaseQ ! FLAT
		CHBase=rol.CutChrg/BASEQ
	Else
		CHBase=rol.CutChrg
	Endif
	cnvtu[0]=0;cnvtu[1]=rol.UMPrice;cnvtu[2]=2
	cnvta=rol.UnitPrice
	Price=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	cnvtu[0]=0;cnvtu[1]=rol.UMPrice;cnvtu[2]=2
	IF rol.UMPrice>0 AND rol.numout LET CNVTA=(rol.UnitPrice/rol.numout) ELSE  LET CNVTA=rol.UnitPrice
	CPrice=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	cnvtu[0]=0;cnvtu[1]=rol.UMPrice;cnvtu[2]=2
	IF rol.UMPrice>0 AND rol.numout LET CNVTA=(rol.UnitPrice/rol.numout) ELSE  LET CNVTA=rol.UnitPrice
	IF rol.UMPrice>0 AND rol.numout LET CNVTA=CNVTA+(CHBASE/rol.numout) ELSE let CNVTA=CNVTA+CHBASE
	CHPrice=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	! send data
	webstr$=Str$(OrderNo),fdel$,Str$(LineNo),fdel$,RTrim$(rol.ProdCode$),fdel$
	tmp$="STK" \ if rol.LineType=1 let tmp$="INV"
	if rol.LineType=2 let tmp$="FIN"
	webstr$=webstr$,tmp$,fdel$,Str$(rol.NumOut),fdel$
	!cnvtu[0]=rol.UMSell;cnvtu[1]=pr.UMStkDefault;cnvtu[2]=1
	!if rol.numout let cnvta=qtyord/rol.numout Else Let cnvta=Qtyord
	!X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	! webstr$=webstr$,LTRim$(x3 using QMask$),fdel$ ! stk order
	cnvtu[0]=0;cnvtu[1]=cpr.UMStkDefault;cnvtu[2]=1;cnvta=BaseQ
	! if not(nolineyet) let cnvtu[1]=pr.UMPurchDefault ! moved in prtorol
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,CPR.)
	tmp$=XUnit$(cpr.UMStkDefault,ccc)
	webstr$=webstr$,LTRim$(x3 using QMask$)," ",tmp$,fdel$ ! stk order
	if rol.numout let cnvta=qtyord/rol.numout Else let cnvta=Qtyord
	webstr$=webstr$,lTRIM$(cnvta using QMask$),fdel$ !  ordered
	webstr$=webstr$,LTRim$(Qtyord using QMask$),fdel$ ! Qty to cust
	webstr$=webstr$,LTrim$(WGT using QMask$),fdel$ ! weight
	webstr$=webstr$,LTrim$(Charg using PMask$),fdel$ ! cut charge
	tmp$="" \ if rol.UMCutChrg let tmp$=XUnit$(rol.UMCutChrg,ccc)
	if rol.UMCutChrg=-3 let tmp$="FLAT"
	webstr$=webstr$,tmp$,fdel$,Str$(rol.UMCutChrg),fdel$ ! cut um, ID
	x3=0 \ if rol.UMCutChrg>0 let x3=UMtoFactor(rol.UMCutChrg)
	if rol.UMCutChrg<0 let x3=rol.UMCutChrg
	webstr$=webstr$,LTrim$(X3 using "-------#"),fdel$ ! um factor?
	webstr$=webstr$,LTrim$(CCost using PMask$),fdel$ ! cut cost
	tmp$="" \ if rol.UMCutCost let tmp$=XUnit$(rol.UMCutCost,ccc)
	if rol.UMCutCost=-3 let tmp$="FLAT"
	webstr$=webstr$,tmp$,fdel$,Str$(rol.UMCutCost),fdel$
	x3=0 \ if rol.UMCutCost let x3=UMtoFactor(rol.UMCutCost)
	if rol.UMCutCost<0 let x3=rol.UMCutCost
	webstr$=webstr$,LTrim$(X3 using "-------#"),fdel$ ! um factor?
	tmp$=clrtxtc$(e$,rol.desc1$) ! chk/clr control chars
	webstr$=webstr$,RTrim$(tmp$),fdel$
	tmp$=clrtxtc$(e$,rol.desc2$) ! chk/clr control chars
	webstr$=webstr$,RTrim$(tmp$),fdel$
	webstr$=webstr$,LTrim$(Price using PMask$),fdel$
	webstr$=webstr$,LTrim$(CPrice using PMask$),fdel$
	webstr$=webstr$,LTrim$(CHPrice using PMask$),fdel$
	tmp$=XUnit$(rol.UMSell,ccc)
	webstr$=webstr$,tmp$,fdel$ ! UM Sell
	tmp$=XUnit$(rol.UMPrice,ccc)
	webstr$=webstr$,tmp$,fdel$ ! UM PRICE
	webstr$=webstr$,Str$(Level+1),fdel$ ! level
	List$[2]=webstr$
	List$[3]=esdel$ ! finished
	e$=""
	call AddToStr(e$,rstr$,List$[])
	! need to send UM usable (add FLAT!)
	clear list$[]
	List$[0]=bsdel$,"CUTUM",fdel$
	list$[1]="UM",fdel$,"DESC",fdel$
	row=2
	! add cwt/flat
	let list$[row]="CWT ",fdel$,"HUNDRED WT",fdel$ \ row=row+1
	list$[row]="FLAT",fdel$,"FLAT CHRG",fdel$ \ row=row+1
	for x=0 to 7
		if x=0 let x1=pr.BaseUM
		if x=1 let x1=pr.UM2
		if x=2 let x1=pr.UM3
		if x=3 let x1=pr.UM4
		if x=4 let x1=pr.UM5
		if x=5 let x1=pr.UM6
		if x=6 let x1=pr.UM7
		if x=7 let x1=pr.UM8
		if x1>0
			read #ccc,x1,0;x$[1,14];
			list$[row]=x$[11,14],fdel$,X$[1,10],fdel$
			row=row+1
		Endif
	Next X
	! done
	list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])
	GCDDone: ! finished
	if returnstatus=1 let message$="OK" ! set if no other problems
	if debugdetail
		dmsg$="Get Cut "+Str$(rol.OrdNum)+"-"+Str$(rol.LineNum)+" "+rol.ProdCode$+Message$ \ Call updatelog(debug)
	Endif
	
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	
  else
    include "src/callsuberr.inc"
 end try
end sub ! GetCutDetails
! 
!--------------------------------------------------------------------
Sub SubmitCutDetails()
! Submit cutting details
  Try
	Dim X$[20],NSFKey$[60]
	dim holdpswd$[12,16]
	Dim 1%,CNVTU[2],FLAG[9],X1[9]
	Dim 1%,NewLn,HFlg[16],HFlag[16],Credit
	Dim 2%,X2[9],NumLines,ShipDate,JDate[5]
	Dim 3%,CNVTA,AMOUNT,X3[9],V3[99]
	Dim 3%,WHBLD[2],S9[20]

	Dim NRol. as qol ! store new sent data
	Dim CPR. as prod ! copy of prodfile (for um change)
	if debugdetail
		dmsg$="Start submit cut details" \ Call updatelog(debug)
	Endif
	if p9$[20,20]<>"F" ! not fine version
		returnstatus=0
		message$="Not Fine Paper Version"
		goto SCDDONE
	Endif
	ReturnStatus=1
	Message$="OK"
	hmaxcnt=maxcnt ! keep it
	Read #ctlc,3,188;ShipDate; ! for inv levels
	Call DXGet("ORDERID",tmp$)
	If tmp$="" goto SCDDone
	OrderNo=tmp$
	If OrderNo<1 or OrderNo>999999 or Fra(OrderNo)
		ReturnStatus=0
		Message$="QUOTE NUMBER INVALID"
		Goto SCDDone
	Endif
	OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
	e$=""
	If OHR<=0 ! not found
		ReturnStatus=99
		Message$="QUOTE WAS NOT FOUND"
		goto SCDDone
	Else
		Credit=0 \ if rot.Status=22 let Credit=1 ! instead of roh.status check
		if returnstatus<>0
			call verifystat()
			if returnstatus=99 goto SCDDone
		endif
		LET X3=rot.HoldCode ! unpack hold flags
		FOR CTR=0 TO 11                          
			LET HFlg[CTR]=SGN(FRA(X3/2));X3=INT(X3/2)
		NEXT CTR 
		for ctr=1 to 12
			read #ctlc,66,((ctr*16)-16);holdpswd$[ctr];
		next ctr
	Endif
	tmp$ = ShipDate Using "&&&&&&"                                 
	Call DateToJulian(1,tmp$,tmp1$,f)                              
	If f Let tmp1$ = ""                                            
	JDATE[1] = tmp1$;f = 0 ! julian sys shipdate                   
	tmp$ = roh.ShipDate Using "&&&&&&"                             
	If roh.ShipDate <> 999999 Call DateToJulian(1,tmp$,tmp1$,f)    
	If f Let tmp1$ = ""                                            
	JDATE[2] = tmp1$ ! julian ord shipdate  
	Call DXGet("LN",tmp$) ! +Str$(X1),tmp$)
	nrol.LineNum=tmp$ ! line # (zero on new lines)
	LineNo=nrol.LineNum;NOLINEYET=0
	if nrol.linenum ! get prev data
		rolkey$=" ",rolkey$
		rolkey$[1,6]=OrderNo Using "######"
		rolkey$[7,9]=nrol.linenum using "###"
		rolkey$[11]="" ! cut to length (space @ 10)
		OLR=filegetqolz(e$,OLC,"=",1,rolkey$,rol.)
		clear e$
		if olr<=0 ! what do we do if not found - if passed has to be there
				clear rol.
				returnstatus=0 ! treat as new?
				e$="" ! clear emsg
				Message$="QUOTE LINE WAS NOT FOUND"
				goto SCDDone
		Endif
		If OLR>0
			if rol.NStkItem=1 ! and rol.LineType<>3
				returnstatus=0
				message$="Cut is not allowed on Non-Stocks"
				goto SCDDone
					NSR=rol.PDRecNum
					Read record #NSC,NSR,0;nstk.
					PRR=0;PWR=0
			Endif
			if rol.KitDesignation$="KIT"
				returnstatus=0
				message$="Cut is not allowed on Kit Lines"
				goto SCDDone
			Endif
			If Not(rol.NStkItem) ! get prod & whse
					PRR=rol.PDRecNum
					Read record #PRC,PRR,0;pr.;
					if roh.ordtype=8 or roh.ordtype=16 ! chk to whse
					  If Roh.ConsWh>0 and roh.conswh<100
						Let TPWKey$=" ",tpwKey$
						TPWkey$[1,12]=pr.prodcode$+Blank$
						TPWKey$[13]=ROH.ConsWh Using "##"
						call chktowhse(TPWKey$,pr.PrimVend)
					  Endif
					Endif
					Tmp$=" ",tmp$
					tmp$=Pr.ProdCode$+rol.Whse Using "##"
					if roh.ordtype=7 let tmp$=Pr.ProdCode$+ROH.ConsWh Using "##"
					PWR=filegetprodwhse(e$,PWC,"=",1,tmp$,pw.)
					clear e$
					if PWR<0 ! not found - add new
						Clear pw.
						If PWR=-1 ! not found
							E$="";x3=tmp$[13,14]
							if roh.ordtype=7
								x3[1]=rol.whse/100
								x3=x3+x3[1]
							Endif
							Whbld[0]=PWC;Whbld[1]=X3;WhBld[2]=pr.PrimVend
							if x3<>1 let Whbld[1]=X3+.01 ! fra=copy whse 1
							Call mxwhcreate(e$,IntCo,PR.PRODCode$,WHBLD[])
							PWR=Whbld[2]
							Read record #PWC,PWR,0;PW.;
						Endif ! no whse
					Endif ! wh not found
			Endif ! stk item
		Endif ! existing line
	Else ! no line
		Clear rol. ! clear
		Clear nstk.
		! will need to create line now!
		Call DXGet("PRODID",tmp$)
		tmp$=RTrim$(tmp$)
		If tmp$="" Goto SCDDone: ! NEED A PRODUCT!
		Let PROD$=UCase$(tmp$)+Blank$
		Call DXGet("QTY",tmp$)
		Let SQty=tmp$ ! in sum units
		Call DXGet("UM",tmp$)
		Let SUM=tmp$
		! added for order pad detail entry
		call dxget("SHIPQTY",tmp$)
		SHQty=tmp$ ! in sum units (ordpad dtl)
		call dxget("BOQTY",tmp$)
		let BOQty=tmp$ ! in sum um (ordpad dtl)
		E$="";returnstatus=1
		Clear List$[]
		maxcnt=-9 ! only set up variables flag
		call GetNewProdDtl(e$,List$[],maxcnt,Prod$,Sqty,SUM,OHR,SHQty,BOQty)
		if e$<>"" or returnstatus<>1 ! means bad data
			let message$=E$
			goto SCDDone
		Endif
		PRR=rol.PDRecNum ! needed below?
		! ok - data loaded in to rol.
		NOLINEYET=1;OLR=0
		! all rol. are set up - NO LINE CREATED YET!
	Endif
	If OLR>0 Read Record #OLC,OLR,0;nrol. ! read / lock with prev values
	IF PRR>0 read record #PRC,PRR,0;cpr.; ! copy of prod
	Call GetCust()
	CREDIT=0 \ if ros.status=32 let credit=1
	if credit and roh.ShipType=3 let cost_lev[1]=0 ! no cost on cm price error
	LineNo=rol.LineNum
	if not(NOLINEYET) ! exists - set up conv
		Call SetPRtoRol()
	Endif ! existing line
	IF rol.numout ! to base display qtys
		x3[0]=rol.numout
		x3[2]=rol.QtyOrd*X3[0];x3[3]=rol.QtyBO*X3[0];x3[4]=rol.QtyShip*X3[0]
	Else
		let x3[2]=rol.qtyord;x3[3]=rol.qtybo;x3[4]=rol.qtyship ! retain original BASE
	Endif
	X3[1]=x3[2] ! origqtyord
	! get data
	call dxget("TYPE",tmp$) ! S I F
	tmp$=UCase$(RTrim$(tmp$))
	if tmp$<>"STK" and tmp$<>"INV" and tmp$<>"FIN"
		returnstatus=0
		message$="Invalid Line Type"
		goto SCDDone
	Endif
	let rol.LineType=0 \ if tmp$="INV" let rol.LineType=1
	if tmp$="FIN" let rol.LineType=2
	if rol.LineType=0 ! stock - clear cut data
		rol.NumOut=0;rol.CutChrg=0;rol.CutCost=0
		rol.CutUnit=0;rol.UMCutChrg=0;rol.ExtCutChg=0
		rol.ExtCutCost=0;rol.UMCutCost=0
		goto CutDOK ! bypass cut data
	Endif
	call dxget("QTYOUT",tmp$) ! 0=NG, 1-999 (if chgd-base qtys change!!)
	x2=tmp$
	if x2<1 or x2>999 or fra(x2)
		returnstatus=0
		message$="Invalid Number out"
		goto SCDDone
	Endif
	let rol.numout=x2
	cnvtu[0]=0;cnvtu[1]=rol.UMSell;cnvtu[2]=1
	cnvta=x3[2] ! TO customer ordered
	Qtyord=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.) ! in sell um
	if rol.numout
		ChkFraBs: ! see if fra base
		IF FRA(X3[2]/rol.numout)                                               
		  LET X3[2]=INT(X3[2])+1                                         
		  GOTO ChkFraBS                                                       
		ENDIF                                                              
		LET CNVTU[0]=0;CNVTU[1]=UN[0];CNVTU[2]=1;CNVTA=X3[2] ! QTYORD
		LET Qtyord=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.) ! sell um
	Endif
	call dxget("CUTCHRG",tmp$)
	if tmp$<>""
		let charg=tmp$
		if charg<0 or charg>99999
			returnstatus=0
			message$="Invalid Cutting Charge"
			goto SCDDone
		Endif
	Endif
	call dxget("CUTCHGUM",tmp$)
	IF UCase$(Trim$(tmp$))="FLAT" 
		let R=-3
	else
		R = getumrec(e$,ccc,tmp$,IntCo,CPR.) 
	Endif          
	If R <> 0 Let tmp$ = Str$(R)                  
	X2 = tmp$
	IF X2>0 ! NOT CWT/FLAT
		cum=x2
		Flag=ChkPrdUM(e$,CUM,IntCo,Pr.)
	 If Not(Flag)
		Let messagE$=" INVALID CUTTING U/M" ! +Prod$
		Let ReturnStatus=0
		GOTO SCDDONE
	 Endif
	Endif
	let rol.UMCutChrg=x2
	call dxget("CUTCOST",tmp$)
	if tmp$<>""
		let ccost=tmp$
		if ccost<0 or ccost>99999
			returnstatus=0
			message$="Invalid Cutting Cost"
			goto SCDDone
		Endif
	Endif
	call dxget("CUTCSTUM",tmp$)
	IF UCase$(Trim$(tmp$))="FLAT" 
		let R=-3
	else
		R = getumrec(e$,ccc,tmp$,IntCo,CPR.) 
	Endif
	If R <> 0 Let tmp$ = Str$(R)
	X2 = tmp$
	IF X2>0 ! NOT CWT/FLAT
		cum=x2
		Flag=ChkPrdUM(e$,CUM,IntCo,CPr.)
	 If Not(Flag)
		Let messagE$=" INVALID CUTTING COST U/M" ! +Prod$
		Let ReturnStatus=0
		GOTO SCDDONE
	 Endif
	Endif
	let rol.UMCutCost=x2
	call dxget("LINEDESC1",tmp$)
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Description 1"
		goto SCDDONE
	Endif
	let rol.Desc1$=Trim$(Tmp$)+Blank$
	call dxget("LINEDESC2",tmp$)
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Description 2"
		goto SCDDONE
	Endif
	let rol.Desc2$=Trim$(tmp$)+Blank$
	if not(nolineyet) ! existing and data is ok
		If Not(Credit) and rol.UpdtStk ! back out prev qty ord from prod & whse
			Read record #PRC,PRR,0;PR.
			If PWR>0 Read Record #PWC,PWR,0;pw.
			X3=ROL.QtyShip
			if roh.OrdType=4 or roh.OrdType=15 or roh.ordtype=19 let x3=rol.QtyOrd-rol.PrevQtyShip-rol.QtyBO
			if custom_customer$="MORRISETTE"
				If roh.OrdType=4 Let X3=ROL.QtyShip ! "cct 129415 - only commit shipping qty
			Endif
			IF roh.OrdType=15 AND roh.BOCTR<>0 LET x3=0        
			IF roh.OrdType=15 AND roh.BOCTR=0 LET x3=rol.QtyOrd
			!if roh.ordtype=19 and roh.boctr<>0 and roh.ot19comp=0 let x3=0 ! closed!
			If X3<0 let X3=0 ! neg ship - no Onord update
			pr.QtyOnOrd=pr.QtyOnOrd-X3
			pw.QtyOnOrd=pw.QtyOnOrd-x3
			IF JDATE[1]>=JDATE[2]
				LET pr.Lvl1Qty=pr.Lvl1Qty-x3
				Let pw.Lvl1Qty=pw.Lvl1Qty-x3
				if pr.Lvl1Qty<0 let pr.Lvl1Qty=0
				if pw.Lvl1Qty<0 let pw.Lvl1Qty=0
			ELSE
				LET pr.Lvl2Qty=pr.Lvl2Qty-x3
				Let pw.Lvl2Qty=pw.Lvl2Qty-x3
				if pr.Lvl2Qty<0 let pr.Lvl2Qty=0
				if pw.Lvl2Qty<0 let pw.Lvl2Qty=0
			Endif
			if pr.CatchwgtItem$="Y"
				X=1 \ if rol.QtyOrd<0 let x=0 ! -1 ! neg ord/ship (wgt always +)
				IF roh.OrdType=15 AND roh.BOCTR<>0 LET x=0 ! NO QTY
				pr.LbsOnOrder=pr.LbsOnOrder-(rol.ExtNetWgt*x)
				pw.LbsOnOrder=pw.LbsOnOrder-(rol.ExtNetWgt*x)
			Endif
			If pr.QtyOnOrd<0 Let pr.QtyOnOrd=0
			If pw.QtyOnOrd<0 let pw.QtyOnOrd=0
			If pr.LbsOnOrder<0 Let pr.LbsOnOrder=0
			If pw.LbsOnOrder<0 Let pw.LbsOnOrder=0
			!Write Record #PRC,PRR,0;PR.;
			!If PWR>0 Write Record #PWC,PWR,0;pw.;
		Endif ! of updatestk
	Endif
	! reset weight vars to rol (as re-read pr. above)
	If rol.LbsUnit>0 LET pr.LbsUnit=rol.LbsUnit
	if rol.WgtFactor>0 let pr.LbsFact=rol.WgtFactor
	IF NOT(pr.LbsUnit) LET pr.LbsUnit=1;rol.WgtFactor=1    
	LET pr.CubicFeet=rol.CubeUnit;pr.CubicFtFactor=rol.CubeFactor
	IF NOT(pr.CubicFtFactor) LET pr.CubicFtFactor=1;rol.CubeFactor=1
	! set up conv
	IF PR.LbsFact=0 LET pr.LbsFact=1                          
	if rol.numout 
		LET WGT=FNR(ABS((rol.LbsUnit*X3[2])/(rol.numout*pr.LbsFact)))
	else
		let wgt=rol.ExtNetWgt
	Endif
	REM CONVERT CHARGE TO BASE                                            
	IF rol.UMCutChrg=-3 
		LET rol.CutChrg=CHARG \ LET rol.ExtCutChg=rol.CutChrg
	Else
		LET CNVTU[0]=rol.UMCutChrg;CNVTU[1]=0;CNVTU[2]=2;CNVTA=CHARG
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		LET rol.CutChrg=AMOUNT
		LET ROL.ExtCutChg=CHARG*(WGT/100)
	Endif                                                                
	REM CONVERT COST TO BASE                                              
	IF rol.UMCutCost=-3
		LET rol.CutCost=CCOST \ LET rol.ExtCutCost=Rol.CutCost
	Else
		LET CNVTU[0]=rol.UMCutCost \ LET CNVTU[1]=0 \ LET CNVTU[2]=2 \ LET CNVTA=CCOST
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		LET rol.CutCost=AMOUNT 
		LET ROL.ExtCutCost=CCOST*(WGT/100)
	Endif
	! per group - also redo onord,onbo,ship after
	CutDOK: ! ok - continue
	! use x3[] - base customer qtys-original
	!0=org.numout,1&2=ord,3=bo,4=shp
	IF X3[4]=X3[1] AND X3[2]>X3[4] LET x3[4]=x3[2]   
	IF X3[3] AND X3[2]>X3[1] LET X3[3]=X3[2]-X3[4]       
	IF X3[4]>X3[2] LET X3[4]=X3[2]                          
	IF X3[3]>X3[2] LET X3[3]=X3[2]                             
	IF X3[3]+X3[4]>X3[2] LET X3[3]=X3[2]-X3[4]              
	IF rol.numout ! put back to parent qtys
	  LET rol.QtyOrd=X3[2]/rol.numout;rol.Qtybo=X3[3]/rol.numout;rol.qtyship=X3[4]/rol.numout
	ELSE                                                          
	  LET rol.QtyOrd=X3[2];rol.Qtybo=X3[3];rol.qtyship=X3[4]                  
	ENDIF 
	nrol.QtyOrd=rol.QtyOrd;nrol.Qtybo=rol.Qtybo;nrol.qtyship=rol.qtyship
	! get bo type
	x=0 \ if p60$[27,27]="S" let x=1
	if p60$[27,27]="B" let x=2
	if p60$[27,27]="E" let x=3
	if kit let x=0 ! will build it
	IF P9$[2,2]="M" AND pr.MBFlg$="M" let X=0 ! will build/make it
	Let X=0 ! NEVER A BO CHECK ON QUOTES!
	! Per group = redo avail check
	x2[9]=rol.whse \ if roh.ordtype=7 let x2[9]=roh.ConsWh
	If RTrim$(rol.ProdCode$)<>""
		X3[1]=getwhavail(e$,intco,PWC,rol.ProdCode$,X2[9])
	Else
		x3[1]=0
	Endif
	if Not(credit) and X>0 ! has bochk set
	 If ROL.UpdtStk and rol.QtyOrd>X3[1] ! order > whavail
	  if x3[1]>0 ! has some avail
		Let rol.QtyShip=X3[1] ! take it all
		Let rol.QtyBO=rol.QtyOrd-rol.QtyShip
	  Else ! zero or <0 avail
		Let rol.QtyShip=0
		Let rol.QtyBO=rol.QtyOrd ! all backordered
	  Endif
	 Endif ! of updt and ord>avail
	Endif
	! added 2/28 - convert shipped/bo to sell 2 dec - 2316
	if rol.qtyship<>0
		cnvtu[0]=0;cnvtu[1]=rol.UMSell;cnvtu[2]=1
		cnvta=rol.qtyship
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		tmp$=LTrim$(amount using "----------#.##")
		amount=tmp$ ! now 2 decimals only
		cnvtu[0]=rol.UMSell;cnvtu[1]=0;cnvtu[2]=1
		cnvta=amount
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if amount<>rol.qtyship ! it changed
			rol.qtyship=amount
			if rol.qtyship>x3[1] let rol.qtyship=x3[1] ! no overship!
			Let rol.QtyBO=rol.QtyOrd-rol.QtyShip
		Endif
	Endif ! of recalc qty ship based on 2 dec
	! if user entered?
	!if NoLineYet ! not existing
	! if MSHQty or MBOQty ! manually entered this - keep it? NO
	!	let rol.QtyShip=MSHQty ! as entered (override calc)
	!	let rol.QtyBO=MBOQty ! as entered
	! Endif
	!Endif ! new line
	if roh.ordtype=15 let rol.qtyship=0;rol.qtybo=0 ! starts as zero
	if Cust.BoSAllowedFlag=0 Let rol.QtyBO=0 ! no bo's allowed
	if pw.DNReordFlg=1 and rol.qtybo let rol.qtybo=0 ! no bo
	if roh.ordtype=4 let rol.QtyBO=0 ! no bo's allowed on ot4? - 32160
	! and update on order/rasl
	
	clear rol.SpareNu$ ! dl4 fix
	if nolineyet ! not existing
		 X2=GetNxtLine(orderno) ! GET NEXT LINE# 
		 rol.linenum=x2;E=0;olr=0
		 OLR=fileupdateqolz(e$,OLC,"a",e,rol.)
	Else ! is existing
		write record #OLC,OLR,0;rol.;
	Endif ! add new line
	read record #OLC,OLR,0;nrol.; ! below uses nrol
	call dolineextens() ! re-calc extensions 
	write record #OLC,OLR,0;nrol.; ! ext update
	If Not(nonstk) and rol.UpdtStk and OLR>0
	   ! add qtyord to prod & Whse
	   if Not(nonStk) and Not(Credit) and nrol.UpdtStk ! add NEW qty ord to prod & whse
			Read record #PRC,PRR,0;PR.
			! in case whse change - get whse again
			tmp$=" ",tmp$
			tmp$=pr.prodcode$+nrol.whse using "##"
			if roh.ordtype=7 let tmp$=pr.prodcode$+roh.ConsWh using "##"
			PWR=filegetprodwhse(e$,pwc,"=",1,tmp$,pw.,1)! get and LOCK
			clear e$
			If PWR<0 ! search error
			  Clear pw.
			  if PWR=-1 ! new whse not found - add it now
				E$="";x3=tmp$[13,14] ! CLEAR NOF msg
				if roh.ordtype=7
					x3[1]=nrol.whse/100
					x3=x3+x3[1]
				Endif
				Whbld[0]=PWC;Whbld[1]=x3;WhBld[2]=pr.PrimVend
				if x3<>1 let Whbld[1]=X3+.01 ! fra=copy whse 1
				Call mxwhcreate(e$,IntCo,pr.PRODCode$,WHBLD[])
				PWR=Whbld[2]
				Read Record #PWC,PWR,0;pw.
			  Endif
			Endif
			X3=NROL.QtyShip
			if roh.OrdType=4 or roh.OrdType=15 or roh.ordtype=19 let x3=nrol.QtyOrd-nrol.PrevQtyShip-nrol.QtyBO
			if custom_customer$="MORRISETTE"
				If roh.OrdType=4 Let X3=NROL.QtyShip ! "cct 129415 - only commit shipping qty
			Endif
			IF roh.OrdType=15 AND roh.BOCTR<>0 LET x3=0        
			IF roh.OrdType=15 AND roh.BOCTR=0 LET x3=nrol.QtyOrd
			!if roh.ordtype=19 and roh.boctr<>0 and roh.ot19comp=0 let x3=0 ! closed
			if x3<0 let X3=0 ! no neg onord update
			pr.QtyOnOrd=pr.QtyOnOrd+X3
			pw.QtyOnOrd=pw.QtyOnOrd+x3
			IF JDATE[1]>=JDATE[2]
				LET pr.Lvl1Qty=pr.Lvl1Qty+x3
				Let pw.Lvl1Qty=pw.Lvl1Qty+x3
			ELSE
				LET pr.Lvl2Qty=pr.Lvl2Qty+x3
				Let pw.Lvl2Qty=pw.Lvl2Qty+x3
			Endif
			if pr.CatchwgtItem$="Y"
				X=1 \ if nrol.QtyOrd<0 let x=0 ! -1 ! neg ord/ship (wgt always +)
				IF roh.OrdType=15 AND roh.BOCTR<>0 LET x=0 ! NO QTY
				pr.LbsOnOrder=pr.LbsOnOrder+(nrol.ExtNetWgt*x)
				pw.LbsOnOrder=pw.LbsOnOrder+(nrol.ExtNetWgt*x)
			Endif
			!Write Record #PRC,PRR,0;PR.;
			!If PWR>0 Write Record #PWC,PWR,0;pw.;
			IF PW.QtyOnHand-pw.QtyOnOrd<0 
				!If rtrim$(holdpswd$[3])<>"" LET HFlag[2]=1 ! OOS hold
			endif
			If pr.QtyOnHand-pr.QtyOnOrd<0 
				!If rtrim$(holdpswd$[3])<>"" LET HFlag[2]=1
			endif
		Endif
	Endif ! of onord, etc update
	if roh.ordtype=4
		! moved extensions up (was qtybo-borel) - native = bo+borel		
		if nrol.qtyord<nrol.CurrRelQty+(nrol.QtyBo-nrol.BORelQty)+nrol.PrevQtyShip
			returnstatus=0
			message$="Quantity is over shipped"
			!goto SCDDone ! abort update? let's not
		Endif
	Endif
	if roh.ordtype=15
		! moved extensions up (was qtybo-borel) - native = bo+borel
		!if nrol.qtyord<>nrol.CurrRelQty+(nrol.QtyBo+nrol.BORelQty)+nrol.PrevQtyShip
		if nrol.qtyord<nrol.CurrRelQty+(nrol.QtyBo-nrol.BORelQty)+nrol.PrevQtyShip
			returnstatus=0
			message$="Quantity is Out of Balance"
			!goto SCDDone ! abort update? let's not
		Endif
	Endif
	if roh.ordtype=19
			x3[5]=Nrol.PrevQtyShip+nrol.QtyShip+nrol.QtyBO ! new qty/prev
			!if roh.ordtype=19 and roh.BOCTR<>0 and roh.Ot19Comp=0 let x3[5]=ROL.qtyship ! final ordered=shipped
			if nrol.qtyord<>X3[5] ! rol.PrevQtyShip+rol.QtyShip+rol.QtyBO
				returnstatus=0
				message$="Quantity is unequal. Please adjust (ord=ship+bo+prev)"
				!goto SCDDone ! no abort - just message
			Endif
	Endif
	If ETr.EtAction=0 ! no check yet
			! no hold on price/cost chg - none on native
			if nrol.UnitPrice<>rol.UnitPrice ! diff - is it rounded?
			  if FNC(nrol.UnitPrice)<>FNC(rol.UnitPrice) ! compare at 4 dec
				let ETr.EtAction=23
				!If rtrim$(holdpswd$[5])<>"" let HFlag[4]=1 ! prc chg/hold
			  Endif
			endif
			if nrol.unitcost<>rol.unitCost ! diff - is it rounded?
			  if FNC(nrol.unitcost)<>FNC(rol.unitCost) ! compare 4 dec
				let ETr.EtAction=24
				!If rtrim$(holdpswd$[6])<>"" Hflag[5]=1 ! cost chg/hold
			  Endif
			endif
			If nrol.netprice<>rol.netprice ! diff - is it rounded?
			  If FNC(nrol.netprice)<>FNC(rol.netprice) ! compare to 4 dec
				let etr.etaction=23
				!If rtrim$(holdpswd$[5])<>"" let HFlag[4]=1 ! prc chg/hold
			  Endif
			endif
			if nrol.Qtyord<>rol.QtyOrd let ETr.EtAction=1 ! qty overrides price/cost
			if nrol.QtyBO<>rol.QtyBo let ETr.EtAction=1
			if nrol.QtyShip<>rol.QtyShip let ETr.EtAction=1
			
	Endif
		!if KIT and nrol.QtyShip<>rol.QtyShip let KITCHG=1
	If P60$[44,44]="Y" and etr.EtAction<>0
		! call edttrkdo(rol.,nrol.) ! org, new
	Endif ! of edit tracking
		! now any post update work starts
	! no holds or rasl on quotes
	! resend line to web
	maxcnt=hmaxcnt;dopart=0
	dooneline=rol.linenum ! 1 line send flag
	call getordlines() ! try existing routine
	SCDDone: ! finished
	if returnstatus=1 let message$="OK" ! set if no other problems
	if debugdetail
		dmsg$="Update Cut "+Str$(rol.OrdNum)+"-"+Str$(rol.LineNum)+" "+rol.ProdCode$+Message$ \ Call updatelog(debug)
	Endif
	
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	
  else
    include "src/callsuberr.inc"
 end try
end sub ! SubmitCutDetails
! 
!--------------------------------------------------------------------
Sub dolineextens()
! subroutine for extensions (ALWAYS NROL.!)
! Also recalcs Net Price
  Try
	Dim 3%,CHBase,NetCost
	! REDO EXTENSIONS - From MXLINE
	IF NROL.UMCutChrg=-3 AND Nrol.QtyOrd LET CHBASE=(nrol.CutChrg/nrol.QtyOrd) ELSE  LET CHBASE=nrol.CutChrg 
	LET NRol.NetPrice=nrol.UnitPrice-nrol.LineDisc+CHBASE
	LET NRol.NetPrice=nRol.NetPrice-(nRol.NetPrice*(nrol.LineDiscPct/100))
	IF nrol.UpChrg>0 LET nRol.NetPrice=nRol.NetPrice+(nRol.NetPrice*(nrol.UpChrg/100))
	IF nrol.UpChrg<0 LET nRol.NetPrice=nRol.NetPrice+(0-nrol.UpChrg)
	! LET X2=5 \ GOSUB L_15500: \ LET X2=5 \ GOSUB L_15000: ! TO PRICE UM THEN BACK NET Price
	cnvtu[0]=0;cnvtu[1]=nrol.UMPrice;cnvtu[2]=2
	cnvta=nrol.NetPrice
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	cnvtu[0]=nrol.UMPrice;cnvtu[1]=0;cnvtu[2]=6;cnvta=x3
	nrol.NetPrice=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	IF nrol.UMCutCost=-3 AND nrol.QtyOrd LET CHBASE=(nrol.CutCost/nrol.QtyOrd) ELSE  LET CHBASE=nrol.CutCost
	LET NETCOST=nrol.UnitCost+CHBASE
	IF nrol.LoadUpchrg
	  IF nrol.LoadUpchrg <0
		LET NETCOST=NETCOST+ABS(nrol.LoadUpchrg )
	  ELSE
		LET NETCOST=NETCOST+(NETCOST*(nrol.LoadUpchrg /100))
	  ENDIF
	ENDIF
	! LET X2=16 \ GOSUB L_15500: \ LET X2=11 \ GOSUB L_15000: ! TO COST THEN BACK - NETCOST/W CUT             
	cnvtu[0]=0;cnvtu[1]=nrol.UMCost;cnvtu[2]=2
	IF nrol.UMCost>0 AND nrol.numout LET CNVTA=(NETCOST/nrol.numout) ELSE  LET CNVTA=NETCOST
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	cnvtu[0]=nrol.UMCost;cnvtu[1]=0;cnvtu[2]=6
	IF nrol.UMCost>0 AND nROL.NUMOUT LET CNVTA=x3*nRol.NumOut ELSE  LET CNVTA=x3
	Netcost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	If roh.OrdType=37  ! "EVAP Ship - NO Price - any order in here
		If Not(Credit) Or (Credit And roh.ShipType=16)
			Let nrol.UnitPrice=0;nrol.NetPrice=0;nrol.CutChrg=0
			Let nrol.LineDisc=0;nrol.LineDiscPct=0;nrol.UpChrg=0
		Endif
	Endif
	If roh.OrdType=36 ! "EVAP Billing - NO Cost - Any type order
		If Not(Credit) Or (Credit And roh.ShipType=16)
			Let nrol.UnitCost=0;nrol.CostOrigin=0;nrol.RebtContract=0
			Let nrol.CutCost=0;nrol.ExtCutCost=0;nrol.ExtLoadShip=0;nrol.ExtLoadOrd=0
			nrol.LoadUpchrg=0;NetCost=0
		ENDIF
	Endif
	IF nROL.UMCutChrg=-3 LET nrol.ExtCutChg=nrol.CutChrg ELSE  LET nrol.ExtCutChg=FNR(nrol.CutChrg*nrol.QtyShip)
	IF nrol.UMCutCost=-3 LET nrol.ExtCutCost=nrol.CutCost ELSE  LET nrol.ExtCutCost=FNR(nrol.CutCost*nrol.QtyShip)
	LET nrol.ExtOrdAmt=FNR(nrol.QtyOrd*nRol.NetPrice)
	LET nrol.ExtLoadOrd=FNR(nrol.QtyOrd*NETCOST)
	IF roh.ordtype=4 OR roh.ordtype=15 ! "bill and hold
	  IF roh.ordtype=15 
		if roh.BOCTR=0 let nrol.CurrBillQty=nrol.QtyOrd Else let nrol.CurrBillQty=0
	  Endif
	  LET nrol.ExtShipAmt=FNR(nrol.CurrBillQty*nRol.NetPrice)
	  LET nrol.ExtLoadShip=FNR(nrol.CurrBillQty*NETCOST)
	ELSE
	  LET nrol.ExtShipAmt=FNR(nrol.QtyShip*nRol.NetPrice)
	  LET nrol.ExtLoadShip=FNR(nrol.QtyShip*NETCOST)
	ENDIF
	IF nrol.UMPrice=-2 ! lot
	  LET nrol.ExtOrdAmt=FNR(nRol.NetPrice)*SGN(nrol.QtyOrd)
	  IF roh.ordtype=4 OR roh.ordtype=15
		LET nrol.ExtShipAmt=FNR(SGN(nrol.CurrBillQty)*nRol.NetPrice)
	  ELSE
		LET nrol.ExtShipAmt=FNR(nRol.NetPrice)*SGN(nrol.QtyShip)
	  ENDIF
	ENDIF
	IF nrol.UMCost=-2 ! LOT
	  LET nrol.ExtLoadOrd=FNR(NETCOST*SGN(nrol.QtyOrd))
	  IF roh.ordtype=4 OR roh.ordtype=15
        LET nrol.ExtLoadShip=FNR(NETCOST*SGN(nrol.CurrBillQty))
	  ELSE
		LET nrol.ExtLoadShip=FNR(NETCOST*SGN(nrol.QtyShip))
	  ENDIF
	ENDIF
	nrol.ExtGLCost=FNR(nrol.QtyShip*nrol.UnitGLCost)
	nrol.ExtNetWgt=FNR(Abs((nrol.QtyShip*nrol.LbsUnit)/nrol.WgtFactor))
		if roh.OrdType=8 or roh.OrdType=16 ! cons/trans - no price/cost
			nrol.UnitCost=0;nrol.CostOrigin=0;nrol.RebtContract=0
			nrol.UnitPrice=0;nrol.CutChrg=0;nrol.CutCost=0
			nrol.LineDisc=0;nrol.ExtOrdAmt=0;nrol.ExtShipAmt=0
			nrol.LineDiscPct=0;nrol.ExtCutChg=0;nrol.ExtCutCost=0
			nrol.ExtLoadShip=0;nrol.ExtLoadOrd=0;nrol.NetPrice=0
			nrol.TaxAmt=0;nrol.LoadUpchrg=0;nrol.UpChrg=0
		Endif
		If p61$[46,46]="Y" and Credit and roh.shiptype=3 ! price fix - no cost
			nrol.UnitCost=0;nrol.CostOrigin=0;nrol.RebtContract=0
			nrol.CutCost=0;nrol.ExtCutCost=0;nrol.ExtLoadShip=0;nrol.ExtLoadOrd=0
			nrol.LoadUpchrg=0
		Endif
  	
  else
    include "src/callsuberr.inc"
 end try
end sub ! DoLineExtens
! 
!--------------------------------------------------------------------
Sub GetNetPrcCost()
! get data for netprice or netcost/send it back
  Try
	Dim X$[20],NSFKey$[60]
	dim holdpswd$[12,16]
	Dim SUM$[4],PUM$[4],CUM$[4]
	Dim 1%,CNVTU[2],FLAG[9],X1[9]
	Dim 1%,NewLn,HFlg[16],HFlag[16],Credit
	Dim 2%,X2[9],NumLines,ShipDate,JDate[5]
	Dim 3%,CNVTA,AMOUNT,X3[9],V3[99]
	Dim 3%,WHBLD[2],S9[20]

	Dim NRol. as qol ! store new sent data
	! call dxsave(0,"tmp/olsv.txt!")
	Read #ctlc,3,188;ShipDate; ! for inv levels
	if debugdetail
		dmsg$="Start Calculate Price/Cost" \ Call updatelog(debug)
	Endif
	ReturnStatus=1
	Message$="OK"
	Call DXGet("ORDERID",tmp$)
	If tmp$="" goto CNPCDone:
	OrderNo=tmp$
	If OrderNo<1 or OrderNo>999999 or Fra(OrderNo)
		ReturnStatus=0
		Message$="QUOTE NUMBER INVALID"
		Goto CNPCDone
	Endif
	OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
	e$=""
	If OHR<=0 ! not found
		ReturnStatus=99
		Message$="QUOTE WAS NOT FOUND"
		goto CNPCDone
	Else
		Credit=0 \ if rot.Status=22 let Credit=1 ! instead of roh.status check

	Endif
		E$="" ! clear for this loop
		OLR=0;NewLn=0;KITCHG=0;kit=0
		Clear nrol.
		Clear pr.
		Clear pw.
		Clear etr.
		Clear nstk.
		Call DXGet("LN",tmp$) ! +Str$(X1),tmp$)
		nrol.LineNum=tmp$ ! line # (zero on new lines)
		LineNo=nrol.LineNum
		if nrol.linenum ! get prev data
			rolkey$=" ",rolkey$
			rolkey$[1,6]=OrderNo Using "######"
			rolkey$[7,9]=nrol.linenum using "###"
			rolkey$[11]="" ! cut to length (space @ 10)
			OLR=filegetqolz(e$,OLC,"=",1,rolkey$,rol.)
			clear e$
			if olr<=0 ! what do we do if not found?
				Returnstatus=0
				message$="QUOTE LINE NOT FOUND"
				GOTO CNPCDone
			Endif
			If OLR>0
				if rol.NStkItem=1 and rol.LineType<>3
					NSR=rol.PDRecNum
					Read record #NSC,NSR,0;nstk.
					PRR=0;PWR=0
				Endif
				If Not(rol.NStkItem) ! get prod & whse
					PRR=rol.PDRecNum
					Read record #PRC,PRR,0;pr.;
				Endif ! stk item
			Endif ! existing line
		Else ! no line
			Returnstatus=0
			message$="QUOTE LINE NOT SENT"
			GOTO CNPCDone
		Endif
		If OLR>0 Read Record #OLC,OLR,0;nrol.; ! read with prev values
	Call DXGet("LTYPE",tmp$) ! +Str$(X1),tmp$) ! line type (stk,nstk,msg,del)
		tmp$=UCase$(tmp$)
		ZLine=0;NonStk=0;Stk=0;Delline=0
		if tmp$="MSG" let ZLine=1;NonStk=1
		If tmp$[1,4]="NSTK" let NonStk=1
		if tmp$[1,3]="STK" let Stk=1
		if tmp$[1,4]="CLSD" Let Stk=1 ! goto CNPCDone ! yes - allow it(no Updates)
		if ACTION$="NSBUILDPROD" and olr>0 and not(rol.NStkItem) let stk=1;Nonstk=0 ! web could send as NSTK! NO,NO
		CutLine=0
		If tmp$="INV" and not(nonstk) let cutline=1;Stk=1 ! only cut stock lines
		if tmp$="FIN" and not(nonstk) let cutline=2;Stk=1 ! only cut stock lines
		nrol.Status=11;Credit=0
		if ros.Status=32 let nrol.Status=12;Credit=1 ! determine order/credit?
		nrol.OrdNum=OrderNo
		Call DXGet("UPRICE",tmp$) ! +Str$(X1),tmp$)
		V3[1]=tmp$ ! ALSO ON CUTS - PARENT or CUT
		if v3[1]<0
			returnstatus=0
			message$="NO NEGATIVE PRICE"
			goto CNPCDone
		endif
		If V3[1]>9999999
			returnstatus=0
			message$="Price is out of range"
			goto CNPCDone
		endif
		If V3[1] and rol.UMPrice>0 and (rol.LineType=1 or rol.LineType=2)
			call DXGet("PARCUTP",tmp$) ! if Cut - use as is (SCREEN SHOWS CUT!)
			if UCase$(Trim$(tmp$))="P"
				if rol.numout>0 let v3[1]=FNC(v3[1]/rol.numout)
			Endif
		Endif
		Call DXGet("UCOST",tmp$) ! +Str$(X1),tmp$)
		V3[2]=tmp$ ! ALSO ON CUTS - PARENT OR CUT
		if v3[2]<0
			returnstatus=0
			message$="NO NEGATIVE COST"
			goto CNPCDone
		endif
		If V3[2]>9999999
			returnstatus=0
			message$="Cost is out of range"
			goto CNPCDone
		endif
		if v3[2] and rol.umcost>0 and (rol.LineType=1 or rol.LineType=2)
			call DXget("PARCUTC",tmp$) ! if Cut - use as is (SCREEN SHOWS CUT!)
			if UCase$(Trim$(tmp$))="P"
				if rol.numout>0 let v3[2]=FNC(v3[2]/rol.numout)
			Endif
		Endif
		Call DXGet("LDISC",tmp$) ! +Str$(X1),tmp$)
		nrol.LineDiscPct=tmp$
		call DXGet("QTYORD",tmp$) ! +Str$(X1),tmp$)
		if RTrim$(tmp$)<>""
			let V3[3]=tmp$
		Else ! calc it from line
			cnvtu[0]=0;cnvtu[1]=rol.umsell;cnvtu[2]=1
			Cnvta=rol.QtyOrd \ if rol.numout>0 let cnvta=rol.qtyord*rol.numout
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			let v3[3]=X3
		Endif
		! at start no negative
		x1=roh.ordtype
		if v3[3]<0 and (credit or (x1=4 or x1=7 or x1=8 or x1=15 or x1=16 or x1=19 or x1=24))
			returnstatus=0
			message$="Can not order negative quantity"
			goto CNPCDone
		Endif
		If Abs(V3[3])>9999999
			returnstatus=0
			message$="Order Quantity is out of range"
			goto CNPCDone
		Endif
		Call DXGet("QTYBO",tmp$) ! +Str$(X1),tmp$)
		If RTrim$(tmp$)<>""
			Let V3[4]=tmp$
		Else ! calc it from line
			cnvtu[0]=0;cnvtu[1]=rol.umsell;cnvtu[2]=1
			Cnvta=rol.QtyBO \ if rol.numout>0 let cnvta=rol.qtybo*rol.numout
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			let v3[4]=X3
		Endif
		If Abs(V3[4])>9999999
			returnstatus=0
			message$="Back Order Quantity is out of range"
			goto CNPCDone
		Endif
		Call DXGet("QTYSHIP",tmp$) ! +Str$(X1),tmp$)
		if RTrim$(tmp$)<>""
			Let V3[5]=tmp$
		Else ! calc it from line
			cnvtu[0]=0;cnvtu[1]=rol.umsell;cnvtu[2]=1
			Cnvta=rol.QtyShip \ if rol.numout>0 let cnvta=rol.qtyship*rol.numout
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			let v3[5]=X3
		Endif
		if v3[3]=0 and v3[5] ! no ordered sent - sent shipped
			let v3[3]=v3[4]+v3[5] ! GOT TO HAVE ORDERED!!!
		Endif
		If V3[3]>0 ! new never neg bo and ot4/15 can do neg release
		  if V3[4]<0 or (roh.ordtype<>4 and roh.ordtype<>15 and V3[5]<0)
			returnstatus=0
			message$="Can not have negative BO/Ship quantities!"
			goto CNPCDone
		  Endif
		  IF V3[5]<0 and (roh.ordtype=4 or roh.ordtype=15)
			If nrol.PrevQtyShip<=0 or ABS(V3[5])>nrol.PrevQtyShip
				returnstatus=0
				message$="Negative Ship quantity is invalid!"
				goto CNPCDone
			Endif
		  Endif
		Endif
		if v3[3]<0 and (V3[4]>0 or V3[5]>0)
			returnstatus=0
			message$="Can not have positive Bo/Ship quantities!"
			goto CNPCDone
		Endif
		!if v3[5]<0 and V3[5]<>v3[3] let v3[3]=v3[5] ! no ship more than order
		if v3[3]<0 ! always ship ordered on negative
			v3[5]=v3[3];v3[4]=0
		Endif
		If Abs(V3[5])>9999999
			returnstatus=0
			message$="Ship Quantity is out of range"
			goto CNPCDone
		Endif
		if roh.ordtype=4 ! order type 4 - needs BILLQTY
			call dxget("CURRBILL",tmp$)
			if rtrim$(tmp$)<>"" ! sent it - otherwise ignore
				V3[10]=tmp$
				if v3[3]<0 and v3[10]>0 ! neg line - pos bill? NO
					returnstatus=0
					message$="Can not have positive Bill quantities!"
					goto CNPCDone
				Endif
				if v3[10]<0 ! neg bill allowed
					if nrol.PrevQtyBill<=0 or ABS(v3[10])>nrol.PrevQtyBill
						returnstatus=0
						message$="Negative Bill quantity is invalid!"
						goto CNPCDone
					Endif
				Endif
			Endif ! sent data
			! ON PM Native - it allows overbill with just a prompt
			! check it below (when base)
		Endif ! bill qty - OT4
		! if roh.ordtype=15 let nrol.CurrRelQty=v3[5] ! is relqty
		Call DXGet("PUPCHG",tmp$) ! +Str$(X1),tmp$)
		V3[6]=tmp$
		Call DXGet("PUPTYPE",tmp$) ! +sTR$(X1),tmp$)
		let x$=tmp$
		if x$="$" ! $ is <0  percent is >=0
			let nrol.UpChrg=0-V3[6] ! may need convert
		Else
			let nrol.UpChrg=V3[6]
		Endif
		Call DXGet("UMSELL",tmp$) ! +Str$(X1),tmp$)
		! call programdump("/tmp/ollog10!","")
		!If tmp$[1,1]>"9" ! sent text?
			R=getumrec(e$,CCC,tmp$,IntCo,PR.)
			If R<>0 let tmp$=Str$(R)
		!Endif
		x2=tmp$
		if x2<0 ! no system UM for Qty
			returnstatus=0
			message$="INVALID U/M - SELL"
			goto CNPCdone
		Endif
		if not(nonstk) ! chk u/m
			Flag=ChkPrdUM(e$,X2,IntCo,Pr.)
			if flag=0 ! let x2=pr.UMSellDefault ! unrem / rem below to just change
				ReturnStatus=0
				Message$="INVALID U/M - SELL"
				goto CNPCDone
			Endif
		Endif
		let nrol.UMSell=x2 ! tmp$
		if not(nonStk)
			X3=UMtoFactor(nrol.UMSell)
			rol.SellFactor=X3;nrol.SellFactor=x3
		Endif
		Call DXGet("UMPRICE",tmp$) ! +Str$(x1),tmp$)
		! call programdump("/tmp/ollog11!","")
		!If tmp$[1,1]>"9" ! sent text?
			R=getumrec(e$,CCC,tmp$,IntCo,PR.)
			If R<>0 let tmp$=Str$(R)
		!Endif
		x2=tmp$
		if not(nonstk) ! chk u/m
			Flag=ChkPrdUM(e$,X2,IntCo,Pr.)
			if flag=0 ! let x2=pr.UMPriceDefault ! unrem / rem below to just change
				ReturnStatus=0
				Message$="INVALID U/M - PRICE"
				goto CNPCDone
			Endif
		Endif
		nrol.umprice=x2 ! tmp$
			if not(nonStk)
				X3=UMtoFactor(nrol.umprice)
				rol.PriceFactor=X3;nrol.PriceFactor=x3
			Endif
		Call DXGet("UMCOST",tmp$) ! +Str$(X1),tmp$)
		! call programdump("/tmp/ollog12!","")
		!If tmp$[1,1]>"9" ! sent text?
			R=getumrec(e$,CCC,tmp$,IntCo,PR.)
			If R<>0 let tmp$=Str$(R)
		!Endif
		x2=tmp$
		if not(nonstk) ! chk u/m
			Flag=ChkPrdUM(e$,X2,IntCo,Pr.)
			if flag=0 ! let x2=pr.UMCostDefault ! unrem / rem below to just change
				ReturnStatus=0
				Message$="INVALID U/M - COST"
				goto CNPCDone
			Endif
		Endif
		nrol.UMCost=x2 ! tmp$
			if not(nonStk)
				X3=UMtoFactor(nrol.UMCost)
				rol.CostFactor=X3;nrol.CostFactor=x3
			EndiF
		Call dxget("CUPCHG",tmp$) ! +Str$(X1),tmp$)
		V3[8]=tmp$
		call dxget("CUPTYPE",tmp$) ! +Str$(X1),tmp$)
		X$=tmp$
		if x$="$" ! $ is <0  % is >=0
			nrol.LoadUpchrg=0-V3[8]
		Else
			nrol.LoadUpchrg=V3[8]
		Endif
			! as setprtorol uses rol. needs a setup to new values
			rol.UMBase=nrol.UMBase
			rol.UMSell=nrol.UMSell
			rol.UMCost=nrol.UMCost
			rol.UMPrice=nrol.UMPrice
			rol.UMPurch=nrol.UMPurch
			rol.SellFactor=nrol.SellFactor
			rol.PriceFactor=nrol.PriceFactor
			rol.CostFactor=nrol.CostFactor
			rol.PurchFactor=nrol.PurchFactor
			rol.CubeFactor=nrol.CubeFactor
			rol.WgtFactor=nrol.WgtFactor
		! so nrol. has new, rol. has orig
		Call setprtorol() ! set to rol. factors
		! convert sent to base as sent in display um
		CNVTU[0]=nrol.UMPrice;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
		cnvta=v3[1] \ if nrol.UMPrice>0 and nrol.NumOut>0 let cnvta=v3[1]*nrol.numout
		nrol.UnitPrice=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		CNVTU[0]=nrol.UMPrice;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
		!cnvta=v3[7] \ if nrol.UMPrice>0 and nrol.NumOut>0 let cnvta=v3[7]*nrol.numout
		!nrol.NetPrice=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if nrol.UpChrg<0 ! $ amount
			CNVTU[0]=nrol.UMPrice;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
			cnvta=V3[6] ! still +
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			let nrol.UpChrg=0-x3
		Endif
		CNVTU[0]=nrol.UMCost;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
		cnvta=V3[2]  \ if nrol.UMCost>0 and nrol.NumOut>0 let cnvta=v3[2]*nrol.numout
		nrol.UnitCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if nrol.LoadUpchrg<0 ! it's a $ up
			CNVTU[0]=nrol.UMCost;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
			cnvta=v3[8]
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			nrol.LoadUpchrg=0-X3
		endif

		CNVTU[0]=nrol.UMSell;Cnvtu[1]=0;Cnvtu[2]=1
		cnvta=V3[3] \ IF nrol.NumOut>0 let CNVTA=v3[3]/nrol.NumOut
		nrol.QtyOrd=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		cnvta=V3[4] \ IF nrol.NumOut>0 let CNVTA=v3[4]/nrol.NumOut
		nrol.QtyBO=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		cnvta=V3[5]  \ IF nrol.NumOut>0 let CNVTA=v3[5]/nrol.NumOut
		nrol.QtyShip=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		If roh.ordtype=4 ! Curr Billqty
			cnvta=V3[10] \ if nrol.NumOut>0 let cnvta=v3[10]/nrol.numout
			nrol.CurrBillQty=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		Endif
		if roh.ordtype=4 or roh.ordtype=15
			nrol.CurrRelQty=nrol.qtyship
		Endif
		call dolineextens()
		if roh.OrdType=8 or roh.OrdType=16 ! cons/trans - no price/cost
			nrol.UnitCost=0;nrol.CostOrigin=0;nrol.RebtContract=0
			nrol.UnitPrice=0;nrol.CutChrg=0;nrol.CutCost=0
			nrol.LineDisc=0;nrol.ExtOrdAmt=0;nrol.ExtShipAmt=0
			nrol.LineDiscPct=0;nrol.ExtCutChg=0;nrol.ExtCutCost=0
			nrol.ExtLoadShip=0;nrol.ExtLoadOrd=0;nrol.NetPrice=0
			nrol.TaxAmt=0;nrol.LoadUpchrg=0;nrol.UpChrg=0
		Endif
		If p61$[46,46]="Y" and Credit and roh.shiptype=3 ! price fix - no cost
			nrol.UnitCost=0;nrol.CostOrigin=0;nrol.RebtContract=0
			nrol.CutCost=0;nrol.ExtCutCost=0;nrol.ExtLoadShip=0;nrol.ExtLoadOrd=0
			nrol.LoadUpchrg=0
		Endif
		! ok - now send back
		SUM$=xunit$(NROL.UMSell,ccc) ! u/m
		PUM$=xunit$(NROL.UMPrice,ccc) ! u/m
		CUM$=xunit$(NROL.UMCost,ccc) ! u/m
		Clear List$[]
		If NTPRICE ! net price
			List$[0]=bsdel$,"NETPRICE",fdel$
			WebStr$="UnitPrice",fdel$,"PriceUpchrg",fdel$
			WebStr$=WebStr$,"PriceUpType",fdel$
			WebStr$=WebStr$,"NetPrice",fdel$,"PriceUM",fdel$,"PriceUMID",fdel$
			WebStr$=WebStr$,"ExtPrice",fdel$,"GP%",fdel$
			List$[1]=webstr$
					
			cnvtu[0]=0;cnvtu[1]=nrol.UMPrice;cnvtu[2]=2
			Cnvta=nrol.UnitPrice \ if nrol.umprice>0 and nrol.numout>0 let cnvta=nrol.unitprice/nrol.numout
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			WebStr$=LTrim$(X3 Using PMask$),fdel$ ! Unit price
			! send upcharge as amount & type
			tmp$="%" \ if nrol.UpChrg<0 let tmp$="$"
			Let X3=nrol.UpChrg
			If tmp$="$" ! need convert to price um
				cnvtu[0]=0;cnvtu[1]=nrol.UMPrice;cnvtu[2]=2
				Cnvta=ABS(X3)
				X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			Endif
			WebStr$=WebStr$,Ltrim$(X3 Using PMask$),fdel$,tmp$,fdel$ ! upchrg & type
			cnvtu[0]=0;cnvtu[1]=nrol.UMPrice;cnvtu[2]=2
			Cnvta=nrol.NetPrice \ if nrol.umprice>0 and nrol.numout>0 let cnvta=nrol.NetPrice/nrol.numout
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! net price
			WebStr$=WebStr$,RTrim$(PUM$),fdel$,Str$(nrol.UMPrice),fdel$ ! price um & id
			Let X3=nrol.ExtShipAmt
			WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! net price exten
			IF nrol.UMCutCost=-3 AND nrol.QtyOrd LET CHBASE=(nrol.CutCost/nrol.QtyOrd) ELSE  LET CHBASE=nrol.CutCost
			X3[4]=nrol.UnitCost+CHBase
			X3[3]=X3[4]
			IF nrol.LoadUpchrg ! has cost up
				IF nrol.LoadUpchrg<0 ! $ amount
					X3[3]=x3[4]+Abs(nrol.LoadUpchrg)
				Else ! percent
					X3[3]=X3[4]+(X3[4]*(nrol.LoadUpchrg/100))
				Endif
			Endif ! X3[3]=NETCOST
			NETCOST=X3[3]
			x3=0
			if nrol.NetPrice ! NEEDS A PRICE
				X3=FNR(((nrol.NetPrice-x3[3])/nrol.NetPrice)*100)
			Endif
			WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! GP
			List$[2]=webstr$
			Row=3
		Endif
		If NTCOST ! net cost
			List$[0]=bsdel$,"NETCOST",fdel$
			WebStr$="UnitCost",fdel$,"CostSecurity",fdel$
			WebStr$=WebStr$,"CostUM",fdel$,"CostUMID",fdel$,"CostUpchrg",fdel$
			WebStr$=WebStr$,"CostUpType",fdel$,"ExtCost",fdel$
			WebStr$=WebStr$,"GP%",fdel$,"NETCOST",fdel$ !
			List$[1]=webstr$
			cnvtu[0]=0;cnvtu[1]=nrol.UMCost;cnvtu[2]=2
			Cnvta=nrol.UnitCost \ if nrol.UMCost>0 and nrol.numout>0 let cnvta=nrol.UnitCost/nrol.numout
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			WebStr$=LTrim$(X3 Using PMask$),fdel$ ! unit cost
			WebStr$=WebStr$,Str$(Cost_Lev[1]),fdel$ ! load cost security
			WebStr$=WebStr$,RTrim$(CUM$),fdel$,Str$(nrol.UMCost),fdel$ ! Cost um & id
			! send upcharge as amount & type
			tmp$="%" \ if nrol.LoadUpchrg<0 let tmp$="$"
			Let X3=nrol.LoadUpchrg
			If tmp$="$" ! need convert to cost um
				cnvtu[0]=0;cnvtu[1]=nrol.UMCost;cnvtu[2]=2
				Cnvta=ABS(X3)
				X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			Endif
			WebStr$=WebStr$,Ltrim$(X3 Using PMask$),fdel$,tmp$,fdel$ ! upchrg & type
			IF nrol.UMCutCost=-3 AND nrol.QtyOrd LET CHBASE=(nrol.CutCost/nrol.QtyOrd) ELSE  LET CHBASE=nrol.CutCost
			X3[4]=nrol.UnitCost+CHBase
			X3[3]=X3[4]
			IF nrol.LoadUpchrg ! has cost up
				IF nrol.LoadUpchrg<0 ! $ amount
					X3[3]=x3[4]+Abs(nrol.LoadUpchrg)
				Else ! percent
					X3[3]=X3[4]+(X3[4]*(nrol.LoadUpchrg/100))
				Endif
			Endif ! X3[3]=NETCOST
			NETCOST=X3[3]
			X3=nrol.ExtLoadShip ! FNR(nrol.QtyShip*X3[3]) ! ext net cost
			WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! net cost exten

			x3=0
			if nrol.NetPrice ! NEEDS A PRICE
				X3=FNR(((nrol.NetPrice-x3[3])/nrol.NetPrice)*100)
			Endif
			WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! GP
			cnvtu[0]=0;cnvtu[1]=nrol.umcost;cnvtu[2]=2
			Cnvta=NETCOST \ if nrol.UMCost>0 and nrol.numout>0 let cnvta=NETCOST/nrol.numout
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! net cost
			List$[2]=webstr$
			Row=3
		Endif
	list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])
	CNPCDone: ! finished 
	if returnstatus=1 let message$="OK" ! set if no other problems
	if debugdetail
		dmsg$="Get Net Price/Cost "+Str$(rol.OrdNum)+"-"+Str$(rol.LineNum)+" "+rol.ProdCode$+Message$ \ Call updatelog(debug)
	Endif
	
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	
  else
    include "src/callsuberr.inc"
 end try
end sub ! GetNetPrcCost
! 
!--------------------------------------------------------------------
Sub SProdDtl()
! send details for list entry
  Try
	Dim KPR$[60],KPW$[60],kcm$[40],k1$[50]
	Dim SUM$[4],PUM$[4],CUM$[4]
	Dim 1%,Cnvtu[2],Flag,E,X[9],Pram[5]
	Dim 1%,FCDays,Zline,NonStk
	Dim 2%,X2[9],TaxBack,JDate[5],FDate,ShipDate
	Dim 3%,CNVTA,Amount,x3[9],FutCost,LPR
	Dim 3%,MSHQty,MBOQty,s9[20]
	Clear rol. ! as we will use those vars
	Call DXGet("ORDERID",tmp$)
		if tmp$="" 
			let message$="QUOTE # MISSING"
			Let ReturnStatus=0
			Goto SPEDone:
		Endif
		OrderNo=tmp$
		If OrderNo>0 and OrderNo<999999 and Not(Fra(OrderNo))
			OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
			e$=""
			If OHR<=0 ! no order found
				Let message$="QUOTE # NOT FOUND"
				Let ReturnStatus=99
				Goto SPEDone:
			Endif
		Endif
		if roh.ordtype=15 and roh.boctr<>0 ! no add once accepted!
			Returnstatus=0
			Message$="Invoice has been accepted. No new lines allowed"
			Goto SPEDone:
		Endif
		!if roh.ordtype=19 and roh.BOCtr<>0 and roh.Ot19Comp=0 ! FINAL - NO ADD!
		!	Returnstatus=0
		!	Message$="Final Bill of Order. No new lines allowed"
		!	Goto SPEDone:
		!Endif
		if roh.ordtype=20 ! freight invoice
			Returnstatus=0
			Message$="Order Type=Freight Invoice. No lines are allowed"
			Goto SPEDone:
		Endif
		Call GetCust()
	Credit=0 \ if ros.status=32 let credit=1
		! set list header
		Clear List$[]
		clear slist$[]
		clear tlist$[]
		List$[0]=bsdel$,"PRODUCTDETAIL",fdel$
		WebStr$="ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$,"Commodity",fdel$
		WebStr$=WebStr$,"WHAvail",fdel$,"WHAvlUM",fdel$,"WHAvlUMID",fdel$
		Webstr$=webstr$,"WHSE",fdel$,"QtyUM",fdel$,"QtyUMID",fdel$
		WebStr$=WebStr$,"LTYPE",fdel$ ! include type? ----- ADD WHEN READY  -- ready now
		! added 05/28 - per web send all flags & factors NOW
		webstr$=webstr$,"QTYUMFACT",fdel$,"AvlUmFactor",fdel$
		webstr$=webstr$,"CHKBroken",fdel$,"MBFlag",fdel$
		WebStr$=WebStr$,"SerialNo",fdel$,"CatchWeight",fdel$
		WebStr$=WebStr$,"LotControl",fdel$,"RollLB",fdel$
		WebStr$=WebStr$,"DNReord",fdel$,"BrokenUM",fdel$
		WebStr$=WebStr$,"BrokenUMID",fdel$,"BrokenUMFact",fdel$
		webstr$=webstr$,"STKUPDT",fdel$,"DNRFail",fdel$
		webstr$=webstr$,"CMP",fdel$,"SUB",fdel$,"SPR",fdel$,"ASKLP",fdel$
	List$[1]=webstr$
	row=2
	
	Call DXGet("PRODID",tmp$)
	tmp$=RTrim$(tmp$)
	If tmp$="" Goto SPEDone: ! NEED A PRODUCT!
	Let PROD$=UCase$(tmp$)+Blank$
	If prod$[1,3]="+  " OR PROD$[1,6]="ZNSTK "! it's nonstock
		prod$="Z ZZZZZZZZZZ"
	Endif ! will not have um or qty for messg or nonstk?
	tmp$=ChkAltItem$(e$,IntCo,Prod$,roh.CustNum)
	If tmp$<>"" If tmp$[1,2]<>"  " let prod$=tmp$ ! has alt item
	Let kpr$=Prod$;NonStk=0
	Let kpr$[13]="";e=0 ! no lock
	If prod$[1,3]="Z  " let Nonstk=1;ZLine=1
	If Prod$[1,3]="Z Z" let nonstk=1
	If not(ZLine) ! still get prod for nonstk
	 PRR = filegetprod(e$,PRC,"=",1,KPr$,PR.,e)
	 clear e$
	 If PRR<=0 ! not found
		Let MessagE$=" PRODUCT NOT FOUND" ! +Prod$
		Let ReturnStatus=0
		if debugdetail
			dmsg$=prod$+e$ \ Call updatelog(debug)
		Endif
		Goto SPEDone
	 Endif
	Endif
	! now get whse
	Let kpw$=" ",kpw$;e=0
	kpw$=prod$+roh.Wh Using "##"
	if roh.ordtype=7 let kpw$=prod$+roh.ConsWh Using "##"
	If Not(NonStk)
	 rol.ComdtyCode$=pr.ComdtyCode$+Blank$
	 if roh.ordtype=8 or roh.ordtype=16 ! see if to whse exists
	   If Roh.ConsWh>0 and roh.conswh<100
		Let TPWKey$=" ",tpwKey$
		TPWkey$[1,12]=prod$[1,12]+Blank$
		TPWKey$[13]=ROH.ConsWh Using "##"
		call chktowhse(TPWKey$,pr.PrimVend)
	   Endif
	 Endif
	 PWR=filegetprodwhse(e$,PWC,"=",1,KPw$,PW.,e)
	 clear e$
	 if pwr<0 ! NOT FOUND
		clear pw.
		If P61$[59,59]="Y" or (Credit and (roh.ordtype=7 or roh.ordtype=8)) ! not allowed new prodwhse
			Let MessagE$="Product "+Prod$+"Not Available In this Warehouse"
			Let ReturnStatus=0
			if debugdetail
				dmsg$=e$+" Sysflag 61-59,59 Y "+Str$(roh.wh) \ Call updatelog(debug)
			Endif
			Goto SPEDone
		Endif
	  Endif ! of whse not found
	Else ! is nonstk
	 Clear pw.
	 rol.UpdtStk=0 ! can't happen!
	Endif
	rol.prodcode$=Prod$
	if p60$[30,30]="Y" let HasLPflag=GetAskLP() ! for pricing
	AskLPFlag=0 ! clear it
	! If P61$[25,25]="P"  let AskLPflag=GetAskLP()
	Asklp=0 ! not on quotes?
	! Needs a Prodgroup check (in case single entry!)
	If PW.ProdGrp>0 ! has a group
		Pram[0]=ROH.OrdType !  \ if TScan=2 Let Pram[0]=0-OType
		Pram[1]=PW.ProdGrp
		Pram[5]=0 ! file not opened
		![0]=Order or (-)PO Type
		! [1]=Product Group
		! [2]=Allow on Ord/PO (1=y, 0=N)
		! [3]=Update Stock (1=y, 0=N)
		! [4]=On Price List (0/1)
		! [5]=Channel of 2/ProdGrp#
		Call ProdGroup(e$,intco,Pram[])
		If Pram[2]=0  ! not allowed on OType
			MessagE$="Product "+Prod$+"Not Allowed on this Order Type!"
			returnstatus=0
			if debugdetail
				dmsg$=E$+" OT "+Str$(ROH.OrdType)+" PG "+Str$(PW.ProdGrp) \ Call updatelog(debug)
			Endif
			Goto SPEDone
		Endif
		rol.UpdtStk=Pram[3] ! update Stock
	Endif
	If not(nonStk) and not(credit) ! now a restricted item check
		! set up 
		clear x[]
		clear s9[]
		clear pram[]
		x[1]=PRC;X[2]=CUC ! prod,cust chan
		S9[1]=prr;s9[2]=CUR ! prod,cust records
		pram[2]=roh.wh ! whse to check
		if roh.ordtype=7 let pram[2]=roh.ConsWh ! use consignment?
		Clear tmp2$
		call chkrprod(e$,intco,X[],S9[],PRAM[],Tmp2$)
		if pram[0]=0  ! 0=restrict, <>0=ok
			message$=tmp2$;returnstatus=0
			if debugdetail
				dmsg$=E$ \ Call updatelog(debug)
			Endif
			Goto SPEDone
		Endif
	Endif
	! checking done - now loadit
	rol.UMSell=PR.UMSellDefault
	rol.UpdtStk=0 ! ALWAYS ON A QUOTE!!!
	! as call prodgroup changes updtstk flag - redo it
	IF CREDIT AND roh.ShipType=3 LET rol.UpdtStk=0
	IF CREDIT AND roh.ShipType=7 LET rol.UpdtStk=0
	IF roh.OrdType=16 and ROH.XferAuth=0 let rol.UpdtStk=0 ! whxfer not auth
	if roh.ordtype=15 or roh.ordtype=4 let Cust.BoSAllowedFlag=1 ! will always allow bo's
	IF roh.ordtype=2 or roh.ordtype=5 let rol.UpdtStk=0
	if roh.ordtype=3 and p60$[22,22]<>"Y" LET rol.UpdtStk=0 ! indir no stk
	if custom_customer$="OMAHA"
        ! default ord type 38 to update stock=N cct176559/task10467
		if roh.ordtype=38 let rol.updtstk=0 
	endif
	tmp$=rol.ComdtyCode$
	if tmp$="LABR" OR tmp$="TIME" OR tmp$="MACH" LET rol.UpdtStk=0 ! comm's no stk
	rol.whse=roh.wh
	! quick avail check! If we're here - it's not cutting
	x2[9]=rol.whse \ if roh.ordtype=7 let x2[9]=roh.ConsWh
	If RTrim$(rol.ProdCode$)<>""
		X3[1]=getwhavail(e$,intco,PWC,rol.ProdCode$,X2[9])
	Else
		x3[1]=0 
	Endif
	DNRFail=0
	! note was dnr AND - causes issue - change to IF
	if not(credit) ! credits not DNR check
	 if pw.DNReordFlg=1 If ((ROL.UpdtStk and x3[1]<=0) or (Not(ROL.UpdtStk))) ! dnr and no avail
		!MessagE$="Product "+Prod$+"is a Do Not Reorder!"
		!if debugdetail
		!	dmsg$=E$+" DNR "+Str$(pw.DNReordFlg)+" AVL "+Str$(x3[1]) \ Call updatelog(debug)
		!Endif
		!Goto SPEDone
		DNRFail=1
	 Endif
	Endif ! credit no dnr chk
	SUM$=xunit$(ROL.UMSell,ccc) ! u/m
	rol.linetype=0 \ if zline let rol.linetype=3
	rol.NStkItem=nonstk
	If rol.LineType=3 ! ZLINE
		rol.umsell=0;rol.umprice=0;rol.umcost=0
		SUM$=blank$;PUM$=blank$;CUM$=blank$
	Endif
	tmp$=clrtxtc$(e$,PR.Desc1$) ! chk/clr control chars
	WebStr$=rol.ProdCode$,fdel$,RTrim$(tmp$),fdel$ ! prod code & desc 1
	tmp$=clrtxtc$(e$,PR.Desc2$) ! chk/clr control chars
	WebStr$=WebStr$,RTrim$(tmp$),fdel$,RTrim$(rol.ComdtyCode$),fdel$
	! whse available
	If rol.NStkItem or rol.LineType=3
		let X3[1]=0
	Endif
	Cnvtu[0]=0;Cnvtu[1]=rol.UMSell;Cnvtu[2]=1
	CNVTA=X3[1] \ IF ROL.NUMout>0 let cnvta=x3[1]*rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$,RTrim$(SUM$),fdel$ ! whse avail / um
	WebStr$=WebStr$,Str$(ROL.UMSell),fdel$ ! avl um id
	tmp$=Str$(roh.Wh) \	if roh.ordtype=7 let tmp$=Str$(roh.ConsWh)
	Webstr$=webstr$,tmp$,fdel$,RTrim$(SUM$),fdel$
	WebStr$=WebStr$,Str$(ROL.UMSell),fdel$
	tmp$="STK";X2=rol.LineType
		if rol.NStkItem LET TMP$="NSTK"
		if rol.NStkItem AND X2=3 LET TMP$="MSG"
		IF X2=1 let tmp$="INV"
		If X2=2 LET TMP$="FIN"
		! ot 19 - if header flag=0 or prevship=ordered - it is closed
		if roh.ordtype=19 and Rol.QtyOrd<>0 and rol.PrevQtyShip=rol.QtyOrd let tmp$="CLSD" ! ALL SHIPPED-PARTIAL
		!if roh.ordtype=19 and roh.BOCTR<>0 and roh.ot19comp=0 let tmp$="CLSD" ! FINAL
		WebStr$=WebStr$,RTRIM$(TMP$),FDEL$ ! line type
	X3=UMtoFactor(ROL.UMSell)
	Webstr$=Webstr$,Str$(X3),fdel$,Str$(X3),fdel$ ! qty&avail factor
	
	if rol.NStkItem ! make sure flags correct
		pw.ChkBrknQty$="N";pr.MBFlg$="B"
		pr.SerNoTrack$="N";pr.CatchwgtItem$="N"
		pr.LotCtrl$="N";pr.RollLbItem$="N"
		! pw.DNReordFlg=1
	Endif
	if pw.ChkBrknQty$<>"N" let pw.ChkBrknQty$="Y" ! Y is default
	!if roh.ordtype=19 and roh.BOCTR<>0 and roh.ot19comp=0 let pw.ChkBrknQty$="N" ! closed
	WebStr$=Webstr$,pw.ChkBrknQty$,fdel$,pr.MBFlg$,fdel$ ! chk brkn, make/buy
	let pr.SerNoTrack$="N";pr.LotCtrl$="N" ! can't do IT'S A QUOTE!!
	!if roh.ordtype=19 and roh.BOCTR<>0 and roh.ot19comp=0 let pr.SerNoTrack$="N" ! closed
	WebStr$=WebStr$,pr.SerNoTrack$,fdel$,pr.CatchwgtItem$,fdel$ ! s/n, catchwgt
	WebStr$=WebStr$,pr.LotCtrl$,fdel$,pr.RollLbItem$,fdel$ ! lotcontrol, roll/lb
	tmp$=XUNIT$(pr.UMBrknQty,ccc)
	WebStr$=WebStr$,Str$(pw.DNReordFlg),fdel$,RTrim$(tmp$),fdel$ ! DNReord, brkn um
	X3=UMtoFactor(pr.UMBrknQty)
	WebStr$=WebStr$,Str$(pr.UMBrknQty),fdel$,Str$(X3),fdel$ ! um id, um factor
	tmp$="N" \ if rol.UpdtStk=1 let tmp$="Y"
	webstr$=webstr$,tmp$,fdel$	! stock update
	tmp$="N" \ if DNRFail=1 let tmp$="Y"
	Webstr$=Webstr$,tmp$,fdel$ ! DNR Failed!
	if not(nonstk)
		x1=ComplFlag(e$,PRC,IntCo,Prod$)
		webstr$=webstr$,Str$(X1),fdel$ ! complementary 0/1  N/Y
		X1=SubItmFlag(e$,PRC,IntCo,Prod$)
		webstr$=webstr$,Str$(X1),fdel$ ! substitute 0/1  N/Y
		X1=SPRCIFlag(e$,PRC,IntCo,Prod$)
		webstr$=webstr$,Str$(X1),fdel$ ! supercede 0/1  N/Y
		x1=0 ! =asklp
		Webstr$=Webstr$,Str$(X1),fdel$ ! ask if sub (not on quotes?)
	Else
		webstr$=webstr$,"0",fdel$,"0",fdel$,"0",fdel$,"0",fdel$
	Endif
	List$[2]=webstr$
	List$[3]=esdel$ ! done
	Call AddToStr(e$,rstr$,List$[])
	Goto SPEDone ! Do we need to send super/subst list?
	! send supersede list
	Whse=roh.Wh \	if roh.ordtype=7 let Whse=roh.ConsWh
	OType=roh.ordtype
	Call SPRCIList(e$,IntCo,TList$[],maxcnt,ctlc,prc,whc,ccc,Prod$,Whse,OType)
	e$=""
	call AddToStr(e$,rstr$,TList$[])
	! send subs list? - lets
	
	Call SubstIList(e$,IntCo,SList$[],maxcnt,ctlc,prc,whc,ccc,Prod$,Whse,OType)
	e$=""
	call AddToStr(e$,rstr$,SList$[])

	SPEDone: ! finished
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	
  else
    include "src/callsuberr.inc"
 end try
end sub ! SProdDtl
! 

!--------------------------------------------------------------------
Sub CalcDirLoad()  
!!! note if flag is set, the system will recalculate load everytime the g/l cost is change, regardless of order type
	Try
		dim 1%,wh,scr
		Dim 1%,nsch[10],nstat,2%,nsltbl,3%,nscost
		DIM 2%,LTBL
		dim K5$[45],3%
		returnstatus=1
		message$="OK"
		if p61$[116,116]<>"Y"
			returnstatus=0
			let message$="Option to Calculate Direct Load Cost Not Available"
			goto endcalcdirload:
		endif
		Call dxget("ORDERID",tmp$)                           
		orderno = tmp$  
		If orderno <= 0 Or orderno > 999999 Or Fra(orderno)
			let returnstatus=0
			let message$="Invalid Order Id "
			goto endcalcdirload:
		endif
		OHR = GetOrdRec(e$,OHC,OSC,otc,orderno,roh.,ros.,rot.)
		e$=""
		If OHR <= 0 ! not found                                
			ReturnStatus = 99                                     
			Message$ = "ORDER WAS NOT FOUND"                     
			Goto endcalcdirload:
		endif
		!if roh.ordtype<>2
		!	returnstatus=0
		!	let message$="Order "+str$(orderno)+" Not a direct order type "
		!	goto endcalcdirload:
		!endif
		Call Dxget("GLCOST",tmp$)
		let v3[9]=tmp$
		if v3[9]<=0
			returnstatus=0
			let message$="No General Ledger Cost "
			goto endcalcdirload:
		endif
		Call dxget("LN",tmp$) ! +Str$(X1),tmp$)         
		LineNo = tmp$ ! line # (zero on new lines)
		If LineNo <= 0 Or LineNo > 999 Or Fra(lineno)  
			ReturnStatus = 0                                   
			Message$ = "INVALID ORDER LINE!"
			GOTO endcalcdirload:				
		End If   
		rolkey$ = " ",rolkey$                         
		rolkey$[1,6] = orderno Using "######"         
		rolkey$[7,9] = LineNo Using "###"       
		rolkey$[11] = "" ! cut to length (space @ 10) 
		OLR = filegetqolz(e$,OLC,"=",1,rolkey$,rol.)
		clear e$
		if olr<=0
			returnstatus=0
			Message$="Order Line Not Found"
			GOTO endcalcdirload:
		endif
		let prodkey$=rol.prodcode$
		if rol.NStkItem = 1 ! nonstock item #1
			Read #1,182,4;nsltbl;
			if nsltbl<=0
				let returnstatus=0
				Message$="No Load Table for Nonstocks"
				goto endcalcdirload:
			endif
			Call SetPRtoRol()
			if v3[9]>0 ! sent glcost
				CNVTU[0]=rol.UMCost;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
				cnvta=v3[9] \ if rol.UMCost>0 and rol.NumOut>0 let cnvta=v3[9]*rol.numout
				rol.UnitGLCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			else
				call dxget("GLCOST",tmp$)
				if rtrim$(tmp$)<>""
					if rtrim$(tmp$)="0" or rtrim$(tmp$)="0.0" or rtrim$(tmp$)="0.00"
						let rol.unitglcost=0
					endif
				endif
			endif
			let nsch[0]=ctlc         
			LET NSCH[1]=0 ! load markup channel
			let nsch[2]=olc! sales order line channel
			Parm[0]=281 ! order entry/edit
			Parm[1]=nsltbl ! 
			Parm[2]=olr ! line record #
			Parm[3]=roh.ordtype ! order type
			nsstat=1
			Let NSCOST=rol.UnitGlCost ! set to load cost
			Call "NSLOAD.dl4",NSCH[],PARM[],NSCOST,NSSTAT
			LET rol.UnitCost=NSCOST
		else ! product 
			let prr=rol.PDRecNum
			Read Record #prc,prr;pr.;
			if v3[9]>0 ! sent glcost
				CNVTU[0]=rol.UMCost;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
				cnvta=v3[9] \ if rol.UMCost>0 and rol.NumOut>0 let cnvta=v3[9]*rol.numout
				rol.UnitGLCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			else
				call dxget("GLCOST",tmp$)
				if rtrim$(tmp$)<>""
					if rtrim$(tmp$)="0" or rtrim$(tmp$)="0.0" or rtrim$(tmp$)="0.00"
						let rol.unitglcost=0
					endif
				endif
			endif
			if p9$[32,32]="Y"
				k5$[1,12]=pr.prodcode$[1,12]
				k5$[13]=rol.Whse Using "##"
				PWR=filegetprodwhse(e$,PWC,"=",1,k5$,pw.)
				clear e$
				if pwr<0
					let returnstatus=0
					Message$="No Load Table for Product Warehouse "
					goto endcalcdirload:
				endif
				if pw.Load1MupTbl<=0
					let returnstatus=0
					Message$="No Load Table for Product Warehouse "
					goto endcalcdirload:
				Endif
				let ltbl=pw.Load1MupTbl
			else
				let ltbl=pr.Load1MupTbl
			endif		
			if ltbl>0
				LET PREC[0]=prr ! product record #    
				if pr.lbsfact<=0 let pr.lbsfact=1
				leT PREC[2]=FNR(ABS((ROL.LbsUnit*ROL.QtyOrd)/pr.LbsFact)) ! ext weight of line (ordered)  
				IF ROL.LbsUnit<>0 AND ROL.LbsUnit<>pr.lbsunit! line lbs different from prod file lbs         
					LET PREC[3]=ROL.LbsUnit                                                      
				ELSE                                                                     
					LET PREC[3]=0                                                          
				ENDIF                                                                    
				LET CNVTA=rol.unitglcost ! use g/l cost                             
				LET SCR=-roh.ordtype ! negative otyp means force the base cost   
				!Enter OTYPE,WH,LTBL,PREC[],CNVTA,IntCo,e$,rstr$
				CALL "MXLOAD5.DL4",SCR,WH,LTBL,PREC[],CNVTA,IntCo,e$,rstr$                               
				let rol.unitcost=cnvta 
			else
				let returnstatus=0
				Message$="No Load Table for Product"
				goto endcalcdirload:
			endif
		endif ! #1
		if not(rol.unitcost)
			let returnstatus=0
			Message$="No Load Table for Product"
			goto endcalcdirload:
		endif
		IF rol.UMCutCost=-3 AND nrol.QtyOrd LET CHBASE=(nrol.CutCost/nrol.QtyOrd) ELSE  LET CHBASE=nrol.CutCost
		X3[4]=rol.UnitCost+CHBase
		X3[3]=X3[4]
		IF rol.LoadUpchrg ! has cost up
			IF rol.LoadUpchrg<0 ! $ amount
				X3[3]=x3[4]+Abs(nrol.LoadUpchrg)
			Else ! percent
				X3[3]=X3[4]+(X3[4]*(nrol.LoadUpchrg/100))
			Endif
		Endif ! X3[3]=NETCOST
		NETCOST=X3[3]
		endcalcdirload: ! end calc distribution
		Clear List$[]
		list$[0]=bsdel$,"LOADCOST",fdel$
		List$[1]="UNITCOST",fdel$,"NETCOST",fdel$
		let row=2	
		if returnstatus=1 ! #1
			webstr$=""
			CNVTU[0] = 0;CNVTU[1] = rol.UMCost;CNVTU[2] = 2                 
			CNVTA = rol.UnitCost                                            
			Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.) 
			let webstr$=webstr$+str$(amount)+fdel$ ! new line unit cost
			cNVTU[0] = 0;CNVTU[1] = rol.UMCost;CNVTU[2] = 2                 
			CNVTA = netcost                                           
			Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.) 
			let webstr$=webstr$+str$(amount)+fdel$ ! new line unit cost
			let list$[row]=webstr$
			let row=row+1
		endif  ! #1
		list$[row]=esdel$
		e$=""
	    call AddToStr(e$,rstr$,List$[]) ! add droplist to string  
	 
	  ! status section
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
	  ! status section
	   
 else
    include "src/callsuberr.inc"
 end try
end sub ! CalcDirLoad

!--------------------------------------------------------------------
Sub Getiolines()
! get the lines front end wants
  try
	Dim KOL$[60],KPW$[60],KCM$[50],KLP$[60]
	Dim ZOL$[60],GPID$[20]
	Dim 1%,FCDays,cnvtu[2],elflag
	Dim 2%,OrderNo,row,tmpcnt,JDate[5],FDate
	Dim 3%,OLR,FutCost,CNVTA,Amount

	Dim ZROL. as qol ! for zlines (get data for it before sending line)
	if debugdetail
		dmsg$="Start get Requested Lines" \ Call updatelog(debug)
	Endif
	Read #ctlc,2,198;FCDays; ! days to check future cost
	If FCDays<1 or FCDays>999 or Fra(FCDays) Let FCDays=30 ! check range
	ReturnStatus=1
	Message$="OK"
	Call DXGet("ORDERID",tmp$)
	X2=tmp$
	If X2<1 or X2>999999 or Fra(X2) ! not valid
		ReturnStatus=0
		Message$="ORDER NOT PASSED"
		goto giolDone:
	Endif
	OrderNo=x2
	OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
	e$=""
	If OHR<=0 ! not found
		ReturnStatus=0
		Message$="ORDER NOT FOUND"
		goto giolDone:
	Endif
	Call GetCust()
	CREDIT=0 \ if ros.status=32 let credit=1
	if credit and roh.ShipType=3 let cost_lev[1]=0 ! no cost on cm price error
	! set list header (SIMILAR TO PRODDETAIL ACTION!)
	elflag=9 ! existing Line Flag (for detail to string) as add'l fields needed
		Clear List$[]
		List$[0]=bsdel$,"LINEDETAIL",fdel$
		call MainDtlHdr() ! set webstr$ for main header/LineMainDtl
		List$[1]=WebStr$
		Row=2;tmpcnt=maxcnt
	! okay - see if lines
	call dxget("NUMITEMS",tmp$) ! number of items wanted (lines/prods)
	if rtrim$(tmp$)="" 
		returnstatus=0
		message$="Number of items wanted was not sent"
		goto GIOLFIN ! 
	Endif
	let NumItems=tmp$
	if numitems<=0 or numitems>999 or fra(numitems)
		returnstatus=0
		message$="Number of items wanted is invalid"
		goto GIOLFIN ! 
	Endif
	GN0=0
	! okay loop thru (start at 1!)
	NxtGILoop: ! 
	GN0=GN0+1 \ if GN0>NumItems goto GIOLFin ! reached max
	call dxget("LINENO"+Str$(GN0),tmp$) ! could be blank/zero/null
	GLNO=tmp$
	if GLNO<0 or GLNO>999 or fra(GLNO)
		returnstatus=0
		message$="Line # "+Str$(GN0)+" is invalid"
		goto gioldone ! 
	Endif 
	Call dxget("PRODID"+Str$(GN0),tmp$) ! could be blank/null
	GPID$=UCASE$(RTRIM$(tmp$))+Blank$
	GPID$[13]="" ! cut to length
	if glno=0 and RTrim$(GPID$)="" goto nxtgiloop ! nothing sent - next
	KOL$=" ",KOL$;NumLines=0
	KOL$=OrderNo Using "######"
	if RTrim$(GPID$)<>"" ! sent prod - look for it first
		PrR=filegetprod(e$,PRC,"=",1,GPID$,PR.) ! product mode=2 dir=1
		clear e$
		NonStk=0
		if PRR<=0 let NONSTK=1
		let ldir=2 \ if nonstk let ldir=1
		if ldir=2 
			let kol$[1,6]=PRR USING "######"
			kol$[7,12]=OrderNo using "######"
		endif
		IF NONSTK ! check for spaces BEfor order (web doesn't send 'em)
			search GPID$[1],"-",pos0
			if pos0 ! has a dash so before is order# - after line #
				let x2=GPID$[1,pos0-1]
				let tmp$=x2 using "######" ! make it 6
				let tmp$[7]=gpid$[pos0] ! should be -000
				let gpid$[1,12]=tmp$+blank$
			endif
		endif
		grlolloop:
		search #OLC,3,ldir;kol$,olr,E
		if e goto nxtgiloop
		if ldir=2 ! prod rec
			x2=kol$[1,6] \ if x2<>prr goto nxtgiloop ! done with prod rec
		endif
		let x2=kol$[1,6] \ if ldir=2 let x2=kol$[7,12]
		if x2<>OrderNo goto nxtgiloop ! done with order
		
		Read record #OLC,OLR,0;rol.;
		
		if rol.ProdCode$[1,12]<>GPID$[1,12] goto grlolloop ! diff prod
		if rol.OrdNum<>OrderNo goto nxtgiloop ! another ord# check
		gosub StrtDetailforReq
		goto grlolloop ! next prod?
	Else ! no prodcode - get this line
	  if glno ! want this line!
		kol$[7,9]=GLNO Using "###"
		search #OLC,2,1;kol$,olr,e
		if e
			returnstatus=0
			message$="Order Line "+Str$(GLNO)+" not found"
			goto giolfin
		endif
		gosub StrtDetailforReq ! send line detail
	  Endif
	Endif
	Goto NxtGILoop ! done or neither was sent?
	! same for both options
	StrtDetailforReq: ! 
	read record #OLC,OLR,0;rol.;
	if (roh.OrdType=21 or roh.OrdType=22) and kol$[7,9]="   " goto bprldtl ! ot 21/22
	!x2=kol$[7,9] \ if dooneline and x2<>dooneline exit do ! only want 1 line
		NonStk=rol.NStkItem
		ZLine=0 \ if rol.LineType=3 and NonStk let ZLine=1 ! need for later
		! get/read appropriate records (prod,prodwhse,comm,lastprice
		If Not(NonStk) ! it's a prod
			PRR=rol.PDRecNum
			Read record #PRC,PRR,0;PR.;
			if roh.ordtype=8 or roh.ordtype=16
			  If Roh.ConsWh>0 and roh.conswh<100
				Let TPWKey$=" ",tpwKey$
				TPWkey$[1,12]=rol.prodcode$+Blank$
				TPWKey$[13]=ROH.ConsWh Using "##"
				call chktowhse(TPWKey$,pr.PrimVend)
			  Endif
			Endif
			KPW$=" ",KPW$
			Kpw$=rol.prodcode$+rol.whse Using "##"
			IF roh.ordtype=7 let Kpw$=rol.prodcode$+ROH.ConsWh Using "##"
			PWR=filegetprodwhse(e$,PWC,"=",1,KPW$,pw.)
			clear e$
			if PWR<0 ! not found
				Clear pw.
				If PWR=-1 ! not found - add?
					E$="";x3=kpw$[13,14]
					if roh.ordtype=7
						x3[1]=rol.whse/100
						x3=x3+x3[1]
					Endif
					Whbld[0]=PWC;Whbld[1]=X3;WhBld[2]=pr.PrimVend
					if x3<>1 let Whbld[1]=X3+.01 ! fra=copy whse 1
					Call mxwhcreate(e$,IntCo,rol.PRODCode$,WHBLD[])
					PWR=Whbld[2]
					Read record #PWC,PWR,0;PW.;
				Endif
			Endif
			If rol.ComdtyCode$="" or rol.ComdtyCode$=Blank$[1,4]
				rol.ComdtyCode$=pr.ComdtyCode$
			Endif
		Else
			Clear pr.
			Clear pw.
		Endif
		! always set up pr. w/line factors
		LineNo=rol.LineNum
		Call SetPRtoRol()
		KCM$=" ",KCM$
		KCM$=rol.ComdtyCode$+Blank$[1,4];kcm$[5]=""
		CMR=filegetcommhead(e$,cmc,"=",1,KCM$,cmc.)
		clear e$
		If CMR<1 Clear cmc.
		KLP$=" ",KLP$ ! look for lastprice record
		klp$[1,6]=ROH.custnum using "######"
		X2=rol.dept \ if P9$[44,44]<>"Y" let x2=0
		KLP$[7,10]=X2 Using "####"
		If Not(NonStk)Let KLP$[11]=rol.prodcode$
		If NonStk Let KLP$[11]=rol.VendItemCode$ ! is diff on nonstks!
		tmp$=KLP$ ! only know/can send up to prod
		LPR=filegetlastprice(e$,LPC,">",1,KLP$,CLP.)
		clear e$
		If klp$[1,22]<>tmp$[1,22] let lpr=-1
		If LPR<=0 clear clp.
		FlePtr[4,1]=LPR ! is used this way elsewhere
		FutCost=0
		If Not(NonStk) ! can only call price for futcost on stock items
			Call SetUpSpecs() ! get specs info for fut cost
			! future cost = cost as of xx days from today (specs[5] chg)
			JDate=TIM(6)+FCDays ! ## days from today
			tmp$=JDate$(jdate) ! from ddddd to MM/DD/YYYY
			tmp1$=Formatdate2$(tmp$) ! now MM/DD/YYYY to YYYYMMDD
			Let FDate=tmp1$[3,8] ! just need yymmdd
			Let Specs[5]=0-FDate
			Call getprice() ! call price w/all entries above
			If Specs[0]=0 ! okay
				Let X3=Specs[17]
				cnvtu[0]=0;cnvtu[1]=rol.UMCost;cnvtu[2]=2
				Cnvta=X3 \ if rol.umcost>0 and rol.numout>0 let cnvta=x3/rol.numout
				FutCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			Endif
		Endif ! of stk item - get future cost
		if roh.OrdType=8 or roh.OrdType=16 ! cons/trans - no price/cost
			rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
			rol.UnitPrice=0;rol.CutChrg=0;rol.CutCost=0
			rol.LineDisc=0;rol.ExtOrdAmt=0;rol.ExtShipAmt=0
			rol.LineDiscPct=0;rol.ExtCutChg=0;rol.ExtCutCost=0
			rol.ExtLoadShip=0;rol.ExtLoadOrd=0;rol.NetPrice=0
			rol.TaxAmt=0;rol.LoadUpchrg=0;rol.UpChrg=0
		Endif
		If p61$[46,46]="Y" and Credit and roh.shiptype=3 ! price fix - no cost
			rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
			rol.CutCost=0;rol.ExtCutCost=0;rol.ExtLoadShip=0;rol.ExtLoadOrd=0
			rol.LoadUpchrg=0
		Endif
		If roh.OrdType=37  ! "EVAP Ship - NO Price - any order in here
			If Not(Credit) Or (Credit And roh.ShipType=16)
				Let rol.UnitPrice=0;rol.NetPrice=0;rol.CutChrg=0
				Let rol.LineDisc=0;rol.LineDiscPct=0;rol.UpChrg=0
				rol.ExtOrdAmt=0;rol.ExtShipAmt=0;rol.ExtCutChg=0
			Endif
		Endif
		If roh.OrdType=36 ! "EVAP Billing - NO Cost - Any type order
			If Not(Credit) Or (Credit And roh.ShipType=16)
				Let rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
				Let rol.CutCost=0;rol.ExtCutCost=0;rol.ExtLoadShip=0;rol.ExtLoadOrd=0
				rol.LoadUpchrg=0;NetCost=0
			ENDIF
		Endif
		Call LineMainDtl() ! set up web string
		NumLines=NumLines+1
	 BPRLDTL: ! bypass line (ot21/22)
	Return ! Goto NxtGILoop
	GIOLFIN:  !
	List$[row]=esdel$ ! finished
	e$=""
	call AddToStr(e$,rstr$,List$[])
	giolDone: ! finished
	! status section
	if debugdetail
		dmsg$="Selected Lines "+Str$(Orderno)+" TTL "+Str$(NumLines)+" "+Message$ \ Call updatelog(debug)
	Endif
	!if not(dooneline)
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
	!Endif ! don't send on one line get
	! 
	! call programdump("/tmp/ollog7!","")
  else
    include "src/callsuberr.inc"
 end try
end sub ! Getiolines
! 
!--------------------------------------------------------------------
SUB prcamalg()
! call off to mx201wt for price amalgamation
! and then resend all the lines (can be optional with changes)
  try
	
	Dim 1%,FCDays,cnvtu[2],elflag,PChan[99]
	Dim 2%,OrderNo,row,tmpcnt,JDate[5],FDate
	Dim 3%,OLR,FutCost,CNVTA,Amount
	Dim 1%,H4[2],SO[20],P3,2%,N0,H5[16],H0[12],H6[8]
	Dim 3%,R[50],S9[9]

	Dim ZROL. as qol ! for zlines (get data for it before sending line)
	if debugdetail
		dmsg$="Start Amalgamate Lines" \ Call updatelog(debug)
	Endif
	if p60$[12,12]<>"Y" ! NOT
		returnstatus=0
		message$="NO PRICE AMALGAMATION"
		goto pamdone
	endif
	MaxLines=50 ! per front end - send these # of lines at a time
	Read #ctlc,2,198;FCDays; ! days to check future cost
	If FCDays<1 or FCDays>999 or Fra(FCDays) Let FCDays=30 ! check range
	ReturnStatus=1
	Message$="OK"
	Call DXGet("ORDERID",tmp$)
	X2=tmp$
	If X2<1 or X2>999999 or Fra(X2) ! not valid
		ReturnStatus=0
		Message$="QUOTE NOT PASSED"
		goto pamDone:
	Endif
	OrderNo=x2
	OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
	e$=""
	If OHR<=0 ! not found
		ReturnStatus=0
		Message$="QUOTE NOT FOUND"
		goto pamDone:
	Endif
	Call GetCust()
	CREDIT=0 \ if ros.status=32 let credit=1
	r[50]=3 ! always quote
	! if credit and source<=0 let source=241
	let s9[2]=ohr;s9[4]=source
	if s9[4]<=0 let s9[4]=281 ! quote!
	pchan[1]=prc;pchan[2]=CMC;pchan[3]=OLC
	pchan[4]=btc;pchan[5]=NSC;pchan[6]=PWC
	pchan[7]=CCC;pchan[8]=cphc;pchan[9]=splc
	pchan[10]=CUC;pchan[11]=OHC
	Mat read #ohc,ohr,0;H0;
	mat read #ohc,ohr,78;H4;
	mat read #ohc,ohr,104;h5;
	mat read #ohc,ohr,408;h6;
	let p3=h6[0] ! price type
	if p3<=0 let p3=cust.PriceType
	if p3<=0 let p3=1
	mat read #cuc,cur,502;so;
	let n0=orderno
	
	call "mx201wt.dl4",H4[],SO[],P3,N0,H5[],H0[],R[],S9[],Intco,PChan[]
	! no passing of issues back from call?
	! we can also (and possibly should send back the lines)
	let dooneline=0;DoPart=0 ! so gets all
	Call getordlines()
	goto pamexit ! NO NEED FOR STATUS - (it's in getordlines)
	pamdone: ! finished
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	pamexit: ! bypass status
  else
    include "src/callsuberr.inc"
 end try
end sub ! prcamalg
! 
!--------------------------------------------------------------------
Sub ProduceCPIAlerts()
! take update from CPI exception page and
! produce alerts
 Try
	if p61$[111,111]="N"
		message$ = "CPI NOT ENABLED AND CPI ALERT CALL DONE!"
		returnstatus=0
		goto CPIAlertsDone:
	end if
	Call DXGet("ORDERID",tmp$)
	if tmp$="" 
		let message$="QUOTE # MISSING"
		Let ReturnStatus=0
		Goto CPIAlertsDone:
	Endif
	OrderNo=tmp$
	If OrderNo>0 and OrderNo<999999 and Not(Fra(OrderNo))
		OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
		e$=""
		If OHR<=0 ! no order found
			Let message$="QUOTE # NOT FOUND"
			Let ReturnStatus=99
			Goto CPIAlertsDone:
		Endif
	Endif
	Call GetCust()
	ReturnStatus=1
	Message$="OK" 
	goto CPIAlertsDone ! alerts on Quotes?
	! per the group NO QUOTE ALERTS FOR CPI
	Call DXGet("TTLCPIS",tmp$)
	Let NumCPIs=tmp$
	if NumCPIs<1 ! HAS TO BE AT LEAST 1!
		let message$="NO NUMBER OF CPI REPONSES SENT"
		Let ReturnStatus=0
		Goto CPIAlertsDone:
	Endif
	
	Credit=0 \ if ros.status=32 let credit=1
	if credit
		let message$="CREDIT SHOULD NOT GENERATE CPI ALERTS!"
		Let ReturnStatus=0
		Goto CPIAlertsDone:
	end if
	! set list header
	Clear List$[]
	!DOCPI=0 \ if userid$[1,4]="JIMS" or userid$[1,2]="S8" let docpi=1 ! temp for test
	cpiflag=0;tmpcnt=maxcnt;Custno=roh.CustNum
	clear list$[]
	! ok - make a call & check results if exceptions - status=11 and results in list$
	Call CPIOrdAlerts(e$,intco,NumCPIs,ctlc,OrderNo,roh.,ros.,rot.,CUC)
	CPIAlertsDone: ! finished
	! status section
	If ReturnStatus=1 let message$="OK"
	if returnstatus<>1 and message$="" let message$=E$ ! as there are 99's?
	if debugdetail
	dmsg$="CPI Generate Alerts "+Str$(Orderno)+" TTL IN "+Str$(NumCPIs)+" "+Message$ \ Call updatelog(debug)
	Endif
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
 else
    include "src/callsuberr.inc"
 end try
end sub ! ProduceCPIAlerts
!--------------------------------------------------------------------
Function GetAskLP()
	try
		Dim LPKey$[60]
		If LPR<=0 ! did not find or get yet - look for it
			LPKey$=" ",LPKey$
			LPKey$[1,6]=Roh.CustNum using "######"
			X2=roh.dept \ if P9$[44,44]<>"Y" let x2=0
			LPkey$[7,10]= X2 Using "####"
			If Not(NonStk) let LPKey$[11]=rol.prodcode$
			If NonStk let LPKey$[11]=rol.VendItemCode$
			tmp$=LPKey$
			LPR=filegetlastprice(e$,LPC,">",1,LPKey$,CLP.)
			clear e$
			If lpkey$[1,22]<>tmp$[1,22] let lpr=-1
			!  nothing for main cust try again with pricemaster
			If LPR<=0 and cust.LpPpGrpCust
				clear clp.
				LPKey$=" ",LPKey$
				LPKey$[1,6]=cust.LpPpGrpCust using "######"
				X2=roh.dept \ if P9$[44,44]<>"Y" let x2=0
				LPkey$[7,10]= X2 Using "####"
				If Not(NonStk) let LPKey$[11]=rol.prodcode$
				If NonStk let LPKey$[11]=rol.VendItemCode$
				tmp$=LPKey$
				LPR=filegetlastprice(e$,LPC,">",1,LPKey$,CLP.)
				clear e$
				If lpkey$[1,22]<>tmp$[1,22] let lpr=-1
				If LPR<=0 clear clp.
			Endif
		Endif ! need for poss sugg price
		if LPR>0 let AskLPFlag=0 else AskLPFlag=1  ! 0=lp exists 1=nolp
  else
    include "src/callsuberr.inc"
 end try
End Function AskLPFlag  ! GetAskLP()
!--------------------------------------------------------------------