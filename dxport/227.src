! >>> Program 227
!
! description INVOICE ACCEPT PART 1
!
! loadsave -w -n 100,10 -o prog/dxport/227.dl4 src/227.src
!
! 1.0 mm/dd/yyyy change??
!
include "src/copyright.inc" ! dx
Rem "MX227    invoice accept part I
Rem           Paper Master  (xindist)
Rem "Author:  roman      08/30/1992 - 09/15/1992
! "Last Update: 3/93 (rek) - back out freight addons
!               12/08/1993 roman - handle negative line qty's
!               05/20/1994 rjs - add prodwhse term discount into 
!                                terms disc t2[22]
!               06/08/1994 roman - edi interface into 4/EDITRANS#
!               12/9/94 nate - added line cost origin and rebate cntrct
!               02/2/95 nate - added two indices to invl
!               10/17/95 nate - track cost in edi rebate tag file
!               02/01/96 nate - bug fix -- use k18$ & k22$ instead of f$
!                02/15/96 rjs - update messages into history
!              03/07/96 jlp - no last price for order type 8
!               07/11/96 nate - move debug227# from /tmp to 1 
!               11/23/96 tc - pass misc. chrg tax flags to history
!               02/02/97 jlp - s/e on serial number - cct 98636
!               5/21/97 tc cct100365 write shipto tax type to history
!               07/08/1997 - sordflehhkey & date compares julian
!              10/16/97 vst cct102805 chk if accept is running on another port before checking for accept bomb "iaip#"--8000 area rearranged.
!              02/27/98 nate cct#109213: modify edi to use ediloc file.
!
!          blv 6/23/98 cct113353 - rearranged order of 9100 so that it
!              only cleans up anything it did this run! This prevents
!              the program from deleting the cntrl/iaip# file on a
!              accept bomb.
! cct117030 tc 10/21/98 read CST from rolnew before writing to invl
! cct115255 jlp 12/14/98 rem lines that check lot flag and reassign
!                        order and ship qty, lines 2115 and 2120
! cct122199 jliu 4/27/99 add qty prev. billed field in ROLNEW file
! cct122724 jliu 5/28/99 default all the fields as same as the whse 
!    is coming from when order type is 7 or 8 or 16
! cct115070 jliu 6/9/99 initialize the variable WHBLD[2]
! cct133402 jlp 3/1/00 don't try to read whse record for nonstocks and zlines
! cct127174 jliu 4/21/00 add cntrl record (rec#185) in 924, order type vs
!                last price update. Don't update the last price file, if
!                the value sets as "0" in 924 rec#185 for the order type
! cct142171 zyc 11/30/00 remmed out signal after calling mx227lp   
! cct150909 tc  10/12/01 fix problem where editrans runs into very old info
! cct151597 kag 11/9/01 assign vendor code from prod file to WHBLD[2] before
!                       call to MXWHCREATE.                                 
! cct154133 kag 2/6/02 for order type 8 write consignment whse to pserlno and  
!       set the status back to 0 (open) so it can be selected fororder type 7  
! cct162137 jliu 11/05/02 - write lp_date & lp_time & owhs into history file
! cct226292 jliu 6/10/08 copy the order tag file to the inv line tag file
! cct210803 jliu 3/14/07 build the key into 6/ictrack file
! cct237029 jliu 12/08/09 - initialize the PHUP
! ---------------------  notes for Custom H T Berry  ----------------
! 11/04/06   dd cct151323 - add field to shiplist to hold end user#  
! 08/01/07  rjs cct210769 - commission service charge
! 01/28/08  jcs cct221505 - CCH Tax Calculation
! 02/24/12 vst ! "CCT111941/task12321- added "HFAX" variable (OMAHA needs for custom code) n/u
! task#21954 - master delivery customer
! 10/12/10 txc cct244189/225460 - createorder wasn't initializing srnmd fields to 0 and
! 						     not passing to history ( related to cct225460 )
! ------------------------------------------------------------------------------
!------------------------------------------------------------------------------
! 04/2012 - add INVCOST FILE
!   add status file so no timeout on large accepts (write to myreports)
!
Rem BEDIT Version: 2.2 OBJECT CODE     Created: OCT 28, 2008  10:29:49
Rem /w2/papermaster/r2005//usr/acct/custom/xrev9/mx227.src (univ2) 
Rem  Copyright (c) 2008 Universal Business Systems, Inc.
Rem    **** ALL CHANGES MUST BE MADE IN SOURCE!!! ****
Rem
!  Restart instructions:  NO SUPERUSER - RESTART REQUIRES CHANGES/BYPASSES AT THIS TIME!!
!	1. RUN THIS WITH SETUP THROUGH DXTEST.DL4 - no more details
!	2. UnRem call dxopen()
!	3. Change SuperUser = 1
!
Include "src/inc/fileinvtrans.inc"
Include "src/inc/sql_prod.inc"
External Lib "invttrans.dl4"
Declare External Sub Maketrans
External Lib "libprodwh.lib"
Declare External Sub mxwhcreate
Declare Intrinsic Sub DateToJulian,FindF,InpBuf,String,Time,VerifyDate
Declare Intrinsic Sub getglobals
Declare Intrinsic sub programdump,env
Declare Intrinsic function findchannel
! external libs for subs/functions
External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus
Declare External Function AddToMYReports
External Lib "ubsfunc.dl4"
Declare External Function getuidrec,getuidinfo$,OpenMySQLMirror
External Lib "librebates.lib"
Declare External Sub rebates
!Option Default Dialect IRIS1

Try
Com 1%,CREDIT,TERMFLAG,IntCo,icflag,statchan
Com 2%,PASSR[9]
Com 3%,HEADREC,E$[500],Rstr$[2000]

Def FNR(X) = Sgn(X) * (Int(Abs(X) * 100 + .5) / 100)
REM dim sordroll/sordrollh                                          
DIM KEYORL1$[50],KEYORL2$[50],SOR$[32],1%,SOR1[1],3%,SOR2[3]        
DIM KEYORLH1$[50],3%,SORH2[3]                                       
REM dim prodroll                                                    
DIM KEYRL1$[50],KEYRL2$[50],RL0$[62],2%,RL1[5],3%,RL2[2],RLUSER$[20]
DIM NKEYRL1$[50],NKEYRL2$[50]                                       
DIM PRFLG$[10]
DIM CC_TT$[4] 
Dim 1%,ohcurrid,olcurrid,3%,ohcurrfact,olcurrfact
Dim 1%,EUN[2],S0,CASHP0[1],P0[1023],H3[1],H4[2],L3[3],UN[2],S2[1],ARMONTH
Dim 1%,DIR,I,TRANL1[3],SYSMONTH,PFU1[20],LOTCNT,SN1,SERSN1[2],SNH1,S6[1]
Dim 1%,BNK[1],W1[2],W0[3],WH8[47],ACC_CTR,DEBUG,ABORT,KL1[5],RP0[2],SCR
Dim 1%,EDII,CH_INVTR,MCTXBL[9],FLAG,UPOT,TEMPDISP,LWHSE,HWHSE,PICKBY[2]
Dim 1%,LPRINTED,OWHS,tcb,CommissionSource
Dim 1%,OWHT[1],2%,DT3[1],JSDATE,JWDATE,H2[0],JIDATE,OWHT1[1],CTWT[1]
Dim 1%,RESTART,LINENUM,TRACK[1],PORTNUM,PART,TYPE,TRACKDATE$[25],TRACKFILE$[30]
Dim 1%,CH_WT,CH_WTH,USERPORTINFO[1],DCLVL,OT19Part,totalpage,SplitFlag
Dim 1%,RBUM[1],RB[2],2%,LP_DATE,LP_TIME,SL2[4],RB1[5]
dim 2%,HFAX[1] !  "CCT111941/task12321
dim 2%,upst[3],DL[12],NumberPieces
Dim 2%,ORDNUM,ACCEPTPORT,SCRATCH$[50],CTNWT[1],CommBaseRate[4]
Dim 2%,H0[12],HISTH0[12],H5[16],S3[24],SLSM[9],H6[8],L2[1],L4[3],MCODE[9]
Dim 2%,L6[5],L9[1],S1[1],S5,T1[1],JRNL,PCDATE,B[24],PICKP2[2],SN0[1],AFRT
Dim 2%,SN2[9],PSN[1],SNH[1],CSH0[4],W2[9],W7[14],A2[5],KL2[1],CH_CCN[9],WH7[3]
Dim 2%,WHBLD[2],RP1[3],TR[8],U4[1],LCO[1],ARYEAR,ARDATE,LTAX2,SHIPDATE
Dim 2%,PR_C4[10],PLC[3],ACPT_DATE,CHG_DATE,VENDOR,MH1,SS1,SS2,CSPLT[4]
Dim 3%,MH2,MH2$[1],SLUD,ediENDUSER,commsrvchg,LP1,ups3,k2_tmp
Dim 3%,X1,X2[9],X3,L5[3],L7[12],ROLS3[17],T2[25],Q1,P3[4],LOTS3[5],TRANL2[5]
Dim 3%,PICKP3[11,1],SN3[6],CSH1[2],SCOM[4],SMER[4],SCST[4],W3[24],W5[25]
Dim 3%,T9[5],WH9[24],A[33],A3[11],KL3[1],OLM[6],RP2[2],SRN[5],UNF[6]
Dim 3%,WHMISC[6],WHDISC,TOT_SELL,TP[999],R[99],MCHARGE[9,1],TOT[4],CST
Dim 3%,TR1[8],LINEREC,LTAX1,INVBAL[1],T3,PLV[1],WHLV[2],TR2[1],M1[17],PF_LOAD2
Dim 3%,AVGCOST,CURVAL,QPB,LBSORD,PRPARC[3],WHLBS[1],LBSHIP,TOTGL,ROL0
Dim 3%,CTNWGT,OREF[5],IREFNO,INVNO,TOT_ORD,tl2[1],phup
DIM 3%,PWHMISC[6],PLRNCOST,pw3[24]
Dim 4%,F,F1,F2
dim 3%,srnmd[1]
dim 3%,invcst$[22],invcst[13],rebate_args[10,4],lrncost,pfn[1],status
! non-stock line vars
dim 1%, nsl$[30], nsl1$[30], nsl2$[18], ha1$[50]
Dim NSUDA$[120],NSB4k$[2],k31$[60]
dim 2%, nsl7[2], ha3[2]
dim 3%, nsl8[4],NSINVNO
dim 3%,nsfrt1[2]
Dim Z1$[200],P9$[50],P60$[60],F$[30],A$[30],P0$[20],V0$[12],H0$[20],P61$[256]
Dim L6$[60],L1$[20],MT$[2],S3$[33],S1$[118],S2$[20],PRODA$[156],L0$[56]
Dim BREAK$[50],S0$[36],OL2$[16],TRANL1$[6],STOCK$[22],H1$[6],PICKP2$[23]
Dim CSH0$[156],SN$[224],SN1$[54],PSN$[20],SNH$[54],W1$[32],EDILTP$[8],K67$[50]
dim ccsp$[16],cctran2$[30],ccauth1$[10],ccauth2$[10],ccsp2$[60]
Dim K2$[40],K5$[40],K6$[40],K8$[40],K11$[50],K14$[50],K15$[52],K16$[50]
Dim K17$[50],K19$[60],K20$[60],K21$[60],K23$[60],K24$[60],K25$[60],K26$[60]
Dim IAIP$[16],CAIP$[16],HMAT$[2],K28$[30],K29$[30],KL$[58],K30$[60],M1$[40]
Dim U5$[50],J4$[50],X$[10],ARDATE$[8],K32$[50],K33$[60],K34$[60],K35$[60]
Dim RP$[132],WHPROD$[12],K51$[60],K63$[16],FLG$[4],TRUM$[4],TRVI$[20],K69$[50]
Dim TRCT$[2],TRDE$[30],ACPT_DATE$[10],CHG_DATE$[10],K18$[60],K22$[60]
Dim K2_TMP$[60],CH_CCA$[120],KCWT$[40],KCWTH$[40],MESS$[80],USR$[20],IRIP$[40]
DIM LPONUM$[30],LJOBNUM$[30],PSNUM$[30],MSG1$[30],MSG2$[30],K43$[14],K44$[14]
Dim buttonlist$[5,50],nextlist$[5,100] ! dx error handling variables
Dim upst$[30],kups$[50],kupsh$[50],tupst$[30],EMAIL$[50],MSGS$[750]
Dim tmp$[800],tmp1$[200],nextblockid$[8],Message$[600],WebStr$[600],blockid$[100]
Dim action$[30],options$[30],userid$[8],b$[200],3%,fdel$[10],bsdel$[10],esdel$[10],rdel$[10]
Dim Custom_Customer$[30],SLA1$[142],SLR$[33],SLSI$[120],SLUD$[60],K38$[50],TIDNo$[20]
Dim 3%,K_INV_COST$[50],PWK6$[50],REC_PW
Dim ReportDir$[128],BaseName1$[128],Statusfile$[128]
dim keyrod$[50],3%,rec_rod,2%,DEP1[7],3%,DEP2[4],1%,DEP3[1],3%,rec_rodh,keyrodh$[50],chkdep$[20]

! rfpickq stuff
dim k_rfpq$[100],k_rfpq2$[100],k_rfpqh$[100]
dim 1%,rfpq_wh,rfpq_line,pickedby,pickstat
dim 2%,gendate,gentime,pickdate,picktime,truck,truckstop
dim 3%,rfpq_order,sequence,qty2pick,qtypicked,invnum,pallet,histSequence
dim bin$[6],varsortkey$[40],product$[12],vendprod$[20],zone$[2],binsort$[10]
dim 3%,r_rfpq,r_rfpqh

dim 3%

B$=" ",B$
let phup=0
!Try 
!call dxopen() ! may not need this! NEEDS FOR DXTEST/RESTART RUN!!
!Else
	Rem
!End try
Call getsession(e$,CTLC,options$,action$,userid$,intCO,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$)
! must be passed otherwise wipes out info if chained from 226agl
dim ITR. as invtrans
COID=IntCo ! E = Spc(5) \ COID = Int((E - Int(E / 16384) * 16384) / 64)
F$ = "cntrl/CNTRL"+Str$(COID) ! for restart
! get session opens a READYONLY Cntrl#
Close #1
Open #1,F$
Try Close #9 Else Rem ! dxblock sends sort file on #9 
Mat Read #1,19,50;P9$; \ Mat Read #1,60,6;FLG$;
MAT  READ #1,61,0;P61$; 
If P9$[17,17] <> "M" Goto L_810
!Print @0,22;'CL RB';"*WARNING: GENERAL LEDGER IS NOT ACTIVATED!!!";
!Print @0,23;'CL RB';"Do you wish to continue? "; \ Input ""F$
!If F$ <> "YES" Goto L_9200
L_810: For I = 2 To 39
  Read F \ If F = -1 Goto L_835
  If P9$[17,17] <> "Y" And (I = 18 Or I = 22) Goto L_835
  F2 = Abs(Fra(F) * 1000) \ If F2 < 88 Or F2 > Chf(1) - 1 Let F2 = 88
  F1 = Abs(Int(F))
  Read #1,F2,F1;F$;
  If F >= 0 Open #I,F$
  If F < 0 Ropen #I,F$
L_835: Next I
Data "1136","1152","1168","1184","1744","1504","1840","1856","1872","1888","2128"
Data "1376","1792","2320","2528","2512","64","2224","2704","1232","464","1248","2944"
Data "2960","416","1456","1312","1328","2992","-1","-1","1120 ","1968","-1","-1","-1"
Data "2112","2176"
Open #31,"4/SPRDDESCH"+STR$(COID) ! HIST FOR 2128(#12)
Open #32,"4/SORDFLEHHKEY" + Str$(COID)
Open #35,"4/SORDFLEMH" + Str$(COID)
F$ = "3/CTWTQTY" + Str$(COID)
Call FindF(F$,FOUND)
If FOUND
  CH_WT = 36
  F$ = "4/CTWTQTYH" + Str$(COID)
  Call FindF(F$,FOUND)
  If FOUND
    CH_WTH = 37
  Else 
    CH_WTH = 0
  End If 
Else 
  CH_WT = 0;CH_WTH = 0
End If 
let ch_ups=-99
let ch_upsh=-99
let f$="4/UPSTRAK"+STR$(COID) 
Call FindF(F$,FOUND)
  If FOUND
  let ch_ups=60
  endif
  let f$="4/UPSTRAKH"+STR$(COID) 
Call FindF(F$,FOUND)
if found
let ch_upsh=61
endif

If P9$[8,8] <> "Y" Let CH_WTH = 0
If CH_WT Open #CH_WT,"3/CTWTQTY" + Str$(COID)
If CH_WTH Open #CH_WTH,"4/CTWTQTYH" + Str$(COID)
if p61$[104,104]="Y" ! roll iventory
	OPEN #40,"2/PRODROLL"+STR$(COID) 
	OPEN #41,"3/SORDROLL"+STR$(COID) 
	OPEN #42,"4/SORDROLLH"+STR$(COID)
endif
LET ROLTAGFLAG=0                     
LET F$="3/SORDROLTAG"+STR$(COID)      
CALL FINDF(F$,ROLTAGFLAG)
IF ROLTAGFLAG                        
   OPEN #43,"3/SORDROLTAG"+STR$(COID)    
  OPEN #44,"4/SORDINVLTAG"+STR$(COID)   
ENDIF 
F$="4/INVCOST"+STR$(COID)
call FindF(F$,invcostflag)
if invcostflag ! check for file existance - don't bomb if not there!
	Read #1,88,304;F$;
	Open #45,F$ ! rebate head
	Read #1,88,320;f$;
	Open #46,f$ ! rebate dtl
	open #47,"4/INVCOST"+STR$(COID)  
	CH_INVCOST=47
Endif
EDII = (FLG$[2,2] = "T" Or FLG$[2,2] = "H")
If EDII
  Open #51,"cntrl/EDICNTRL" + Str$(COID)
  Open #63,"4/EDITRANS" + Str$(COID)
  Open #67,"2/EDILOC" + Str$(COID)
End If
!
let docflag=0
!"cct#210803
if p61$[96,96]="Y" let docflag=1
if not(docflag) 
   let icflag=0 
   goto skip_doc
endif
LET F$="6/ictrack"+Str$(COID) 
Call FindF(F$,FOUND)      
if not(found) 
   let icflag=0
else
   icflag = (FLG$[4,4]="Y") ! tracks invoices for auto dcs printing
   if icflag
      OPEN #69,"6/ictrack"+Str$(COID)       
   endif
endif
skip_doc: !
if p61$[94,94]="Y"
	let f$="3/sorddep"+str$(coid)
	ch_rod=58
	open #ch_rod,f$
	let f$="4/sorddeph"+str$(coid)
	ch_rodh=59
	open #ch_rodh,f$
endif
!
!Open #77,"cntrl/userport"
!Read #77,Spc(6);SCR;
SCR=getuidrec(e$,IntCo,Userid$)
If SCR = -1 Let SUPERUSER = 1 Else Let SUPERUSER = 0
! TO ACTIVATE RESTART OPTION SET SUPERUSER = 1
!Close #77
call dxget("u_custom_customer", custom_customer$)
If trim$(Custom_Customer$)=""
  mat read #1,115,60;custom_customer$; ! ALT
Endif
custom_customer$=RTrim$(UCase$(custom_customer$))
tptc=0 \ if custom_customer$="HTBERRY" let tptc=1
IF P61$[140,140]="Y" let tptc=2 ! uses third party tax calc custom_customer$="PIEDMONT"
TRUM$ = " ",TRUM$;TRVI$ = " ",TRVI$;TRCT$ = " ",TRCT$;TRDE$ = " ",TRDE$
Mat Read #1,0,112;PCDATE; \ Mat Read #1,0,120;ARMONTH;
Mat Read #1,0,118;SYSMONTH; \ Read #1,0,108;ARDATE;
Mat Read #1,52,32;SS1;
Mat Read #1,52,20;SS2;
ARDATE$ = ARDATE Using "&&&&&&" \ ARYEAR = ARDATE$[1,2]
Mat Read #1,60,50;P60$;
IAIP$ = "cntrl/iaip"+Str$(COID)
IRIP$ = "cntrl/irip"+Str$(COID)
CAIP$ = "cntrl/caip"+Str$(COID)
If ARMONTH = SS1
  E$="CASH RECEIPTS HAS BEEN ACCEPTED(320/306) FOR THE MONTH"
  !Print 'CL';"PRESS <CR> TO RETURN TO THE MENU";
  !Input ""Z1$
  Goto L_9200
End If 
If ARMONTH = SS2 And P9$[17,17] = "Y"
  E$="ACCOUNTS RECEIVABLE HAS BEEN ACCEPTED(405) FOR THE MONTH"
  !Print 'CL';"PRESS <CR> TO RETURN TO THE MENU";
  !Input ""Z1$
  Goto L_9200
End If 
DEBUG = 1
!Print 'CS';@0,0;"MX227";@25,0;"INVOICE ACCEPT"
! call programdump("/tmp/ialog0!","")
ABORT = 0 \ TERMFLAG = 0
! The following is for Web run of 227
Call DXGet("RN227",tmp$) \ tmp$=UCase$(Trim$(tmp$))
if tmp$="" let tmp$="N" ! unchecked it?
If tmp$="N"  ! DO NOT WANT TO RUN!
	E$="USER SELECTED NO ACCEPT RUN - OK"
	goto L_9100
Endif
Try
	Call dxget("BLOCKID",blockid$) ! Call getglobals("blockx",0,blockid$)
Else
	blockid$=""
End try
 If blockid$ = "757" ! how we know it's a 757? ! also if auto from 226 will be passed!
	Let passr[1]=757;passr[2]=16
	Call DXGet("WH757",tmp$)
	let X2=tmp$ \ if x2<0 let x2=0
	if x2>99 let x2=0
	if Fra(X2) let x2=0
	Passr[3]=x2
Endif

If P9$[48,48] = "Y" ! AUTO POST CASH?
L_944: Rem "What type of order
  If PASSR[1] <> 757
    !Print @0,15;'CL';"ACCEPT TYPE: 1=CASH, 2=ORDERS, 3=BOTH, E=EXIT ";
    !Input ""Z1$ \ If Z1$ = "E" Goto L_9100
    !If Len(Z1$) > 2 Print 'RB';"INVALID!!!" \ Signal 3,15 \ Goto L_944
	Z1$="3" ! do all?!
  Else 
    Z1$ = "2" ! do all ! 757 should not be updating cash sales
  End If 
  TERMFLAG = Z1$ \ If TERMFLAG < 1 Goto L_944
  If TERMFLAG > 3 Goto L_944
  If TERMFLAG = 3 Let TERMFLAG = 0
End If 
ABORT = 0 \ Gosub L_8000 \ RESTART = 1
! call programdump("/tmp/ialog1!","")
If SUPERUSER And RESTART And ABORT = 1 ! ONLY USE IN BACK END - WILL NOT WORK ON WEB!
  Print 'CS';@0,10;"The track file contains the following values: "
  Print @2,12;"Order:    ";ORDNUM;@25,12;"Line:  ";LINENUM;
  Print @2,13;"Track[0]: ";TRACK[0];@25,13;"Track[1]: ";TRACK[1];
  Print @2,15;"Port: ";PORTNUM;"  Part: ";
  If PART = 1 Print "mx227";
  If PART = 2 Print "mx227a";
  If PART = 3 Print "mx227b";
  If PASSR[1] = 757
    Print " warehouse ";PASSR[3];" transfer"
  End If 
  Print "   Type: ";
  If TYPE = 0 Print "Both (cash & orders)";
  If TYPE = 1 Print "Cash";
  If TYPE = 2 Print "Orders";
ASK_READY: Print @0,23;"Ready to Begin? (Y/N) (last chance!!)  ";
  Input ""Z1$ \ Call String(1,Z1$)
  If Z1$ <> "Y" And Z1$ <> "N" Goto ASK_READY
  If Z1$ = "N" Goto L_9100
  Goto L_1000
Else 
  If RESTART Goto L_9100
End If 
L_955: !Print @0,22;'CE';"OK to Accept Invoices (Y/<CR>): ";
!Input ""Z1$ \ If Z1$ = "" Or Z1$ = "N" Or Z1$ = "E" Goto L_9100
!If Z1$ <> "Y" Goto L_955
if tptc ! 3rd party tax calc
	!! test the internet to see if we connect to cch
	if tptc=1 Call "cch.testconn.dl4",X1
	if tptc=2 call "ava.testconn.dl4",x1
	If Not(x1) ! "no connect/wrong response
		E$="NO INTERNET CONNECTION WAS MADE(TO 3RD PARTY TAX CALC), PLEASE TRY AGAIN LATER  "
		! Input Len 16384+1;""Z1$
		Goto L_9100 ! treat like user said "N"
	Endif
	if x1=9 let TPTC=0 ! not set up - do not use tptc
Endif ! 
If P9$[17,17] <> "Y" Goto L_1000
K18$ = " ",K18$
E = 2 \ Search #18,1,0;K18$,R[18],E \ If E error 11000
Search #18,4,1;K18$,R[18],E \ If E error 11000
L_1000: Rem ========================= start accept
Read #1,3,188;SHIPDATE;
X2 = SHIPDATE \ Gosub L_7820 \ X2 = 0
If X2 Let JSDATE = X2 Else Let X2 = Tim(6)
! as accept make take >2 mins - use a status file
if not(restart) ! if a restart - in manual run mode? so no file
	ReportDir$ = "REPORTDIR" \ System 28,ReportDir$
	BaseName1$ = "invoice_accept_"+dateusing$(Tim#(0),"YYMMDDHHNNSS")
	StatusFile$ = ReportDir$ + "/"+BaseName1$
	Call FindF(StatusFile$,tmp)
	If tmp Kill StatusFile$
	StatChan = 88 ! FindChannel() ! channel to build text file need fixed channel
	Try Close #88 Else Rem
	Try
		Build #StatChan,StatusFile$ As "TEXT"
	Else
		returnstatus=1
		let e$="Error in Building Status File "
		goto L_9100
	end TRY
	Try Close #StatChan Else Rem
	Try
		Open #StatChan,StatusFile$
	else
		returnstatus=1
		let e$="Error in Opening Status File "
		goto L_9100
	end TRY
	Print #StatChan;"Accept Process Started..."
	! PAUSE 20
	e = AddToMYReports(BaseName1$) 
	if e<0
		e$="Error adding to my reports!" 
		returnstatus=1
		goto L_9100
	endif
	returnstatus=0 ! or is it 1?
	message$="Please check under My Reports "+basename1$+" for status and completion"
	Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)     
	Call AddToStr(e$,rstr$,WebStr$)                            
	Call SetOutPut(e$,rstr$)
Endif ! of not a restart
L_1100: K23$ = " ",K23$ ! will check all status here for "lost" entries that should be deleted
L_1105: Search #23,3,1;K23$,R[23],E \ If E > 2 error 11000
If E Goto L_1135
If K23$[1,2] <> " 7"  ! ALL 7'S CAN BE DELETED, OTHERWISE CHECK DATES
	mat read #23,r[23],0;DL;
	CHG_DATE$ = DL[5] Using "&&&&&&" \ Call DateToJulian(1,CHG_DATE$,CHG_DATE$,E)
	IF E CHG_DATE$ = DL[4] Using "&&&&&&" \ Call DateToJulian(1,CHG_DATE$,CHG_DATE$,E)
	CHG_DATE = CHG_DATE$
	X2 = ARDATE \ Gosub L_7820 \ X2 = 0
	IF X2 - CHG_DATE <= 7 
		Goto L_1105
	ENDIF
endif
Search #23,5,1;K23$,R[23],E \ If E error 11000
E = 3 \ Search #23,1,0;K23$,R[23],E \ If E error 11000
Goto L_1105
L_1135: Rem
ACC_CTR = 0
If DEBUG
	DBChan=FindChannel()
! call programdump("/tmp/ialog2!","")
  F$ = "files/1/debug227"+sTR$(coid)
  If Not(RESTART) !System "cp /dev/null " + F$ ! doesn't work this way
	tmp$=f$+"!"
  ! tmp$=ORip$+"!"
	Build #DBChan,+tmp$
	Close #DBChan ! so can reopen
	tmp$="chmod go+rw "+f$
	System tmp$
  Endif
  Open #DBChan,F$
  If RESTART
NEXT_DEBUG: Read #DBChan;F$;
    If F$ <> "" Goto NEXT_DEBUG
  End If 
  Print #DBChan;"invoice accept debug file: ";F$;" ";Msc$(3)
End If 
scratch$="doing a lock"
call "proglock.dl4","227",1,scratch$
! OK - all opens are above this one and the last open (DBChan) used a 
! call to find an open channel number and open, so I can assume from
! here forward, no more conflicts with channel #s
sqlChan = OpenMySQLMirror(e$)
if p61$[135,135] = "Y" ! RF Picking
	ch_rfpq = findchannel()
	F$ = "3/RFPICKQ"+STR$(coid)
	open #ch_rfpq,f$
	ch_rfpqh = findchannel()
	F$ = "4/RFPICKQH"+STR$(coid)
	open #ch_rfpqh,f$
end if

! call programdump("/tmp/ialog3!","")
K8$ = " ",K8$;K8$[1,2] = " 7"
If Not(ORDNUM) Let ORDNUM = 1
K8$[3,8] = ORDNUM - 1 Using "######"
L_1200: Rem "==================================================== invoice loop
L_1220: Search #8,3,1;K8$,R[8],E \ If E > 2 error 11000
If E Goto OUTEND
If K8$[1,2] <> " 7" Goto OUTEND
Mat Read #8,R[8],104;H5;
If PASSR[1] = 757 ! "came from 757 - Only OT 16 for TO Whse
  If H5[7] <> 16 Goto L_1220
  If PASSR[3] And H5[11] <> PASSR[3] Goto L_1220
Else 
  If H5[7] = 16 Goto L_1220
End If 
! if H5[7]=36 or H5[7]=37 goto L_1220 ! EVAP NOT READY
ORDNUM = K8$[3,8] \ Write #TRChan,0,4;ORDNUM;
If Not(RESTART)
  LINENUM = 0 \ Write #TRChan,0,8;LINENUM;
End If 
Gosub L_6000
If TERMFLAG = 1 And T2[10] = 0 Goto L_1220
If TERMFLAG = 2 And T2[10] <> 0 Goto L_1220
ACC_CTR = ACC_CTR + 1
HWHSE = H4[2];TCB=0
if tptc Read #39,H4[0],412;TCB;  ! tax calc'd by
If P9$[8,8] <> "Y" Goto L_1540
Gosub L_7600
K2$ = " ",K2$;K2$[1,2] = "30";K2$[3,12] = OREF[1] Using "##########"
L_1280: Search #2,2,1;K2$,R[2],E \ If E > 1 error 11000
If E If K2$[1,2] = "30" Let K2$[1,2] = "31" \ Goto L_1280
If E Goto L_1380
Mat Read #2,R[2],0;HISTH0
If HISTH0[4] <> H0[4] Goto L_1350
If HISTH0[7] <> H0[7] Goto L_1350
If HISTH0[8] <> H0[8] Goto L_1350
If RESTART Goto L_1540
Goto L_1200
L_1350: !Window Open @1,4; To @79,14; Using "Duplicate invoice in history."
E$="INVOICE "+Str$(OREF[1])+" ALREADY IN HISTORY.  ACCEPT HALTED."
E$=E$+" CURRENT ORDER NUMBER"+Str$(H0[7])+"."
!Print @8,3;"ACCOUNTS RECEIVABLE AND INVENTORY ARE ONLY PARTIALLY UPDATED!"
E$=e$+" Run 228, History Purge, to remove the old invoice from history,"
e$=e$+" then run 227 again to have it pick up from where it left off."
!Print @2,9;"HIT <CR> TO CONTINUE ";
If DEBUG Print #DBChan;"duplicate history for inv.";OREF[1];"order";H0[7]
!Input ""Z1$
!Window Close 
ABORT = 4 \ Goto L_9100
L_1380: Rem "allocate history records
Gosub L_7600
X2 = H0[10] \ If X2 <> 999999 Gosub L_7820 \ X2 = 0
JWDATE = X2
E = 2 \ Search #2,1,0;K2$,R[2],E \ If E error 11000
E = 2 \ Search #3,1,0;Z1$,R[3],E \ If E error 11000
E = 2 \ Search #4,1,0;Z1$,R[4],E \ If E error 11000
K2$[1,2] = "30";K2$[3] = OREF[1] Using "##########"
Search #2,4,1;K2$,R[2],E \ If E error 11000
K2$ = " ",K2$;K2$[1,6] = H0[4] Using "######"
K2$[7,16] = OREF[1] Using "##########"
Search #2,4,2;K2$,R[2],E \ If E error 11000
K2$ = " ",K2$;K2$[1,3] = H0[11] Using "###"
K2$[4,13] = OREF[1] Using "##########"
Search #2,4,3;K2$,R[2],E \ If E error 11000
H0[0] = 30
OREF[4] = R[3];OREF[5] = R[4]
INVNO = OREF[1]
Gosub L_7900 \ Gosub L_7800
T2[25] = X2 * 100 + ARMONTH
If Not(OREF[3])
  OREF[3] = H0[7]
  If H5[7] <> 20
    If OREF[2] > 0 Let OREF[3] = OREF[2]
  Else 
    If OREF[2] > 0
      K2_TMP$ = "30",OREF[2] Using "##########"
      Search #2,2,1;K2_TMP$,K2_TMP,E
      If E > 1 error 11000
      If Not(E)
        Read #2,K2_TMP,524;OREF[3];
        If Not(OREF[3])
          Read #2,K2_TMP,28;H2[0];
          OREF[3] = H2[0]
        End If 
      End If 
    End If 
  End If 
End If 
Gosub L_6500
Gosub L_6700
Gosub L_5000
gosub updateups ! ups tracking numbers 
L_1540: K11$ = " ",K11$;K11$[1,6] = K8$[3,8]
INVNO = OREF[1]
REPAIR = 0
If RESTART If LINENUM Let K11$[7,9] = LINENUM - 1 Using "###"
L_1548: Rem "==================================================== line loop
Search #11,3,1;K11$,R[11],E \ If E > 2 error 11000
If E Goto L_1800
If K11$[1,6] <> K8$[3,8] Goto L_1800
if statchan Print #statchan;"Doing...";ACC_CTR;K11$
LINENUM = K11$[7,9] \ Write #TRChan,0,8;LINENUM;
Gosub L_6300
LWHSE = L4[3] \ If LWHSE <= 0 Or LWHSE > 99 Let LWHSE = HWHSE
KIT = 0;MKIT = 0 \ Gosub L_3200
If P9$[8,8] <> "Y" Goto L_1635
K5$ = " ",K5$;K5$[1,10] = OREF[1] Using "##########";K5$[11,14] = K11$[7,10]
If RESTART Search #5,2,1;K5$,R[5],E \ If Not(E) Goto L_1635
E = 2 \ Search #5,1,0;K5$,R[5],E \ If E error 11000
Search #5,4,1;K5$,R[5],E \ If E error 11000
If L3[0] Let L4[0] = 0 \ Goto L_1620
K5$ = " ",K5$;K5$[1,6] = L4[0] Using "######"
K5$[7,16] = OREF[1] Using "##########"
K5$[17,20] = K11$[7,10]
Search #5,4,2;K5$,R[5],E \ If E error 11000
L_1620: INVNO = OREF[1]
If H5[7] = 2 Or L3[0]
  If L7[7] Let CST = L7[7] Else Let CST = L5[1]
End If 
Gosub L_6800
L_1635: Rem
If (H5[7] = 21 Or H5[7] = 22) And K11$[7,9] = "   " Gosub L_4100 \ Goto L_1683
KIT = 0;MKIT = 0 \ Gosub L_3200
DEFWHNUM = 0
INVBAL[0] = 0;INVBAL[1] = 0 \ Gosub L_10000
WHSE = - LWHSE \ If H5[7] = 7 Let WHSE = - H5[11]
if not(l3[0]) gosub update_invcost !      stock items only
Gosub L_2000
If (H5[7] = 8 Or H5[7] = 16) Let WHSE = H5[11] \ Gosub L_2000
WHSE = LWHSE \ Gosub L_3500
If (H5[7] = 7 Or H5[7] = 8 Or H5[7] = 16) Let WHSE = H5[11] \ Gosub L_3500
Gosub L_6300
If L3[0] = 0 Let R[14] = L4[0] \ Gosub L_6400 \ Unlock #14
if l1$[17,20]="" or l1$[17]="" 
	let l1$[17,20]=Proda$[152,155]
	mat write #11,r[11],140;l1$;
Endif
If L3[0] GOSUB NSTKHist ! new nonstk history
Gosub L_4500 ! serial numbers
if p61$[104,104]="Y" GOSUB UPDATEROLLINV: ! rolls
Gosub L_3300
Gosub CTNWGT
CREDIT = 0;LINEREC = R[11]
TEMPDISP = (H5[7] - 1) * 2
Mat Read #1,185,TEMPDISP;UPOT; ! do not LOCK!!
If H5[7]=19 And OT19Part Goto L_1683 ! "not on partials
If UPOT = 1 !"update last price file
  !Call "MX227LP",H0[],H5[],CREDIT,LINEREC,H4[],OREF[]
  Call "227lp.dl4",H0[],H5[],CREDIT,LINEREC,H4[],OREF[],e$,IntCo,rstr$,statchan
  If DEBUG Print #DBChan;"Last Price Updated ";k11$
End If 
L_1683: KIT = 0;MKIT = 0
If H5[7]=19 And OT19Part Goto LineDone
If EDII And Not(L3[0]) !"tag invoices for rebate claims to be processed later
  K6$ = " ",K6$;K6$[1,12] = PRODA$[140,151];K6$[13,14] = L4[3] Using "##"
  Search #6,2,1;K6$,R[6],E \ If E > 2 error 11000
  If Not(E) Read #6,R[6],50;VENDOR;
  If E Or Not(VENDOR) Let VENDOR = B[24]
  K51$ = " ",K51$;K51$[1,8] = VENDOR Using "VN######"
  Search #51,2,1;K51$,R[51],E \ If E > 1 error 11000
  If Not(E) !"this vendor is an edi trading partner
    Mat Read #51,R[51],8;TP;
    If Int(Abs(TP[867])) !"this vendor is set up to send rebate claims
	  !if custom_customer$="HTBERRY"
		GOSUB GET_SHIPLIST: 	! "cct151323 read ediENDUSER from SHIPLIST
	  !Endif ! per DD - standard on everyone
      K63$ = " ",K63$;K63$[1,12] = OREF[1] Using "RB##########"
      K63$[13,15] = L3[2] Using "###"
      Search #63,2,1;K63$,R[63],E \ If E > 1 error 11000
      If E ! not found, allocate a record for it
        E = 2 \ Search #63,1,0;K63$,R[63],E \ If E error 11000
        Search #63,4,1;K63$,R[63],E \ If E error 11000
      End If 
      For X1 = 0 To 8 \ TR[X1] = 0;TR1[X1] = 0 \ Next X1
      TR2[0] = 0 \ Gosub L_5100
      TR1[8] = Fra(T2[25] / 100) * 10000 + Int(T2[25] / 1000000)
	  !if custom_customer$="HTBERRY" LET TR1[6]=ediENDUSER			! "cct151323
	  LET TR1[6]=ediENDUSER			! "cct151323 per DD for everyone
      TR[1] = L3[2]
      TR[2] = VENDOR
      TR[3] = ARDATE;TR[4] = H0[1]
      TR[5] = Int(T2[25] / 100)
      TR2[1] = OREF[1];TR[7] = H0[0]
      WHPROD$ = " ",WHPROD$
      Write #63,R[63],0;WHPROD$[1,12];
      Mat Write #63,R[63],12;TR
      Mat Write #63,R[63],48;TR1
      Mat Write #63,R[63],102;TRUM$
      Mat Write #63,R[63],106;TRVI$
      Mat Write #63,R[63],126;TRCT$
      Mat Write #63,R[63],128;TRDE$
      Mat Write #63,R[63],158;TR2;
      Mat Write #63,R[63],170;K63$;
L_1761: End If 
  End If 
End If 
if p61$[135,135] = "Y" ! RF Picking
	gosub MoveRFPicksToHistory:
end if
LineDone: ! for ot19 bypass lprc/edi
RESTART = 0
TRACK[1] = 0 \ Write #TRChan,0,2;TRACK[1];
Goto L_1548
L_1800: Rem ============================= update messages
If P9$[8,8] <> "Y" Goto L_1850
K34$ = K8$[3,8]
L_1815: Search #34,3,1;K34$,R[34],E \ If E > 2 error 11000
If E Goto L_1850
If K34$[1,6] <> K8$[3,8] Goto L_1850
Mat Read #34,R[34];M1$
Read #34,R[34],40;MH1
Mat Read #34,R[34],44;MH2
Mat Read #34,R[34],50;MH2$;
MH2$ = " ",MH2$;MH2 = OREF[1]
K35$ = K34$ \ K35$[1,10] = OREF[1] Using "##########"
K35$[11] = K34$[7]
Search #35,2,1;K35$,R[35],E \ If Not(E) Goto L_1815
E = 2
Search #35,1,0;K35$,R[35],E \ If E error 11000
Mat Write #35,R[35];M1$
Write #35,R[35],40;MH1
Mat Write #35,R[35],44;MH2;
Mat Write #35,R[35],50;MH2$;
Search #35,4,1;K35$,R[35],E \ if e error 11000
Goto L_1815
L_1850: ! ============ see if cch calc'd tax and add histmessg if did
If TCB<1 or tcb>2 goto L_1875: ! no - pm or other calc'd it
! TCB=1 cch did - so get & record their TIDNo$
Let TIDNo$="";OrderRec=R[8]
if tcb=1 Call "cch.commit.out.dl4",H0[7],TIDNo$,intco,rstr$ ! it passes back the tid committed
if tcb=2 call "ava.posttaxout.dl4",H0[7],OrderRec,TIDNO$,intco,rstr$ ! passes back the DOCID number
If TIDNo$[1,1]="" OR TIDNo$[1,3]="   " ! some kind of issue
	Let TIDNo$="UNKNOWN/NOT FOUND" ! "if tcb=1 ALWAYS have TID even none
Endif
! got it - record in messages 801+
Let X2=801
HMTNxt: ! "try until open # found
Let k35$=" ",k35$;K35$[1,10]=ORef[1] USING "##########"
Let k35$[11]=X2 Using "###"
Search #35,2,1;K35$,R[35],e \ if e>1 error 11000
If Not(e) ! found - try next
	Let X2=X2+1 \ if x2>=999 goto l_1875: ! give up
	goto HMTNxt:
Endif
Let U5$=" ",U5$;m1$=" ",m1$;MH1=X2 ! can only hold line # not invno
MH2$ = " ",MH2$;MH2 = OREF[1]
if tcb=1 Let m1$="CCH TID: "+TIDNO$+U5$ ! "space fill to max
IF TCB=2 LET M1$="AVALARA ID: "+TIDNO$+U5$
LET E=2;R[35]=0
SEARCH #35,1,0;K35$,R[35],E \ IF E error 11000
MAT  WRITE #35,R[35];M1$
WRITE #35,R[35],40;MH1;
Mat Write #35,R[35],44;MH2;
Mat Write #35,R[35],50;MH2$;
K35$=K35$+U5$ ! "SPACE FILL KEY TO END
SEARCH #35,4,1;K35$,R[35],E \ if e error 11000
! finished with cch
L_1875: ! ================= update order tag           
LET K43$=K8$[3,8]                                               
IF NOT(ROLTAGFLAG) GOTO L_1975:                                  
L_1915: SEARCH #43,3,1;K43$,R43,E \ IF E>2 error 11000
IF E GOTO L_1975:                                               
IF K43$[1,6]<>K8$[3,8] GOTO L_1975:                             
MAT  READ #43,R43,0;TL2;                                        
READ #43,R43,12;LINENUM;                                        
READ #43,R43,14;LPONUM$;                                        
READ #43,R43,44;LJOBNUM$;                                       
READ #43,R43,74;PSNUM$;                                         
READ #43,R43,104;MSG1$;                                         
READ #43,R43,134;MSG2$;  
Mat read #43,R43,164;MSGS$;
LET K44$=" ",K44$                                               
LET K44$[1,10]=OREF[1] USING "##########"                       
LET K44$[11,13]=K43$[7,9]
LET K44$[15]="" ! CUT TO LENGTH
SEARCH #44,2,1;K44$,R44,E \ IF NOT(E) GOTO L_1915:               
LET E=2                                                         
SEARCH #44,1,0;K44$,R44,E \ IF E error 11000
TL2[1]=OREF[1]              
MAT  WRITE #44,R44,0;TL2;                                       
WRITE #44,R44,12;LINENUM;                                       
WRITE #44,R44,14;LPONUM$;     
WRITE #44,R44,44;LJOBNUM$;             
WRITE #44,R44,74;PSNUM$;               
WRITE #44,R44,104;MSG1$;               
WRITE #44,R44,134;MSG2$;
MAT WRITE #44,R44,164;MSGS$;
x$=" ",x$
WRITE #44,R22,998;X$[1,1]; ! BLANK FOR KEY!
SEARCH #44,4,1;K44$,R44,E \ IF E error 11000
GOTO L_1915
L_1975: If P9$[8,8] = "Y" Gosub L_4300
if p61$[94,94]="Y" gosub updephist: ! 
If H5[7] = 20 And OREF[2] <> 0 Gosub L_4000
If H5[7]=19 And OT19Part Goto L_1995 ! not the final bill
if custom_customer$="SOUTHJERSEY"
	call "obtrakr.dl4",H0[4],0,invno,0,e$,IntCo,rstr$,statchan ! don't know custrec or custchannel
Endif
If Not(EDII) Goto L_1995
K67$ = SRN[2] Using "######" + "." + SRN[1] Using "&&&&&&"
Search #67,2,1;K67$,R[67],E \ If E > 2 error 11000
If Not(E)
  Mat Read #67,R[67],8;EDILTP$;
  K51$ = EDILTP$
Else 
  K51$ = H0[1] Using "CN######"
End If 
Search #51,2,1;K51$,R[51],E \ If E > 1 error 11000
If E Goto L_1995
Mat Read #51,R[51],8;TP;
If Not(Int(Abs(TP[810]))) Goto L_856 ! 1995
if custom_customer$ = "HATHAWAY" ! 240481
	if h0[12]=10 or h0[12]=23 goto L_856 ! 1995 ! no edi on terms 10 or 23
Endif
K63$ = " ",K63$;K63$[1,12] = OREF[1] Using "30##########"
Search #63,2,1;K63$,R[63],E \ If E > 1 error 11000
For X1 = 0 To 8 \ TR[X1] = 0;TR1[X1] = 0 \ Next X1
TR2[0] = 0;TR2[1] = 0
If Not(E) Goto L_1960
E = 2 \ Search #63,1,0;K63$,R[63],E \ If E error 11000
Search #63,4,1;K63$,R[63],E \ If E error 11000
L_1960: Rem "write the file
WHPROD$ = " ",WHPROD$
Write #63,R[63],0;WHPROD$[1,12];
Mat Write #63,R[63],12;TR
Mat Write #63,R[63],48;TR1
Mat Write #63,R[63],102;TRUM$
Mat Write #63,R[63],106;TRVI$
Mat Write #63,R[63],126;TRCT$
Mat Write #63,R[63],128;TRDE$
Mat Write #63,R[63],158;TR2;
Mat Write #63,R[63],170;K63$;
L_856: REM CHECK FOR ASN
IF NOT(INT(ABS(TP[856]))) GOTO L_1995:
if custom_customer$="HTBERRY" ! They have the following active
 IF H5[0]<>998 GOTO L_1995:
Endif
IF H5[7]>2 GOTO L_1995:
LET K63$=" ",K63$;K63$[1,12]=OREF[1] USING "SO##########"
SEARCH #63,2,1;K63$,R[63],E \ IF E>1 error 11000
FOR X1=0 TO 8 \ LET TR[X1]=0;TR1[X1]=0 \ NEXT X1
LET TR2[0]=0;TR2[1]=0
IF NOT(E) GOTO L_1960A:
LET E=2 \ SEARCH #63,1,0;K63$,R[63],E \ IF E error 11000
SEARCH #63,4,1;K63$,R[63],E \ IF E error 11000
L_1960A: REM "write the file
LET WHPROD$=" ",WHPROD$
WRITE #63,R[63],0;WHPROD$[1,12];
MAT  WRITE #63,R[63],12;TR
MAT  WRITE #63,R[63],48;TR1
MAT  WRITE #63,R[63],102;TRUM$
MAT  WRITE #63,R[63],106;TRVI$
MAT  WRITE #63,R[63],126;TRCT$
MAT  WRITE #63,R[63],128;TRDE$
MAT  WRITE #63,R[63],158;TR2;
MAT  WRITE #63,R[63],170;K63$;
L_1995: Goto L_1200
L_2000: Rem "================================= lot files
If L3[0] Goto L_2595
If Not(WHSE) Let E = 0 \ error 11000
K14$ = " ",K14$;K14$ = L1$[1,12]
Search #14,2,1;K14$,R[14],E \ If E > 1 error 11000
If E error 11000
If R[14] <> L4[0] Let E = 0 \ error 11000
L_2060: Gosub L_6400
Unlock #14
K15$ = " ",K15$;K15$ = H0[7] Using "######"
K15$[7,9] = L3[2] Using "###";K15$[10,11] = Abs(WHSE) Using "##"
BREAK$ = K15$
L_2085: Search #15,3,3;K15$,R[15],E \ If E > 2 error 11000
If E Goto L_2595
If K15$[1,11] <> BREAK$[1,11] Goto L_2595
If Not(KIT) If K15$[30,32] = "KIT" Goto L_2085
If KIT If K15$[30,32] <> "KIT" Goto L_2085
LN = K15$[33,35] \ If KIT If LN <> KL1[1] Goto L_2085
If K15$[40,40] = "4" Goto L_2085
Mat Read #15,R[15],0;S0$
Mat Read #15,R[15],60;LOTS3
Mat Read #15,R[15],96;OL2$
If DEBUG Print #DBChan;"    read sordlot ";K15$;" rec #";R[15]
If H5[7] = 21 Or H5[7] = 22 Let LOTS3[3] = 0
If WHSE < 0
  If H5[7] <> 4 Let Q1 = LOTS3[1] Else Let Q1 = LOTS3[5]
  If H5[7] = 15 If Not(H0[5]) Let Q1 = LOTS3[1]
  If H5[7] = 15 If H0[5] Let Q1 = 0
Else 
  Q1 = LOTS3[4]
End If 
If H5[7]=19 And Not(OT19Part) Let Lots3[1]=0;Lots3[3]=0;Q1=0 ! "no ship/bo - final
STOCK$ = " ",STOCK$;STOCK$[1,12] = S0$[13,24];STOCK$[13,22] = OL2$[1,10]
If Not(L3[1]) Goto L_2215
If KIT Let OL2$[1,10] = "          "
K16$ = " ",K16$;K16$[1,2] = Abs(WHSE) Using "##";K16$[3,8] = OL2$[11,16]
K16$[9,32] = S0$[1,24];K16$[33,42] = OL2$[1,10]
Search #16,2,3;K16$,R[16],E \ If E > 1 error 11000
If E If Not(Q1) Goto L_2215
If E error 11000
Mat Read #16,R[16],82;P3
If WHSE < 0 Let P3[1] = P3[1] + Q1;INVBAL[0] = INVBAL[0] - Q1
If WHSE < 0 If Q1 > 0 Let P3[3] = P3[3] - Q1
If WHSE < 0 And Q1 > 0 And H5[7] = 24 Let P3[3] = P3[3] + Q1
If WHSE > 0 Let P3[0] = P3[0] + Q1;INVBAL[1] = INVBAL[1] + Q1
If MKIT = 9 Let P3[0] = P3[0] + Q1;INVBAL[0] = INVBAL[0] + Q1
Write #16,R[16],74;H0[8]
Mat Write #16,R[16],82;P3;
L_2215: If H5[7] = 24 Goto L_2400
If H5[7] <> 4 And H5[7] <> 15 If Not(LOTS3[3]) Goto L_2260
IF H5[7] = 4 if lots3[0] <= lots3[1] and lots3[3]=0 GOTO L_2260 ! "none on b/o    
If H5[7] = 15 If L7[2] <= (L7[0] + L7[4]) Goto L_2260
If H5[7] <> 4 Let LOTS3[0] = L7[3];LOTS3[1] = 0
If H5[7] = 4
  LOTS3[0] = LOTS3[0] - LOTS3[5];LOTS3[1] = LOTS3[1] - LOTS3[5];LOTS3[5] = 0
End If 
If H5[7] = 15 If Not(H0[5]) Let LOTS3[0] = 0;LOTS3[1] = 0;LOTS3[5] = 0
If WHSE > 0 Let LOTS3[4] = 0
Write #15,R[15],48;H0[8]
Mat Write #15,R[15],60;LOTS3;
If DEBUG Print #DBChan;"    sordlot not deleted. ";K15$;" rec #";R[15]
Goto L_2400
L_2260: Rem "delete sordlot
Z1$ = K15$
Search #15,5,3;K15$,R[15],E \ If E error 11000
K15$[1,22] = Z1$[18,39];K15$[23,39] = Z1$[1,17];K15$[40,51] = S0$[1,12];K15$[52,52] = " "
Search #15,5,2;K15$,R[15],E \ If E error 11000
K15$[1,12] = S0$[1,12];K15$[13,29] = Z1$[1,17];K15$[30,51] = Z1$[18,39];K15$[52,52] = " "
Search #15,5,1;K15$,R[15],E \ If E error 11000
E = 3 \ Search #15,1,0;K15$,R[15],E \ If E error 11000
If DEBUG Print #DBChan;"    deleted sordlot ";K15$;" rec #";R[15]
K15$ = Z1$
L_2400: Rem "================================================== lottrans
If P9$[9,9] <> "Y" Goto L_2580
If Not(L3[1]) Goto L_2590
Gosub L_3500 \ Gosub L_6450
Unlock #6
itr.ProdCode$=B$;itr.LotNum$=b$;itr.SrcCode$=b$ ! L0$ = " ",L0$;TRANL1$ = " ",TRANL1$
itr.Comment$=b$;itr.Loc$=b$
itr.ProdCode$=S0$[1,12];itr.LotNum$=S0$[13,24] !L0$[1,24] = S0$[1,24]
itr.SrcCode$[1,1] = "I";itr.SrcCode$[2,9] = OREF[1] Using "########"
itr.SrcCode$[10,12] = L3[2] Using "###"
itr.Comment$[1,5] = "CUST#";itr.Comment$[6,12] = H0[4] Using " ######";itr.Comment$[13]=B$
itr.Whse = Abs(WHSE);itr.EntBy = H5[0];itr.Tiebrkr = 0
If Not(Q1) Goto L_2585
If Q1 >= 0 ! "positive qty
  If WHSE < 0
    If H5[7] = 8 Let itr.TrnsType = 20 Else Let itr.TrnsType = 16
  Else 
    itr.TrnsType = 8
  End If 
  If H5[7] = 16 If WHSE >= 0 Let itr.TrnsType = 10
  If H5[7] = 16 If WHSE < 0 Let itr.TrnsType = 28
Else 
  If WHSE < 0 Let itr.TrnsType = 3 Else Let itr.TrnsType = 9
  If H5[7] = 16 If WHSE >= 0 Let itr.TrnsType = 28
End If 
If H5[7] = 6 Or H5[7] = 10 Let itr.TrnsType = 26
If MKIT = 9 If itr.TrnsType > 15 Let itr.TrnsType = 12
If MKIT = 9 If itr.TrnsType <> 12 If itr.TrnsType < 16 Let itr.TrnsType = 21
If KIT If PASS = 1 Let itr.TrnsType = 21
If KIT If PASS = 2 Let itr.TrnsType = 12
itr.Loc$ = OL2$[11,16]
itr.TrnsDate = H0[8];itr.Qty = Abs(Q1);itr.CostLoad = L5[1]
If WHSE < 0 Let itr.RunInvt = INVBAL[0] Else Let itr.RunInvt = INVBAL[1]
itr.CostAvg = B[21];itr.NetPrice = OLM[3]
If P9$[32,32] = "Y" If W3[15] Let itr.CostAvg = W3[15]
itr.Wgt = (ROLS3[4]*Sgn(L7[4])) ! "lbs
CH_INVTR = 17
!Call "MAKETRANS",L0$,TRANL1[],TRANL2[],TRANL1$,CH_INVTR
Call MakeTrans(e$,IntCo,CH_INVTR,Status,ITR.) !  as invtrans)
! This program ONLY takes care of adding a record and finding a unique (non-
! duplicated) key.  The calling program must still set all variables needed
! and send over via the "call" with the proper File Structure.
! The NSInvtrans & Invtrans Files should be exactly the same
! Variables In
! e$		Error Message
! IntCo		Company #
! ITC		Invtrans Channel #
! Status	Status of call (0=NG, 1+=Record added)
! ITR.		File Structure
If DEBUG Print #DBChan;"Create Invtrans ";itr.prodcode$;" Status= ";status
L_2580: If MKIT = 9 Let MKIT = 1 \ Goto L_2400
L_2585: If WHSE < 0 If H5[7] <> 7 Gosub L_5300
If Not(KIT) If MKIT = 1 Let MKIT = 9
L_2590: Goto L_2085
L_2595: Return 
E = 0 \ error 11000
A$ = " ",A$ \ A$ = H0[1] Using "######"
A$[7] = (H0[7] * 10) + (L3[2] - 990) Using "######" \ A$[13] = "7"
Search #7,2,1;A$,V1,E
If E = 1 Goto L_3085
If E error 11000
Mat Read #7,V1,0;A2;
H = Int(Fra(A2[3]) * 100)
If H <> 7 Return 
A2[3] = A2[3] + .001
Mat Write #7,V1,0;A2;
Mat Read #7,V1,24;A3;
T9[0] = (A3[0] - A3[1] - A3[2])
If T2[0] < 0 Goto L_3065
If T9[2] < T9[0] Let T9[0] = T9[2] \ Gosub L_3100
L_3065: T9[1] = T9[1] + T9[0]
T9[2] = T9[2] - T9[0]
A3[2] = A3[2] + T9
Mat Write #7,V1,24;A3;
L_3085: Return 
L_3100: Rem "update qty b'ord and price for deposits
Return 
updateups: ! copy data from ups tracking file
if ch_ups<1 return ! file not found
if ch_upsh<1 return ! file not found
kups$=" ",kups$
let kups$[1,6]=h0[7] using "######"
upst_loop: ! 
search #ch_ups,3,1;kups$,rec_ups,e
if e=2 goto upsdone:
upsord=kups$[1,6]
if upsord<>h0[7] goto upsdone:
MAT READ #CH_UPS,REC_UPS,0;UPST;
MAT READ #CH_UPS,REC_UPS,16;UPST$;
MAT READ #CH_UPS,REC_UPS,46;UPS3;
LET Kupsh$[1,10]=oref[1] USING "##########" !  "Invoice #      
LET Kupsh$[11,13]=UPST[1] USING "###" ! "line #                
LET Kupsh$[14,19]=UPST[2] USING "&&&&&&" ! "zero fill! ! "date 
LET Kupsh$[20,22]=Kups$[16,18]
SEARCH #ch_upsh,2,1;Kupsh$,rec_upsh,E 
if e=0 
MAT READ #CH_UPSH,REC_UPSH,16;TUPST$;
if tupst$=UPST$ goto SKIPADD: ! already in file get next
let e=0
error 11000
endif
LET E=2;rec_upsh=0       
let ups3=oref[1]
SEARCH #ch_upsh,1,0;Kupsh$,rec_upsh,E \ IF E error 11000 
MAT  WRITE #ch_upsh,rec_upsh,0;UPST;                         
MAT  WRITE #ch_upsh,rec_upsh,16;UPST$;                       
MAT  WRITE #ch_upsh,rec_upsh,46;UPST3;                       
SEARCH #ch_upsh,4,1;Kupsh$,rec_upsh,E \ IF E error 11000
SKIPADD: ! 
REM REMOVE FROM ORDER TRACKING FILE
Search #CH_UPS,5,1;KUPS$,REC_UPS,E \ If E error 11000
E = 3 
Search #CH_UPS,1,0;KUPS$,REC_UPS,E \ If E error 11000
goto upst_loop: 
upsdone: ! 
return

L_3200: Rem "=============== check if valid kit
K28$ = " ",K28$;K28$ = K11$[1,9]
Search #28,2,1;K28$,R[28],E \ If E Goto L_3800
If K28$[1,9] <> K11$[1,9] Goto L_3800
If P9$[22,22] <> "Y" Goto L_3800
If L7[4] = 0 Goto L_3800
If L3[0] = 1 Goto L_3800
Mat Read #28,R[28],0;KL$;
If KL$[1,12] <> L1$[1,12] Goto L_3800
If L1$[14,16] <> "KIT" Goto L_3800
If S2[0] <> 0 Goto L_3800
MKIT = 9
Return 
L_3300: Rem "============ do kit lines
If MKIT = 9 Let MKIT = 1
K28$ = " ",K28$;K28$[1,9] = K11$[1,9]
L_3310: Search #28,3,1;K28$,R[28],E \ If E Return 
If K28$[1,9] <> K11$[1,9] Return 
INVBAL[0] = 0;INVBAL[1] = 0
If Not(MKIT) Goto L_3850
Mat Read #28,R[28],0;KL$;
If L1$[14,16] <> "KIT" Goto L_3850
If KL$[1,12] <> L1$[1,12] Goto L_3850
Mat Read #28,R[28],58;KL1;
Mat Read #28,R[28],70;KL2;
Mat Read #28,R[28],78;KL3;
If P9$[8,8] <> "Y" Goto L_3370
K29$ = " ",K29$;K29$ = K28$;K29$[1,10] = OREF[1] Using "##########"
K29$[11] = K28$[7]
Search #29,2,1;K29$,R[29],E \ If Not(E) Goto L_3850
L_3370: K14$ = " ",K14$;K14$ = KL$[13,24]
If KL1[5] = -2 Goto L_3700
Search #14,2,1;K14$,R[14],E \ If E Goto L_3700
Gosub L_6400
If PRODA$[152,155] = "MACH" Or PRODA$[152,155] = "TIME" Or PRODA$[152,155] = "LABR" Let KL1[3] = 1
If KL1[3] = 1 Goto L_3400
If (H5[7] = 8 Or H5[7] = 16) Goto L_3395
A[0] = A[0] - KL3[1]
L_3395: A[1] = A[1] - KL3[1] \ If A[1] < 0 Let A[1] = 0
L_3400: A[13] = A[13] + KL3[1];A[14] = A[14] + KL3[1]
A[15] = A[15] + FNR(KL3[0] * KL3[1]);A[16] = A[16] + FNR(KL3[0] * KL3[1])
B[13] = H0[8]
Mat Write #14,R[14],256;A
Mat Write #14,R[14],156;B;
if sqlChan >= 0 ! MySQL enabled and channel opened
	e = prod_UpdateSQLFromDL4(e$, intCo, K14$, sqlChan, 14)
	if e <> 1 ! returns the number of records add/updated/deleted
		error 11000
	end if
end if
WHSE = 0 - LWHSE;PASS = 1
Gosub L_3610
If (H5[7] = 7 Or H5[7] = 8 Or H5[7] = 16) Let WHSE = 0 - H5[11];PASS = 2 \ Gosub L_3610
KIT = 9;MKIT = 1;L3[0] = 0;L5[1] = KL3[0]
L7[0] = 0;L7[1] = 0;L7[2] = KL3[1];L7[3] = 0;L7[4] = KL3[1]
L5[2] = 0;L3[1] = 1;OLM[3] = 0
If KL1[3] = 1 Let L3[1] = 0
WHSE = 0 - LWHSE \ If H5[7] = 7 Let WHSE = 0 - H5[11]
L4[0] = R[14];L6$[1,30] = PRODA$[9,38];L6$[31,60] = PRODA$[63,92]
PASS = 1 \ Gosub L_2060
If (H5[7] = 8 Or H5[7] = 16) Let WHSE = H5[11];PASS = 2 \ Gosub L_2060
Gosub L_4500
if p61$[104,104]="Y" GOSUB UPDATEROLLINV: ! rolls
Goto L_3700
L_3500: Rem "========================= check for prodwhse record
If L3[0] Return 
K6$ = " ",K6$;K6$[1,12] = PRODA$[140,151];K6$[13,14] = Abs(WHSE) Using "##"
Search #6,2,1;K6$,R[6],E \ If E > 1 error 11000
If E Goto L_3560
Mat Read #6,R[6],800;WHMISC;
Goto L_3600
DEFWHNUM = 0
If H5[7] = 7 Or H5[7] = 8 Or H5[7] = 16
  DEFWHNUM = LWHSE / 100
End If 
L_3560: WHPROD$[1,12] = K6$[1,12];WHBLD[0] = 6;WHBLD[1] = Abs(WHSE) + DEFWHNUM
WHBLD[2] = B[24]
!Call "MXWHCREATE",WHPROD$,WHBLD[]
call mxwhcreate(e$,IntCo,WHPROD$,WHBLD[])
! e$=error messages
! intco=Company ID #
! WHPROD$[1,12]=ITEM CODE
! WHBLD[0]=WHSE CHANNEL, WHBLD[1]=WHSE #, WHBLD[2]=RECNO TO SEND BACK
! ALSO: seems whbld[1] can have a fractional # - the default whse to copy
! ENTER DIMS:  WHPROD$[12],3%,WHBLD[2]
R[6] = WHBLD[2];E = 0;WHBLD[2] = 0
If DEBUG Print #DBChan;"   warehouse record created ";K6$;" rec";R[6]
L_3600: Return 
L_3610: Rem "======= kit update prodwhse file
If KL1[3] = 1 Return 
Gosub L_3500
Gosub L_6450
If PASS = 1 Let INVBAL[0] = W3[0]
If PASS = 2 And H5[7] = 7 Let INVBAL[0] = W3[0]
If PASS = 2 And (H5[7] = 8 Or H5[7] = 16) Let INVBAL[1] = W3[0]
If PASS = 1 If H5[7] = 7 Goto L_3680
If PASS = 1 Goto L_3634
If PASS = 2 If H5[7] = 7 Goto L_3634
W3[0] = W3[0] + KL3[1] \ Goto L_3670
L_3634: W3[0] = W3[0] - KL3[1]
KQTY = KL3[1]
If (H5[7] = 8 Or H5[7] = 16) Goto L_3670
W5[0] = W5[0] + KQTY;W5[ARMONTH] = W5[ARMONTH] + KQTY
If W3[9] If U4[0] If W3[9] + (W3[9] * U4[0] / 100) <= KQTY ! "check for exc. sale
  WH8[ARMONTH - 1 + 24] = 1
End If 
If W3[0] > 0 Goto L_3670
If W7[8] And Not(W7[9]) Goto L_3670
W7[8] = PCDATE;W7[11] = W7[11] + 1;W7[9] = 0;WH8[ARMONTH - 1] = 1
L_3670: W3[2] = W3[2] - KL3[1] \ If W3[2] < 0 Let W3[2] = 0
W2[7] = H0[8]
L_3680: Gosub L_6900
Return 
L_3700: Rem "========= xfer to kit history
If P9$[8,8] <> "Y" Goto L_3850
K29$ = " ",K29$;K29$[1,10] = OREF[1] Using "##########"
K29$[11] = K28$[7]
Search #29,2,1;K29$,R[29],E \ If Not(E) Goto L_3790
R[29] = 0;E = 2
Search #29,1,0;K29$,R[29],E \ If E error 11000
Search #29,4,1;K29$,R[29],E \ If E error 11000
KL2[1] = H0[4]
Mat Write #29,R[29],0;KL$;
Mat Write #29,R[29],58;KL1;
Mat Write #29,R[29],70;KL2;
Mat Write #29,R[29],78;KL3;
Mat Write #29,R[29],90;INVNO;
L_3790: Goto L_3850
L_3800: Rem INVALID KIT
L1$[14,16] = "   "
Mat Write #11,R[11],140;L1$;
MKIT = 0 \ Goto L_3850
L_3850: Rem DEL KIT
Goto L_3890
K29$ = K28$
Search #28,5,1;K29$,V1,E
If E = 1 Goto L_3890
If E error 11000
V1 = R[28];E = 3
Search #28,1,0;K29$,V1,E \ If E error 11000
L_3890: Goto L_3310
L_4000: Rem "=================== freight invoice update of orig. invoice
If H5[7] <> 20 Or OREF[2] <= 0 Return 
K2$ = " ",K2$;K2$[1,2] = "30";K2$[3] = OREF[2] Using "##########"
Search #2,2,1;K2$,V1,E \ If E Return 
AFRT = 2
Write #2,V1,120;AFRT;
Return 
L_4100: Rem "====================================== repair transactions
If P60$[25,25] <> "Y" Return 
If REPAIR = 1 Return 
If K11$[10,10] <> "A" Goto L_4280
If L3[0] = 1 Goto L_4280
RP$ = " ",RP$;Z1$ = K11$
For I = 0 To 3
  If I <= 2 Let RP0[I] = 0
  RP1[I] = 0
  If I <= 2 Let RP2[I] = 0
Next I
RP$[1,12] = L1$[1,12]
RP0[1] = HWHSE;RP1[0] = H0[8];RP1[1] = H0[7];RP2[2] = OREF[1];RP1[3] = H0[4]
RP2[0] = T2[0];RP2[1] = T2[17]
If H5[7] = 21 Let RP0[0] = 1
K11$[10,10] = "B"
Search #11,2,1;K11$,V1,E \ If E > 1 error 11000
If E = 1 Goto L_4275
Mat Read #11,V1,80;L6$; \ Mat Read #11,V1,260;ROLS3;
RP$[13,42] = L6$[1,30]
RP$[103,132] = S1$[1,30]
K11$[10,10] = "C"
Search #11,2,1;K11$,V1,E \ If E > 1 error 11000
If E = 1 Goto L_4200
Mat Read #11,V1,80;L6$;
RP$[43,102] = L6$[1,60]
L_4200: Rem UPDATE SERIAL NO FILE
Gosub L_6300
Gosub L_4400
Goto L_4275
K30$ = " ",K30$;K30$[1,42] = RP$[1,42]
K30$[43] = RP1[1] Using "######"
Search #30,2,1;K30$,R[30],E \ If E = 0 Goto L_4275
If E > 1 error 11000
E = 2;R[30] = 0
Search #30,1,0;K30$,R[30],E \ If E error 11000
Search #30,4,1;K30$,R[30],E \ If E error 11000
RP2[2] = OREF[1]
Mat Write #30,R[30],0;RP$; \ Mat Write #30,R[30],132;RP0;
Mat Write #30,R[30],138;RP1; \ Mat Write #30,R[30],154;RP2;
K30$ = " ",K30$;K30$[1,30] = RP$[13,42];K30$[31,42] = RP$[1,12]
K30$[43] = RP1[1] Using "######"
Search #30,4,2;K30$,R[30],E \ If E error 11000
L_4275: K11$ = Z1$
L_4280: REPAIR = 1
Return 
L_4300: Rem "=========================================== cash sales info
K19$ = " ",K19$;K19$ = H0[7] Using "######"
Search #19,2,1;K19$,R[19],E \ If E > 1 error 11000
If E Goto L_4395
Mat Read #19,R[19],0;CSH0
K20$ = " ",K20$;K20$ = OREF[1] Using "##########"
Search #20,2,1;K20$,R[20],E \ If E > 1 error 11000
If Not(E) Goto L_4395
E = 2 \ Search #20,1,0;K20$,R[20],E \ If E error 11000
Mat Read #19,R[19],20;CSH1
Mat Read #19,R[19],38;CSH0$
Mat Read #19,R[19],194;BNK
Mat Read #19,R[19],198;CH_CCN
Mat Read #19,R[19],238;CH_CCA$
Mat Read #19,R[19],364;CC_TT$
Mat Read #19,r[19],368;CCSP$;
Mat read #19,r[19],384;cctran2$;
Mat read #19,r[19],414;ccauth1$;
Mat read #19,r[19],424;ccauth2$;
Mat read #19,r[19],434;ccsp2$;
  
Mat Write #20,R[20],0;CSH0
Mat Write #20,R[20],20;CSH1
Mat Write #20,R[20],38;CSH0$
Mat Write #20,R[20],194;BNK
Mat Write #20,R[20],198;CH_CCN
Mat Write #20,R[20],238;CH_CCA$;
Mat Write #20,R[20],358;INVNO;
Mat Write #20,R[20],364;CC_TT$;
Mat write #20,r[20],384;cctran2$;
Mat write #20,r[20],414;ccauth1$;
Mat write #20,r[20],424;ccauth2$;
Mat write #20,r[20],434;ccsp2$;
Search #20,4,1;K20$,R[20],E \ If E error 11000
If DEBUG Print #DBChan;"   write cash sale history ";K20$;" rec #";R[20]
L_4395: Return 

Updephist: ! update deposit history file
if p61$[94,94]<>"Y" return
let keyrod$=" ",keyrod$
let keyrod$[1,6]=H0[4] using "######"
let keyrod$[7,12]=h0[7] using "######"
let chkdep$=keyrod$[1,12]
searchdep: ! search thru deposit file
search #ch_rod,3,1;keyrod$,rec_rod,e
if e=2 return
if e<>0 error 11000
if keyrod$[1,12]<>chkdep$[1,12] return
Mat read #ch_rod,rec_rod,0;dep1;
Mat read #ch_rod,rec_rod,32;dep2;
Mat Read #ch_rod,rec_rod,74;dep3;
let keyrodh$=" ",keyrodh$
let keyrodh$[1,6]=h0[4] using "######"
let keyrodh$[7,16]=oref[1] using "##########"
let keyrodh$[17,18]=dep1[2] using "##"
let dep2[3]=oref[1]
search #ch_rodh,2,1;keyrodh$,rec_rodh,e
if e> 1 error 11000
if not(e) goto searchdep:
let e=2\search #ch_rodh,1,0;keyrodh$,rec_rodh,e\if e error 11000
Mat write #ch_rodh,rec_rodh,0;dep1;
Mat write #ch_rodh,rec_rodh,32;dep2;
Mat write #ch_rodh,rec_rodh,74;dep3;
search #ch_rodh,4,1;keyrodh$,rec_rodh,e\if e error 11000
goto searchdep: ! 

L_4400: Rem "====================== repair serial number update
K26$ = " ",K26$;K26$ = RP$[13,42]
Search #26,2,1;K26$,R[26],E \ If E > 1 error 11000
If E = 1 Return 
L_4420: Mat Read #26,R[26],0;SN$;
If SN$[1,12] = RP$[1,12] Goto L_4450
Search #26,3,1;K26$,R[26],E \ If E = 2 Goto L_4490
If E error 11000
If K26$[1,30] <> RP$[13,42] Goto L_4490
Goto L_4420
L_4450: Rem UPDATE REPAIR INFO IN SERIAL FILE
Mat Read #26,R[26],298;SN2 \ Mat Read #26,R[26],342;SN3
SN2[8] = H0[8]
If H5[7] = 21 Let SN3[5] = SN3[5] + RP2[1]
If H5[7] = 22 Let SN3[3] = SN3[3] + RP2[1]
Mat Write #26,R[26],298;SN2 \ Mat Write #26,R[26],342;SN3;
Return 1
L_4490: Return 
L_4500: Rem "=================================== serial numbers
LOTCNT = 0 \ If P9$[1,1] = "Y" Let LOTCNT = 1
If P9$[1,1] = "B" And PRODA$[113,113] = "Y" Let LOTCNT = 1
K24$ = " ",K24$;K24$[1,6] = H0[7] Using "######";K24$[7,9] = L3[2] Using "###"
BREAK$ = K24$
L_4520: Search #24,3,1;K24$,R[24],E \ If E > 2 error 11000
If E Goto L_4990
If K24$[1,9] <> BREAK$[1,9] Goto L_4990
Mat Read #24,R[24],0;SN1$;
If SN1$[1,12] <> PRODA$[140,151] Goto L_4520
If L7[4] = 0 Goto L_4955
If L3[0] Goto L_4955
If PRODA$[8,8] <> "Y" Goto L_4955
Mat Read #24,R[24],0;SN1$
Mat Read #24,R[24],54;SN0
Mat Read #24,R[24],62;SN1
If Not(LOTCNT) Let SN1$[13,24] = "STOCK        "
If SN1$[13,17] = "STOCK"
  If H5[7] <> 16 !not tansfers
    SN1$[13,24] = HWHSE Using "STOCK&&      "
  Else 
    SN1$[13,24] = H5[11] Using "STOCK&&      "
  End If 
End If 
NEWSN=1
If SN1 = 1 Gosub L_4900
!
if newsn
	SN$ = " ",SN$;SN$[1,24] = SN1$[1,24];SN$[35,64] = SN1$[25,54]
endif
L_4640: SN$[85,144] = L6$
SN$[145,174] = S1$[1,30]
SERSN1[0] = HWHSE;SERSN1[1] = PFU1;SERSN1[2] = 1
If H5[7] <> 16 And H5[7] <> 8 !not transfers and not consignment whse
  SN2[6] = H0[8];SN2[4] = H0[7];SN2[5] = H0[4];SN3[1] = OLM[3] - ROLS3[15]
Else 
  SERSN1[0] = H5[11];SERSN1[2] = 0
End If 
SN3[2] = L5[1] \ If L7[4] < 0 Let SERSN1[2] = 0
SN$[65,84] = PSN$
SN2[7] = PSN[1]
If SN1 = 1 Goto L_4765
K26$ = " ",K26$;K26$[1,30] = SN$[35,64]
R[26] = 0;E = 2
Search #26,1,0;K26$,R[26],E \ If E error 11000
K26$[31] = R[26] Using "##########"
Search #26,4,1;K26$,R[26],E \ If E error 11000
K26$ = " ",K26$;K26$[1,24] = SN$[1,24]
K26$[25] = R[26] Using "##########"
Search #26,4,2;K26$,R[26],E \ If E error 11000
L_4765: SN$[25,34] = R[26] Using "##########"
Mat Write #26,R[26],0;SN$
Write #26,R[26],284;INVNO
Mat Write #26,R[26],290;SERSN1
Mat Write #26,R[26],298;SN2
Mat Write #26,R[26],342;SN3
If P9$[8,8] <> "Y" Goto L_4870
K25$ = " ",K25$;K25$[1,10] = OREF[1] Using "##########"
K25$[11,13] = L3[2] Using "###";K25$[14,43] = SN1$[25,54]
Search #25,2,1;K25$,R[25],E \ If E > 1 error 11000
If Not(E) Goto L_4870
E = 2 \ Search #25,1,0;K25$,R[25],E \ If E error 11000
Search #25,4,1;K25$,R[25],E \ If E error 11000
SNH$ = " ",SNH$;SNH$ = SN1$
SNH[0] = H0[7];SNH[1] = R[26]
SNH1 = SN1
Mat Write #25,R[25],0;SNH$
Mat Write #25,R[25],54;SNH
Mat Write #25,R[25],62;SNH1;
Write #25,R[25],64;INVNO;
L_4870: Rem
Goto L_4955
!
L_4900: Rem FLAG SAYS EXISTING (USE SN0[1])
R[26] = SN0[1] \ If R[26] <= 0 Let SN1 = 0 \ newsn=1 \ return
Mat Read #26,R[26],0;SN$
If SN$[1,12] <> SN1$[1,12] Let SN1 = 0 \ newsn=1 \ return
Mat Read #26,R[26],290;SERSN1
Mat Read #26,R[26],298;SN2
Mat Read #26,R[26],342;SN3
If SN$[13,24] = SN1$[13,24] newsn=0 \ return
K26$ = " ",K26$;K26$[1,24] = SN$[1,24];K26$[25,34] = R[26] Using "##########"
Search #26,5,2;K26$,R[26],E \ If E error 11000
K26$[13,24] = SN1$[13,24]
Search #26,4,2;K26$,R[26],E \ If E error 11000
SN$[13,24] = SN1$[13,24] \ Mat Write #26,R[26],0;SN$
newsn=0
return
!
L_4955: Rem DEL
Z1$ = K24$
Search #24,5,1;K24$,R[24],E \ If E error 11000
K24$ = " ",K24$;K24$[1,30] = Z1$[10,39];K24$[31,36] = R[14] Using "######"
Search #24,5,2;K24$,R[24],E \ If E error 11000
E = 3 \ Search #24,1,0;K24$,R[24],E \ If E error 11000
K24$ = Z1$ \ Goto L_4520
L_4990: Return 

UPDATEROLLINV: REM update roll  inventory file
if p61$[104,104]<>"Y" return
IF NOT(L7[4]) RETURN 
IF L3[0] RETURN 
IF PRFLG$[6,6]<>"Y" RETURN 
LET KEYORL1$=" ",KEYORL1$;KEYORL1$[1,6]=H0[7] USING "######";KEYORL1$[7,9]=L3[2] USING "###"
LET BREAK$=KEYORL1$
SRCHORDRL: SEARCH #41,3,1;KEYORL1$,R[41],E \ IF E=2 RETURN 
IF E error 11000
IF KEYORL1$[1,9]<>BREAK$[1,9] RETURN 
MAT  READ #41,R[41],0;SOR$;
MAT  READ #41,R[41],62;SOR1;
MAT  READ #41,R[41],86;SOR2
LET KEYORLH1$=" ",KEYORLH1$
FOR X=0 TO 3 \ LET SORH2[X]=SOR2[X] \ NEXT X
LET SORH2[1]=OREF[1]
LET KEYORLH1$[1,8]=SORH2[1] USING "########"
LET KEYORLH1$[9,11]=SOR1[1] USING "###"
LET KEYORLH1$[13,32]=SOR$[13,32]
SEARCH #42,2,1;KEYORLH1$,R[42],E \ IF E>1 error 11000
IF (E) ! new record
  LET E=2 \ SEARCH #42,1,0;KEYORLH1$,R[42],E \ IF E error 11000
  SEARCH #42,4,1;KEYORLH1$,R[42],E \ IF E error 11000
ENDIF 
MAT  WRITE #42,R[42],0;SOR$
MAT  WRITE #42,R[42],62;SOR1
MAT  WRITE #42,R[42],86;SORH2;
LET KEYRL1$=" ",KEYRL1$
LET KEYRL1$[1,12]=SOR$[1,12]
LET KEYRL1$[13,14]=SOR1[0] USING "##"
LET KEYRL1$[15,34]=SOR$[13,32]
SEARCH #40,2,1;KEYRL1$,R[40],E \ IF E>1 error 11000
IF E=1 GOTO DELORDROLL:
MAT  READ #40,R[40],0;RL0$
MAT  READ #40,R[40],62;RL1
MAT  READ #40,R[40],102;RL2
MAT  READ #40,R[40],150;RLUSER$
LET KEYRL2$=" ",KEYRL2$
LET KEYRL2$[1,20]=RL0$[13,32]
LET KEYRL2$[21,32]=RL0$[1,12]
LET KEYRL2$[33,34]=RL1[0] USING "##"
IF H5[7]=16 ! or h5[7]=8 ! moving to another warehouse only for transfer
  LET RL1[0]=H5[11]
  MAT  WRITE #40,R[40],0;RL0$
  MAT  WRITE #40,R[40],62;RL1
  MAT  WRITE #40,R[40],102;RL2
  MAT  WRITE #40,R[40],150;RLUSER$;
  LET NKEYRL1$=KEYRL1$
  LET NKEYRL1$[13,14]=RL1[0] USING "##"
  SEARCH #40,4,1;NKEYRL1$,R[40],E \ IF E error 11000
  SEARCH #40,5,1;KEYRL1$,R[40],E \ IF E error 11000
  LET NKEYRL2$=KEYRL2$
  LET NKEYRL2$[33,34]=RL1[0] USING "##"
  SEARCH #40,4,2;NKEYRL2$,R[40],E \ IF E error 11000
  SEARCH #40,5,2;KEYRL2$,R[40],E \ IF E error 11000
ELSE 
  SEARCH #40,5,2;KEYRL2$,R[40],E \ IF E error 11000
  SEARCH #40,5,1;KEYRL1$,R[40],E \ IF E error 11000
  LET E=3 \ SEARCH #40,1,0;KEYRL1$,R[40],E \ IF E error 11000
ENDIF 
DELORDROLL: REM delete from current order file
LET KEYORL2$=" ",KEYORL2$
LET KEYORL2$[1,20]=SOR$[13,32]
LET KEYORL2$[21,26]=SOR2[3] USING "######"
LET KEYORL2$[27,32]=SOR2[1] USING "######"
LET KEYORL2$[33,35]=SOR1[1] USING "###"
SEARCH #41,5,2;KEYORL2$,R[41],E \ IF E error 11000
SEARCH #41,5,1;KEYORL1$,R[41],E \ IF E error 11000
LET E=3 \ SEARCH #41,1,0;KEYORL1$,R[41],E \ IF E error 11000
GOTO SRCHORDRL:
RETURN 


L_5000: Rem ============= CREATE INVHKEY KEYS
K32$ = " ",K32$
K32$[1,2] = ARYEAR Using "&&"
K32$[3,4] = ARMONTH Using "&&"
X2 = K32$[1,4] \ Gosub L_7860
K32$[1,6] = X2 Using "######"
K32$[7,8] = "30"
K32$[9,18] = OREF[1] Using "##########"
Search #32,4,1;K32$,R[2],E \ If E error 11000
K32$ = " ",K32$
K32$[1,6] = JIDATE Using "######"
K32$[7,8] = "30"
K32$[9,18] = OREF[1] Using "##########"
Search #32,4,2;K32$,R[2],E \ If E error 11000
K32$ = " ",K32$
K32$[1,6] = H0[7] Using "######"
K32$[7,16] = OREF[1] Using "##########"
Search #32,4,3;K32$,R[2],E \ If E error 11000
K32$ = " ",K32$
K32$[1,10] = OREF[3] Using "##########"
K32$[11,15] = JIDATE Using "#####"
K32$[16,25] = OREF[1] Using "##########"
Search #32,4,4;K32$,R[2],E \ If E error 11000
K32$ = " ",K32$
K32$[1,6] = H0[4] Using "######"
K32$[7,16] = OREF[3] Using "##########"
K32$[17,21] = JIDATE Using "#####"
K32$[22,31] = OREF[1] Using "##########"
Search #32,4,5;K32$,R[2],E \ If E error 11000
!"cct#210803
if icflag   !"build the key on 6/ictrack file
   let k69$=" ",k69$
   let k69$[1,2]=0 using "&&"
   let k69$[3,4]=30 using "##"
   let k69$[5,14]=OREF[1] using "##########"
   let k69$[15,20]=h0[7] using "######"
   let k69$[21,26]=h0[4] using "######"
   let k69$[27,32]=0 using "&&&&&&"
   SEARCH #69,4,1;K69$,r[2],E \ IF E error 11000
   let k69$=" ",k69$                         
   let k69$[1,2]=0 using "&&"                
   let k69$[3,4]=30 using "##" 
   let k69$[5,10]=0 using "&&&&&&"   
   let k69$[11,20]=OREF[1] using "##########"       
   let k69$[21,26]=h0[7] using "######"      
   let k69$[27,32]=h0[4] using "######"      
   SEARCH #69,4,2;K69$,r[2],E \ IF E error 11000   
endif
Return 
!
L_5100: Rem Get system cost as determined by rebate cost type from screen2 of vend
K33$ = VENDOR Using "######"
Search #33,2,1;K33$,R[33],E \ If E > 2 error 11000
If Not(E)
  Mat Read #33,R[33],206;M1;
Else 
  Mat M1 = Zer \ M1 = 0
End If 
M1[17] = Int(M1[17])
If M1[17] < 1 Or M1[17] > 6 Let M1[17] = 4
If P9$[32,32] = "Y"
  K6$ = " ",K6$;K6$[1,12] = PRODA$[140,151];K6$[13,14] = L4[3] Using "##"
  Search #6,2,1;K6$,R[6],E \ If E > 1 error 11000
  If Not(E) Gosub L_6450 \ Unlock #6
  If E Mat W3 = Zer \ Mat W7 = Zer \ Mat WHLV = Zer
  If M1[17] = 1 Let TR2[0] = W3[17]
  If M1[17] = 2 Let TR2[0] = W3[14]
  If M1[17] = 3 Let TR2[0] = W3[15]
  If M1[17] = 4
    TR2[0] = W3[16]
    If W7[14] And WHLV[2] !"does old last cost and date of change exist?
      CHG_DATE$ = WHLV[2] Using "&&&&&&" \ Call DateToJulian(1,CHG_DATE$,CHG_DATE$,E1)
      ACPT_DATE$ = Int(T2[25] / 100) Using "&&&&&&" \ Call DateToJulian(1,ACPT_DATE$,ACPT_DATE$,E2)
      If Not(E1) And Not(E2)
        CHG_DATE = CHG_DATE$;ACPT_DATE = ACPT_DATE$
        If ACPT_DATE - CHG_DATE <= 14 Let TR2[0] = W7[14]
      End If 
    End If 
  End If 
  If M1[17] = 5 Let TR2[0] = W3[18]
  if m1[17] = 6 let tr2[0] = whmisc[2]
End If 
L_5212: If P9$[32,32] <> "Y" Or TR2[0] = 0
  If M1[17] = 1 Let TR2[0] = B[8]
  If M1[17] = 2 Let TR2[0] = PF_LOAD2
  If M1[17] = 3 Let TR2[0] = B[21]
  If M1[17] = 4
    TR2[0] = B[10]
    If PLC[2] And PLC[3] !"does old last cost and date of change exist?
      CHG_DATE$ = PLC[3] Using "&&&&&&" \ Call DateToJulian(1,CHG_DATE$,CHG_DATE$,E1)
      ACPT_DATE$ = Int(T2[25] / 100) Using "&&&&&&" \ Call DateToJulian(1,ACPT_DATE$,ACPT_DATE$,E2)
      If Not(E1) And Not(E2)
        CHG_DATE = CHG_DATE$;ACPT_DATE = ACPT_DATE$
        If ACPT_DATE - CHG_DATE <= 14 Let TR2[0] = PLC[2]
      End If 
    End If 
  End If 
  If M1[17] = 5 Let TR2[0] = PR_C4[4]
  if m1[17] = 6 let tr2[0] = prparc[2]
End If 
If Not(TR2[0]) And M1[17] <> 4 Let M1[17] = 4 \ Goto L_5212
Return 
L_5300: Rem "======================================== product pick count
If H5[7]=19 And Not(OT19Part) Return ! "no picking on final
K21$ = " ",K21$;K21$[1,2] = Abs(WHSE) Using "##"
K21$[3,14] = S0$[1,12]
K21$[15,20] = OL2$[11,16]
Search #21,2,1;K21$,R[21],E \ If E > 1 error 11000
If Not(E) Goto L_5400
E = 2 \ Search #21,1,0;K21$,R[21],E \ If E error 11000
Search #21,4,1;K21$,R[21],E \ If E error 11000
PICKP2$ = " ",PICKP2$;PICKP2$[1,12] = S0$[1,12]
PICKP2$[13,18] = OL2$[11,16]
PICKP2[0] = R[14]
PICKP2[1] = Abs(WHSE);PICKP2[2] = 0
For I = 0 To 11
  PICKP3[I,0] = 0;PICKP3[I,1] = 0
Next I
Mat Write #21,R[21],0;PICKP2$
Mat Write #21,R[21],22;PICKP2
Goto L_5405
L_5400: Mat Read #21,R[21],34;PICKP3
L_5405: PICKP3[(SYSMONTH - 1),0] = PICKP3[(SYSMONTH - 1),0] + 1
PICKP3[(SYSMONTH - 1),1] = PICKP3[(SYSMONTH - 1),1] + Q1
Mat Write #21,R[21],34;PICKP3;
If DEBUG Print #DBChan;"     update pick count ";K21$;" rec #";R[21]
Return 
L_6000: Rem "======================== read order header, ship to, totals
Mat Read #8,R[8],0;H0
Mat Read #8,R[8],52;H3
Read #8,R[8],56;TOT_SELL
Mat Read #8,R[8],446;P0$
Read #8,R[8],482;H2;
Mat Read #8,R[8],66;V0$
Mat Read #8,R[8],78;H4
Mat Read #8,R[8],84;H0$
Mat Read #8,R[8],104;H5
Mat Read #8,R[8],172;S3
Mat Read #8,R[8],272;H1$
Mat Read #8,R[8],278;SLSM
Mat Read #8,R[8],318;SCOM
Mat Read #8,R[8],348;SMER
Mat Read #8,R[8],378;SCST
Mat Read #8,R[8],408;H6
Mat Read #8,R[8],444;HMAT$
MAT  READ #8,R[8],466;HFAX   ! "CCT111941/task12321
Mat Read #8,R[8],486;OWHT
Mat Read #8,R[8],490;OWHT1
Mat Read #8,R[8],504;PICKBY
mat read #8,R[8],508;OT19Part ! aka pickby[2]
Mat Read #8,R[8],512;OREF
Mat Read #8,R[8],548;CSPLT
!if custom_customer$="HTBERRY" - no longer custom
mat read #8,r[8],568;commsrvchg
!Endif
Read #8,R[8],586;PHUP
Read #8,R[8],598;SplitFlag
mat Read #8,R[8],600;CommBaseRate
mat Read #8,R[8],620;NumberPieces      ! "keep it locked
mat read #8,r[8],624;ohcurrid;
mat read #8,r[8],626;ohcurrfact ! 
R[9] = H0[2];R[10] = H0[3]
Mat Read #9,R[9],0;S1
Mat Read #9,R[9],8;S1$
Mat Read #9,R[9],126;S2$
Mat Read #9,R[9],146;S5
Mat Read #9,R[9],150;S6
Mat Read #9,R[9],154;SRN
if P61$[109,109]="Y"
	mat  read #9,R[9],196;srnmd
endif
Mat Read #10,R[10],0;T1
Mat Read #10,R[10],8;T2
Mat Read #10,R[10],164;JRNL
Mat Read #10,R[10],168;MCODE
Mat Read #10,R[10],208;MCHARGE
Mat Read #10,R[10],328;TOT
Mat Read #10,R[10],358;MCTXBL
Mat Read #10,R[10],378;DCLVL
Mat Read #10,R[10],380;TOT_ORD
Mat Read #10,R[10],398;totalpage   ! "cct192372
Mat Read #10,R[10],412;EMAIL$
If DEBUG
  Print #DBChan;"======================================================="
  Print #DBChan;"read header for ";K8$;" rec #";R[8]
  Print #DBChan;"     ship to rec #";R[9]
  Print #DBChan;"     totals rec #";R[10]
End If 
Return 
L_6300: Rem "======================== read order line record
Mat Read #11,R[11],0;L2
Mat Read #11,R[11],8;L3
Mat Read #11,R[11],16;L4
Mat Read #11,R[11],32;L5
Mat Read #11,R[11],56;L6
Mat Read #11,R[11],80;L6$
Mat Read #11,R[11],140;L1$
Mat Read #11,R[11],160;L9
Mat Read #11,R[11],168;L7
Mat Read #11,R[11],250;UN
Mat Read #11,R[11],256;S2
Mat Read #11,R[11],260;ROLS3
Mat Read #11,R[11],368;MT$
Mat Read #11,R[11],370;S3$
Mat Read #11,R[11],404;OLM
Mat Read #11,R[11],446;EUN
Mat Read #11,R[11],452;UNF
Mat Read #11,R[11],494;LCO \ Mat Read #11,R[11],502;CST
Mat Read #11,R[11],508;LTAX1; \ Mat Read #11,R[11],538;LTAX2;
Mat Read #11,R[11],514;CTWT;
Mat Read #11,R[11],542;QPB;
Mat Read #11,R[11],548;LPRINTED;
Mat Read #11,R[11],550;OWHS;
Mat Read #11,R[11],552;LP_DATE;
Mat Read #11,R[11],556;LP_TIME;
Mat Read #11,R[11],564;ROL0;
Mat Read #11,R[11],616;LP1;
Mat Read #11,R[11],622;CommissionSource;
mat read #11,r[11],624;olcurrid;
mat read #11,r[11],626;olcurrfact; 
If DEBUG Print #DBChan;"  read line ";K11$;" rec #";R[11]
LWHSE = L4[3] \ If LWHSE <= 0 Or LWHSE > 99 Let LWHSE = HWHSE
Return 
L_6400: Rem "======================== read product record
Mat Read #14,R[14],0;PRODA$
Mat Read #14,R[14],156;B
Mat Read #14,R[14],256;A
Mat Read #14,R[14],512;PFU1
Mat Read #14,R[14],596;PRPARC
Mat Read #14,R[14],632;PSN$
Mat Read #14,R[14],652;PSN
Mat Read #14,R[14],664;LBSORD
Mat Read #14,R[14],670;U4
Mat Read #14,R[14],894;PR_C4
Mat Read #14,R[14],938;PF_LOAD2
MAT  READ #14,R[14],990;PLV
MAT  READ #14,R[14],1002;PLC
MAT  READ #14,R[14],1018;pfn
MAT  READ #14,R[14],1056;PRFLG$
If DEBUG Print #DBChan;"    read product rec #";R[14];PRODA$[140,151]
Return 
L_6450: Rem "======================== read product warehouse record
Mat Read #6,R[6],32;W1
Mat Read #6,R[6],38;W2
Mat Read #6,R[6],78;W3
Mat Read #6,R[6],228;W5
Mat Read #6,R[6],428;WH7
Mat Read #6,R[6],444;WH8
Mat Read #6,R[6],696;W7
Mat Read #6,R[6],780;WHLV
MAT  READ #6,R[6],800;whmisc
MAT  READ #6,R[6],992;lrncost
Mat Read #6,R[6],980;WHLBS
Return 
L_6500: Rem "======================== write order header, ship to, totals
let phup=0
H0[2] = -1 * H0[2]
H0[3] = -1 * H0[3]
Mat Write #2,R[2],0;H0
H0[2] = -1 * H0[2]
H0[3] = -1 * H0[3]
Mat Write #2,R[2],52;H3
Write #2,R[2],56;TOT_SELL
Mat Write #2,R[2],446;P0$
Mat Write #2,R[2],66;V0$
Mat Write #2,R[2],78;H4
Mat Write #2,R[2],84;H0$
Mat Write #2,R[2],104;H5
Mat Write #2,R[2],172;S3
Mat Write #2,R[2],272;H1$
Mat Write #2,R[2],278;SLSM
Mat Write #2,R[2],318;SCOM
Mat Write #2,R[2],348;SMER
Mat Write #2,R[2],378;SCST
Mat Write #2,R[2],444;HMAT$
MAT  WRITE #2,R[2],466;HFAX   ! 'CCT111941 task12321
Mat Write #2,R[2],408;H6
Write #2,R[2],482;H2
Mat Write #2,R[2],486;OWHT
Mat Write #2,R[2],490;OWHT1
Mat Write #2,R[2],498;TOTGL
Mat Write #2,R[2],504;PICKBY;
mat write #2,R[2],508;OT19Part;
Mat Write #2,R[2],512;OREF;
Mat Write #2,R[2],548;CSPLT;
!if custom_customer$="HTBERRY" ! no longer custom
MAT Write #2,R[2],568;commsrvchg;
!Endif
write #2,R[2],586;PHUP;
write #2,R[2],598;SplitFlag;
mat write #2,R[2],600;CommBaseRate;
mat write #2,R[2],620;NumberPieces;
if p61$[136,136]="Y"
	if ohcurrid<=0 or ohcurrid>9999
		let ohcurrfact=0 ! invalid currency id
		let ohcurrid=0
	endif
	if ohcurrfact<0 let ohcurrfact=0 ! invalid currency factor
else
	let ohcurrid=0
	let ohcurrfact=0
endif
mat write #2,r[2],624;ohcurrid;
mat write #2,r[2],626;ohcurrfact;
Mat Write #3,R[3],0;S1
Mat Write #3,R[3],8;S1$
Mat Write #3,R[3],126;S2$
Mat Write #3,R[3],146;S5
Mat Write #3,R[3],150;S6
Mat Write #3,R[3],154;SRN;
Write #3,R[3],190;INVNO;
if P61$[109,109]="Y"
	mat write #3,r[3],196;srnmd;
endif
If DEBUG
  Print #DBChan;" write history header for ";K2$;" rec #";R[2]
  Print #DBChan;"               ship to rec #";R[3]
End If 
Return
L_6700: Rem
Mat Write #4,R[4],0;T1
Mat Write #4,R[4],8;T2
Mat Write #4,R[4],164;JRNL
Mat Write #4,R[4],168;MCODE
Mat Write #4,R[4],208;MCHARGE
Mat Write #4,R[4],328;TOT;
Mat Write #4,R[4],358;MCTXBL;
Mat Write #4,R[4],378;DCLVL;
Mat Write #4,R[4],380;TOT_ORD;
Mat Write #4,R[4],398;totalpage;
Mat Write #4,R[4],400;INVNO;
Mat write #4,r[4],412;email$;
If DEBUG Print #DBChan;" write history totals for ";K2$;" rec #";R[4]
Return 
L_6800: Rem "======================== write order line record
Mat Write #5,R[5],0;L2
Mat Write #5,R[5],8;L3
Mat Write #5,R[5],16;L4
Mat Write #5,R[5],32;L5
Mat Write #5,R[5],56;L6
Mat Write #5,R[5],80;L6$
Mat Write #5,R[5],140;L1$
Mat Write #5,R[5],160;L9
Mat Write #5,R[5],168;L7
Mat Write #5,R[5],250;UN
Mat Write #5,R[5],256;S2
Mat Write #5,R[5],260;ROLS3
Mat Write #5,R[5],368;MT$
Mat Write #5,R[5],370;S3$
Mat Write #5,R[5],404;OLM
Mat Write #5,R[5],446;EUN
Mat Write #5,R[5],452;UNF
Mat Write #5,R[5],494;LCO
Mat Write #5,R[5],502;CST;
Mat Write #5,R[5],508;LTAX1; \ Mat Write #5,R[5],538;LTAX2;
Mat Write #5,R[5],514;CTWT;
Write #5,R[5],518;INVNO;
Mat Write #5,R[5],542;QPB;
Mat Write #5,R[5],548;LPRINTED;
Mat Write #5,R[5],550;OWHS;
Mat Write #5,R[5],552;LP_DATE;
Mat Write #5,R[5],556;LP_TIME;
Mat Write #5,R[5],616;LP1;
Write #5,R[5],622;CommissionSource;
if p61$[136,136]="Y"
	if olcurrid<=0 or olcurrid>9999
		let olcurrid=0
		let olcurrfact=0 ! invalid currency id
	endif
	if olcurrfact<0 let olcurrfact=0 ! invalid currency factor
else
	let olcurrid=0
	let olcurrfact=0
endif
mat write #5,r[5],624;olcurrid;
mat write #5,r[5],626;olcurrfact; 
If DEBUG Print #DBChan;"   write history line ";K5$;" rec #";R[5]
Return 
MoveRFPicksToHistory: !
	k_rfpq$ = " ",k_rfpq$
	rfpq_wh = h4[2]
	if l4[3] rfpq_wh = l4[3]
	k_rfpq$[1,2] = rfpq_wh using "##"
	k_rfpq$[3,8] = K11$[1,6]
	k_rfpq$[10,12] = K11$[7,9]
	histSequence = 0
	RFPickLoop: !
		search #ch_rfpq,3,2;k_rfpq$,r_rfpq,e
		if e>2 error 11000
		if E goto ExitRFPickLoop:
		if val(k_rfpq$[1,2]) <> rfpq_wh goto ExitRFPickLoop:
		if k_rfpq$[3,8] <> K11$[1,6] goto ExitRFPickLoop:
		if k_rfpq$[10,12] <> K11$[7,9] goto ExitRFPickLoop:
		! yup - this guy needs to go to history
		gosub ReadRFPickRec:
		gosub WriteRFPickHistoryRec:
		gosub DeleteRFPickRec:
		histSequence = histSequence + 1
	goto RFPickLoop:
	ExitRFPickLoop: !
return
ReadRFPickRec:
	mat read #ch_rfpq,r_rfpq,0;rfpq_wh
	mat read #ch_rfpq,r_rfpq,2;rfpq_order
	mat read #ch_rfpq,r_rfpq,8;rfpq_line
	mat read #ch_rfpq,r_rfpq,10;bin$
	mat read #ch_rfpq,r_rfpq,16;sequence
	mat read #ch_rfpq,r_rfpq,22;varsortkey$
	mat read #ch_rfpq,r_rfpq,62;product$
	mat read #ch_rfpq,r_rfpq,74;vendprod$
	mat read #ch_rfpq,r_rfpq,94;qty2pick
	mat read #ch_rfpq,r_rfpq,100;qtypicked
	mat read #ch_rfpq,r_rfpq,106;pickedby
	mat read #ch_rfpq,r_rfpq,108;gendate
	mat read #ch_rfpq,r_rfpq,112;gentime
	mat read #ch_rfpq,r_rfpq,116;pickdate
	mat read #ch_rfpq,r_rfpq,120;picktime
	mat read #ch_rfpq,r_rfpq,124;pickstat
	mat read #ch_rfpq,r_rfpq,126;invnum
	mat read #ch_rfpq,r_rfpq,132;zone$
	mat read #ch_rfpq,r_rfpq,134;truck
	mat read #ch_rfpq,r_rfpq,138;truckstop
	mat read #ch_rfpq,r_rfpq,142;binsort$
	mat read #ch_rfpq,r_rfpq,152;pallet
Return
WriteRFPickHistoryRec:
	! get new record
	E = 2 \ Search #ch_rfpqh,1,0;k_rfpqh$,r_rfpqh,e \ If E error 11000
	invnum = OREF[1]
	k_rfpqh$ = " ",k_rfpqh$
	k_rfpqh$[1,10] = invnum using "##########"
	k_rfpqh$[11,14] = rfpq_line using "####"
	k_rfpqh$[15,18] = histSequence using "####"
	Search #ch_rfpqh,4,1;k_rfpqh$,r_rfpqh,E \ If E error 11000
	k_rfpqh$ = " ",k_rfpqh$
	k_rfpqh$[1,6] = pickdate using "&&&&&&"
	k_rfpqh$[7,10] = pickedby using "####"
	k_rfpqh$[11,20] = invnum using "##########"
	k_rfpqh$[21,24] = rfpq_line using "####"
	k_rfpqh$[25,28] = histSequence using "####"
	Search #ch_rfpqh,4,2;k_rfpqh$,r_rfpqh,E \ If E error 11000
	k_rfpqh$ = " ",k_rfpqh$
	k_rfpqh$[1,4] = pickedby using "####"
	k_rfpqh$[5,10] = pickdate using "&&&&&&"
	k_rfpqh$[11,20] = invnum using "##########"
	k_rfpqh$[21,24] = rfpq_line using "####"
	k_rfpqh$[25,28] = histSequence using "####"
	Search #ch_rfpqh,4,3;k_rfpqh$,r_rfpqh,E \ If E error 11000
	mat write #ch_rfpqh,r_rfpqh,0;rfpq_wh
	mat write #ch_rfpqh,r_rfpqh,2;rfpq_order
	mat write #ch_rfpqh,r_rfpqh,8;rfpq_line
	mat write #ch_rfpqh,r_rfpqh,10;bin$
	mat write #ch_rfpqh,r_rfpqh,16;histSequence
	mat write #ch_rfpqh,r_rfpqh,22;varsortkey$
	mat write #ch_rfpqh,r_rfpqh,62;product$
	mat write #ch_rfpqh,r_rfpqh,74;vendprod$
	mat write #ch_rfpqh,r_rfpqh,94;qty2pick
	mat write #ch_rfpqh,r_rfpqh,100;qtypicked
	mat write #ch_rfpqh,r_rfpqh,106;pickedby
	mat write #ch_rfpqh,r_rfpqh,108;gendate
	mat write #ch_rfpqh,r_rfpqh,112;gentime
	mat write #ch_rfpqh,r_rfpqh,116;pickdate
	mat write #ch_rfpqh,r_rfpqh,120;picktime
	mat write #ch_rfpqh,r_rfpqh,124;pickstat
	mat write #ch_rfpqh,r_rfpqh,126;invnum
	mat write #ch_rfpqh,r_rfpqh,132;zone$
	mat write #ch_rfpqh,r_rfpqh,134;truck
	mat write #ch_rfpqh,r_rfpqh,138;truckstop
	mat write #ch_rfpqh,r_rfpqh,142;binsort$
	mat write #ch_rfpqh,r_rfpqh,152;pallet
Return
DeleteRFPickRec: !
	k_rfpq2$ = " ",k_rfpq2$
	k_rfpq2$[1,2] = rfpq_wh using "##"
	k_rfpq2$[3,42] = varsortkey$
	k_rfpq2$[43,46] = pickedby using "####"
	k_rfpq2$[47,56] = sequence using "##########"
	Search #ch_rfpq,5,1;k_rfpq2$,r_rfpq,E \ If E error 11000
	k_rfpq2$ = k_rfpq$ ! this is the index we are taversing to move to history
	Search #ch_rfpq,5,2;k_rfpq2$,r_rfpq,E \ If E error 11000
	k_rfpq2$ = " ",k_rfpq2$
	k_rfpq2$[1,2] = rfpq_wh using "##"
	k_rfpq2$[3,6] = pickedby using "####"
	k_rfpq2$[7,16] = sequence using "##########"
	Search #ch_rfpq,5,3;k_rfpq2$,r_rfpq,E \ If E error 11000
	k_rfpq2$ = " ",k_rfpq2$
	k_rfpq2$[1,6] = rfpq_order using "######"
	k_rfpq2$[7,10] = rfpq_line using "####"
	k_rfpq2$[11,14] = pickedby using "####"
	k_rfpq2$[15,24] = sequence using "##########"
	Search #ch_rfpq,5,4;k_rfpq2$,r_rfpq,E \ If E error 11000
	E = 3 \ Search #ch_rfpq,1,0;k_rfpq2$,r_rfpq,E \ If E error 11000
Return

L_6900: Rem "======================== write product whse record
Mat Write #6,R[6],32;W1
Mat Write #6,R[6],38;W2
Mat Write #6,R[6],78;W3
Mat Write #6,R[6],228;W5
Mat Write #6,R[6],444;WH8
Mat Write #6,R[6],696;W7;
Return 

NSTKHist: ! added - read/write Non-Stock History
IF P9$[8,8]<>"Y" Return ! "no invoice history
! uses channels 12 =2128, 31 = desch
k5$=K11$ ! record (L4[0]) could be unreliable - use keys ONLY - only save hist on entered nstks
let k5$[10]="" ! trim last space just in case not there
Search #12,2,1;k5$,r[12],e \ if e>1 error 11000 ! oooooolll
if e return ! not found - cannot xfer
mat read #12, r[12],   0;nsl7
mat read #12, r[12],  12;nsl$
mat read #12, r[12],  42;nsl1$
mat read #12, r[12],  72;nsl8
mat read #12, r[12], 102;nsl2$
mat read #12, r[12], 120;ha3
mat read #12, r[12], 132;ha1$
mat read #12, r[12], 182;NSinvno
mat read #12, r[12], 190;nsfrt1
mat read #12, r[12], 208;NSUDA$;
! now 4/sprddesch - history for nonstock sproddesc
k31$=" ",k31$
k31$[1,10]=Oref[1] using "##########"
k31$[11,13]=k5$[7,9]
search #31,2,1;k31$,R[31],E \ if e>1 error 11000 ! iiiiiiiiiilll
if not(e) return ! already there - bypass (restart?)
let e=2;r=0
search #31,1,0;k31$,r,E \ if e error 11000
let r[31]=r[0]
search #31,4,1;k31$,R[31],e \ if e error 11000
NSB4k$="  " ! must have spaces for auto keygen
NSInvno=Oref[1] ! curr inv - SB only change for history?
mat Write #31, R[31],   0;nsl7
mat Write #31, R[31],  12;nsl$
mat Write #31, R[31],  42;nsl1$
mat Write #31, R[31],  72;nsl8
mat Write #31, R[31], 102;nsl2$
mat Write #31, R[31], 120;ha3
mat Write #31, R[31], 132;ha1$
mat Write #31, R[31], 182;NSinvno
mat Write #31, R[31], 188;NSB4k$
mat Write #31, R[31], 190;nsfrt1
mat write #31, R[31], 208;NSUDA$;
Return

L_7600: Rem CONVERT H0[8] TO JULIAN JIDATE
X2 = H0[8] \ Gosub L_7820 \ X2 = 0
If X2 = 0 ! "BAD DATE?
  X2 = ARDATE \ Gosub L_7820 \ X2 = 0
  If X2 = 0 ! "ARDATE BAD?
    U5$ = "" \ Call Time(U5$)
    Call VerifyDate(U5$,X$,E) \ If E  error 11000
    Gosub L_7820 \ let x2=tim(6) !!\ error 11000
  End If 
End If 
JIDATE = X2
Return 
X$ = " ",X$ \ X$[10] = ""
X$[1,3] = Int(X2 / 10 ^ 2 - Int(X2 / 10 ^ 4) * 10 ^ 2) + 10 ^ 2 Using "###"
X$[4,6] = Fra(X2 / 10 ^ 2) * 10 ^ 2 + 10 ^ 2 Using "###"
X$[7,9] = Int(X2 / 10 ^ 4) + 10 ^ 2 Using "###"
X$[4,4] = "/" \ X$[7,7] = "/" \ X$ = X$[2]
Return 
!DT3[0] = X2;FLAG = 1;X$ = " "
!Call "JULIANUTIL",DT3[],X$,FLAG
Return 
L_7800: Rem DATE X$ TO X2
Call VerifyDate(X$,X$,E) \ If E Let X$ = "    "
X2 = X$[1,6] \ Return 
L_7820: Rem  CONVERT YYMMDD TO JULIAN (RETURN=NOGOOD, +1=OKAY)
if x2<=0 return ! no good
X$ = X2 Using "&&&&&&"
Call DateToJulian(1,X$,X$,E) \ If E Return 
X2 = X$[1,5] \ Return 1
!DT3[0] = X2;DT3[1] = X2;FLAG = 0
!Call "JULIANUTIL",DT3[],X$,FLAG
Return 
L_7860: Rem CONVERT YYMM TO YYYYMM
X$ = X2 Using "&&&&"
DT3[0] = X$[1,2];DT3[1] = X$[3,4]
If DT3[0] > 67 Let DT3[0] = 1900 + DT3[0]
If DT3[0] < 68 Let DT3[0] = 2000 + DT3[0]
X$[1,4] = DT3[0] Using "&&&&";X$[5,6] = DT3[1] Using "&&"
X2 = X$[1,6] \ Return 
L_7900: Rem GET CURRENT DATE
U5$ = ""
J4$ = "JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC"
Call Time(U5$)
For K1 = 1 To 12
  If U5$[1,3] = J4$[K1 * 3 - 2,K1 * 3] Goto L_7940
Next K1
END ! Print "\15\DATE ERROR - STOP AT 7935" \ Stop 
L_7940: X$ = "/",X$
X$[1,2] = K1 Using "##"
X$[4,5] = U5$[5,6]
X$[7,8] = U5$[11,12]
For K1 = 1 To 8
  If X$[K1,K1] = " " Let X$[K1,K1] = "0"
Next K1
Return 
L_8000: Rem "============ check for register/accept/eom/eoy in process
R[99]=getuidrec(e$,IntCo,Userid$) ! Call "getuidrec",R[99]
Mat Read #1,120,0;P0
Rem new now check program #
if p0[227] <> 0
	E=3  ! CHECK with time check
	scratch$=" "
	call "proglock.dl4","227",e,scratch$  
	if not(e)  !! no proglock entry
		unlock #1
		call "flagreset","227.DL4",e
		if e
			Mat Read #1,120,0;P0 ! reset done, relock record
		endif
	endif
endif
If P0[226] <> 0 Or P0[227] <> 0 Goto L_8033
If PCDATE = 888888 Or PCDATE = 999999 Let X1 = 0;P0[X1] = 13 \ Goto L_8033
P0[227] = R[99]
Mat Write #1,120,0;P0;
ABORT = ABORT + 1
Goto L_8050
L_8033: E$="" ! Print @0,20;'CE RB';
R = P0[226]
If R let Z1$=GetUIDInfo$(e$,IntCo,R)
USR$ = Trim$(Z1$[21])
!Call "trim",USR$
If P0[226] <> 0 E$="INVOICE REGISTER BEING PRINTED BY USER "+USR$
R = P0[227]
If R let Z1$=GetUIDInfo$(e$,IntCo,R) ! Call "getuidinfo",R,Z1$
USR$ = Trim$(Z1$[21])
! Call "trim",USR$
If P0[227] <> 0 E$=E$+"INVOICE ACCEPT BEING RUN BY USER "+USR$
If P0[0] = 13 E$=E$+"END-OF-PERIOD BEING RUN SOMEWHERE "
E$=E$+"RUN ACCEPT WHEN DONE."
Unlock #1
Goto L_8425
L_8050: Rem "=============================== check to see if accept can be run
!Print @0,22;'CE';"Checking flags...";
E = 0 \ Call FindF(IAIP$,E) \ If Not(E) Goto L_8068
E$="INVOICE ACCEPT BOMB DETECTED! CANNOT RE-START."
SCRATCH$ = IAIP$
!System "cat " + IAIP$
USERPORTINFO[1] = 227
Gosub MESSAGE
TRACKFILE$ = "files/1/227track"+Str$(COID)
!If COID > 9 Let TRACKFILE$ = COID Using "1/227track##"
TRChan=80 ! Findchannel() ! ALL OTHER PROGRAMS USE HERE
Open #TRChan,TRACKFILE$
Read #TRChan,0,0;TRACK[0],TRACK[1],ORDNUM,LINENUM,PORTNUM,PART,TYPE,TRACKDATE$,PASSR[1],PASSR[2],PASSR[3];
TERMFLAG = TYPE
Goto L_8425 ! press return?
L_8068: E = 0 \ Call FindF(CAIP$,E) \ If Not(E) Goto L_8070
E$="CREDIT ACCEPT BOMB DETECTED! CANNOT RE-START."
SCRATCH$ = CAIP$
!System "cat " + CAIP$
USERPORTINFO[1] = 247
Gosub MESSAGE
Goto L_8425
L_8070: E = 0 \ Call FindF(IRIP$,E) \ If Not(E) Goto L_8080
E$="INVOICE JOURNAL BOMB DETECTED! CANNOT RE-START."
SCRATCH$ = IRIP$
!System "cat " + IRIP$
USERPORTINFO[1] = 226
Gosub MESSAGE
Goto L_8425
L_8080: ! System "cp /dev/null " + IAIP$
R = R[99]
Chan=Findchannel()
tmp$=IAip$+"!"
  ! tmp$=IAip$+"!"
Build #CHan,+tmp$
! Open #Chan,IAIP$
Print #Chan;"invoice accept started ";Msc$(3)
Print #Chan;"user ";R;" SPC 5= ";Spc(5)
Close #Chan
tmp$="chmod go+rw files/"+IAIP$
System tmp$
TRACKFILE$ = "files/1/227track"+Str$(COID)
!If COID > 9 Let TRACKFILE$ = COID Using "1/227track##"
SCRATCH$ = " ",SCRATCH$
SCRATCH$ = "[1:42] ",TRACKFILE$,"!"
TRChan=80 ! Findchannel() ! ALL OTHER PROGRAMS USE THIS CHANNEL!
Build #TRChan,SCRATCH$ \ Close #TRChan
tmp$="chmod go+rw "+Trackfile$
System tmp$
Open #TRChan,TRACKFILE$
TRACKDATE$ = " ",TRACKDATE$;TRACKDATE$ = Msc$(3)
PORTNUM = Spc(6);PART = 1;TYPE = TERMFLAG
Write #TRChan,0,0;TRACK[0],TRACK[1],ORDNUM,LINENUM,PORTNUM,PART,TYPE,TRACKDATE$,PASSR[1],PASSR[2],PASSR[3];
ABORT = ABORT + 1
If P9$[17,17] <> "Y" Goto L_8150
K22$ = " ",K22$;K22$[1,6] = "DFAULT"
Search #22,2,1;K22$,R[22],E \ If E > 1 error 11000
If Not(E) Goto L_8121
E$="G/L - A/R INTERFACE CONTROL NOT SETUP PROPERLY"
Goto L_8425
L_8121: K18$ = " ",K18$
Search #18,2,1;K18$,R[18],E \ If E > 1 error 11000
If Not(E)
  E$="INVOICE REGISTER/ACCEPT IN PROCESS. (G/L) TRY AGAIN LATER"
  Goto L_8425
End If 
ABORT = ABORT + 1
L_8150: Rem "============ check for cash receipts in process
if passr[1]=757
	let p9$[48,48]="N" ! turn off auto post cash
	let p61$[94,94]="N" ! turn off deposits
	goto L_8400
endif
If P9$[48,48] <> "Y" and p61$[94,94]<>"Y" Goto L_8400 ! no auto post cash, no sales order deposits
if p9$[48,48]="Y"
	If TERMFLAG = 2 Goto L_8400
	if passr[1]=757 GOTO L_8400
endif
Read #1,20,8;S0
If S0
  If S0 = 4
    E$="CASH RECEIPTS JOURNAL(304) RUN BUT NOT ACCEPTED(305)"
    E$=E$+"YOU NEED TO ACCEPT CASH RECEIPTS(305) BEFORE RUNNING THE 227 ACCEPT"
    Goto L_8425
  End If 
  If S0 = 3
    E$="CASH RECEIPTS JOURNAL(304) "
    If P60$[6,6] = "Y" E$=E$+"OR MONTHLY JOURNAL(306)"
    E$=E$+"IN PROGRESS. TRY AGAIN LATER"
    Goto L_8425
  End If 
  If S0 = 5
    E$="ACCEPT(305, 311, 227, 320, etc) IN PROGRESS. TRY AGAIN LATER "
    Goto L_8425
  End If 
  E$="CASH RECEIPTS ENTRY/VERIFICATION IN PROCESS. TRY AGAIN LATER"
  Goto L_8425
End If 
If P60$[6,6] = "Y" ! "cash receipts separated by bank #
  For R[27] = 1 To Chf(27) - 1
    Mat Read #27,R[27],0;A$;
    If A$[1,3] = "   " Or Len(A$) = 0 Goto L_8225
    Mat Read #27,R[27],36;CASHP0;
    If CASHP0[0]
      If CASHP0[0] = 4
        E$="FOR BANK"+Str$(R[27])+", CASH RECEIPTS JOURNAL(304) RUN BUT NOT ACCEPTED(305)"
        E$=E$+"YOU NEED TO ACCEPT CASH RECEIPTS(305) BEFORE RUNNING THE 227 ACCEPT"
        Goto L_8425
      End If 
      If CASHP0[0] = 3
        E$="FOR BANK"+Str$(R[27])+", CASH RECEIPTS JOURNAL(304) OR MONTHLY JOURNAL(306)"
        E$=E$+"IN PROGRESS. TRY AGAIN LATER"
        Goto L_8425
      End If 
      If CASHP0[0] = 5
        E$="FOR BANK"+Str$(R[27])+", ACCEPT(305, 311, 227, 320, etc) "
        E$=E$+"IN PROGRESS. TRY AGAIN LATER"
        Goto L_8425
      End If 
      E$="CASH RECEIPTS ENTRY/VERIF -IN PROCESS BANK"+Str$(R[27])+". TRY AGAIN LATER"
      Goto L_8425
    End If 
L_8225: Next R[27]
End If 
S0 = 5 \ Write #1,20,8;S0;
ABORT = ABORT + 1
L_8400: Rem "============ see if any invoices to accept
K8$ = " ",K8$;K8$[1,2] = " 7"
Search #8,3,1;K8$,R[8],E \ If E > 2  error 11000
If Not(E) And K8$[1,2] = " 7" Goto L_8450
E$="NO INVOICES TO ACCEPT."
L_8425: ! Input "HIT <CR> TO CONTINUE:"Z1$ \ If Z1$ <> "" Goto L_8425
! call programdump("/tmp/ialog4!","")
Return 
L_8450: Rem
! call programdump("/tmp/ialog5!","")
Return 1
MESSAGE: Rem ADD INFO ON ACCEPT BOMB IF IT COULD BE IN PROGRESS
Chan=Findchannel()
Open #Chan,SCRATCH$
MESS1: Read #Chan;MESS$;
If MESS$ = "" Close #Chan \ Return 
If MESS$[1,4] <> "user" Goto MESS1
Close #Chan
For K1 = 6 To 22
  If MESS$[K1,K1 + 2] = "SPC" Goto MESS2
Next K1
Return 
MESS2: R = MESS$[6,K1 - 1]
USR$ = " ",USR$
Chan=FindChannel()
Ropen #Chan,"cntrl/USERCNTRL"
If R > 0 If R < Chf(Chan) Mat Read #Chan,R[0],280;USR$;
If R = -1 Let USR$ = "SYSTEM ADMINSTRATOR"
Close #Chan
!Print "*******************************************"
E$=E$+"NOTE: SOMEONE MAY CURRENTLY BE RUNNING THE "
If USERPORTINFO[1] = 226 E$=E$+"INVOICE JOURNAL. "
If USERPORTINFO[1] = 227 E$=E$+"INVOICE ACCEPT. "
If USERPORTINFO[1] = 247 E$=E$+"CREDIT MEMO ACCEPT. "
K1 = 20 \ If USR$[16,20] = "     " Let K1 = 15 \ If USR$[11,15] = "     " Let K1 = 10
E$=E$+"PLEASE CHECK " \ If USR$[1,5] <> "     " E$=E$+"WITH "+USR$[1,K1]
E$=E$+" TO SEE IF THIS IS TRUE."
!Print "IF THIS IS THE CASE, AND THERE HAVE BEEN NO ERRORS ON THE OTHER PORT,"
!Print "PLEASE WAIT UNTIL THEY ARE FINISHED. THEN YOU CAN RUN THIS ACCEPT AGAIN."
E$=E$+"OTHERWISE, IF THERE IS A PROBLEM, PLEASE CONTACT UNIVERSAL."
Return 
L_8600: Rem "================================= clear "glartemp"
K18$ = " ",K18$
Search #18,2,1;K18$,R[18],E \ If E > 1 error 11000
If E Goto L_8630
Search #18,5,1;K18$,R[18],E \ If E error 11000
E = 3 \ Search #18,1,0;K18$,R[18],E \ If E error 11000
L_8630: Return 

L_10000: Rem UPDATE INVENTORY (except kit components)
If TRACK[1] > 0 Goto L_10100
T3 = L7[4];LBSHIP = (ROLS3[4] * Sgn(L7[4]))
If H5[7]=19 And Not(Ot19Part) Let T3=0;LBShip=0 ! "no ship - just recap of partials
If H5[7] = 15
  T3 = L7[2]
  If H0[5] <> 0 Let T3 = 0;LBSHIP = 0
End If 
If L3[1] And Not(L3[0]) ! "update stock
  R[14] = L4[0] \ Gosub L_6400
  If PRODA$[127,127] <> "Y" Let LBSHIP = 0
  If H5[7] <> 8 And H5[7] <> 16 ! "consign/xfer don't do
    If L1$[14,16] = "KIT" Let A[0] = A[0] + T3
    A[0] = A[0] - T3
    PRPARC[3] = PRPARC[3] - LBSHIP
  End If 
  If T3 > 0 And H5[7] <> 24 ! "not a credit or standing order
    A[3] = A[3] - T3
    If A[3] < 0 Let A[3] = 0
    LBSORD = LBSORD - LBSHIP \ If LBSORD < 0 Let LBSORD = 0
    If JSDATE >= JWDATE ! "do levels (gg stuff)
      PLV[0] = PLV[0] - T3 \ If PLV[0] < 0 Let PLV[0] = 0
    Else 
      PLV[1] = PLV[1] - T3 \ If PLV[1] < 0 Let PLV[1] = 0
    End If 
  End If 
  Mat Write #14,R[14],256;A
  Mat Write #14,R[14],596;PRPARC
  Mat Write #14,R[14],664;LBSORD
  Mat Write #14,R[14],990;PLV
  TRACK[1] = TRACK[1] + 1 \ Write #TRChan,0,2;TRACK[1];
	if sqlChan >= 0 ! MySQL enabled and channel opened
		e = prod_UpdateSQLFromDL4(e$, intCo, PRODA$[140,151], sqlChan, 14)
		if e <> 1 ! returns the number of records add/updated/deleted
			error 11000
		end if
	end if

  Gosub L_10100
  Unlock #14
End If 
Return 
L_10100: Rem NOW DO WAREHOUSE
If TRACK[1] > 1 Return 
K6$ = " ",K6$;K6$[1,12] = PRODA$[140,151];K6$[13,14] = LWHSE Using "##"
Search #6,2,1;K6$,R[6],E \ If E > 1 error 11000
If E
  WHPROD$[1,12] = K6$[1,12];WHBLD[0] = 6;WHBLD[1] = LWHSE;WHBLD[2] = B[24]
  !Call "MXWHCREATE",WHPROD$,WHBLD[]
  call mxwhcreate(e$,IntCo,WHPROD$,WHBLD[])
  R[6] = WHBLD[2];E = 0;WHBLD[2] = 0
  If DEBUG Print #DBChan;"   warehouse record created ";K6$;" rec";R[6]
End If 
Gosub L_6450
INVBAL[0] = W3[0]
If H5[7] <> 7 ! "don't update/billing control
  If L1$[14,16] = "KIT" Let W3[0] = W3[0] + T3;WHLBS[0] = WHLBS[0] + LBSHIP
  W3[0] = W3[0] - T3
  WHLBS[0] = WHLBS[0] - LBSHIP
  If T3 > 0 And H5[7] <> 24 ! "not a credit or standing order
    W3[2] = W3[2] - T3
    If W3[2] < 0 Let W3[2] = 0
    WHLBS[1] = WHLBS[1] - LBSHIP
    If WHLBS[1] < 0 Let WHLBS[1] = 0
    If JSDATE >= JWDATE ! "do levels (gg stuff)
      WHLV[0] = WHLV[0] - T3 \ If WHLV[0] < 0 Let WHLV[0] = 0
    Else 
      WHLV[1] = WHLV[1] - T3 \ If WHLV[1] < 0 Let WHLV[1] = 0
    End If 
  End If 
End If 
Mat Write #6,R[6],78;W3
Mat Write #6,R[6],780;WHLV
Mat Write #6,R[6],980;WHLBS;
If H5[7] = 7 Or H5[7] = 8 Or H5[7] = 16 ! "handle consigns, etc.
  AVGCOST = W3[15]
  K6$ = " ",K6$;K6$[1,12] = PRODA$[140,151];K6$[13,14] = H5[11] Using "##"
  Search #6,2,1;K6$,R[6],E \ If E > 1 error 11000
  If E
    DEFWHNUM = LWHSE / 100
    WHPROD$[1,12] = K6$[1,12];WHBLD[0] = 6;WHBLD[1] = H5[11] + DEFWHNUM
    WHBLD[2] = B[24]
    ! Call "MXWHCREATE",WHPROD$,WHBLD[]
	call mxwhcreate(e$,IntCo,WHPROD$,WHBLD[])
    R[6] = WHBLD[2];E = 0;WHBLD[2] = 0
	If DEBUG Print #DBChan;"   warehouse record created ";K6$;" rec";R[6]
  End If 
  Gosub L_6450  !! read prodwhse record
  If H5[7] = 7 Let INVBAL[0] = W3[0] Else Let INVBAL[1] = W3[0]
  If H5[7] = 8 Or H5[7] = 16 ! "consign/xfer
    CURVAL = W3[0] * W3[15]
    W3[0] = W3[0] + T3;WHLBS[0] = WHLBS[0] + LBSHIP
    If P9$[32,32] = "Y"
      If W3[0] > 0 And CURVAL > 0 Let W3[15] = ((CURVAL + (T3 * AVGCOST)) / W3[0]) Else Let W3[15] = AVGCOST
    Else 
      W3[15] = B[21]
    End If 
  Else 
    W3[0] = W3[0] - T3
    W3[2] = W3[2] - T3 \ If W3[2] < 0 Let W3[2] = 0
    WHLBS[0] = WHLBS[0] - LBSHIP
    WHLBS[1] = WHLBS[1] - LBSHIP
    If WHLBS[1] < 0 Let WHLBS[1] = 0
    If JSDATE >= JWDATE ! "do levels (gg stuff)
      WHLV[0] = WHLV[0] - T3 \ If WHLV[0] < 0 Let WHLV[0] = 0
    Else 
      WHLV[1] = WHLV[1] - T3 \ If WHLV[1] < 0 Let WHLV[1] = 0
    End If 
  End If 
  IF H5[7]=16 
	W7[10]=WH7[0];WH7[0]=FRA(TIM(4)/100)*1000000+(INT(TIM(4)/100))
  endif
  Mat Write #6,R[6],78;W3
  Mat Write #6,R[6],428;WH7
  Mat Write #6,R[6],696;W7
  Mat Write #6,R[6],780;WHLV
  Mat Write #6,R[6],980;WHLBS;
End If 
TRACK[1] = TRACK[1] + 1 \ Write #TRChan,0,2;TRACK[1];
Return 
CTNWGT: Rem "Delete/Xfer Carton Weight Tally
If Not(CH_WT) Return 
KCWT$ = " ",KCWT$;KCWT$[1,6] = H0[7] Using "######"
KCWT$[7,9] = L3[2] Using "###"
CNW_LOOP: Rem "
Search #CH_WT,3,1;KCWT$,R[36],E \ If E = 2 Return 
If E error 11000
X2[1] = KCWT$[1,6] \ If X2[1] <> H0[7] Return 
X2[2] = KCWT$[7,9] \ If X2[2] <> L3[2] Return 
If CH_WTH ! "history file Xfer
  KCWTH$ = KCWT$;KCWTH$[1,10] = OREF[1] Using "##########"
  KCWTH$[11] = KCWT$[7]
  E = 2;R[37] = 0
  Search #CH_WTH,1,0;KCWTH$,R[37],E \ If E error 11000
  Search #CH_WTH,4,1;KCWTH$,R[37],E \ If E error 11000
  Mat Read #CH_WT,R[36],0;CTNWT;
  Mat Read #CH_WT,R[36],8;CTNWGT;
  Mat Write #CH_WTH,R[37],0;CTNWT;
  Mat Write #CH_WTH,R[37],8;CTNWGT;
  Write #CH_WTH,R[37],14;INVNO;
End If 
Search #CH_WT,5,1;KCWT$,R[36],E \ If E error 11000
E = 3
Search #CH_WT,1,0;KCWT$,R[36],E \ If E error 11000
Goto CNW_LOOP
GET_SHIPLIST: !  READ SHIPLIST FILE FOR EDI TRANS END USER NUMBER -cct151323
LET K38$=" ",K38$
IF SRN[2]=0 LET SRN[2]=H0[4]
LET K38$[1,13]=SRN[2]+(SRN[1]/10^6) USING "######.######"
LET K38$[14]=""
SEARCH #38,2,1;K38$,R38,E
IF NOT(E)
	MAT  READ #38,R38,0;SLA1$;
	MAT  READ #38,R38,150;SLR$
	MAT  READ #38,R38,184;SL2
	MAT  READ #38,R38,204;SLSI$
	MAT  READ #38,R38,324;SLUD
	MAT  READ #38,R38,330;SLUD$; ! UNLOCK IT
ELSE 
	LET SLUD$=" ",SLUD$
ENDIF 
LET EDIENDUSER=SLUD$[1,20]
RETURN 
UPDATE_INVCOST: ! write out invcost file
if invcostflag=0 return ! no file - no update!
LET R[14]=L4[0] \ GOSUB L_6400: \ UNLOCK #14 ! RE-read product
FOR IC = 0 TO 13
	INVCST[IC]=0
NEXT IC
INVCST$=" ",INVCST$
INVCST$[1,12]=L1$[1,12]
IF P9$[32,32]="Y" ! WHSE PRICING IS ON
	LET pwK6$=" ",pwK6$;pwK6$[1,12]=PRODA$[140,151];pwK6$[13,14]=LWhse USING "##"
	SEARCH #6,2,1;pwK6$,Rec_pw,E \ IF E>1 error 11000   
	if e
		! no product warehouse - build it.
		WHPROD$[1,12] = pwK6$[1,12];WHBLD[0] = 6;WHBLD[1] = LWhse
		WHBLD[2] = B[24]
		call mxwhcreate(e$,IntCo,WHPROD$,WHBLD[])
		rec_pw = WHBLD[2]
	end if
	rem get currret prodwhse costs read new vars dont use ones from inv update
	MAT  READ #6,rec_pw,78;pW3       
	MAT  READ #6,rec_pw,800;pwhmisc  
	MAT  READ #6,rec_pw,992;plrncost 
	IF pW3[17] LET INVCST[0]=pW3[17] ELSE INVCST[0]=B[8] ! LOADED COST
	IF pW3[14] LET INVCST[1]=pW3[14] ELSE INVCST[1]=PF_LOAD2 ! LOAD 2
	IF pW3[15] LET INVCST[2]=pW3[15] ELSE INVCST[2]=B[21] ! AVG COST
	IF pW3[16] LET INVCST[3]=pW3[16] ELSE INVCST[3]=B[10] ! PO COST
	IF pW3[18] LET INVCST[5]=pW3[18] ELSE INVCST[5]=PR_C4[4] ! BASE COST
	IF pWHMISC[2] LET INVCST[4]=pWHMISC[2] ELSE INVCST[4]=PRPARC[2] ! NET PO COST
ENDIF
IF P9$[32,32]="N" ! WHSE PROCING IS OFF
	INVCST[0]=B[8] ! LOADED COST  
	INVCST[1]=PF_LOAD2 ! LOAD 2   
	INVCST[2]=B[21] ! AVG COST    
	INVCST[3]=B[10] ! PO COST     
	INVCST[5]=PR_C4[4] ! BASE COST
	INVCST[4]=PRPARC[2] ! NET PO COST 
endif
invcst[8]=Oref[1] !  " h0[6]
INVCST[9]=L3[2]
invcst[11]=h0[4]
invcst[12]=r[5]
ch_REBATEDTL=46 ! 40
Clear REBATE_ARGS[]
LET REBATE_ARGS[1,0]=14
LET REBATE_ARGS[2,0]=6
LET REBATE_ARGS[3,0]=33
LET REBATE_ARGS[4,0]=45 ! 39
LET REBATE_ARGS[5,0]=46 ! 40
LET REBATE_ARGS[1,1]=r[14]
LET REBATE_ARGS[2,1]=R[6]
IF L4[3] LET REBATE_ARGS[1,2]=L4[3] ELSE LET REBATE_ARGS[1,2]=H4[2]
LET REBATE_ARGS[2,2]=H0[4]
LET REBATE_ARGS[3,2]=0
LET REBATE_ARGS[4,2]=H0[8]
LET REBATE_ARGS[5,2]=H6[0]
!CALL "rebates",REBATE_ARGS[],prodA$[140,151],STATUS
call rebates(e$,Rebate_args[],ProdA$[140,151],Status,0,"") ! new external sub
IF NOT(STATUS) !"indicates call was successful in finding rebate
	LET invcst[6]=REBATE_ARGS[1,3]
	LET REC_REBATEDTL=REBATE_ARGS[5,1]
	MAT  READ #CH_REBATEDTL,REC_REBATEDTL,12;RB1
	invcst[13]=rb1[0] 
ENDIF
! next line REM. build it after we check to see if key already/restart.
!let e=2\SEARCH #ch_invcost,1,0;K_inv_cost$,rec_invcost,E \ IF E error 11000 
k_inv_cost$=" ",k_inv_cost$
k_inv_cost$[1,10]=INVCST[8] USING "##########"
K_INV_COST$[11,13]=INVCST[9] USING "###"
K_INV_COST$[14,15]=ARYEAR USING "&#"
K_INV_COST$[16,17]=ARMONTH USING "&#"
SEARCH #CH_INVCOST,2,1;K_INV_COST$,REC_INVCOST,E  ! already there?
if not(e) and not(restart)   ! found it
   error 11000 ! key in there but not restart
endif
! now, if we didn't find it, build it.
if e
   let e=2 \ SEARCH #ch_invcost,1,0;K_inv_cost$,rec_invcost,E ! new rec#
   if e error 11000                               ! if can't build it.
   SEARCH #CH_INVCOST,4,1;K_INV_COST$,REC_INVCOST,E     ! insert key d1
   IF E error 11000
endif
invcst[10]=k_inv_cost$[14,17]
mat write #ch_invcost,rec_invcost,0;invcst$
mat write #ch_invcost,rec_invcost,22;invcst;
k_inv_cost$=" ",k_inv_cost$                     
K_INV_COST$[1,12]=INVCST$[1,12]
K_INV_COST$[13,14]=ARYEAR USING "&#"      
K_INV_COST$[15,16]=ARMONTH USING "&#"     
k_inv_cost$[17,26]=INVCST[8] USING "##########"  
K_INV_COST$[27,29]=INVCST[9] USING "###"       
SEARCH #CH_INVCOST,2,2;K_INV_COST$,REC_INVCOST,E 
if NOT(e) and not(restart) error 11000 ! already in there, why?
if e>1 error 11000
If E 
 SEARCH #CH_INVCOST,4,2;K_INV_COST$,REC_INVCOST,E
Endif
IF E error 11000     
	k_inv_cost$=" ",k_inv_cost$                           
	K_INV_COST$[1,6]=INVCST[11] using "######"
	K_INV_COST$[7,8] =ARYEAR USING "&#"                  
	K_INV_COST$[9,10]=ARMONTH USING "&#"                 
	k_inv_cost$[11,20]=INVCST[8] USING "##########"       
	K_INV_COST$[21,23]=INVCST[9] USING "###" 
	SEARCH #CH_INVCOST,2,3;K_INV_COST$,REC_INVCOST,E 
	if not(e) and not(restart) error 11000
	If E>1 error 11000
	If E
	 SEARCH #CH_INVCOST,4,3;K_INV_COST$,REC_INVCOST,E        
	Endif
	IF E error 11000
return

L_9100: Rem "================================ abort accept.
If ABORT ! "non-fatal abort (able to re-start w/o ubs assistance)
  Mat Read #1,120,0;P0
  X1 = 227;P0[X1] = 0
  Mat Write #1,120,0;P0;
  ABORT = ABORT - 1
End If 
If ABORT Kill IAIP$ \ Kill TRACKFILE$ \ ABORT = ABORT - 1
If ABORT If P9$[17,17] = "Y" Gosub L_8600 \ ABORT = ABORT - 1
If ABORT <>0
	If P9$[48,48] = "Y"
		Let S0 = 0 \ Write #1,20,8;S0; \ ABORT = ABORT - 1
	ELSE
		IF P61$[94,94]="Y"
			Let S0 = 0 \ Write #1,20,8;S0; \ ABORT = ABORT - 1 
		endif
	endif
endif
If DEBUG Print #DBChan;"accept aborted at ";Msc$(3)
L_9200: !Close
Goto Err_Msg: ! send 'em a message!
! call programdump("/tmp/ialog7!","")
!Chain "MX000"
End ! Stop 
OUTEND: Rem "================================ done, onto next part
!Print @0,22;'CE RB RB';"PART 1 COMPLETE..."; \ Signal 3,10
! If Err 0 Rem
If DEBUG 
	Print #DBChan;ACC_CTR;"invoices processed"
	Try Close #DBChan  Else Rem
Endif 
if statchan print #statchan;"Part 1 complete ";Str$(acc_ctr);" invoices processed"
For I = 2 To 90 ! only to 90 - 91+ used in dxblock!
	If I<>Statchan Try Close #I  Else Rem
Next I
if sqlChan<>-1 try close #sqlChan else rem
if p61$[135,135] = "Y" ! RF Picking
	try close #ch_rfpq else rem
	try close #ch_rfpqh else rem
end if
chain "227A.DL4"

ERR_MSG: ! send message                        
ReturnStatus = 1 ! 0 ! no good (ONLY DISPLAYS IF =1 ??)    
Message$ = e$                                              
If Statchan                                                
 Print #Statchan;Message$                                
 Print #Statchan;"Accept has ended with an error"        
Else ! not open yet - send to user                        
 Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)  
 Call AddToStr(e$,rstr$,WebStr$)                          
 Call SetOutPut(e$,rstr$)                                
EndIf                                                                                  
End ! Stop
!
Rem {begin rtn.error.s}
Else
!
include "src/callmainerrnet.inc"
end try
End ! the whole program
