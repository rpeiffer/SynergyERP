! libfilesordlotz.lib
! MODIFIED FOR PRODUCTION WORK ORDERS AS WELL AS ORDER NUMBER
! supporting library of file maintenance routines for browser
!
! loadsave -w -n 100,10 -o prog/dxport/libfilesordlotz.lib src/libfilesordlotz.src
!
! 1.0 generated by dfcreatestruct on 08/19/11 new
!
include "src/copyright.inc"
!
! file maintenance sub routines for sordlot File
!
!  function  filegetsordlotz
!  function  fileupdatesordlotz
!  function  filedroplistsordlotz
!
Declare external function dfaudit !libgeneral.lib
Declare Intrinsic Sub Env,GetGlobals
Declare Intrinsic Function crc32,callstat$,trim$,findchannel
External Lib "dfgeneral.lib"
Declare External Function dfDTConvert$
External Lib "ubsfunc.dl4"
Declare External Function Openfile
!
include "src/inc/filesordlotz.inc"
!
! ----------------------------------------
external function filegetsordlotz(e$,chan,mode$,keyno,keyval$,sordlot. as sordlot,...)
!
! get a sordlot record
!
! pass e$ to return error msg if any
! pass chan channel # of file
! pass mode$ =,>,>=,<,<=,next,prev
! pass keyno for key number to search on
! pass keyval$ populated with key to search for
! pass structure to return record in
! optionals
!     pass lockflag<>0 to lock record
!     pass timeout period
!     pass CrcValue for crc value to be calculated and returned
!
! returns record # and record structure if found
! returns a negative number on an error, e$=routine error, -123=record locked
!
Try
!
  Try Enter lockflag,... Else Let lockflag = 0
  Try Enter timeout,... else let timeout = 100000
  Try Enter CrcValue else let CrcValue=-1
  !
  dim hold$[80],tmp$[80],errmsg$[200],3%
  !
  if mode$="=" or mode$=">=" or mode$="<=" let mode=2
  if mode$=">" or lcase$(mode$)="next" let mode=3
  if mode$="<" or lcase$(mode$)="prev" let mode=6
  !
  hold$ = keyval$
  search #chan,mode,keyno;keyval$,r1,e2
  if mode$="="
   if rtrim$(keyval$) <> rtrim$(hold$) let e2=1
  endif
  if e2 if mode=2 if mode$<>"="
    if mode$=">=" let mode=3 else let mode=6
    search #chan,mode,keyno;keyval$,r1,e2
  end if
  if e2 = 0
    if lockflag=0 read record #chan,r1,0,timeout;sordlot.; else read record #chan,r1,0,timeout;sordlot.
    CrcValue=crc32(hex$(sordlot.))
  else
    r1 = e2 * -1 ! <0 error
    e$ = "msg Record Not On File"
  end if
else
  if spc(8) = 123 exit function -123 ! record locked
  dim msc4$[100] \ msc4$=msc$(4)
  if Pos(msc4$, = "/",-1) let msc4$=msc4$[pos(msc4$,="/",-1)+1]
  select case spc(8)
    case 10000
      ! this is default "message" error
      ! e$ should be set with message to display
    case 11000
      ! search error
      call env(2,"PROGNAME",msc4$)
      call programdump()
      call searcherr(e$, e, Spc(10), e$)
    case else
      e$="filegetsordlotz mode=",mode," keyno=",keyno," r1=",r1," e2=",e2," keyval$=",keyval$
      if spc(8) <> 0 if spc(8) < 10000
        call env(2,"PROGNAME",msc4$)
        call programdump()
        call suberr(e$,Spc(8),Spc(10),Msc$(2))
      end if
  end select
  error 10000
end try
end function r1 ! filegetsordlot
!
! ----------------------------------------
external function fileupdatesordlotz(e$,chan,mode$,rcdno,sordlot. as sordlot,...)
!
! adds, changes or deletes a sordlot record
!
! pass e$     : to return error msg if any
  ! pass chan   : channel # of file
  ! pass mode$  : a = add, c = change, d = delete
  ! pass rcdno  : on change or delete,
  !      if -4 is passed routine will get record (index 1 can't change on change)
  ! pass record : structure
  ! optionally pass lockflag to keep record locked
  ! optionally pass timeout period
  ! optionally pass chan# of audit log, -1 to audit but log not open
  ! optionally pass reason (up to 80 char) reason for change,writes to audit
  ! returns 0 or negative # if error, -9=already on file, -123=record locked
  ! returns rcdno added on add
  !
  ! search used in update call
  !
  Declare sub DoSearch,AddKeys,DeleteKeys,ChangeKeys
  !
Try
  !
  Try Enter lockflag,... Else Let lockflag = 0
  Try enter timeout,... else let timeout = 100000
  Try enter auditchan,... else let auditchan = 0
  Try enter reason$ else dim reason$[1]
  !
  dim K$[64],K1$[64],K2$[64],K3$[64],K4$[64],K5$[64]
  dim 3%,K6$[64],K7$[64],K8$[64],K9$[64]
  dim Dir1$[300],Dir2$[300],Dir3$[300],Dir4$[300],Dir5$[300]
  dim Dir6$[300],Dir7$[300],Dir8$[300],Dir9$[300]
  dim OldDir1$[300],OldDir2$[300],OldDir3$[300],OldDir4$[300],OldDir5$[300]
  dim OldDir6$[300],OldDir7$[300],OldDir8$[300],OldDir9$[300]
  dim errmsg$[200],Lmode$[1],ofld$[6],3%
  dim old?[3072],new?[3072],auditk$[30]
  dim Blank$[100] \ Blank$=" ",Blank$
  !
  Lmode$ = lcase$(mode$[1,1]) ! convert mode to lower case,just in case
  ofld$=sordlot.OrdNum using "######"
  if sordlot.OrdType=1 let ofld$=sordlot.ProdWo$+Blank$ ! PWO not order
  sordlot.NU$=" ",sordlot.NU$
  !
  if Lmode$ = "a" ! add: set defaults, check not on file, get free record
    k$=sordlot.ProdCode$,ofld$,sordlot.WoSoLine using "###",sordlot.Whse using "##",sordlot.Loc$,sordlot.LotNum$,sordlot.Stock$,sordlot.NU$[1, 1 ]
    call dosearch(k$,2,1,1) ! search mode=2 dir=1 errflag
    if e = 0 ! record already on file, can't add error
      e$ = "msg Record Already On File" ! set to already on file msg # in dxmsg.txt file
      exit function -9 ! -9 indicates already on file!
    end if
    !
    e=2
    call dosearch("",1,0) ! get record #
    !
    ! do like unibasic - write data/then add keys
    if lockflag=0 write record #chan,r,0,timeout;sordlot.; else write record #chan,r,0,timeout;sordlot.
    if auditchan
     if lockflag=0 mat read #chan,r;old?; else mat read #chan,r;old?
    end if
	!
	call AddKeys(1, 3 ) ! add keys, all directories
    !
    e=r !return record # added
  endif
  !
  if lmode$ = "c" or lmode$ = "d" ! change or delete, verify record
    dim oldsordlot. as sordlot
    if rcdno = -4 ! need to get the record first
      r=rcdno \ oldr=rcdno ! if record # is used in the key
      k$=sordlot.ProdCode$,ofld$,sordlot.WoSoLine using "###",sordlot.Whse using "##",sordlot.Loc$,sordlot.LotNum$,sordlot.Stock$,sordlot.NU$[1, 1 ]
      call dosearch(k$,2,1,1) ! mode 2, dir 1, errflag 1 never trap as hard error
      if e
        ! Customer not on file!
        e$="msg Record Not On File" ! set to not on file msg # in dxmsg.txt file
        exit function e * -1
      end if
    else
      r = rcdno \ oldr=rcdno
    end if
	if lmode$="d" let lockflag=0 ! never on delete!
    if auditchan 
		if lockflag=0 mat read #chan,r;old?; else mat read #chan,r;old?
	Endif
    if lockflag=0 read record #chan,r,0,timeout;oldsordlot.; else read record #chan,r,0,timeout;oldsordlot.
  endif
  !
  if Lmode$ = "d" ! deletes keys and record #
    !
    call DeleteKeys(1, 3 ) ! delete keys, all directories
    !
    e=3
   call dosearch("",1,0) ! releases record #
  endif
  !
  if Lmode$ = "c" ! change record and keys
    !
    if lockflag=0 write record #chan,r,0,timeout;sordlot.; else write record #chan,r,0,timeout;sordlot.
	if auditchan
     if lockflag=0 mat read #chan,r;new?; else mat read #chan,r;new?
    end if
    !
    call ChangeKeys() ! deletes old keys & add new keys
  endif
  !
  if auditchan
   r=dfaudit(e$,auditchan,"sordlot",lmode$,auditk$,old?,new?,reason$)
  end if !auditchan
else
  if spc(8) = 123 exit function -123 ! record locked
  dim msc4$[100] \ msc4$=msc$(4)
  if Pos(msc4$, = "/",-1) let msc4$=msc4$[pos(msc4$,="/",-1)+1]
  select case spc(8)
    case 10000
      ! this is default "message" error
      ! e$ should be set with message to display
    case 11000
      ! search error
      call env(2,"PROGNAME",msc4$)
      call programdump()
      call searcherr(e$, e, Spc(10))
    case else
      if spc(8) < 10000
        call env(2,"PROGNAME",msc4$)
        call programdump()
        call suberr(e$,Spc(8),Spc(10),Msc$(2))
      end if
  end select
  error 10000
End Try
!
!----------------------------------------
sub dosearch(k$,m,k,...)
  !
  !pass k$=keyvalue, m=mode, k=keyno, optionally errflag <>0 return e, don't err
  !
  try enter errflag else let errflag=0
  search #chan,m,k;k$,r,e
  if e if errflag=0 let e$="syserrorfile fileupdatesordlot mode (m)=",m," keyno (k)=",k," r=",r," e=",e," keyval (k$)=",k$
  if e if errflag=0 error 11000 !hard error
end sub ! dosearch
!
!----------------------------------------
sub AddKeys(BegDir,EndDir)
  !
  ! BegDir = Beginning Directory
  ! EndDir = Ending Directory
  !
  try
    Dim CurKey$[64],ofld$[6],3%,CurRec
    !
	ofld$=sordlot.OrdNum using "######"
	if sordlot.OrdType=1 let ofld$=sordlot.ProdWo$+"      "
	sordlot.NU$=" ",sordlot.NU$
    For CurDir=BegDir to EndDir
      CurKey$=""
      if CurDir=1 let CurKey$=sordlot.ProdCode$,ofld$,sordlot.WoSoLine using "###",sordlot.Whse using "##",sordlot.Loc$,sordlot.LotNum$,sordlot.Stock$,sordlot.NU$[1, 1 ]
      if CurDir=1 let auditk$=curkey$
      if CurDir=2 let CurKey$=sordlot.LotNum$,sordlot.Stock$,ofld$,sordlot.WoSoLine using "###",sordlot.Whse using "##",sordlot.Loc$,sordlot.ProdCode$,sordlot.NU$[1, 1 ]
      if CurDir=3 let CurKey$=ofld$,sordlot.WoSoLine using "###",sordlot.Whse using "##",sordlot.Loc$,sordlot.LotNum$,sordlot.Stock$,sordlot.NU$[1, 1 ]
      call DoSearch(CurKey$,4,CurDir) ! add key to directory
    next CurDir
else
  dim msc4$[100] \ msc4$=msc$(4)
  if Pos(msc4$, = "/",-1) let msc4$=msc4$[pos(msc4$,="/",-1)+1]
  select case spc(8)
    case 10000
      ! this is default "message" error
      ! e$ should be set with message to display
    case 11000
      ! search error
      call env(2,"PROGNAME",msc4$)
      call programdump()
      call searcherr(e$, e, Spc(10))
    case else
      if spc(8) < 10000
        call env(2,"PROGNAME",msc4$)
        call programdump()
        call suberr(e$,Spc(8),Spc(10),Msc$(2))
      end if
  end select
  error 10000
End Try
End Sub ! AddKeys
!
!----------------------------------------
sub DeleteKeys(BegDir,EndDir)
  !
  ! BegDir = Beginning Directory
  ! EndDir = Ending Directory
  !
  Try
    Dim CurKey$[64],oofld$[6],3%,CurRec
    !
	oofld$=oldsordlot.OrdNum using "######"
	if oldsordlot.OrdType=1 let oofld$=oldsordlot.ProdWo$+"      "
	oldsordlot.NU$=" ",oldsordlot.NU$
    For CurDir=EndDir to BegDir Step -1
      CurKey$=""
      if CurDir=1 let CurKey$=oldsordlot.ProdCode$,oofld$,oldsordlot.WoSoLine using "###",oldsordlot.Whse using "##",oldsordlot.Loc$,oldsordlot.LotNum$,oldsordlot.Stock$,oldsordlot.NU$[1, 1 ]
      if CurDir=2 let CurKey$=oldsordlot.LotNum$,oldsordlot.Stock$,oofld$,oldsordlot.WoSoLine using "###",oldsordlot.Whse using "##",oldsordlot.Loc$,oldsordlot.ProdCode$,oldsordlot.NU$[1, 1 ]
      if CurDir=3 let CurKey$=oofld$,oldsordlot.WoSoLine using "###",oldsordlot.Whse using "##",oldsordlot.Loc$,oldsordlot.LotNum$,oldsordlot.Stock$,oldsordlot.NU$[1, 1 ]
      call DoSearch(CurKey$,5,CurDir) ! add key to directory
    next CurDir
else
  dim msc4$[100] \ msc4$=msc$(4)
  if Pos(msc4$, = "/",-1) let msc4$=msc4$[pos(msc4$,="/",-1)+1]
  select case spc(8)
    case 10000
      ! this is default "message" error
      ! e$ should be set with message to display
    case 11000
      ! search error
      call env(2,"PROGNAME",msc4$)
      call programdump()
      call searcherr(e$, e, Spc(10))
    case else
      if spc(8) < 10000
        call env(2,"PROGNAME",msc4$)
        call programdump()
        call suberr(e$,Spc(8),Spc(10),Msc$(2))
      end if
  end select
  error 10000
End Try
End Sub ! DeleteKeys
!
!----------------------------------------
sub ChangeKeys()
  !
  try
    Dim CurKey$[64],OldKey$[64],ofld$[6],oofld$[6],3%
    !
	ofld$=sordlot.OrdNum using "######"
	if sordlot.OrdType=1 let ofld$=sordlot.ProdWo$+"      "
	oofld$=oldsordlot.OrdNum using "######"
	if oldsordlot.OrdType=1 let oofld$=oldsordlot.ProdWo$+"      "
	oldsordlot.NU$=" ",oldsordlot.NU$
	sordlot.NU$=" ",sordlot.NU$
    ! Directory #3
    OldKey$=oofld$,oldsordlot.WoSoLine using "###",oldsordlot.Whse using "##",oldsordlot.Loc$,oldsordlot.LotNum$,oldsordlot.Stock$,oldsordlot.NU$[1, 1 ]
    CurKey$=ofld$,sordlot.WoSoLine using "###",sordlot.Whse using "##",sordlot.Loc$,sordlot.LotNum$,sordlot.Stock$,sordlot.NU$[1, 1 ]
    if CurKey$<>OldKey$
      call DoSearch(OldKey$,5,3)
      call DoSearch(Curkey$,4,3)
    endif
    !
    ! Directory #2
    OldKey$=oldsordlot.LotNum$,oldsordlot.Stock$,oofld$,oldsordlot.WoSoLine using "###",oldsordlot.Whse using "##",oldsordlot.Loc$,oldsordlot.ProdCode$,oldsordlot.NU$[1, 1 ]
    CurKey$=sordlot.LotNum$,sordlot.Stock$,ofld$,sordlot.WoSoLine using "###",sordlot.Whse using "##",sordlot.Loc$,sordlot.ProdCode$,sordlot.NU$[1, 1 ]
    if CurKey$<>OldKey$
      call DoSearch(OldKey$,5,2)
      call DoSearch(Curkey$,4,2)
    endif
    !
    ! Directory #1
    OldKey$=oldsordlot.ProdCode$,oofld$,oldsordlot.WoSoLine using "###",oldsordlot.Whse using "##",oldsordlot.Loc$,oldsordlot.LotNum$,oldsordlot.Stock$,oldsordlot.NU$[1, 1 ]
    CurKey$=sordlot.ProdCode$,ofld$,sordlot.WoSoLine using "###",sordlot.Whse using "##",sordlot.Loc$,sordlot.LotNum$,sordlot.Stock$,sordlot.NU$[1, 1 ]
    auditk$=curkey$
    if CurKey$<>OldKey$
      call DoSearch(OldKey$,5,1)
      call DoSearch(Curkey$,4,1)
    endif
    !
else
  dim msc4$[100] \ msc4$=msc$(4)
  if Pos(msc4$, = "/",-1) let msc4$=msc4$[pos(msc4$,="/",-1)+1]
  select case spc(8)
    case 10000
      ! this is default "message" error
      ! e$ should be set with message to display
    case 11000
      ! search error
      call env(2,"PROGNAME",msc4$)
      call programdump()
      call searcherr(e$, e, Spc(10))
    case else
      if spc(8) < 10000
        call env(2,"PROGNAME",msc4$)
        call programdump()
        call suberr(e$,Spc(8),Spc(10),Msc$(2))
      end if
  end select
  error 10000
End Try
End Sub  ! ChangeKeys
!
End Function e ! updatesordlot
!
! ----------------------------------------
external sub filedroplistsordlotz(e$,list$[],maxcnt,Chan,...)
  !
  ! creates a drop list
  !
  ! e$          : to return error msg if any
  ! List$[]     : the record created from the field array
  ! maxcnt      : maxmium # of lines for list array
  ! Chan        : the channel # of the file
  !
  ! Optional parameters
  ! Section$    : .net, the section to be created and sent to web
  ! Field$[]    : the fields being created in the drop down list
  !               in the order of being displayed
  ! KeyNo       : the directory # to search
  ! KeyVal$     : beginning key / compare to
  ! Others$     : list of flags to display other drop list options 0=None,A=All
  !
  Try
    !
    Try enter iSection$,... else dim iSection$[1]
    Try enter iField$[],... else dim iField$[1,30]
    Try enter KeyNo,... else let KeyNo=1
    Try enter KeyVal$,... else Dim KeyVal$[64]
    Try enter Others$ else dim Others$[1]
    !
    option string redim is legal
    !
    dim tmp$[50],tmpfield$[50],tmpline$[500],calling$[14],errtype$[1],Section$[30],Field$[ 3 ,30]
    dim bsdel$[20],esdel$[20],rdel$[20],fdel$[20]
    dim SearKey$[64],Mode$[5]
    dim 2%,row
    dim 2%,tmpcnt,3%
    !
    dim sordlot. as sordlot
    Section$ = iSection$
    for i=0 to ubound(iField$[],1)
     Field$[i]=iField$[i]
    next i
    calling$=callstat$(1,errtype$)
    if calling$="libfilehandler" let blockformat=1 !dxblock <data> format
    !
    call env(1,"BSDEL",bsdel$)
    call env(1,"ESDEL",esdel$)
    call env(1,"RDEL",rdel$)
    call env(1,"FDEL",fdel$)
    !
    if Section$="" let Section$="droplistsordlot"
    tmpcnt=ubound(list$[],1)
    row=0
    !
    ! beginning section
    Clear list$[]
    List$[0]=bsdel$,Section$,fdel$ ! beginning section
    !
    ! heading section for .net
    cnt=0
    if field$=""
      tmpline$="ID",fdel$,"ProdCode",fdel$,"LotNum",fdel$,"Whse",fdel$
      !
      Field$[0]="ProdCode$"
      Field$[1]="LotNum$"
      Field$[2]="Whse"
    else
      tmpline$="ID",fdel$
      while Field$[cnt]
        tmpline$=tmpline$,trim$(Field$[cnt]),fdel$ ! field name
        cnt=cnt+1
      wend
    endif
    if blockformat=0
     List$[1]=tmpline$
    row=2
    end if
    !
 !any other optional elements to include in drop list (defined in page block userdef2
       sub tmpline(tmp$) !needed to put right # of fields in others
        tmpline$=""
        for fcnt=0 to ubound(Field$[],1)
          if Field$[fcnt] = "" exit for
          tmpfield$=" "
          if fcnt=0 let tmpfield$=tmp$
          if blockformat
           let tmpline$=tmpline$,rtrim$(tmpfield$)," "
          else
           let tmpline$=tmpline$,rtrim$(tmpfield$),fdel$
          end if
        next fcnt
       end sub
 xpos=pos(ucase$(others$),="A")
 if xpos
          call tmpline("All")
          if blockformat=0 List$[row]="A",fdel$,tmpline$
          if blockformat let list$[row]=tmpline$,fdel$,"A",fdel$,fdel$
          row=row+1
 end if
 xpos=pos(ucase$(others$),="0")
 if xpos
          call tmpline("None")
          if blockformat=0 List$[row]="0",fdel$,tmpline$
          if blockformat let list$[row]=tmpline$,fdel$,"0",fdel$,fdel$
          row=row+1
 end if
 xpos=pos(ucase$(others$),="B") !blank
 if xpos
          call tmpline("")
          if blockformat=0 List$[row]="",fdel$,tmpline$
          if blockformat let list$[row]=tmpline$,fdel$,"",fdel$,fdel$
          row=row+1
 end if
 xpos=pos(ucase$(others$),="C")
 if xpos
          call tmpline("Total of Selected")
          if blockformat=0 List$[row]="C",fdel$,tmpline$
          if blockformat let list$[row]=tmpline$,fdel$,"C",fdel$,fdel$
          row=row+1
 end if
    ! create data section
      SearKey$=KeyVal$
      Mode$=">"
      do
        RecNo=FileGetsordlotz(e$,Chan,Mode$,KeyNo,SearKey$,sordlot.)
        if RecNo<0 exit do
        if KeyVal$ if SearKey$[1,len(KeyVal$)]<>KeyVal$ exit do
        !
        if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
        !
        tmpline$=""
        for fcnt=0 to ubound(Field$[],1)
          if Field$[fcnt] = "" exit for
          tmpfield$=""
          if Field$[fcnt]="ProdCode$" let tmpfield$=sordlot.ProdCode$," "
          if Field$[fcnt]="LotNum$" let tmpfield$=sordlot.LotNum$," "
          if Field$[fcnt]="Whse" let tmpfield$=str$(sordlot.Whse)
          !
		   if tmpfield$<>"" let tmpfield$=RTrim$(tmpfield$) \ if tmpfield$="" let tmpfield$=" " !even if field all spaces, include it
          if tmpfield$
           if blockformat
            let tmpline$=tmpline$,rtrim$(tmpfield$)," "
           else
            let tmpline$=tmpline$,rtrim$(tmpfield$),fdel$
           end if
          end if
        next fcnt
        !
        if tmpline$
          if blockformat=0 List$[row]=SearKey$,fdel$,tmpline$
          if blockformat let list$[row]=tmpline$,fdel$,trim$(searkey$),fdel$,fdel$
          row=row+1
          !if row > maxcnt+1 exit do !to limit # in drop list
        endif
        !
	   loop
    !
    if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
    if blockformat=0 let List$[row]=esdel$ ! end of section delimiter
    !
else
  dim msc4$[100] \ msc4$=msc$(4)
  if Pos(msc4$, = "/",-1) let msc4$=msc4$[pos(msc4$,="/",-1)+1]
  select case spc(8)
    case 10000
      ! this is default "message" error
      ! e$ should be set with message to display
    case 11000
      ! search error
      call env(2,"PROGNAME",msc4$)
      call programdump()
      call searcherr(e$, e, Spc(10),e$)
    case else
      e$="filedroplistsordlot mode=",mode," keyno=",keyno," error=",recno," keyval$=",keyval$
      if spc(8) = 123 let e$=" record locked"
      if spc(8)<10000 if spc(8)<>123
        call env(2,"PROGNAME",msc4$)
        call programdump()
        call suberr(e$,Spc(8),Spc(10),Msc$(2))
      end if
  end select
  error 10000
end try
end sub ! filedroplistsordlot
!
! ----------------------------------------
!
! **main procedure
!
! dim variables used by program
!
dim e$[500],buttonlist$[5,50],nextlist$[5,100] !error handling variables
try
!
 dim blockid$[8],tmp$[100],ofld$[6],id$[100],readonly$[1],Blank$[80]
 dim action$[30],options$[30],userid$[8],3%,fdel$[10],rstr$[3000],bsdel$[10],esdel$[10],rdel$[10]
 dim sordlot. as sordlot
 Blank$=" ",Blank$
 !
 call getglobals("blockx",0,blockid$,CTLC,options$,action$,userid$,intCO,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$)
 !open data file
 let readonly$="R" !ropen
 chan = OpenFile("sordlot",intCo*-1,readonly$)
 if chan < 0 error 10000
 !
 call dxget("ID",id$)  !record # or key
 !
 ofld$=sordlot.OrdNum using "######"
  if sordlot.OrdType=1 let ofld$=sordlot.ProdWo$+Blank$ ! PWO not order
  sordlot.NU$=" ",sordlot.NU$
 if action$="VERIFY"
  sordlot.ProdCode$=id$
  id$=sordlot.ProdCode$,ofld$,sordlot.WoSoLine using "###",sordlot.Whse using "##",sordlot.Loc$,sordlot.LotNum$,sordlot.Stock$,sordlot.NU$[1, 1 ]
  r = filegetsordlotz(e$,chan,"=",1,ID$,sordlot.)
  if r < 0 
   let e$="msg Record Not on File"
   error 10000 !not on file return error
  end if
  tmp$="ID",fdel$,"Desc",fdel$,rdel$  !always going to return ID (key) and first droplist field
  tmp$=tmp$,rtrim$(id$),fdel$
  tmp$=tmp$,fdel$,rdel$
  call addtostr(e$,rstr$,tmp$)  !return formatted key and first required field
 end if
 !
 Call addtostr(e$,rstr$,esdel$) !end section
 !!!!!!print rstr$
 Call setoutput(e$,rstr$,1,e$) !1 flag puts 0 status section in, puts </page> in, e$ is message
else
 ! error routine
  dim msc4$[100] \ msc4$=msc$(4)
  if Pos(msc4$, = "/",-1) let msc4$=msc4$[pos(msc4$,="/",-1)+1]
  select case spc(8)
    case 10000
      ! this is default "message" error
      ! e$ should be set with message to display
    case 11000
      ! search error
      call env(2,"PROGNAME",msc4$)
      call programdump()
      call searcherr(e$, e, Spc(10),e$)
    case else
      if spc(8) <> 10000
        call env(2,"PROGNAME",msc4$)
        call programdump()
        call suberr(e$,Spc(8),Spc(10),Msc$(2))
      end if
  end select
  call mainerr(e$,spc(8),buttonlist$[],nextlist$[],rstr$)
end try
end
