! 1.0 12/02/2009 - initial conversion
!
! loadsave -w -n 100,10 -o prog/dxport/serp229.dl4 src/serp229.src
!
! From the original code:Rem BEDIT Version: 2.2 OBJECT CODE     Created: APR  9, 2009  14:42:59
Rem /w2/papermaster/r2005//usr/acct/bill/work/r2005/mx2/mx229.src (univ2) [bill] {62103}
Rem  Copyright (c) 2009 Universal Business Systems, Inc.
Rem    **** ALL CHANGES MUST BE MADE IN SOURCE!!! ****
Rem
Rem MX229  ORDER/INVOICE BATCH STATUS
Rem  G.DOSCHER  11/82
Rem  LAST UPDATE: 5/92 - ADD "RESET" FOR IN PROCESS ORDERS
!
!include copyright, common libs, common intrinsics
include "src/copyright.inc"
Declare External Sub CreateNetStatus
!
!
!
!include structure,filehandler libs & default structure dims
! include "src/inc/file?.inc"

!
! *declare additional dl4 intrinsic subs & functionsDeclare Intrinsic Sub InpBuf,String
Declare Intrinsic Sub MiscStr,String,WhoLock
Declare External Sub Monitor
! External Lib "OLDCALLS.LIB"
! Option Default Dialect IRIS1
!
! *declare additional external libs & subs & functions
External Lib "ubsfunc.dl4"
!Declare External Function openfile,pdate$,jdate$,Formatdate2$
Declare External Function GetUIDRec,OpenFile,PDATE$
External Lib "libedittrack.lib"
Declare External Sub MakeEdittrack
Include "src/inc/fileedittrack.inc"
Include "src/inc/filesordcash.inc" ! cash order file
dim etRec. as edittrack
dim e$[500],buttonlist$[5,50],nextlist$[5,100] !error handling variables
!
try
dim action$[30],action1$[30],action2$[30],options$[30],userid$[8],3%
dim bsdel$[20],esdel$[20],rdel$[20],fdel$[20],rstr$[2500] ! .net delimiters
dim tmp$[1000],tmp1$[500],tmp2$[1000],b$[200]
b$=" ",b$
dim message$[150],webstr$[200]
!
! call dxopen()
!
! call getsession(e$,CTLC,options$,action$,userid$,intCO,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$)
Call GetSession(e$,CTLC,options$,action$,UserID$,intCo,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$,Action1$,Action2$)
! call dxsave(0,"tmp/229in.txt!")
DIM 2%,S9[9],t1[1],mcode[9],SEL,SEL$[5],1%,COST_LEV[3],3%,PARAM[20],T2[25],mcharge[9,1]
DIM 1%,mctxbl[9],dclvl,3%,TOT[4],CFIN[8],V1
! If Err 0 Gosub L_9500
! If Spc(13) = 11 Print @0,0;"\177\UWHOTSPOT.\\HOTSPOT\\HOTSPOTIN.hsf\177\";
Dim 1%,LOCKPORT,FILE,CH_ROH,CH_ROH_READ,CH_INVH[1],CH_USERPORT,P2,ch[99]
Dim A$[50],A1$[50],S$[64],S1$[150],X$[20],FILE$[16]
Dim J$[20],J0$[15],J1$[10],J2$[10],J4$[20],J8$[10],J5$[50]
Dim J7$[40],U3$[20],K2$[70],K3$[70],1%,F9[9],2%,S1,S2,H0[12],J9$[20]
Dim FRMSTAT$[2]
Dim keyroc$[30],3%,rec_roc,1%,ch_roc
Dim 1%,SCR1,SUPERUSER,PASS,SCAN_STATUS,STAT,H4[2]
Dim 1%,ETLINE,ETSTAT,ETUNIT,ETNONSTOCK,CH_ET,LOCKTIME,C1,REC1,C2,ETPRINT
Dim 1%,ETPUNIT,X1[9]
Dim 2%,ETORDER,ETDATE,ETTIME,ETPORT,ETACTION,ETCUST,ETSLS
Dim 2%,H5[16],H6[8],SORD,COID,X2[9]
Dim 3%,REC,REC_OS,ETINVOICE,OREF[5],INV_
Dim 3%,ETOQTY[2],ETNQTY[2],X3[9]
Dim 3%,ETUNITPRICE[1],ETLOADCOST[1],ETORIGTOT,ETWGT[1]
Dim KEY_$[50],OS$[50],RSTORDER$[6]
Dim SCRATCH$[80],ET$[80],ETPROD$[12],USER$[10],P60$[50]
Dim BLANK$[90],DL1$[20]
Dim DEVICE$[32],DIR$[32],FILENAMES$[512],TERM$[32]
Dim K11$[60],K17$[60],K177$[60],K1777$[60],S0$[36],OL2$[16]
Dim 1%,OL1[3],L3[3],SS2[1]
Dim 2%,CHAN[102],INFO[7],STATUS,STATUSCOUNT,STATUSOFF,SHIPTOTORD[1]
Dim 2%,L2[1],L4[3],L7[2],OL2[3],BYPASSQUEST,DELETELINEFLAG,ORDERSTATUS
Dim 3%,R2,R5,R11,R17,R177,H1
Dim fchan[1]
Dim 1%,FLAG,E,STATCOUNT
Dim 2%,SOSRCHH0[12],SOSRCHH5[16]
Dim 3%,SCR,SOSRREF[5]

dim roc. as sordcash ! sale order cash file

U3$ = " ",U3$;BLANK$ = " ",BLANK$
S1$ = "ENTERED   PRINTED   REGISTEREDRDY TO INVINV ENTRD INV PRNTD INV REG'D "

S1$[Len(S1$) + 1] = "INV REG'D "
CH_ROH = 8;CH_AUD = 34
CH_ROH_READ = 2;CH_INVH = -43;CH_INVH[1] = -99
CH_USERPORT = 33
BYPASSQUEST = 0
For J = 0 To 9
	S9[J] = 0
Next J
SEL = 0
SEL$ = "0"

!
! open all the needed files
!
For J = 8 To 17
	Read J1 \ If J1 = -1 Goto L_270
	Read #1,88,Abs(J1);FILE$;
	If J1 < 0 Ropen #J,FILE$ Else Open #J,FILE$
L_270: Next J
Data "1840","1856","1872","1888","2128","-1","-1","-1","-1"," 2320"
Read #1,88,1840;FILE$;
Rem open #ch_roh,file$   ! normal open
Ropen #2,FILE$
! No super user functionality ported
! key record is the user record, not the port
!
! Ropen #CH_USERPORT,"cntrl/userport"
! Read #CH_USERPORT,Spc(6);SCR1;
! Ropen #CH_USRCTL,"cntrl/usercntrl"
ch_usrctl = OpenFile(-9988,IntCo) \ if ch_usrctl = -1 Error 42
! If SCR1 = -1
! 	SUPERUSER = 1
! 	ETUSER$ = "SUPERUSER "
! Else
	REC1 = GetUIDRec(e$, IntCo, Userid$)
	SUPERUSER = 0
!	Mat Read #CH_USRCTL,REC1,260;ETUSER$;
! End If
! Close #CH_USERPORT,#CH_USRCTL
Mat Read #1,60,50;P60$;
! SCRATCH$ = + Str$(Int((Spc(5) - Int(Spc(5) / 16384) * 16384) / 64))
If P60$[44,44] = "Y"
	! Open #CH_ET,"2/edittrack" + SCRATCH$
	! Open #CH_ET,"2/edittrack" + str$(intco)
	CH_ET=OpenFile(9996,IntCo)
	if ch_et<0 let p60$[44,44]="N"
End If

ch_invh = OpenFile(-1136,IntCo) \ if ch_invh = -1 Error 42
ch_invh[1] = OpenFile(-9994,IntCo) \ if ch_invh = -1 Error 42

!
! Main "action" sub-routine dispatcher
!
select case action1$
	case "GETLIST" !							doc=Order Status - GETLIST - 229.doc
		gosub BuildList
		! status section
		Message$=""
	case "DETAIL" !								doc=Order Status - DETAIL - 229.doc
		gosub BuildDetail
		! status section
		Message$="OK"
	case "SEARCH" !								doc=Order Status - SEARCH - 229.doc
		gosub OrdInvSearch
		! status section
		Message$="OK"
	case "RESET" !								doc=Order Status - RESET - 229.doc
		gosub ResetStatus
		!TMP$=""+FDEL$+rdel$+ESDEL$ ! close the open "addl msg" section!
		!call addtostr(e$,rstr$,tmp$)
		! status section
		Message$="Status reset."+FDEL$+RDEL$
		call addtostr(e$,rstr$,message$+esdel$)
		Message$="OK"
	case else
		e$ = "Unknown action1: "+action1$ \ error 10000
endselect
! message should be set.  if we got here - we've got a good status
ReturnStatus=1
call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
call addToStr(e$,rstr$,webstr$)
goto OutEnd:


! ***********************************************************************
! Nobody but us subroutines and exit code down here
! ***********************************************************************

!----------------------------------------------------------------------------
! build initial status list breakdown
!----------------------------------------------------------------------------
BuildList: !
	! Add section header and column defs
	tmp$=bsdel$+"StatusList"+fdel$+rdel$
	tmp$=tmp$+"Status"+fdel$+"Desc"+fdel$
	tmp$=tmp$+"First"+fdel$+"Last"+fdel$+"Number"+fdel$+rdel$
	call addToStr(e$,rstr$,tmp$)
	S4 = 0 \ S1 = 0
	A$ = " " \ F9[1] = 0;F9[2] = 0;F9[5] = 0
	do
		Search #2,3,1;A$,R1,E \ If E>2 gosub err_search:
		If E exit do
		S2 = A$[1,2]
		If S1 <> S2 Gosub StatusBreak
		N2 = A$[3] ! last order/inv number this status
		S3 = S3 + 1 ! number of order/inv this status
		S4 = S4 + 1 ! total number of order/inv
		F9[3] = 0
		try
			Mat Read #2,R1,0,10;H0;
		else
			F9[3] = Spc(8)
		end try
		If H0[0] <> S2 Let F9[1] = F9[1] + 1 ! status error
		If H0[7] <> N2 Let F9[2] = F9[2] + 1 ! key/data errors
	Loop
	Gosub StatusBreak
	call addToStr(e$, rstr$, esdel$)
	tmp$=bsdel$+"StatusWarnings"+fdel$+rdel$
	tmp$=tmp$+"Warning"+fdel$+rdel$
	call addToStr(e$,rstr$,tmp$)
	If F9[1]
		tmp$="WARNING!  "+str$(F9[1])+" STATUS ERROR(S) DETECTED!"
		call addToStr(e$, rstr$, tmp$+rdel$)
	end if
	If F9[2]
		tmp$="WARNING!  "+str$(F9[2])+" KEY/DATA ERROR(S) DETECTED!"
		call addToStr(e$, rstr$, tmp$+rdel$)
	end if
	call addToStr(e$, rstr$, esdel$)
Return

!----------------------------------------------------------------------------
! pass the status - get the description
!----------------------------------------------------------------------------
Function StatusDescription$(stat)
	Select Case stat
		case IS < 9
			exit function S1$[stat * 10 - 9,stat * 10]
		case 9 TO 14
			exit function "CM "+S1$[(stat - 8) * 10 - 9,(stat - 8) * 10]
		case 15 TO 19
			exit function S1$[(stat - 10) * 10 - 9,(stat - 10) * 10]
		case 20 TO 24
			exit function "DELETED"
		case 30
			exit function "HISTORY"
		case 31
			exit function "HISTORY C/M"
		case 44
			exit function "MEMO ENTERED"
		case 45
			exit function "MEMO PRINTED"
		case 59
			exit function "POS ON HOLD "
		case 58
			exit function "POS BEING PKT "
		case 90
			exit function "IN PROCESS"
		case 91
			exit function "IN EDIT"
		case 92
			exit function "IN JOURNAL"
		case 93
			exit function "IN CM JOURNAL"
		case 94
			exit function "INV ENTRY ERP"
		case 95
			exit function "ORD PROC ERP"
		case 96
			exit function "INV PROC ERP"
		case 97
			exit function "CM PROC ERP"
	end select
End Function "** UNKNOWN **"

!----------------------------------------------------------------------------
! part of "BuildList"  - process break in status
!----------------------------------------------------------------------------
StatusBreak: !
	If S1
		tmp$ = str$(S1)+fdel$+StatusDescription$(S1)+fdel$
		tmp$=tmp$+str$(N1)+fdel$+str$(N2)+fdel$+str$(S3)+fdel$
		call addToStr(e$, rstr$, tmp$+rdel$)
	End If
	S3 = 0
	If S1 >= 90 Let F9[5] = 9
	S1 = S2
	N1 = A$[3]
return

!----------------------------------------------------------------------------
! Get detail for a particular status
!----------------------------------------------------------------------------
BuildDetail: !
	Call DxGet("Status", tmp$) \ i = tmp$
	if i < 1 or i  > 99
		e$ = "Status to get detail of must be between 1 and 99!"
		error 10000
	end if
	FRMSTAT$ = i Using "##"
	! Add section header and column defs
	tmp$=bsdel$+"HouseKeeping"+fdel$+rdel$
	tmp$=tmp$+"Status"+fdel$+"Desc"+fdel$
	call addToStr(e$,rstr$,tmp$+rdel$)
	tmp$=str$(i)+fdel$+StatusDescription$(I)+fdel$+rdel$
	call addToStr(e$,rstr$,tmp$+esdel$)
	! Add section header and column defs
	tmp$=bsdel$+"DetailList"+fdel$+rdel$
	tmp$=tmp$+"OrderNumber"+fdel$+"Type"+fdel$+"LockedBy"+fdel$
	tmp$=tmp$+"PreviousStatus"+fdel$
	TMP$=TMP$+"EntDateTime"+fdel$
	call addToStr(e$,rstr$,tmp$+rdel$)
	A$ = " ",A$ \ A$[1,2] = FRMSTAT$
	do
		Search #2,3,1;A$,R1,E \ if e>2 gosub err_search:
		If E Or A$[1,2] <> FRMSTAT$ exit do
		Read #2,R1,64;LOCKPORT;
		Mat Read #2,R1,104;H5;
		Mat Read #2,R1,408;H6;
		tmp$=A$[3,8]+fdel$+str$(H5[7])+fdel$
		If FRMSTAT$ >= "90"
			If LOCKPORT
				if FRMSTAT$ >= "94" and FRMSTAT$ <= "97"
					Mat Read #CH_USRCTL,LOCKPORT,260;USER$;
					tmp$=tmp$+"User "+USER$
				else
					tmp$=tmp$+"Port "+str$(LOCKPORT)
				end if
			end if
			tmp$=tmp$+fdel$
			tmp$=tmp$+str$(H6[2])+fdel$
		Else
			tmp$=tmp$+fdel$+fdel$
		End If
		! added 38547 - date/time entered
		IF H5[16]>2500 ! SOME ARE HHMMSS?
			LET X$=H5[16] USING "&&&&&&"
			LET H5[16]=X$[1,4] ! CUT TO HHMM
		ENDIF
		clear x$
		clear tmp2$
		if h5[15]>0 let x$=pdate$(h5[15]) ! date as MM/DD/YYYY
		
		if h5[16]>25 and H5[16]<=2500 ! some are HHMM
			tmp1$=h5[16] using "&&&&"
			tmp2$=tmp1$[1,2]+":"+tmp1$[3,4]
		else
			tmp1$=h5[16] using "&&.&&&&&&" ! incase seconds or more
			tmp2$=tmp1$[1,2]+":"+tmp1$[4,5]
		endif
		tmp$=tmp$+x$+" "+tmp2$+fdel$
		call addToStr(e$, rstr$, tmp$+rdel$)
	loop
	call addToStr(e$,rstr$,esdel$)
Return

!----------------------------------------------------------------------------
! reset status errored out - close additional "messages" section
! and set the message and status.
!----------------------------------------------------------------------------
sub ResetStatusFatal(msg$)
	
	call addToStr(e$, rstr$, msg$+fdel$+rdel$+esdel$)
	ReturnStatus=0
	call CreateNetStatus(e$,ReturnStatus,msg$,WebStr$)
	call addToStr(e$,rstr$,webstr$)
End Sub

!----------------------------------------------------------------------------
! Reset Status of an Order
!----------------------------------------------------------------------------
ResetStatus: !
	! * set up section for additional warning and/or error messages
	tmp$=bsdel$+"AdditionalMsgs"+fdel$+rdel$
	tmp$=tmp$+"Msg"+fdel$+rdel$
	call addToStr(e$, rstr$, tmp$)
	! * let's do it
	Call DxGet("Status", tmp$) \ A$ = tmp$
	If A$ <> "90" And A$ <> "91" and a$<>"94" and a$<>"95" and a$<>"96" and a$<>"97"
		call ResetStatusFatal("Status reset only allowed on status 90-91 and 94-97!")
		goto outend
	end if
	STAT = A$[1,2]
	call DxGet("OrderNumber", tmp$) \ RSTORDER$ = tmp$
	T0 = 0;RSTORDER = RSTORDER$[1,6]
	A$ = " ",A$;A$[1,2] = STAT Using "##"
	A$[3] = RSTORDER Using "######"
	Search #CH_ROH,2,1;A$,R1,E \ if e>1 gosub err_search:
	If E
		call ResetStatusFatal("Order "+A$[3,8]+" is not in status ["+str$(STAT)+"]")
		goto outend
	End If
	A1$ = " ",A1$ \ A1$ = A$
	Gosub CheckOrderValid
	! ***************************************************************
	! Get the original status and the port that is said to be
	! locking the order.  Get the program # that said port is
	! currently said to be accessing.  If the status and the program
	! appear to be matching up, a check was offered to the user to
	! verify if the port is REALLY still logged in.
	!
	! Couple of problems:
	!   1. Need to verify, but under ERP, LOCKPORT is no longer
	!      a port, but a usercntrl record #
	!   2. Program access is not logged in userport for ERP.
	!
	! Temporary solution: if port happens to match up (as in the old
	! Unibasic / Paper Master style) this order is NOT available for
	! reset here.
	! ***************************************************************
	Mat Read #CH_ROH,R1,64;LOCKPORT;
	Ropen #CH_USERPORT,"cntrl/userport"
	! Read #CH_USERPORT,Spc(6),0;REC1; ! already set above
	If Stat<92 ! these are ub side
		Try
			Read #CH_USERPORT,LOCKPORT,2;P2;
		Else ! could be usrcntrl # ! (on erp side)
			p2=0
		End try
	Else ! erp side
		! p2= ?? (or allow all?)
	Endif
	Close #CH_USERPORT
	L_3660: Rem check original status
	Mat Read #CH_ROH,R1,104;H5;
	Mat Read #CH_ROH,R1,78;H4;
	Read #CH_ROH,R1,416;S2; ! orig
	Mat Read #CH_ROH,R1,512;OREF;
	! IN ERP (status 95), new orders have an original status of
	! 0.  If these are left hanging open, reset to status 1
	if stat = 95 AND S2 = 0 s2 = 1
	ORDERSTATUS = S2
	If S2 <> 58 And S2 <> 59
		If S2 <= 0 Or S2 >= 11 Or S2 = 7
			call ResetStatusFatal("NOT ABLE TO RESET ORDER ["+str$(H0[7])+"]") \ goto outend
		End If
	End If
	If S2 = 8 Or Fra(S2) <> 0 !CK JUST TO BE SURE
		call ResetStatusFatal("NOT ABLE TO RESET ORDER ["+str$(H0[7])+"]") \ goto outend
	End If
	If (STAT = 90 And S2 = 1 And P2 = 201) Or (STAT = 90 And S2 = 5 And (P2 = 231 Or P2 = 251))
! 		Gosub L_3799 \ Return
		call ResetStatusFatal("Order ["+str$(H0[7])+"] locked by port "+str$(LOCKPORT)+".  Not reset!") \ goto outend
	End If
	If (STAT = 91 And S2 <= 4 And (P2 = 208 Or P2 = 221)) Or (STAT = 91 And S2 > 4 And S2 < 9 And P2 = 223)
! 		Gosub L_3799 \ Return
		call ResetStatusFatal("Order ["+str$(H0[7])+"] locked by port "+str$(LOCKPORT)+".  Not reset!") \ goto outend
	End If
	If (STAT = 90 And P2 = 241 And (S2 = 9 Or S2 = 10))
! 		Gosub L_3799 \ Return
		call ResetStatusFatal("Order ["+str$(H0[7])+"] locked by port "+str$(LOCKPORT)+".  Not reset!") \ goto outend
	End If
	If (STAT = 91 And P2 = 243 And (S2 = 9 Or S2 = 10))
! 		Gosub L_3799 \ Return
		call ResetStatusFatal("Order ["+str$(H0[7])+"] locked by port "+str$(LOCKPORT)+".  Not reset!") \ goto outend
	End If
	Gosub CHECK_PROBLEM
	A1$[1,2] = S2 Using "##"
	If P60$[44,44] = "Y"
		Gosub EditTrackInit
		etRec.EtAction = H0[0] + (S2 / 100)
		call MakeEdittrack(e$, IntCo, fchan[], etRec.)
	End If
	Gosub LogAudit
	Write #CH_ROH,R1,0;S2;
	S2 = 0 \ Write #CH_ROH,R1,416;S2;
	Search #CH_ROH,4,1;A1$,R1,E \ If E>1 gosub err_search:
	Search #CH_ROH,5,1;A$,R1,E \ If E gosub err_search:
	T0 = T0 + 1
	If Fra(DELETELINEFLAG) <> 0
		tmp$="It is highly recomended to run a 775 on all products(including"+fdel$
		call addToStr(e$, rstr$, tmp$+rdel$)
		tmp$="lines that were totally deleted) with problems on this order, to"+fdel$
		call addToStr(e$, rstr$, tmp$+rdel$)
		tmp$="correct some problems caused by the program deleting partly entered lines."+fdel$
		call addToStr(e$, rstr$, tmp$+rdel$)
	End If
	! Rem THE GOSUB TO FORCE AN EDIT ALL CHAIN TO MX208A, ETC
 	! Gosub EDITCHAIN
	gosub RetotalOrder
Return

!----------------------------------------------------------------------------
! for status 90s on reset, check to make sure the order is valid
!----------------------------------------------------------------------------
CheckOrderValid: !
	F9[6] = 0
	F9[7] = 0
	try
		Mat Read #CH_ROH,R1,0,10;H0;
		Mat Read #CH_ROH,R1,512;OREF;
	else
		Let F9[7] = Spc(8)
	end try
	If F9[7] <> 0 If F9[7] <> 123 Error 10000
	If F9[7] = 123
		Call WhoLock(CH_ROH,R1,PORTLOCK)
		e$="Order # "+str$(H0[7])+"locked "
		If PORTLOCK <> -1 and PORTLOCK <> 0
			e$=e$+"by port "+str$(PORTLOCK)+" "
		end if
		e$=e$+"- reset is not permitted."
		call ResetStatusFatal(e$)
		goto outend
	End If
	If H0[2] < 0 Or H0[3] < 0 Let F9[6] = 1 \ Gosub OrderInvalid
	If H0[2] >= Chf(9) Let F9[6] = 1 \ Gosub OrderInvalid
	If H0[3] >= Chf(10) Let F9[6] = 1 \ Gosub OrderInvalid
	E = 0
	Search #9,1,0;K11$,R11,E \ If E gosub err_search:
	If H0[2] = 0 If R11 <> 0 Let F9[6] = 1 \ Gosub OrderInvalid
	E = 0
	Search #10,1,0;K11$,R11,E  \ If E gosub err_search:
	If H0[3] = 0 If R11 <> 0 Let F9[6] = 1 \ Gosub OrderInvalid
	If H0[7] <= 0 Or H0[4] <= 0 Or H0[11] <= 0 Let F9[6] = 2 \ Gosub OrderInvalid
	K11$ = " ",K11$
	K11$[1,6] = H0[7] Using "######"
	If K11$[1,6] <> A$[3,8] Let F9[6] = 3 \ Gosub OrderInvalid
	Mat Read #9,H0[2],0;SHIPTOTORD;
	If SHIPTOTORD[1] <> H0[7] Gosub CrossCheckError
	Mat Read #10,H0[3],0;SHIPTOTORD;
	If SHIPTOTORD[1] <> H0[7] Gosub CrossCheckError
	K2$ = " ",K2$;K2$[1,6] = H0[4] Using "######";K2$[7] = H0[7] Using "######"
	K3$ = " ",K3$;K3$[1,3] = H0[11] Using "###";K3$[4,9] = H0[7] Using "######"
	Search #CH_ROH,2,2;K2$,R2,E \ If E>1 gosub err_search:
	If E
		Search #CH_ROH,4,2;K2$,R1,E \ If E gosub err_search:
	End If
	Search #CH_ROH,2,3;K3$,R2,E \ If E>1 gosub err_search:
	If E
		Search #CH_ROH,4,3;K3$,R1,E \ If E gosub err_search:
	End If
Return

!----------------------------------------------------------------------------
! for status 90s on reset order is not valid - attempt delete if possible
!----------------------------------------------------------------------------
OrderInvalid: !
	K11$ = " ",K11$
	K11$[1,6] = A1$[3,8]
	K11$[7] = ""
	Search #11,2,1;K11$,R11,E \ If E>1 gosub err_search:
	If E = 0
		tmp$="Order "+str$(H0[7])+" damaged- possible useful data - not deleteing."+fdel$
		call addToStr(e$, rstr$, tmp$+rdel$)
		tmp$="This order has internal problems. The order is not recoverable."+fdel$
		call addToStr(e$, rstr$, tmp$+rdel$)
		If F9[6] = 1
			tmp$="(Note: Order has invalid ship-to/total record numbers)"+fdel$
			call addToStr(e$, rstr$, tmp$+rdel$)
		end if
		If F9[6] = 2
			tmp$="(note: Order has invalid customer/order/salesman number in data)"+fdel$
			call addToStr(e$, rstr$, tmp$+rdel$)
		end if
		If F9[6] = 3
			tmp$="(Note: Order has garbage data where the keys are <> the data)"
			call addToStr(e$, rstr$, tmp$+rdel$)
		end if
		tmp$="Please contact Universal to check out this order."+fdel$
		call addToStr(e$, rstr$, tmp$+rdel$)
		call ResetStatusFatal("Order status not reset!")
		goto outend
	End If
	tmp$="Order "+str$(H0[7])+" unsalvagable, deleting."+fdel$
	call addToStr(e$, rstr$, tmp$+rdel$)
	H0[7] = A1$[3];H0 = 20
	K2$ = A1$;K2$[1,2] = H0 Using "##"
	Mat Read #CH_ROH,R1,104;H5;
	Mat Read #CH_ROH,R1,78;H4;
	H4 = 229
	H4[1] = Spc(6)
	H5[1] = REC1
	DL1$ = " ",DL1$
	DL1$ = "DEL ORDER-BAD DATA  "
	Mat Write #CH_ROH,R1,0;H0;
	Mat Write #CH_ROH,R1,78;H4;
	Mat Write #CH_ROH,R1,84;DL1$;
	Mat Write #CH_ROH,R1,104;H5;
	Search #CH_ROH,5,1;A1$,R1,E \ If E gosub err_search:
	Search #CH_ROH,4,1;K2$,R1,E \ If E gosub err_search:
	Rem SCAN 1ST DIR FOR ANY OTHER RELATED PROBLEMS- DON'T DELETE KEY JUST INSERTED
	K3$ = " ",K3$
	do
		L_3915: Search #CH_ROH,3,1;K3$,R2,E \ If E>2 gosub err_search:
		If E=2 exit do
		! if rec #s equal and key not equal to key we just added
		! and order #s are equal - delete it
		If R2 = R1 and K2$[1,8] <> K2$[1,8] and  K3$[3,8] = A1$[3,8]
			Search #CH_ROH,5,1;K3$,R2,E \ If E gosub err_search:
		end if
	loop
	K2$ = " ",K2$;K2$[1,6] = H0[4] Using "######";K2$[7] = H0[7] Using "######"
	K3$ = " ",K3$;K3$[1,3] = H0[11] Using "###";K3$[4,9] = H0[7] Using "######"
	Search #CH_ROH,2,2;K2$,R2,E \ If E>1 gosub err_search:
	If Not(E) And R1 = R2
		Search #CH_ROH,5,2;K2$,R2,E \ If E gosub err_search:
	Else
		K2$ = " ",K2$
		do
			Search #CH_ROH,3,2;K2$,R2,E \ If E>2 gosub err_search:
			If E exit do
			If R2 = R1 and K2$[7,12] = A1$[3,8]
				Search #CH_ROH,5,2;K2$,R2,E \ If E gosub err_search:
			end if
		loop
	End If
	K3$[10] = ""
	Search #CH_ROH,2,3;K3$,R2,E \ If E>1 gosub err_search:
	If Not(E) And R1 = R2
		Search #CH_ROH,5,3;K3$,R2,E \ If E gosub err_search:
	Else
		K3$ = " ",K3$
		do
			Search #CH_ROH,3,3;K3$,R2,E \ If E>2 gosub err_search:
			If E=2 exit do
			If R2 = R1 and K3$[4,9] = A1$[3,8]
				Search #CH_ROH,5,3;K3$,R2,E \ If E gosub err_search:
			end if
		loop
	End If
	If P60$[44,44] = "Y" !order audit flag
		Gosub EditTrackInit
		etRec.EtAction = 0
		etRec.ProdCode$ = "DEL OR-BAD D"
		call MakeEdittrack(e$, IntCo, fchan[], etRec.)
	End If
	Gosub LogAudit
Return

!----------------------------------------------------------------------------
! ORDER CROSSCHECK PROBLEMS- SORDFLES OR SORDFLET REC # DUPS??
! routine never returns as this is a fatal error
!----------------------------------------------------------------------------
CrossCheckError: 
	! Print @0,17;'CE';
	tmp$="Possible pointer problems have been detected with order # "+str$(H0[7])+"."+fdel$
	call addToStr(e$, rstr$, tmp$+rdel$)
	tmp$="Do not try to accept or delete this order.  Instead, please"+fdel$
	call addToStr(e$, rstr$, tmp$+rdel$)
	tmp$="contact Universal with this message and the order number with"+fdel$
	call addToStr(e$, rstr$, tmp$+rdel$)
	tmp$="the problem.  There may be internal problems with the order."+fdel$
	call addToStr(e$, rstr$, tmp$+rdel$)
	call ResetStatusFatal("Order status not reset!")
	goto outend
Return

!----------------------------------------------------------------------------
! initialize edit track record
!----------------------------------------------------------------------------
EditTrackInit: ! initialize same fields as ETRACK_INIT
	fchan[0] = CH_ET
	fchan[1] = 0
	etRec.OrdNum = H0[7]
	etRec.LineNum = 0
	etRec.Status = H0[0]
	etRec.ProdCode$ = "STATUS CHG",b$
	etRec.OrgQtyOrd = 0
	etRec.OrgQtyShip = 0
	etRec.OrgQtyBO = 0
	etRec.Printer = 0
	etRec.UMSell = 0
	etRec.NstkFlag = 0
	etRec.InvNum = OREF[1]
	etRec.OrgOrdTot = 0
	etRec.CustNum = H0[4]
	etRec.Slsm = H0[11]
	etRec.OrgUnitPrice = 0
	etRec.NewUnitPrice = 0
	etRec.UMPrice = 0
	etRec.UnitNetWgt = 0
	etRec.NetWgtFact = 0
Return

!----------------------------------------------------------------------------
! CHECK & CORRECT BAD DATA- HEADER, LINES, ETC-WMB 8/2002
!----------------------------------------------------------------------------
CHECK_PROBLEM:
	DELETELINEFLAG = 0
	Rem FIRST GO THRU SORDFLEL FILE
	K11$ = " ",K11$
	K11$[1,6] = A1$[3,8]
	K11$[7] = ""
	CHECK_P1: Search #11,3,1;K11$,R11,E \ if E>2 gosub err_search:
	If E = 2 Goto CHECK_P2
	If K11$[1,6] <> A1$[3,8] Goto CHECK_P2
	Mat Read #11,R11,0;L2;
	Mat Read #11,R11,8;L3;
	Mat Read #11,R11,16;L4;
	Mat Read #11,R11,256;SS2;
	K2$ = " ",K2$
	K2$[1,6] = L2[1] Using "######"
	K2$[7,9] = L3[2] Using "###"
	If L3[2] = 0 And K2$[1,6] = K11$[1,6] And (K11$[10,10] = "A" Or K11$[10,10] = "B" Or K11$[10,10] = "C") Goto CHECK_P1
	! If L3[2] >= 900 And L3[2] <= 999 And K2$[1,9] = K11$[1,9] Goto CHECK_P1
	If K2$[1,9] <> K11$[1,9] !BAD KEY
		Search #11,5,1;K11$,R2,E \ If E gosub err_search:
		K3$ = " ",K3$
		K3$ = K11$[1,10]
		K3$[10] = ""
		Search #12,5,1;K3$,R2,E \ If E>1 gosub err_search:
		K3$ = " ",K3$
		CHECK_P1A: Search #11,3,2;K3$,R2,E \ if E>2 gosub err_search:
			If E = 2 Goto CHECK_P1B
			If R2 <> R11 Goto CHECK_P1A
			If K11$[1,9] <> K3$[7,15] Goto CHECK_P1A
			Search #11,5,2;K3$,R2,E \ if E gosub err_search:
		Goto CHECK_P1A
		CHECK_P1B: Rem REM DELETE SORDLOT RECORDS
		K1777$ = " ",K1777$
		K1777$[1,9] = K11$[1,9]
		Gosub CHECKDEL_SORDLOT
		If P60$[44,44] = "Y" !order audit flag
			Gosub EditTrackInit
			etRec.EtAction = 4
			etRec.LineNum = K11$[7,9]
			etRec.ProdCode$ = "DEL LN-BAD D"
			call MakeEdittrack(e$, IntCo, fchan[], etRec.)
		End If
		ETLINE = K11$[7,9]
		Gosub ITSGONEMESSAGE
		DELETELINEFLAG = DELETELINEFLAG + 1
		Goto CHECK_P1
	End If
	If L3[0] = 1 If SS2[0] = 3 Goto CHECK_P1
	If L3[0] = 1 !NON-STOCK
		K3$ = " ",K3$
		K3$ = K11$[1,10]
		K3$[10] = ""
		Search #12,2,1;K3$,R2,E \ IF E>1 gosub err_search:
		If E = 1
			Search #11,5,1;K11$,R2,E \ If E gosub err_search:
			If P60$[44,44] = "Y" !order audit flag
				Gosub EditTrackInit
				etRec.EtAction = 4
				etRec.LineNum = L3[2]
				etRec.ProdCode$ = "DEL LN-KEY N"
				call MakeEdittrack(e$, IntCo, fchan[], etRec.)
			End If
			ETLINE = L3[2]
			Gosub ITSGONEMESSAGE
			DELETELINEFLAG = DELETELINEFLAG + 1
			Goto CHECK_P1
		End If
		Mat Read #12,R2,0;L7;
		K2$ = " ",K2$
		K2$[1,6] = L7[0] Using "######"
		K2$[7,9] = L7[1] Using "###"
		If K2$[1,9] <> K3$[1,9] !BAD KEY
			Search #12,5,1;K3$,R2,E \ if E gosub err_search:
			Search #11,5,1;K11$,R2,E \ if E gosub err_search:
			If P60$[44,44] = "Y" !order audit flag
				Gosub EditTrackInit
				etRec.EtAction = 4
				etRec.LineNum = L3[2]
				etRec.ProdCode$ = "DEL LN-BADND"
				call MakeEdittrack(e$, IntCo, fchan[], etRec.)
			End If
			ETLINE = L3[2]
			Gosub ITSGONEMESSAGE
			DELETELINEFLAG = DELETELINEFLAG + 1
			Goto CHECK_P1
		End If
		Goto CHECK_P1
	End If
	Rem STOCK ITEM- CK FOR PROBLEMS.
	K2$ = " ",K2$
	K2$[1,6] = L4[0] Using "######"
	K2$[7,12] = L2[1] Using "######"
	K2$[13,15] = L3[2] Using "###"
	K2$[16] = ""
	Search #11,2,2;K2$,R2,E \ if e>1 gosub err_search:
	If E = 0 Goto CHECK_P1
	Rem NOT THERE -WE HAVE PROBLEMS. IF OK IN SORDLOT, INSERT, OTHERWISE DEL
	K3$ = " ",K3$
	K3$[1,6] = L2[1] Using "######"
	K3$[7,9] = L3[2] Using "###"
	K3$[10] = ""
	Rem WE ARE LOOKING FOR 1 LINE IS SORDLOT- DON'T CARE IF MORE THEN 1 EXIST
	CHECK_P1C: Search #17,3,3;K3$,R17,E \ if E>2 gosub err_search:
	If E = 2 Goto CHECK_P1H
	If K3$[1,9] <> K2$[7,15] Goto CHECK_P1H
	Mat Read #17,R17,0;S0$;
	Mat Read #17,R17,36;OL1;
	Mat Read #17,R17,44;OL2;
	Mat Read #17,R17,96;OL2$;
	K17$ = " ",K17$
	K17$[1,6] = OL2[0] Using "######"
	K17$[7,9] = OL1[0] Using "###"
	K17$[10,11] = OL1[2] Using "##"
	K17$[12,17] = OL2$[11,16]
	K17$[18,29] = S0$[13,24]
	K17$[30,39] = OL2$[1,10]
	If K3$[1,39] <> K17$[1,39] Goto CHECK_P1G
	Rem NOW CK 1ST & 2ND DIR OF SORDLOT
	K17$ = " ",K17$
	K17$[1,12] = S0$[1,12]
	K17$[13,18] = OL2[0] Using "######"
	K17$[19,21] = OL1[0] Using "###"
	K17$[22,23] = OL1[2] Using "##"
	K17$[24,29] = OL2$[11,16]
	K17$[30,41] = S0$[13,24]
	K17$[42,51] = OL2$[1,10]
	K17$[52] = ""
	Search #17,2,1;K17$,R177,E \ if E>1 gosub err_search:
	If E = 1 Goto CHECK_P1G
	K17$ = " ",K17$
	K17$[1,12] = S0$[13,24]
	K17$[13,22] = OL2$[1,10]
	K17$[23,28] = OL2[0] Using "######"
	K17$[29,31] = OL1[0] Using "###"
	K17$[32,33] = OL1[2] Using "##"
	K17$[34,39] = OL2$[11,16]
	K17$[40,51] = S0$[1,12]
	K17$[52] = ""
	Search #17,2,2;K17$,R177,E \ if E>1 gosub err_search:
	If E = 0 Goto CHECK_P1J
	Rem go thru file & delete 1st & 2nd dir keys that are found
	CHECK_P1G: K1777$ = " ",K1777$
	K1777$[1,9] = K3$[1,9]
	Gosub CHECKDEL_SORDLOT
	CHECK_P1H: Search #11,5,1;K11$,R2,E \ if E gosub err_search:
	If P60$[44,44] = "Y" !order audit flag
		Gosub EditTrackInit
		etRec.EtAction = 4
		etRec.LineNum = L3[2]
		etRec.ProdCode$ = "DEL LN-KEY 2"
		call MakeEdittrack(e$, IntCo, fchan[], etRec.)
	End If
	ETLINE = L3[2]
	Gosub ITSGONEMESSAGE
	DELETELINEFLAG = DELETELINEFLAG + 1
	Goto CHECK_P1
	CHECK_P1J: Rem EVERYTHING ELSE IS OK, SO INSERT 2ND DIR INTO SORDFLEL
	K2$ = " ",K2$
	K2$[1,6] = L4[0] Using "######"
	K2$[7,12] = L2[1] Using "######"
	K2$[13,15] = L3[2] Using "###"
	Search #11,4,2;K2$,R2,E \ if E gosub err_search:
	Goto CHECK_P1
	Rem  ***************************************************
	CHECK_P2: Rem! NEXT GO THRU SORDLOT FILE
	K11$ = " ",K11$
	K11$[1,6] = A1$[3,8]
	K11$[7] = ""
	CHECK_P3: Search #17,3,3;K11$,R17,E \ if E>2 gosub err_search:
	If E = 2 Goto CHECK_P4
	If K11$[1,6] <> A1$[3,8] Goto CHECK_P4
	Mat Read #17,R17,0;S0$;
	Mat Read #17,R17,36;OL1;
	Mat Read #17,R17,44;OL2;
	Mat Read #17,R17,96;OL2$;
	K2$ = " ",K2$
	K2$[1,6] = OL2[0] Using "######"
	K2$[7,9] = OL1[0] Using "###"
	K2$[10,11] = OL1[2] Using "##"
	K2$[12,17] = OL2$[11,16]
	K2$[18,29] = S0$[13,24]
	K2$[30,39] = OL2$[1,10]
	If K2$[1,39] <> K11$[1,39] Goto CHECK_P3A
	Rem NOW CK 1ST & 2ND DIR OF SORDLOT
	K2$ = " ",K2$
	K2$[1,12] = S0$[1,12]
	K2$[13,18] = OL2[0] Using "######"
	K2$[19,21] = OL1[0] Using "###"
	K2$[22,23] = OL1[2] Using "##"
	K2$[24,29] = OL2$[11,16]
	K2$[30,41] = S0$[13,24]
	K2$[42,51] = OL2$[1,10]
	K2$[52] = ""
	Search #17,2,1;K2$,R177,E \ if E>1 gosub err_search:
	If E = 1 Goto CHECK_P3A
	K2$ = " ",K2$
	K2$[1,12] = S0$[13,24]
	K2$[13,22] = OL2$[1,10]
	K2$[23,28] = OL2[0] Using "######"
	K2$[29,31] = OL1[0] Using "###"
	K2$[32,33] = OL1[2] Using "##"
	K2$[34,39] = OL2$[11,16]
	K2$[40,51] = S0$[1,12]
	K2$[52] = ""
	Search #17,2,2;K2$,R177,E \ if E>1 gosub err_search:
	If E = 0 Goto CHECK_P3
	CHECK_P3A: Rem DELETE ANY TRACES IN SORDLOT
	DELETEFLAG = 0
	K17$ = K11$
	Gosub CHECKDEL_SORDLOT2
	DELETELINEFLAG = DELETELINEFLAG + .01
	Gosub ITSGONEMESSAGE
	Goto CHECK_P3
	CHECK_P4: Rem DONE WITH THE CHECKS
Return

!----------------------------------------------------------------------------
! DELETE ANY KEYS FOUND IN SORDLOT-SCAN 1ST & 2ND DIR
! 2 PARTS: AT START, DELETE ALL KEYS FOR THAT ORDER/LINE, IN THE
! 2ND OPTION, JUST DELETE KEYS ASSOCIATED WITH THAT ONE KEY IN SORDLOT.
!----------------------------------------------------------------------------
CHECKDEL_SORDLOT:
	DELETEFLAG = 1
	K17$ = " ",K17$
	K17$[1,9] = K1777$[1,9]
	CHECKDEL_C: Search #17,3,3;K17$,R17,E \ if E>2 gosub err_search:
	If E = 2 Return
	If K17$[1,9] <> K1777$[1,9] Return
	Rem SELECTIVE DELETE OPTION. VALUES OF K17$ & R17 S/B ALREADY ASSIGNED
	CHECKDEL_SORDLOT2: K177$ = " ",K177$	
	CHECKDEL_E: Search #17,3,1;K177$,R177,E \ if e>2 gosub err_search:
		If E = 2 Goto CHECKDEL_F
		If R17 <> R177 Goto CHECKDEL_E
		If K17$[1,9] <> K177$[13,21] Goto CHECKDEL_E
		Search #17,5,1;K177$,R177,E \ if e gosub err_search:
	Goto CHECKDEL_E
	CHECKDEL_F: K177$ = " ",K177$
		CHECKDEL_F1: Search #17,3,2;K177$,R177,E \ if e>2 gosub err_search:
		If E = 2 Goto CHECKDEL_G
		If R17 <> R177 Goto CHECKDEL_F1
		If K17$[1,9] <> K177$[23,31] Goto CHECKDEL_F1
		Search #17,5,2;K177$,R177,E \ if e gosub err_search:
	Goto CHECKDEL_F1
	CHECKDEL_G: Search #17,5,3;K17$,R177,E \ if E gosub err_search:
	If DELETEFLAG = 1 Goto CHECKDEL_C
Return

!----------------------------------------------------------------------------
! DISPLAY WHAT LINES WERE DELETED
!----------------------------------------------------------------------------
ITSGONEMESSAGE:
	If DELETELINEFLAG = 0
		tmp$ = "There are problems with order # "+str$(H0[7])+fdel$
		call addToStr(e$, rstr$, tmp$+rdel$)
		tmp$ = "Lines that were deleted:"+fdel$
		call addToStr(e$, rstr$, tmp$+rdel$)
	End If
	If Fra(DELETELINEFLAG) = 0
		tmp$="    "+str$(ETLINE)+fdel$
		call addToStr(e$, rstr$, tmp$+rdel$)
	end if
	If Fra(DELETELINEFLAG) = .01
		tmp$="Note: In addition to any deleted lines, you should check on"+fdel$
		call addToStr(e$, rstr$, tmp$+rdel$)
		tmp$="the following products:"+fdel$
		call addToStr(e$, rstr$, tmp$+rdel$)
	End If
	If Fra(DELETELINEFLAG) <> 0
		tmp$ = "    "+S0$[1,12]+fdel$
		call addToStr(e$, rstr$, tmp$+rdel$)
! 		If Fra(Fra(DELETELINEFLAG) * 25) = 0 Print " "
	End If
Return

!----------------------------------------------------------------------------
! log activity into audit file
!----------------------------------------------------------------------------
LogAudit:
	LOCKTIME = 100;P2 = 229;C1 = 1
	Open #CH_AUD,"cntrl/CNTRL.AUD"
	If Chf(CH_AUD) > 2 ^ 16 - 10
		tmp$="Warning! Audit log file full, transaction not logged!"+fdel$
		call addToStr(e$, rstr$, tmp$+rdel$)
	else
		try
			Write #CH_AUD,Chf(CH_AUD),0,LOCKTIME;P2,Spc(6),C1,REC1,(Spc(2) * 36000 + Spc(3)) / 600,IntCo;
		else
			error 10000
		end try
	end if
	Close #CH_AUD
Return

!----------------------------------------------------------------------------
! as a reset in status can delete lines, re-total the order
!----------------------------------------------------------------------------
RetotalOrder:
	clear ch[] ! channels for files sent to order total
	CH[2]=openfile(1920) \ if ch[2] < 0 error 42
	CH[3]=openfile(1792) \ if ch[3] < 0 error 42
	CH[4]=openfile(2288) \ if ch[4] < 0 error 42
	CH[5]=openfile(1808) \ if ch[5] < 0 error 42
	CH[6]=openfile(1744) \ if ch[6] < 0 error 42
	CH[7]=openfile(1856) \ if ch[7] < 0 error 42
	CH[8]=openfile(1840) \ if ch[8] < 0 error 42
	CH[9]=openfile(1872) \ if ch[9] < 0 error 42
	CH[10]=openfile(1888) \ if ch[10] < 0 error 42
	CH[11]=openfile(2128) \ if ch[11] < 0 error 42
	CH[12]=openfile(928) \ if ch[12] < 0 error 42
	CH[13]=openfile(1824) \ if ch[13] < 0 error 42
	CH[14]=openfile(2176) \ if ch[14] < 0 error 42
	CH[15]=openfile(2528) \ if ch[15] < 0 error 42
	CH[16]=openfile(2320) \ if ch[16] < 0 error 42
	CH[17]=openfile(1728) \ if ch[17] < 0 error 42
	CH[19]=openfile(2032) \ if ch[19] < 0 error 42
	clear s9[]
	let s9[0]=RSTORDER
	let s9[1]=intco
	let s9[2]=H0[11]
	let s9[4]=201 ! default
	If ORDERSTATUS >= 1 If ORDERSTATUS <= 4
		S9[4] = 201
	End If
	If ORDERSTATUS >= 5 If ORDERSTATUS <= 6
		S9[4] = 223
	End If
	If ORDERSTATUS >= 9 If ORDERSTATUS <= 10
		S9[4] = 241
	End If
	! currently don't allow reset of the statuses below:
	! if roh.status=96 let s9[4]=223 ! inv edit
	! if roh.status=94 let s9[4]=231 ! direct invoice/point of sale
	! customer rec - must be on file
	key_$=H0[4] using "######"
	Search #CH[5],2,1;KEY_$,R5,E \ if e gosub err_search:
	! header rec
	H1=R1
	! slsmn rec - must be on file
	key_$=H0[11] using "###"
	Search #CH[13],2,1;KEY_$,V1,E \ if e gosub err_search:

	clear param[]
	param[0]=0 !cred check
	param[1]= 0 ! no credit check 0 !no cred check
	param[2]=0 !no exception check
	param[3]=1 !write total data out
	param[4]=1 !no retotal of customer on order
	if p60$[40,40]="S" let param[4]=1! retotal on order if based on shipped
	param[5]=0 !do no clear manual edits
	param[6]=0 !you can clear cash stuff -- No you cannot not 
	PARAM[10] = 99! ar term misc cost charge   - bypass 
	MAT  READ #ch[9],H0[3],0;T1
	MAT  READ #ch[9],H0[3],8;T2
	MAT  READ #ch[9],H0[3],168;MCODE
	MAT  READ #ch[9],H0[3],208;MCHARGE
	MAT  READ #ch[9],H0[3],328;TOT
	MAT  READ #ch[9],H0[3],358;MCTXBL
	MAT  READ #ch[9],H0[3],378;DCLVL
	Mat Read #ch[5],R5,544;CFIN;   ! from customer file
	! verify cash sale
	Try
		ch_roc = OpenFile(2224,IntCo)
	else
		let ch_roc=-1
	end try
	if ch_roc>0
		let keyroc$=RSTORDER using "######" 
		rec_roc = filegetsordcash(e$,Ch_roc,"=",1,keyroc$,roc.)
		if rec_roc<0 
			let t2[10]=0
			let t2[12]=0
			param[6]=1 ! no sordcash record
		else
			let t2[10]=1
			let t2[12]=roc.payamt1+roc.payamt2
			param[6]=0 
		endif
	else
		let t2[10]=0
		let t2[12]=0
		param[6]=1 ! no sordcash record
	endif
	Mat Write #ch[9],H0[3],8;T2
	Call "ORDERTOTAL",S9[],H1,PARAM[],ch[],T1[],T2[],MCODE[],MCHARGE[],TOT[],MCTXBL[],DCLVL,R5,V1,CFIN[]
Return

!----------------------------------------------------------------------------
! search for an order / invoice or both
!----------------------------------------------------------------------------
OrdInvSearch:
	call DxGet("OrderNumber", tmp$) \ SORD = tmp$
	call DxGet("InvoiceNumber", tmp$) \ INV_ = tmp$
	if not(SORD) and not(INV_)
		e$ = "Enter an order number, an invoice number, or both."
		error 10000
	end if
	tmp$=bsdel$+"SearchResults"+fdel$+rdel$
	tmp$=tmp$+"OrderNumber"+fdel$+"InvoiceNumber"+fdel$
	tmp$=tmp$+"InFile"+fdel$+"Status"+fdel$+"Description"+fdel$
	TMP$=TMP$+"EntDateTime"+fdel$
	call addToStr(e$, rstr$, tmp$+rdel$)
	gosub check_roh
	gosub check_invh
	call addToStr(e$, rstr$, esdel$)
Return

!----------------------------------------------------------------------------
! found one - add results to output
!----------------------------------------------------------------------------
SearchFind:
	tmp$=str$(sosrchh0[7])+fdel$+str$(sosrref[1])+fdel$
	If FILE < 2
		tmp$=tmp$+"In order file"+fdel$
	Else
		tmp$=tmp$+"In order history"+fdel$
	End If
	tmp$=tmp$+str$(sosrchh0)+fdel$+StatusDescription$(sosrchh0)+fdel$
	! added 38547 - date/time entered
	IF sosrchh5[16]>2500 ! SOME ARE HHMMSS?
			LET X$=sosrchh5[16] USING "&&&&&&"
			LET sosrchh5[16]=X$[1,4] ! CUT TO HHMM
	ENDIF
	clear x$
	clear tmp2$
	if sosrchh5[15]>0 let x$=pdate$(sosrchh5[15]) ! date as MM/DD/YYYY
	if sosrchh5[16]>25 and sosrchh5[16]<=2500 ! some are HHMM
		tmp1$=sosrchh5[16] using "&&&&"
		tmp2$=tmp1$[1,2]+":"+tmp1$[3,4]
	else
		tmp1$=sosrchh5[16] using "&&.&&&&&&" ! incase seconds or more
		tmp2$=tmp1$[1,2]+":"+tmp1$[4,5]
	endif
	if sosrchh5[16]=0 clear tmp2$
	tmp$=tmp$+x$+" "+tmp2$+fdel$
	call addToStr(e$, rstr$, tmp$+rdel$)
return

!----------------------------------------------------------------------------
! check order file
!----------------------------------------------------------------------------
CHECK_ROH: Rem
FLAG = 0
FILE = 1
!If KEY_$ = ""
  STATCOUNT = 1
  KEY_$ = " ",KEY_$
  KEY_$[1] = STATCOUNT Using "##"
  If Not(INV_)
    KEY_$[3] = SORD Using "######"
    KEY_$[8] = ""
  End If 
!End If 
Search #CH_ROH,2,1;Key_$,Rec,E
if not(e) goto gotomtch
CHECK_ROH_LOOP: Rem
Search #CH_ROH,3,1;KEY_$,REC,E
If E > 2 Gosub ERR_SEARCH
GotOMtch: ! found on mode 2
If Not(E)
  SCR = KEY_$[3]
  If SORD
    If SCR = SORD
      FLAG = 1
      Mat Read #CH_ROH,REC;SOSRCHH0;
	  MAT READ #CH_ROH,REC,104;SOSRCHH5;
      Mat Read #CH_ROH,REC,512;SOSRREF;
	  gosub SearchFind
      Goto END_CHECK_ROH
    Else 
      X = KEY_$[1,2]
      If INV_ = 0 And (SCR > SORD Or X > STATCOUNT)
        STATCOUNT = STATCOUNT + 1
        If STATCOUNT > 99 Goto END_CHECK_ROH_LOOP
        KEY_$ = " ",KEY_$
        KEY_$[1,2] = STATCOUNT Using "##"
        KEY_$[3] = SORD Using "######"
        KEY_$[8] = ""
        Goto CHECK_ROH_LOOP
      End If 
    End If 
  End If 
  Mat Read #CH_ROH,REC;SOSRCHH0;
  MAT READ #CH_ROH,REC,104;SOSRCHH5;
  Mat Read #CH_ROH,REC,512;SOSRREF;
  If INV_ And SOSRREF[1] = INV_ ! " sosrchH0[6] = inv
    FLAG = 1
	gosub SearchFind
    Goto END_CHECK_ROH
  Else 
    Goto CHECK_ROH_LOOP
  End If 
End If 
END_CHECK_ROH_LOOP: Rem
KEY_$ = ""
REC = 0
END_CHECK_ROH: Rem
Return 


!----------------------------------------------------------------------------
! check invoice file
!----------------------------------------------------------------------------
CHECK_INVH: Rem
FLAG = 0
FILE = 2
STATCOUNT = 0
!If KEY_$ = ""
  KEY_$ = " ",KEY_$
  KEY_$[1] = STATCOUNT Using "##"
  If SORD
    KEY_$ = SORD Using "######"
    If INV_
      KEY_$[7] = INV_ Using "##########"
      KEY_$[17] = ""
    End If 
  Else 
    KEY_$[3] = INV_ Using "##########"
    KEY_$[11] = ""
  End If 
!End If 
If SORD
  Search #CH_INVH[1],2,3;KEY_$,REC,E
  If not(e) goto gotimtch
CHECK_INVH1_LOOP: Rem
  Search #CH_INVH[1],3,3;KEY_$,REC,E
  If E > 2 Gosub ERR_SEARCH
  GotiMtch: ! matched mode 2
  If Not(E) And Val(KEY_$[1,6]) = SORD
    If INV_ And Val(KEY_$[7,16]) <> INV_
      Goto CHECK_INVH1_LOOP
    End If 
    FLAG = 1
    Mat Read #CH_INVH,REC;SOSRCHH0;
	MAT READ #CH_INVH,REC,104;SOSRCHH5;
    Mat Read #CH_INVH,REC,512;SOSRREF;
	gosub SearchFind
    Goto check_invh1_loop:  ! END_CHECK_INVH
  End If 
END_CHECK_INVH1_LOOP: Rem
  KEY_$ = ""
  REC = 0
Else 
  Statcount=30
  Key_$[1,2]="30"
  Search #ch_invh,2,1;key_$,Rec,E
  if not(e) goto gotihmtch 
CHECK_INVH_LOOP: Rem
  Search #CH_INVH,3,1;KEY_$,REC,E
  If E > 2 Gosub ERR_SEARCH
  GotIHMtch: ! match mode 2
  If Not(E)
    SCR = KEY_$[3]
    If INV_
      If SCR = INV_
        FLAG = 1
        Mat Read #CH_INVH,REC;SOSRCHH0;
		MAT READ #CH_INVH,REC,104;SOSRCHH5;
        Mat Read #CH_INVH,REC,512;SOSRREF;
		gosub SearchFind
        Goto END_CHECK_INVH
      Else 
        X = KEY_$[1,2]
        If SORD = 0 And (SCR > INV_ Or X > STATCOUNT)
          STATCOUNT = STATCOUNT + 1
          If STATCOUNT > 99 Goto END_CHECK_INVH_LOOP
          KEY_$ = " ",KEY_$
          KEY_$[1,2] = STATCOUNT Using "##"
          KEY_$[3] = INV_ Using "##########"
          KEY_$[11] = ""
          Goto CHECK_INVH_LOOP
        End If 
      End If 
    End If 
    Mat Read #CH_INVH,REC;SOSRCHH0;
	MAT READ #CH_INVH,REC,104;SOSRCHH5;
    Mat Read #CH_INVH,REC,512;SOSRREF;
    If SORD And SOSRCHH0[7] = SORD
      FLAG = 1
	  gosub SearchFind
      Goto END_CHECK_INVH
    Else 
      Goto CHECK_INVH_LOOP
    End If 
  End If 
END_CHECK_INVH_LOOP: Rem
  KEY_$ = ""
  REC = 0
End If 
END_CHECK_INVH: Rem
Return 


! PRE_MAIN: Rem
! Print 'CS';@0,0;"-MX229-";@25,0;"ORDER/INVOICE BATCH STATUS    vers 3.2"
! SCAN_STATUS = 1
! SCAN_QUEST: Print @0,23;'CL';"SCAN ORDER STATUS? (Y/<N>)  ";
! Input ""S$
! Call String(1,S$)
! If S$ = "" Or S$ = "N" Let SCAN_STATUS = 0 \ Goto OPT_QUEST
! If S$ <> "Y" And S$ <> "N" And S$ <> "" Goto SCAN_QUEST
! Print @0,23;'CL';
! 
! MAIN: Rem
! Print 'CS';@0,0;"-MX229-";@25,0;"ORDER/INVOICE BATCH STATUS    vers 3.2"
! Print @0,2;" STATUS"; Tab 21;"FROM -  TO"; Tab 50;"TOTAL";
! Print @0,3;'BR'; Tab 80;'ER';@0,4;
! S4 = 0 \ S1 = 0
! A$ = " " \ F9[1] = 0;F9[2] = 0;F9[5] = 0
! MAIN_LOOP: Rem
! 	Search #2,3,1;A$,R1,E \ If E > 2 Gosub L_9580
! 	If E Goto L_2000
! 	S2 = A$[1,2]
! 	If S1 <> S2 Gosub STATUS_BREAK
! 	N2 = A$[3]
! 	S3 = S3 + 1
! 	S4 = S4 + 1
! 	F9[3] = 0 \ If Err 0 Let F9[3] = Spc(8)
! 	Mat Read #2,R1,0,10;H0;
! 	If Err 0 Gosub L_9600
! 	If H0[0] <> S2 Let F9[1] = F9[1] + 1
! 	If H0[7] <> N2 Let F9[2] = F9[2] + 1
! Goto MAIN_LOOP
! 
! STATUS_BREAK: Rem -------------------------------------------
! 	If S1
! 		Print Using "##";S1;
! 		If S1 < 9 Print "  ";S1$[S1 * 10 - 9,S1 * 10];
! 		If S1 >= 9 If S1 < 14 Print "  CM ";S1$[(S1 - 8) * 10 - 9,(S1 - 8) * 10];
! 		If S1 >= 15 If S1 < 20 Print "  ";S1$[(S1 - 10) * 10 - 9,(S1 - 10) * 10];
! 		If S1 >= 20 If S1 < 25 Print "  ";"DELETED";
! 		If S1 = 90 Print "  IN PROCESS";
! 		If S1 = 91 Print "  IN EDIT";
! 		If S1 = 92 Print "  IN JOURNAL";
! 		If S1 = 93 Print "  IN CM JOURNAL";
! 		If S1 = 95 Print "  ORD PROC ERP";
! 		If S1 = 96 Print "  INV PROC ERP"
! 		If S1 = 97 Print "  CM PROC ERP"
! 		If S1 = 44 Print "  MEMO ENTERED";
! 		If S1 = 45 Print "  MEMO PRINTED";
! 		If S1 = 59 Print "  POS ON HOLD ";
! 		If S1 = 58 Print "  POS BEING PKT ";
! 		Print Using "###### ###### ###,###"; Tab 19;N1;"- ";N2; Tab 48;S3
! 	End If
! 	S3 = 0
! 	If S1 >= 90 Let F9[5] = 9
! 	S1 = S2
! 	N1 = A$[3]
! Return
! 
! L_2000: Rem NO MORE
! Gosub STATUS_BREAK
! Print Using "###,###";'CR'; Tab 38;"TOTAL:    ";S4
! Print 'BR'; Tab 80;'ER';
! If F9[1] Print @20,21;'BB';"WARNING!";F9[1];"STATUS ERROR(S) DETECTED!";'EB';
! If F9[2] Print @20,22;'BB';"WARNING!";F9[2];"KEY/DATA ERROR(S) DETECTED!";'EB';
! 
! OPT_QUEST: Rem==================================================
! If Not(SCAN_STATUS) Print @0,1;'CE'
! Print @0,23;'CL';"ENTER  D:DETAIL  S:SEARCH  RESET  OR <CR>:EXIT  ";
! Input ""S$
! If S$ = "" Goto L_9000
! If S$ = "D"
! 	Gosub DISP_DETAIL
! 	If SCAN_STATUS
! 		Goto MAIN
! 	Else
! 		Goto OPT_QUEST
! 	End If
! End If
! If S$ = "S"
! 	Gosub SOSRCH
! 	If SCAN_STATUS
! 		Goto MAIN
! 	Else
! 		Goto OPT_QUEST
! 	End If
! End If
! If Not(SCAN_STATUS)
! 	If S$ = "CHECK" Or S$ = "RESET" Or S$ = "ADJUST" Or S$ = "RESETALL"
! 		Print 'RB';@0,23;'CL';"YOU HAVE TO SCAN ORDER FIRST !!!!" \ Signal 3,20
! 		Goto PRE_MAIN
! 	End If
! End If
! If Not(SUPERUSER)
! 	If S$ = "RESET" Gosub RESET_STATUS \ Goto L_6500
! 	Print 'RB'; \ Goto OPT_QUEST
! End If
! If S$ = "CHECK" Goto DO_CHECK
! If S$ = "RESETALL" Or S$ = "RESET" Gosub RESET_STATUS \ Goto L_6500
! If S$ <> "ADJUST" Print 'RB'; \ Goto OPT_QUEST
! S1 = 0
! S2 = 0
! N1 = 0
! N2 = 999999
! Gosub ADJUST_BACKGROUND
! Goto FRMSTAT_QUEST
! 
! L_2190: Gosub ADJUST_BACKGROUND
! L_2200: Print @0,23;"O.K. TO CHANGE STATUS?  (YES/<CR>) ";'CL';
! Input ""S$
! If S$ = "" Or S$ = "E" Goto MAIN
! Gosub CHECK_VALIDSTAT \ Goto L_2235
! If S$ = "YES" Goto L_6000
! L_2230: Gosub ADJUST_BACKGROUND
! L_2235: Print @0,23;"ENTER ITEM TO CHANGE, <CR> TO ABORT,  E: TO END ";'CL';
! Input ""S$
! If S$ = "E" Goto L_2190
! K = S$
! If Not(K) Goto MAIN
! If K > 0 If K < 5
! 	On K Goto FRMSTAT_QUEST,TOSTAT_QUEST,FRMORD_QUEST,TOORD_QUEST
! End If
! Goto L_2230
! Stop 
! 
! FRMSTAT_QUEST: Rem
! 	J0$ = "1000 21521"
! 	J2$ = "##"
! 	J1$ = S1 Using J2$
! 	Gosub L_7000
! 	S1 = J$
! 	If J4$ = "E" Goto MAIN
! 	If S1 >= 90 Goto L_3030
! 	If S1 > 40 If S1 < 47 Goto L_3030
! 	If S1 > 0 If S1 < 19 If S1 <> S2 Goto L_3030
! 	Goto FRMSTAT_QUEST
! L_3030: If K = 1 Goto L_2230
! 
! TOSTAT_QUEST: Rem
! 	J0$ = "1000 21522"
! 	J2$ = "##"
! 	J1$ = S2 Using J2$
! 	Gosub L_7000
! 	S2 = J$
! 	If J4$ = "E" Goto MAIN
! 	If S2 > 43 If S2 < 46 If S1 <> S2 Goto L_3065
! 	If S2 > 0 If S2 < 19 If S1 <> S2 Goto L_3065
! 	If S2 > 57 If S2 < 60 If S1 <> S2 Goto L_3065
! 	Goto TOSTAT_QUEST
! L_3065: If K = 2 Goto L_2230
! 
! Gosub ADJUST_BACKGROUND
! 
! FRMORD_QUEST: Rem
! 	J0$ = "1000 64821"
! 	J2$ = "######"
! 	J1$ = N1 Using J2$
! 	Gosub L_7000
! 	N1 = J$
! 	If J4$ = "E" Goto MAIN
! If K = 3 Goto L_2230
! 
! TOORD_QUEST: Rem
! 	J0$ = "1000 64822"
! 	J2$ = "######"
! 	J1$ = N2 Using J2$
! 	Gosub L_7000
! 	N2 = J$
! 	If J4$ = "E" Goto MAIN
! If K = 4 Goto L_2230
! Goto L_2200
! 
! CHECK_VALIDSTAT: Rem CHECK VALID STATUSES
! 	If S1 >= 90 Return 1
! 	If S1 < 9 If S2 < 10 Return 1
! 	If S1 > 8 If S1 < 15 If S2 < 15 Return 1
! 	If S1 > 14 If S2 > 14 Return 1
! 	Print @0,23;"CANNOT CHANGE BETWEEN ORDER/INVOICE & CREDIT STATUS! ";'CL RB';
! Signal 3,30 \ Print @0,23;'CL'; \ Return
! 
! ETRACK_INIT: Rem ---------------------------------------------------
! 	ETPRINT = 0
! 	ETORDER = H0[7]
! 	ETLINE = 0
! 	ETSTAT = H0[0]
! 	ETPROD$ = "STATUS CHG"
! 	ETOQTY[0] = 0
! 	ETOQTY[1] = 0
! 	ETOQTY[2] = 0
! 	ETDATE = Tim(6)
! 	ETTIME = Tim(11) * 10000 + Tim(12) * 100 + Tim(13)
! 	ETPORT = Spc(6)
! 	ETUNIT = 0
! 	ETNONSTOCK = 0
! 	ETINVOICE = OREF[1]
! 	ETORIGTOT = 0
! 	ETCUST = H0[4]
! 	ETSLS = H0[11]
! 	ETUNITPRICE[0] = 0
! 	ETUNITPRICE[1] = 0
! 	ETPUNIT = 0
! 	ETWGT[0] = 0
! 	ETWGT[1] = 0
! Return
! 
! ETRACK_COMPLETE: Rem ----------------------------------------------
! 	ET$ = " ",ET$
! 	ET$ = ETORDER Using "######"
! 	ET$[7] = ETLINE Using "######"
! 	ET$[13] = ETDATE Using "########"
! 	ET$[21] = ETTIME Using "######"
! 	E = 2 \ Search #CH_ET,1,0;ET$,REC_ET,E \ If E Gosub L_9580
! 	Search #CH_ET,4,1;ET$,REC_ET,E \ If E Gosub L_9580
! 	SCRATCH$ = " ",SCRATCH$
! 	SCRATCH$[1,10] = ETUSER$ + BLANK$
! 	SCRATCH$[11,36] = ET$
! 	Search #CH_ET,4,2;SCRATCH$,REC_ET,E \ If E Gosub L_9580
! 	ET$ = ETDATE Using "########"
! 	ET$[9] = ETTIME Using "######"
! 	ET$[15] = ETORDER Using "######"
! 	ET$[21] = ETLINE Using "######"
! 	Search #CH_ET,4,3;ET$,REC_ET,E \ If E Gosub L_9580
! 	SCRATCH$ = " ",SCRATCH$
! 	SCRATCH$[1,3] = ETSLS Using "###"
! 	SCRATCH$[4,29] = ET$
! 	SCRATCH$[30,30] = " "
! 	Search #CH_ET,4,4;SCRATCH$,REC_ET,E \ If E Gosub L_9580
! 	Rem {begin src/inc/write.edittrack.i}
! 	Mat Write #CH_ET,REC_ET,0;ETORDER
! 	Mat Write #CH_ET,REC_ET,4;ETLINE
! 	Mat Write #CH_ET,REC_ET,6;ETSTAT
! 	Mat Write #CH_ET,REC_ET,8;ETPROD$
! 	Mat Write #CH_ET,REC_ET,20;ETOQTY
! 	Mat Write #CH_ET,REC_ET,38;ETNQTY
! 	Mat Write #CH_ET,REC_ET,56;ETDATE
! 	Mat Write #CH_ET,REC_ET,60;ETTIME
! 	Mat Write #CH_ET,REC_ET,64;ETPORT
! 	Mat Write #CH_ET,REC_ET,68;ETUSER$
! 	Mat Write #CH_ET,REC_ET,78;ETACTION
! 	Mat Write #CH_ET,REC_ET,82;ETUNIT
! 	Mat Write #CH_ET,REC_ET,84;ETNONSTOCK
! 	Mat Write #CH_ET,REC_ET,90;ETORIGTOT
! 	Mat Write #CH_ET,REC_ET,96;ETCUST
! 	Mat Write #CH_ET,REC_ET,100;ETPRINT
! 	Mat Write #CH_ET,REC_ET,102;ETINVOICE
! 	Mat Write #CH_ET,REC_ET,108;ETSLS
! 	Mat Write #CH_ET,REC_ET,112;ETUNITPRICE
! 	Mat Write #CH_ET,REC_ET,124;ETPUNIT
! 	Mat Write #CH_ET,REC_ET,128;ETLOADCOST
! 	Mat Write #CH_ET,REC_ET,140;ETWGT;
! 	Rem {end write.edittrack.i}
! Return
! 
! RESET_STATUS: Rem====================================to previous status
! A$ = " ",A$
! If S$ = "RESET"
! 	Print @0,23;'CL';
! 	Print @0,22;'CL';"RESET FROM STATUS (90/91/E): ";
! 	Input ""A$
! 	If A$ <> "90" And A$ <> "91" And A$ <> "E" Print 'RB'; \ Goto RESET_STATUS
! 	If A$ = "E" Return
! 	STAT = A$[1,2]
! 	Print @0,23;'CL';"ENTER ORDER NUMBER TO RESET: ";
! 	Input ""RSTORDER$
! 	If RSTORDER$ = "" Or RSTORDER$ = "      " Return
! 	T0 = 0;RSTORDER = RSTORDER$[1,6]
! 	A$ = " ",A$;A$[1,2] = STAT Using "##"
! 	A$[3] = RSTORDER Using "######"
! 	Search #CH_ROH,2,1;A$,R1,E
! 	If E
! 		Print @0,22;'CL';'BD BR';"ORDER ";A$[3,8];" IS NOT IN STATUS [";STAT;"]";'ER EB'
! 		Return
! 	End If
! 	If Not(E) Let A1$ = " ",A1$ \ A1$ = A$ \ Goto L_3650
! End If
! Print @0,23;'CL';"RESET FROM STATUS (90/91/92/93/E): ";
! Input ""A$
! If A$ <> "90" And A$ <> "91" And A$ <> "92" And A$ <> "93" And A$ <> "E"
! 	Print 'RB'; \ Goto RESET_STATUS
! End If
! If A$ = "E" Return 
! T0 = 0;FRMSTAT$ = A$;A$ = " ",A$;A$[1,2] = FRMSTAT$
! 
! L_3620: Search #CH_ROH,3,1;A$,R1,E \ If E > 2 Gosub L_9580
! 	If E Or A$[1,2] <> FRMSTAT$ Return
! 	A1$ = A$
! 	L_3650: Gosub L_3800 \ Goto L_3750
! 	Mat Read #CH_ROH,R1,64;LOCKPORT;
! 	Ropen #CH_USERPORT,"cntrl/userport"
! 	Read #CH_USERPORT,Spc(6),0;REC1;
! 	Read #CH_USERPORT,LOCKPORT,2;P2;
! 	Close #CH_USERPORT
! 	L_3660: Rem check original status
! 	Mat Read #CH_ROH,R1,104;H5;
! 	Mat Read #CH_ROH,R1,78;H4;
! 	Read #CH_ROH,R1,416;S2;
! 	Mat Read #CH_ROH,R1,512;OREF;
! 	ORDERSTATUS = S2
! 	If S2 <> 58 And S2 <> 59
! 		If S2 <= 0 Or S2 >= 11 Or S2 = 7
! 			Print @0,22;"NOT ABLE TO RESET ORDER [";H0[7];"]" \ Return
! 		End If
! 	End If
! 	If S2 = 8 Or Fra(S2) <> 0 !CK JUST TO BE SURE
! 		Print @0,22;"NOT ABLE TO RESET ORDER [";H0[7];"]" \ Return
! 	End If
! 	If (STAT = 90 And S2 = 1 And P2 = 201) Or (STAT = 90 And S2 = 5 And (P2 = 231 Or P2 = 251))
! 		Gosub L_3799 \ Return
! 	End If
! 	If (STAT = 91 And S2 <= 4 And (P2 = 208 Or P2 = 221)) Or (STAT = 91 And S2 > 4 And S2 < 9 And P2 = 223)
! 		Gosub L_3799 \ Return
! 	End If
! 	If (STAT = 90 And P2 = 241 And (S2 = 9 Or S2 = 10))
! 		Gosub L_3799 \ Return
! 	End If
! 	If (STAT = 91 And P2 = 243 And (S2 = 9 Or S2 = 10))
! 		Gosub L_3799 \ Return
! 	End If
! 	Gosub CHECK_PROBLEM
! 	A1$[1,2] = S2 Using "##"
! 	If P60$[44,44] = "Y" And S$ = "RESET" !order audit flag
! 		Gosub ETRACK_INIT
! 		ETACTION = H0[0] + (S2 / 100)
! 		Gosub ETRACK_COMPLETE
! 	End If
! 	If S$ = "RESET" Gosub L_6800
! 	Write #CH_ROH,R1,0;S2;
! 	S2 = 0 \ Write #CH_ROH,R1,416;S2;
! 	Search #CH_ROH,4,1;A1$,R1,E \ If E > 1 Gosub L_9580
! 	Search #CH_ROH,5,1;A$,R1,E \ If E Gosub L_9580
! 	T0 = T0 + 1
! 	If Fra(DELETELINEFLAG) <> 0
! 		Print 'CR CL';"IT IS HIGHLY RECOMENDED TO RUN A 775 ON ALL PRODUCTS(INCLUDING"
! 		Print 'CL';"LINES THAT WERE TOTALLY DELETED) WITH PROBLEMS ON THIS ORDER, TO"
! 		Print 'CL';"CORRECT SOME PROBLEMS CAUSED BY THE PROGRAM DELETING PARTLY ENTERED LINES."
! 	End If
! 	If DELETELINEFLAG <> 0
! 		Print 'CL';
! 		Input "PRESS <CR> TO CONTINUE "X$
! 	End If
! 	Rem THE GOSUB TO FORCE AN EDIT ALL CHAIN TO MX208A, ETC
! 	Gosub EDITCHAIN
! 	L_3750: If Not(SUPERUSER) Return
! 	If S$ = "RESET" Return
! Goto L_3620
! 
! L_3799: Rem===================================================================
! 	Rem SAYS LOCKED BY A PORT. SEE IF IT IS REALLY ON(UNIBASIC ONLY)-WMB 8/2002
! 	Call MiscStr(1,DIR$,DEVICE$,TERM$,FILENAMES$)
! 	Call Monitor(LOCKPORT,INFO[],DIR$,DEVICE$,TERM$,CHAN[],FILENAMES$,STATUS)
! 	If STATUS = 0 Goto L_3799A
! 	Print @0,16;'CE';
! 	Print @0,17;'CE';"THE SYSTEM THINKS PORT ";LOCKPORT;" IS LOCKING ORDER ";H0[7];
! 	Print " IN PROGRAM ";P2;"."
! 	Print @0,18;'CL';"DO YOU WANT THE SYSTEM TO TRY TO DETERMINE IF THE PORT IS"
! 	Print @0,19;'CL';"ACTUALLY SIGNED ON? IF IT IS NOT ON, THE PROGRAM WILL RESET"
! 	Print @0,20;'CL';"THE ORDER.  NOTE: IT CAN TAKE UP TO 30 SECONDS FOR THE SYSTEM"
! 	Print @0,21;'CL';"TO DETERMINE IF THE PORT IS ON"
! 	Print @0,22;'CL';"DO YOU WANT THE STATUS OF THE PORT CHECKED?(Y/N) :";
! 	Input ""X$
! 	If X$ <> "Y" If X$ <> "YES" If X$ <> "N" Print 'RB CL';"INVALID!!" \ Signal 3,20 \ Goto L_3799
! 	If X$ = "N" Goto L_3799A
! 	Rem REM CHECK IF PORT IS ON.
! 	Print @0,22;'CL';"CHECKING, PLEASE WAIT ....";
! 	STATUS = 0
! 	STATUSOFF = 0
! 	STATUSCOUNT = 0
! 	CHECK_PORTON: Rem CHECK IF PORT IS ON- LOOP THRU & CK FOR 20 SECONDS-WMB
! 	Call MiscStr(1,DIR$,DEVICE$,TERM$,FILENAMES$)
! 	Call Monitor(LOCKPORT,INFO[],DIR$,DEVICE$,TERM$,CHAN[],FILENAMES$,STATUS)
! 	If STATUS = 0 Goto CHECK_FAIL
! 	If STATUS = 1 Let STATUSOFF = STATUSOFF + 1
! 	If STATUSOFF >= 5 Goto CHECK_PORTON_PASS
! 	STATUSCOUNT = STATUSCOUNT + 1
! 	If STATUSCOUNT >= 10 Goto CHECK_FAIL
! 	If STATUSCOUNT - STATUSOFF > 5 Goto CHECK_FAIL
! 	Signal 3,20
! 	Print ".";
! 	Goto CHECK_PORTON
! 	CHECK_FAIL: Print @0,21;'CE';" THE PORT IS ON";
! 	If STATUS <> 0 Print " OR UNABLE TO DETERMINE";
! 	Print ". NOT RESETTING ORDER."
! 	Signal 3,25
! 	L_3799A: Print @0,22;'BD BR';"ORDER ";H0[7];" IS LOCKED BY PORT <";LOCKPORT;"> IN ";P2;'ER EB'
! 	Return
! 	CHECK_PORTON_PASS: Rem PORT IS NOT ON- RESET IT
! 	Print @0,21;'CE';"THE PORT IS OFF, RESETTING ORDER # ";H0[7]
! 	Signal 3,10
! Return 1
! 
! L_3800: Rem CHECK FOR VALID INFO IN STS 90 ORDERS
! 	F9[6] = 0
! 	F9[7] = 0
! 	If Err 0 Let F9[7] = Spc(8)
! 	Mat Read #CH_ROH,R1,0,10;H0;
! 	Mat Read #CH_ROH,R1,512;OREF;
! 	If Err 0 Gosub L_9500
! 	If F9[7] <> 0 If F9[7] <> 123 Gosub L_9500
! 	If F9[7] = 123
! 		Print @0,22;'CE';
! 		Call WhoLock(CH_ROH,R1,PORTLOCK)
! 		If PORTLOCK <> -1 If PORTLOCK <> 0 Print @0,22;'CL BR';"PORT ";PORTLOCK;" IS";
! 		Print " LOCKING ORDER # ";H0[7];"-RESET IS NOT PERMITTED"
! 		Signal 3,15
! 		Return
! 	End If
! 	If H0[2] < 0 Or H0[3] < 0 Let F9[6] = 1 \ Goto L_3900
! 	If H0[2] >= Chf(9) Let F9[6] = 1 \ Goto L_3900
! 	If H0[3] >= Chf(10) Let F9[6] = 1 \ Goto L_3900
! 	E = 0
! 	Search #9,1,0;K11$,R11,E
! 	If E > 0 Gosub L_9580
! 	If H0[2] = 0 If R11 <> 0 Let F9[6] = 1 \ Goto L_3900
! 	E = 0
! 	Search #10,1,0;K11$,R11,E
! 	If E > 0 Gosub L_9580
! 	If H0[3] = 0 If R11 <> 0 Let F9[6] = 1 \ Goto L_3900
! 	If H0[7] <= 0 Or H0[4] <= 0 Or H0[11] <= 0 Let F9[6] = 2 \ Goto L_3900
! 	K11$ = " ",K11$
! 	K11$[1,6] = H0[7] Using "######"
! 	If K11$[1,6] <> A$[3,8] Let F9[6] = 3 \ Goto L_3900
! 	Mat Read #9,H0[2],0;SHIPTOTORD;
! 	If SHIPTOTORD[1] <> H0[7] Goto L_3950
! 	Mat Read #10,H0[3],0;SHIPTOTORD;
! 	If SHIPTOTORD[1] <> H0[7] Goto L_3950
! 	K2$ = " ",K2$;K2$[1,6] = H0[4] Using "######";K2$[7] = H0[7] Using "######"
! 	K3$ = " ",K3$;K3$[1,3] = H0[11] Using "###";K3$[4,9] = H0[7] Using "######"
! 	Search #CH_ROH,2,2;K2$,R2,E \ If E > 1 Gosub L_9580
! 	If E = 1
! 		Search #CH_ROH,4,2;K2$,R1,E \ If E Gosub L_9580
! 	End If
! 	Search #CH_ROH,2,3;K3$,R2,E \ If E > 1 Gosub L_9580
! 	If E = 1
! 		Search #CH_ROH,4,3;K3$,R1,E \ If E Gosub L_9580
! 	End If
! Return 1
! 
! L_3900: Rem ORDER INVALID
! 	K11$ = " ",K11$
! 	K11$[1,6] = A1$[3,8]
! 	K11$[7] = ""
! 	Search #11,2,1;K11$,R11,E
! 	If E > 1 Gosub L_9580
! 	If E = 0
! 		Print @0,19;'CE';"ORDER ";H0[7];" DAMAGED- POSSIBLE USEFUL DATA- NOT DELETEING."
! 		Print @0,20;'CL';"THIS ORDER HAS INTERNAL PROBLEMS. THE ORDER IS NOT RECOVERABLE."
! 		If F9[6] = 1 Print @0,21;'CL';"(NOTE: ORDER HAS INVALID SHIP-TO/TOTAL RECORD NUMBERS)";
! 		If F9[6] = 2 Print @0,21;'CL';"(NOTE: ORDER HAS INVALID CUSTOMER/ORDER/SALESMAN NUMBER IN DATA)"
! 		If F9[6] = 3 Print @0,21;'CL';"(NOTE: ORDER HAS GARBAGE DATA WHERE THE KEYS ARE <> THE DATA)"
! 		Print @0,22;'CL';"PLEASE CONTACT UNIVERSAL TO CHECK OUT THE ORDER ";
! 		Input ""X$
! 		Return
! 	End If
! 	H0[7] = A1$[3];H0 = 20
! 	Print @0,22;'CE';"ORDER ";H0[7];" UNSALVAGABLE, DELETING" \ Signal 3,0
! 	K2$ = A1$;K2$[1,2] = H0 Using "##"
! 	Mat Read #CH_ROH,R1,104;H5;
! 	Mat Read #CH_ROH,R1,78;H4;
! 	H4 = 229
! 	H4[1] = Spc(6)
! 	Ropen #CH_USERPORT,"cntrl/userport"
! 	Read #CH_USERPORT,Spc(6),0;REC1;
! 	Close #CH_USERPORT
! 	H5[1] = REC1
! 	DL1$ = " ",DL1$
! 	DL1$ = "DEL ORDER-BAD DATA  "
! 	Mat Write #CH_ROH,R1,0;H0;
! 	Mat Write #CH_ROH,R1,78;H4;
! 	Mat Write #CH_ROH,R1,84;DL1$;
! 	Mat Write #CH_ROH,R1,104;H5;
! 	Search #CH_ROH,5,1;A1$,R1,E \ If E Gosub L_9580
! 	Search #CH_ROH,4,1;K2$,R1,E \ If E Gosub L_9580
! 	Rem SCAN 1ST DIR FOR ANY OTHER RELATED PROBLEMS- DON'T DELETE KEY JUST INSERTED
! 	K3$ = " ",K3$
! 	L_3915: Search #CH_ROH,3,1;K3$,R2,E \ If E <> 0 If E <> 2 Gosub L_9580
! 	If E = 2 Goto L_3917
! 	If R2 <> R1 Goto L_3915
! 	If K2$[1,8] = K2$[1,8] Goto L_3915
! 	If K3$[3,8] <> A1$[3,8] Goto L_3915
! 	Search #CH_ROH,5,1;K3$,R2,E \ If E Gosub L_9580
! 	Goto L_3915
! 	L_3917: Rem ALL DONE WITH CK 1ST DIR FOR PROBLEMS
! 	K2$ = " ",K2$;K2$[1,6] = H0[4] Using "######";K2$[7] = H0[7] Using "######"
! 	K3$ = " ",K3$;K3$[1,3] = H0[11] Using "###";K3$[4,9] = H0[7] Using "######"
! 	Search #CH_ROH,2,2;K2$,R2,E \ If E > 1 Gosub L_9580
! 	If Not(E) And R1 = R2
! 		Search #CH_ROH,5,2;K2$,R2,E \ If E > 1 Gosub L_9580
! 		If E Gosub L_9580
! 	Else
! 		K2$ = " ",K2$
! 		L_3921: Search #CH_ROH,3,2;K2$,R2,E \ If E <> 0 If E <> 2 Gosub L_9580
! 		If E = 2 Goto L_3923
! 		If R2 <> R1 Goto L_3921
! 		If K2$[7,12] <> A1$[3,8] Goto L_3921
! 		Search #CH_ROH,5,2;K2$,R2,E \ If E Gosub L_9580
! 	L_3923: End If
! 	K3$[10] = ""
! 	Search #CH_ROH,2,3;K3$,R2,E \ If E > 1 Gosub L_9580
! 	If Not(E) And R1 = R2
! 		Search #CH_ROH,5,3;K3$,R2,E \ If E > 1 Gosub L_9580
! 		If E Gosub L_9580
! 	Else
! 		K3$ = " ",K3$
! 		L_3925: Search #CH_ROH,3,3;K3$,R2,E \ If E <> 0 If E <> 2 Gosub L_9580
! 		If E = 2 Goto L_3927
! 		If R2 <> R1 Goto L_3925
! 		If K3$[4,9] <> A1$[3,8] Goto L_3925
! 		Search #CH_ROH,5,3;K3$,R2,E \ If E Gosub L_9580
! 	L_3927: End If
! 	If P60$[44,44] = "Y" !order audit flag
! 		Gosub ETRACK_INIT
! 		ETACTION = 0
! 		ETPROD$ = "DEL OR-BAD D"
! 		Gosub ETRACK_COMPLETE
! 	End If
! 	Gosub L_6800
! Return
! 
! L_3950: Rem ORDER CROSSCHECK PROBLEMS- SORDFLES OR SORDFLET REC # DUPS??
! 	Print @0,17;'CE';
! 	Print @0,18;'CL';"POSSIBLE POINTER PROBLEMS HAVE BEEN DETECTED WITH ORDER # ";H0[7];". "
! 	Print @0,19;'CL';"DO NOT TRY TO ACCEPT OR DELETE THIS ORDER.  INSTEAD, PLEASE"
! 	Print @0,20;'CL';"CONTACT UNIVERSAL WITH THIS MESSAGE AND THE ORDER NUMBER WITH"
! 	Print @0,21;'CL';"THE PROBLEM.  THERE MAY BE INTERNAL PROBLEMS WITH THE ORDER."
! 	Print @0,22;'CL';"PRESS <CR> TO CONTINUE. ";
! 	Input ""X$
! Return
! 
! ADJUST_BACKGROUND: Rem
! 	Print @0,21;" 1.FROM STATUS:";
! 	If Not(S1) Goto L_4010
! 	If S1 < 9 Print @20,21;S1$[S1 * 10 - 9,S1 * 10];
! 	If S1 >= 9 If S1 < 14 Print @20,21;S1$[(S1 - 8) * 10 - 9,(S1 - 8) * 10];
! 	If S1 >= 15 If S1 < 20 Print @20,21;S1$[(S1 - 10) * 10 - 9,(S1 - 10) * 10];
! 	L_4010: Print @0,22;" 2.  TO STATUS:";
! 	If Not(S2) Goto L_4020
! 	If S2 < 9 Print @20,22;S1$[S2 * 10 - 9,S2 * 10];
! 	If S2 >= 9 If S2 < 14 Print @20,22;S1$[(S2 - 8) * 10 - 9,(S2 - 8) * 10];
! 	If S2 >= 15 If S2 < 20 Print @20,22;S1$[(S2 - 10) * 10 - 9,(S2 - 10) * 10];
! 	L_4020: Print @38,21;" 3.ORDERS:";
! 	Print @38,22;" 4.  THRU:";
! 	Print @0,23;'CL';
! 	Print Using "##";@15,21;S1;
! 	Print Using "##";@15,22;S2;
! 	Print Using "######";@48,21;N1;
! 	Print Using "######";@48,22;N2;
! Return
! 
! DO_CHECK: Rem CHECK FILE
! Print 'CS';@0,3;" ORDER     RECORD#  DATA  KEY(s) ";'CR'
! A$ = ""
! CHECK_LOOP: Rem
! Search #2,3,1;A$,R1,E \ If E > 2 Gosub L_9580
! If Not(E)
! 	Mat Read #2,R1;H0;
! 	S2 = A$[1,2] \ N2 = A$[3]
! 	If S2 = H0[0] And N2 = H0[7] Goto CHECK_LOOP
! 	Gosub CHECK_OTHER_STATUS
! 	Print Using "###### ";H0[7];
! 	Print Using "########### ";R1;
! 	Print Using "  ## ";H0;
! 	Print Tab (26);A$[1,2];" ";A$[3];
! 	If PASS
! 		Print
! 		Print Tab (26);OS$[1,2];" ";OS$[3];
! 	End If
! 	If N2 <> H0[7] Print \ Goto CHECK_LOOP
! 	If PASS
! 		STAT_QUEST: Rem
! 		Print Tab (37);"Enter Correct Status <no change> ";
! 		Input ""S$
! 		If S$ = "" Print \ Goto CHECK_LOOP
! 		SCR = OS$[1,2]
! 		STATMAKE = S$
! 		If STATMAKE <> SCR And STATMAKE <> S2
! 			Print
! 			Print 'CL RB';"You must enter either ";Str$(SCR);" or ";Str$(S2);
! 			Goto STAT_QUEST
! 		End If
! 		If STATMAKE = SCR
! 			STATKILL = S2
! 		Else
! 			STATKILL = SCR
! 		End If
! 		H0[0] = STATMAKE
! 		Write #CH_ROH,R1;H0[0];
! 		OS$[1,2] = STATKILL Using "##"
! 		Search #CH_ROH,5,1;OS$,REC_OS,E \ If E Gosub L_9580
! 		Print "  CHANGED";
! 	Else
! 		Input " CHANGE DATA (Y/<CR>) "S$
! 		If S$ = "Y"
! 			H0[0] = S2
! 			Write #CH_ROH,R1;H0[0];
! 			Print "  CHANGED";
! 		End If
! 	End If
! 	Print
! 	Goto CHECK_LOOP
! End If
! Input @0,23;"PRESS <CR> TO CONTINUE "A$
! Goto MAIN
! 
! CHECK_OTHER_STATUS: Rem
! 	PASS = 0
! 	OS$ = " ",OS$
! 	OS$ = H0 Using "##"
! 	OS$[3] = A$[3]
! 	Search #2,2,1;OS$,REC_OS,E \ If E > 2 Gosub L_9580
! 	SCR = OS$[1,2]
! 	If Not(E) And SCR = H0 And OS$[3] = A$[3]
! 		PASS = 1
! 	End If
! Return
! 
! L_6000: Rem UPDATE STATUS
! 	Print @0,23;'CL';"CHANGING STATUS... PLEASE WAIT . . . ";
! 	T0 = 0
! 	A$ = S1 Using "##"
! 	L_6040: Search #CH_ROH,3,1;A$,R1,E
! 	If E = 2 Goto L_6500
! 	E9 = Spc(9)
! 	If E Goto L_9580
! 	X1 = A$[1,2]
! 	If X1 <> S1 Goto L_6500
! 	X2 = A$[3]
! 	If X2 >= N1 If X2 <= N2 Goto L_6130
! 	Goto L_6040
! 	L_6130: A1$ = A$
! 	A1$[1,2] = S2 Using "##"
! 	F9 = 0
! 	Write #CH_ROH,R1;S2;
! 	L_6150: Search #CH_ROH,4,1;A1$,R1,E
! 	If Not(E) Goto L_6300
! 	E9 = Spc(9)
! 	If E If E <> 2 If F9 Goto L_9580
! 	F9 = 99
! 	Search #CH_ROH,7,1;S$,R2,E
! 	E9 = Spc(9)
! 	If E Goto L_9580
! 	Goto L_6150
! 	L_6300: Search #CH_ROH,5,1;A$,R2,E
! 	If R2 <> R1 Stop
! 	E9 = Spc(9)
! 	If E Goto L_9580
! 	T0 = T0 + 1
! 	Goto L_6040
! 	L_6500: Rem DONE!
! 	Print @0,23;'CL';"COMPLETE...";T0;"ORDER(S) RESET.  PRESS <CR> TO CONTINUE ";
! 	Input ""S$
! 	Close #2
! 	Ropen #2,FILE$
! Goto MAIN
! 
! L_6800: Rem "=========================== log activity into audit file
! 	LOCKTIME = 100;P2 = 229;C1 = 1;C2 = (Int((Spc(5) - Int(Spc(5) / 16384) * 16384) / 64))
! 	If Err 0 Gosub L_9500
! 	Open #CH_AUD,"CNTRL.AUD"
! 	If Chf(CH_AUD) > 2 ^ 16 - 10 Goto L_6850
! 	Write #CH_AUD,Chf(CH_AUD),0,LOCKTIME;P2,Spc(6),C1,REC1,(Spc(2) * 36000 + Spc(3)) / 600,C2;
! L_6830: Close #CH_AUD \ Return
! L_6850: Print @0,22;'BB RB';" AUDIT LOG FILE FULL! ";'EB'; \ Signal 3,30
! Print @0,22;'CL'; \ Goto L_6830
! 
! CHECK_PROBLEM: Rem CHECK & CORRECT BAD DATA- HEADER, LINES, ETC-WMB 8/2002
! 	DELETELINEFLAG = 0
! 	Rem FIRST GO THRU SORDFLEL FILE
! 	K11$ = " ",K11$
! 	K11$[1,6] = A1$[3,8]
! 	K11$[7] = ""
! 	CHECK_P1: Search #11,3,1;K11$,R11,E
! 	If E = 2 Goto CHECK_P2
! 	If E Gosub L_9580
! 	If K11$[1,6] <> A1$[3,8] Goto CHECK_P2
! 	Mat Read #11,R11,0;L2;
! 	Mat Read #11,R11,8;L3;
! 	Mat Read #11,R11,16;L4;
! 	Mat Read #11,R11,256;SS2;
! 	K2$ = " ",K2$
! 	K2$[1,6] = L2[1] Using "######"
! 	K2$[7,9] = L3[2] Using "###"
! 	If L3[2] = 0 And K2$[1,6] = K11$[1,6] And (K11$[10,10] = "A" Or K11$[10,10] = "B" Or K11$[10,10] = "C") Goto CHECK_P1
! 	If L3[2] >= 900 And L3[2] <= 999 And K2$[1,9] = K11$[1,9] Goto CHECK_P1
! 	If K2$[1,9] <> K11$[1,9] !BAD KEY
! 		Search #11,5,1;K11$,R2,E
! 		If E <> 0 Gosub L_9580
! 		K3$ = " ",K3$
! 		K3$ = K11$[1,10]
! 		K3$[10] = ""
! 		Search #12,5,1;K3$,R2,E
! 		If E <> 0 If E <> 1 Gosub L_9580
! 		K3$ = " ",K3$
! 		CHECK_P1A: Search #11,3,2;K3$,R2,E
! 			If E <> 0 If E <> 2 Gosub L_9580
! 			If E = 2 Goto CHECK_P1B
! 			If R2 <> R11 Goto CHECK_P1A
! 			If K11$[1,9] <> K3$[7,15] Goto CHECK_P1A
! 			Search #11,5,2;K3$,R2,E
! 			If E <> 0 Gosub L_9580
! 		Goto CHECK_P1A
! 		CHECK_P1B: Rem REM DELETE SORDLOT RECORDS
! 		K1777$ = " ",K1777$
! 		K1777$[1,9] = K11$[1,9]
! 		Gosub CHECKDEL_SORDLOT
! 		If P60$[44,44] = "Y" !order audit flag
! 			Gosub ETRACK_INIT
! 			ETACTION = 4
! 			ETLINE = K11$[7,9]
! 			ETPROD$ = "DEL LN-BAD D"
! 			Gosub ETRACK_COMPLETE
! 		End If
! 		ETLINE = K11$[7,9]
! 		Gosub ITSGONEMESSAGE
! 		DELETELINEFLAG = DELETELINEFLAG + 1
! 		Goto CHECK_P1
! 	End If
! 	If L3[0] = 1 If SS2[0] = 3 Goto CHECK_P1
! 	If L3[0] = 1 !NON-STOCK
! 		K3$ = " ",K3$
! 		K3$ = K11$[1,10]
! 		K3$[10] = ""
! 		Search #12,2,1;K3$,R2,E
! 		If E <> 0 If E <> 1 Gosub L_9580
! 		If E = 1
! 			Search #11,5,1;K11$,R2,E
! 			If E <> 0 Gosub L_9580
! 			If P60$[44,44] = "Y" !order audit flag
! 				Gosub ETRACK_INIT
! 				ETACTION = 4
! 				ETLINE = L3[2]
! 				ETPROD$ = "DEL LN-KEY N"
! 				Gosub ETRACK_COMPLETE
! 			End If
! 			ETLINE = L3[2]
! 			Gosub ITSGONEMESSAGE
! 			DELETELINEFLAG = DELETELINEFLAG + 1
! 			Goto CHECK_P1
! 		End If
! 		Mat Read #12,R2,0;L7;
! 		K2$ = " ",K2$
! 		K2$[1,6] = L7[0] Using "######"
! 		K2$[7,9] = L7[1] Using "###"
! 		If K2$[1,9] <> K3$[1,9] !BAD KEY
! 			Search #12,5,1;K3$,R2,E
! 			If E <> 0 Gosub L_9580
! 			Search #11,5,1;K11$,R2,E
! 			If E <> 0 Gosub L_9580
! 			If P60$[44,44] = "Y" !order audit flag
! 				Gosub ETRACK_INIT
! 				ETLINE = L3[2]
! 				ETACTION = 4
! 				ETPROD$ = "DEL LN-BADND"
! 				Gosub ETRACK_COMPLETE
! 			End If
! 			ETLINE = L3[2]
! 			Gosub ITSGONEMESSAGE
! 			DELETELINEFLAG = DELETELINEFLAG + 1
! 			Goto CHECK_P1
! 		End If
! 		Goto CHECK_P1
! 	End If
! 	Rem STOCK ITEM- CK FOR PROBLEMS.
! 	K2$ = " ",K2$
! 	K2$[1,6] = L4[0] Using "######"
! 	K2$[7,12] = L2[1] Using "######"
! 	K2$[13,15] = L3[2] Using "###"
! 	K2$[16] = ""
! 	Search #11,2,2;K2$,R2,E
! 	If E <> 0 If E <> 1 Gosub L_9580
! 	If E = 0 Goto CHECK_P1
! 	Rem NOT THERE -WE HAVE PROBLEMS. IF OK IN SORDLOT, INSERT, OTHERWISE DEL
! 	K3$ = " ",K3$
! 	K3$[1,6] = L2[1] Using "######"
! 	K3$[7,9] = L3[2] Using "###"
! 	K3$[10] = ""
! 	Rem WE ARE LOOKING FOR 1 LINE IS SORDLOT- DON'T CARE IF MORE THEN 1 EXIST
! 	CHECK_P1C: Search #17,3,3;K3$,R17,E
! 	If E = 2 Goto CHECK_P1H
! 	If E Gosub L_9580
! 	If K3$[1,9] <> K2$[7,15] Goto CHECK_P1H
! 	Mat Read #17,R17,0;S0$;
! 	Mat Read #17,R17,36;OL1;
! 	Mat Read #17,R17,44;OL2;
! 	Mat Read #17,R17,96;OL2$;
! 	K17$ = " ",K17$
! 	K17$[1,6] = OL2[0] Using "######"
! 	K17$[7,9] = OL1[0] Using "###"
! 	K17$[10,11] = OL1[2] Using "##"
! 	K17$[12,17] = OL2$[11,16]
! 	K17$[18,29] = S0$[13,24]
! 	K17$[30,39] = OL2$[1,10]
! 	If K3$[1,39] <> K17$[1,39] Goto CHECK_P1G
! 	Rem NOW CK 1ST & 2ND DIR OF SORDLOT
! 	K17$ = " ",K17$
! 	K17$[1,12] = S0$[1,12]
! 	K17$[13,18] = OL2[0] Using "######"
! 	K17$[19,21] = OL1[0] Using "###"
! 	K17$[22,23] = OL1[2] Using "##"
! 	K17$[24,29] = OL2$[11,16]
! 	K17$[30,41] = S0$[13,24]
! 	K17$[42,51] = OL2$[1,10]
! 	K17$[52] = ""
! 	Search #17,2,1;K17$,R177,E
! 	If E > 1 Gosub L_9580
! 	If E = 1 Goto CHECK_P1G
! 	K17$ = " ",K17$
! 	K17$[1,12] = S0$[13,24]
! 	K17$[13,22] = OL2$[1,10]
! 	K17$[23,28] = OL2[0] Using "######"
! 	K17$[29,31] = OL1[0] Using "###"
! 	K17$[32,33] = OL1[2] Using "##"
! 	K17$[34,39] = OL2$[11,16]
! 	K17$[40,51] = S0$[1,12]
! 	K17$[52] = ""
! 	Search #17,2,2;K17$,R177,E
! 	If E > 1 Gosub L_9580
! 	If E = 0 Goto CHECK_P1J
! 	Rem go thru file & delete 1st & 2nd dir keys that are found
! 	CHECK_P1G: K1777$ = " ",K1777$
! 	K1777$[1,9] = K3$[1,9]
! 	Gosub CHECKDEL_SORDLOT
! 	CHECK_P1H: Search #11,5,1;K11$,R2,E
! 	If E <> 0 Gosub L_9580
! 	If P60$[44,44] = "Y" !order audit flag
! 		Gosub ETRACK_INIT
! 		ETLINE = L3[2]
! 		ETACTION = 4
! 		ETPROD$ = "DEL LN-KEY 2"
! 		Gosub ETRACK_COMPLETE
! 	End If
! 	ETLINE = L3[2]
! 	Gosub ITSGONEMESSAGE
! 	DELETELINEFLAG = DELETELINEFLAG + 1
! 	Goto CHECK_P1
! 	CHECK_P1J: Rem EVERYTHING ELSE IS OK, SO INSERT 2ND DIR INTO SORDFLEL
! 	K2$ = " ",K2$
! 	K2$[1,6] = L4[0] Using "######"
! 	K2$[7,12] = L2[1] Using "######"
! 	K2$[13,15] = L3[2] Using "###"
! 	Search #11,4,2;K2$,R2,E
! 	If E <> 0 Gosub L_9580
! 	Goto CHECK_P1
! 	Rem  ***************************************************
! 	CHECK_P2: Rem! NEXT GO THRU SORDLOT FILE
! 	K11$ = " ",K11$
! 	K11$[1,6] = A1$[3,8]
! 	K11$[7] = ""
! 	CHECK_P3: Search #17,3,3;K11$,R17,E
! 	If E = 2 Goto CHECK_P4
! 	If E Gosub L_9580
! 	If K11$[1,6] <> A1$[3,8] Goto CHECK_P4
! 	Mat Read #17,R17,0;S0$;
! 	Mat Read #17,R17,36;OL1;
! 	Mat Read #17,R17,44;OL2;
! 	Mat Read #17,R17,96;OL2$;
! 	K2$ = " ",K2$
! 	K2$[1,6] = OL2[0] Using "######"
! 	K2$[7,9] = OL1[0] Using "###"
! 	K2$[10,11] = OL1[2] Using "##"
! 	K2$[12,17] = OL2$[11,16]
! 	K2$[18,29] = S0$[13,24]
! 	K2$[30,39] = OL2$[1,10]
! 	If K2$[1,39] <> K11$[1,39] Goto CHECK_P3A
! 	Rem NOW CK 1ST & 2ND DIR OF SORDLOT
! 	K2$ = " ",K2$
! 	K2$[1,12] = S0$[1,12]
! 	K2$[13,18] = OL2[0] Using "######"
! 	K2$[19,21] = OL1[0] Using "###"
! 	K2$[22,23] = OL1[2] Using "##"
! 	K2$[24,29] = OL2$[11,16]
! 	K2$[30,41] = S0$[13,24]
! 	K2$[42,51] = OL2$[1,10]
! 	K2$[52] = ""
! 	Search #17,2,1;K2$,R177,E
! 	If E > 1 Gosub L_9580
! 	If E = 1 Goto CHECK_P3A
! 	K2$ = " ",K2$
! 	K2$[1,12] = S0$[13,24]
! 	K2$[13,22] = OL2$[1,10]
! 	K2$[23,28] = OL2[0] Using "######"
! 	K2$[29,31] = OL1[0] Using "###"
! 	K2$[32,33] = OL1[2] Using "##"
! 	K2$[34,39] = OL2$[11,16]
! 	K2$[40,51] = S0$[1,12]
! 	K2$[52] = ""
! 	Search #17,2,2;K2$,R177,E
! 	If E > 1 Gosub L_9580
! 	If E = 0 Goto CHECK_P3
! 	CHECK_P3A: Rem DELETE ANY TRACES IN SORDLOT
! 	DELETEFLAG = 0
! 	K17$ = K11$
! 	Gosub CHECKDEL_SORDLOT2
! 	DELETELINEFLAG = DELETELINEFLAG + .01
! 	Gosub ITSGONEMESSAGE
! 	Goto CHECK_P3
! 	CHECK_P4: Rem DONE WITH THE CHECKS
! Return
! 
! CHECKDEL_SORDLOT: Rem DELETE ANY KEYS FOUND IN SORDLOT-SCAN 1ST & 2ND DIR
! 	Rem 2 PARTS: AT START, DELETE ALL KEYS FOR THAT ORDER/LINE, IN THE
! 	Rem 2ND OPTION, JUST DELETE KEYS ASSOCIATED WITH THAT ONE KEY IN SORDLOT.
! 	DELETEFLAG = 1
! 	K17$ = " ",K17$
! 	K17$[1,9] = K1777$[1,9]
! 	CHECKDEL_C: Search #17,3,3;K17$,R17,E
! 	If E = 2 Return
! 	If E Gosub L_9580
! 	If K17$[1,9] <> K1777$[1,9] Return
! 	Rem SELECTIVE DELETE OPTION. VALUES OF K17$ & R17 S/B ALREADY ASSIGNED
! 	CHECKDEL_SORDLOT2: K177$ = " ",K177$
! 	CHECKDEL_E: Search #17,3,1;K177$,R177,E
! 		If E = 2 Goto CHECKDEL_F
! 		If E Gosub L_9580
! 		If R17 <> R177 Goto CHECKDEL_E
! 		If K17$[1,9] <> K177$[13,21] Goto CHECKDEL_E
! 		Search #17,5,1;K177$,R177,E
! 		If E <> 0 Gosub L_9580
! 	Goto CHECKDEL_E
! 	CHECKDEL_F: K177$ = " ",K177$
! 		CHECKDEL_F1: Search #17,3,2;K177$,R177,E
! 		If E = 2 Goto CHECKDEL_G
! 		If E Gosub L_9580
! 		If R17 <> R177 Goto CHECKDEL_F1
! 		If K17$[1,9] <> K177$[23,31] Goto CHECKDEL_F1
! 		Search #17,5,2;K177$,R177,E
! 		If E <> 0 Gosub L_9580
! 	Goto CHECKDEL_F1
! 	CHECKDEL_G: Search #17,5,3;K17$,R177,E
! 	If E <> 0 Gosub L_9580
! 	If DELETEFLAG = 1 Goto CHECKDEL_C
! Return
! 
! ITSGONEMESSAGE: Rem DISPLAY WHAT LINES WERE DELETED
! 	If DELETELINEFLAG = 0
! 		Print 'CR CL';"THERE ARE PROBLEMS WITH ORDER # ";H0[7]
! 		Print 'CL';" LINES THAT WERE DELETED: ";
! 	End If
! 	If Fra(DELETELINEFLAG) = 0 Print ETLINE;
! 	If Fra(DELETELINEFLAG) = .01
! 		Print 'CR CL';"NOTE: IN ADDITION TO ANY DELETED LINES, YOU SHOULD CHECK ON "
! 		Print 'CL';"THE FOLLOWING PRODUCTS:";
! 	End If
! 	If Fra(DELETELINEFLAG) <> 0
! 		Print " ";S0$[1,12];
! 		If Fra(Fra(DELETELINEFLAG) * 25) = 0 Print " "
! 	End If
! Return
! 
! EDITCHAIN: Rem FORCE AN EDIT ALL
! 	If ORDERSTATUS = 58 Return
! 	If ORDERSTATUS = 59 Return
! 	If SUPERUSER
! 		Print @0,22;
! 		If BYPASSQUEST = 1 Return
! 		Print 'CR CL';"DO YOU WANT TO FORCE THE EDIT ALL(IE:GOTO MX208,ETC)(Y/N)? ";
! 		Input ""X$
! 		If X$ <> "Y" If X$ <> "YES" If X$ <> "N" Print 'RB CL';"INVALID!!" \ Signal 3,20 \ Goto EDITCHAIN
! 		If X$ = "N" Let BYPASSQUEST = 1 \ Return
! 	End If
! 	Print @0,16;'CE';
! 	Print @0,17;'CE';"THE PROGRAM WILL NOW GO INTO ";
! 	If ORDERSTATUS >= 1 If ORDERSTATUS <= 4 Print "208 ";
! 	If ORDERSTATUS >= 5 If ORDERSTATUS <= 6 Print "223 ";
! 	If ORDERSTATUS >= 9 If ORDERSTATUS <= 10 Print "243 ";
! 	Print "SO YOU CAN GO THROUGH THE ";
! 	If ORDERSTATUS >= 1 If ORDERSTATUS <= 4 Print "ORDER ";
! 	If ORDERSTATUS >= 5 If ORDERSTATUS <= 6 Print "INVOICE ";
! 	If ORDERSTATUS >= 9 If ORDERSTATUS <= 10 Print "CREDIT MEMO ";
! 	Print @0,18;'CL';"AND HAVE IT ALLOCATE INVENTORY & RE-TOTAL.  PLEASE NOTE, "
! 	Print @0,19;'CL';"WHEN IT IS FINISHED, IT WILL GO BACK TO THE MENU.  IF YOU WISH";
! 	Print @0,20;'CL';"TO RESET ANY ADDITIONAL ORDERS, YOU WILL HAVE TO GO BACK INTO 229";
! 	Print @0,21;'CL';"PRESS <CR> TO CONTINUE ";
! 	Input ""X$
! 	Close
! 	X2 = Spc(5)
! 	FILE$ = Int((X2 - Int(X2 / 16384) * 16384) / 64) Using "CNTRL#"
! 	Open #1,FILE$
! 	For J = 2 To 32
! 		Read J1 \ If J1 = -1 Goto EDITC1
! 		Read #1,88,Abs(J1);FILE$;
! 		If J1 < 0 Ropen #J,FILE$ Else Open #J,FILE$
! 	EDITC1: Next J
! 	Data "2400","1792","2288","1808","1952","1104","1840","1856","1872","1888","2128"
! 	Data "2112","1824","2176","2528","2320","1680","1376","-1","1632","-1","1920","-688","2880"
! 	Data "1728","1664","1936","2352","1744","928","1712"
! 	COID = Int((Spc(5) - Int(Spc(5) / 16384) * 16384) / 64)
! 	FILE$ = "2/ARTERMCODE" + Str$(COID) \ Ropen #50,FILE$
! 	K11$ = " ",K11$
! 	K11$[1,6] = H0[4] Using "######"
! 	Search #5,2,1;K11$,R5,E
! 	If E <> 0 Gosub L_9580
! 	S9[1] = R5
! 	S9[2] = R1
! 	If ORDERSTATUS >= 1 If ORDERSTATUS <= 4
! 		S9 = 5
! 		S9[3] = 5
! 		S9[4] = 208
! 	End If
! 	If ORDERSTATUS >= 5 If ORDERSTATUS <= 6
! 		S9 = 22
! 		S9[4] = 223
! 	End If
! 	If ORDERSTATUS >= 9 If ORDERSTATUS <= 10
! 		S9 = 44
! 		S9[4] = 243
! 	End If
! 	If S9[4] = 0
! 		Print @0,16;'CE';
! 		Print @0,18;'CL';"THERE ARE POSSIBLE PROBLEMS WITH ORDER # ";H0[7];". PLEASE"
! 		Print @0,19;'CL';"CHECK THE ORDER. THERE COULD BE STATUS PROBLEMS WITH IT"
! 		Print @0,21;'CL';"PRESS <CR> TO EXIT PROGRAM ";
! 		Input ""X$
! 		Chain "MX000"
! 	End If
! 	Rem CHANGE STATUS FOR EDITING, ETC
! 	Mat Read #CH_ROH,R1,0;H0
! 	If H0[0] > 11 Goto EDITCEND
! 	S2 = H0[0]
! 	H0[0] = 91
! 	LOCKPORT = Spc(6)
! 	K11$ = " ",K11$
! 	K11$[1,2] = H0[0] Using "##"
! 	K11$[3,8] = H0[7] Using "######"
! 	Search #CH_ROH,4,1;K11$,R1,E
! 	If E Gosub L_9580
! 	K11$[1,2] = S2 Using "##"
! 	Search #CH_ROH,5,1;K11$,R2,E
! 	If E Gosub L_9580
! 	If R1 <> R2 Gosub L_9580
! 	Mat Write #CH_ROH,R1,0;H0
! 	Mat Write #CH_ROH,R1,64;LOCKPORT
! 	Write #CH_ROH,R1,416;S2;
! 	If ORDERSTATUS >= 1 If ORDERSTATUS <= 4 Chain "MX208A"
! 	If ORDERSTATUS >= 5 If ORDERSTATUS <= 6 Chain "MX223A"
! 	If ORDERSTATUS >= 9 If ORDERSTATUS <= 10 Chain "MX243A"
! 	EDITCEND: Print @0,16;'CE';
! 	Print @0,18;'CL';"THERE ARE POSSIBLE PROBLEMS WITH ORDER # ";H0[7];". PLEASE"
! 	Print @0,19;'CL';"CHECK THE ORDER. THERE COULD BE STATUS PROBLEMS WITH IT"
! 	Print @0,21;'CL';"PRESS <CR> TO EXIT PROGRAM ";
! 	Input ""X$
! 	Chain "MX000"
! Return
! 
! DISP_DETAIL: Rem ----------------------------------all orders w/in a stat
! 	COUNT = 0
! 	L_8020: Print @0,23;'CL';"STATUS # TO DISPLAY DETAIL <CR>: EXIT ";
! 	Input ""A$
! 	If A$ = "" Return
! 	SCR = A$
! 	If SCR < 1 Or SCR > 99 Print 'RB' \ Goto L_8020
! 	FRMSTAT$ = SCR Using "##"
! 	Gosub NEW_DETAIL_SCREEN
! 	A$ = " ",A$ \ A$[1,2] = FRMSTAT$
! 	DISP_DETAIL_NEXT_ORDER: Rem <----------loopstart
! 	Search #2,3,1;A$,R1,E
! 	If E Or A$[1,2] <> FRMSTAT$ Goto END_DISP_DETAIL
! 	Read #2,R1,64;LOCKPORT;
! 	Mat Read #2,R1,104;H5;
! 	Mat Read #2,R1,408;H6;
! 	SCR = Int(COUNT / 15)
! 	COUNT = COUNT + 1
! 	Print @SCR * 20,(COUNT - SCR * 15) + 3;A$[3,8];
! 	If FRMSTAT$ >= "90"
! 		If LOCKPORT > 1 And LOCKPORT < 999 Print LOCKPORT Using " <### >";
! 		If H6[2] Print H6[2] Using " [##]";
! 	Else
! 		Print H5[7] Using " {##}"
! 	End If
! 	If Not(Fra(COUNT / 60))
! 		Print @0,23;'CL';" <CR> TO CONTINUE,  E: TO EXIT: ";
! 		Input ""S$
! 		If S$ = "E" Return
! 		COUNT = 0
! 		Gosub NEW_DETAIL_SCREEN
! 	End If
! 	Goto DISP_DETAIL_NEXT_ORDER
! 	END_DISP_DETAIL: Rem ---------------------------------------------
! 	Print @0,23;'CL';" NO MORE ORDERS IN STATUS ";FRMSTAT$;". <CR> ";
! 	Input ""S$
! Return
! 
! NEW_DETAIL_SCREEN: Rem ---------------header
! 	Print 'CS';@0,0;"-MX229-";@25,0;"ORDER/INVOICE BATCH STATUS"
! 	Print @0,2;"STATUS ";FRMSTAT$;" ORDERS ";
! 	If FRMSTAT$ >= "90"
! 		Print " <LOCKING PORT> [PREVIOUS STATUS]"
! 	Else
! 		Print " {ORDER TYPE} "
! 	End If
! 	Print 'BR'; Tab 80;'ER';
! Return
! 
! SOSRCH: Rem ----------------------------------------sales order search
! 	FILE = 0
! 	REC = 1
! 	KEY_$ = ""
! 	Call "sosrch",SORD,INV_,KEY_$,REC,FILE,CH_ROH_READ,CH_INVH[]
! 	CH_INVH = Abs(CH_INVH)
! Return
! 
! L_9000: Rem EXIT ROUTINE
! 	Print 'CS'
! 	Close
! 	Chain "MX000"
! Stop
ERR_SEARCH: Rem
	ENUM = E ;ELINE = Spc(16);CTERR = 0
	If E = 5 Let CTERR = Err(8)
	e$ = "SEARCH ERROR RETURN STATUS",(E + (CTERR * .001))
	e$ = e$,"/ STATEMENT",ELINE," IN PROGRAM "+msc$(4)
	error 9999 ! (1 less than 10000, bogus, but causes full dump)
Return ! End

OUTEND: Rem EXIT ROUTINE
call setoutput(e$,rstr$)
Close
else ! main try failure
 include "src/callmainerrnet.inc"
end try
end

