Rem buildquote  fqom salespro to papermaster
! loadsave -w -n 100,10 -o prog/dxport/buildquote src/buildquote.src
! 9/19/06 fixed z lines

Include "src/cartdet.inc"

Declare Intrinsic Sub DateToJulian,FindF,FormatDate,InpBuf,JulianToDate,String,Time,VerifyDate
Option Default Dialect IRIS1
Declare Intrinsic Sub dxget
Declare Intrinsic Function findchannel
Declare External Function stringcheck$
Declare Intrinsic Function TRIM$
Rem
Rem
! WRKFLE[1] = carthc;WRKFLE[2] = cartdc;WRKFLE[3] = cartsc ! "cart files 
!		wrkfle[4] = cartns; wrkfle[5]=deleteflag 999
! PRG_VAR elements:
! 0= order counter per rep (from eccos)
! 1=?
! 2=specs[20]=systemprice
! 3=open used to be order counter per rep
! 4=qty um rec#
! 5=price um rec#
! 6=given_fld[1]=pc3[0]=QTY ORDERED
! 7=orderedqty-availqty
! 8=given_fld[2]=pc3[1]=unitprice
! 9=x3[3]=price with upcharge in punit
! 10=x3[3] in base unit
! 11=l5[1]
! 12=cost um rec#
Rem
! ADDED - OMNI_R (workfle[0]=-1) - HAS faux cart files (WITH EXTRA FIELDS)!!
Rem

!GIVEN_FLD[2]	CARTDET.PRICE
!GIVEN_FLD[16]	cartdet.TAXABLE				
!GIVEN_FLD[18]	cartdet.l7				
!GIVEN_FLD[19]	cartdet.rol0				
!GIVEN_FLD[20]	cartdet.ucost				
!GIVEN_FLD[21]	cartdet.uprice				
!GIVEN_FLD[22]	cartdet.dept				
!GIVEN_FLD[23]	CARTDET.COST				
!GIVEN_FLD[24]	CARTDET.GP				
					
					
!PRG_VAR[4]	CART.QUM$		REC NUM	QTY		
!PRG_VAR[5]	cartdet.PUM$	REC NUM	PRICE	
!PRG_VAR[8]	PRICE IN PRICE U/M				
!PRG_VAR[11]	COST IN BASE				
!PRG_VAR[12] CARTDET.COSTUM$ rec num	COST


External Lib "libgeneral.lib"
Declare External Sub suberr,mainerr
Dim e$[500],buttonlist$[5,50],nextlist$[5,100]
External Lib "ubsfunc.dl4"
Declare External Function openfile,clrtxtc$
Declare External Sub TaxFlag
External Lib "libprice.lib"
Declare External Sub SysPriceCalc
include "src/inc/filesfcartns.inc"
include "src/inc/fileqproddesc.inc"
If Err 0 Gosub ERR_TRAP_LOGGED
Enter WRKFILE[],FLESPEC[],result$,WRKKEY$,PROB[],lastflag$
Rem
dim cartdet. as cartdet

dim 1%,delallflag
let delallflag=wrkfile[5] ! 
Rem ***** need ordernum and delallflag *****
Dim co$[5]
Dim 1%,CHNL[99]
Dim 3%,CHNLSCR,CHNLFREE,LPCHAN[9]
Rem
Dim keycust$[30],keyprod$[20],userid$[8],tmp$[200]
Dim 2%,R5,H1,V1,lpppcust,q0[1]
DIM 3%,CFIN[8]
Dim SPACES$[200],KCUST$[50],DLINE$[40],HDR$[40],ns_dline$[40]
Dim KSLSM$[50],KZONE$[50],KSHIPLIST$[50],KCCODES$[50],PASSWD$[16]
Dim work$[600],SDATE$[50],LPTNAME$[80],LPTDESCR$[24]
Dim TYPE$[10],MSGDESC$[100],FNAME$[120],notes$[600],DDATA$[256]
Dim DLOG$[256],X$[40],A1TMP$[142],A2TMP$[30],A3TMP$[22],X1$[20],HOME$[100]
Dim CMD$[256],msg$[256],DDATA_MASK$[256],DLOG_MASK$[256],SUPERCD$[12]
Dim P61$[256],SPTYPE$[2],GIVEN_PUM$[4],SP1$[80],CUM$[4],GIVEN_CUM$[4]
Dim CUSTID$[10],SHIPDATE$[8],SHIPTO$[6],OS1$[120],ATTN$[30],SHIPVIA$[12],shipcust$[6]
Dim GPROD$[30],QUM$[4],PUM$[4],GIVEN_PRC_TP$[1],GPO$[20],ltype$[1],lwh$[2],headwh$[2]
dim keycartmc$[50],keycstqt1$[50],keycstqt2$[50]
dim 1%,qhcurrid,qlcurrid,3%,qhcurrfact,qlcurrfact
Dim 1%,OTYPE,TERMS,ROUTING,PC1[1],3%,PC3[3],ORDDISC,GNETPC[1]
Dim 1%,X1[9],TAX[100],RASL[5],FOUND,HOLD[14],2%,pline[9]
Dim 1%,FLAG[99],Q1[3],MS1[2],MS2[2]
dim 1%,ch_cartmc,ch_cstqt,ORGSTAT
Dim 1%,CH_LPT,ch_cntrl,ch_prod,ch_comcd,ch_aract,ch_credck,ch_qoh,ch_qot,ch_qod
Dim 1%,ch_qol,ch_slsm,ch_prwh,CH_INPUT[3],ch_qom,CH_ZIP,ch_prtype,ch_temp
Dim 1%,ch_ccodes,ch_lastpr,ch_ordl,ch_zone,ch_tax,ch_sprice,ch_ctrct
Dim 1%,ch_prlt,ch_brktbl,ch_custax,ch_stagitem,ch_shiplist,ch_miscchg
Dim 1%,ch_qos,coid,FALSE,TRUE,FATAL_ERROR,NON_FATAL_ERROR
Dim 1%,CH_SORT,X[9],ch_qoltag
Dim 2%,X2[9],I,LOCKTIMEOUT,cdate[5],JDATE[6]
Dim 2%,E1,flechan[99],CUTTIME,CURTM[9],LTAXABLE[1]
Dim 2%,pos2,pos3,SC,SR,SLSLSM,1%,SO[20]
Dim 2%,GMCODE[9],3%,GMCHG[9],GMCOST[9],GUCHG[1]
Dim 2%,expday,hdept
dim 3%,mccust
Dim 3%,SUPERCEDE_LIST[50],WREC[9],R[99]
Dim 3%,AVAIL[1],X3[9],BASE,FLEPTR[20,1],SPECS[50],MAXTAX,TOT_HOLD
Dim 1%,PFU1[20],CNVTU[2],3%,PFU2[6],CNVTA,AMOUNT,C2TMP[2],C7TMP[4]
Dim 2%,C1TMP[12],POS_,pos1,D0
Dim 3%,REC_BRKTBL,REC_CUST,REC_PROD,REC_PRWH,REC_qoh,REC_qol,REC_qos
Dim 3%,REC_qot,REC_SLSM,REC_ZIP,REC_CUST,REC_COMCD,REC_LASTPR,REC_STAGITEM
Dim 3%,E,REC_ZONE,REC_SHIPLIST,REC_CCODES,WHBLD[5]
Dim 3%,REC_ORDL,REC_PRLT,REC_qom,rec_qoltag
Dim 3%,GIVEN_FLD[99],PRG_VAR[99]
dim 3%,rec_cartmc,rec_cstqt
Dim CNAME$[30],CDATE$[8],P9$[50],P60$[50],TFILE$[256],GIVEN_COMMENTS$[80]
Dim SUPER_PROD$[12]
Dim GIVEN_PO$[20],GIVEN_ITEM$[12],GIVEN_UM$[4],GIVEN_PRICE_CODE$[1]
Dim K6$[20],GIVEN_CONF$[16]
Dim 4%,GIVEN_CONF,X4
Rem
Dim 1%,H3[1],H4[2],LOCKPORT,OWHT[1],PICKBY[1]
Dim 2%,H0[12],H5[16],ST3[24],SLSM[9],H6[8],HFAX[1]
Dim 2%,HSTI[1],H2[0],OWHT1[1]
Dim 3%,TOT_SELL,SCOM[4],SMER[4],SCST[4],TOTGL,netcost,QUOTENUM
Dim V0$[12],H0$[20],H1$[6],HMAT$[2],P0$[20]
Rem
Rem
Dim 1%,S6[1]
Dim 2%,S1[1],S5
Dim 3%,SRN[5]
Dim S1$[118],S2$[20]
Rem
Rem
Dim 1%,DCLVL,MCTXBL[9]
Dim 2%,MCODE[9],T1[1],JRNL
Dim 3%,MCHARGE[9,1],T2[25],TOT[4],TOT1[1]
Rem
Rem
Dim 1%,L3[3],PL[1],UN[2],S2[1],EUN[2],OWHS,LPRINTED,CTWT
Dim 2%,L2[1],L4[3],L6[5],L9[1],LCO[1],LTAX2,LP_DATE,LP_TIME,GWGT[1]
Dim 3%,L5[3],L7[12],S3[17],OLM[6],UNF[6],CST[0],LTAX1,QPB,GWGT1,ROL0
Dim L6$[60],L1$[20],MT$[2],S3$[33]
Rem
Rem
Dim 2%,M1,M1$[40]
Rem
Dim A$[156],PR_A2$[30],T2$[7]
Dim 1%,PFU1[20]
Dim 2%,B[24],PR_C4[10]
Dim 3%,A1[7],A[33],PF_LOAD2,PFU2[6],PLV[1]
Dim 1%,ch_cust
Dim A3$[22],A2$[30],A1$[142]
Dim 2%,A0[3],C1[12]
Dim 1%,C2[2],C7[4]
Dim 3%,REC_CUST,raw_wgt
Dim 1%,W0[3],2%,W2[9]
Dim 3%,W3[24],WHLV[2]
Dim 1%,SA$[142],SR$[33],SI$[120],C11[3]
Dim 2%,SL2[4],SHIPCUST
Dim 4%,SC1
Dim SLSM_NAME$[30],CCD$[14]
Dim 3%,SS3[9],ordernum
Dim 1%,PT[37],ch[99],2%,S9[9]
Dim 3%,PARAM[20]
Dim 3%,ZLINE$[60]
! qoltag vars
dim 1%,rt_linenum
dim 3%,tl2[1]
dim LPONUM$[30],LJOBNUM$[30],PSNUM$[30],rt_msg$[810]
dim 1%,ch_ns,ch_roc,ch_rod,ch_trd,ch_usr,ch_et,ch_usrctl,ch_usrport             
dim 1%,ch_ron,ch_ser,ch_shhist,ch_wt,ch_kit                                     
! dim for new rec                                                               
dim 3%,rec_ns,rec_roc,rec_rod,rec_trd,rec_et                                    
dim 3%,rec_ron,rec_ser,rec_shist,rec_wt,rec_kit                                 
! dim for new keys                                                              
dim keytmp$[50],keyron$[50],keyron2$[50],keyrol$[50],keyrol2$[50],keyshist$[50] 
dim keyprwh$[50],keyshist$[50],keywt$[50],keykit$[50],keyroh$[50],keylot$[60],tmpkey$[50]
dim keysave$[50],keypr$[50]
!! dim for serial #                                                             
dim sn1$[54]                                                                    
dim 1%,sn1,snn1[2]                                                              
dim 2%,sn1$[54]                                                                 
!! dim for kits                                                                 
dim kl$[58]                                                                     
dim 1%,kl1[5]                                                                   
dim 2%,kl2[1]                                                                   
dim 3%,kl3[1]                                                                   
DIM I$[60],keyplot$[60]                                                         
DIM S0$[36],FLG$[4]                                                             
DIM 1%,oS1[3],WHSE,DL1,U1,HWHse,LWhse                                           
Dim 1%,etline,etstat,etunit,etnonstock,chnlfree,scr1,ch_et,lockport,etprint     
DIM 1%,ETPUNIT[1]                                                               
DIM 2%,DL[12]   
DIM 2%,SHIPDATE                                                 
Dim 2%,etorder,etdate,ettime,etport,etaction,etcust,adelln,uca2 
Dim 2%,etorigcust                                               
Dim 3%,etoqty[2],etnqty[2],LBSOrd,WHLBS[1]                      
DIM 3%,P3[4],oS3[3],C9                                          
DIM 3%,sS2[20],OL2$[16],DLT                                     
DIM 2%,JSDATE,JWDATE,DT3[1]                                     
DIM 2%,ETSLS,dept
DIM 3%,ETUNITPRICE[1],ETLOADCOST[1],ETWGT[1]                    
DIM BLANK$[90]                                                  
DIM DL$[20],DL1$[20],SCRATCH$[80]                      
Dim etprod$[12],etuser$[10],et$[80],useraccess$[10]             
dim 3%,DL3,OREF[5],ETInvoice
Dim 1%,tx9[1],2%,lvlpct,3%,qtysell,rtype$[1]
dim custom_customer$[30]

dim ns. as qproddesc  ! as quotes may have different fields!
dim cartns. as sfcartns

OMNI_R=0 \ if WRKFILE[0]=-1 let OMNI_R=1 ! SHOW FROM OMNI RETAIL
call DxGet("u_custom_customer", custom_customer$)
Mat PROB = Zer \ PROB[0] = 0
FLAG[6] = 1;FLAG[7] = 1
LOCKTIMEOUT = 600
Def FNR(H) = Int(Abs(H) * 100 + .5) * .01 * Sgn(H)
Def FNU(H) = Int(Abs(H) + Sgn(Fra(Abs(H)))) * Sgn(H)
DEF FNV(X)=SGN(X)*(INT(ABS(X)*100+.9999999)*.01) 
Def FNN(H) = Int(Abs(H) * 10 ^ Q0[1] + .5) * 10 ^ - Q0[1] * Sgn(H)    ! "normal round

For X = 0 To 32
  If Err 0 Exit For 
  flechan[X] = FLESPEC[X]
  FLESPEC[X] = 0
Next X
! coid = Int((Spc(5) - Int(Spc(5) / 16384) * 16384) / 64)
Call dxget("S_USER.AppID",co$)
intCo = co$ \ coid=intCo
If Err 0 Gosub ERR_TRAP_LOGGED
CH_LPT = 0
If flechan[0] = -1 Let FLAG[7] = 0
If Not(WRKFILE[1])
  msg$ = "Work file header not passed. Exiting..."
  Error 10000
Else 
  CH_INPUT[1] = WRKFILE[1]
End If 
If Not(WRKFILE[2])
  msg$ = "Work file detail not passed. Exiting..."
  Error 10000
Else 
  CH_INPUT[2] = WRKFILE[2]
End If 
If Not(WRKFILE[3])
  CH_INPUT[3] = 0
Else 
  CH_INPUT[3] = WRKFILE[3]
End If 
If Not(WRKFILE[4]) ! nonstock cart file
	cartns=openfile(10017,intCo)\if cartns=-1 error 42 !cart nonstock! mtg 
else
	let cartns=wrkfile[4]
End If 
HOME$ = "HOME" \ system 28,HOME$
if HOME$ = ""	! home environment variable not set
	HOME$ = MSC$(9) ! absolute path of the current program
	! assume we are running in prog/ .. off of the home dir
	SEARCH HOME$,"prog/",e
	if e = 0
		HOME$=""
	else
		HOME$[e] = ""
	end if
end if
DLOG_MASK$ = HOME$+"/prog/custom/files/6/slplog&&.txt"
DDATA_MASK$ = HOME$+"/prog/custom/files/6/slpdata&&.debug"
ch_prod = flechan[3]
ch_comcd = flechan[4]
ch_cust = flechan[5]
ch_aract = flechan[6]
ch_credck = flechan[7]
ch_qoh = flechan[8]
CH_SORT = flechan[9]
ch_qot = flechan[10]
ch_qol = flechan[11]
ch_qom = flechan[12]
CH_ZIP = flechan[13]
ch_slsm = flechan[14]
ch_prtype = flechan[15]
ch_ccodes = flechan[17]
ch_lastpr = flechan[18]
ch_ordl = flechan[19]
ch_zone = flechan[20]
ch_tax = flechan[21]
ch_sprice = flechan[22]
ch_ctrct = flechan[23]
ch_prlt = flechan[24]
ch_brktbl = flechan[25]
ch_custax = flechan[26]
ch_stagitem = flechan[27]
ch_shiplist = flechan[29]
ch_prwh = flechan[30]
ch_miscchg = flechan[31]
ch_qos = flechan[32]
If Err 0 Let E1 = Spc(8)
E1 = 0 \ LPTNAME$ = Chf$(800 + CH_LPT)
If Err 0 Gosub ERR_TRAP_LOGGED
If Not(FLAG[7]) Let E1 = 0
If E1
  msg$ = "This process must be printed on Hard Copy!"
  Error 10000
End If 
LPTDESCR$ = ""
If LPTNAME$[1,12] = "/usr/ub/sys/"
  LPTNAME$ = "$",LPTNAME$[13]
  LPTNAME$ = LPTNAME$ To " "
  ch_temp = findchannel()
  Open #ch_temp,"files/cntrl/CNTRL.LPT"
  LPTDESCR$ = " (unknown)"
  For X1 = 1 To Chf(ch_temp) - 1
    Mat Read #ch_temp,X1,0,LOCKTIMEOUT;work$[1,30];
    Call String(1,work$) \ Call String(1,LPTNAME$)
    If work$[1,Len(LPTNAME$)] = LPTNAME$
      Mat Read #ch_temp,X1,30,LOCKTIMEOUT;Q1;
      Q1 = 0
      Q1[1] = 0
      Mat Write #ch_temp,X1,30,LOCKTIMEOUT;Q1;
      LPTDESCR$ = work$[11,30];X1 = 999
    End If 
  Next X1
  Close #ch_temp
End If 

Call DXGet("S_USER.Userdef1",co$) ! Salesman Number
intSalesman = co$
If LPTNAME$[1,1] = "$" Call String(2,LPTNAME$)
FALSE = 0;TRUE = Not(FALSE)
SPACES$ = " ",SPACES$
pline[1] = 60
Call Time(SDATE$)
CURTM[4] = SDATE$[5,6]
JDATE[5] = Tim(6)
X2 = JDATE[5];X$ = X2 Using "#####"
Call JulianToDate(1,X$,work$,E)
cdate[1] = (work$[7,8] + work$[1,2] + work$[4,5])
cdate[2] = cdate[1]
work$ = Str$(intCo)
work$ = work$ + JDATE[5] Using "&&&&&"
CURTM[0] = SDATE$[15,16]
CURTM[1] = SDATE$[18,19]
CURTM[2] = SDATE$[21,22]
CURTM[3] = CURTM[0] * 10000 + CURTM[1] * 100 + CURTM[2]
work$ = work$ + CURTM[3] Using "&&&&&&"
GIVEN_CONF$ = work$
TFILE$ = Chf$(800 + CH_INPUT[1])
If Not(E1) Gosub PURGE_LOG
If Not(E1) And DLOG$ And DDATA$
  System "touch " + DLOG$,E1 \ If E1 Goto OUTHERE
  System "touch " + DDATA$,E1 \ If E1 Goto OUTHERE
Else 
  E1 = TRUE
End If 
OUTHERE: Rem
If E1
  msg$ = "Unable to open work files. Exiting..."
  Error 10000
End If 
ch_cntrl = openfile(9999,intCo) \ If ch_cntrl = -1 Error 42
If Err 0 Gosub ERR_TRAP_LOGGED
Mat Read #ch_cntrl,115,40;Q0; \ If Not(Q0[1]) Let Q0[1] = 2 
Mat Read #ch_cntrl,0,100,LOCKTIMEOUT;CDATE$;
Mat Read #ch_cntrl,3,0,LOCKTIMEOUT;CNAME$;
Read #ch_cntrl,3,188,LOCKTIMEOUT;JDATE[6];
Mat Read #ch_cntrl,19,50,LOCKTIMEOUT;P9$;
Mat Read #ch_cntrl,60,50,LOCKTIMEOUT;P60$;
Mat Read #ch_cntrl,61,0,LOCKTIMEOUT;P61$;
Mat Read #ch_cntrl,182,84,LOCKTIMEOUT;CUTTIME;
MAT  READ #ch_cntrl,3,188,LOCKTIMEOUT;SHIPDATE;        
LET X2=SHIPDATE \ GOSUB ymd2jul \ LET X2=0 
IF X2                                      
        LET JSDATE=X2                      
else                                       
        let x$=jdate[6] Using "&&&&&&"     
        Call DateToJulian(1,X$,X$,1,E)     
        let jsdate=x$                      
endif                                
If P9$[32,32] = "Y" Let FLAG[10] = TRUE
If P9$[41,41] = "Y" Or P9$[41,41] = "W" Let RASL = TRUE
If P9$[33,33] = "N" Let FLAG[10] = FALSE
If CUTTIME <= 0 Let CUTTIME = 24
X$ = JDATE[6] Using "&&&&&&"
Call DateToJulian(1,X$,X$,1,E)
If E
  JDATE[6] = 0
Else 
  JDATE[6] = X$
End If 
work$ = "MXOHCSZONE"
Call FindF(work$,FOUND)
If Not(FOUND) Let P61$[34,34] = "N"
If Not(ch_prod)
  ch_prod = openfile(1792) \ If ch_prod = -1 Error 42
End If 
If Not(ch_cust)
  ch_cust = openfile(1808) \ If ch_cust = -1 Error 42
End If 
If Not(ch_aract)
  ch_aract = openfile(-1504) \ If ch_aract = -1 Error 42
End If 
If Not(ch_credck)
  ch_credck = openfile(992) \ If ch_credck = -1 Error 42
End If 
If Not(ch_slsm)
  ch_slsm = openfile(-1824) \ If ch_slsm = -1 Error 42
End If 
If Not(ch_qoh)
  ch_qoh = openfile(1280) \ If ch_qoh = -1 Error 42
End If 
If Not(ch_qos)
  ch_qos = openfile(1392) \ If ch_qos = -1 Error 42
End If 
If Not(ch_qot)
  ch_qot = openfile(2656) \ If ch_qot = -1 Error 42
End If 
If Not(ch_qol)
  ch_qol = openfile(1344) \ If ch_qol = -1 Error 42
End If 
If Not(ch_qom)
  ch_qom = openfile(2672) \ If ch_qom = -1 Error 42
End If 
If Not(ch_prtype)
  ch_prtype = openfile(-752) \ If ch_prtype = -1 Error 42
End If 
If Not(ch_prwh)
  ch_prwh = openfile(1744) \ If ch_prwh = -1 Error 42
End If 
If Not(ch_ccodes)
  ch_ccodes = openfile(-1728) \ If ch_ccodes = -1 Error 42
End If 
If Not(ch_lastpr)
  ch_lastpr = openfile(1376) \ If ch_lastpr = -1 Error 42
End If 
If Not(ch_ordl)
  ch_ordl = openfile(2320) \ If ch_ordl = -1 Error 42
End If 
If Not(ch_zone)
  ch_zone = openfile(-1920) \ If ch_zone = -1 Error 42
End If 
If Not(ch_comcd)
  ch_comcd = openfile(-2288) \ If ch_comcd = -1 Error 42
End If 
If Not(ch_tax)
  ch_tax = openfile(-2176) \ If ch_tax = -1 Error 42
End If 
If Not(ch_sprice)
  ch_sprice = openfile(-1936) \ If ch_sprice = -1 Error 42
End If 
If Not(ch_ctrct)
  ch_ctrct = openfile(-2880) \ If ch_ctrct = -1 Error 42
End If 
If Not(ch_prlt)
  ch_prlt = openfile(2528) \ If ch_prlt = -1 Error 42
End If 
If Not(ch_brktbl)
  ch_brktbl = openfile(-1952) \ If ch_brktbl = -1 Error 42
End If 
If Not(ch_custax)
  ch_custax = openfile(-928) \ If ch_custax = -1 Error 42
End If 
If Not(ch_stagitem)
  ch_stagitem = openfile(-2352) \ If ch_stagitem = -1 Error 42
End If 
If Not(ch_shiplist)
  ch_shiplist = openfile(-2112) \ If ch_shiplist = -1 Error 42
End If 
If Not(ch_miscchg)
  ch_miscchg = openfile(-2032) \ If ch_miscchg = -1 Error 42
End If
ch_qod = openfile(1424) \ If ch_qod = -1 Error 42
CSZC = openfile(-9997,intCo) \ If CSZC = -1 Error 42 !"cust/ship zone file  
ch_ns = openfile(1424) \ If ch_ns = -1 Error 42 ! non-stock 
ch_cartmc=openfile(10014,intco) \if ch_cartmc=-1 Error 42 ! multi customer quote
ch_cstqt=openfile(9980,intco) \if ch_cstqt=-1 Error 42 ! multi customer quote unibasic
ch_qoltag = openfile(9938) \ if ch_qoltag = -1 error 42
ch_temp = findchannel()
Unlock #ch_cntrl
STARTLOOP: Rem
Gosub PURGE_LOG
Search #CH_INPUT[1],2,1;WRKKEY$,WREC[1],E
If Not(E) Let FOUND = 1 Else Let FOUND = 0
If FOUND
  HDR$ = WRKKEY$
   gosub readwhdr
  if ordernum and delallflag=0   !! only check if not deleting
	x2=ordernum
	GOSUB CHK_ORDER_NUM
	IF E or i<>91     !! if not quote being editted or quote not in qoh
		ordernum=0
		Mat write #CH_INPUT[1],WREC[1],386;ordernum;
	endif 
  endif
  if ordernum
  	gosub rtnordedit:
	if delallflag
		msg$ = "--- Finished deleting order  --------------"
		Gosub UPDATE_LOG
		goto outend
	endif
  endif
  Gosub PROCESS
  Unlock #ch_qoh
  Unlock #ch_qot
  Unlock #ch_qos
  If H0[7]
    msg$ = "Processed quote # " + H0[7] Using "######" + " for cust # " + Str$(H0[4])
    msg$ = msg$ + ". Confirmation #" + GIVEN_CONF$
  Else 
    msg$ = "Complete - " + Str$(PRG_VAR[0]) + " quote"
    msg$ = msg$ + " loaded"
  End If 
Else 
  msg$ = "Nothing received fqom File"
End If 
Goto OUTEND
PROCESS: Rem
If Err 0 Gosub ERR_TRAP_LOGGED
If FLAG[7]
  If LPTNAME$[1,1] <> "$"
FPLOOP: Read #CH_LPT;work$;
    If work$ Goto FPLOOP
  End If 
End If 
FATAL_ERROR = FALSE
NON_FATAL_ERROR = FALSE
pline = 999;pline[9] = 0
PRG_VAR[0] = 0;GIVEN_FLD[12] = 1
GIVEN_COMMENTS$ = " ",GIVEN_COMMENTS$;GIVEN_COMMENTS$ = ""
SDATE$ = "" \ Call Time(SDATE$)
msg$ = "--- Begin processing quote export file -----------------"
GIVEN_FLD[7] = 0;GIVEN_FLD[8] = 0;GIVEN_FLD[6] = 0
GIVEN_FLD[10] = 95;GIVEN_FLD[11] = 995;GIVEN_FLD[17] = 0
GIVEN_PO$ = "INTERNET QUOTE" + SPACES$
Gosub UPDATE_LOG
Gosub READWHDR
FLAG[11] = FALSE
If CUSTID$[1,1] = "" Or CUSTID$[1,5] = "     " Let CUSTID$ = "EMPTY"
X2 = CUSTID$
If X2 > 0 And X2 < 999999 And Not(Fra(X2))
  KCUST$ = X2 Using "######"
  Search #ch_cust,2,1;KCUST$,REC_CUST,E \ If E > 1 Gosub ERR_SEARCH_LOGGED
Else 
  E = 1
End If 
If Not(E) Let FLAG[11] = TRUE;GIVEN_FLD[0] = KCUST$
Gosub PARSE_RECORD
Rem
If Not(FLAG[11])
  Gosub RPTHEAD
  FNAME$ = Chf$(800 + CH_INPUT[1])
  Close #CH_INPUT[1]
  CMD$ = "echo ''Bad export file ",FNAME$," KEY = ",WRKKEY$,"'' >> ",DDATA$
  System CMD$
  If CUSTID$[1,5] = "EMPTY"
    msg$ = "The export file is empty"
    If FLAG[7] Print #CH_LPT;msg$
    Gosub UPDATE_LOG
  Else 
    If FLAG[7]
      Print #CH_LPT;"Wrong export file. Expecting quotes, but instead got: ''";
      Print #CH_LPT;CUSTID$;"''"
    End If 
    msg$ = "Wrong export file. Refer to ",FNAME$," for details"
    Gosub UPDATE_LOG
  End If 
  pline = pline + 1
  Gosub RPTHEAD
  Goto OUTEND
End If 
FLAG[8] = 0;DLINE$ = " ",DLINE$
DLINE$ = HDR$
LOOP_: Gosub GETWDLINE
If Not(FLAG[14])
  Gosub PARSE_LRECORD
  If GIVEN_ITEM$ And GIVEN_FLD[1]
    FLAG[8] = 1
  Else 
    msg$ = "Key of invalid line data:"
    Gosub UPDATE_LOG
    If FLAG[7] Print #CH_LPT;msg$
    msg$ = DLINE$
    Gosub UPDATE_LOG
    If FLAG[7] Print #CH_LPT;msg$
    msg$ = "End of invalid data"
    Gosub UPDATE_LOG
    If FLAG[7] Print #CH_LPT;msg$
    pline = pline + 3
    Gosub RPTHEAD
  End If 
  Goto LOOP_
End If 
If Not(FLAG[8]) Let FATAL_ERROR = TRUE
If FATAL_ERROR
  msg$ = "No Line Item data:"
  Gosub UPDATE_LOG
  If FLAG[7] Print #CH_LPT;msg$
  msg$ = HDR$
  Gosub UPDATE_LOG
  If FLAG[7] Print #CH_LPT;msg$
  msg$ = "No Quote created"
  Gosub UPDATE_LOG
  If FLAG[7] Print #CH_LPT;msg$
  pline = pline + 3
  Gosub RPTHEAD
  Goto FATAL_ABORT
End If 
DLINE$ = SPACES$
TYPE$ = "QUOTE"
CHKCUST: Rem
KCUST$ = GIVEN_FLD[0] Using "######"
Search #ch_cust,2,1;KCUST$,REC_CUST,E
If Not(E)
  FLAG[12] = FALSE
  Gosub READ_CUST
  Rem
  !!If TYPE$ = "ORDER" Write #ch_cust,REC_CUST,162;cdate[1];
  Gosub GET_SHIPLIST
  If Not(GIVEN_FLD[8]) Let GIVEN_FLD[8] = CFIN[4]
  If SLSLSM > 0 And SLSLSM < 999 And Not(Fra(SLSLSM)) Let GIVEN_FLD[4] = SLSLSM
  For I = 0 To 12 \ C1TMP[I] = C1[I] \ Next I
  For I = 0 To 2 \ C2TMP[I] = C2[I] \ Next I
  For I = 0 To 4 \ C7TMP[I] = C7[I] \ Next I
  If Not(C7[0]) Let FLAG[6] = 0
  A1TMP$ = A1$
  A2TMP$ = A2$
  A3TMP$ = A3$
  Mat Read #ch_custax,A0[3],36,LOCKTIMEOUT;TAX;
  If P60$[42,42] <> "Y" Let L6[5] = TAX[A1[7]]
Else 
  FLAG[12] = TRUE
  REC_CUST = 0
End If 
DLINE$ = SPACES$
IF TERMS
	LET C2TMP[0]=TERMS
ENDIF
Gosub MAKEORDER
If PRG_VAR[0]
  If FLAG[7] Print #CH_LPT;"Quote count for salesman ";H0[11];":";PRG_VAR[0];
End If 
FATAL_ABORT: Rem
msg$ = "--- Finished processing quote export file --------------"
Gosub UPDATE_LOG
CMD$ = "echo ''-------------------- Parse Date: " + SDATE$
CMD$ = CMD$ + " ------------------------'' >> " + DDATA$
System CMD$
CMD$ = "echo " + TFILE$ + " " + WRKKEY$ + " >> " + DDATA$
System CMD$
Goto OUTEND
PARSE_RECORD: Rem
Rem
GIVEN_FLD[0] = CUSTID$
let shipcust=shipcust$
if shipcust<=0 let shipcust=custid$
gotshipto = 0
If SHIPTO$[1,1] <> "" And SHIPTO$[1,6] <> SPACES$[1,6]
  GIVEN_FLD[5] = SHIPTO$
  gotshipto=1 ! (GIVEN_FLD[5] could be 0 indicating default shipto code used)
Else 
  GIVEN_FLD[5] = 0
End If 
!If GIVEN_FLD[5] = 0 And OS1$[1,1] <> "" And OS1$[1,6] <> SPACES$[1,6]
If not(gotshipto) And OS1$[1,1] <> "" And OS1$[1,6] <> SPACES$[1,6]
  tmp$ = OS1$[1,30] \ SA$[1,30] = clrtxtc$(e$,tmp$) + SPACES$
  tmp$ = OS1$[31,60] \ SA$[31,60] = clrtxtc$(e$,tmp$) + SPACES$
  tmp$ = OS1$[61,90] \ SA$[61,90] = clrtxtc$(e$,tmp$) + SPACES$
  tmp$ = OS1$[91,105] \ SA$[91,105] = clrtxtc$(e$,tmp$) + SPACES$
  tmp$ = OS1$[106,107] \ SA$[106,107] = clrtxtc$(e$,tmp$) + SPACES$
  tmp$ = OS1$[108,117] \ SA$[108,117] = clrtxtc$(e$,tmp$) + SPACES$

  GIVEN_FLD[5] = -1
End If 
h0$[1,20] = clrtxtc$(e$,ATTN$) + SPACES$
GIVEN_FLD[3] = cdate[1]
X$ = SPACES$
If Len(SHIPDATE$) > 6 And SHIPDATE$[7,8] <> "  "
  X$ = SHIPDATE$[3,8]
Else 
  X$ = SHIPDATE$[1,6]
End If 
GIVEN_FLD[9] = X$
If GIVEN_FLD[9] <= 0 Let GIVEN_FLD[9] = cdate[2]
GIVEN_PO$ = clrtxtc$(e$,GPO$) + SPACES$
If OTYPE < 1 Or OTYPE > 38 Let OTYPE = 1
GIVEN_FLD[14] = OTYPE
Rem
ORDDISC = 0 - ORDDISC
Rem
X2 = Abs(ORDDISC)
If ORDDISC >= 0 And X2 > 100 Let ORDDISC = 0
GIVEN_FLD[15] = ORDDISC
If Not(GIVEN_FLD[0])
  msg$ = "Unable to determine the customer code"
  Gosub UPDATE_LOG
  Gosub RPTHEAD
  If FLAG[7] Print #CH_LPT;msg$
  pline = pline + 1
  Gosub RPTHEAD
  FATAL_ERROR = TRUE
Else 
  KCUST$ = GIVEN_FLD[0] Using "######"
  Search #ch_cust,2,1;KCUST$,REC_CUST,E
  If Not(E)
    Gosub READ_CUST
    If Not(GIVEN_FLD[4]) Let GIVEN_FLD[4] = C1[2]
  End If 
  If Not(GIVEN_FLD[4]) Let GIVEN_FLD[4] = 999
End If 
If Not(GIVEN_PO$)
  msg$ = "Unable to determine the PO number"
  Gosub UPDATE_LOG
  Gosub RPTHEAD
  If FLAG[7] Print #CH_LPT;msg$
  pline = pline + 1
  Gosub RPTHEAD
  NON_FATAL_ERROR = TRUE
End If 
If GIVEN_CONF$
  FOUND = 0
  If FOUND
    work$ = Str$(H0[7])
    msg$ = "PO ALREADY IMPORTED ON QUOTE " + work$
    Gosub UPDATE_LOG
    Gosub RPTHEAD
    If FLAG[7] Print #CH_LPT;msg$
    pline = pline + 1
    Gosub RPTHEAD
    FATAL_ERROR = TRUE
    H0[0] = 0;H0[7] = 0
  End If 
End If 
Return 


PARSE_LRECORD: Rem
work$ = cartdet.PROD$ + SPACES$
GIVEN_ITEM$ = work$[1,12]
GIVEN_FLD[1] = CARTDET.QTY ! PC3[0]
work$ = "O"
If CARTDET.PERM Let work$ = "P"
GIVEN_PRC_TP$ = work$
GIVEN_FLD[2] = CARTDET.PRICE ! PC3[1]
GIVEN_PRICE_CODE$ = "M"
If GIVEN_FLD[2] <= 0
  ! GIVEN_FLD[2] = 0;GIVEN_PRICE_CODE$ = "S"    ! need to allow zero price for dispensers, etc.
End If 
work$ = cartdet.pum$
work$ = work$ + "    "
If work$[1,1] <> " " And work$[1,1] <> "~" And Len(work$) > 0
!  cartdet.PUM$ = work$
Else 
  cartdet.PUM$ = "    "
End If
work$ = cartdet.COSTUM$
work$ = work$ + "    "
If work$[1,1] <> " " And work$[1,1] <> "~" And Len(work$) > 0
!	cartdet.CUM$ = work$
Else
	cartdet.COSTUM$ = "    "
End If
GIVEN_FLD[16] = cartdet.TAXABLE
GIVEN_FLD[18] = cartdet.l7
GIVEN_FLD[19] = cartdet.rol0
GIVEN_FLD[23] = CARTDET.COST	!PC3[2]
GIVEN_FLD[20] = cartdet.ucost	!GNETPC[0]
GIVEN_FLD[21] = cartdet.uprice	!GNETPC[1]
GIVEN_FLD[22] = cartdet.dept	!LTAXABLE[1]
GIVEN_FLD[24] = CARTDET.GP		!PC3[3]
work$ = ""
! go through notes which are separated by "|"
! and build a string of fixed length fields (30)
! trim and repad with blanks. sometimes get ghost data after field break
CARTDET.notes$=rtrim$(CARTDET.notes$)
pos3=len(cartdet.notes$)   !! significant info
POS1 = 0;POS_ = 1;POS2 = 0
work$ = "" ; x$ = ""
Rem "thru notes
	for pos1=1 to pos3
		if cartdet.notes$[pos1,pos1]="|"
			X$ = X$ + SPACES$;X$[31] = ""
			WORK$ = WORK$,X$
			if LEN(WORK$) >= 600 exit for
			X$ = ""
		else
			x$ = x$ + cartdet.notes$[pos1,pos1]
		endif
	next pos1
	CARTDET.notes$ = work$ +spaces$+spaces$+spaces$
!
FLAG[16] = 1
If GIVEN_PRICE_CODE$ <> "S" Let FLAG[16] = 0
If Not(GIVEN_ITEM$)
  msg$ = "Unable to determine the product code " + DLINE$
  Gosub UPDATE_LOG
  Gosub RPTHEAD
  If FLAG[7] Print #CH_LPT;msg$
  pline = pline + 1
  Gosub RPTHEAD
End If 
If Not(GIVEN_FLD[1])
  msg$ = "Unable to determine the quote quantity " + DLINE$
  Gosub UPDATE_LOG
  Gosub RPTHEAD
  If FLAG[7] Print #CH_LPT;msg$
  pline = pline + 1
  Gosub RPTHEAD
End If 
If Not(GIVEN_PRICE_CODE$)
  GIVEN_PRICE_CODE$ = "S"
End If 
Return 


PARSE_ZLINE: Rem
ZLINE$[1,30] = work$[1,30]
ZLINE$[31,60] = work$[31,60]
Return 
PARSE_MRECORD: Rem
pos2 = SPTYPE$
pos2 = (100 * pos2) + 1
GIVEN_COMMENTS$ = SPACES$
GIVEN_COMMENTS$ = SP1$[1,40] + SPACES$
If SP1$[41,41] <> "" And SP1$[41,65] <> SPACES$[1,25]
  GIVEN_COMMENTS$[41] = SP1$[41,80] + SPACES$
End If 
Return 
MAKEORDER: Rem
msg$ = "Processing quote for customer #" + Str$(GIVEN_FLD[0])
msg$ = msg$ + ". Conf# " + GIVEN_CONF$
Gosub UPDATE_LOG
X2 = GIVEN_FLD[4]
KSLSM$ = X2 Using "###"
Search #ch_slsm,2,1;KSLSM$,REC_SLSM,E
If Not(E)
  Mat Read #ch_slsm,REC_SLSM,0,LOCKTIMEOUT;SLSM_NAME$;
  Mat Read #ch_slsm,REC_SLSM,862;SS3;
  If Not(GIVEN_FLD[7]) And SS3[3]
    GIVEN_FLD[7] = SS3[3]
  End If 
  If Not(GIVEN_FLD[7]) And SS3[2]
  End If 
Else 
  SLSM_NAME$ = " *** Not on File !!! **** ",SPACES$
  REC_SLSM = 0
End If 
If Not(GIVEN_FLD[7]) Let GIVEN_FLD[7] = 1
if headwh$ and headwh$ <> "0" let given_fld[7]=val(headwh$)
pline = 9999
Gosub RPTHEAD
H0 = 0 \ Mat H0 = Zer
H3 = 0 \ Mat H3 = Zer
TOT_SELL = 0
LOCKPORT = 0
qhcurrid=0;qhcurrfact=0
LET SHIPVIA$=""
IF ROUTING>0 AND ROUTING<107
	 READ #CH_CNTRL,130,((ROUTING*12)-12);SHIPVIA$;
ENDIF
IF SHIPVIA$="" OR SHIPVIA$="            "
	LET SHIPVIA$=      "OUR TRUCK   "
ENDIF
!! V0$ = "OUR TRUCK",SPACES$
V0$=SHIPVIA$
H4 = 0 \ Mat H4 = Zer
H5 = 0 \ Mat H5 = Zer
ST3 = 0 \ Mat ST3 = Zer
H1$ = SPACES$
SLSM = 0 \ Mat SLSM = Zer
SCOM = 0 \ Mat SCOM = Zer
SMER = 0 \ Mat SMER = Zer
SCST = 0 \ Mat SCST = Zer
H6 = 0 \ Mat H6 = Zer
HMAT$ = SPACES$
P0$ = SPACES$
S1 = 0 \ Mat S1 = Zer
S1$ = SPACES$;S2$ = SPACES$
S5 = 0
S6 = 0 \ Mat S6 = Zer
SRN = 0 \ Mat SRN = Zer
T1 = 0 \ Mat T1 = Zer
T2 = 0 \ Mat T2 = Zer
JRNL = 0
MCODE = 0 \ Mat MCODE = Zer
For X1 = 0 To 9 \ MCHARGE[X1,0] = 0;MCHARGE[X1,1] = 0 \ Next X1
TOT = 0 \ Mat TOT = Zer
MCTXBL = 0 \ Mat MCTXBL = Zer
DCLVL = 0
If C11[0] Let DCLVL = C11[0]
HOLD = 0 \ Mat HOLD = Zer
Gosub RPTHEAD
If FLAG[12]
  msg$ = "Invalid customer - quote rejected"
  Gosub UPDATE_LOG
  work$ = "=",work$
  If FLAG[7]
    Print #CH_LPT;work$[1,130]
    Print #CH_LPT; Tab (9);"Customer"; Tab (40);"Contact"; Tab (63);"Phone";
    Print #CH_LPT;"" \ pline = pline + 2
    Print #CH_LPT;HDR$[9,18];
    Print #CH_LPT;"  <<<<Invalid customer - quote rejected>>>>";
    Print #CH_LPT;"\15\" \ pline = pline + 2 \ Gosub RPTHEAD
    Print #CH_LPT;" #   Product code"; Tab (18);"Description";
    If FLAG[16]
      Print #CH_LPT; Tab (76);"F Price";
    Else 
      Print #CH_LPT; Tab (76);"S Price";
    End If 
    Print #CH_LPT; Tab (87);"Price"; Tab (94);"Tax?"; Tab (103);"Comments"
    work$ = "-",work$ \ Print #CH_LPT;work$[1,130]
    pline = pline + 2 \ Gosub RPTHEAD
  End If 
  Goto LINECREATE
End If 

! find quote number here
 if not (ordernum)
	x2=0
	READ #CH_CNTRL,20,66;X2
	NEXT_NUM: LET x2=x2+1                          
	IF X2>999998 GOTO max_order:
	GOSUB CHK_ORDER_NUM: \ IF NOT(E) GOTO NEXT_NUM: 
	WRITE #CH_CNTRL,20,66;X2
	H6[2] = 1
else
	let x2=ordernum
	let h6[2]=orgstat
endif


H0[7] = X2
H0[0] = GIVEN_FLD[12]
H0[1] = C1TMP[4];H6[0] = C1TMP[7];S1[0] = 31;T1[0] = 21;H3[1] = 1
S1[1] = H0[7];T1[1] = H0[7]
S2$ = SPACES$;S2$[1,15] = A3TMP$[7,21];S2$[19,20] = A2TMP$[29,30]
H0[4] = GIVEN_FLD[0]
SRN[0] = 0;SRN[1] = 0;SRN[2] = SHIPCUST;SRN[3] = 0;SRN[4] = A0[3]
IF NOT(SRN[2]) LET SRN[2]=H0[4]

OWHT1[1]=HDEPT

H0[9] = cdate[1]
H0[10] = cdate[2]
h0[10]=h0[9]
If GIVEN_FLD[9] Let H0[10] = GIVEN_FLD[9]
H0[11] = GIVEN_FLD[4]
H0[12] = C2TMP[0]
H4[0] = C2TMP[1]
H4[1] = C7TMP[4]
H4[2] = GIVEN_FLD[7]
H3[0] = GIVEN_FLD[6]
H5[0] = GIVEN_FLD[11]
H5[1] = cdate[2]
If GIVEN_FLD[13] Let H5[1] = GIVEN_FLD[13]
H5[6] = 0;H2[0] = 0
H5[7] = GIVEN_FLD[14]
If H5[7] < 1 Or H5[7] > 38 Or Fra(H5[7]) Let H5[7] = 1
H5[8] = GIVEN_FLD[8]
H5[9] = GIVEN_FLD[10]
H5[15] = cdate[1]
If Not(H5[15]) Let H5[15] = cdate[1]
! X$ = Str$(CURTM[0] + (CURTM[1]/100))
LET X$=tim(11) using "&&" + "." + tim(12) using "&&" 
H5[16] = X$
If GIVEN_FLD[15] >= 0 Let H6[7] = Abs(GIVEN_FLD[15])
If H0$[1,20] = SPACES$[1,20] Let H0$[1,20] = A1TMP$[1,20]
KZONE$ = A2TMP$[29,30]
D0 = 0 \ S5 = 1 \ T2$ = "Y",T2$
Gosub GET_ZONE_INFO
If REC_SHIPLIST <> -1
  If REC_SHIPLIST > 0 Goto GOT_SHIPLIST
  KSHIPLIST$ = SRN[2] Using "######.&&&&&&"
  Search #ch_shiplist,2,1;KSHIPLIST$,REC_SHIPLIST,E \ If E > 2 Gosub ERR_SEARCH_LOGGED
  If Not(E)
GOT_SHIPLIST: Rem
    Mat Read #ch_shiplist,REC_SHIPLIST,0;SA$
    Mat Read #ch_shiplist,REC_SHIPLIST,142;SC1
    Mat Read #ch_shiplist,REC_SHIPLIST,150;SR$
    Mat Read #ch_shiplist,REC_SHIPLIST,184;SL2
    Mat Read #ch_shiplist,REC_SHIPLIST,204;SI$
    Unlock #ch_shiplist
    SRN[1] = Int(Fra(SC1) * 10 ^ 6)
    SRN[3] = 1
    If SRN[1] > 0 Let SRN[3] = 2
    H4[1] = SR$[26,31]
    If SL2[0] Let H4[0] = SL2[0]
    If SL2[3]>0 Let A0[3] = SL2[3]
    If SL2[4] Let DCLVL = SL2[4]
    H5[12] = SL2[1]
    IF SL2[3]>0 LET SRN[4] = SL2[3]
    S2$[19,20] = SR$[32,33]
    A1TMP$[31,137] = SA$[1,107]
    A2TMP$[1,10] = SA$[108,117]
    A3TMP$[7,21] = SR$[13,25]+"            "  ! there have been nulss in sr$
    KZONE$ = S2$[19,20]
    Gosub GET_ZONE_INFO
  Else 
    REC_SHIPLIST = 0
    SR$ = SPACES$
    Mat SL2 = Zer \ SL2 = 0
  End If 
Else 
  A1TMP$[31,137] = SA$[1,107]
  A2TMP$[1,10] = SA$[108,117]
  if given_fld[5] < 0 srn[3]=5
End If 
IF ROUTING<1 OR ROUTING>106
	If SR$[1,12] <> SPACES$[1,12] Let V0$ = SR$[1,12]
ENDIF
S1$[1,107] = A1TMP$[31,137];S1$[108,117] = A2TMP$[1,10]
Read #ch_tax,H4[0],20,LOCKTIMEOUT;X2;
T2[2] = X2
P0$ = GIVEN_PO$
msg$ = "Creating quote #" + Str$(H0[7])
Gosub UPDATE_LOG
work$ = "=",work$
If FLAG[7]
  Print #CH_LPT;work$[1,130]
  Print #CH_LPT; Tab (9);"Customer"; Tab (40);"Contact"; Tab (63);"Phone";
  Print #CH_LPT; Tab (76);"Quote#"; Tab (86);"P.O. #"; Tab (103);"Ship to   Date: ";
  work$ = H0[10] Using "&&&&&&"
  Call FormatDate(work$)
  Print #CH_LPT;work$;
  Print #CH_LPT;"" \ pline = pline + 2
  Print #CH_LPT; Using "###### ";C1TMP[1];A1TMP$[31,60];
  Print #CH_LPT; Tab (40);A1TMP$[1,20]; Tab (63);A1TMP$[21,30];
  Print #CH_LPT; Using "######"; Tab (76);H0[7]; Tab (86);GIVEN_PO$;
  If GIVEN_FLD[5] >= 0 And Not(REC_SHIPLIST) Print #CH_LPT; Tab (110);"Same";
  If GIVEN_FLD[5] = 0 And REC_SHIPLIST > 0 Print #CH_LPT; Tab (110);"Default";
  If GIVEN_FLD[5] > 0 And REC_SHIPLIST > 0 Print #CH_LPT; Tab (110);Str$(GIVEN_FLD[5]);
  If GIVEN_FLD[5] < 0 Print #CH_LPT; Tab (110);"Manual";
  Print #CH_LPT;"" \ pline = pline + 1 \ Gosub RPTHEAD
  Print #CH_LPT;"" \ pline = pline + 1 \ Gosub RPTHEAD
  Print #CH_LPT;" #   Product code"; Tab (18);"Description";
  Print #CH_LPT; Tab (54);"Available"; Tab (68);"Quoted";
  If FLAG[16]
    Print #CH_LPT; Tab (76);"F Price";
  Else 
    Print #CH_LPT; Tab (76);"S Price";
  End If 
  Print #CH_LPT; Tab (87);"Price"; Tab (94);"Tax?"; Tab (103);"Comments"
  work$ = "-",work$ \ Print #CH_LPT;work$[1,130]
  pline = pline + 2 \ Gosub RPTHEAD
End If 
if not (ordernum)
E = 2 \ Search #ch_qoh,1,0;work$,REC_qoh,E \ If E Gosub ERR_SEARCH_LOGGED
E = 2 \ Search #ch_qos,1,0;work$,REC_qos,E \ If E Gosub ERR_SEARCH_LOGGED
E = 2 \ Search #ch_qot,1,0;work$,REC_qot,E \ If E Gosub ERR_SEARCH_LOGGED
H0[2] = REC_qos;H0[3] = REC_qot
ELSE
H0[2] = REC_qOS;H0[3] = REC_qOT
endif
FLESPEC[1] = H0[7]
FLESPEC[2] = REC_qoh
Call Time(SDATE$)
CURTM[0] = SDATE$[15,16]
CURTM[1] = SDATE$[18,19]
CURTM[2] = SDATE$[21,22]
CURTM[3] = CURTM[0] * 10000 + CURTM[1] * 100 + CURTM[2]
If H0[10] = cdate[1] And CURTM[3] > CUTTIME
  X2 = H0[10] \ Gosub YMD2JUL \ X2 = 0
  X2 = X2 + 1
  work$ = X2 Using "&&&&&"
  JDATE[0] = X2 \ JDATE[1] = X2 \ E = 0
  Call "JULIANUTIL",JDATE[],X$,E
  X2 = X$
  H0[10] = X2
  PARAM[0] = H4[2];PARAM[1] = H5[8]
  cdate[3] = H0[10];cdate[4] = 1;cdate[5] = 0
  Call "validdate",cdate[3],cdate[4],cdate[5],PARAM[]
  If cdate[4] <> -2 Let H0[10] = cdate[3]
End If 
Gosub MISCCHARGE
Gosub WRITEHEADS
if not (ordernum)
	work$ = H0[0] Using "##";work$[3] = H0[7] Using "######"
	Search #ch_qoh,4,1;work$,REC_qoh,E \ If E Gosub ERR_SEARCH_LOGGED
	work$ = H0[4] Using "#######";work$[8] = H0[7] Using "######"
	Search #ch_qoh,4,2;work$,REC_qoh,E \ If E Gosub ERR_SEARCH_LOGGED
	work$ = H0[11] Using "###";work$[4] = H0[7] Using "###### "
	Search #ch_qoh,4,3;work$,REC_qoh,E \ If E Gosub ERR_SEARCH_LOGGED
else
	if not (h6[2]) let h6[2]=orgstat
	If h6[2]<1 let h6[2]=1
	if h6[2]>3 let h6[2]=1
	let h0[0]=h6[2]
	work$ = H0[0] Using "##";work$[3] = H0[7] Using "######"
	search #ch_qoh,4,1;work$,rec_qoh,e\if e gosub err_search_logged
	let work$[1,2]="91"
	search #ch_qoh,5,1;work$,rec_qoh,e\if e gosub err_search_logged
	gosub writeheads
endif
PRG_VAR[0] = PRG_VAR[0] + 1
LINECREATE: Rem
pline[3] = 0
DLINE$ = HDR$
LCLOOP1: Gosub GETWDLINE
If Not(FLAG[14])
  Gosub PARSE_LRECORD
  mat prg_var = zer  ! clear out elements 1-99 for each line
  If H0[7]
  Else 
  End If 
  FLAG[9] = 0
ZLNLOOP: Rem
  qlcurrid=0;qlcurrfact=0
  L2 = 0 \ Mat L2 = Zer
  L3 = 0 \ Mat L3 = Zer
  L4 = 0 \ Mat L4 = Zer
  L5 = 0 \ Mat L5 = Zer
  L6 = 0 \ Mat L6 = Zer
  L6$ = SPACES$
  L1$ = SPACES$
  L9 = 0 \ Mat L9 = Zer
  L7 = 0 \ Mat L7 = Zer
  PL = 0 \ Mat PL = Zer
  UN = 0 \ Mat UN = Zer
  S2 = 0 \ Mat S2 = Zer
  S3 = 0 \ Mat S3 = Zer
  MT$ = SPACES$
  S3$ = SPACES$
  OLM = 0 \ Mat OLM = Zer
  EUN = 0 \ Mat EUN = Zer
  UNF = 0 \ Mat UNF = Zer
  LCO = 0 \ Mat LCO = Zer
  CST = 0
  LTAX1 = 0
  LTAX2 = 0
  L2[0] = 11;L2[1] = H0[7];L3[1] = 1;L4[3] = H4[2]
  L4[1] = H0[11]
  L9[1] = GIVEN_FLD[22] \ If Not(L9[1]) Let L9[1] = GIVEN_FLD[6]
  l9[1]=cartdet.dept
  IF H5[7]=2 LET L3[1]=0 ! DIRECT ORDER SET STOCK UPDATE FLAG TO NO
  IF H5[7]=3 AND P60$[22,22]="N" let l3[1]=0 ! indirect stock update flag = no
  FLAG[16] = 1
  If GIVEN_PRICE_CODE$ <> "S" Let FLAG[16] = 0
  if cartdet.ltype$="9" and not(flag[9])
	let l3[1]=0 ! nonstock item 
	GOSUB BUILD_NONSTOCK:
	goto GETTAXBYLINE:
	!GOTO ALLOCATEDONE:
  Endif
  If FLAG[9]
    L3[0] = 1;L3[1] = 0;L3[3] = 20;S2[0] = 3
    if cartdet.ltype$="9" let l3[1]=0 ! nonstock item
    pline[3] = pline[3] + 1;L3[2] = pline[3]
    L6$[1,30] = ZLINE$[1,30] + SPACES$
    L6$[31,60] = ZLINE$[31,60] + SPACES$
    L1$ = "Z" + SPACES$
    L1$[17,20] = "MISC"
    If FLAG[7]
      Print #CH_LPT; Using "###"; Tab (0);L3[2];
      Print #CH_LPT; Tab (5);"Z LINE   ";
      Print #CH_LPT; Tab (20);ZLINE$[1,30];
      Print #CH_LPT; Tab (60);ZLINE$[31,60];
      Print #CH_LPT;"" \ pline = pline + 1 \ Gosub RPTHEAD
    End If 
    Goto BUILD_qol
  End If 
if cartdet.ltype$<>"9"  ! not a message line
  work$ = GIVEN_ITEM$ + SPACES$
  Search #ch_prod,2,1;work$,REC_PROD,E \ If E > 1 Gosub ERR_SEARCH_LOGGED
  If GIVEN_ITEM$[1,5] = "     " Or GIVEN_FLD[1] <= 0 Let E = 1
  If E
    If FLAG[7]
      Print #CH_LPT; Tab (5);work$;
      X3[9] = GIVEN_FLD[1]
      Print #CH_LPT; Using "-----# "; Tab (65);X3[9];
      Print #CH_LPT;CARTDET.QUM$;
      Print #CH_LPT; Tab (80);Str$(GIVEN_FLD[2]);
      Print #CH_LPT; Tab (103);"<<< Invalid Product Code";
      Print #CH_LPT;"" \ pline = pline + 1 \ Gosub RPTHEAD
    End If 
    REC_PROD = 0
    Goto LCLOOP1
  Else 
    pline[3] = pline[3] + 1;L3[2] = pline[3]
    Mat Read #ch_prod,REC_PROD,0;A$
    Mat Read #ch_prod,REC_PROD,156;B
    Mat Read #ch_prod,REC_PROD,256;A
    Mat Read #ch_prod,REC_PROD,460;A1
    Mat Read #ch_prod,REC_PROD,512;PFU1
    Mat Read #ch_prod,REC_PROD,554;PFU2
    Mat Read #ch_prod,REC_PROD,894;PR_C4
    Read #ch_prod,REC_PROD,938;PF_LOAD2
    Mat Read #ch_prod,REC_PROD,944;PR_A2$
    Mat Read #ch_prod,REC_PROD,990;PLV
    S3$ = " ",S3$
    Gosub GET_QTY_AVAIL
    If AVAIL[1] <= 0 And PR_A2$ <> "" And PR_A2$[1,3] <> "   "
      Mat SUPERCEDE_LIST = Zer \ X[1] = 1;X[2] = FALSE
SUPER_LOOP: Rem
      SUPERCEDE_LIST[X[1]] = REC_PROD
      For I = 1 To X[1] - 1
        If REC_PROD = SUPERCEDE_LIST[I]
          X[2] = TRUE
          I = X[1] - 1
        End If 
      Next I
      If X[1] >= 50 Or X[2]
        REC_PROD = SUPERCEDE_LIST[1]
        Goto EXIT_SUPER_LOOP
      End If 
      SUPER_PROD$ = PR_A2$[1,12]
      Search #ch_prod,2,1;SUPER_PROD$,REC_PROD,E
      If E > 2 Gosub ERR_SEARCH_LOGGED
      If E
        REC_PROD = SUPERCEDE_LIST[1]
        Goto EXIT_SUPER_LOOP
      End If 
      Mat Read #ch_prod,REC_PROD,0;A$;
      Mat Read #ch_prod,REC_PROD,944,LOCKTIMEOUT;PR_A2$;
      Gosub GET_QTY_AVAIL
      If AVAIL[1] <= 0 And PR_A2$ <> "" And PR_A2$[1,3] <> "   "
        X[1] = X[1] + 1
        Goto SUPER_LOOP
      Else 
        work$ = SUPER_PROD$
        GIVEN_ITEM$ = SUPER_PROD$ + SPACES$
        S3[16] = 2
      End If 
EXIT_SUPER_LOOP: Rem
      Mat Read #ch_prod,REC_PROD,0;A$
      Mat Read #ch_prod,REC_PROD,156;B
      Mat Read #ch_prod,REC_PROD,256;A
      Mat Read #ch_prod,REC_PROD,460;A1
      Mat Read #ch_prod,REC_PROD,512;PFU1
      Mat Read #ch_prod,REC_PROD,554;PFU2
      Mat Read #ch_prod,REC_PROD,894;PR_C4
      Read #ch_prod,REC_PROD,938;PF_LOAD2
      Mat Read #ch_prod,REC_PROD,944;PR_A2$
      Mat Read #ch_prod,REC_PROD,990;PLV
    End If 
    S3$[1,20] = A$[93,112]
    If SUPERCD$[1,2] <> "  " And SUPERCD$[1,1] <> ""
      S3$[21,32] = SUPERCD$
      S3[16] = 2
    End If 
else
	! load the factor for the product file
endif
    If Not(A1[3]) Let A1[3] = 1
    If cartdet.PUM$ <> "    "
      KCCODES$ = cartdet.PUM$ + "    "
      Search #ch_ccodes,2,1;KCCODES$,REC_CCODES,E
      If E
        PRG_VAR[5] = 0
        If cartdet.PUM$[1,3] = "LOT" Let REC_CCODES = -2
        If cartdet.PUM$[1,3] = "CWT" Let REC_CCODES = -1
        If A$[127,127] = "Y" And cartdet.PUM$[1,3] = "LB " Let REC_CCODES = -3
        cartdet.PUM$ = "    "
      End If 
      If A$[127,127] = "Y" And cartdet.PUM$[1,3] = "LB " Let REC_CCODES = -3 !in case lb is found
      If REC_CCODES <> 0
        FLAG[13] = TRUE
        For I = 0 To 7
          If REC_CCODES = PFU1[I] Let FLAG[13] = FALSE
        Next I
        If Not(FLAG[13]) Or REC_CCODES < 0
          If REC_CCODES = -2 Let CCD$[11,14] = "LOT "
          If REC_CCODES = -1 Let CCD$[11,14] = "CWT "
          If REC_CCODES = -3 Let CCD$[11,14] = "LB  "
          If REC_CCODES > 0 Mat Read #ch_ccodes,REC_CCODES,0,LOCKTIMEOUT;CCD$;
          PRG_VAR[5] = REC_CCODES
        Else 
          PRG_VAR[5] = 0
        End If 
      End If 
    Else 
      PRG_VAR[5] = 0
    End If 
	If cartdet.COSTUM$ <> "    "
		KCCODES$ = cartdet.COSTUM$ + "    "
		Search #ch_ccodes,2,1;KCCODES$,REC_CCODES,E
		If E
			PRG_VAR[12] = 0
			If cartdet.COSTUM$[1,3] = "LOT" Let REC_CCODES = -2
			If cartdet.COSTUM$[1,3] = "CWT" Let REC_CCODES = -1
			If A$[127,127] = "Y" And cartdet.COSTUM$[1,3] = "LB " Let REC_CCODES = -3
			cartdet.COSTUM$ = "    "
		End If
		If A$[127,127] = "Y" And cartdet.COSTUM$[1,3] = "LB " Let REC_CCODES = -3 !in case lb is found
		If REC_CCODES <> 0
			FLAG[13] = TRUE
			For I = 0 To 7
				If REC_CCODES = PFU1[I] Let FLAG[13] = FALSE
			Next I
			If Not(FLAG[13]) Or REC_CCODES < 0
				If REC_CCODES = -2 Let CCD$[11,14] = "LOT "
				If REC_CCODES = -1 Let CCD$[11,14] = "CWT "
				If REC_CCODES = -3 Let CCD$[11,14] = "LB  "
				If REC_CCODES > 0 Mat Read #ch_ccodes,REC_CCODES,0,LOCKTIMEOUT;CCD$;
				PRG_VAR[12] = REC_CCODES
			Else
				PRG_VAR[12] = 0
			End If
		End If
	Else
		PRG_VAR[12] = 0
	End If

    FLAG[13] = FALSE
    If CARTDET.QUM$ <> "    "
      KCCODES$ = CARTDET.QUM$ + "    "
      Search #ch_ccodes,2,1;KCCODES$,REC_CCODES,E
      If E
        CARTDET.QUM$ = "    "
      Else 
        FLAG[13] = TRUE
        For I = 0 To 7
          If REC_CCODES = PFU1[I] Let FLAG[13] = FALSE
        Next I
        If Not(FLAG[13])
          If REC_CCODES = -2 Let CCD$[11,14] = "LOT "
          If REC_CCODES = -1 Let CCD$[11,14] = "CWT "
          If REC_CCODES > 0 Mat Read #ch_ccodes,REC_CCODES,0,LOCKTIMEOUT;CCD$;
        Else 
          CCD$ = "Invalid!  " + CARTDET.QUM$
          REC_CCODES = 0
        End If 
      End If 
    End If 
    If CARTDET.QUM$ = "    "
      REC_CCODES = PFU1[9]
      If REC_CCODES = -2 Let CCD$[11,14] = "LOT "
      If REC_CCODES = -1 Let CCD$[11,14] = "CWT "
      If REC_CCODES > 0 Mat Read #ch_ccodes,REC_CCODES,0,LOCKTIMEOUT;CCD$;
      CARTDET.QUM$ = CCD$[11,14] + SPACES$
      FLAG[13] = FALSE
    End If 
    If Not(FLAG[13])
      PRG_VAR[4] = REC_CCODES
      If Not(PRG_VAR[5]) Let PRG_VAR[5] = PFU1[12]
	If Not(PRG_VAR[12]) Let PRG_VAR[12] = PFU1[11]
      
    End If 
    If FLAG[13]
      If Not(PRG_VAR[5]) Let PRG_VAR[5] = PFU1[12]
	If Not(PRG_VAR[12]) Let PRG_VAR[12] = PFU1[11]
      PRG_VAR[4] = PFU1[9]
    End If 
    If FLAG[12] Or FLAG[13]
      L1$[1,12] = GIVEN_ITEM$ + SPACES$
      L6$[1,30] = A$[9,38];L6$[31,60] = A$[63,92]
      If TAX[A1[7]] Let L6[5] = H4[0]
      If FLAG[7]
        Print #CH_LPT; Using "###  ";pline[3];GIVEN_ITEM$;"  ";A$[9,38];
        X3[9] = GIVEN_FLD[1]
        Print #CH_LPT; Using "-----# "; Tab (65);X3[9];
        Print #CH_LPT;CARTDET.QUM$;
        Print #CH_LPT; Tab (80);L9[1] Using "##";
        If Not(FLAG[12])
          If L6[5]
            Print #CH_LPT; Tab (96);"Y";
          Else 
            Print #CH_LPT; Tab (96);"N";
          End If 
        Else 
          Print #CH_LPT; Tab (96);"-";
        End If 
      End If 
      If FLAG[13]
        If FLAG[7] Print #CH_LPT; Tab (103);"<<< Invalid unit of measure"
        msg$ = "Invalid u/m: " + CARTDET.QUM$
        Gosub UPDATE_LOG
      End If 
      If FLAG[7] Print #CH_LPT;""
      pline = pline + 1
      Gosub RPTHEAD
      Unlock #ch_prod
      Goto LCLOOP1
    End If 
    work$ = GIVEN_ITEM$;work$[13] = L4[3] Using "##"
    if cartdet.ltype$<>"9"
    If P9$[33,33] = "Y"
      Search #ch_prwh,2,1;work$,REC_PRWH,E \ If E > 1 Gosub ERR_SEARCH_LOGGED
      If E = 1
        WHBLD[0] = ch_prwh;WHBLD[1] = L4[3];WHBLD[2] = B[24]
        Call "MXWHCREATE",work$[1,12],WHBLD[]
        REC_PRWH = WHBLD[2];WHBLD[2] = 0
        If Err 0 Gosub ERR_TRAP_LOGGED
      End If 
      Mat Read #ch_prwh,REC_PRWH,38;W2
      Mat Read #ch_prwh,REC_PRWH,78;W3
      Mat Read #ch_prwh,REC_PRWH,420;W0
      Mat Read #ch_prwh,REC_PRWH,780;WHLV
      FLAG[2] = TRUE
    Else 
      FLAG[2] = FALSE
    End If 
else
	FLAG[2]=FALSE
endif
    work$ = " ",work$;work$ = A$[152,155]
    Search #ch_comcd,2,1;work$,REC_COMCD,E
    If E Gosub ERR_SEARCH_LOGGED
    L4[0] = REC_PROD;L4[3] = H4[2]
if cartdet.ltype$<>"9"
    If P9$[41,41] = "W" Call "CHKWRASL",L4[3],RASL[]
endif
    If Err 0 Gosub ERR_TRAP_LOGGED
    L1$[1,12] = GIVEN_ITEM$ + SPACES$
    L1$[17,20] = A$[152,155]
    L6$[1,30] = A$[9,38];L6$[31,60] = A$[63,92]
    If TAX[A1[7]] Let L6[5] = H4[0]
    L6[5] = GIVEN_FLD[16]
    If P60$[42,42] = "T" And L6[5] <> 0 Let L6[5] = 1
    MT$[1,1] = A$[156,156]
    If B[11] Let L3[3] = B[11] Else Let L3[3] = 1
    S3[14] = B[24] \ If FLAG[10] And W2[3] Let S3[14] = W2[3]
    L6[2] = B[23]
    L6[4] = A[6] \ If Not(L6[4]) Let L6[4] = 1
    PRG_VAR[6] = GIVEN_FLD[1]
    CNVTA = PRG_VAR[6];CNVTU[0] = PRG_VAR[4];CNVTU[1] = 0;CNVTU[2] = 1
    Call "mxprconv5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
    If Err 0 Gosub ERR_TRAP_LOGGED
    If FLAG Let E = FLAG \ Gosub ERR_SEARCH_LOGGED
    L7[2] = CNVTA;L7[4] = CNVTA;L7[5] = CNVTA;UN[0] = PRG_VAR[4]
    if cartdet.ltype$<>"9"
	AVAIL[1] = W3[0] - W3[2]
	If P9$[28,28] = "Y" Let AVAIL[1] = AVAIL[1] + W3[1]
	CNVTA = AVAIL[1];CNVTU[0] = 0;CNVTU[1] = PRG_VAR[4];CNVTU[2] = 1
	Call "mxprconv5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
	If FLAG Let E = FLAG \ Gosub ERR_SEARCH_LOGGED
	AVAIL[0] = CNVTA
    else
	avail[0]=0
    endif
    if cartdet.ltype$<>"9" goto qnoavail
    If TYPE$ = "QUOTE" Goto QNOAVAIL
    If P60$[27,27] <> "N" And PRG_VAR[6] > AVAIL[0] And FLAG[6] And W0[0] <> 1
      If AVAIL[0] >= 1
        CNVTA = Int(AVAIL[0]);PRG_VAR[7] = PRG_VAR[6] - Int(AVAIL[0])
      Else 
        CNVTA = 0;PRG_VAR[7] = PRG_VAR[6]
      End If 
      CNVTU[0] = PRG_VAR[4];CNVTU[1] = 0;CNVTU[2] = 1
      If CNVTA
        Call "mxprconv5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
        If FLAG Let E = FLAG \ Gosub ERR_SEARCH_LOGGED
      End If 
      L7[4] = CNVTA
      If W0[0] = 1 Let PRG_VAR[7] = 0
      CNVTA = PRG_VAR[7]
      If CNVTA
        Call "mxprconv5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
        If FLAG Let E = FLAG \ Gosub ERR_SEARCH_LOGGED
      End If 
      L7[3] = CNVTA
    End If 
    If PRG_VAR[6] > AVAIL[0] And (Not(FLAG[6]) Or W0[0] = 1)
      If AVAIL[0] >= 1
        CNVTA = Int(AVAIL[0])
      Else 
        CNVTA = 0
      End If 
      CNVTU[0] = PRG_VAR[4];CNVTU[1] = 0;CNVTU[2] = 1
      If CNVTA
        Call "mxprconv5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
        If FLAG Let E = FLAG \ Gosub ERR_SEARCH_LOGGED
      End If 
      L7[4] = CNVTA
    End If 
    If PRG_VAR[6] > AVAIL[0] And (P60$[27,27] = "N" Or Not(FLAG[6]))
      X1 = 2
      Gosub CHECK_HOLD_PASSWD
      If FOUND Let HOLD[X1] = TRUE
    End If 
QNOAVAIL: Rem
    UN[2] = prg_var[12]
    Mat Read #ch_prtype,H6[0],28,LOCKTIMEOUT;PT;
    FLAG[15] = PT[H5[7] - 1]
    If Not(FLAG[15]) Let FLAG[15] = P60$[29,29]
    If FLAG[10]
      L5[1] = W3[17]
      If FLAG[15] = 2
        L5[1] = W3[14]
      Else 
        If FLAG[15] = 3
          L5[1] = W3[15]
        Else 
          If FLAG[15] = 4
            L5[1] = W3[16]
          Else 
            If FLAG[15] = 5
              L5[1] = W3[18]
            End If 
          End If 
        End If 
      End If 
    Else 
      L5[1] = B[8]
      If FLAG[15] = 2
        L5[1] = PF_LOAD2
      Else 
        If FLAG[15] = 3
          L5[1] = B[21]
        Else 
          If FLAG[15] = 4
            L5[1] = B[10]
          Else 
            If FLAG[15] = 5
              L5[1] = PR_C4[4]
            End If 
          End If 
        End If 
      End If 
    End If 
    FLAG[17] = FALSE
    If GIVEN_FLD[23] AND S3[16] = 0  !! NOT ALT/SUPER, USE CART COST
      UN[1] = PRG_VAR[12]
      If UN[1] = 0 Let UN[1] = PFU1[11]
      CNVTU[0] = UN[1];CNVTU[1] = 0;CNVTU[2] = 2;CNVTA = GIVEN_FLD[23]
      Call "mxprconv5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
      If FLAG Let E = FLAG \ Gosub ERR_SEARCH_LOGGED
      L5[1] = cnvta ! AMOUNT
      PRG_VAR[11] =  cnvta ! AMOUNT
	ELSE
	  PRG_VAR[11] = 0
    End If 
    FLAG[3] = FALSE;X2 = 0
    If P9$[44,44] = "Y" And GIVEN_FLD[22] Let X2 = GIVEN_FLD[22]
    work$ = C1[1] Using "######";work$[7,10] = X2 Using "####"
    work$[10,30] = L1$[1,12],SPACES$;work$[31] = ""
    Search #ch_lastpr,2,1;work$,REC_LASTPR,E
    If E Let REC_LASTPR = 0
    UN[1] = PRG_VAR[5]
    If UN[1] = 0 Let UN[1] = PFU1[12]
    S3[4] = FNR(Abs((L6[4] * L7[4]) / A[5]))
	raw_wgt = Abs((L6[4] * L7[4]) / A[5])
    L7[8] = 0
	if given_fld[18] > 0 then l7[8]=given_fld[18]
	If GIVEN_FLD[18] < 0
		Let L7[8] = GIVEN_FLD[18]
		If UN[1] = 0 Let UN[1] = PFU1[12]
		CNVTU[0] = UN[1];CNVTU[1] = 0;CNVTU[2] = 2;CNVTA = L7[8]
		Call "mxprconv5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
		If FLAG Let E = FLAG \ Gosub ERR_SEARCH_LOGGED
		L7[8] = cnvta ! AMOUNT
	ENDIF
    ROL0 = 0
	if given_fld[19] > 0 then rol0=given_fld[19]
	If GIVEN_FLD[19] <0
		Let ROL0 = GIVEN_FLD[19]
		CNVTU[0] = UN[1];CNVTU[1] = 0;CNVTU[2] = 2;CNVTA = ROL0
		Call "mxprconv5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
		If FLAG Let E = FLAG \ Gosub ERR_SEARCH_LOGGED
		ROL0 = cnvta ! AMOUNT
	ENDIF
	fleptr[0,0] = ch_cntrl;fleptr[0,1] = lpppcust
    FLEPTR[1,0] = ch_prod;FLEPTR[1,1] = REC_PROD
    FLEPTR[2,0] = ch_prwh;FLEPTR[2,1] = REC_PRWH
    FLEPTR[3,0] = ch_comcd;FLEPTR[3,1] = REC_COMCD
    FLEPTR[4,0] = ch_lastpr;FLEPTR[4,1] = REC_LASTPR
    FLEPTR[5,0] = ch_sprice;FLEPTR[5,1] = 0
    FLEPTR[6,0] = ch_ctrct;FLEPTR[6,1] = 0
    FLEPTR[7,0] = ch_ccodes;FLEPTR[7,1] = 0
    FLEPTR[8,0] = ch_brktbl;FLEPTR[8,1] = 0
    SPECS[0] = 0
    SPECS[1] = L7[2]
    If raw_wgt
      SPECS[2] = raw_wgt
    Else 
      If Not(A[5]) Let A[5] = 1
      X3[8] = ((A[6] * L7[2]) / A[5])
      SPECS[2] = X3[8]
    End If 
    SPECS[3] = H0[4]
    SPECS[4] = L4[3]
    SPECS[5] = H0[9]
    SPECS[6] = L9[1]
    SPECS[7] = H6[0]
    SPECS[8] = H5[7]
    SPECS[9] = FLAG[15]
    SPECS[10] = 0
    SPECS[11] = 0
    SPECS[12] = 0
    SPECS[13] = UN[0]
    SPECS[14] = UN[1]
    SPECS[15] = UN[2]
    SPECS[16] = L7[8]
    SPECS[17] = L5[1]
    SPECS[18] = CST[0]
    SPECS[19] = 0
    SPECS[40] = ROL0
    ! Call "price",FLEPTR[],SPECS[],MSGDESC$
    !Call "price.dl4",fleptr[],SPECS[],msgdesc$,coid,1,HOME$+"/files/6/dx.log"
	if custom_customer$ = "BURKE"
		call "price.dl4",fleptr[],specs[],msgdesc$,intco,debug,HOME$+"/prog/custom/files/6/dx.log"
	else
		Call SysPriceCalc(e$,FLEPTR[],SPECS[],MSGDESC$,1,HOME$+"/prog/custom/files/6/dx.log")
	end if
	If SPECS[0] Let E = SPECS[0] \ Gosub ERR_SEARCH_LOGGED
    UN[1] = SPECS[14]
    !UN[2] = SPECS[15]
    L7[8] = SPECS[16]
    L5[1] = SPECS[17]
    CST[0] = SPECS[18]
    PRG_VAR[2] = SPECS[20]
    L6[1] = SPECS[21]
    L6[0] = SPECS[22]
    LCO[1] = SPECS[24]
    L9[0] = SPECS[25]
    LCO[0] = SPECS[26]
    OLM[2] = SPECS[27]
    OLM[4] = SPECS[28]
    L7[9] = SPECS[29]
    ROL0 = SPECS[40]
    If PRG_VAR[2] Let FLAG[3] = TRUE
    If L5[1] <= 0 And PRG_VAR[11] Let L5[1] = PRG_VAR[11]
	IF ORDERNUM  !! EDITTING AN EXISTING QUOTE
		IF fnn(l5[1])<>fnn(prg_var[11]) then l5[1]=prg_var[11]  !! if new cost different than 1 cent, use it
	ENDIF
    If (PRG_VAR[11] OR S3[16] <> 0) And fnn(L5[1]) <> fnn(PRG_VAR[11]) Let FLAG[17] = TRUE
    If GIVEN_PRICE_CODE$ <> "S"
      If Not(PRG_VAR[5])
        UN[1] = PFU1[12]
      Else 
        UN[1] = PRG_VAR[5]
      End If 
      L6[0] = 0;L6[1] = 0
      ! L9[0] = -7;OLM[2] = 0;L7[9] = 0
      OLM[2] = 0;L7[9] = 0
      If FLAG[17] And GIVEN_FLD[24] > 0
        X3[1] = L5[1]
        If ROL0 < 0
          AMOUNT = Abs(ROL0)
        End If 
        X2 = GIVEN_FLD[24]
		IF X2<>100 
			!X3 = (X3[1] / ((100 - X2) / 100))
			x3[0] = -l5[1] / ((cartdet.gp / 100) -1)  !! in base
		ELSE
			X3[0] = 0
		ENDIF
		L9[0] = 14
		CNVTA = given_fld[2];CNVTU[0] = un[1];CNVTU[1] = 0;CNVTU[2] = 2
		Call "mxprconv5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
		if abs(x3[0]-cnvta)<.0001
			x3=cnvta
		endif
		l5[2] = x3
		CNVTA = X3;CNVTU[0] = 0;CNVTU[1] = UN[1];CNVTU[2] = 2
		Call "mxprconv5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
		If FLAG Let E = FLAG \ Gosub ERR_SEARCH_LOGGED
		GIVEN_FLD[2] = CNVTA
	   End If 
    End If 
    PRG_VAR[8] = GIVEN_FLD[2]
    CNVTA = PRG_VAR[8];CNVTU[0] = UN[1];CNVTU[1] = 0;CNVTU[2] = 2
	Call "mxprconv5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
    If FLAG Let E = FLAG \ Gosub ERR_SEARCH_LOGGED
	if ordernum  !! is a quote edit of existing quote, see if price really really changed
		x3 = PRG_VAR[8]
		for i=1 TO 7
			if pfu1[i]=UN[1]
				X3 = GIVEN_FLD[2]/PFU2[I-1]
			ENDIF
		NEXT I
		IF abs(x3-cnvta)<.01 cnvta=x3
	endif
    L5[2] = CNVTA;OLM[3] = L5[2]
    L7[6] = L5[2]
    ! need to keep the value of the price origin and the
    ! special price contract # if the calculated price and
    ! the price coming in are the same (have not been
    ! overridden).
	if fnn(PRG_VAR[2]) = fnn(L5[2])
		OLM[2]=specs[27]
    else ! unit price <> calculated: origin = manual
		l9[0] = -7
    end if
    FLAG[4] = FALSE;FLAG[5] = FALSE
    If GIVEN_PRC_TP$ = "O"
	  If FLAG[3] And fnn(L5[2]) < fnn(PRG_VAR[2]) Let FLAG[5] = TRUE
      X1 = 4 \ Gosub CHECK_HOLD_PASSWD
      If FOUND Let HOLD[X1] = TRUE
    End If 
    If GIVEN_PRC_TP$ = "P"
	  If FLAG[3] And fnn(L5[2]) < fnn(PRG_VAR[2]) Let FLAG[5] = TRUE
      If P60$[33,33] = "Y" And P60$[12,12] <> "Y" And L5[2] > 0
        EUN[2] = 1
      End If 
      X1 = 4 \ Gosub CHECK_HOLD_PASSWD
      If FOUND Let HOLD[X1] = TRUE
    End If 
    ! If PRG_VAR[8] <= 0 Let GIVEN_PRICE_CODE$ = "S"   ! need to allow zero price for dispensers, etc.
    If GIVEN_PRICE_CODE$ = "S" And FLAG[3] = TRUE
      if fnn(L5[2]) <> fnn(PRG_VAR[2]) L5[2] = PRG_VAR[2]
      OLM[3] = L5[2];L7[6] = L5[2]
    End If 
    OLM[3] = L5[2] - L6[1]
    OLM[3] = OLM[3] - (OLM[3] * (L6[0] / 100))
    If L7[8]
      If L7[8] < 0
        AMOUNT = Abs(L7[8])
        OLM[3] = OLM[3] + AMOUNT
      Else 
        OLM[3] = OLM[3] + (OLM[3] * (L7[8] / 100))
      End If 
    End If 
    let netcost=l5[1]
    if ROL0<>0
	if ROL0<0
		let amount=abs(ROL0)
		let netcost=netcost+amount
	else
		let netcost=netcost+(netcost*ROL0/100)
	endif
    endif
    L7[6] = L5[2]
    CNVTA = OLM[3];CNVTU[0] = 0;CNVTU[1] = UN[1];CNVTU[2] = 2
    Call "mxprconv5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
    If FLAG Let E = FLAG \ Gosub ERR_SEARCH_LOGGED
    PRG_VAR[8] = CNVTA
    CNVTA = PRG_VAR[8];CNVTU[0] = UN[1];CNVTU[1] = 0;CNVTU[2] = 2
    Call "mxprconv5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
    If FLAG Let E = FLAG \ Gosub ERR_SEARCH_LOGGED
    OLM[3] = CNVTA
    If Not(OLM[3]) Let FLAG[4] = TRUE
    If Not(FLAG[16]) And FLAG[3] = TRUE
      X3[1] = PRG_VAR[2]
      X3[3] = X3[1] - L6[1]
      X3[3] = X3[3] - (X3[3] * (L6[0] / 100))
      If L7[8]
        If L7[8] < 0
          AMOUNT = Abs(L7[8])
          X3[3] = X3[3] + AMOUNT
        Else 
          X3[3] = X3[3] + (X3[3] * (L7[8] / 100))
        End If 
      End If 
      CNVTA = X3[3];CNVTU[0] = 0;CNVTU[1] = UN[1];CNVTU[2] = 2
      Call "mxprconv5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
      If FLAG Let E = FLAG \ Gosub ERR_SEARCH_LOGGED
      PRG_VAR[9] = CNVTA
      CNVTA = PRG_VAR[9];CNVTU[0] = UN[1];CNVTU[1] = 0;CNVTU[2] = 2
      Call "mxprconv5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
      If FLAG Let E = FLAG \ Gosub ERR_SEARCH_LOGGED
      PRG_VAR[10] = CNVTA
    Else 
      PRG_VAR[9] = 0;PRG_VAR[10] = 0
    End If 
    L5[0] = FNR(L7[2] * OLM[3]);L5[3] = FNR(L7[4] * OLM[3])
	S3[3] = A[6]
    S3[4] = FNR(Abs((L6[4] * L7[4]) / A[5]))
	raw_wgt = Abs((L6[4] * L7[4]) / A[5])
    !S3[12] = FNR((L7[4] * L5[1]) + S3[10])
   !S3[13] = FNR((L7[2] * L5[1]) + S3[10])
    S3[12] = FNR((L7[4] * netcost) + S3[10])
    S3[13] = FNR((L7[2] * netcost) + S3[10])
    EUN[0] = PFU1[0];EUN[1] = PFU1[10]
    For X1 = 0 To 3
      If X1 < 3 Let X1[1] = UN[X1] Else Let X1[1] = PFU1[10]
      If X1 And X1[1] <= 0
        UNF[X1] = 0
      Else 
        For X2 = 0 To 7
          If PFU1[X2] = X1[1] Goto CEUNSKIP
        Next X2
        E = 0 \ Gosub ERR_SEARCH_LOGGED
CEUNSKIP: If X2
          UNF[X1] = PFU2[X2 - 1]
        Else 
          UNF[X1] = 1
        End If 
      End If 
    Next X1
    UNF[4] = A1[3] \ If Not(UNF[4]) Let UNF[4] = 1
    UNF[5] = A[5] \ If Not(UNF[5]) Let UNF[5] = 1
	IF NOT(UNF[6]) LET UNF[6]=L5[1] 
	IF NOT(UNF[6]) LET UNF[6]=L7[7]                                        
    !!! TAX HERE !!!
GETTAXBYLINE: ! GET TAX INFO BY LINE #
    let keyprod$=L1$[1,12]
    let keycust$=srn[2] using "######"
    Call Taxflag(keycust$,keyprod$,SRN[2],srn[1],L9[1],a1[7],intco,c2[1],a0[3],l6[5])
    If P60$[42,42] = "Y" And L6[5] > 0
      Mat Read #ch_tax,L6[5],20,LOCKTIMEOUT;LTAX2
	  mat  read #ch_tax,L6[5],414;rtype$;
      LTAX1 = FNR(L5[3] * (LTAX2 / 100))
      Mat Read #ch_tax,L6[5],66;MAXTAX;
      !If MAXTAX
      !  CNVTA = L7[4];CNVTU[0] = 0;CNVTU[1] = UN[0];CNVTU[2] = 1
      !  Call "mxprconv5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
      !  If FLAG Let E = FLAG \ Gosub ERR_SEARCH_LOGGED
      !  If (LTAX1 > (CNVTA * MAXTAX)) Let LTAX1 = FNR(CNVTA * MAXTAX)
      !End If
	  If MAXTAX
			CNVTA = L7[4];CNVTU[0] = 0;CNVTU[1] = UN[0];CNVTU[2] = 1
			Call "mxprconv5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
			If FLAG Let E = FLAG \ Gosub ERR_SEARCH_LOGGED
			qtysell=CNVTA
			mat read #CH_TAX,L6[5],444;TX9;
			let lvlpct=0
			if tx9[1]>0 and tx9[1]<10
				if tx9[1]=1 READ #CH_TAX,L6[5],72;lvlpct;  
				if tx9[1]=2 READ #CH_TAX,L6[5],76;lvlpct;  
				if tx9[1]=3 READ #CH_TAX,L6[5],80;lvlpct;     
				if tx9[1]=4 READ #CH_TAX,L6[5],292;lvlpct; 
				if tx9[1]=5 READ #CH_TAX,L6[5],296;lvlpct; 
				if tx9[1]=6 READ #CH_TAX,L6[5],300;lvlpct; 
				if tx9[1]=7 READ #CH_TAX,L6[5],304;lvlpct; 
				if tx9[1]=8 READ #CH_TAX,L6[5],308;lvlpct; 
				if tx9[1]=9 read #CH_TAX,L6[5],312;lvlpct;! NEED BREAKTABLE LEVELS
			endif
			If not (tx9[0]) ! max tax based upon tax amount
				IF LTAX1>FNR(MAXTAX*qtysell) ! tax amount greater per unit
					if tx9[1]=0 ! based upon entire tax code
						LET LTAX1=FNR(MAXTAX*qtysell)
						if rtype$="U" LET LTAX1=FNV(MAXTAX*qtysell)
					else ! based upon the level
						if rtype$<>"U"
							let ltax1=fnr(maxtax*qtysell)! need break table 
							let ltax1=ltax1+fnr(l5[3]*((ltax2-lvlpct)/100))
						else
							let ltax1=fnv(maxtax*qtysell)! need break table 
							let ltax1=ltax1+fnv(l5[3]*((ltax2-lvlpct)/100))
						endif
					endif
				ENDIF
			else ! TAXABLE MERCHANDISE AMOUNT
				IF L5[3]>MAXTAX ! total shipped on the line > max tax
					LET MAXTAX=MAXTAX*QTYSELL
					IF L5[3]>MAXTAX
						IF TX9[1]=0 ! FOR ENTIRE TAX CODE
							LET LTAX1=FNR(MAXTAX*LTAX[2]/100)
							if rtype$="U" LET LTAX1=FNV(MAXTAX*AMOUNT)
						ELSE
							let ltax1=0
							if rtype$<>"U"
								LET LTAX1=FNR(MAXTAX*lvlpct/100)
								let Ltax1=ltax1+fnr(l5[3]*((ltax2-lvlpct)/100))
							else
								let ltax1=FNV(MAXTAX*lvlpct/100)
								let ltax1=ltax1+fnr(l5[3]*((ltax2-lvlpct)/100))
							endif
						ENDIF
					ENDIF
				endIF
			EndIf 
		EndIf 

    End If 
BUILD_qol: Rem

    E = 2 \ Search #ch_qol,1,0;work$,REC_qol,E
    If E Gosub ERR_SEARCH_LOGGED
    Rem
    Mat Write #ch_qol,REC_qol,0;L2
    Mat Write #ch_qol,REC_qol,8;L3
    Mat Write #ch_qol,REC_qol,16;L4
    Mat Write #ch_qol,REC_qol,32;L5
    Mat Write #ch_qol,REC_qol,56;L6
    Mat Write #ch_qol,REC_qol,80;L6$
    Mat Write #ch_qol,REC_qol,140;L1$
    Mat Write #ch_qol,REC_qol,160;L9
    Mat Write #ch_qol,REC_qol,168;L7
    Mat Write #ch_qol,REC_qol,246;PL
    Mat Write #ch_qol,REC_qol,250;UN
    Mat Write #ch_qol,REC_qol,256;S2
    Mat Write #ch_qol,REC_qol,260;S3
    Mat Write #ch_qol,REC_qol,368;MT$
    Mat Write #ch_qol,REC_qol,370;S3$
    Mat Write #ch_qol,REC_qol,404;OLM
    Mat Write #ch_qol,REC_qol,446;EUN
    Mat Write #ch_qol,REC_qol,452;UNF
    Mat Write #ch_qol,REC_qol,494;LCO
    Mat Write #ch_qol,REC_qol,502;CST
    Mat Write #ch_qol,REC_qol,508;LTAX1
    Mat Write #ch_qol,REC_qol,514;CTWT
    Mat Write #ch_qol,REC_qol,524;GWGT
    Mat Write #ch_qol,REC_qol,532;GWGT1
    Mat Write #ch_qol,REC_qol,538;LTAX2
    Mat Write #ch_qol,REC_qol,542;QPB
    Write #ch_qol,REC_qol,548;LPRINTED
    Write #ch_qol,REC_qol,550;OWHS
    Write #ch_qol,REC_qol,552;LP_DATE
    Write #ch_qol,REC_qol,556;LP_TIME;
    Write #ch_qol,REC_qol,564;ROL0;
	write #ch_qol,rec_qol,624;qlcurrid;
	write #ch_qol,rec_qol,626;qlcurrfact;

    Rem
    work$ = L2[1] Using "######";work$[7] = L3[2] Using "### "
    Search #ch_qol,4,1;work$,REC_qol,E \ If E Gosub ERR_SEARCH_LOGGED
    If Not(L3[0])
      work$ = L4[0] Using "######"
      work$[7] = L2[1] Using "######";work$[13] = L3[2] Using "### "
      Search #ch_qol,4,2;work$,REC_qol,E \ If E Gosub ERR_SEARCH_LOGGED
	else
		! nonstock pointer
		let ns.ordlinerec=rec_qol
	    write #ch_ns,rec_ns,8;ns.ordlinerec;
		l4[0]=rec_ns
		Mat Write #ch_qol,REC_qol,16;L4
    End If 
    Unlock #ch_qol
    If FLAG[9] Goto ZLINE_LOOP
    Goto ALLOCATEDONE ! do not update on order for quotes   
    IF cartdet.LTYPE$="9" GOTO ALLOCATEDONE:
    A[3] = A[3] + L7[4]
    X2 = H0[10] \ Gosub YMD2JUL \ X2 = 0
    JDATE[0] = X2
    X2 = cdate[2] \ Gosub YMD2JUL \ X2 = 0
    JDATE[1] = X2
    If JDATE[6] >= JDATE[0]
      PLV[0] = PLV[0] + L7[4]
    Else 
      PLV[1] = PLV[1] + L7[4]
    End If 
    W3[2] = W3[2] + L7[4]
    If JDATE[6] >= JDATE[0]
      WHLV[0] = WHLV[0] + L7[4]
    Else 
      WHLV[1] = WHLV[1] + L7[4]
    End If 
    If TYPE$ = "QUOTE" Goto ALLOCATEDONE
    Goto ALLOCATEDONE ! do not update sordlot for quotes   
    !Mat Write #ch_prod,REC_PROD,256;A
   !Mat Write #ch_prod,REC_PROD,990;PLV;
    If FLAG[2]
     ! Mat Write #ch_prwh,REC_PRWH,78;W3
      !Mat Write #ch_prwh,REC_PRWH,780;WHLV
    End If 
    Unlock #ch_prwh
    Unlock #ch_prod
    S9[4] = 281;ch[0] = ch_qoh;ch[1] = ch_qol
    ch[2] = ch_ordl;ch[3] = ch_prlt
    R[0] = REC_qoh;R[1] = REC_qol;X1 = 0
    Call "ALLOCORDLOT",S9[],ch[],R[],RASL,X1
    If X1
      If X1 < 10 Let msg$ = "Missing channel " + Str$(X1 - 1) + " for Allocate call"
      If X1 > 9 Let msg$ = "Missing record # " + Str$(X1 - 10) + " for Allocate call"
    Else 
      REC_ORDL = R[2]
      REC_PRLT = R[3]
    End If 
ALLOCATEDONE: Rem
    T2[1] = T2[1] + L5[3]
    If L6[5]
      T2[8] = T2[8] + (L5[3] - OLM[1])
      T2[11] = T2[8]
    Else 
      T2[9] = T2[9] + (L5[3] - OLM[1])
    End If 
    T2[14] = T2[14] + S3[13]
    T2[15] = T2[15] + FNR((L7[4] * L6[2]) / A1[3])
    T2[16] = T2[16] + FNR(S3[4])
    T2[17] = T2[17] + S3[12]
    T2[18] = T2[18] + FNR(B[21] * L7[4])
    T2[24] = T2[24] + L5[0]
    H6[6] = H6[6] + OLM[1]
    CNVTU[0] = 0;CNVTU[1] = UN[0];CNVTU[2] = 1;CNVTA = L7[4]
    Call "mxprconv5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
    TOT_SELL = TOT_SELL + CNVTA
    If FLAG[7]
      Print #CH_LPT; Using "###  ";L3[2];L1$[1,12];"  ";L6$[1,30];
      Print #CH_LPT; Using "-----# "; Tab (53);AVAIL[0];CCD$[11,14];
      Print #CH_LPT; Using "-----# "; Tab (65);PRG_VAR[6];CCD$[11,14];
      If FLAG[16]
        X3[5] = GIVEN_FLD[2]
      Else 
        X3[5] = PRG_VAR[9]
      End If 
      Print #CH_LPT; Using "#####.##"; Tab (76);X3[5];
      Print #CH_LPT; Using "#####.##"; Tab (86);PRG_VAR[8]; Tab (96);
      If L6[5] Print #CH_LPT;"Y"; Else Print #CH_LPT;"N";
      If S3[16] = 2
        Print #CH_LPT; Tab (103);"** Supercedes ";S3$[21,32]
        pline = pline + 1
      End If 
      If PRG_VAR[6] > AVAIL[0] And TYPE$ = "QUOTE"
        PROB[1] = 1
        If AVAIL[0] <= 0
          Print #CH_LPT; Tab (103);"** No stock **  ";
        Else 
          Print #CH_LPT; Tab (103);"** Low stock **  ";
        End If 
        Print #CH_LPT;"" \ pline = pline + 1
      End If 
      If L5[1] > L5[2]
        PROB[2] = 1
        Print #CH_LPT; Tab (103);"<< Price lower than cost! >>";
        Print #CH_LPT;"" \ pline = pline + 1
      End If 
      If FLAG[5]
        Print #CH_LPT; Tab (103);"!! Low Price warning !!  ";
        Print #CH_LPT;"" \ pline = pline + 1
      End If 
      If FLAG[4]
        PROB[3] = 1
        Print #CH_LPT; Tab (103);"## Missing Price ##  ";
        Print #CH_LPT;"" \ pline = pline + 1
      End If 
      If REC_LASTPR = 0
        Print #CH_LPT; Tab (103);"** New product ** ";
        Print #CH_LPT;"" \ pline = pline + 1
      End If 
      If Not(L5[2])
        PROB[4] = 1
      End If 
      Gosub RPTHEAD
    End If 
  End If 
  If FLAG[7] Print #CH_LPT;"" \ pline = pline + 1
ZLINE_LOOP: Rem
TMP$ = TRIM$(CARTDET.NOTES$)
  If TMP$[1,1] <> ""
! OLD WAY OF DOING NOTES: ZLINES
! ZLNLOOP2: Rem
!     FLAG[9] = FLAG[9] + 1 \ If FLAG[9] > 10 Goto ZNDONE
!     X2 = (FLAG[9] - 1) * 60 + 1
!     work$ = SPACES$
!     work$ = notes$[X2,X2 + 59]
!     If work$[1,1] <> "" And work$[1,60] <> SPACES$[1,60]
!       Gosub PARSE_ZLINE
!       Goto ZLNLOOP
!     Else 
!       Goto ZLNLOOP2
!     End If 
! ZNDONE: Rem
! NEW WAY OF DOING NOTES: QOLTAG
	gosub DoQoltag
  End If 
  Goto LCLOOP1
End If 
If Not(FLAG[12])
  msg$ = "Calculating quote totals"
  Gosub UPDATE_LOG
  If GIVEN_FLD[15] < 0
    T2[3] = Abs(GIVEN_FLD[15])
    If Not(H6[7]) And T2[1]
      H6[7] = Abs((T2[3] * 100) / T2[1]) * Sgn(T2[1])
    End If 
  End If 
  T2[7] = FNR(T2[8] * (T2[2] / 100))
  If H6[7] Let T2[3] = FNR(H6[7] * T2[1] / 100)
  T2[0] = T2[1] - T2[3] + T2[4] + T2[5] + T2[6] + T2[7]
  H5[13] = T2[1] - H6[6];H5[14] = T2[17]
  If P9$[35,35] = "Y" Let H5[13] = H5[13] + T2[5] + H6[6]
  If P9$[36,36] = "Y" Let H5[13] = H5[13] - T2[3]
  If P9$[37,37] = "Y" Let H5[14] = H5[14] + T2[20]
  If P9$[38,38] = "Y" Let H5[13] = H5[13] + T2[4] + T2[6]
  If P60$[40,40] = "S"
    TOT_HOLD = T2[0]
  Else 
    TOT_HOLD = (T2[0] - T2[1]) + T2[24]
  End If 
  goto SkipCreditCheck ! no credit check on quotes
  X1 = 0
  Gosub CHECK_HOLD_PASSWD
  If FOUND
	Let CHNL[1]=ch_cntrl   !cntrl
	Let CHNL[2]=ch_cust    !cust
	Let CHNL[3]=ch_aract   !saract
	Let CHNL[4]=ch_credck  !credck
	E=1
	Call "credck.dl4",CHNL[],H0[4],H0[1],TOT_HOLD,H0[7],E,work$,debug,dlog$,ss
	! E = 0 \ Call "credck",H0[4],H0[1],TOT_HOLD,H0[7],E,work$
	If E Let HOLD[X1] = TRUE
    If Err 0 Rem
    ! Read #ch_cntrl,88,1808;work$[1,16]; \ Open #ch_cust,work$[1,16]
    ! Read #ch_cntrl,88,1504;work$[1,16]; \ Ropen #ch_aract,work$[1,16]
    ! Read #ch_cntrl,88,992;work$[1,16]; \ Open #ch_credck,work$[1,16]
    If Err 0 Gosub ERR_TRAP_LOGGED
  End If 
  SkipCreditCheck: !
  If GIVEN_FLD[17] > 0 And GIVEN_FLD[17] < 13 Let X1 = GIVEN_FLD[17] - 1;HOLD[X1] = TRUE
  Gosub PACKHOLD
  X1[9] = H5[9];H5[9] = 9
  ! calclate cancel date                         
  H5[1] = H0[9] ! set cancel date to ship date   
  Read #ch_cntrl,60,0;expday;                    
  If expday > 0                                  
     x2 = H5[1] \ Gosub YMD2JUL \ x2 = 0          
     If x2 > 0                                    
       x2 = x2 + expday                           
       JDATE[0] = x2 \ JDATE[1] = x2 \ E = 0      
       Call "JULIANUTIL",JDATE[],X$,E             
       x2 = X$                                    
       H5[1] = x2                                 
     Else                                         
       H5[1] = 0                                  
     End If                                       
   Else                                           
     H5[1] = 0 ! no cancel date                   
   End If                                         
  Gosub WRITEHEADS
  if p60$[12,12]="Y" or P60$[13,13]="Y" ! amalg/frtaddon
	gosub Call_amalg ! BEFORE ORDER TOTALLING
  Endif
  Gosub CALL_ORDERTOTAL
  H5[9] = X1[9]
  Write #ch_qoh,REC_qoh,140;H5[9];
  R5 = REC_CUST;H1 = REC_qoh;V1 = REC_SLSM
  If R5 And H1 And V1
    CFIN8 = CFIN[8]
    Rem
    Rem
  Else 
    msg$ = "*Commission not calculated*"
    Gosub UPDATE_LOG
    If FLAG[7] Print #CH_LPT; Tab (105);msg$
    pline = pline + 1
  End If 
  Unlock #ch_qoh
  Unlock #ch_qot
  Unlock #ch_qos
End If 
If H0[7]
  Gosub DO_MESSAGES
  gosub Do_Multcust:
  if lastflag$="y"
	let lpchan[0]=ch_qoh ! quote header
	let lpchan[1]=ch_qol ! quote line
	let lpchan[2]=ch_lastpr ! last price file
	let lpchan[3]=ch_prod ! product file
	let lpchan[4]=ch_qod ! quote prod desc
	let lpchan[5]=ch_cstqt ! multi cust contract
	let lpchan[6]=0 ! last price shipto file
	let lpchan[7]=ch_qos ! quote shipto file
	let lpchan[8]=ch_ccodes
	let lpchan[9]=h1
	ch_shllp=0
	IF P61$[64,64]="Y"
	   ch_shllp = openfile(9982,intco) \ If ch_shllp = -1 Error 42  
	   let lpchan[6]=ch_shllp
	 endif
    	CALL "quote117",H0[],H5[],lpchan[],dlog$,intco
   endif
  msg$ = "End of quote #" + Str$(H0[7])
Else 
  msg$ = "End of rejected quote"
End If 
Gosub UPDATE_LOG
Return 

Build_NonStock: ! build non-stock lines
work$ = "Z ZZZZZZZZZZ" + SPACES$
Search #ch_prod,2,1;work$,REC_PROD,E \ If E > 1 Gosub ERR_SEARCH_LOGGED
Mat Read #ch_prod,REC_PROD,460;A1;  ! Need a2[7], tax type
getnsline: ! rem get the nonstock line
clear ns.
ns.SpareNu$=" "
 L2[0] = 11;L2[1] = H0[7];L3[1] = 1  ! ;L4[3] = H4[2] 
 l4[1]=H0[11] ! salesperson #
 L4[3]=cartdet.LWH$  ! line wh
 If not(l4[3]) L4[3] = H4[2]  ! default to headerwh

 pline[3] = pline[3] + 1;L3[2] = pline[3]   
ns.OrdNum=H0[7]                    
ns.LineNum =l3[2]                 
ns.Desc1$=clrtxtc$(e$,cartns.desc1$) + spaces$
ns.Desc2$=clrtxtc$(e$,cartns.desc2$) + spaces$                          
ns.PSlsCat=cartns.category 
ns.prodcode$=" ",ns.prodcode$                                       
ns.ProdCode$[1,6]=ns.OrdNum using "######"  ! NOT "&&&&&&"
ns.prodCode$[7,7]="-"
ns.prodcode$[8,10]=ns.linenum using "&&&"
ns.ComdtyCode$=cartns.Commcode$               
ns.HazFlg=cartns.hazflag
ns.Buyer=cartns.buyer
ns.HazFileRecno=cartns.hazrec                              
ns.HazClass$=cartns.hazclass$                 
ns.PackGrp$=cartns.packinggroup$                 
ns.DotID$=cartns.dotid$                
ns.ERGdbk$=cartns.erbookno$               
ns.NS_UDA2$=SPACES$;ns.NS_UDA3$=SPACES$;ns.NS_UDA4$=SPACES$;ns.NS_UDA5$=SPACES$
ns.NS_UDA1=0
let l2[0]=11 ! status
let l2[1]=h0[7] ! order number
let l3[0]=1 ! not of product -- nonstock item
let l3[1]=0 ! stock up non
let l3[2]=pline[3] ! next line #
let l3[3]=ns.pslscat ! product category
let L4[0]=cartns.poid ! ******* need to update this field when the non-stock record line is created ***** mtg
let l4[1]=H0[11] ! salesperson #
let l4[2]=0 ! po number
let l4[2]=cartns.POID
! L4[3] = H4[2] ! warehouse
  L4[3]=cartdet.LWH$  ! line wh
  If not(l4[3]) L4[3] = H4[2]  ! default to headerwh
let l6[2] = cartns.cube
let l6[4] = cartns.weight
let l6[5] = cartdet.TAXABLE
L6$[1,30]=NS.DESC1$,"                              "
L6$[31,60]=NS.DESC2$,"                              "
L1$=" ",L1$
L1$[1,12]=NS.PRODCODE$
L1$[17,20]=ns.ComdtyCode$
L9[1]=cartdet.DEPT ! **** CHECK IF THIS IS VALUE IS READ FOR THE CARTDET 
mt$[1,1]=cartns.matcode$
! unit of measure
KCCODES$ = cartdet.qum$ + "    "  
LET REC_CCODES=-4 ! ERROR 
Search #ch_ccodes,2,1;KCCODES$,REC_CCODES,E                      
UN[0]=REC_CCODES ! SELLING UNIT OF MEASURE

KCCODES$ = cartdet.pum$ + "    "  
LET REC_CCODES=-4 ! ERROR 
Search #ch_ccodes,2,1;KCCODES$,REC_CCODES,E                            
If E                                                                  
  If cartdet.PUM$[1,3] = "LOT" Let REC_CCODES = -2                       
  If cartdet.PUM$[1,3] = "CWT" Let REC_CCODES = -1             
End If                                                                 
UN[1]=REC_CCODES ! PRICING UNIT OF MEASURE

if cartdet.ltype$="9" 
	KCCODES$ = CARTNS.COSTUM$ + "    "  
else
	kccodes$ = cartdet.cOSTum$ 
endif
if kccodes$="    " then KCCODES$ = cartdet.pum$
LET REC_CCODES=-4 ! ERROR 
Search #ch_ccodes,2,1;KCCODES$,REC_CCODES,E                            
If E                                                                  
  If cartdet.PUM$[1,3] = "LOT" Let REC_CCODES = -2                       
  If cartdet.PUM$[1,3] = "CWT" Let REC_CCODES = -1             
End If                                                                 
UN[2]=REC_CCODES ! COSTING UNIT OF MEASURE

KCCODES$ = CARTNS.BASEUM$ + "    "  
LET REC_CCODES=-4 ! ERROR 
Search #ch_ccodes,2,1;KCCODES$,REC_CCODES,E
EUN[0]=REC_CCODES ! BASE UNIT OF MEASURE

KCCODES$ = CARTNS.PURCHUM$ + "    "  
LET REC_CCODES=-4 ! ERROR 
Search #ch_ccodes,2,1;KCCODES$,REC_CCODES,E
EUN[1]=REC_CCODES ! PURCH UNIT OF MEASURE

S3[14]=CARTNS.VENDID
S3$[1,20]=CARTNS.VENDPART$
! FACTORS
UNF[0]=cartns.factsell
unf[1]=cartns.factprice
unf[2]=cartns.factcost
unf[3]=cartns.factpurch
unf[4]=cartns.factcube
unf[5]=cartns.factwgt
gosub loadnonstockval:
!!! for the nonstock --- still need to define ---
!! QTY ORDERED, QTY SHIPPED, ORIG QTY
CNVTA = CARTDET.QTY;CNVTU[0] = UN[0];CNVTU[1] = 0;CNVTU[2] = 1  
Call "mxprconv5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG         
If Err 0 Gosub ERR_TRAP_LOGGED                                      
If FLAG Let E = FLAG \ Gosub ERR_SEARCH_LOGGED                      
L7[2] = CNVTA;L7[4] = CNVTA;L7[5] = CNVTA
ns.QtyShip = CNVTA
!! UNIT COST
CNVTA = CARTDET.COST;CNVTU[0] = UN[2];CNVTU[1] = 0;CNVTU[2] = 2
 Call "mxprconv5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
 If FLAG Let E = FLAG \ Gosub ERR_SEARCH_LOGGED
 L5[1] = CNVTA
 ns.UnitCost=CNVTA
 !! GL COST
 CNVTA = CARTNS.GLCOST;CNVTU[0] = UN[2];CNVTU[1] = 0;CNVTU[2] = 2
 Call "mxprconv5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
 If FLAG Let E = FLAG \ Gosub ERR_SEARCH_LOGGED
 L7[7] = CNVTA
!! UNIT PRICE, ORIG PRICE, NET PRICE
 CNVTA = CARTDET.PRICE;CNVTU[0] = UN[1];CNVTU[1] = 0;CNVTU[2] = 2
 Call "mxprconv5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
 If FLAG Let E = FLAG \ Gosub ERR_SEARCH_LOGGED
 L5[2] = CNVTA;OLM[3] = L5[2]
 L7[6] = L5[2]
 ns.UnitPrice=CNVTA
 ! extended amt ord/amt ship
  L5[0] = FNR(L7[2] * OLM[3]);L5[3] = FNR(L7[4] * OLM[3])
  ns.ExtShipAmt=L5[3]
  S3[4] = FNR(Abs((L6[4] * L7[4]) / A[5])) ! EXT WGT
  raw_wgt = Abs((L6[4] * L7[4]) / A[5])
  S3[3] = L6[4]
  S3[12] = FNR((L7[4] * L5[1]) + S3[10]) ! EXT LOAD COST SHIP
  S3[13] = FNR((L7[2] * L5[1]) + S3[10]) ! EXT LOAD COST ORDERED                                        
  IF NOT(UNF[6]) LET UNF[6]=L5[1]
  IF NOT(UNF[6]) LET UNF[6]=L7[7]
!ns.OrdLineRec               
 


! do extensions
! add non-stock 
rec_ns = fileupdateqproddesc(e$,ch_ns,"a",rcdno,ns.) 
if rec_ns<=0
	gosub err_search_logged
endif
RETURN  !! get out here, don't write rol

! E = 2 \ Search #ch_qol,1,0;work$,REC_ROL,E
!    
!   If E Gosub ERR_SEARCH_LOGGED
!
!    let ns.ordlinerec=rec_rol
!    write #ch_ns,rec_ns,8;ns.ordlinerec;
!    l4[0]=rec_ns
!    Mat Write #ch_qol,REC_ROL,0;L2
!    Mat Write #ch_qol,REC_ROL,8;L3
!    Mat Write #ch_qol,REC_ROL,16;L4
!    Mat Write #ch_qol,REC_ROL,32;L5
!    Mat Write #ch_qol,REC_ROL,56;L6
!    Mat Write #ch_qol,REC_ROL,80;L6$
!    Mat Write #ch_qol,REC_ROL,140;L1$
!    Mat Write #ch_qol,REC_ROL,160;L9
!    Mat Write #ch_qol,REC_ROL,168;L7
!    Mat Write #ch_qol,REC_ROL,246;PL
!    Mat Write #ch_qol,REC_ROL,250;UN
!    Mat Write #ch_qol,REC_ROL,256;S2
!    Mat Write #ch_qol,REC_ROL,260;S3
!    Mat Write #ch_qol,REC_ROL,368;MT$
!    Mat Write #ch_qol,REC_ROL,370;S3$
!    Mat Write #ch_qol,REC_ROL,404;OLM
!    Mat Write #ch_qol,REC_ROL,446;EUN
!    Mat Write #ch_qol,REC_ROL,452;UNF
!    Mat Write #ch_qol,REC_ROL,494;LCO
!    Mat Write #ch_qol,REC_ROL,502;CST
!    Mat Write #ch_qol,REC_ROL,508;LTAX1
!    Mat Write #ch_qol,REC_ROL,514;CTWT
!    Mat Write #ch_qol,REC_ROL,524;GWGT
!    Mat Write #ch_qol,REC_ROL,532;GWGT1
!    Mat Write #ch_qol,REC_ROL,538;LTAX2
!    Mat Write #ch_qol,REC_ROL,542;QPB
!    Write #ch_qol,REC_ROL,548;LPRINTED
!    Write #ch_qol,REC_ROL,550;OWHS
!    Write #ch_qol,REC_ROL,552;LP_DATE
!    Write #ch_qol,REC_ROL,556;LP_TIME;
!    Write #ch_qol,REC_ROL,564;ROL0;
  

    Rem
 !   work$ = L2[1] Using "######";work$[7] = L3[2] Using "### "
 !   Search #ch_qol,4,1;work$,REC_ROL,E \ If E Gosub ERR_SEARCH_LOGGED
 !   If Not(L3[0])
 !     work$ = L4[0] Using "######"
 !     work$[7] = L2[1] Using "######";work$[13] = L3[2] Using "### "
 !     Search #ch_qol,4,2;work$,REC_ROL,E \ If E Gosub ERR_SEARCH_LOGGED
 !   End If 
 !   Unlock #ch_qol
! add rol
! delete cartns
! delete cartdet
return



LoadNonstockVal: !!! load non-stock variables for product conversion
LET A[6]=L6[4];A[5]=UNF[5] \ IF NOT (A[5]) LET A[5]=1;UNF[5]=1                                                                 
LET B[23]=L6[2];A1[3]=UNF[4] \ IF NOT (A1[3]) LET A1[3]=1;UNF[4]=1                                                                        
LET PFU1[0]=EUN[0];PFU1[1]=UN[0]
LET PFU1[2]=UN[1];PFU1[3]=UN[2]   
LET PFU1[4]=EUN[1]  
LET PFU1[5]=0;PFU1[6]=0;PFU1[7]=0 
LET PFU1[8]=UN[0];PFU1[9]=UN[0];PFU1[10]=EUN[1] 
LET PFU1[11]=UN[2];PFU1[12]=UN[1]   
LET PFU1[13]=UN[0];PFU1[16]=EUN[0];PFU1[17]=EUN[0]                     
LET PFU1[18]=UN[0];PFU1[19]=UN[0] 
LET PFU2[0]=UNF[0];PFU2[1]=UNF[1]             
lET PFU2[2]=UNF[2];PFU2[3]=UNF[3] 
LET PFU2[4]=0;PFU2[5]=0;PFU2[6]=0 
FOR X1=1 TO 4 
   FOR X2=0 TO X1-1  
     IF PFU1[X1]=PFU1[X2] LET PFU1[X1]=0;PFU2[X1-1]=0 
   NEXT X2                                              
               
NEXT X1 

return
Call_Amalg: ! using amalgamate
r[50]=3 ! 3=quote 
	let s9[2]=REC_QOH;s9[4]=281
	ch[1]=ch_prod;ch[2]=ch_comcd;ch[3]=ch_qol
	ch[4]=ch_brktbl;ch[5]=ch_ns;ch[6]=ch_prwh
	ch[7]=ch_ccodes;ch[8]=ch_ctrct;ch[9]=ch_sprice
	ch[10]=ch_cust;ch[11]=ch_qoh
	Mat read #ch_qoh,REC_QOH,0;H0;
	mat read #ch_qoh,REC_QOH,78;H4;
	mat read #ch_qoh,REC_QOH,104;h5;
	mat read #ch_qoh,REC_QOH,408;h6;
	let p3=h6[0] ! price type
	if p3<=0 let p3=C1[7]
	if p3<=0 let p3=1
	mat read #CH_cust,Rec_cust,502;so;
	let n0=H0[7]
call "mx201wt.dl4",H4[],SO[],P3,N0,H5[],H0[],R[],S9[],Intco,ch[]
	! no passing of issues back from call?
Return
CALL_ORDERTOTAL: Rem
ch[0] = 0;ch[1] = 0  ! ch_temp
ch[2] = ch_zone;ch[3] = ch_prod;ch[4] = ch_comcd;ch[5] = ch_cust
ch[6] = ch_prwh;ch[7] = ch_qos;ch[8] = ch_qoh;ch[9] = ch_qot;ch[10] = ch_qol
ch[11] = ch_ns;ch[12] = ch_custax;ch[13] = ch_slsm;ch[14] = ch_tax
ch[15] = ch_prlt;ch[16] = ch_ordl;ch[17] = ch_ccodes
PARAM[0] = 1 	! credit check - inquiry only mode?
		! must set credit check in inquiry mode or ordertotal
		! will force an update of open order amounts (param[4])
		! BAD for quotes
PARAM[1] = 0	! NO credit checks on quotes
PARAM[2] = 0
if p61$[106,106]="Y" let param[2]=1 ! sysflag controlled!
PARAM[3] = 1
PARAM[4] = 0	! NO update of open order amounts on quotes
! If P60$[40,40] = "S" Let PARAM[4] = 1
PARAM[5] = 0
PARAM[6] = 1
PARAM[9] = 99 ! match ERP - no delivery charge for quotes
PARAM[10] = 99! ar term misc cost charge   - bypass  
S9[1]=intCo
S9[2]=intSalesman
S9[4] = 281
R5 = REC_CUST;H1 = REC_qoh;V1 = REC_SLSM
Call "ORDERTOTAL",S9[],H1,PARAM[],ch[],T1[],T2[],MCODE[],MCHARGE[],TOT[],MCTXBL[],DCLVL,R5,V1,CFIN[]
If Err 0 Gosub ERR_TRAP_LOGGED
Return 
GETWDLINE: Rem
Search #CH_INPUT[2],3,1;DLINE$,WREC[2],E \ If E > 2 Gosub ERR_SEARCH_LOGGED
If DLINE$[1,18] <> HDR$[1,18] Let E = 2
If Not(E)
  Read record #ch_input[2],wrec[2];cartdet.;
  !Mat Read #CH_INPUT[2],WREC[2],18;GPROD$;
  !mat read #ch_input[2],wrec[2],30;lWH$;
  !mat read #ch_input[2],wrec[2],48;ltype$;
  !Mat Read #CH_INPUT[2],WREC[2],50;QUM$;
  !Mat Read #CH_INPUT[2],WREC[2],54;PUM$;
  !Mat Read #CH_INPUT[2],WREC[2],58;PC1;
  !Mat Read #CH_INPUT[2],WREC[2],62;PC3;
  !Mat Read #CH_INPUT[2],WREC[2],86;notes$;
  !Mat Read #CH_INPUT[2],WREC[2],686;GNETPC;
  !Mat Read #CH_INPUT[2],WREC[2],698;LTAXABLE;
  !Mat Read #CH_INPUT[2],WREC[2],702;dept
  !Mat Read #CH_INPUT[2],WREC[2],706;GUCHG;
  !Mat Read #CH_INPUT[2],WREC[2],740;cum$;
  
  cartdet.qum$ = cartdet.qum$+"    "
  cartdet.pum$ = cartdet.pum$+"    "
  cartdet.costum$ = cartdet.costum$+"    "
  if cartdet.costum$[1,4]="    " then cartdet.costum$ = cartdet.pum$
    if cartdet.ltype$="9" ! non-stock item
	ns_dline$=dline$[1,34]
	rec_cartns = filegetsfcartns(e$,cartns,"=",1,ns_dline$,cartns.)
	if rec_cartns<0
		clear cartns.
		! need to set-up defaults
		let cartns.desc1$="Error in Nonstock"
		let cartns.desc2$="*******ERROR******"
		let cartns.category=20 
		let cartns.commcode$="MISC"
		let cartns.factprice=1
		let cartns.factpurch=1
		let cartns.factcost=1
		let cartns.factcube=1
		let cartns.factwgt=1
		let cartns.factsell=1
		let cartns.baseum$=cartdet.qum$
		let cartns.costum$=cartdet.pum$
		if cartdet.costum$<>"    " then let cartns.costum$=cartdet.costum$
		let cartns.purchum$=cartdet.pum$
	endif
 endif
End If 
FLAG[14] = E
Return 
RPTHEAD: Rem
If Not(FLAG[7]) Return 
If pline >= pline[1]
  If pline[9] Print #CH_LPT;"\14\";
  pline[9] = pline[9] + 1
  Print #CH_LPT; Tab (66 - Len(CNAME$) / 2);CNAME$
  Print #CH_LPT;CDATE$; Tab (40);"PORTAL DEVICE SALES QUOTE LOAD REGISTER";
  Print #CH_LPT; Tab (120);"Page";pline[9];"\15\"
  Print #CH_LPT;"Loaded: ";SDATE$;
  If GIVEN_FLD[4] <> 0
    Print #CH_LPT; Tab (52);"For salesman: ";Str$(GIVEN_FLD[4]);"  ";SLSM_NAME$;
  End If 
  Print #CH_LPT;""
  Print #CH_LPT;""
  pline = 6
End If 
Return 
WRITEHEADS: Rem
Rem
Mat Write #ch_qoh,REC_qoh,0;H0
Mat Write #ch_qoh,REC_qoh,52;H3
Mat Write #ch_qoh,REC_qoh,56;TOT_SELL
Mat Write #ch_qoh,REC_qoh,64;LOCKPORT
Mat Write #ch_qoh,REC_qoh,66;V0$
Mat Write #ch_qoh,REC_qoh,78;H4
Mat Write #ch_qoh,REC_qoh,84;H0$
Mat Write #ch_qoh,REC_qoh,104;H5
Mat Write #ch_qoh,REC_qoh,172;ST3
Mat Write #ch_qoh,REC_qoh,272;H1$
Mat Write #ch_qoh,REC_qoh,278;SLSM
Mat Write #ch_qoh,REC_qoh,318;SCOM
Mat Write #ch_qoh,REC_qoh,348;SMER
Mat Write #ch_qoh,REC_qoh,378;SCST
Mat Write #ch_qoh,REC_qoh,408;H6
Mat Write #ch_qoh,REC_qoh,444;HMAT$
Mat Write #ch_qoh,REC_qoh,446;P0$
Mat Write #ch_qoh,REC_qoh,466;HFAX
Mat Write #ch_qoh,REC_qoh,474;HSTI
Mat Write #ch_qoh,REC_qoh,482;H2
Mat Write #ch_qoh,REC_qoh,486;OWHT
Mat Write #ch_qoh,REC_qoh,490;OWHT1
Mat Write #ch_qoh,REC_qoh,498;TOTGL
Mat Write #ch_qoh,REC_qoh,504;PICKBY;
Mat Write #ch_qoh,rec_qoh,624;qhcurrid;
Mat Write #ch_qoh,rec_qoh,626;qhcurrfact;
Rem
Rem
Mat Write #ch_qos,REC_qos,0;S1
Mat Write #ch_qos,REC_qos,8;S1$
Mat Write #ch_qos,REC_qos,126;S2$
Mat Write #ch_qos,REC_qos,146;S5
Mat Write #ch_qos,REC_qos,150;S6
Mat Write #ch_qos,REC_qos,154;SRN;
Rem
Rem
Mat Write #ch_qot,REC_qot,0;T1
Mat Write #ch_qot,REC_qot,8;T2
Mat Write #ch_qot,REC_qot,164;JRNL
Mat Write #ch_qot,REC_qot,168;MCODE
Mat Write #ch_qot,REC_qot,208;MCHARGE
Mat Write #ch_qot,REC_qot,328;TOT
Mat Write #ch_qot,REC_qot,358;MCTXBL
Mat Write #ch_qot,REC_qot,378;DCLVL;
Mat Write #ch_qot,REC_qot,386;TOT1;
Rem
Return 
READ_CUST: Rem
Mat Read #ch_cust,REC_CUST,0,30;A1$
Mat Read #ch_cust,REC_CUST,142;C1
Mat Read #ch_cust,REC_CUST,194;C2
Mat Read #ch_cust,REC_CUST,348;A2$
Mat Read #ch_cust,REC_CUST,378;C7
Mat Read #ch_cust,REC_CUST,388;A3$
Mat Read #ch_cust,REC_CUST,486;A0
Mat Read #ch_cust,REC_CUST,544;CFIN
Mat Read #ch_cust,REC_CUST,660;C11
mat read #ch_cust,rec_cust,660;c11                   
read #ch_cust,rec_cust,724;lpppcust;                 
! if p60$[33,33] <> "y" let lpppcust = 0
if lpppcust < 1 or lpppcust > 999999 or fra(lpppcust)
  lpppcust = 0
end if
if a1$[138,138] = "Y" let lpppcust = 0
if lpppcust = c1[1] let lpppcust = 0
if p61$[100,100] <> "Y" let lpppcust = 0
Unlock #ch_cust
Return 

READWHDR: Rem
Mat Read #CH_INPUT[1],WREC[1],8;CUSTID$;
Mat Read #CH_INPUT[1],WREC[1],18;GPO$;
Mat Read #CH_INPUT[1],WREC[1],38;SHIPDATE$;
Mat Read #CH_INPUT[1],WREC[1],46;SHIPTO$;
Mat Read #CH_INPUT[1],WREC[1],52;OS1$;
Mat Read #CH_INPUT[1],WREC[1],172;OTYPE;
Mat Read #CH_INPUT[1],WREC[1],174;GMCODE;
Mat Read #CH_INPUT[1],WREC[1],214;GMCHG;
Mat Read #CH_INPUT[1],WREC[1],274;GMCOST;
Mat Read #CH_INPUT[1],WREC[1],334;ORDDISC;
Mat Read #CH_INPUT[1],WREC[1],346;ATTN$;
Mat Read #CH_INPUT[1],WREC[1],376;TERMS;
Mat Read #CH_INPUT[1],WREC[1],378;ROUTING;
Mat Read #CH_INPUT[1],WREC[1],380;shipcust$;
Mat Read #CH_INPUT[1],WREC[1],386;ordernum;
Mat Read #ch_input[1],wrec[1],392;headwh$;
Mat Read #CH_INPUT[1],WREC[1],394;hdept;

Return 
MISCCHARGE: Rem
For X = 0 To 9
  If GMCODE[X] Gosub CHEKMC
Next X
Return 
CHEKMC: Rem
R[90] = GMCODE[X]
If R[90] < 1 Or R[90] > Chf(ch_miscchg) - 1 Or Fra(R[90]) Return 
Mat Read #ch_miscchg,R[90],0;MS1;
If MS1[2] <> 2 Return 
Mat Read #ch_miscchg,R[90],38;MS2;
For X1 = 0 To 9
  If Not(MCODE[X1]) Goto AMCODE
Next X1
Return 
AMCODE: Rem
If GMCHG[X] Or GMCOST[X] OR custom_customer$ = "MIDATLANTIC"
  MCODE[X1] = GMCODE[X]
  MCHARGE[X1,0] = GMCHG[X]
  MCHARGE[X1,1] = GMCOST[X]
  MCTXBL[X1] = MS2[0]
  T2[4] = T2[4] + MCHARGE[X1,0]
  TOT[0] = TOT[0] + MCHARGE[X1,1]
End If 
Return 
DO_MESSAGES: Rem
If FLAG[7] Print #CH_LPT;""; \ pline = pline + 1
!M1 = 401
!M1$ = " ",M1$
!M1$ = "CONF# " + GIVEN_CONF$
!Gosub WRITEMESSAGE
If CH_INPUT[3] <= 0 Return 
work$ = " ",work$
work$ = HDR$
LOOP_MESSAGES: Rem
Search #CH_INPUT[3],3,1;work$,WREC[3],E \ If E Return 
If work$[1,18] <> HDR$[1,18] Return 
Mat Read #CH_INPUT[3],WREC[3],18;SPTYPE$;
Mat Read #CH_INPUT[3],WREC[3],20;SP1$;
Gosub PARSE_MRECORD
M1 = pos2;X1 = 1
If GIVEN_COMMENTS$[1,40] = SPACES$[1,40] Let X1 = 2
CHK_qom: Rem
If X1 = 2 And GIVEN_COMMENTS$[41,80] = SPACES$[1,40] Goto LOOP_MESSAGES
K6$ = " ",K6$;K6$[1,6] = H0[7] Using "######"
K6$[7,9] = M1 Using "###"
Search #ch_qom,2,1;K6$,REC_qom,E \ If E > 1 Gosub ERR_SEARCH_LOGGED
If Not(E)
  M1 = M1 + 1 \ If M1 > 999 Goto LOOP_MESSAGES
  Goto CHK_qom
End If 
M1$ = SPACES$
If X1 = 1 Let M1$ = GIVEN_COMMENTS$[1,40]
If X1 = 2 Let M1$ = GIVEN_COMMENTS$[41,80]
Gosub WRITEMESSAGE
If X1 = 1 Let X1 = 2 \ Goto CHK_qom
Goto LOOP_MESSAGES
WRITEMESSAGE: Rem
K6$ = " ",K6$;K6$[1,6] = H0[7] Using "######"
K6$[7,9] = M1 Using "###"
E = 2 \ Search #ch_qom,1,0;K6$,REC_qom,E \ If E Return 
Search #ch_qom,4,1;K6$,REC_qom,E \ If E Return 
Rem
Mat Write #ch_qom,REC_qom,0;M1$
Mat Write #ch_qom,REC_qom,40;M1
QUOTENUM=H0[7]
Mat Write #ch_qom,REC_qom,44;QUOTENUM;
Rem
If FLAG[7]
  Print #CH_LPT;K6$[1,6];" ";K6$[7,10];" ";M1$;" "
  pline = pline + 1
End If 
Return 
Do_multcust: ! do the mult customer file
let keycartmc$=hdr$
loop_multcust: ! do the loop
search #ch_cartmc,3,1;keycartmc$,rec_cartmc,e\if e =2 return
if e gosub err_search_logged
if keycartmc$[1,18]<>hdr$[1,18] return
let mccust=keycartmc$[19,28]
if not (mccust) goto loop_multcust:
let keycstqt1$=" ",keycstqt1$
let keycstqt1$[1,6]=h0[7] using "######"
let keycstqt1$[7,12]=mccust using "######"
rec_cstqt=rec_qoh
search #ch_cstqt,4,1;keycstqt1$,rec_cstqt,e\if e gosub err_search_logged
let keycstqt2$=" ",keycstqt2$
let keycstqt2$[1,6] =mccust using "######"
let keycstqt2$[7,12]=h0[7] using "######"
search #ch_cstqt,4,2;keycstqt2$,rec_cstqt,e\if e gosub err_search_logged 
goto loop_multcust:


goto loop_multcust:
RECALC_SHIPDATE: Rem
H0[10]= H0[9]
H0[10] = GIVEN_FLD[9]
If H0[10] < 1 Let H0[10] = cdate[2]
X2 = H0[10] \ Gosub YMD2JUL \ X2 = 0
JDATE[0] = X2
X2 = cdate[2] \ Gosub YMD2JUL \ X2 = 0
JDATE[1] = X2
If JDATE[0] < JDATE[1] Let H0[10] = cdate[2]
X2 = H0[10] \ Gosub YMD2JUL \ X2 = 0
X2 = X2 + D0
If P60$[16,16] = "Y"
  Search T2$,"Y",E
  If E
ZONE_DAY_CHK: POS_ = X2 Mod 7
    If T2$[POS_ + 1,POS_ + 1] <> "Y" Let X2 = X2 + 1 \ Goto ZONE_DAY_CHK
  End If 
End If 
work$ = X2 Using "&&&&&"
JDATE[0] = X2 \ JDATE[1] = X2 \ E = 0
Call "JULIANUTIL",JDATE[],X$,E
X2 = X$
H0[10] = X2 !;H5[1] = X2
PARAM[0] = H4[2];PARAM[1] = H5[8]
cdate[3] = H0[10];cdate[4] = 1;cdate[5] = 0
Call "validdate",cdate[3],cdate[4],cdate[5],PARAM[]
If cdate[4] <> -2 Let H0[10] = cdate[3];H5[1] = cdate[3]
Return 
GET_SHIPLIST: Rem
KSHIPLIST$ = KCUST$;REC_SHIPLIST = 0
If GIVEN_FLD[5] >= 0
  KSHIPLIST$[7,13] = (GIVEN_FLD[5] / 10 ^ 6) Using ".&&&&&&"
  Search #ch_shiplist,2,1;KSHIPLIST$,REC_SHIPLIST,E \ If E > 2 Gosub ERR_SEARCH_LOGGED
  If Not(E)
    Mat Read #ch_shiplist,REC_SHIPLIST,0;SA$
    Mat Read #ch_shiplist,REC_SHIPLIST,142;SC1
    Mat Read #ch_shiplist,REC_SHIPLIST,150;SR$
    Mat Read #ch_shiplist,REC_SHIPLIST,184;SL2
    Mat Read #ch_shiplist,REC_SHIPLIST,204;SI$
    Mat Read #ch_shiplist,REC_SHIPLIST,390;SLSLSM;
    Unlock #ch_shiplist
    SRN[1] = Int(Fra(SC1) * 10 ^ 6)
    SRN[3] = 1
    If SRN[1] > 0 Let SRN[3] = 2
    H4[1] = SR$[26,31]
    If SL2[0] Let H4[0] = SL2[0]
    If SL2[3]>0 Let A0[3] = SL2[3]
    H5[12] = SL2[1]
    IF SL2[3]>0 LET SRN[4] = SL2[3]
    S2$[19,20] = SR$[32,33]
    A1$[61,137] = SA$[31,107]
    A2$[1,10] = SA$[108,117]
    A3$[7,21] = SR$[13,25]+"            "  ! there have been nulss in sr$
  Else 
    REC_SHIPLIST = 0
    SR$ = SPACES$
    Mat SL2 = Zer \ SL2 = 0
  End If 
Else 
  REC_SHIPLIST = -1
  Mat SL2 = Zer \ SL2 = 0
End If 
IF ROUTING<1 OR ROUTING>106
	If SR$[1,12] <> SPACES$[1,12] Let V0$ = SR$[1,12]
ENDIF
Return 
GET_ZONE_INFO: Rem
S5 = 0;D0 = 0
If KZONE$[1,2] <> SPACES$[1,2]
  Search #ch_zone,2,1;KZONE$,REC_ZONE,E
  If E
    S5 = 0;D0 = 0
    REC_ZONE = 0
  Else 
    Read #ch_zone,REC_ZONE,28,LOCKTIMEOUT;D0
    Read #ch_zone,REC_ZONE,32,LOCKTIMEOUT;S5
    Read #ch_zone,REC_ZONE,36,LOCKTIMEOUT;T2$;
  End If 
End If 
If P61$[34,34] = "Y"
  REC_ZONE = -1
  BASE = H0[9]
  H0[10] = H0[9]
SHIP_DATE_LOOP: Call "mxohcszone.dl4",SRN[2],SRN[1],BASE,H5[8],H4[2],REC_ZONE,KZONE$,H4[1],cszc
  If REC_ZONE <> -1
    X2 = H0[10] \ Gosub YMD2JUL \ X2 = 0
    JDATE[0] = X2
    X2 = REC_ZONE \ Gosub YMD2JUL \ X2 = 0
    JDATE[1] = X2
    X2 = JDATE[0] - JDATE[1]
    If X2 > 0 And X2 < 265
      BASE = BASE + 1
      Goto SHIP_DATE_LOOP
    End If 
    H0[10] = REC_ZONE
   ! H5[1] = REC_ZONE
    S2$[19,20] = KZONE$[1,2]
    Search #ch_zone,2,1;KZONE$,REC_ZONE,E
    If E = 0 Read #ch_zone,REC_ZONE,32,LOCKTIMEOUT;S5
  End If 
Else 
  If SRN[1] = 0
    Gosub RECALC_SHIPDATE
  Else 
    H0[10] = GIVEN_FLD[9]
    If H0[10] < 1 Let H0[10] = cdate[2]
    X2 = H0[10] \ Gosub YMD2JUL \ X2 = 0
    JDATE[0] = X2
    X2 = cdate[2] \ Gosub YMD2JUL \ X2 = 0
    JDATE[1] = X2
    If JDATE[0] < JDATE[1] Let H0[10] = cdate[2]
    Gosub RECALC_SHIPDATE
  End If 
End If 
Return 
CSMZONE: Rem
If Not(SRN[2]) Let SRN[2] = H0[4]
If Not(H0[9]) Let H0[9] = cdate[1]
Call "MXOHCSZONE",SRN[2],SRN[1],H0[9],H5[8],H4[2],H0[10],X$[1,2],H4[1]
SR$[32,33] = X$[1,2]
S2$[19,20] = SR$[32,33]
Return 
CHECK_HOLD_PASSWD: Rem
FOUND = FALSE
If X1 >= 0 And X1 <= 14
  Mat Read #ch_cntrl,66,X1 * 16,LOCKTIMEOUT;PASSWD$;
  If PASSWD$[1,1] > " "
    FOUND = TRUE
  End If 
  E = 0
Else 
  E = 1
End If 
Return 
PACKHOLD: Rem
T2[21] = 0
For X1 = 0 To 11
  If HOLD[X1] Let T2[21] = T2[21] + 2 ^ X1
Next X1
Return 
YMD2JUL: Rem
X$ = X2 Using "&&&&&&"
Call DateToJulian(1,X$,X$,E) \ If E Return 
X2 = X$[1,5]
Return 1

PURGE_LOG: Rem
X1 = CURTM[4]
If X1 < 31 Let CURTM[5] = CURTM[4] + 1 Else Let CURTM[5] = 1
DDATA$ = CURTM[5] Using DDATA_MASK$
DLOG$ = CURTM[5] Using DLOG_MASK$
Call FindF(DDATA$,FOUND)
If FOUND
  Kill DDATA$
End If 
Call FindF(DLOG$,FOUND)
If FOUND
  Kill DLOG$
End If 
DDATA$ = CURTM[4] Using DDATA_MASK$
DLOG$ = CURTM[4] Using DLOG_MASK$
Return 

UPDATE_LOG: Rem
If DLOG$ = "" Or DLOG$[1,1] = " " Let DLOG$ = HOME$+ CURTM[4] Using "/prog/custom/files/6/slplog&&.txt"
!
SYSTEM "echo ''"+MSC$(0)+" "+MSG$+"'' >> "+DLOG$
Return 

ERR_TRAP_LOGGED: Rem
If Err 0 Gosub ERR_TRAP
If Spc(8) = 123
  msg$ = "*** Record locked at line " + Str$(Spc(10)) + " in " + Msc$(4)
Else If Spc(8) < 10000
  msg$ = "*** BE#" + Str$(Spc(8)) + " at line " + Str$(Spc(10)) + " in " + Msc$(4)
End If 
Gosub UPDATE_LOG
Goto ERR_TRAP

ERR_SEARCH_LOGGED: Rem
msg$ = "*** SE# " + Str$(E) + " at line " + Str$(Spc(16)) + " in " + Msc$(4)
Gosub UPDATE_LOG
Goto ERR_SEARCH

GET_QTY_AVAIL: Rem
work$ = " ",work$;AVAIL[1] = 0
work$ = A$[140,151];work$[13] = H4[2] Using "##"
NEXT_PRWH: Search #ch_prwh,2,1;work$,REC_PRWH,E \ If E Goto END_GET_QTY_AVAIL
Mat Read #ch_prwh,REC_PRWH,78;W3
Mat Read #ch_prwh,REC_PRWH,780;WHLV
AVAIL[1] = W3[0] - W3[2]
If P9$[28,28] = "Y" Let AVAIL[1] = AVAIL[1] + W3[1]
END_GET_QTY_AVAIL: work$ = " ",work$ \ Return 

support_email: !
	GOSUB UPDATE_LOG:
return

CHK_ORDER_NUM: REM check to see if there is a record in qoh with this order# 
	LET A$=" ",A$ \ LET A$[3,8]=x2 USING "######"                            
	FOR I=1 TO 99                                                            
		LET A$[1,2]=I USING "##"                                             
		SEARCH #ch_qoh,2,1;A$,x3[9],E \ IF E>1 GOSUB ERR_SEARCH:             
		IF NOT(E) RETURN                                                      
	NEXT I                                                                   
RETURN 

max_order:  ! max order number
	msg$="THE ORDER NUMBER HAS REACHED IT'S LIMIT!"  \ gosub support_email:
	GOTO ERR_SEARCH_LOGGED:
return


!----- start delete order here
rtnordedit: ! order edit routine                                        
mat read #ch_input[1],wrec[1],8;custid$;
mat read #ch_input[1],wrec[1],0;userid$;
!! will delete lines in buildorder                                      
let x2=custid$                                                          
let kcust$=x2 using "######"                                            
search #ch_cust,2,1;kcust$,rec_cust,e\if e gosub err_search_logged:     
gosub read_cust:                                                        
let work$=" ",work$                                                     
let work$[1,7]=x2 using "#######"                                        
let work$[8]=ordernum using "######"                                
search #ch_qoh,2,2;work$,rec_qoh,e\if e gosub err_search_logged:        
gosub readheads 
LET ORGSTAT=H6[2]
!!! delete messages                                                     
let work$=" ",work$                                                     
let work$[1,6]=ordernum using "######"                                  
srchdelmsg: ! search to delete messages                                 
search #ch_qom,3,1;work$,rec_qom,e\if e=2 goto enddelmsg:               
if e gosub err_search_logged                                            
let x2=work$[1,6]\if x2<>ordernum goto enddelmsg:                         
search #ch_qom,5,1;work$,rec_qom,e\if e gosub err_search_logged         
let e=3\search #ch_qom,1,0;work$,rec_qom,e\if e gosub err_search_logged:
goto srchdelmsg                                                         
enddelmsg: ! end delete messages
!! delete nonstock lines    
if not(ch_ns)
	ch_ns = openfile(1424,intco) \ If ch_ns = -1 Error 42   
endif            
let work$=" ",work$                                                       
let work$[1,6]=ordernum using "######"                                    
srchnsdel: ! search to delete nonstock items                              
search #ch_ns,3,1;work$,rec_ns,e\if e=2 goto enddelns:                    
if e gosub err_search_logged                                              
let x2=work$[1,6]\if x2<>ordernum goto enddelns:                          
search #ch_ns,5,1;work$,rec_ns,e\if e gosub err_search_logged:            
let e=3\search #ch_ns,1,0;work$,rec_ns,e\if e gosub err_search_logged:    
goto srchnsdel:                                                           
enddelns: ! end delete nonstock 
!!! delete out multiple customer
let work$=" ",work$                                                     
let work$[1,6]=ordernum using "######"                                  
srchdelcstqt: ! search to delete messages                                 
search #ch_cstqt,3,1;work$,rec_qom,e\if e=2 goto enddelcstqt:               
if e gosub err_search_logged                                            
let x2=ordernum\if x2<>ordernum goto enddelcstqt:                         
search #ch_cstqt,5,1;work$,rec_qom,e\if e gosub err_search_logged         
let keycstqt2$=" ",keycstqt2$
let keycstqt2$[1,6]=work$[7,12]
let keycstqt2$[7,12]=work$[1,6]
search #ch_cstqt,5,2;keycstqt2$,rec_qom,e\if e gosub err_search_logged
goto srchdelcstqt                                                  
enddelcstqt: ! end delete multiple customer quotes
!!! end delete multiple customer
! DELETE ORDER- ALL LINE & HEADER RECORDS                                       
! delete order lines                                                            
let work$=" ",work$                                                             
let work$[1,6]=ordernum using "######"                                          
CTR=0;BLANK$=" ",BLANK$                                                         
                                                                                
srchdelln:  SEARCH #ch_qol,3,1;work$,rec_qol,E \ if e=2 goto enddelln:          
IF E GOSUB Err_Search_Logged:                                                   
!IF E GOTO L_1100:                                                              
LET X2=work$[1,6]\ IF X2<>ordernum goto enddelln:                               
!!  GOTO L_1100: ! "hit next order                                              
LET F7=0;CTR=CTR+1                                                              
gosub readlines:                                                                
LET WHSE=LWHSE \ IF H5[7]=7 LET WHSE=H5[11]                                     
IF F7 GOTO endofdel: !                                                          
GOSUB DELLINE: ! "delete line keys                                              
goto srchdelln: ! GOTO L_1030: ! "next line                                     
                                                                                
enddelln: !  end deleting  
if delallflag                                                                   
        GOSUB delhead: ! L_1130: ! "delete header, ship to and totals           
endif                                                                           
goto endofdel:  ! end if the delete process                                          
                                                                                
delhead: !! "========================================= delete header/ship/totals
LET TOT_SELL=T2[0] ! "replace tot sell units w/total order $ for deletes        
let keyroh$=" ",keyroh$                                                         
LET keyroh$[1,2]=H0 USING "##"                                                  
LET keyroh$[3,8]=ordernum USING "######"                                        
LET keyroh$[9]=""                                                               
SEARCH #ch_qoh,2,1;keyroh$,rec_qoh,E\if e gosub err_search_logged:              
SEARCH #ch_qoh,5,1;keyroh$,rec_qoh,E\if e gosub err_search_logged:              
!! LET H0=20 ! "orders/invoices        
!! LET keyroh$[1,2]=H0 USING "##"   
!! SEARCH #ch_qoh,4,1;keyroh$,rec_qoh,E\if e gosub err_search_logged:
!!  WRITE #ch_qoh,rec_qoh;H0  
! "delete dir's 2 and 3                                                         
LET keyroh$=" ",keyroh$ \ LET keyroh$=H0[4] USING "#######"                      
LET keyroh$[8]=ordernum using "######"                                          
SEARCH #ch_qoh,2,2;keyroh$,rec_qoh,E                                            
if not (e)                                                                      
        SEARCH #ch_qoh,5,2;keyroh$,rec_qoh,E\if e gosub err_search_logged:      
endif                                                                           
LET keyroh$=" ",keyroh$ \ LET keyroh$=H0[11] USING "###"                        
LET keyroh$[4]=ordernum using "###### "                                          
SEARCH #ch_qoh,2,3;keyroh$,rec_qoh,E                                            
if not(e)                                                                       
        SEARCH #ch_qoh,5,3;keyroh$,rec_qoh,E \ IF E GOSUB Err_Search_logged:    
endif                                                                           
! DELETE TOTAL & SHIP TO                                                        
GOSUB readheads: ! "read header 
LET ORGSTAT=H6[2]
LET H4[1]=DL1;H5[1]=scr1 ! "port # & usercntrl rec #                            
LET H4=206! S9[3]                                                               
WRITE #ch_qoh,rec_qoh,56;TOT_SELL                                               
MAT  WRITE #ch_qoh,rec_qoh,78;H4                                                
MAT  WRITE #ch_qoh,rec_qoh,84;DL1$ ! "reason replaces contact                   
MAT  WRITE #ch_qoh,rec_qoh,104;H5                                               
LET E=3 \ SEARCH #ch_qos,1,0;keytmp$,H0[2],E \ IF E GOSUB Err_Search_logged:
LET E=3 \ SEARCH #ch_qot,1,0;keytmp$,H0[3],E \ IF E GOSUB Err_Search_logged:    
RETURN                                                                          
                                                                                
DELLINE: !  ! "====================================== delete lines              
let keyrol$=" ",keyrol$                                                         
let keyrol$[1,6]=ordernum using "######"                                        
let keyrol$[7,9]=l3[2] using "###"                                              
!!IF H5[7]=21 OR H5[7]=22 IF L3[2]=0 LET keyrol$[7,9]="   " ! need adjusted     
SEARCH #ch_qol,5,1;keyrol$,rec_qol,E \ IF E GOSUB Err_Search:                   
IF L3[0] GOTO enddelline: ! L_1780: ! "non stock                                
if not (l3[0]) ! stock item                                                     
        let keyrol2$=" ",keyrol2$                                               
        let keyrol2$[1,6]=l4 using "######"                                     
        let keyrol2$[7,12]=ordernum using "######"                              
        let keyrol2$[13,15]=l3[2] using "###"                                   
        !!IF H5[7]=21 OR H5[7]=22 IF L3[2]=0 LET A$[13,15]="   ";A$[16]=A1$[10] 
        search #ch_qol,2,2;keyrol2$,rec_qol,e\if e gosub err_search_logged:     
        search #ch_qol,5,2;keyrol2$,rec_qol,e\if e gosub err_search_logged:     
        IF H5[7]=15 LET L7[4]=L7[2] \ IF H0[5] LET L7[4]=0;S3[4]=0              
        IF L2=12 OR L7[2]<0 GOTO enddelline: ! L_1780: ! "credit memo           
endif
enddelline: ! end of the line                                                   
                                                                           
IF L1$[14,16]="KIT" GOSUB delkits: ! L_7200: ! "delete kit lines                
LET E=3 \ SEARCH #ch_qol,1,0;keyrol$,rec_qol,E \ IF E GOSUB Err_Search:     
!
! delete tag message lines
search #ch_qoltag,2,1;keyrol$,rec_qoltag,e \ if e>1 gosub err_search_logged:
if not(e)
	search #ch_qoltag,5,1;keyrol$,rec_qoltag,e \ if e gosub err_search_logged:
	LET E=3 \ SEARCH #ch_qoltag,1,0;keyrol$,rec_qoltag,E \ IF E GOSUB Err_Search:
end if
RETURN    
READHEADS: Rem                           
Mat Read #ch_qoh,rec_qoh,0;H0            
Mat Read #ch_qoh,rec_qoh,52;H3           
Mat Read #ch_qoh,rec_qoh,56;TOT_SELL     
Mat Read #ch_qoh,rec_qoh,64;LOCKPORT     
Mat Read #ch_qoh,rec_qoh,66;V0$          
Mat Read #ch_qoh,rec_qoh,78;H4           
Mat Read #ch_qoh,rec_qoh,84;H0$          
Mat Read #ch_qoh,rec_qoh,104;H5          
Mat Read #ch_qoh,rec_qoh,172;ST3         
Mat Read #ch_qoh,rec_qoh,272;H1$         
Mat Read #ch_qoh,rec_qoh,278;SLSM        
Mat Read #ch_qoh,rec_qoh,318;SCOM        
Mat Read #ch_qoh,rec_qoh,348;SMER        
Mat Read #ch_qoh,rec_qoh,378;SCST        
Mat Read #ch_qoh,rec_qoh,408;H6          
Mat Read #ch_qoh,rec_qoh,444;HMAT$       
Mat Read #ch_qoh,rec_qoh,446;P0$         
Mat Read #ch_qoh,rec_qoh,466;HFAX                             
Mat Read #ch_qoh,rec_qoh,474;HSTI                             
Mat Read #ch_qoh,rec_qoh,482;H2                               
Mat Read #ch_qoh,rec_qoh,486;OWHT                             
Mat Read #ch_qoh,rec_qoh,490;OWHT1                            
Mat Read #ch_qoh,rec_qoh,498;TOTGL                            
Mat Read #ch_qoh,rec_qoh,504;PICKBY;  
Mat Read #ch_qoh,rec_qoh,624;qhcurrid;
Mat Read #ch_qoh,rec_qoh,626;qhcurrfact;
Let x2=h0[1]\if h0[10]<>999999 gosub ymd2jul\let x2=0         
let jwdate=x2                                                 
let hwhse=h4[2]                                               
let rec_qos=h0[2] ! set ship to record #                      
let rec_qot=h0[3] ! set total record #                        
Mat Read #ch_qos,rec_qos,0;S1                                 
Mat Read #ch_qos,rec_qos,8;S1$                                
Mat Read #ch_qos,rec_qos,126;S2$                              
Mat Read #ch_qos,rec_qos,146;S5                               
Mat Read #ch_qos,rec_qos,150;S6                               
Mat Read #ch_qos,rec_qos,154;SRN;                             
Rem                                                           
Rem                                                           
Mat Read #ch_qot,rec_qot,0;T1                                 
Mat Read #ch_qot,rec_qot,8;T2                                 
Mat Read #ch_qot,rec_qot,164;JRNL 
Mat Read #ch_qot,rec_qot,168;MCODE       
Mat Read #ch_qot,rec_qot,208;MCHARGE     
Mat Read #ch_qot,rec_qot,328;TOT         
Mat Read #ch_qot,rec_qot,358;MCTXBL      
Mat Read #ch_qot,rec_qot,378;DCLVL;      
Mat Read #ch_qot,rec_qot,386;TOT1;       
Return                                   
                                         
Readlines: ! read line items             
Mat Read #ch_qol,rec_qol,0;L2            
Mat Read #ch_qol,rec_qol,8;L3            
Mat Read #ch_qol,rec_qol,16;L4           
Mat Read #ch_qol,rec_qol,32;L5           
Mat Read #ch_qol,rec_qol,56;L6           
Mat Read #ch_qol,rec_qol,80;L6$          
Mat Read #ch_qol,rec_qol,140;L1$         
Mat Read #ch_qol,rec_qol,160;L9          
Mat Read #ch_qol,rec_qol,168;L7          
Mat Read #ch_qol,rec_qol,246;PL          
Mat Read #ch_qol,rec_qol,250;UN          
Mat Read #ch_qol,rec_qol,256;S2          
Mat Read #ch_qol,rec_qol,260;S3          
Mat Read #ch_qol,rec_qol,368;MT$
Mat Read #ch_qol,rec_qol,370;S3$                                            
Mat Read #ch_qol,rec_qol,404;OLM                                            
Mat Read #ch_qol,rec_qol,446;EUN                                            
Mat Read #ch_qol,rec_qol,452;UNF                                            
Mat Read #ch_qol,rec_qol,494;LCO                                            
Mat Read #ch_qol,rec_qol,502;CST                                            
Mat Read #ch_qol,rec_qol,508;LTAX1                                          
Mat Read #ch_qol,rec_qol,514;CTWT                                           
Mat Read #ch_qol,rec_qol,524;GWGT                                           
Mat Read #ch_qol,rec_qol,532;GWGT1                                          
Mat Read #ch_qol,rec_qol,538;LTAX2                                          
Mat Read #ch_qol,rec_qol,542;QPB                                            
Read #ch_qol,rec_qol,548;LPRINTED                                           
Read #ch_qol,rec_qol,550;OWHS                                               
Read #ch_qol,rec_qol,552;LP_DATE                                            
Read #ch_qol,rec_qol,556;LP_TIME;                                           
Read #ch_qol,rec_qol,564;ROL0; 
Read #ch_qol,rec_qol,624;qlcurrid;
read #ch_qol,rec_qol,626;qlcurrfact;
If OWhs<=0 Or OWhs>99 Or Fra(OWhs) Let OWhs=0                               
If L4[3]<=0 Or L4[3]>99 Let L4[3]=H4[2]                                     
Let LWhse=L4[3] \ If OWhs Let LWhse=OWhs ! "changed but not thru Alloc yet  
return                                                                      
                                                                            
delkits: ! delete the kits here
WRITE #ch_qoh,rec_qoh; \ WRITE #ch_qol,L1; ! "unlock em               
ch_kit=openfile(1296)\if ch_kit= -1 Error 42                       
LET Keykit$=" ",Keykit$;Keykit$[1,6]=H0[7] USING "######"             
Keykit$[7,9]=l3[2] USING "###"                                        
srchkit: SEARCH #ch_kit,3,1;Keykit$,rec_kit,E\ if e goto endsrchkit:  
let x2=keykit$[1,6]\if x2<>h0[7] goto endsrchkit:                     
let x2=keykit$[7,9]\if x2<>l3[2] goto endsrchkit:                     
MAT  READ #ch_kit,rec_kit,0;KL$;                                      
MAT  READ #ch_kit,rec_kit,58;KL1;                                     
MAT  READ #ch_kit,rec_kit,70;KL2;                                     
MAT  READ #ch_kit,rec_kit,78;KL3;                                     
if kl1[5]=-2 or kl1[3]=1 goto endkitalloc:                            
let keypr$=kl$[13,24]                                                 
search #ch_prod,2,1;keypr$,rec_prod,e                                 
if not (e)                                                            
        mat read #ch_prod,rec_prod,256;a                              
        if kl3[1]>0 let a[1]=a[1]-kl3[1]                              
        if a[1]<0 let a[1]=0                                          
        mat write #ch_prod,rec_prod,256;a;                            
endif                                                                 
let keyprwh$=" ",keyprwh$                                             
let keyprwh$[1,12]=kl$[13,24]                                         
let keyprwh$[13,14]=kl1[0] using "##" 
search #ch_prwh,2,1;keyprwh$,rec_prwh,e                                        
if not (e)                                                                     
        mat read #ch_prwh,rec_prwh,78;w3                                       
        if kl3[1]>0 let w3[2]=w3[2]-kl3[1]                                     
        if w3[2]<0 let w3[2]=0                                                 
        mat read #ch_prwh,rec_prwh,78;w3;                                      
endif                                                                          
endkitalloc: ! end of kit allocation                                           
search #ch_kit,5,1;keykit$,rec_kit,e\if e gosub err_search_logged:             
let e=3\search #ch_kit,1,0;keykit$,rec_kit,e\if e gosub err_search_logged:     
!                                                                              
!                                                                              
GOTO srchkit: ! L_8710:                                                        
endsrchkit: ! this is the end                                                  
close #ch_kit                                                                  
READ #ch_qoh,rec_qoh,104;H5 \ READ #ch_qol,rec_qol;L2 ! "lock em               
RETURN                                                                         
                                                                               
                                                                               
endofdel: ! this end the delete                                                
return
!----- end delete order here
OUTEND: Rem
PROB[0] = T2[21]
result$ = msg$
End 
Rem
Rem
Rem
ERR_TRAP: Rem
If Spc(8) = 123
  Escdis 
  Escclr 
  Return -1
End If 
Goto ERR_MAIN
ERR_SEARCH: Rem
ENUM = E + 1000;ELINE = Spc(16);CTERR = 0
If E = 5 Let CTERR = Err(8)
msg$ = "RETURN STATUS",(E + (CTERR * .001))
msg$ = msg$,"/ STATEMENT",ELINE," IN PROGRAM "
Goto ERR_MAIN
ERR_MAIN: Rem
If Err 0 Rem
e$ = msg$
If Spc(8) <> 10000 Call suberr(e$,Spc(8),Spc(10),Msc$(2))
Call mainerr(e$,Spc(8),buttonlist$[],nextlist$[])
Stop 
Rem

DoQoltag: !
	rt_linenum = l3[2]
	tl2[0] = 11
	tl2[1] = H0[7]
	LPONUM$=" ",LPONUM$
	LJOBNUM$=" ",LJOBNUM$
	PSNUM$=" ",PSNUM$
	rt_msg$ = " ",rt_msg$
	for x2 = 1 to 16
		begIdx = ((x2-1)*30)+1
		endIdx = X2*30
		if begIdx > len(CARTDET.notes$)
			x2 = 17
		else
			rt_msg$[begIdx,endIdx] = CARTDET.notes$[begIdx,endIdx]
		end if
	next x2
	let e=2\search #ch_qoltag,1,0;TMP$,rec_qoltag,e\if e gosub err_search_logged:
		mat write #ch_qoltag,rec_qoltag,0;tl2
		mat write #ch_qoltag,rec_qoltag,12;rt_linenum
		mat write #ch_qoltag,rec_qoltag,14;LPONUM$
		mat write #ch_qoltag,rec_qoltag,44;LJOBNUM$
		mat write #ch_qoltag,rec_qoltag,74;PSNUM$
	if custom_customer$ = "MIDATLANTIC"
		mat write #ch_qoltag,rec_qoltag,14;rt_msg$
	else
		mat write #ch_qoltag,rec_qoltag,104;rt_msg$
	end if
	tmp$ = " ",tmp$
	tmp$[1,6] = tl2[1] using "######"
	tmp$[7,9] = rt_linenum using "###"
	search #ch_qoltag,4,1;tmp$,rec_qoltag,e \ if e gosub err_search_logged:
RETURN

