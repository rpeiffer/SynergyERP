! serp450c.dl4 - Commission report - "amalgamated"
! 1.0 03/24/2010 - initial conversion
!
! loadsave -w -n 100,10 -o prog/dxport/serp450c.dl4 src/serp450c.src
!
Rem MX450C - SALESMAN COMMISSION  AMALGAMATION
Rem AUTHOR:   MAR 27, 1987
Rem LAST UPDATE: roman  05/30/1991  fix prompts
! mod B.Swet 2/26/92 add cust sort moved gp% & cost in with column
! mod vst - 11/03/94 - adjusted tabs
! mod jlp - 8/18/95 recalc comm for all invoices not just $0 comm invs
! mod nate 5/7/96 -- Clean up
!	  kmm - 7/31/96 - use negative commission grid and mkbedit
!     jl - 12/04/96 - mod to use commission history file
!     tc - 2/21/97 - use 2 decimal places for CP to match comm in other places
!     jcs - 03/28/1997 - date compare julian
!     jlp - 08/19/98 cct112147, cct115015, cct110205 and cct110903 patch1050
!     blv 2/9/99 cct119745 - fixed line count problem with customer totals
!                rtn where it was adding 3 and header rtn adds one as well.
!     jliu 2/11/99 cct119954 check the min gross profit if the s1[1] is zero
!                in print line routine
!     sms 7/19/99 leap year
!     jlp cct122322 Fix purge flag, and renumber prompts
! tc 11/3/99 cct128503 make comm grid read match the one in mxslscom
! tc 01/04/00 cct131003 year checking for month/year not right
! jlp 1/4/00 (cct131003) add'l fix for year check for y2k
!rjs 05/04/00: cct133029 check cust for comm grid if there override slsm comm
! jliu 6/13/00 cct136890 - nc s/b assign if the o/t=1
! jliu 5/22/02 cct145980 - if running with the hypothetical grids ask
!      if the report should amalagte or not. - also bring it up to standard
! jliu 6/26/02 cct158506 if the items are marked to pruged, print the "*" 
!      before the inv/cm#. Add the unmark option in audit version
! dgh 07/05/05 cct192384 set BILLTO in case can not find customer record.
! 03/14/12  vst task12994 - added 'custom_customer$' code
!   Added Phillips Supply custom code for:
! 06/27/03 jcs cct168659 - add min GP$ and if below - no commission on line
! CUSTOM FOR ACTION - adjust SUBTOTAL CHECK
Rem BEDIT Version: 2.2 OBJECT CODE     Created: DEC  5, 2008  14:43:39
Rem /w2/papermaster/r2005//usr/acct/txc/work/r2005/mx/mx450c.src (univ2) [txc] {55032}
Rem  Copyright (c) 2008 Universal Business Systems, Inc.
Rem    **** ALL CHANGES MUST BE MADE IN SOURCE!!! ****
Rem
include "src/copyright.inc"
External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus
Declare External Function getmsg$,expandarray
Declare External Function AddToMYReports
Declare External Function openprinter

External Lib "dxblockcustom.lib"
Declare External Sub blockPrintersDropList
External Lib "ubsfunc.dl4"
Declare External Sub getportdefault,GetCostLevels
Declare External Function OpenFile,PDate$,FormatDate2$,getuidinfo$,JDate$
Declare External Function chkDteFrmt$,buildsort,getuidrec
Declare Intrinsic Sub DateToJulian,FindF,InpBuf,String,String,programdump
Declare intrinsic function findchannel
!Option Default Dialect IRIS1

If Err 0 Gosub ERR_TRAP
!If Spc(13) = 11 Print @0,0;"\177\UWHOTSPOT.\\HOTSPOT\\HOTSPOTIN.hsf\177\";
Dim 1%,CH_CNTRL,CH_SLSMCOMM,CH_SLSM,CH_CUST,CH_SARACT,CH_COMMGRID
Dim 1%,C1$[30],J$[75],J1$[75],J2$[20],J3$[40],J4$[75],J7$[50],K9$[50]
Dim 1%,H9$[50],P60$[50],CF$[1],P9$[50],J8$[8],J9$[50],J0$[10],J5$[75]
Dim 1%,K1$[50],K2$[20],K3$[20],S1$[30],Z1$[50],X$[100],MCODE$[2]
Dim 1%,RETVAL$[256],Z2$[2],URECFLAG
Dim 1%,E,N3,N4,S4[1],X1,A0[10],ARMONTH,CHNL,CHNLFREE,SCR1
Dim 1%,NCGRID,CUSTCOMMGRID,BOFLAG
Dim 2%,A2[5],J2,J3,J4,J7[2],J8,J9,N1,N2,R1,R3,R4,R5,S1[3],S3[1],SLSM_BREAK,X2
Dim 2%,C1[12],CG[13],CG1[99,11],DT3[1],H0[12],JWDATE,JDATE[1]
Dim 3%,T10[20],T7[1],BILLTO_BREAK,MTOTAL[94,1],T4[20],SLS1[3],ORDTYPE[20,1]
Dim 3%,PT4[5],PT8[5],PT9[5],PT10[5],A3[13],J,S2[1],T8[20],T9[20]
Dim 3%,S6[1],S7[1],T6[1],T5[1],CP,SCR,SMT[3],SMTD,INVH_REC,OREF[5],cfin[8]
DIM KEYINVL$[50],3%,REC_INVL,OLM[6],SX3[17],L5[3],MINGPD
Dim 3%,GPP,GPD,SLS3[9],4%,J1,EXCSALES,EXCCOST,INCCOMM
Dim SCRATCH$[80],AHYPO$[1],COMP$[30],SMAT$[2],K8$[50]
Dim e$[500],buttonlist$[5,50],nextlist$[5,100] ! dx error handling variables
dim tmp$[800],tmp1$[800],tmp2$[800],Message$[600],msg$[100],rstr$[2000],webstr$[2000]
dim action$[30],options$[30],userid$[8],3%,fdel$[10],bsdel$[10],esdel$[10],rdel$[10]
Dim ReportDir$[128],BaseName1$[128],Statusfile$[128],action1$[30],action2$[30]
dim List$[100,100],Custom_customer$[30]
! call dxopen() ! for standalone run
Call getsession(e$,CTLC,options$,action$,userid$,intCO,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$,Action1$,Action2$)
Def FNW(H) = Sgn(H) * (Int(Abs(H) * 1 + .5) * 1)
Def FNR(X) = Sgn(X) * (Int(Abs(X) * 100 + .5) * .01)
CH_CNTRL = 1
CH_SLSMCOMM = 2
CH_SLSM = 3
CH_CUST = 4
CH_SARACT = 5
CH_COMMGRID = 6
CH_INVH = 7
ch_invl =8
For J = 2 To 8
	Read J1 \ If J1 = -1 Goto L_830
	Read #CH_CNTRL,88,Abs(J1);J$;
	If J1 < 0 Ropen #J,J$ Else Open #J,J$
L_830: Next J
Data "2240","-1824","-1808","-1504","-1584","-1136","-1184"
Read #CH_CNTRL,3,0,10;COMP$;
Mat Read #CH_CNTRL,0,100,10;J8$
Mat Read #CH_CNTRL,0,120;ARMONTH;
Mat Read #CH_CNTRL,19,50,10;P9$;
Mat Read #CH_CNTRL,60,4;NCGRID;
Mat Read #CH_CNTRL,60,50,10;P60$;
Read #ch_cntrl,19,4;MinGPD; ! "minimum GP$ to get commission
mat read #1,115,60;custom_customer$;
Custom_customer$=UCase$(RTrim$(custom_customer$))
If NCGRID < 0 Or NCGRID > 999 Let NCGRID = 0
If MinGPD<0 Or MinGPD>9999 Let MinGPD=0
CF$ = P60$[37,37]
returnstatus=1;message$="OK"
CT = 0
Gosub GET_USRCTL
ARCODE = 0
Gosub HYPO_FIND
Gosub HIST_FIND
If action1$="GETLISTS" ! want's flags/droplists
  clear List$[]
  list$[0]=bsdel$,"SYSFLAG",fdel$
  List$[1]="ALLOWCH",fdel$,"ALLOWHYPO",fdel$ ! allow commission history prompts
  tmp$="N" \if havehist let tmp$="Y"
  tmp1$="N" \ if havehypo let tmp1$="Y"
  List$[2]=tmp$,fdel$,tmp1$,fdel$
  list$[3]=esdel$
  List$[4]=bsdel$,"PURGEFLAG",fdel$
  List$[5]="ID",fdel$,"DESC",fdel$
  List$[6]="1",fdel$,"1 - Ranges above",fdel$
  list$[7]="2",fdel$,"2 - Audit Version",fdel$
  ! List$[8]="3",fdel$,"3 - ",fdel$
  List$[8]=esdel$
  call addtostr(e$,rstr$,list$[])
  clear list$[]
  list$[0]=bsdel$,"Printers",fdel$
  List$[1]="Name",fdel$,"Id",fdel$,"Default",fdel$
  call AddToStr(e$,rstr$,List$[])
  pdfoption=1
  xmloption=1 ! BROWSER is OK  (We'll try and hope no timeout)
  Call blockPrintersDropList(rstr$,xmloption,pdfoption)
  Call AddToStr(e$,rstr$,esdel$) ! end of section 
  goto outend
Endif
X2=BuildSort(e$,20,0,9) ! build a sortwork on chan#9, keysize=20w/40C
! if x2<0 Error 10000 ! problem with build
MAXFIELDS = 7
If HAVEHYPO Let MAXFIELDS = 8
If HAVEHIST Let MAXFIELDS = 9
L_1000: Rem "=================================== get ranges
!Gosub SCREENDISP
!Goto EDT_ALL
!Goto INPUTS
!INPUTS: Rem
!Print @0,23;'CE';"Enter #:field to edit  R: reselect all  P: print  E: exit ";
!Input Len 16384 + 3;""X$ \ Call String(1,X$)
!Print @0,23;'CE';
!If X$ = "P" Goto MAIN
!If X$ = "E" Let J8 = 0 \ Goto OUTEND
!If X$ = "R" Goto EDT_ALL
!If X$ = "" Goto INPUTS
!X = X$
!If X < 1 Or X > MAXFIELDS Goto INPUTS
!Gosub EDTFIELD
!Goto INPUTS
!EDT_ALL: Rem
!For X = 1 To 7
!  If Not(ARCODE) If X = 2 Let X = 4
!  If ARCODE If X = 3 Or X = 2 Let X = 4
!  Gosub EDTFIELD
!Next X
!If HAVEHYPO Gosub HYPO_QUEST
!If HAVEHIST Gosub HIST_QUEST
!Goto INPUTS
EDTFIELD: Rem
!If Spc(13) = 11 Print @0,0;"\177\UWHOTSPOT.\\HOTSPOT\\HOTSPOTDIS.hsf\177\";
!On X Gosub EDARCODE,EDYEAR,EDDATE,EDSLSM,EDPAIDONLY,EDDETSUMM,EDPURGE,HYPO_QUEST,HIST_QUEST
!If Spc(13) = 11 Print @0,0;"\177\UWHOTSPOT.\\HOTSPOT\\HOTSPOTIN.hsf\177\";
!Return 
SCREENDISP: Rem --display prompts on screen
!Print 'CS';@0,0;"-MX450C-";@19,0;"SALESMAN COMMISSION AMALGAMATION";@55,0;Msc$(3)
!Print @0,2;" 1> Enter AR month to print or <CR> for date range ";
!Print @0,3;" 2> Enter year ## to print ";'CE';
!Print @22,5;'BR';"STARTING";@36,5;"ENDING";'ER';
!Print @0,6;" 3> DATE (MMDDYY) ";
!Print @0,7;" 4> SALESMAN ";
!Print @0,9;" 5> Pay commission on paid invoices only? ";
!Print @0,11;" 6> Print  D: detail or  S: summary? ";
!Print @0,12;" 7> 460 to purge:  (1/2) ";
!Print @0,13;"     1:  Ranges specified above"
!Print @0,14;"     2:  Audit Version (will not flag any to be purged) "
!If HAVEHYPO Print @0,16;" 8> Use  A: actual or  H: hypothetical commission grid? ";
!If HAVEHIST Print @0,18;" 9> Use  C: current or  H: historical slsm commission records? ";
YEAR_ = 0
N3 = 1
N4 = 999
PAID_ONLY = 0
SUMMARY = 0
HYPO = 0
!Return 
EDARCODE: Rem
J1$ = " " \ J0$ = "2   025102"
J5$ = "Enter A/R Month "
!Gosub L7000 \ K2$ = J4$
!Call String(1,K2$)
call dxget("ARMONTH",k2$)
k2$=RTrim$(K2$)
If K2$ = "" or k2$="0"
 ! Print @51,2;'CL';
  ARCODE = 0
  !Print @28,3;'CL';
  Goto EDDate !Gosub EDDATE
  !Return 
End If 
ARCODE = K2$
If ARCODE < 1 Or ARCODE > 12  ! Goto EDARCODE
	!If ARCODE
  !Print @22,6;'CL';
  !Gosub EDYEAR
  e$="Invalid A/R Month (1-12)"
  goto err_msg
End If 
!Return 
EDYEAR: Rem
If Not(ARCODE) goto EDDate ! Return 
J1$ = YEAR_ \ J0$ = "2   022803"
J5$ = "Enter Year (YY)"
!Gosub L7000 \ K2$ = J4$
!Call String(1,K2$)
call dxget("ARYEAR",tmp$)
tmp$=Trim$(tmp$)
if len(tmp$)>2 ! sent 4 digit?
	K2$=tmp$[3,4] ! just last 2
Else
	k2$=RTrim$(tmp$)
Endif
YEAR_ = K2$
!If ARCODE
  !Print @28,3;K2$;
!Else 
  !Print @28,3;'CL';
!End If 
!Return 
EDDATE: Rem
If ARCODE goto EDSLSM !  Return 
If STARTDATE = 0 Let STARTDATE = 700101
J1 = STARTDATE
J5$ = "Please Enter the Starting Date MMDDYY  "
J0$ = "5 00082206"
!Gosub L7000 \ X2 = 0
call dxget("STARTDATE",tmp$)
if tmp$="" let tmp$="01/01/1970"
tmp1$=chkDteFrmt$(E$,tmp$)
if tmp1$[1,1]<"0" and tmp1$[1,1]>"9" let tmp1$=""
  if tmp1$<>""
	tmp$=formatdate2$(tmp1$) ! mm/dd/yyyy to yyyymmdd
  Else
	tmp$="19"+StartDate using "&&&&&&"
  Endif
J1=tmp$[3,10]
If J1 Let X2 = J1 \ Gosub YMD2JUL \ let x2=-1 ! Goto EDDATE
if x2<=0
	returnstatus=0
	e$="Invalid Start Date"
	goto err_msg
Endif
STARTDATE = J1;JDATE[0] = X2
EDENDDATE: Rem "Ending
J0$ = "5 00083606"
J5$ = "Please Enter the Ending date MMDDYY    "
If ENDDATE = 0 Let ENDDATE = 591231
J1 = ENDDATE
!Gosub L7000
call dxget("ENDDATE",tmp$)
if tmp$="" let tmp$="12/31/2059"
tmp1$=chkDteFrmt$(E$,tmp$)
if tmp1$[1,1]<"0" and tmp1$[1,1]>"9" let tmp1$=""
  if tmp1$<>""
	tmp$=formatdate2$(tmp1$) ! mm/dd/yyyy to yyyymmdd
  Else
	tmp$="20"+EndDate Using "&&&&&&"
  Endif
J1=tmp$[3,10]
X2 = J1 \ Gosub YMD2JUL \ let x2=-1 ! Goto EDENDDATE
if x2<=0
	returnstatus=0
	e$="Invalid End Date"
	goto err_msg
Endif
ENDDATE = J1;JDATE[1] = X2
If JDATE[0] > JDATE[1]
  ! J7$ = "INVALID RANGE" \ Gosub L_7600 \ Goto EDDATE
  E$="Invalid Date Range"
  goto err_msg
End If 
!Return 
EDSLSM: Rem ***** INPUT SALESMAN RANGE == BWB == 4/9/87
J1$ = N3 Using "###" \ J0$ = "1 00032207"
J5$ = "Enter the starting salesman code maximum 999"
!Gosub L7000 \ K2$ = J$
call dxget("STSLSM",tmp$) \ if tmp$="" let tmp$=Str$(N3)
k2$=tmp$
N3 = K2$
J1$ = N4 Using "###" \ J0$ = "1 00033607"
J5$ = "Enter the ending salesman code maximum 999 "
! Gosub L7000 \ K3$ = J$
call dxget("ENDSLSM",tmp$) \ if tmp$="" let tmp$=Str$(N4)
k3$=tmp$
N4 = K3$
If N3 <= N4 Goto SLSMDONE
! J7$ = "INVALID RANGE" \ Gosub L_7600 \ Goto EDSLSM
e$="Invalid Salesperson Range"
goto err_msg
SLSMDONE: Rem
!Return 
EDPAIDONLY: Rem COMMISSION ON PAID INVOICES ONLY?
J1 = PAID_ONLY \ J0$ = "6   014509"
J5$ = "Enter Y or N "
!Gosub L7000
call dxget("COMMPAID",tmp$)
j1=0 \ if UCase$(tmp$)="Y" let j1=1
PAID_ONLY = 0 \ If J1 Let PAID_ONLY = 1
If PAID_ONLY
  !Print @0,10;"     Print only the paid invoices? ";
  J1 = PRT_PAIDONLY \ J0$ = "6   015310"
  J5$ = "Enter Y or N "
  !Gosub L7000
  call dxget("PRNTPAID",tmp$)
	j1=0 \ if UCase$(tmp$)="Y" let j1=1
  PRT_PAIDONLY = 0 \ If J1 Let PRT_PAIDONLY = 1
Else 
  !Print @0,10;'CL';
End If 
!Return 
EDDETSUMM: Rem  DETAIL OR SUMMARY
J5$ = "Enter  D: detail or  S: summary "
J0$ = "2 00014011"
If SUMMARY Let J1$ = "S" Else Let J1$ = "D"
! Gosub L7000
call dxget("DTLSUMM",tmp$)
J$=Trim$(UCase$(tmp$))
If J$ <> "D" And J$ <> "S" ! Goto EDDETSUMM
	e$="Answer D or S only"
	goto err_msg
Endif
SUMMARY = 0 \ If J$ = "S" Let SUMMARY = 1
!Return 
EDPURGE: Rem  paid only , all , or audit version ?
!Print @27,12;'CL';@5,19;'CL';
!Input @27,12;""Z1$
call dxget("PRGTYPE",tmp$)
z1$=tmp$
If Z1$ <> "1" And Z1$ <> "2" ! Goto EDPURGE
	e$="Answer is 1 or 2 only"
	goto err_msg
Endif
PURGEFLAG = Z1$
!If PURGEFLAG = 1 Print @5,19;'ER BR';" RANGES ENTERED ABOVE WILL BE PURGED WHEN 460 IS RUN ";'ER'
If PURGEFLAG = 2
  !Print @0,15;"     Unmark items that are marked for purging? ";
  J1 = UNMARK_PURGE \ J0$ = "6   015315"
  J5$ = "Enter Y or N "
  !Gosub L7000
  call dxget("UMKPRG",tmp$)
  J1=0 \ if tmp$="Y" let j1=1
  UNMARK_PURGE = 0 \ If J1 Let UNMARK_PURGE = 1
Else 
  !Print @0,15;'CL';
End If 
!Return 
HYPO_QUEST: ! If HYPO = 1 Print @56,16;"H"; Else Print @56,16;"A";
If Not(HAVEHYPO) goto Hist_Quest ! Return 
J5$ = "Enter  A: actual or  H: hypothetical commission grid"
J0$ = "2 00015616"
If HYPO Let J1$ = "H" Else Let J1$ = "A"
!Gosub L7000
call dxget("ACTHYPO",tmp$)
J$=UCase$(Trim$(tmp$))
If J$ <> "H" And J$ <> "A" ! Goto HYPO_QUEST
	e$="Answer is A:actual or H:hypothetical"
	goto err_msg
Endif
HYPO = 0 \ If J$ = "H" Let HYPO = 1
If J$ = "H"
  HYPO = 1
  Close #6
  Open #6,"2/COMMGRIDH" + Str$(IntCo) !Str$(Int((Spc(5) - Int(Spc(5) / 16384) * 16384) / 64))
Else 
  HYPO = 0
End If 
If HYPO
  ! Print @0,17;"     Amalgamate the report? ";
  J1 = HYPO_AMAG \ J0$ = "6   015317"
  J5$ = "Enter Y or N "
  ! Gosub L7000
  call dxget("AMALHYPO",tmp$)
  J1=0 \ if tmp$="Y" let j1=1
  HYPO_AMAG = 0 \ If J1 Let HYPO_AMAG = 1
Else 
  !Print @0,17;'CL';
End If 
!Return 
HIST_QUEST: ! If HIST = 1 Print @63,18;"H"; Else Print @63,18;"C";
if not(havehist) goto Main ! that's all folks
J5$ = "Enter  C: current or  H: historical slsm commission records"
J0$ = "2 00016318"
If HIST Let J1$ = "H" Else Let J1$ = "C"
! Gosub L7000
call dxget("CHCOMM",tmp$)
	J$=UCase$(RTrim$(tmp$))
If J$ <> "H" And J$ <> "C" ! Goto HIST_QUEST
	e$="Answer is C:current or H:historical only"
	goto Err_msg
Endif
HIST = 0 \ If J$ = "H" Let HIST = 1
If J$ = "H"
  HIST = 1
  Close #CH_SLSMCOMM
  SCRATCH$ = Str$(IntCo) ! Str$(Int((Spc(5) - Int(Spc(5) / 16384) * 16384) / 64))
  Open #CH_SLSMCOMM,"4/SSLSMCOMMH" + SCRATCH$
Else 
  HIST = 0
End If 
! Return 


MAIN: Rem continue
	call dxget("Printer",tmp$) ! let's see if 1 selected (-- = NONE)
	tmp$=rtrim$(tmp$)
	if tmp$[1,2]="--"
			Returnstatus=0
			e$="NO PRINTER SELECTED"
			goto ERR_MSG ! Done
	Endif
	onchannelno=0 ! zero for channel 
	printchan = openprinter(e$,onchannelno) 
	Toscreen=0
	if printchan=-1 let Toscreen=1 ! to browser
	!if toscreen ! UNREM TO NOT ALLOW XML
	!	Returnstatus=0
	!	e$="NO Browser Print"
	!	goto ERR_MSG ! Done
	!Endif
	let SCREENPRINT=toscreen
	! Call dxsave(0,"tmp/450cin.txt!") ! save web data sent

MAXLINES = 60 ! \ If SCREENPRINT Let MAXLINES = 20
LN = 99 \ J2 = 0
if screenprint ! xml 
	!<section>
  tmp$ = bsdel$,"450c",fdel$,rdel$
  call addtostr(e$,rstr$,tmp$)
  tmp$="SLSM",fdel$,"SLSM NAME",fdel$
  If not(Summary)
	tmp$=tmp$,"CUST",fdel$,"CUST NAME",fdel$
	tmp$=tmp$,"PRGFLG",fdel$,"REF NUM",fdel$
	tmp$=tmp$,"OT",fdel$,"MCODE",fdel$
	tmp$=tmp$,"REF DATE",fdel$
  Else
	tmp$=tmp$,"DATE",fdel$ ! on print_smt
  Endif
  tmp$=tmp$,"GP%",fdel$,"MU%",fdel$,"PR MTH",fdel$
  tmp$=tmp$,"SALES",fdel$,"COST",fdel$,"PROFIT",fdel$
  tmp$=tmp$,"COMMISSION",fdel$,"NEW COMM",fdel$
  If not(Summary)
	tmp$=tmp$,"COMM%",fdel$,"PAID",fdel$
  Endif
  tmp$=tmp$,rdel$
  call addtostr(e$,rstr$,tmp$)
  ! header
Else ! normal print - send in process
  Call setoutput(e$,rstr$,2) !2 flag puts 0 status section in w/print in process msg, puts </page> in
Endif
If Err 0 Gosub ERR_TRAP ! ESCAPE
K1$ = " ",K1$
Gosub DO_SORT
! Print @0,23;"Printing...please wait";'CL';
If Err 0 Gosub ERR_TRAP ! ESCAPE
COUNT = 0
TYPE = 0
! If J8 Print 'CS';
K1$ = N3 Using "###"


MAIN_LOOP: Rem
	Search #9,3,1;K1$,R1,E \ If E > 2 Gosub ERR_SEARCH
	If E Or K1$[1,1] = "~" Goto END_RANGE
	If K1$[18,18] = "!"
		! new header
		SALES = K1$[19,28]
		COST = K1$[29,38]
		Goto MAIN_LOOP
	End If 
	If Not(X9)
		X2 = K1$[10,15] \ Gosub JUL2YMD
		X9 = X2
	End If 
	! TYPE=99 - non-invoice (credit, etc.), 98 BO, 2 Direct, 1 Non Direct
	If Not(TYPE) Let TYPE = K1$[16,17]
	If Not(OTYPE) Let OTYPE = K1$[16,17]
	If K1$[16,17] = "99" Let CREDIT = 99 Else Let CREDIT = 0
	Mat Read #CH_SLSMCOMM,R1,0,10;S1
	Mat Read #CH_SLSMCOMM,R1,16;S2
	Mat Read #CH_SLSMCOMM,R1,28;S3
	Mat Read #CH_SLSMCOMM,R1,36;S4
	Mat Read #CH_SLSMCOMM,R1,40;S6
	Mat Read #CH_SLSMCOMM,R1,52;SMAT$
	Mat Read #CH_SLSMCOMM,R1,54;S7
	If HYPO If Not(HYPO_AMAG)
		SALES = S2[0]
		COST = S6[0]
	End If 
	COUNT = COUNT + 1
	! If Fra(COUNT / 100) = 0 Print @30,23;COUNT Using "###,###";
	TYPE_BREAK = K1$[16,17]
	O9 = K1$[16,17]
	Gosub GET_CUST
	If custom_customer$="ACTION" ! Custom break logic?
		!IF NOT(BILLTO_BREAK) LET BILLTO_BREAK=BILLTO
		IF BILLTO_BREAK AND BILLTO_BREAK<>BILLTO OR X9<>S1[3] OR TYPE<>TYPE_BREAK OR OTYPE<>O9 !'custom -valerie
			GOSUB commondate_totals
		endif
	Else
		If Not(BILLTO_BREAK) Let BILLTO_BREAK = BILLTO
		If BILLTO_BREAK <> BILLTO Or X9 <> S1[3] Or TYPE <> TYPE_BREAK Or OTYPE <> O9
			Gosub COMMONDATE_TOTALS
		End If 
	Endif
	! re-check ranges - not sure why as sort
	! should have pulled everything.
	If ARCODE And S4[0] <> ARCODE Goto MAIN_LOOP
	X2 = S1[3] \ Gosub YMD2JUL \ X2 = 0
	JWDATE = X2
	If Not(ARCODE) If JWDATE < JDATE[0] Goto MAIN_LOOP
	If Not(ARCODE) If JWDATE > JDATE[1] Goto MAIN_LOOP
	If S1[0] < N3 Goto MAIN_LOOP
	If S1[0] > N4 Goto END_RANGE
	If SMAT$ = "" Let SMAT$ = " "
	If SLSM_BREAK And SLSM_BREAK <> S1 Gosub SLSM_BREAK
	If Not(SUMMARY) And BILLTO_BREAK And BILLTO_BREAK <> BILLTO Gosub CUST_BREAK
	Gosub GET_SLSM
	Gosub GET_AR
	If TYPE = 99 ! "a credit
		T9 = 0 - T9
		S6 = 0 - S6
		S2 = 0 - S2;S2[1] = 0 - S2[1]
	End If 
	If TYPE <> 99 If PAID_ONLY If PRT_PAIDONLY If Not(PAID) Goto MAIN_LOOP
	If Not(SUMMARY) Gosub HEADER
	If HEADING
		Gosub PRINT_SLSM
		If SUMMARY = 0 If BILLTO_BREAK <> 0 Gosub PRINT_CUST
	End If 
	Gosub PRINT_LINE
	If PURGEFLAG = 2 If UNMARK_PURGE !"cct158507
		S4[1] = 0
		Mat Write #CH_SLSMCOMM,R1,36;S4;
	End If 
	Gosub CALC_TOTALS
Goto MAIN_LOOP

CALC_TOTALS: Rem ============================= TOTALS CALCULATIONS
If SUMMARY Gosub ACCUM_SMT
T3[0] = T3[0] + S6[0];T4[6] = T4[6] + T9;T4[7] = T4[7] + S2[1];T4[8] = T4[8] + NC
If Not(ARCODE) If S4[0] <> ARMONTH
  PT9[5] = PT9[5] + S2[0];PT8[5] = PT8[5] + S2[0]
  PT10[5] = PT10[5] + S2[0];PT4[5] = PT4[5] + S2[0]
Else 
  T9[5] = T9[5] + S2[0];T8[5] = T8[5] + S2[0]
  T10[5] = T10[5] + S2[0];T4[5] = T4[5] + S2[0]
End If 
T6[0] = T6[0] + S6[0];T5[0] = T5[0] + S6[0];T7[0] = T7[0] + S6[0]
T9[6] = T9[6] + T9;T8[6] = T8[6] + T9;T10[6] = T10[6] + T9
T9[7] = T9[7] + S2[1];T8[7] = T8[7] + S2[1];T10[7] = T10[7] + S2[1]
If CF$ = "C"
  If TYPE = 99 ! credit (don't need to check if paid or not)
    T9[8] = T9[8] + S2[1];T8[8] = T8[8] + S2[1];T10[8] = T10[8] + S2[1]
  Else 
    If T9 >= S2
      T9[8] = T9[8] + S2[1];T8[8] = T8[8] + S2[1];T10[8] = T10[8] + S2[1]
    End If 
  End If 
End If 
If CF$ = "A"
  If Abs(T9) >= Abs(S2)
    T9[8] = T9[8] + S2[1];T8[8] = T8[8] + S2[1];T10[8] = T10[8] + S2[1]
  End If 
End If 
If PURGEFLAG = 1
  If CF$ = "C"
    If TYPE = 99 ! credit (does not matter if paid or not)
      S4[1] = 1
    Else 
      If PAID_ONLY
        If T9 >= S2 Or PAID Let S4[1] = 1 Else Let S4[1] = 0
      Else 
        S4[1] = 1
      End If 
    End If 
  End If 
  If CF$ = "A"
    If PAID_ONLY
      If Abs(T9) >= Abs(S2) Or PAID Let S4[1] = 1 Else Let S4[1] = 0
    Else 
      S4[1] = 1
    End If 
  End If 
End If 
!Call String(3,SMAT$[1,1],M9) ! does NOT RETURN VALUE > 160!!!
!If TYPE <> 99 And TYPE <> 98
!  MTOTAL[(M9 - 160),0] = MTOTAL[(M9 - 160),0] + S2[0]
!  MTOTAL[(M9 - 160),1] = MTOTAL[(M9 - 160),1] + S6[0]
!End If 
Mat Write #CH_SLSMCOMM,R1,36;S4;
Return 
GET_SLSM: Rem ============================= GET SALESMAN NAME
If SLSM_BREAK = S1 Return 
J2$ = " ",J2$ \ J2$ = S1 Using "###"
Search #CH_SLSM,2,1;J2$,R3,E
If E = 1 Let S1$ = "** ERROR ** SALESMAN NOT FOUND" \ Goto L_3050
If E Gosub ERR_SEARCH
Mat Read #CH_SLSM,R3,0,10;S1$
Mat Read #CH_SLSM,R3,118;SLS1;
Mat Read #CH_SLSM,R3,862;SLS3;
L_3050: Return 

GET_CUST: Rem ============================= GET CUSTOMER
	For X = 0 To 12 \ C1[X] = 0 \ Next X
	J3$ = " ",J3$ \ J3$ = S3[1] Using "######"
	BILLTO = S3[1]
	Search #CH_CUST,2,1;J3$,R4,E
	If E = 1 Let C1$ = "** ERROR ** CUSTOMER NOT FOUND" \ Return 
	If E Gosub ERR_SEARCH
	Mat Read #CH_CUST,R4,30,10;C1$
	Mat Read #CH_CUST,R4,142;C1;
	Read #CH_CUST,R4,664;CUSTCOMMGRID;
	BILLTO = C1[4]
	mat read #ch_cust,r4,544;cfin;
Return 

GET_AR: Rem ============================= GET A/R RECORD
	A0[6] = 0
	PAID = 0
	J4$ = " ",J4$ \ J4$ = S3[1] Using "######"
	If S7 Let J4$[7] = S7 Using "##########" Else Let J4$[7] = S7[1] Using "##########"
	J4$[17,17] = K1$[29,29]
	Search #CH_SARACT,2,1;J4$,R5,E
	If E
		PAID = 99
		T9 = S2[0]
	Else 
		Mat Read #CH_SARACT,R5,0,10;A2
		Mat Read #CH_SARACT,R5,24;A3
		Mat Read #CH_SARACT,R5,124;A0;
		T9 = A3[1] + A3[2]
		If T9 >= S2 Let PAID = 99
		If Abs(A3[0] - T9) = 0 Let PAID = 99
		T1 = Int(Fra(A2[3]) * 100)
	End If 
Return 

PRINT_TOTALS: Rem ============================= TOTAL PRINT
if screenprint
	tmp$=" REPORT",fdel$,"** TOTALS **",fdel$
	If not(summary) ! need extra (CUST & ALL DETAIL FLDS)
		tmp$=tmp$,fdel$,fdel$,fdel$,fdel$,fdel$,fdel$,fdel$
	Endif
	tmp1$=""
	If (PT9[5] + T9[5]) tmp1$=FNW((PT9[5] + T9[5] - T5[0]) / (PT9[5] + T9[5]) * 100) Using " ----#%"
	tmp$=tmp$,LTrim$(tmp1$),fdel$
	tmp1$=""
	If T9[0] tmp1$=FNW((PT9[5] + T9[5] - T5[0]) / T9[0] * 100) Using "----#%"
	tmp$=tmp$,LTrim$(tmp1$),fdel$
	tmp1$=""
	If Not(ARCODE) tmp1$=PT9[5] Using "--------#.##"
	tmp$=tmp$,LTrim$(tmp1$),fdel$
	tmp$=tmp$,LTrim$(T9[5] Using "--------#.##"),fdel$
	tmp$=tmp$,LTrim$(T5[0] Using "--------#.##"),fdel$
	tmp$=tmp$,LTrim$((PT9[5] + T9[5] - T5[0]) Using "--------#.##"),fdel$
	tmp$=tmp$,LTrim$(T9[7] Using "--------#.##"),fdel$
	tmp$=tmp$,LTrim$(GRANDNEW Using "--------#.##"),fdel$
	if not(summary)
		tmp$=tmp$,fdel$,fdel$ ! comm%,pd
	Endif
	tmp$=tmp$,rdel$
	call addtostr(e$,rstr$,tmp$)
Else
	Gosub HEADER
	Print #0;"** TOTALS **";
	If (PT9[5] + T9[5]) Print #0; Using " ----#%"; Tab 32;FNW((PT9[5] + T9[5] - T5[0]) / (PT9[5] + T9[5]) * 100);
	If T9[0] Print #0; Using "----#%"; Tab 39;FNW((PT9[5] + T9[5] - T5[0]) / T9[0] * 100);
	If Not(ARCODE) Print #0; Using "--------#.##"; Tab 46;PT9[5];
	Print #0; Using "--------#.##"; Tab 59;T9[5];
	Print #0; Using "--------#.##"; Tab 72;T5[0];
	Print #0; Using "--------#.##"; Tab 85;PT9[5] + T9[5] - T5[0];
	Print #0; Using "--------#.##"; Tab 98;T9[7];
	Print #0; Using "--------#.##"; Tab 111;GRANDNEW
	Print #0;""
	LN = LN + 2
Endif
Return 
COMMONDATE_TOTALS: Rem ============================= CALC TOTALS FOR A COMMON DATE
	TOTNEW = TOTNEW + T4[8]
	GRANDNEW = GRANDNEW + T4[8]
	TOTNEWC = TOTNEWC + T4[8]
	CT = 0
	X9 = S1[3]
	NEWCOM = 0
	OTYPE = O9
	TYPE = TYPE_BREAK
	For X = 0 To 94 \ MTOTAL[X,0] = 0;MTOTAL[X,1] = 0 \ Next X
	For X = 0 To 20 \ T4[X] = 0;ORDTYPE[X,0] = 0;ORDTYPE[X,1] = 0 \ Next X
	T3[0] = 0
Return 
SLSM_BREAK: Rem ============================= SALESMAN TOTAL
If SUMMARY Gosub PRINT_SMT Else Gosub CUST_BREAK
if screenprint
	tmp$=Str$(SLSM_BREAK),fdel$," TOTALS **",fdel$
	if not(summary) ! need extra
		tmp$=tmp$,fdel$,fdel$,fdel$,fdel$,fdel$,fdel$,fdel$
	Endif
	tmp1$=""
	If PT8[5] + T8[5] tmp1$=FNW((PT8[5] + T8[5] - T6[0]) / (PT8[5] + T8[5]) * 100) Using " ----#%"
	tmp$=tmp$,LTrim$(tmp1$),fdel$
	tmp1$=""
	If T6[0] tmp1$=FNW((PT8[5] + T8[5] - T6[0]) / T6[0] * 100) Using "----#%"
	tmp$=tmp$,LTrim$(tmp1$),fdel$
	tmp1$=""
	If Not(ARCODE) tmp1$=PT8[5] Using "--------#.##"
	tmp$=tmp$,LTrim$(tmp1$),fdel$
	tmp$=tmp$,LTrim$(T8[5] Using "--------#.##"),fdel$
	tmp$=tmp$,LTrim$(T6[0] Using "--------#.##"),fdel$
	tmp$=tmp$,LTrim$((PT8[5] + T8[5] - T6[0]) Using "--------#.##"),fdel$
	tmp$=tmp$,LTrim$(T8[7] Using "--------#.##"),fdel$
	tmp$=tmp$,LTrim$(TOTNEW Using "--------#.##"),fdel$
	if not(summary)
		tmp$=tmp$,fdel$,fdel$ ! comm%,pd
	Endif
	tmp$=tmp$,rdel$
	call addtostr(e$,rstr$,tmp$)
Else
	Gosub HEADER
	Print #0;""
	Print #0;"** SALESMAN ";SLSM_BREAK;" TOTALS **";
	If PT8[5] + T8[5] Print #0; Using " ----#%"; Tab 32;FNW((PT8[5] + T8[5] - T6[0]) / (PT8[5] + T8[5]) * 100);
	If T6[0] Print #0; Using "----#%"; Tab 39;FNW((PT8[5] + T8[5] - T6[0]) / T6[0] * 100);
	If Not(ARCODE) Print #0; Using "--------#.##"; Tab 46;PT8[5];
	Print #0; Using "--------#.##"; Tab 59;T8[5];
	Print #0; Using "--------#.##"; Tab 72;T6[0];
	Print #0; Using "--------#.##"; Tab 85;PT8[5] + T8[5] - T6[0];
	Print #0; Using "--------#.##"; Tab 98;T8[7];
	Print #0; Using "--------#.##"; Tab 111;TOTNEW
Endif
SLSM_BREAK = 0;T8[5] = 0;T8[6] = 0;T8[7] = 0;T8[8] = 0;TOTNEW = 0;T6[0] = 0;PT8[5] = 0
LN = 9999
Return 
CUST_BREAK: Rem ============================= CUSTOMER TOTAL
If Screenprint
	If Not(SLSM_BREAK) tmp$=S1 Using "###",fdel$,S1$,fdel$
	If SLSM_BREAK tmp$=SLSM_BREAK Using "###",fdel$,S1$,fdel$
	tmp$=tmp$,BILLTO_BREAK using "######",fdel$," TOTALS **",fdel$
	tmp$=tmp$,fdel$,fdel$,fdel$,fdel$,fdel$ ! detl stuff
	tmp1$=""
	If PT10[5] + T10[5]
	  tmp1$=FNW((PT10[5] + T10[5] - T7[0]) / (PT10[5] + T10[5]) * 100) Using " ----#%"
	End If 
	tmp$=tmp$,tmp1$,fdel$
	tmp1$=""
	If T7[0] tmp1$=FNW((PT10[5] + T10[5] - T7[0]) / T7[0] * 100) Using "----#%"
	tmp$=tmp$,tmp1$,fdel$
	tmp1$=""
	If Not(ARCODE) tmp1$=PT10[5] Using "--------#.##"
	tmp$=tmp$,LTrim$(tmp1$),fdel$
	tmp$=tmp$,LTrim$(T10[5] Using "--------#.##"),fdel$
	tmp$=tmp$,LTrim$(T7[0] Using "--------#.##"),fdel$
	tmp$=tmp$,LTrim$((PT10[5] + T10[5] - T7[0]) Using "--------#.##"),fdel$
	tmp$=tmp$,LTrim$(T10[7] Using "--------#.##"),fdel$
	tmp$=tmp$,LTrim$(TOTNEWC Using "--------#.##"),fdel$
	if not(summary)
		tmp$=tmp$,fdel$,fdel$ ! comm%,pd
	Endif
	tmp$=tmp$,rdel$
	call addtostr(e$,rstr$,tmp$)
Else
	Gosub HEADER
	If HEADING Gosub PRINT_SLSM
	Print #0;""
	Print #0; Using "######";"** CUSTOMER ";BILLTO_BREAK;" TOTALS **";
	If PT10[5] + T10[5]
	  Print #0; Using " ----#%"; Tab 32;FNW((PT10[5] + T10[5] - T7[0]) / (PT10[5] + T10[5]) * 100);
	End If 
	If T7[0] Print #0; Using "----#%"; Tab 39;FNW((PT10[5] + T10[5] - T7[0]) / T7[0] * 100);
	If Not(ARCODE) Print #0; Using "--------#.##"; Tab 46;PT10[5];
	Print #0; Using "--------#.##"; Tab 59;T10[5];
	Print #0; Using "--------#.##"; Tab 72;T7[0];
	Print #0; Using "--------#.##"; Tab 85;PT10[5] + T10[5] - T7[0];
	Print #0; Using "--------#.##"; Tab 98;T10[7];
	Print #0; Using "--------#.##"; Tab 111;TOTNEWC
	Print #0;""
	LN = LN + 3
Endif
BILLTO_BREAK = 0
T10[5] = 0
T10[6] = 0
T10[7] = 0
T10[8] = 0
TOTNEWC = 0
PT10[5] = 0
T7[0] = 0
Return 

PRINT_LINE: Rem ============================= PRINT LINE
	NC = 0;CP = 0
	let excsales=0;exccost=0;inccomm=0
	if custom_customer$="PHILLIPS"
		if P60$[24,24]="Y" ! "commission by line- use what's there!!!
			Let NC=S2[1] ! "Comm $
			Let CP=S1[2] ! "comm %
			goto PHILLIPS_bypass_commbyline: !
		Endif
	endif
	If TYPE <> 99 And TYPE <> 98
		Gosub GET_GRID
		If Not(SLS1[1]) !"cct#119954
			If (SALES - COST) >= SLS3[0] ! greater than the min gross profit
				CP = SLS1[0]
			Else 
				CP = 0
			End If 
		End If 
		gosub getexcludes:
		!LET TMP_GPP=S2[0]-S6[0] 
		let tmp_gpp=(s2[0]-excsales)-(s6[0]-exccost)
		if cfin[8]
			iF TMP_GPP AND cfin[8] LET TMP_GPP=TMP_GPP-((S2[0]-excsales)*cfin[8]/100) 
		endif
		LET NC=FNR((TMP_GPP)*(CP/100))
		if inccomm<>0
			let nc=nc+inccomm
		endif
	Else 
		If CF$ = "C" Or (CF$ = "A" And (Abs(T9) >= Abs(S2) Or PAID))
			NC = S2[1]
			CP = S1[2]
		End If 
	End If 
	Rem IF COMMISSION GETS SET=0 & IT WAS SOME VALUE, PUT IT BACK
	Rem (BACKORDERS CHECK SEPER BELOW) CCT # 229853
	If NC = 0 And TYPE <> 98
		If S2[1] <> 0 Let NC = S2[1]
	End If 
	PHILLIPS_bypass_commbyline: ! 
	If S3[0] = 0 Or TYPE = 98
		NC = S2[1]
		CP = 0
	End If 
	If PAID_ONLY And Not(CREDIT) And Not(PAID) Let NC = 0
	If Not(SUMMARY)
		if screenprint
			If Not(SLSM_BREAK) tmp$=S1 Using "###",fdel$,S1$,fdel$
			If SLSM_BREAK tmp$=SLSM_BREAK Using "###",fdel$,S1$,fdel$
			tmp$=tmp$,Billto Using "######",fdel$,C1$,fdel$
			tmp1$=""
			If PURGEFLAG = 2 If S4[1] tmp1$="*"
			tmp$=tmp$,tmp1$,fdel$
			tmp1$=""
			If TYPE <> 99 tmp1$=S7[1] Using "########"
			If TYPE = 99 tmp1$=S7[1] Using "CR########"
			tmp$=tmp$,tmp1$,fdel$
			tmp$=tmp$,Str$(S3[0]),fdel$,SMAT$[1,1],fdel$
			X2 = S1[3] \ Gosub UNPACK_DATE
			tmp$=tmp$,X$[1,8],fdel$
			tmp1$=""
			If S2 tmp1$=FNW((S2[0] - S6[0]) / S2[0] * 100) Using " ----#%"
			tmp$=tmp$,LTrim$(tmp1$),fdel$
			tmp1$=""
			If S6[0] tmp1$=FNW((S2[0] - S6[0]) / S6[0] * 100) Using "----#%"
			tmp$=tmp$,LTrim$(tmp1$),fdel$
			tmp1$="";tmp2$="" ! 1=46, 2=59
			If Not(ARCODE) If S4[0] <> ARMONTH
				tmp1$=S2[0] Using "--------#.##"
			Else 
				tmp2$=S2[0] Using "--------#.##"
			End If 
			tmp$=tmp$,LTrim$(tmp1$),fdel$,LTrim$(tmp2$),fdel$
			tmp$=tmp$,LTrim$(S6[0] Using "--------#.##"),fdel$
			tmp$=tmp$,LTrim$((S2[0] - S6[0]) Using "--------#.##"),fdel$
			tmp$=tmp$,LTrim$(S2[1] Using "--------#.##"),fdel$
			tmp$=tmp$,LTrim$(NC Using "--------#.##"),fdel$
			tmp$=tmp$,LTrim$(CP Using "--#.##%"),fdel$
			tmp1$=""
			If PAID_ONLY And PAID tmp1$=" *"
			tmp$=tmp$,tmp1$,fdel$
			tmp$=tmp$,rdel$
			call addtostr(e$,rstr$,tmp$)
			CT = CT + 1
		Else ! printer
			If BILLTO_BREAK <> BILLTO And Not(HEADING) Gosub PRINT_CUST
			If PURGEFLAG = 2 If S4[1] Print #0; Tab 3;"*"; ! was 4
			If TYPE <> 99 Print #0; Using "########"; Tab 6;S7[1]; ! was 7
			If TYPE = 99 Print #0; Using "CR########"; Tab 4;S7[1]; ! was 5
			X2 = S1[3] \ Gosub UNPACK_DATE
			Print #0; Using "##"; Tab 16;S3[0];"  ";SMAT$[1,1];
			Print #0; Tab 23;X$[1,8];
			If S2 Print #0; Using " ----#%"; Tab 32;FNW((S2[0] - S6[0]) / S2[0] * 100);
			If S6[0] Print #0; Using "----#%"; Tab 39;FNW((S2[0] - S6[0]) / S6[0] * 100);
			If Not(ARCODE) If S4[0] <> ARMONTH
				Print #0; Using "--------#.##"; Tab 46;S2[0];
			Else 
				Print #0; Using "--------#.##"; Tab 59;S2[0];
			End If 
			Print #0; Using "--------#.##"; Tab 72;S6[0];
			Print #0; Using "--------#.##"; Tab 85;S2[0] - S6[0];
			Print #0; Using "--------#.##"; Tab 98;S2[1];
			Print #0; Using "--------#.##"; Tab 111;NC;
			Print #0; Using "--#.##%"; Tab 124;CP;
			If PAID_ONLY And PAID Print #0;" *";
			CT = CT + 1
			Print #0;""
			LN = LN + 1
			Gosub HEADER
			If HEADING
				Gosub PRINT_SLSM
				If Not(SUMMARY) Gosub PRINT_CUST
			End If 
		Endif
	End If 
	SLSM_BREAK = S1
	BILLTO_BREAK = BILLTO
Return 
!-----------------------------------------------------------------------------
getexcludes: ! read thru invoice history lines and exclude items with line commission
let excsales=0
let exccost=0
let inccomm=0
let keyinvl$=" ",keyinvl$
let keyinvl$[1,10]=s7[1] using "##########"
srchinvl: ! 
search #ch_invl,3,1;keyinvl$,rec_invl,e
if e<>0 return
let j1=keyinvl$[1,10]
if j1<>s7[1] return
mat read #ch_invl,rec_invl,404;olm;
if not(olm[5]) goto srchinvl:
mat read #ch_invl,rec_invl,32;l5;
mat read #ch_invl,rec_invl,260;sX3;
let excsales=excsales+l5[3]
let exccost=exccost+sX3[12]
let inccomm=inccomm+olm[6]
goto srchInvl:
return
!-----------------------------------------------------------------------------

PRINT_CUST: Rem ============================= PRINT CUSTOMER
if not(screenprint)
	Print #0; Using "######"; Tab 0;BILLTO;
	Print #0; Tab 7;C1$ \ LN = LN + 1 !  was 8
	Gosub HEADER
	If HEADING
	  Gosub PRINT_SLSM
	  If Not(SUMMARY) Gosub PRINT_CUST
	End If 
Endif
Return 
PRINT_SLSM: Rem ============================= PRINT SALESMAN
If not(Screenprint)
	If Not(SLSM_BREAK) Print #0; Using "###";"SALESMAN ";S1;" ";S1$
	If SLSM_BREAK Print #0; Using "###";"SALESMAN ";SLSM_BREAK;" ";S1$
	Print #0;" "
	LN = LN + 2
	Gosub HEADER
	If HEADING
	  Gosub PRINT_SLSM
	  If Not(SUMMARY) Gosub PRINT_CUST
	End If 
Endif
SALESMAN = 1
Return 
HEADER: Rem ============================= HEADINGS ROUTINE
if screenprint goto HDGDone
HEADING = 0
If LN < MAXLINES Return 
! If J2 If SCREENPRINT Input @0,23;"PRESS <CR> TO CONTINUE "J$ \ Print 'CS';
If J2 If Not(SCREENPRINT) Print #0;"\14\";
J2 = J2 + 1 \ LN = 2
If Not(SCREENPRINT) Print #0;"\15\";
Print #0; Tab 10;J8$; Tab (64 - Len(COMP$) / 2);COMP$; Tab 120;"PAGE";J2
Print #0;" - 450C - ";Msc$(3);
If Not(HYPO)
  Print #0; Tab 47;"S A L E S M A N   C O M M I S S I O N"
Else 
  Print #0; Tab 47;"*HYPOTHETICAL* SALESMAN COMMISSION"
End If 
LN = LN + 1
If ARCODE
  Print #0; Tab 56;"FOR A/R MONTH CODE ";ARCODE
  LN = LN + 1
Else 
  X2 = STARTDATE \ Gosub UNPACK_DATE
  Print #0; Tab 46;"RUN FOR DATES ";X$;" THROUGH ";
  X2 = ENDDATE \ Gosub UNPACK_DATE \ Print #0;X$
  LN = LN + 1
End If 
If PAID_ONLY Print #0; Tab 50;"COMMISSION ON PAID INV ONLY " \ LN = LN + 1
If PURGEFLAG = 1 Print #0; Tab 52;"RUN FOR PURGE ALL IN RANGE" \ LN = LN + 1
If PURGEFLAG = 2 Print #0; Tab 55;"AUDIT VERSION ONLY" \ LN = LN + 1
If Not(HYPO) Print #0; Tab 58;"AMALGAMATED";
If HYPO
  If HYPO_AMAG Print #0; Tab 58;"AMALGAMATED";
  If Not(HYPO_AMAG) Print #0; Tab 56;"NON-AMALGAMATED";
End If 
Print #0;" "
LN = LN + 1
Print #0; Tab 1;"CUST NO";
Print #0; Tab 11;"CUSTOMER NAME";
If Not(ARCODE) Print #0; Tab 47;"--- N E T    S A L E ---";
Print #0;" "
LN = LN + 1
Print #0; Tab 8;"INV/CM  OT MC";
Print #0; Tab 25;"DATE";
Print #0; Tab 34;"GP %";
Print #0; Tab 41;"MU %";
If Not(ARCODE)
  Print #0; Tab 49;"PRIOR MTH";
  Print #0; Tab 60;"CURRENT MTH";
Else 
  Print #0; Tab 60;"       SALE";
End If 
Print #0; Tab 80;"COST";
Print #0; Tab 91;"PROFIT";
Print #0; Tab 101;"COMM AMT";
Print #0; Tab 114;"NEW COMM";
Print #0; Tab 126;"COMM %"
Print #0;"\15\";
LN = LN + 2
HDGDone: ! done
HEADING = 1
Return 
!MAX = MTOTAL[0,0];MAXCODE = 0
!For MCODE = 1 To 94
!  If MTOTAL[MCODE,0] > MAX Let MAXCODE = MCODE \ MAX = MTOTAL[MCODE,0]
!Next MCODE
!Call String(4,MAXCODE + 160,MCODE$[1,1])
GET_GRID: Rem ============================= GET CORRECT GRID
GPD = SALES - COST
GPP = 0
If SALES Let GPP = FNW(((SALES - COST) / SALES) * 100)
If Not(SALES) And COST Let GPP = -100
GPP = Abs(GPP)
If GPP > 99 Let GPP = 99
If GPD < 0 And NCGRID
  SCR = NCGRID
Else 
  If CUSTCOMMGRID
    SCR = CUSTCOMMGRID
  Else 
    SCR = SLS1[1]
  End If 
End If 
K8$ = " ",K8$
K8$[1,3] = SCR Using "###"
K8$[4,5] = S3[0] Using "##"
K8$[6,6] = SMAT$[1,1]
K8$[7] = ""
Search #CH_COMMGRID,2,1;K8$,R8,E
If Not(E) Goto END_COMMGRID_SEARCH
K8$[4,5] = " 0"
Search #CH_COMMGRID,2,1;K8$,R8,E
If Not(E) Goto END_COMMGRID_SEARCH
K8$[4,5] = S3[0] Using "##"
K8$[6,6] = " "
Search #CH_COMMGRID,2,1;K8$,R8,E
If Not(E) Goto END_COMMGRID_SEARCH
K8$[4,5] = " 0"
Search #CH_COMMGRID,2,1;K8$,R8,E
END_COMMGRID_SEARCH: Rem
If E
  For I = 0 To 99 \ For J = 0 To 11 \ CG1[I,J] = 0 \ Next J \ Next I
  For I = 0 To 13 \ CG[I] = 0 \ Next I
Else 
  Mat Read #CH_COMMGRID,R8,6,10;CG
  Mat Read #CH_COMMGRID,R8,62;CG1;
  If CG[12] = 1 Let AMOUNT = SALES Else Let AMOUNT = SALES - COST
End If 
TOT = 0
If CG[12] = 1 And Abs(GPD) < CG[13] Goto L_6690
For REC = GPP To 1 Step -1
  For X8 = 0 To 11
    If CG1[REC,X8] Goto L_6620
  Next X8
Next REC
L_6620: Rem
If GPP > REC Let GPP = REC
REC = GPP
For X8 = 11 To 0 Step -1
  If CG[X8] <= Abs(AMOUNT)
    CP = CG1[REC,X8]
    Return 
  End If 
Next X8
L_6690: CP = 0
Return 

DO_SORT: Rem ============================= Sort Commission File
	! Print @0,23;"Sorting...please wait";'CL';
	COUNT = 0
	! N3 - staring salesrep
	K1$ = N3 Using "###"
	SORT_LOOP: Rem
	Search #CH_SLSMCOMM,3,1;K1$,R1,E
	If E And E <> 2 Gosub ERR_SEARCH
	If Not(E)
		Mat Read #CH_SLSMCOMM,R1,0;S1;
		Mat Read #CH_SLSMCOMM,R1,16;S2;
		Mat Read #CH_SLSMCOMM,R1,28;S3;
		Mat Read #CH_SLSMCOMM,R1,36;S4;
		Mat Read #CH_SLSMCOMM,R1,40;S6;
		Mat Read #CH_SLSMCOMM,R1,52;SMAT$
		Mat Read #CH_SLSMCOMM,R1,54;S7;
		COUNT = COUNT + 1
		! If Fra(COUNT / 100) = 0 Print @30,23;COUNT Using "###,###";
		Gosub GET_CUST
		! commission type
		TYPE = K1$[14,14]
		! check for billto - skip if none
		If Not(C1[4]) Goto SORT_LOOP
		! weed out if no match on ar year and month
		If YEAR_ Or ARCODE ! year could be zero with mm/yy
			If S4[0] <> ARCODE Goto SORT_LOOP
			X$ = S1[3] Using "&&&&&&";TEMPYR = X$[1,2]
			TEMPMTH = X$[3,4]
			If S4[0] <> TEMPMTH ! invoice date not match ar period on record
				If S4[0] >= 11 And TEMPMTH <= 3 ! period at eoy, but invoice
					TEMPYR = TEMPYR - 1
					If TEMPYR < 0 Let TEMPYR = 100 - TEMPYR
				End If 
				If S4[0] <= 2 And TEMPMTH >= 10 ! period at start of year ,  invoice
					TEMPYR = TEMPYR + 1
				End If 
			End If 
			If TEMPYR > 99 Let TEMPYR = TEMPYR - 100
			If TEMPYR < 0 Let TEMPYR = TEMPYR + 100
			If YEAR_ <> TEMPYR Goto SORT_LOOP
		End If 
		! weed out invoice date ranges
		X2 = S1[3] \ Gosub YMD2JUL \ X2 = 0
		JWDATE = X2
		If Not(ARCODE) If JWDATE < JDATE[0] Goto SORT_LOOP
		If Not(ARCODE) If JWDATE > JDATE[1] Goto SORT_LOOP
		! make sure in salesrep range
		If S1[0] < N3 Goto SORT_LOOP
		If S1[0] <= N4
			Gosub GET_AR
			! if not order type and AR has order type, use it
			If Not(S3[0]) And A0[6] > 0 Let S3[0] = A0[6]
			! HERE WE GO - SORT KEY
			! 1-3 is salesrep
			! 4-9 is customer billto
			! 10-15 is julian invoice / CM date
			! 16-17 is type defined as
			! 	98 = back order release - no amalg
			!       99 = not an invoice (credit, other type) - no amalg
			!       02 = direct invoice
			!	01 = not a direct, but an invoice
			! 18 is "~" indicates commission record
			!       "!" idicates summary header rec  
			! 19-28 is invoice / credit memo number
			! 29 is commission type
			K9$ = " ",K9$
			K9$[1,3] = K1$[1,3]
			K9$[4,9] = C1[4] Using "######"
			K9$[10,15] = JWDATE Using "######"
			If S3[0] = 2 Let OT = 2 Else Let OT = 1
			If K1$[14,14] = "1" Or K1$[14,14] = "2"
				K9$[16,17] = OT Using "##"
			Else 
				K9$[16,17] = "99"
			End If 
			Gosub CHECKBO
			If BOFLAG Let K9$[16,17] = "98"
			K9$[18,18] = "~"
			K9$[19,28] = S7[1] Using "##########"
			K9$[29,29] = K1$[14,14]
			K9$[30] = ""
			Search #9,4,1;K9$,R1,E
			If E Gosub ERR_SEARCH
			If HYPO If Not(HYPO_AMAG) Goto SORT_LOOP
			! only invoices that are not backordered
			! are amalgamated
			If TYPE = 1 And Not(BOFLAG) Gosub L_8000
			Goto SORT_LOOP
		End If 
	End If
Return

CHECKBO: Rem check if invoice was from a backordered order
	BOFLAG = 0
	If CH_INVH < 0 Return 
	J3$ = " ",J3$
	If K1$[14,14] = "1"
		J3$ = "30"
	Else 
		Return 
	End If 
	J3$[3] = S7[1] Using "##########"
	Search #CH_INVH,2,1;J3$,INVH_REC,E
	If E > 1 Gosub ERR_SEARCH
	If E Return 
	Mat Read #CH_INVH,INVH_REC,0;H0;
	Mat Read #CH_INVH,INVH_REC,512;OREF;
	Rem WE MIGHT AS WELL CK THE BO COUNTER IF THE ORDER # STAYS THE SAME
	If H0[5] > 0 Let BOFLAG = 1
	If OREF[2] And OREF[2] <> H0[7] Let BOFLAG = 1
Return 

L7000: ! Call "Input",J1,J$,J0$,J1$,J4$,J5$
Return 

UNPACK_DATE: Rem  *UNPACK DATE  X2 TO X$      V1.0  4/04/84  G.DOSCHER
X$ = " ",X$ \ X$[10] = ""
X$[1,3] = Int(X2 / 10 ^ 2 - Int(X2 / 10 ^ 4) * 10 ^ 2) + 10 ^ 2 Using "###"
X$[4,6] = Fra(X2 / 10 ^ 2) * 10 ^ 2 + 10 ^ 2 Using "###"
X$[7,9] = Int(X2 / 10 ^ 4) + 10 ^ 2 Using "###"
X$[4,4] = "/" \ X$[7,7] = "/" \ X$ = X$[2]
Return 
L_7800: Rem  *PACK DATE    X$ TO X2      V1.0  4/04/84  G.DOSCHER
X2 = X$[4,5] \ X1 = X$[1,2] \ X2 = X2 + X1 * 10 ^ 2
X1 = X$[7,8] \ X2 = X2 + X1 * 10 ^ 4
Return 

L_8000: Rem ============================= ADD HEADER REC FOR DATE
	! for the type
	H9$ = K9$
	J7$ = " ",J7$;SALES = 0;COST = 0
	H9$[18,18] = "!"
	H9$[19,50] = J7$[19,50]
	Search #9,3,1;H9$,H9,E
	If E Goto L_8100
	If H9$[1,17] <> K9$[1,17] Goto L_8100
	If H9$[18,18] <> "!" Goto L_8100
	SALES = H9$[19,28] \ COST = H9$[29,38]
	Search #9,5,1;H9$,H9,E
	If E Gosub ERR_SEARCH
	L_8100: H9$[18,18] = "!"
	H9$[19,50] = J7$[19,50]
	SALES = SALES + S2[0]
	COST = COST + S6[0]
	H9 = 0
	H9$[19,28] = SALES Using "-######.##"
	H9$[29,38] = COST Using "-######.##"
	Search #9,4,1;H9$,H9,E
	If E Gosub ERR_SEARCH
Return 

HYPO_FIND: Rem---------------------------------use hypothetical grid?
SCRATCH$ = "2/COMMGRIDH" + Str$(IntCo) ! Str$(Int((Spc(5) - Int(Spc(5) / 16384) * 16384) / 64))
Call FindF(SCRATCH$,SCR)
If Not(SCR) Or AHYPO$ <> "Y"
  HAVEHYPO = 0
Else 
  HAVEHYPO = 1
End If 
Return 
HIST_FIND: Rem--------------------------------------------------
SCRATCH$ = "4/SSLSMCOMMH" + Str$(IntCo) ! Str$(Int((Spc(5) - Int(Spc(5) / 16384) * 16384) / 64))
Call FindF(SCRATCH$,SCR)
If Not(SCR)
  HAVEHIST = 0
Else 
  HAVEHIST = 1
End If 
Return 
ACCUM_SMT: Rem ----------------------------------------------
SMTD = Int(S1[3] / 100)
SCRATCH$ = " ",SCRATCH$
SCRATCH$[1,1] = "~"
SCRATCH$[2] = S1[0] Using "###"
SCRATCH$[5] = SMTD Using "####"
Search #9,2,1;SCRATCH$,REC_SMT,E
If E
  E = 2
  Search #9,1,0;X$,REC_SMT,E \ If E Gosub ERR_SEARCH
  Search #9,4,1;SCRATCH$,REC_SMT,E \ If E Gosub ERR_SEARCH
  Mat SMT = Zer
  SMT = 0
  Mat Write #9,REC_SMT;SMT
End If 
Mat Read #9,REC_SMT;SMT
SMT[0] = SMT[0] + S2[0]
SMT[1] = SMT[1] + S2[1]
SMT[2] = SMT[2] + S6[0]
SMT[3] = SMT[3] + NC
Mat Write #9,REC_SMT;SMT;
Return 
PRINT_SMT: Rem Summary total-----------------------------------------
Gosub HEADER
If HEADING Gosub PRINT_SLSM
SCRATCH$ = " ",SCRATCH$
SCRATCH$ = "~"
SCRATCH$[2] = SLSM_BREAK Using "###"
SMT_LOOP: Rem
Search #9,3,1;SCRATCH$,REC_SMT,E \ If E > 2 Goto ERR_SEARCH
SCR = SCRATCH$[2,4]
If Not(E) And SCR = SLSM_BREAK
  Mat Read #9,REC_SMT;SMT;
  if screenprint ! xml
	If Not(SLSM_BREAK) tmp$=S1 Using "###",fdel$,S1$,fdel$
	If SLSM_BREAK tmp$=SLSM_BREAK Using "###",fdel$,S1$,fdel$
	tmp$=tmp$,SCRATCH$[7,8],"/",SCRATCH$[5,6],fdel$
	tmp1$=""
	If SMT[0] tmp1$=FNW((SMT[0] - SMT[2]) / SMT[0] * 100) Using " ----#%"
	tmp$=tmp$,tmp1$,fdel$
	tmp1$=""
	If SMT[2] tmp1$=FNW((SMT[0] - SMT[2]) / SMT[2] * 100) Using "----#%"
	tmp$=tmp$,tmp1$,fdel$
	tmp$=tmp$,LTrim$(SMT[0] Using "--------#.##"),fdel$
	tmp$=tmp$,LTrim$(SMT[2] Using "--------#.##"),fdel$
	tmp$=tmp$,LTrim$((SMT[0] - SMT[2]) Using "--------#.##"),fdel$
	tmp$=tmp$,LTrim$(SMT[1] Using "--------#.##"),fdel$
	tmp$=tmp$,LTRim$(SMT[3] Using "--------#.##"),fdel$
	call addtostr(e$,rstr$,tmp$)
  Else
	  Print #0;""
	  Print #0; Tab (24);SCRATCH$[7,8];"/";SCRATCH$[5,6];
	  If SMT[0] Print #0; Using " ----#%"; Tab 32;FNW((SMT[0] - SMT[2]) / SMT[0] * 100);
	  If SMT[2] Print #0; Using "----#%"; Tab 39;FNW((SMT[0] - SMT[2]) / SMT[2] * 100);
	  Print #0; Using "--------#.##"; Tab 59;SMT[0];
	  Print #0; Using "--------#.##"; Tab 72;SMT[2];
	  Print #0; Using "--------#.##"; Tab 85;SMT[0] - SMT[2];
	  Print #0; Using "--------#.##"; Tab 98;SMT[1];
	  Print #0; Using "--------#.##"; Tab 111;SMT[3]
	  LN = LN + 1
	Gosub HEADER
  Endif
  Goto SMT_LOOP
  If HEADING Gosub PRINT_SLSM
End If 
Return 
GET_USRCTL: Rem ---------------------------------------------------
CHNL = findchannel() ! 99 \ Gosub GETCHAN \ CH_USRCTL = CHNL
CH_USRCTL = CHNL
Ropen #CH_USRCTL,"cntrl/usercntrl"
CHNL = findchannel() ! CHNL - 1 \ Gosub GETCHAN \ CH_USRPORT = CHNL
CH_USRPORT = CHNL
Ropen #CH_USRPORT,"cntrl/userport"
! Read #CH_USRPORT,Spc(6);SCR1;
SCR1=getuidrec(e$,IntCo,Userid$)
If SCR1 = -1 Let AHYPO$ = "Y" Else Let AHYPO$ = "N"
If SCR1 > 0
  Read #CH_USRCTL,SCR1,338;AHYPO$;
End If 
Close #CH_USRPORT,#CH_USRCTL
Return 

NUM2DATE: Rem *UNPACK DATE  X2 TO X$      V1.0  4/04/84  G.DOSCHER
X$ = " ",X$ \ X$[10] = ""
X$[1,3] = Int(X2 / 10 ^ 2 - Int(X2 / 10 ^ 4) * 10 ^ 2) + 10 ^ 2 Using "###"
X$[4,6] = Fra(X2 / 10 ^ 2) * 10 ^ 2 + 10 ^ 2 Using "###"
X$[7,9] = Int(X2 / 10 ^ 4) + 10 ^ 2 Using "###"
X$[4,4] = "/" \ X$[7,7] = "/" \ X$ = X$[2]
If Not(X2) Let X$ = "        "
Return 
DATE2NUM: Rem *PACK DATE    X$ TO X2      V1.0  4/04/84  G.DOSCHER
X2 = X$[4,5] \ X1 = X$[1,2] \ X2 = X2 + X1 * 10 ^ 2
X1 = X$[7,8] \ X2 = X2 + X1 * 10 ^ 4
Return 
JUL2DATE: Rem REM DATE JULIAN X2 TO X$
DT3[0] = X2;FLAG = 1;X$ = " "
Call "JULIANUTIL",DT3[],X$,FLAG
Return 
YMD2JUL: Rem  REM  CONVERT YYMMDD TO JULIAN (RETURN=NOGOOD, +1=OKAY)
X$ = X2 Using "&&&&&&"
Call DateToJulian(1,X$,X$,E) \ If E Return 
X2 = X$[1,5]
Return 1
JUL2YMD: Rem  REM CONVERT JULIAN TO YYMMDD
DT3[0] = X2;DT3[1] = X2;FLAG = 0
Call "JULIANUTIL",DT3[],X$,FLAG
Return 
YM2LONGYEAR: Rem Rem Convert YYMM to YYYYMM
X$ = X2 Using "&&&&"
DT3[0] = X$[1,2];DT3[1] = X$[3,4]
If DT3[0] > 67 Let DT3[0] = 1900 + DT3[0]
If DT3[0] < 68 Let DT3[0] = 2000 + DT3[0]
X$[1,4] = DT3[0] Using "&&&&"
X$[5,6] = DT3[1] Using "&&"
X2 = X$[1,6]
Return 

END_RANGE: Rem ============================= END OF THIS RANGE
Gosub COMMONDATE_TOTALS
Gosub SLSM_BREAK
Gosub PRINT_TOTALS
! If J8 Print @0,23;"PRESS <CR> TO CONTINUE ";'CL'; \ Input ""J$
Goto OUTEND
OUTEND: Rem ============================= EXIT PROGRAM
!Print 'CS'
Close #CH_SLSMCOMM,#CH_SLSM,#CH_CUST,#CH_SARACT,#CH_COMMGRID
!Chain "MX000C"
If screenprint ! dx xml
  Call addtostr(e$,rstr$,esdel$) !end section
  Call setoutput(e$,rstr$,1) !1 flag puts 0 status seciton in, puts </page> in
Else
Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)     
Call AddToStr(e$,rstr$,WebStr$)                            
Call SetOutPut(e$,rstr$)
Endif
! try Call dxclose() else rem
End
ERR_SEARCH: Rem                                            
ENUM = E;ELINE = Spc(16);CTERR = 0                         
If E = 5 Let CTERR = Err(8)                                
e$ = "RETURN STATUS",(E + (CTERR * .001))                  
e$ = e$,"/ STATEMENT",ELINE," IN PROGRAM " + Msc$(4)       
Call programdump("tmp/450cse!","")                        
Goto ERR_MSG ! Error 10000                                 
Return ! End

ERR_MSG: ! send message                                    
ReturnStatus = 0 ! no good (ONLY DISPLAYS IF =1 ??)    
Message$ = e$                                              
Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)     
Call AddToStr(e$,rstr$,WebStr$)                            
Call SetOutPut(e$,rstr$)                                   
End                             

Rem {begin rtn.error.s}
ERR_TRAP: Rem *Error routine (escape trap)   V3.1 8/94 G.DOSCHER/REK
!
include "src/callmainerrnet.inc"
End
