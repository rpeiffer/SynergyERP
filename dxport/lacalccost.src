! >>> Program Lacalccost
!
! description Accounts Payable - lacalccost - calculate freight/misc charges per line
!
! loadsave -w -n 100,10 -o prog/dxport/lacalccost.dl4 src/lacalccost.src
!
! 1.0 mm/dd/yyyy change??
!
include "src/copyright.inc" ! dx

Rem BEDIT Version: 2.2 OBJECT CODE     Created: DEC  4, 2008  11:14:07
Rem /w2/papermaster/r2005//usr/acct/mary/work/custom/xrev9/lacalccost.src (univ2) [mary] {12469}
Rem  Copyright (c) 2008 Universal Business Systems, Inc.
Rem    **** ALL CHANGES MUST BE MADE IN SOURCE!!! ****
Rem

include "src/inc/fileedittrack.inc"

Declare Intrinsic Sub DateToJulian,FindF,InpBuf,String,Time,VerifyDate
! Option Default Dialect IRIS1
Declare Intrinsic Sub getglobals
Declare Intrinsic sub programdump,env
Declare Intrinsic function findchannel
! external libs for subs/functions
External Lib "libgeneral.lib"
Declare External Sub suberr,mainerr,GetSession,AddToStr,SetOutput,CreateNetStatus
External Lib "ubsfunc.dl4"
Declare External Function OpenFile,OpenMySQLMirror
include "src/inc/sql_prod.inc"
include "src/inc/filecosthist.inc"
External Lib "libprod.lib"
Declare External Sub mkcosthist
External Lib "libedittrack.lib"
Declare External Sub MakeEdittrack
Try
	Enter CH_POC,REC_POC,L1[],O1$,O2,O1,POSTDATE,POSTPER,message$,IntCo,rstr$,e$,rec_uac,lchan[]
! uses lchan to pass open channels, wchan is used for files that need to be opened in this program
!	let lchan[1]=33 ! product file
!	let lchan[2]=0 ! prod whse
!	let lchan[3]=31 ! purchase order header
!	let lchan[4]=32 ! purchase order line
!	let lchan[5]=24 ! appolh
!   let lchan[6]=0 ! fifolot
!	let lchan[7]=0 ! fifotrans
!	let lchan[8]=0 ! sordfleh
!	let lchan[9]=0 ! sordflel
!	let lchan[10]=0 ! sordflet
!	let lchan[11]=0 ! sordfles
!	let lchan[12]=0 ! customer
!	let lchan[13]=0 ! zone
!	let lchan[14]=0 ! sordtype
  dim action$[30],options$[30],userid$[8],3%,fdel$[10],bsdel$[10],esdel$[10],rdel$[10]
  dim e$[500]!,message$[600]
Rem lacalccost  -- recalculate average cost/fifo tier cost

!If Err 0 Gosub ERR_TRAP
! order file - line item (dim.invl.i is linked to dim.rol.i)            
dim 1%,ol3[3],pl[1],un[2],s2[1],eun[2],OWHS,olPrinted,CTWT[1]           
dim 2%,ol2[1],ol4[3],ol6[5],ol9[1],lco[1],oltax2,olP_Date,olP_Time     
dim 3%,ol5[3],ol7[12],Os3[17],olm[6],unf[6],cst[0],oltax1,INVNO,qpb,rol0 
dim ol6$[60],ol1$[20],mt$[2],s3$[33]                                     

!! order header (dim.invh is linked to dim.roh.i)      
dim 1%,oh3[1],oh4[2],LockPort,OWHT[1],PickBy[1]       
dim 2%,oh0[12],oh5[16],st3[24],slsm[9],oh6[8],ohfax[1]
dim 2%,ohSTI[1],oh2[0],OWHT1[1]                       
dim 3%,tot_sell,scom[4],smer[4],scst[4],TotGL,OREF[5] 
dim v0$[12],oh0$[20],oh1$[6],ohmat$[2],p0$[20]        


! order file - totals (dim.invt.i is linked to dim.rot.i)  
dim 1%,dclvl,mctxbl[9]                                     
dim 2%,mcode[9],t1[1],jrnl                                 
dim 3%,mcharge[9,1],t2[25],tot[4],INVNO    

! ! order file - ship to (dim.invs.i is linked to dim.ros.i)   
dim 1%,s6[1]                                                 
dim 2%,s1[1],s5                                              
dim 3%,srn[5],INVNO                                          
dim s1$[118],s2$[20]                                         

dim etr. as edittrack

Dim 1%,FIFOSPECCH[10],FIFOSPEC$[12]
Dim 1%,CNVTU[2],3%,CNVTA,AMOUNT,CURRQTY
Dim 1%,X1,APCLOSE,APL1[4],APL3
Dim 1%,FIFOSPECCH[10],SPO,C0[6],POGLFLAG,SPCFLAG
Dim 2%,CURJDATE,DT3[1],CURRDATE,FIFL,COMP,X2,POCNTRL,CURRPDATE
Dim 3%,POCOST,POCOST1,OLDAVG,OLDNET,NEWAVG,NEWNET,POFREIGHT,POMISC
Dim 3%,BPOCOST,BPOCOST1,OFCST
Dim 3%,CURRCOST,APQTY,LASTCOST,APL2[6],L3[6],PL4[23],SPCURRCOST
Dim 3%,LBSUNIT,LBSFACTOR,NETCOST,UOLDNET,UNEWNET,UNEWAVG,UOLDAVG
Dim 3%,PCT9[3],TOTFOCOST,TOTFNCOST,PRODLBS,PRODFACT,BASEQTY,BASECOST
Dim X$[10],P9$[50]
Dim P60$[50],P61$[256]
Dim FNAME$[16],SCRATCH$[80]
Dim APHKEY$[30],APLKEY$[40],POCKEY$[30],POLKEY$[30],PRODKEY$[50],POHKEY$[30]
Dim PRWHKEY$[30],FLT$[30],FLK$[50],KEYAPPOLH$[50]
Dim 3%,REC_PROD,REC_POH,REC_POL,REC_APH,REC_APL,REC_FIFOL,REC_FIFOT
Dim 3%,REC_PRWH,REC_APPOLH
Dim 3%,FTRECA,FTRECB,LETTER$[1]
Dim 2%,LASTAPCOST,3%,NETAPCOST
Rem {begin src/inc/dim.getchan.i}
Dim 1%,CHNL
Dim 3%,CHNLSCR,CHNLFREE
Rem {end dim.getchan.i}

! dim poh variables
dim 3%,h8[9],po3[12],poh7[1]
dim 1%,ot2[15],LM[1]
dim 2%,s9[9],flags[16],3%,parm[20],1%,pchan[99],wchan[99]
dim 3%,PREC[3],LD1,2%,otype,LTBL
dim 3%,orgloadcost, newloadcost, orgcost, orgamt, orgshipamt, orgfreight, orgother,CFIN[8],unf[6]
dim 1%,holdcodeflag[12],oldholdcodeflag[12]
dim keyroh$[50],keyrol$[50],keysot$[50],keycust$[50]
dim 3%,rec_roh,rec_rol,rec_sot,rec_cust

Dim 3%,OLDEXTCOST,NEWEXTCOST
Dim PCT$[12]
Dim 1%,PCT3[2],PCT7[2],PCT0
Dim 2%,PCT1[5]
Dim 3%,PCT2[5],PCT4[1],PCT5[9],PCT6[1]
Dim 1%,WHLM[1]
Dim 2%,W2[9]
Dim 3%,W3[24],WHMISC[6]
Dim WHFLG$[10]
Dim 1%,FL1[2]
Dim 2%,FL2[3]
Dim 3%,FL3[14]
Dim FL1$[80]
Rem {begin src/inc/dim.fifotrans.i}
Dim 1%,FT1[3]
Dim 2%,FT2[3]
Dim 3%,FT3[3]
Dim FT1$[72]
Rem {end dim.fifotrans.i}
Dim P1$[156],PRFLG$[10]
Dim 1%,PFU1[20]
Dim 2%,B[24]
Dim 3%,A[33],PFU2[6],PRPARC[3]
dim 1%,FCHan[5],3%,OLDNETCOST,OLDWHAVGCOST,OLDWHLASTCOST,OLDWHNETCOST
dim 3%,oldavgcost,oldlastcost
Dim U5$[50],groupid$[2],msg$[100],glpmsg$[100]
Dim buttonlist$[5,50],nextlist$[5,100] ! dx error handling variables
Dim tmp$[800],tmp1$[200],nextblockid$[8],WebStr$[600],blockid$[100]
Dim Blank$[100] \ let blank$=" ",Blank$
Rem open files
Def FNR(X) = Sgn(X) * (Int(Abs(X) * 100 + .5) * .01)
!X2 = Spc(5)
Dim PCH. as costhist
!COMP = Int((X2 - Int(X2 / 16384) * 16384) / 64)
comp=intco
Mat Read #1,60,50;P60$;
Mat Read #1,61,0;P61$;
Mat Read #1,19,50;P9$;
Mat Read #1,51,88;POGLFLAG;
Mat Read #1,51,76;SPO;
Mat Read #1,51,18;C0;
Read #1,3,172;CURRDATE;
X2 = CURRDATE \ Gosub YMD2JUL \ X2 = 0
If X2 Let CURJDATE = X2 Else Gosub GETCURJDATE
X2 = POSTDATE \ Gosub YMD2JUL \ X2 = 0
If X2 Let CURPDATE = X2 Else Let CURPDATE = CURJDATE
Read #1,3,192;FIFL;
!CHNL = 99
!!!!!!!! open files !!!!!!!!!!!!!!!!!!!!!!!
clear wchan[]
if not(lchan[1])
	chnl=findchannel() !Gosub GETCHAN
	CH_PROD = CHNL
	Read #1,88,1792;FNAME$;
	Open #CH_PROD,FNAME$
	let wchan[1]=ch_prod
else
	let ch_prod=lchan[1]
endif
if not(lchan[2])
	chnl=findchannel() !Gosub GETCHAN
	CH_PRWH = CHNL
	Read #1,88,1744;FNAME$;
	Open #CH_PRWH,FNAME$
	wchan[2]=ch_prwh
else
	let ch_prwh=lchan[2]
endif
if not(lchan[3])
	chnl=findchannel() !Gosub GETCHAN
	CH_POH = CHNL
	Read #1,88,2416;FNAME$;
	Ropen #CH_POH,FNAME$
	let wchan[3]=ch_poh
else
	let ch_poh=lchan[3]
endif
if not(lchan[4])
	chnl=findchannel() !Gosub GETCHAN
	CH_POL = CHNL
	Read #1,88,2432;FNAME$;
	Ropen #CH_POL,FNAME$
	let wchan[4]=ch_pol
else
	let ch_pol=lchan[4]
endif
if not(lchan[5])
	chnl=findchannel() !Gosub GETCHAN
	CH_APPOLH = CHNL
	FNAME$ = COMP Using "2/appolh#"
	Ropen #CH_APPOLH,FNAME$
	wchan[5]=ch_appolh
else
	let ch_appolh=lchan[5]
endif
If P60$[9,9] = "F"
	IF NOT(LCHAN[6])
		chnl=findchannel() !Gosub GETCHAN
		CH_FIFOL = CHNL
		Read #1,88,3008;FNAME$;
		Open #CH_FIFOL,FNAME$
		LET WCHAN[6]=CH_FIFOL
	ELSE
		LET CH_FIFOL=LCHAN[6]
	ENDIF
	IF NOT(LCHAN[7])
		chnl=findchannel() !Gosub GETCHAN
		CH_FIFOT = CHNL
		Read #1,88,3024;FNAME$;
		Open #CH_FIFOT,FNAME$
		WCHAN[7]=CH_FIFOT
	else
		ch_fifot=lchan[7]
	endif
End If
if not(lchan[8])
	ch_roh=findchannel()
	Read #1,88,1840;FNAME$;
	open #ch_roh,fname$
	let wchan[8]=ch_roh
else
	let ch_roh=lchan[8]
endif
if not(lchan[9])
	ch_rol=findchannel()
	Read #1,88,1888;FNAME$;
	open #ch_rol,fname$
	let wchan[9]=ch_rol
else
	let ch_rol=lchan[9]
endif
if not(lchan[10])
	ch_rot=findchannel()
	Read #1,88,1872;FNAME$;
	Open #ch_rot,fname$
	let wchan[10]=ch_rot
else
	ch_rot=lchan[10]
endif
if not(lchan[11])
	ch_ros=findchannel()
	Read #1,88,1856;FNAME$;
	Open #ch_ros,fname$
	let wchan[11]=ch_ros
else
	ch_ros=lchan[11]
endif
if not(lchan[12])
	ch_cust=findchannel()
	read #1,88,1808;fname$;
	Open #ch_cust,fname$
	let wchan[12]=ch_cust
else
	ch_cust=lchan[12]
endif
if not(lchan[13])
	ch_zone=findchannel()
	read #1,88,1920;fname$;
	Open #ch_zone,fname$
	let wchan[13]=ch_zone
else
	ch_zone=lchan[13]
endif
if not(lchan[14])
	ch_sot=findchannel()
	FNAME$ = COMP Using "3/SORDTYPE#"
	Ropen #CH_SOT,FNAME$
	let wchan[14]=ch_sot
else
	let ch_sot=lchan[14]
endif
sqlChan = OpenMySQLMirror(e$)
!!!!!!!!!!!!! end file open !!!!!!!!!!!!!!!!!!!!!!!!!!!!


!If Err 0 Gosub ERR_TRAP
Gosub READ_POC
Rem if not pct3[0] goto outend: ! line is not closed
If Not(PCT2[0]) And Not(PCT5[3]) Goto OUTEND
PL4[12] = 0;PL4[13] = 0
POLKEY$ = " ",POLKEY$;POLKEY$[1,6] = PCT1[0] Using "######"
POLKEY$[7] = PCT1[1] Using "###"
Search #CH_POL,2,1;POLKEY$,REC_POL,E \ If E > 1 Gosub ERR_SEARCH
If Not(E)
  Mat Read #CH_POL,REC_POL,232;PL4;
  Rem check if nonstock item and bypass
End If 
If PCT6[0]
  LBSUNIT = PCT6[0]
  LBSFACTOR = PCT6[1]
Else 
  LBSUNIT = PL4[12]
  LBSFACTOR = PL4[13]
End If 
POHKEY$ = " ",POHKEY$
POHKEY$ = PCT1[2] Using "######"
POHKEY$[7,12] = PCT1[0] Using "######"
APCLOSE = 0
SPCURRCOST = 0
Search #CH_POH,2,2;POHKEY$,REC_POH,E \ If E > 1 Gosub ERR_SEARCH
If E
  APCLOSE = 99
  let poh7=0;h8[6]=0;h8[7]=0! po freight
  let po3[5]=0;po3[11]=0;po3[12]=0
Else 
  Mat Read #CH_POH,REC_POH,248;APCLOSE;
  mat read #ch_poh,rec_poh,250;h8;
  mat read #ch_poh,rec_poh,350;po3;
  mat read #ch_poh,rec_poh,528;poh7;
End If 
Rem always read the product need to find out if weighted product
PRODKEY$ = " ",PRODKEY$
PRODKEY$[1,12] = PCT$[1,12]
Search #CH_PROD,2,1;PRODKEY$,REC_PROD,E \ If E > 1 Gosub ERR_SEARCH
If Not(E)
  Mat Read #CH_PROD,REC_PROD,0;P1$;
  Mat Read #CH_PROD,REC_PROD,156;B;
  Mat Read #CH_PROD,REC_PROD,256;A
  Mat Read #CH_PROD,REC_PROD,512;PFU1;
  Mat Read #CH_PROD,REC_PROD,554;PFU2;
  !PRODLBS = A[6];PRODFACT = A[5]
  Mat Read #ch_prod,rec_prod,596;prparc
	let prodlbs=a[6];prodfact=a[5]
	oldavgcost=b[21]
	OLDLASTCOST=B[10]
	OLDNETCOST=prparc[2]
Else 
  If PCT6[0] <> 0 And PCT6[1] <> 0
    A[6] = PCT6[0];A[5] = PCT6[1]
    PRODLBS = A[6];PRODFACT = A[5]
  Else 
    If PL4[12] <> 0 And PL4[13] <> 0
      A[6] = PL4[12];A[5] = PL4[13]
      PRODLBS = A[6];PRODFACT = A[5]
    Else 
      A[6] = 1;A[5] = 1
      PRODLBS = A[6];PRODFACT = A[5]
    End If 
  End If 
End If 
If L1[5] = -1 Or L1[5] = -3 ! cwt or catch weight
  If PCT6[0] <> 0 And PCT6[1] <> 0
    LBSUNIT = PCT6[0];LBSFACTOR = PCT6[1]
  Else 
    If PL4[12] <> 0 And PL4[13] <> 0
      LBSUNIT = PL4[12];LBSFACTOR = PL4[13]
    End If 
  End If 
End If 
If Not(PCT2[3]) And Not(PCT5[4] + PCT5[6]) And Not(PCT5[5] + PCT5[7]) Goto OUTEND
If PCT2[3] Or (PCT5[4] + PCT5[6]) Or (PCT5[5] + PCT5[7]) ! qty rec, freight, or misc ! ap amt has been received
  PRODKEY$ = " ",PRODKEY$
  PRODKEY$[1,12] = PCT$[1,12]
  Search #CH_PROD,2,1;PRODKEY$,REC_PROD,E \ If E > 1 Gosub ERR_SEARCH
  If E = 1 Goto OUTEND
  Mat Read #CH_PROD,REC_PROD,0;P1$;
  Mat Read #CH_PROD,REC_PROD,156;B;
  Mat Read #CH_PROD,REC_PROD,256;A
  Mat Read #CH_PROD,REC_PROD,512;PFU1;
  Mat Read #CH_PROD,REC_PROD,554;PFU2;
  PRODLBS = A[6];PRODFACT = A[5]
  Rem get base qty
  APQTY = PCT2[3] + PCT5[3]
  If Not(PCT2[3])
    APQTY = PCT2[0] + PCT5[3]
  End If 
  BASEQTY = APQTY
  If PCT0 ! catchweight item base qty is in lbs need in base um
    BASEQTY = Int((FNR(APQTY / LBSUNIT) * LBSFACTOR))
    If PCT5[3] Let BASEQTY = BASEQTY + PCT5[3]
  End If 
  If Not(BASEQTY) Goto OUTEND
  BASECOST = 0
  If PCT2[4]
    BASECOST = PCT2[4] / BASEQTY
  Else 
    If PCT9[3]
      BASECOST = PCT9[3] / BASEQTY
    Else 
      If PCT2[1]
        BASECOST = PCT2[1]
        If L1[5] = -1 Or L1[5] = -3
          A[5] = PRODFACT;A[6] = PRODLBS
          CNVTA = PCT2[1];CNVTU[0] = 0;CNVTU[1] = L1[5];CNVTU[2] = 2
          Gosub L_20000
          A[5] = LBSFACTOR;A[6] = LBSUNIT
          CNVTA = AMOUNT;CNVTU[0] = L1[5];CNVTU[1] = 0;CNVTU[2] = 2
          Gosub L_20000
          BASECOST = AMOUNT
          A[5] = PRODFACT;A[6] = PRODLBS
        End If 
      End If 
    End If 
  End If 
  LASTAPCOST = BASECOST
  POCOST = BASECOST
  BPOCOST = BASECOST
End If 
SPCURRCOST = POCOST
POCOST1 = POCOST
BPOCOST1 = BPOCOST
LBSUNIT = 0;LBSFACTOR = 0
If PCT6[0]
  LBSUNIT = PCT6[0]
  LBSFACTOR = PCT6[1]
Else 
  LBSUNIT = PL4[12]
  LBSFACTOR = PL4[13]
End If 
If APCLOSE<>0 !!!! it is closed
  POFREIGHT = PCT5[4] + PCT5[6]
  POMISC = PCT5[5] + PCT5[7]
Else 
  If PCT5[4] <> 0 Or PCT5[6] <> 0 Or PCT5[5] <> 0 Or PCT5[6] <> 0  ! has had freight and misc charges applied
    POFREIGHT = PCT5[4] + PCT5[6]
    POMISC = PCT5[5] + PCT5[7]
  Else 
    POFREIGHT = PCT5[4]
    POMISC = PCT5[5]
	! po is not close for ap
	IF Poh7[0]<>0 and (H8[6]+H8[7])=0! check if freight was on the purchase order and never applied to purchase order
		let pofreight=pct5[0] ! add po freight from receiving
	endif
	if PO3[5]<>0 and (PO3[11]+PO3[12])=0 ! check if misc charge received on purchase order and no ap applied
		let pomisc=pct5[1] ! add po misc from receiving
	endif
  End If 
End If 
If L1[5] = -1 Or L1[5] = -3
  If POFREIGHT
    If L1[5] = -1 Let POFREIGHT = POFREIGHT * 100
    CNVTA = POFREIGHT
    A[5] = LBSFACTOR;A[6] = LBSUNIT
    CNVTU[0] = L1[5];CNVTU[1] = 0;CNVTU[2] = 2
    Gosub L_20000
    POFREIGHT = AMOUNT
    A[5] = PRODFACT;A[6] = PRODLBS
  End If 
  If POMISC
    If L1[5] = -1 Let POMISC = POMISC * 100
    A[5] = LBSFACTOR;A[6] = LBSUNIT
    CNVTU[0] = L1[5];CNVTU[1] = 0;CNVTU[2] = 2
    Gosub L_20000
    POMISC = AMOUNT
    A[5] = PRODFACT;A[6] = PRODLBS
  End If 
End If 
BPOMISC = POMISC
BPOFREIGHT = POFREIGHT
If P60$[19,19] = "Y" ! add freight for average cost
  POCOST = POCOST + POFREIGHT
  BPOCOST = BPOCOST + BPOFREIGHT
End If 
If P60$[49,49] = "F" Or P60$[49,49] = "B"
  POCOST1 = POCOST1 + POFREIGHT
  BPOCOST1 = BPOCOST1 + BPOFREIGHT
End If 
If P60$[49,49] = "M" Or P60$[49,49] = "B"
  POCOST1 = POCOST1 + POMISC
  BPOCOST1 = BPOCOST1 + BPOMISC
End If 
If PCT5[8]
  OLDAVG = PCT5[8]
Else 
  OLDAVG = PCT2[1]
  If PCT5[3]
    OLDAVG = (PCT2[1] * PCT2[0]) / (PCT2[0] + PCT5[3])
  End If 
  If P60$[48,48] = "N" ! average cost to use net po cost
    If P60$[49,49] = "F" Or P60$[49,49] = "B"
      OLDAVG = OLDAVG + BPOFREIGHT
    End If 
    If P60$[49,49] = "M" Or P60$[49,49] = "B"
      OLDAVG = OLDAVG + BPOMISC
    End If 
  Else 
    If P60$[19,19] = "Y" !if average cost includes freight
      OLDAVG = OLDAVG + BPOFREIGHT
    End If 
  End If 
End If 
If PCT5[9]
  OLDNET = PCT5[9]
Else 
  OLDNET = PCT2[1]
  If PCT5[3] ! free goods
    OLDNET = (PCT2[1] * PCT2[0]) / (PCT2[0] + PCT5[3])
  End If 
  If P60$[49,49] = "F" Or P60$[49,49] = "B"
    OLDNET = OLDNET + BPOFREIGHT
  End If 
  If P60$[49,49] = "M" Or P60$[49,49] = "B"
    OLDNET = OLDNET + BPOMISC
  End If 
End If 
If P61$[60,60] = "Y" And PCT7[0] <> 0 Goto UPSPECCOST
Write #CH_POC,REC_POC,150;BPOCOST; \ Read #CH_POC,REC_POC,150;BPOCOST;
Write #CH_POC,REC_POC,156;BPOCOST1; \ Read #CH_POC,REC_POC,156;BPOCOST1;
NEWNET = BPOCOST1
NEWAVG = BPOCOST
If P60$[48,48] = "N" Let NEWAVG = POCOST1
Rem convert cost to purchase unit of measure
If PFU1[0] <> L1[4] ! base um = purch qty um  =
  CNVTA = OLDAVG;CNVTU = 0;CNVTU[1] = L1[4];CNVTU[2] = 2 \ Gosub L_20000
  UOLDAVG = AMOUNT
  CNVTA = NEWAVG;CNVTU = 0;CNVTU[1] = L1[4];CNVTU[2] = 2 \ Gosub L_20000
  UNEWAVG = AMOUNT
Else 
  UOLDAVG = OLDAVG
  UNEWAVG = NEWAVG
End If 
If UNEWAVG <> UOLDAVG ! average always stays in base uom by qty uom
  PRODKEY$ = " ",PRODKEY$
  PRODKEY$[1,12] = PCT$[1,12]
  Search #CH_PROD,2,1;PRODKEY$,REC_PROD,E \ If E > 1 Gosub ERR_SEARCH
  If Not(E)
    Mat Read #CH_PROD,REC_PROD,156;B;
    Mat Read #CH_PROD,REC_PROD,256;A
	oldavgcost=b[21]
    CURVAL = A[0] * B[21]
    If A[0] > 0 And (CURVAL + (PCT2[0] * NEWAVG) - (PCT2[0] * OLDAVG)) > 0
      B[21] = (CURVAL + (PCT2[0] * NEWAVG) - (PCT2[0] * OLDAVG)) / A[0]
    End If 
    Mat Write #CH_PROD,REC_PROD,156;B;
	if sqlChan >= 0 ! MySQL enabled and channel opened
		e = prod_UpdateSQLFromDL4(e$, intCo, PRODKEY$, sqlChan, CH_PROD)
		if e <> 1 ! returns the number of records add/updated/deleted
			gosub ERR_SEARCH
		end if
	end if
	if oldavgcost<>b[21]                       
			pch.ctype=6                                
			pch.OldCost=OLDAVGCOST                       
			pch.NewCost=B[21]                            
			pch.Whse=0
			GOSUB update_cost_hist: ! cost hist log    
	ENDIF     
  End If 
  PRWHKEY$ = " ",PRWHKEY$
  PRWHKEY$[1,12] = PCT$[1,12]
  PRWHKEY$[13,14] = PCT3[1] Using "##"
  Search #CH_PRWH,2,1;PRWHKEY$,REC_PRWH,E \ If E > 1 Gosub ERR_SEARCH
  If Not(E)
    Mat Read #CH_PRWH,REC_PRWH,78;W3
	OLDWHAVGCOST=W3[15]
    CURVAL = ((W3[0]) * W3[15])
    If (W3[0]) > 0 And (CURVAL + (PCT2[0] * NEWAVG) - (PCT2[0] * OLDAVG)) > 0
      W3[15] = (CURVAL + (PCT2[0] * NEWAVG) - (PCT2[0] * OLDAVG)) / (W3[0])
    End If 
    Mat Write #CH_PRWH,REC_PRWH,78;W3;
	IF P9$[32,32]="Y"   
			if oldwhavgcost<> w3[15]                 
				pch.ctype=6                              
				pch.OldCost=OLDwhavgCOST                   
				pch.NewCost= W3[15]                        
				pch.Whse=pct3[1]
				GOSUB update_cost_hist: ! cost hist log  
			endif
	endif
  End If 
End If 
If P60$[21,21] <> "N" And L1[5] <> -2 And PCT3[0] <> 0 ! line closed
  KEYAPPOLH$ = " ",KEYAPPOLH$
  KEYAPPOLH$[1,6] = O2 Using "######"
  KEYAPPOLH$[7,18] = O1$[1,12]
  KEYAPPOLH$[19,20] = O1 Using "##"
  KEYAPPOLH$[21,26] = PCT1[0] Using "######"
  KEYAPPOLH$[27,29] = L1[2] Using "###"
  KEYAPPOLH$[30,35] = PCT1[3] Using "######"
  Search #CH_APPOLH,2,1;KEYAPPOLH$,REC_APPOLH,E \ If E > 1 Gosub ERR_SEARCH
  If Not(E)
    Mat Read #CH_APPOLH,REC_APPOLH,24;APL1;
    Mat Read #CH_APPOLH,REC_APPOLH,36;APL2;
    Mat Read #CH_APPOLH,REC_APPOLH,78;APL3;
    If APL2[1] <> 0 And APL2[1] <> PCT2[1] And LASTAPCOST <> 0
      LASTAPCOST = APL2[1]
      If PFU1[11] = -1 Or PFU1[11] = -3
        If Not(PCT0) ! not a catchweight item
          CNVTA = LASTAPCOST;CNVTU[0] = 0;CNVTU[1] = PFU1[11];CNVTU[2] = 2
          If LBSUNIT <> 0 Let A[6] = LBSUNIT;A[5] = LBSFACTOR
          Gosub L_20000
        Else 
          AMOUNT = LASTAPCOST
        End If 
        CNVTA = AMOUNT;CNVTU[0] = PFU1[11];CNVTU[1] = 0;CNVTU[2] = 2
        A[6] = PRODLBS;A[5] = PRODFACT
        Gosub L_20000
        LASTAPCOST = AMOUNT
      End If 
    End If 
    If APL2[1] <> 0 And LASTAPCOST <> 0 And APL2[1] <> PCT2[1]
      PRODKEY$ = " ",PRODKEY$
      PRODKEY$[1,12] = PCT$[1,12]
      Search #CH_PROD,2,1;PRODKEY$,REC_PROD,E \ If E > 1 Gosub ERR_SEARCH
      If Not(E)
        Mat Read #CH_PROD,REC_PROD,156;B
		oldlastcost=b[10]
        PRWHKEY$ = " ",PRWHKEY$
        PRWHKEY$[1,12] = PCT$[1,12]
        PRWHKEY$[13,14] = PCT3[1] Using "##"
        W2[3] = 0
        Search #CH_PRWH,2,1;PRWHKEY$,REC_PRWH,E \ If E > 1 Gosub ERR_SEARCH
        If Not(E)
          Mat Read #CH_PRWH,REC_PRWH,38;W2;
          Mat Read #CH_PRWH,REC_PRWH,78;W3
		  oldwhlastcost=w3[16]
          VEND = B[24] \ If W2[3] Let VEND = W2[3]
          If PCT1[2] = VEND
            W3[16] = LASTAPCOST
          End If 
          Mat Write #CH_PRWH,REC_PRWH,78;W3;
		  IF P9$[32,32]="Y"   
					if oldwhlastcost<> W3[16]                     
						pch.ctype=3                                   
						pch.OldCost=OLDwhLASTCOST                       
						pch.NewCost= W3[16]                             
						pch.Whse=pct3[1]
						GOSUB update_cost_hist: ! cost hist log       
					ENDIF                                         
			ENDIF
        End If 
        VEND = B[24]
        If PCT1[2] = VEND
          B[10] = LASTAPCOST
        End If 
        Mat Write #CH_PROD,REC_PROD,156;B;
	if sqlChan >= 0 ! MySQL enabled and channel opened
		e = prod_UpdateSQLFromDL4(e$, intCo, PRODKEY$, sqlChan, CH_PROD)
		if e <> 1 ! returns the number of records add/updated/deleted
			gosub ERR_SEARCH
		end if
	end if
		if oldlastcost<>b[10]                      
					pch.ctype=3                                
					pch.OldCost=OLDLASTCOST                      
					pch.NewCost=B[10] 
					pch.Whse=0
					GOSUB update_cost_hist: ! cost hist log    
		ENDIF  
      End If 
    End If 
  End If 
End If 
If PFU1[0] <> L1[4]
  CNVTA = OLDNET;CNVTU = 0;CNVTU[1] = L1[4];CNVTU[2] = 2 \ Gosub L_20000
  UOLDNET = AMOUNT
  CNVTA = NEWNET;CNVTU = 0;CNVTU[1] = L1[4];CNVTU[2] = 2 \ Gosub L_20000
  UNEWNET = AMOUNT
Else 
  UOLDNET = OLDNET
  UNEWNET = NEWNET
End If 
If UNEWNET <> UOLDNET ! net po cost change
  If P60$[43,43] <> "N" And L1[5] <> -2
    PRODKEY$ = " ",PRODKEY$;PRFLG$ = " ",PRFLG$
    PRODKEY$[1,12] = PCT$[1,12]
    Search #CH_PROD,2,1;PRODKEY$,REC_PROD,E \ If E > 1 Gosub ERR_SEARCH
    If Not(E)
      Mat Read #CH_PROD,REC_PROD,596;PRPARC
	  OLDNETCOST=PRPARC[2]
      NETCOST = NEWNET
      If PFU1[11] = -1 Or PFU1[11] = -3
        CNVTA = NEWNET;CNVTU[0] = 0;CNVTU[1] = PFU1[11];CNVTU[2] = 2
        If LBSUNIT <> 0 Let A[6] = LBSUNIT;A[5] = LBSFACTOR
        Gosub L_20000
        CNVTA = AMOUNT;CNVTU[0] = PFU1[11];CNVTU[1] = 0;CNVTU[2] = 2
        A[6] = PRODLBS;A[5] = PRODFACT
        Gosub L_20000
        NETCOST = AMOUNT
      End If 
      PRPARC[2] = NETCOST
PNPDONE: Rem "done write/unlock
      Mat Write #CH_PROD,REC_PROD,596;PRPARC;
	if sqlChan >= 0 ! MySQL enabled and channel opened
		e = prod_UpdateSQLFromDL4(e$, intCo, PRODKEY$, sqlChan, CH_PROD)
		if e <> 1 ! returns the number of records add/updated/deleted
			gosub ERR_SEARCH
		end if
	end if
	  if oldNETcost<> prparc[2]
				pch.ctype=4                                 
				pch.OldCost=OLDNETCOST                        
				pch.NewCost= prparc[2]     
				pch.Whse=0
				GOSUB update_cost_hist: ! cost hist log     
       ENDIF   
    End If 
    PRWHKEY$ = " ",PRWHKEY$
    PRWHKEY$[1,12] = PCT$[1,12]
    PRWHKEY$[13,14] = PCT3[1] Using "##"
    Search #CH_PRWH,2,1;PRWHKEY$,REC_PRWH,E \ If E > 1 Gosub ERR_SEARCH
    If Not(E)
      Mat Read #CH_PRWH,REC_PRWH,800;WHMISC
	  OLDWHNETCOST=WHMISC[2]
      NETCOST = NEWNET
      If PFU1[11] = -1 Or PFU1[11] = -3
        CNVTA = NEWNET;CNVTU[0] = 0;CNVTU[1] = PFU1[11];CNVTU[2] = 2
        If LBSUNIT <> 0 Let A[6] = LBSUNIT;A[5] = LBSFACTOR
        Gosub L_20000
        CNVTA = AMOUNT;CNVTU[0] = PFU1[11];CNVTU[1] = 0;CNVTU[2] = 2
        A[6] = PRODLBS;A[5] = PRODFACT
        Gosub L_20000
        NETCOST = AMOUNT
      End If 
      WHMISC[2] = NETCOST
WHNPDONE: Rem "done write/unlock
      Mat Write #CH_PRWH,REC_PRWH,800;WHMISC;
	  IF P9$[32,32]="Y"
			  if oldwhNETcost<>  WHMISC[2]                   
				pch.ctype=4                                  
				pch.OldCost=OLDwhNETCOST                         
				pch.NewCost=  WHMISC[2]                       
				pch.Whse=pct3[1]
				GOSUB update_cost_hist: ! cost hist log      
			  ENDIF                                        
		ENDIF
    End If 
  End If 
End If 
If P60$[9,9] = "F" ! check for fifo
  If UNEWNET <> UOLDNET
    NETCOST = NEWNET
    If P1$[127,127] = "Y" And P61$[73,73] = "Y"
      If LBSUNIT <> 0 Let A[6] = LBSUNIT;A[5] = LBSFACTOR
      NETCOST = (NEWNET / LBSUNIT) * LBSFACTOR
      A[6] = PRODLBS;A[5] = PRODFACT
    End If 
    FLK$ = " ",FLK$
    FLK$[1,12] = PCT$[1,12];FLK$[13,14] = PCT3[1] Using "##"
    X2 = PCT1[4] \ Gosub YMD2JUL
    Goto ENDSRCHFIFOLOT
    RSTDATE = X2
    FLK$[15,20] = RSTDATE Using "######"
SRCHFIFOLOT: Rem search fifo lot for tier
    Search #CH_FIFOL,3,1;FLK$,REC_FIFOL,E \ If E = 2 Goto ENDSRCHFIFOLOT
    If E Gosub ERR_SEARCH
    If FLK$[1,12] <> PCT$[1,12] Goto ENDSRCHFIFOLOT
    WH = FLK$[13,14] \ If WH <> PCT3[1] Goto ENDSRCHFIFOLOT
    X2 = FLK$[15,20] \ If X2 <> RSTDATE Goto ENDSRCHFIFOLOT
    Gosub READ_FIFOLOT
    If FL1[1] <> 1 Goto SRCHFIFOLOT
    PO = FL1$[44,49] \ If PO <> PCT1[0] Goto SRCHFIFOLOT
    Rem if pct2[0]<>fl3[0] goto srchfifolot:! check qty
    If FL1$[74,74] = "c" ! check contrl # for multiple receipts of a line
      POCNTRL = FL1$[75,80]
      If POCNTRL And PCT1[3] <> POCNTRL Goto SRCHFIFOLOT
    End If 
    If FL3[6] = NETCOST Goto SRCHFIFOLOT
    OFCST = FL3[6]
    TOTFOCOST = FNR((FL3[0] - FL3[1]) * FL3[6])
    TOTFNCOST = FNR((FL3[0] - FL3[1]) * NETCOST)
    PCT9 = PCT9 + (TOTFNCOST - TOTFOCOST)
    FL3[6] = NETCOST
    FL3[7] = FL3[6] + ((FL3[6] * FIFL) / 100)
    FT1$ = " ",FT1$
    For S9 = 0 To 3 \ FT1[S9] = 0 \ FT2[S9] = 0 \ FT3[S9] = 0 \ Next S9
    FT1$[1,12] = FL1$[1,12] \ FT1$[13,24] = FL1$[13,24]
    FT1$[25,34] = FL1$[25,34] \ FT1$[35,40] = FL1$[35,40]
    FT1$[41,50] = O2 Using "AP V######"
    FT1$[53,59] = "CST ADJ"
    FT1$[60,71] = O1$[1,12]
    FT1[0] = 6
    FT1[1] = FL1[0]
    FT1[2] = Spc(6) \ FT2[0] = FL2[0]
    FT2[2] = CURPDATE \ FT2[3] = POSTPER \ FT3[0] = 0
    FT3[1] = FL3[6] \ FT3[2] = FL3[7]
    FLT$ = " ",FLT$
    E = 2 \ Search #CH_FIFOT,1,0;FLT$,REC_FIFOT,E \ If E Gosub ERR_SEARCH
    If REC_FIFOT <= 999999 Let FT2[1] = REC_FIFOT
    Gosub WRITE_FIFOTRANS
    FLT$[1,6] = FT2[0] Using "######" \ FLT$[7,12] = FT2[2] Using "######"
    If REC_FIFOT <= 999999
      FLT$[13,18] = FT2[1] Using "######"
    Else 
      FTRECA = Int((REC_FIFOT - 1000000) / 100000)
      FTRECB = Fra(REC_FIFOT / 100000) * 100000
      Call String(4,FTRECA + 193,LETTER$)
      FLT$[13,13] = LETTER$[1,1]
      FLT$[14,18] = FTRECB Using "#####"
    End If 
    Search #CH_FIFOT,4,1;FLT$,REC_FIFOT,E \ If E Gosub ERR_SEARCH
    Gosub WRITE_FIFOLOT
    SPCFLAG = 0
    If P61$[60,60] = "Y" And FL3[14] <> 0 Let SPCFLAG = 99
    If SPCFLAG = 0
      If P9$[17,17] = "Y" And POGLFLAG <> 0 And C0[4] <> 0 And SPO <> 0
        FIFOSPECCH[0] = CH_FIFOL
        FIFOSPECCH[1] = CH_FIFOT
        Call "MXFIFOVAR.dl4",FIFOSPECCH[],REC_FIFOL,REC_FIFOT,OFCST,FL3[6],FT1$,FT1[],FT2[],SPCFLAG,e$,IntCo,rstr$
	                                           
      End If 
    End If 
    If P61$[81,81] = "Y" ! average fifo cost
      FIFOSPECCH[0] = CH_FIFOL
      FIFOSPECCH[1] = CH_FIFOT
      FIFOSPECCH[2] = 0
      FIFOSPECCH[3] = 0
      FIFOSPECCH[4] = CH_PROD
      FIFOSPECCH[5] = CH_PRWH
      FIFOSPEC$[1,12] = PCT$[1,12]
      Call "mxfifoavg.dl4",FIFOSPECCH[],FIFOSPEC$,e$,IntCo,rstr$
    End If 
    Goto SRCHFIFOLOT
ENDSRCHFIFOLOT: Rem end of the search for fifo
  End If 
End If 
PCT5[8] = NEWAVG
PCT5[9] = NEWNET
Mat Write #CH_POC,REC_POC,90;PCT5
Mat Write #CH_POC,REC_POC,180;PCT9;
If UNEWNET <> UOLDNET and rec_prod>0! 
	let keyrol$=" ",keyrol$
	let keyrol$[1,6]=rec_prod using "######"
	srchrol: ! 
	search #ch_rol,3,2;keyrol$,rec_rol,e
	if e<>0 goto endsrchrol:
	let tmp3=keyrol$[1,6]\if tmp3<>rec_prod goto endsrchrol:
	mat read #ch_rol,rec_rol,8;ol3;
	if ol3[0]<>0 goto srchrol: ! nonstock 
	if ol3[1]<>1 goto srchrol: ! stock update flag=N
	mat read #ch_rol,rec_rol,494;lco;
	if lco=11 goto srchrol: !11 - special salesman cost
	if lco=10 goto srchrol: ! !10 - rebate salesman cost 
	mat read #ch_rol,rec_rol,0;ol2;
	FOR ctr=1 to 6                                      
		let keyroh$[1,2]=ctr using "##"
		let keyroh$[3]=ol2[1] using "######" 
		search #ch_roh,2,1;keyroh$,rec_roh,e
		if not(e) goto foundso: 
    next ctr
	goto srchrol: ! no sales order between status 1 and 4
    foundso: ! found the sales order
	mat read #ch_roh,rec_roh,104;OH5;
	let ot2[14]=0
	let keysot$=oh5[7] using "##"
	search #ch_sot,2,1;keysot$,rec_sot,e
	if not(e)
		mat read #ch_sot,rec_sot,32;ot2;
	endif
	if not(ot2[14]) goto srchrol:
	gosub read_rol:
	if rec_prod<>ol4[0] goto srchrol: ! wrong product
	!if not(ol7[4]) goto srchrol: ! no quantity shipped bypass
	if ol4[0]<=0 goto endloadcstupd: !  no product code
	gosub read_roh: ! read header record
	! read the product file
	REC_PROD = OL4[0]
	gosub read_prod:  
	Mat Read #CH_PROD,REC_PROD,620;LM;
	let ld1=0 ! that is the new load cost
	ORGLOADCOST=0
	NEWLOADCOST=0
	If P9$[32,32] = "Y" ! warehouse pricing
		let whlm[0]=0;w3[17]=0
		PRWHKEY$ = " ",PRWHKEY$
		PRWHKEY$[1,12] =oL1$[1,12]
		PRWHKEY$[13,14] = oH4[2] Using "##"
		Search #CH_PRWH,2,1;PRWHKEY$,REC_PRWH,E \ If E goto outend:
		If Not(E)
			Mat Read #CH_PRWH,REC_PRWH,78;W3;
			Mat Read #CH_PRWH,REC_PRWH,842;WHLM;
		ELSE
			GOTO ENDWHLOAD: ! no warehouse record
		endif
		if whlm[0]=0 
          	LD1 = W3[17]
			!goto endwhload:
			if LD1<=0 goto endwhload:
			GOTO ENDLOADCOST:
		endif
		WH = OH4[2];LTBL = WHLM[0]
        Gosub CALC_LOAD
        LD1 = CNVTA
		if ld1>0 goto endloadcost: 
    End If 
	endwhload: ! end warehouse load costing
	! check the product load table
	If LM[0]
        WH = 0;LTBL = LM[0]
        Gosub CALC_LOAD
        LD1 = CNVTA 
    Else 
       	LD1 = B[8]
    End If ! find load table
	endloadcost: ! end finding load cost
	if ld1>0 and ld1<>ol5[1]
		
		LET ORGLOADCOST=OL5[1]
		LET NEWLOADCOST=LD1
		clear cfin[]
		KEYCUST$ = " ",KEYCUST$;KEYCUST$ = Oh0[4] Using "######"                   
		Search #ch_cust,2,1;Keycust$,rec_cust,e 
		if not(e)                                     
			Mat Read #CH_cust,rec_cust,544;CFIN;
		endif
		Mat Read #ch_ROL,rec_rol,32;OL5
		Mat read #ch_rol,Rec_rol,260;OS3
		let ol5[1]=ld1
		If Not(UNF[5]) Let UNF[5] = 1
		NETCOST = OL5[1] + CHBASE
		OS3[13] = FNR(OL7[2] * NETCOST)
		If H5[7] = 4 Or H5[7] = 15 ! "bill and hold
			OS3[12] = FNR(OS3[7] * NETCOST)
		Else 
			OS3[12] = FNR(OL7[4] * NETCOST)
		End If 
		If UN[2] = -2 Let OS3[12] = FNR(NETCOST * Sgn(OL7[4]));OS3[13] = FNR(NETCOST * Sgn(OL7[2]))
		Mat Write #ch_rol,rec_rol,32;OL5;
		Mat Write #ch_rol,rec_rol,260;OS3;
		gosub RETOT_ORD:
		if p60$[44,44]="Y" gosub create_edittrack:
	endif
	endloadcstupd: ! 
	goto srchrol: !
	
	endsrchrol: ! that's all

ENDIF

UPSPECCOST: Rem update special cost section
If P61$[60,60] <> "Y" Goto OUTEND
If Not(PCT7[0]) Goto OUTEND
If P60$[9,9] <> "F" Goto OUTEND
KEYAPPOLH$ = " ",KEYAPPOLH$
KEYAPPOLH$[1,6] = O2 Using "######"
KEYAPPOLH$[7,18] = O1$[1,12]
KEYAPPOLH$[19,20] = O1 Using "##"
KEYAPPOLH$[21,26] = PCT1[0] Using "######"
KEYAPPOLH$[27,29] = L1[2] Using "###"
KEYAPPOLH$[30,35] = PCT1[3] Using "######"
Search #CH_APPOLH,2,1;KEYAPPOLH$,REC_APPOLH,E \ If E > 1 Gosub ERR_SEARCH
If E Goto OUTEND
Mat Read #CH_APPOLH,REC_APPOLH,36;APL2;
Mat Read #CH_APPOLH,REC_APPOLH,24;APL1;
Mat Read #CH_APPOLH,REC_APPOLH,78;APL3;
If PCT2[1] <> SPCURRCOST And APL1[4] <> 0 ! cost different line closed
  FLK$ = " ",FLK$
  FLK$[1,12] = PCT$[1,12];FLK$[13,14] = PCT3[1] Using "##"
  X2 = PCT1[4] \ Gosub YMD2JUL
  Goto ENDSRCHSPCLOT
  RSTDATE = X2
  FLK$[15,20] = RSTDATE Using "######"
SRCHSPCLOT: Rem search fifo lot for tier
  Search #CH_FIFOL,3,1;FLK$,REC_FIFOL,E \ If E = 2 Goto ENDSRCHSPCLOT
  If E Gosub ERR_SEARCH
  If FLK$[1,12] <> PCT$[1,12] Goto ENDSRCHSPCLOT
  WH = FLK$[13,14] \ If WH <> PCT3[1] Goto ENDSRCHSPCLOT
  X2 = FLK$[15,20] \ If X2 <> RSTDATE Goto ENDSRCHSPCLOT
  Gosub READ_FIFOLOT
  If FL1[1] <> 1 Goto SRCHSPCLOT
  PO = FL1$[44,49] \ If PO <> PCT1[0] Goto SRCHSPCLOT
  Rem if pct2[0]<>fl3[0] goto srchspclot:! check qty
  If FL1$[74,74] = "c" ! check contrl # for multiple receipts of a line
    POCNTRL = FL1$[75,80]
    If POCNTRL And PCT1[3] <> POCNTRL Goto SRCHSPCLOT
  End If 
  If FL3[14] = SPCURRCOST Goto SRCHSPCLOT
  OFCST = FL3[14]
  OLDEXTCOST = FNR(FL3[0] * FL3[14])
  NEWEXTCOST = FNR(FL3[0] * SPCURRCOST)
  If OLDEXTCOST = NEWEXTCOST Goto SRCHSPCLOT
  Mat Read #CH_POC,REC_POC,180;PCT9
  TOTFOCOST = FNR((FL3[0] - FL3[1]) * FL3[14])
  TOTFNCOST = FNR((FL3[0] - FL3[1]) * SPCURRCOST)
  PCT9 = PCT9 + (TOTFNCOST - TOTFOCOST)
  Mat Write #CH_POC,REC_POC,180;PCT9;
  FL3[14] = SPCURRCOST
  FT1$ = " ",FT1$
  For S9 = 0 To 3 \ FT1[S9] = 0 \ FT2[S9] = 0 \ FT3[S9] = 0 \ Next S9
  FT1$[1,12] = FL1$[1,12] \ FT1$[13,24] = FL1$[13,24]
  FT1$[25,34] = FL1$[25,34] \ FT1$[35,40] = FL1$[35,40]
  FT1$[41,50] = O2 Using "AP V######"
  FT1$[53,59] = "FSP ADJ"
  FT1$[60,71] = O1$[1,12]
  FT1[0] = 66
  FT1[1] = FL1[0]
  FT1[2] = rec_uac \ FT2[0] = FL2[0]
  FT2[2] = CURJDATE \ FT2[3] = POSTPER \ FT3[0] = 0
  FT3[1] = FL3[6] \ FT3[2] = FL3[7] \ FT3[3] = FL3[14]
  FLT$ = " ",FLT$
  E = 2 \ Search #CH_FIFOT,1,0;FLT$,REC_FIFOT,E \ If E Gosub ERR_SEARCH
  If REC_FIFOT <= 999999 Let FT2[1] = REC_FIFOT
  Gosub WRITE_FIFOTRANS
  FLT$[1,6] = FT2[0] Using "######" \ FLT$[7,12] = FT2[2] Using "######"
  If REC_FIFOT <= 999999
    FLT$[13,18] = FT2[1] Using "######"
  Else 
    FTRECA = Int((REC_FIFOT - 1000000) / 100000)
    FTRECB = Fra(REC_FIFOT / 100000) * 100000
    Call String(4,FTRECA + 193,LETTER$)
    FLT$[13,13] = LETTER$[1,1]
    FLT$[14,18] = FTRECB Using "#####"
  End If 
  Search #CH_FIFOT,4,1;FLT$,REC_FIFOT,E \ If E Gosub ERR_SEARCH
  Gosub WRITE_FIFOLOT
  SPCFLAG = 99
  If P9$[17,17] = "Y" And POGLFLAG <> 0 And C0[4] <> 0 And SPO <> 0
    FIFOSPECCH[0] = CH_FIFOL
    FIFOSPECCH[1] = CH_FIFOT
    If Not(OFCST) Let OFCST = FL3[6]
    Call "MXFIFOVAR.dl4",FIFOSPECCH[],REC_FIFOL,REC_FIFOT,OFCST,FL3[14],FT1$,FT1[],FT2[],SPCFLAG,e$,IntCo,rstr$
  End If 
  Goto SRCHSPCLOT
ENDSRCHSPCLOT: Rem end of the search for fifo
End If 
Goto OUTEND
READ_POC: Rem read pocontrol line
Mat Read #CH_POC,REC_POC,0;PCT1;
Mat Read #CH_POC,REC_POC,24;PCT2;
Mat Read #CH_POC,REC_POC,60;PCT3;
Mat Read #CH_POC,REC_POC,66;PCT$;
Mat Read #CH_POC,REC_POC,78;PCT4;
Mat Read #CH_POC,REC_POC,90;PCT5;
Mat Read #CH_POC,REC_POC,162;PCT6;
Mat Read #CH_POC,REC_POC,174;PCT7;
Mat Read #CH_POC,REC_POC,180;PCT9
Mat Read #CH_POC,REC_POC,288;PCT0
Return 
READ_FIFOLOT: Rem read fifolot file
Rem {begin src/inc/read.fifolot.i}
Mat Read #CH_FIFOL,REC_FIFOL,0;FL1
Mat Read #CH_FIFOL,REC_FIFOL,6;FL1$
Mat Read #CH_FIFOL,REC_FIFOL,86;FL2
Mat Read #CH_FIFOL,REC_FIFOL,102;FL3
Rem {end read.fifolot.i}
Return 
WRITE_FIFOLOT: Rem write fifolot file
Rem {begin src/inc/write.fifolot.i}
Mat Write #CH_FIFOL,REC_FIFOL,0;FL1
Mat Write #CH_FIFOL,REC_FIFOL,6;FL1$
Mat Write #CH_FIFOL,REC_FIFOL,86;FL2
Mat Write #CH_FIFOL,REC_FIFOL,102;FL3;
Rem {end write.fifolot.i}
Return 
WRITE_FIFOTRANS: Rem write fifotrans file
Rem {begin src/inc/write.fifotrans.i}
Mat Write #CH_FIFOT,REC_FIFOT,0;FT1$;
Mat Write #CH_FIFOT,REC_FIFOT,72;FT1;
Mat Write #CH_FIFOT,REC_FIFOT,80;FT2;
Mat Write #CH_FIFOT,REC_FIFOT,96;FT3;
Rem {end write.fifotrans.i}
Return 

read_prod: ! read product file
Mat Read #CH_PROD,REC_PROD,0;P1$;
Mat Read #CH_PROD,REC_PROD,156;B;
Mat Read #CH_PROD,REC_PROD,256;A
Mat Read #CH_PROD,REC_PROD,512;PFU1;
Mat Read #CH_PROD,REC_PROD,554;PFU2;
!PRODLBS = A[6];PRODFACT = A[5]
Mat Read #ch_prod,rec_prod,596;prparc
return

read_rol: ! read lines files
! read order line item             
Mat read #CH_ROL,Rec_ROL,  0;OL2   
Mat read #CH_ROL,Rec_ROL,  8;OL3   
Mat read #CH_ROL,Rec_ROL, 16;OL4   
Mat read #CH_ROL,Rec_ROL, 32;OL5   
Mat read #CH_ROL,Rec_ROL, 56;OL6   
Mat read #CH_ROL,Rec_ROL, 80;OL6$  
Mat read #CH_ROL,Rec_ROL,140;OL1$  
Mat read #CH_ROL,Rec_ROL,160;OL9   
Mat read #CH_ROL,Rec_ROL,168;OL7   
Mat read #CH_ROL,Rec_ROL,246;PL    
Mat read #CH_ROL,Rec_ROL,250;UN    
Mat read #CH_ROL,Rec_ROL,256;S2    
Mat read #CH_ROL,Rec_ROL,260;OS3    
Mat read #CH_ROL,Rec_ROL,368;MT$   
Mat read #CH_ROL,Rec_ROL,370;S3$   
Mat read #CH_ROL,Rec_ROL,404;OLM   
Mat read #CH_ROL,Rec_ROL,446;EUN   
Mat read #CH_ROL,Rec_ROL,452;UNF   
Mat read #CH_ROL,Rec_ROL,494;LCO  
Mat read #CH_ROL,Rec_ROL,502;CST   
mat read #CH_ROL,rec_rol,508;OLtax1
mat read #CH_ROL,rec_rol,514;ctwt
mat read #CH_ROL,rec_rol,518;invNo 
mat read #ch_rol,rec_rol,538;OLtax2
mat read #ch_rol,rec_rol,542;qpb   
read #ch_rol,rec_rol,548;OLPrinted 
read #CH_ROL,Rec_Rol,550;OWhs      
read #ch_rol,rec_rol,552;OLP_Date  
read #CH_ROL,Rec_Rol,556;OLP_Time  
read #CH_ROL,Rec_Rol,564;rol0;     
return

write_rol: ! write order line
! write order line item              
Mat write #CH_ROL,Rec_ROL,  0;OL2    
Mat write #CH_ROL,Rec_ROL,  8;OL3    
Mat write #CH_ROL,Rec_ROL, 16;OL4    
Mat write #CH_ROL,Rec_ROL, 32;OL5    
Mat write #CH_ROL,Rec_ROL, 56;OL6    
Mat write #CH_ROL,Rec_ROL, 80;OL6$   
Mat write #CH_ROL,Rec_ROL,140;OL1$   
Mat write #CH_ROL,Rec_ROL,160;OL9    
Mat write #CH_ROL,Rec_ROL,168;OL7    
Mat write #CH_ROL,Rec_ROL,246;PL     
Mat write #CH_ROL,Rec_ROL,250;UN     
Mat write #CH_ROL,Rec_ROL,256;S2     
Mat write #CH_ROL,Rec_ROL,260;OS3     
Mat write #CH_ROL,Rec_ROL,368;MT$    
Mat write #CH_ROL,Rec_ROL,370;S3$    
Mat write #CH_ROL,Rec_ROL,404;OLM    
Mat write #CH_ROL,Rec_ROL,446;EUN    
Mat write #CH_ROL,Rec_ROL,452;UNF    
Mat write #CH_ROL,Rec_ROL,494;LCO    
Mat write #CH_ROL,Rec_ROL,502;CST    
mat write #CH_ROL,rec_rol,508;OLtax1 
mat write #CH_ROL,rec_rol,514;ctwt   
mat write #CH_ROL,rec_rol,518;invNo 
mat write #ch_rol,rec_rol,538;OLtax2
mat write #ch_rol,rec_rol,542;qpb   
write #ch_rol,rec_rol,548;OLPrinted 
write #CH_ROL,Rec_Rol,550;OWhs      
write #ch_rol,rec_rol,552;OLP_Date  
write #CH_ROL,Rec_Rol,556;OLP_Time  
write #CH_ROL,Rec_Rol,564;rol0;  
return
! -----------------------------------
read_roh: ! read order header file
! Read order header                 
Mat Read #CH_ROH,Rec_ROH,  0;oh0    
Mat Read #CH_ROH,Rec_ROH, 52;oh3    
Mat Read #CH_ROH,Rec_ROH, 56;Tot_Sell
Mat Read #CH_ROH,Rec_ROH, 64;LockPort
Mat Read #CH_ROH,Rec_ROH, 66;V0$    
Mat Read #CH_ROH,Rec_ROH, 78;oh4    
Mat Read #CH_ROH,Rec_ROH, 84;oh0$   
Mat Read #CH_ROH,Rec_ROH,104;oh5    
Mat Read #CH_ROH,Rec_ROH,172;ST3    
Mat Read #CH_ROH,Rec_ROH,272;oh1$   
Mat Read #CH_ROH,Rec_ROH,278;Slsm   
Mat Read #CH_ROH,Rec_ROH,318;Scom   
Mat Read #CH_ROH,Rec_ROH,348;Smer   
Mat Read #CH_ROH,Rec_ROH,378;Scst   
Mat Read #CH_ROH,Rec_ROH,408;oh6    
Mat Read #CH_ROH,Rec_ROH,444;ohmat$ 
Mat Read #CH_ROH,Rec_ROH,446;P0$    
Mat Read #CH_ROH,Rec_ROH,466;ohFAX  
Mat Read #CH_ROH,Rec_ROH,474;ohSTI  
Mat Read #CH_ROH,Rec_ROH,482;oh2    
Mat Read #CH_ROH,Rec_ROH,486;OWHT   
Mat Read #CH_ROH,Rec_ROH,490;OWHT1
Mat Read #CH_ROH,Rec_ROH,498;TotGL 
Mat Read #CH_ROH,Rec_ROH,504;PickBy
Mat Read #CH_ROH,Rec_ROH,512;OREF;
return
!------------------------------------------------
CALC_LOAD: Rem
PREC[0] = REC_PROD
IF NOT(PREC[0]) LET PREC[0]=OL4[0]
PREC[2] = FNR(Abs((oL6[4] * oL7[2]) / A[5]))
If oL6[4] And oL6[4] <> A[6] ! line lbs different from prod file lbs
  PREC[3] = oL6[4]
Else 
  PREC[3] = 0
End If 
CNVTA = -999 ! SET TO CALCULATE BASED UPON PROD/PRODWHSE
OTYPE = - oH5[7] 
wh=oh4[2]
Call "MXLOAD5.DL4",OTYPE,WH,LTBL,PREC[],CNVTA,Intco,E$,RSTR$
Return 

!-------------------------------------------------------
RETOT_ORD: Rem "finally off to retotal
S9[2] = Rec_roh;S9[3] = 6;S9[4] = 374
PASSINFO[0] = 1
Mat Read #ch_roh,REC_ROH,0;oH0;
REC_ROT=oh0[3]
Mat Read #ch_rot,REC_ROT,0;T1         
Mat Read #ch_rot,REC_ROT,8;T2         
Mat Read #ch_rot,REC_ROT,168;MCODE    
Mat Read #ch_rot,REC_ROT,208;MCHARGE  
Mat Read #ch_rot,REC_ROT,328;TOT      
Mat Read #ch_rot,REC_ROT,358;MCTXBL   
Mat Read #ch_rot,REC_ROT,378;DCLVL;   
PCHAN[0] = 1 ! ctlc
PCHAN[1] = 0                                              
PCHAN[2] = ch_zone ! zone
PCHAN[3] = ch_prod ! product ch_prod
PCHAN[4] = 0! commodity code
PCHAN[5] = ch_cust ! cust        
PCHAN[6] = 0 ! ch_prwh
PCHAN[7] = ch_ros !  ch_ros
PCHAN[8] = ch_roh ! order header 
PCHAN[9] = ch_rot ! ch_rot! ch_rot
PCHAN[10] =ch_rol !  ch_rol                                                                              
PCHAN[11] = 0
PCHAN[12] = 0! custtax
PCHAN[13] = 0 !slsm
PCHAN[14] = 0 !ch_tax            
PCHAN[15] = 0 ! ch_prlt
PCHAN[16] = 0 !ch_ordlot
PCHAN[17] = 0 ! ch_ccodes   

PARM[0] = 1    ! credit check inquiry - set to Y for existing order                                                             
PARM[1] = 1   ! do credit check   - set to Y  - maybe increasing sales amount                                                      
PARM[2] = 1    ! exception     - set to Y to check gp/cost exceptions                                                      
PARM[3] = 1    ! write total                                                        
PARM[4] = 1    ! update order total in customer's file                                                       
If P60$[40,40] = "S" Let PARM[4] = 1                                     
PARM[5] = 0    ! clear manual fields = N                                                          
PARM[6] = 0    ! clear cash filed =N 
PARM[9] = 99	! delivery charge
PARM[10] = 99! ar term misc cost charge   - bypass                                                                                                                  
S9[4] = 374                                                             
R5 = REC_CUST! rec_cust
!H1 = R[5] ! ORDER HEADER RECORD #
V1 = 0 ! REC_SLSM    
! SAVE ORIGINAL VALUES
let orgcost=fnr(t2[14])
let orgamt=fnr(t2[24])
IF P60$[40,40]="S" 
	let orgshipamt=fnr(T2[0]) ! Shipped amount
endif
let orgfreight=fnr(T2[5])
LET orgother=fnr(t2[6])
let tmp3=t2[21]
For ctr = 1 To 12                       
	oldholdcodeflag[ctr] = Sgn(Fra(tmp3 / 2))
	tmp3 = Int(tmp3 / 2)                  
Next ctr
Call "ORDERTOTAL",S9[],REC_ROH,PARM[],PCHAN[],T1[],T2[],MCODE[],MCHARGE[],TOT[],MCTXBL[],DCLVL,R5,V1,CFIN[]   
Mat Read #ch_ROT,REC_ROT,8;T2;
let tmp3=t2[21]
For ctr = 1 To 12                       
		holdcodeflag[ctr] = Sgn(Fra(tmp3 / 2))
		tmp3 = Int(tmp3 / 2)                  
Next ctr
if oldholdcodeflag[1]<>holdcodeflag[1] ! credit 
	If p60$[40,40]="S"
		if fnr(t2[0])<=fnr(orgshipamt)
			let holdcodeflag[1]=oldholdcodeflag[1]
		endif
	else
		if fnr(t2[24])<=fnr(orgamt)  ! amount is less than or equal
			let holdcodeflag[1]=oldholdcodeflag[1] 
		endif
	endif
endif
if oldholdcodeflag[2]<>holdcodeflag[2] ! gp exception
	if fnr(t2[24])=orgamt and t2[14]=fnr(orgcost)
		let holdcodeflag[2]=oldholdcodeflag[2]
	else
		if fnr(t2[24])=orgamt and oldholdcodeflag[2]=0 and holdcodeflag[2]<>0
			if fnr(orgamt-orgcost)<=fnr(t2[24]-t2[14]) ! original gp is less than new gp
				let holdcodeflag[2]=oldholdcodeflag[2]
			endif
		endif
	endif
endif
if fnr(orgamt)=Fnr(t2[24]) and fnr(orgcost)=fnr(t2[14])
	for ctr=3 to 12
		if oldholdcodeflag[ctr]<>holdcodeflag[ctr]
			let holdcodeflag[ctr]=oldholdcodeflag[ctr]
		endif
	next ctr
endif
tmp3 = 0                                            
For ctr = 0 To 11                                   
	If holdcodeflag[ctr + 1] Let tmp3 = tmp3 + 2 ^ ctr
Next ctr                                            
t2[21] = tmp3
Mat Write #ch_rot,REC_ROT,8;T2;
return

update_cost_hist: ! rem                              
! Get main data & call it                          
LET pch.ProdCode$=p1$[140,151]+Blank$
pch.AccessCode$=Blank$
LET tmp1$="AP 512" 
let tmp1$=tmp1$+" INV "
LET tmp1$=tmp1$+O1$[1,12]
pch.Source$=tmp1$[1,10]
pch.sOpen$=tmp1$[11]+Blank$
pch.Blankforkey$=Blank$
lET pch.CDate=0                                      
LET pch.CTime=0                                      
LET pch.CostUm=PFU1[11]                               
IF pch.CostUm>0                                       
	FOR XCST=0 TO 7                                      
		IF PFU1[XCST]=PFU1[11]                               
			IF XCST=0                                            
				LET pch.CstUmFactor=1                                      
			ELSE                                                 
				LET pch.CstUmFactor=PFU2[XCST-1]                           
			ENDIF                                                
		ENDIF                                                
	NEXT XCST                                            
ENDIF                                                
LET FChan[0]=0                                  
! CALL "mkcosthist",CSTHST$,CSTHST[],CHAN 
call MkCostHist(e$,IntCo,fchan[],pch.)
return

create_Edittrack: ! do edittracking
if p60$[44,44]<>"Y" return
IF ORGLOADCOST=NEWLOADCOST return
FOR I=0 TO 2 \ LET FCHAN[I]=-1 \ NEXT I
! fchan[0] =-1 edittrack not open
! fchan[1] =-1 usercntrl not open
etr.Status=Oh0[0] ! STATUS
etr.OrdNum=OH0[7]
etr.LineNum=OL3[2]
etr.ProdCode$=ol1$[1,12]
etr.etaction=512
!CALL $LOGIC,1,2^0,PL1[3],etnonstock                                             
etr.NstkFlag = 0 ! stock items only
etr.umsell=0
let etr.umsell=un[0]
! There is no qty change ... just for tracking
etr.OrgQtyOrd=ol7[2]
etr.OrgQtyShip=ol7[4]
etr.OrgQtyBO=ol7[3]
etr.NewQtyOrd=ol7[2]
etr.NewQtyShip=ol7[4]
etr.NewQtyBO=ol7[3]
!
etr.InvNum=oref[1]
etr.OrgOrdTot=t2[0]
etr.CustNum=oh0[4]
etr.Printer=0
let etr.OrgLoadCost=0
let etr.NewLoadCost=0
let etr.umcost=0
IF ORGLOADCOST<>0 OR NEWLOADCOST<>0
	IF ORGLOADCOST<>NEWLOADCOST
		let etr.umcost=un[2]
		let etr.OrgLoadCost=ORGLOADCOST
		let etr.NewLoadCost=NEWLOADCOST ! get load cost
	ENDIF
ENDIF
ETR.AccessCode$ = "AP PUR JRNL"+BLANK$
Call MakeEdittrack(e$,IntCo,fchan[],etr.)
Let e$=""
Return



Rem {begin src/inc/rtn.date.i}
NUM2DATE: Rem *UNPACK DATE  X2 TO X$      V1.0  4/04/84  G.DOSCHER
X$ = " ",X$ \ X$[10] = ""
X$[1,3] = Int(X2 / 10 ^ 2 - Int(X2 / 10 ^ 4) * 10 ^ 2) + 10 ^ 2 Using "###"
X$[4,6] = Fra(X2 / 10 ^ 2) * 10 ^ 2 + 10 ^ 2 Using "###"
X$[7,9] = Int(X2 / 10 ^ 4) + 10 ^ 2 Using "###"
X$[4,4] = "/" \ X$[7,7] = "/" \ X$ = X$[2]
If Not(X2) Let X$ = "        "
Return 
DATE2NUM: Rem *PACK DATE    X$ TO X2      V1.0  4/04/84  G.DOSCHER
X2 = X$[4,5] \ X1 = X$[1,2] \ X2 = X2 + X1 * 10 ^ 2
X1 = X$[7,8] \ X2 = X2 + X1 * 10 ^ 4
Return 
JUL2DATE: Rem REM DATE JULIAN X2 TO X$
DT3[0] = X2;FLAG = 1;X$ = " "
If X2 <= 0 Let X$ = " ",X$ \ Return 
Call "JULIANUTIL",DT3[],X$,FLAG
Return 
YMD2JUL: Rem  REM  CONVERT YYMMDD TO JULIAN (RETURN=NOGOOD, +1=OKAY)
If X2 <= 0 Return 
X$ = X2 Using "&&&&&&"
Call DateToJulian(1,X$,X$,E) \ If E Return 
X2 = X$[1,5]
Return 1
JUL2YMD: Rem  REM CONVERT JULIAN TO YYMMDD
DT3[0] = X2;DT3[1] = X2;FLAG = 0
If X2 <= 0 Return 
Call "JULIANUTIL",DT3[],X$,FLAG
Return 
YM2LONGYEAR: Rem Rem Convert YYMM to YYYYMM
If X2 <= 0 Return 
X$ = X2 Using "&&&&"
DT3[0] = X$[1,2];DT3[1] = X$[3,4]
If DT3[0] > 67 Let DT3[0] = 1900 + DT3[0]
If DT3[0] < 68 Let DT3[0] = 2000 + DT3[0]
X$[1,4] = DT3[0] Using "&&&&"
X$[5,6] = DT3[1] Using "&&"
X2 = X$[1,6]
Return 
Rem {end rtn.date.i}
GETCURJDATE: Rem GET JULIAN DATE
SCRATCH$ = "" \ Call Time(SCRATCH$)
SCRATCH$[13] = "" \ Call VerifyDate(SCRATCH$,X$,E) \ If E Gosub ERR_SEARCH
DATE = X$
Call DateToJulian(1,X$,X$,E) \ If E Gosub ERR_SEARCH
X2 = X$[1,5]
CURJDATE = X2
Return 

L_20000: Rem UNIT CONVERSION RETURNS AMOUNT  (rev 01/07/1992)   ! 20040 REM
If CNVTU[2] = 3 Goto L_20050
If CNVTU[2] = 1 And CNVTU[1] = CNVTU[0] Let AMOUNT = CNVTA \ Goto L_20160
If CNVTU[0] = -2 Or CNVTU[1] = -2 Let AMOUNT = CNVTA \ Goto L_20160
If CNVTU[2] = 0 Goto L_20050
If Not(CNVTA) Let AMOUNT = 0 \ Goto L_20160
L_20050: Goto L_20120 !If Spc(4) > 1280 Goto L_20120
!Swap 1,"MXPRCONV"
!If CNVTU[2] = 3 Goto L_20160
!L_20080: Signal 2,X1,AMOUNT,FLAG \ If X1 = -1 Let E = 0 \ Gosub ERR_SEARCH
!If X1 <> Spc(6) Goto L_20080
!If CNVTU[2] = 0 Goto L_20160
!If FLAG Let E = FLAG \ Gosub ERR_SEARCH
!Goto L_20160
L_20120: Rem "====== unibasic 5+ logic
Call "MXPRCONV5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
If CNVTU[2] = 0 Goto L_20160
If FLAG Let E = FLAG \ Gosub ERR_SEARCH
AMOUNT = CNVTA
L_20160: Return 

ERR_SEARCH: Rem                         
ENUM = E;ELINE = Spc(16);CTERR = 0           
If E = 5 Let CTERR = Err(8)                  
msg$ = "RETURN STATUS",(E + (CTERR * .001))  
msg$ = msg$,"/ STATEMENT",ELINE," IN PROGRAM "
e$ = msg$ \ Error 10000                      
Return ! End                                 
If Msg$<>"" let e$=msg$ !  Error 10000 ! sent reason
ENUM = E ;ELINE = Spc(16);CTERR = 0
If E = 5 Let CTERR = Err(8)
e$ = "RETURN STATUS",(E + (CTERR * .001))
e$ = e$,"/ STATEMENT",ELINE," IN PROGRAM "
call programdump("tmp/lacalccost!","")
! goto err_msg ! Error 10000
Error 10000
Return ! End

ERR_MSG: ! send message
ReturnStatus=0! need report to print still
Message$=E$
!Call addtostr(e$,rstr$,esdel$) !end section -- DXBLOCK 
!call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
!call AddToStr(e$,rstr$,WebStr$)
!call SetOutPut(e$,rstr$)
End

OUTEND: Rem EXIT
	!Try Close #CH_PROD Else Rem
	!Try Close #CH_PRWH Else Rem
	!Try Close #CH_POH Else Rem
	!Try Close #CH_APPOLH Else Rem
	!Try Close #CH_POL Else Rem
	!If P60$[9,9] = "F"
	!	Try Close #CH_FIFOL Else Rem
	!	Try Close #CH_FIFOT Else Rem
	!End If 
	!Try close #ch_roh Else Rem
	!Try close #ch_rol Else Rem
	!Try close #ch_sot Else Rem
	if sqlChan <> -1
		try close #sqlChan else rem
	end if
	! if channel is open in this program set in wchan[]
	for ctr=1 to 99
		if wchan[ctr]>0
				Try Close #wchan[ctr] Else Rem
		endif
	next ctr
Else
ERR_TRAP: Rem *Error routine (escape trap)   V3.1 8/94 G.DOSCHER/REK
!
include "src/callmainerrnet.inc"
end try
End ! the whole program
