! -- dfcreatestruct.dl4
!
! Program to create def structures for xport file definitions
!
! loadsave -w -n 100,10 -o dfcreatestruct.dl4 src/dfcreatestruct.src
!
! 1.0 03/23/2007  new 
!     05/09/2007  add NFTOC option
!     07/24/2007  add create drop list
!     11/20/2007  error handling corrections
!     03/26/2008  run from xoprt button gencode
!     03/26/2008  add code to save backup of previous lib and struct
!     04/04/2009  add change logging option
!     08/30/2011  UBS, change to add record before keys, read/unlock record before deleting, programdump on error
!
!
!include copyright, common libs, common intrinsics
! --- include "src/copyright 4/5/2007"
!
!
declare intrinsic sub dxget,dxset,dxsave,dxclose
Declare Intrinsic Function findchannel,DateUsing$,Trim$,replace$
Declare Intrinsic Sub StringSearch
!
External Lib "dfgeneral.lib"
Declare External Sub dfmainerr,dfsuberr,ReadSystemFile,Openfiles
declare external function GetProgramPath$
!
Declare Sub OpenSection,InputSection,CloseSection,ProcessIncSection,CheckForIndex
Declare sub ProcessLibSection,CreateGet,CreateUpdate,CreateUpdateKeyVaribles
Declare sub CreateUpdateAddRecord,CreateUpdateDeleteRecord,CreateUpdateChangeRecord
Declare sub CreateDropList,CreateDropHeading,CreateDropFields,CreateMain
!  
include "src/dffiles.bsh"
!
option string redim is legal
!
!
! ------------------------------------------------
!
!
! **main procedure
!
dim DH. as FileDefHdr
dim DF. as FileDefFields
dim DK. as FileDefKey
Dim config. as config
!
dim optiondir$[60],buttonlist$[5,50],nextlist$[5,100]
!
Dim PathInc$[100],PathLib$[100],FileName$[50],CurFile$[50],BatFile$[100]
dim BegKey$[20],EndKey$[20],FileKey$[48],FieldKey$[48],DirKey$[48]
dim FileRec$[36],FieldRec$[50]
Dim e$[200],I8$[1],Field$[50],RequiredVarname$[20]
dim tmp$[300],tmp1$[300],tmpold$[300],tmp1old$[300],tmptext$[100],tmpkey$[48]
dim Dir1$[300],Dir2$[300],Dir3$[300],Dir4$[300],Dir5$[300]
dim Dir6$[300],Dir7$[300],Dir8$[300],Dir9$[300]
dim OldDir1$[300],OldDir2$[300],OldDir3$[300],OldDir4$[300],OldDir5$[300]
dim OldDir6$[300],OldDir7$[300],OldDir8$[300],OldDir9$[300]
dim holddir1$[300],filename$[200]
dim SearKey$[300],tmpline$[500]
dim Blank$[100] \ Blank$=" ",Blank$
dim U$[100] \ U$="-",U$
!
Dim 1%,C[20],FileMat[3],FieldMat[2],tmpcnt,tmp1,loadsaveline$[200]
Dim 2%,tmp2
Dim 3%,tmp3
Dim 4%,tmp4
!
Try 
  !
  
  !
   !coming from xport button
  try call dxget("u_filekey",begkey$) else let xport=0 !filename
  if begkey$<>""
   endkey$=begkey$
   xport=1
  end if
  if xport=0  call InputSection() \ if errflag chain "" ! input beg/end files
  Call OpenSection() ! open files
  !
  PathInc$=config.structdir$  !"src/inc/" ! path for 'inc' files (def struct files)
  PathLib$=config.srcdir$     !"src/" ! path for code 'src' files
  !
  !
  FileKey$=BegKey$
  FileRec=-2 
  search >= #c[0],1;FileKey$
  Do
    try read record #c[0],FileRec;DH. else exit do
    if DH.FileName$[1,len(EndKey$)]>EndKey$ exit do
    !
    if lcase$(DH.Active$)="a" ! active file
     CurFile$=lcase$(rtrim$(replace$(DH.FileName$,".","")))! current file, used for file naming
     doit=1
	 if xport=0 if begkey$="" !ask if it should process
	  print curfile$;" ok to process Y/N/END ? ";
      input ""tmp$
      tmp$=Ucase$(tmp$)
	  if tmp$="END" goto done
      if tmp$<>"Y" let doit=0
      ;""
	 end if
	 if doit
	  p1 = Pos(curfile$, = "/",-1) !last slash
      If p1 Let curfile$ = curfile$[p1 + 1]
      !
      c[11]=findchannel() ! chan for 'inc' file
      c[12]=findchannel() ! chan for 'lib' src file
      !
	  Call CheckForIndex(I8$) ! checks if file is index, I8$="Y" has index
      Call ProcessIncSection(I8$) ! create .inc file
      call ProcessLibSection(I8$) ! create .lib file
	  if xport=0 print "Processing ";curfile$

      !
	!
	tmp$=config.codedir$,"libfile",curfile$,".lib ",config.codedir$,"backup/libfile",curfile$,".lib",dateusing$(tim#(0),"YYYYMMDDHHNNSS")
    try
	 duplicate tmp$ !make a backup copy
	else
     if spc(8)<>42 e$="Error trying to make backup copy of libfile program!"\error 10000
    end try
	filename$=config.codedir$,"libfile",CurFile$,".lib"
	loadsaveline$="loadsave -w -n 10,10 -o ",filename$," ",PathLib$,"libfile",CurFile$,".src"
    if xport=0 print #c[10];loadsaveline$
	!!if needed if xport=0 print #c[10];"chmod 664 ";filename$  !note, only works on unix    664=-rw-rw-r-- per ubs request (default is -rw------)
	end if !doit
	end if !a
	FileRec=-1 ! next file def record
  loop
  done:Close ! close files
  if xport
   e$='fx',"file",curfile$,".inc def struct include file successfully generated<br>libfile",curfile$,".lib code successfully generated!"
   call dxset("s_msg",e$)
   buttonlist$[0]="Close"
   nextlist$[0]="close"
   call dxset("buttonlist",buttonlist$[])
   call dxset("nextlist",nextlist$[])
   try call dxget("s_view.optiondir",optiondir$) else let optiondir$="dxstd/"
   call dxset("output",optiondir$+"msg.html")
   call dxclose()
  end if
  
  if xport
   system loadsaveline$
   filename$=filename$," <664>"
   !!if needed modify filename$ !protection on libfile*.lib
  else
   !was  tmp$="exec ",batfile$ chain tmp$  can swich back if needed,jsut doesn't work if xport
   tmp$=Batfile$," <700>" !make .bat executable
   modify tmp$
   system batfile$  !run directly can do more than one (grouping)
  end if
  end
Else 
  ! error routine
  if xport
   if spc(8)<>10000 
    call dfsuberr(e$,spc(8),spc(10),msc$(2))
    !call programdump("")
   end if
   call dfmainerr(e$,spc(8),buttonlist$[],nextlist$[])
  else
   ;"error";spc(8);" at line ";spc(10)
   stop
  end if
End Try 

!
! ------------------------------------------------
Sub OpenSection()
!
Try
  ! need to get filenames from dxsystem.txt
  !
  !read system file parameters
  Call ReadSystemFile(e$,config.)
  !
  ! open files
  !
  Call openfiles(e$,config.,c[]) ! dxport files
  ! ds
  ! build text file to execute loadsave
  if xport=0
   c[10]=findchannel()
   BatFile$="dfcreatestruct.bat"
   FileName$=BatFile$,"!"
   build #c[10],+ FileName$
  end if
  !
else
  if xport
   if spc(8)<>10000
    call dfsuberr(e$,Spc(8),Spc(10),Msc$(2))
    !call programdump("")
   end if
   error 10000
  else
   ;"error";spc(8);" at line ";spc(10)
   stop
  end if
end try
!
End Sub ! opensection
!
! ------------------------------------------------
Sub InputSection()
!
  !
  try
  BegInput:
  ;'cs';"Create 'inc' & 'lib' structures for file"
  ;""
  ;""
  ;"Enter File Name (return for all) ";
  input ""BegKey$
  BegKey$=Ucase$(BegKey$)
  !if BegKey$="" goto BegInput
  if BegKey$="END" let errflag=1 \ exit sub
  ;""
  ;""
  if BegKey$ print "File ='";BegKey$;"'" else print "All Files"
  CorrInput:
  ;""
  ;"Correct <Y/N> ";
  input ""tmp$
  tmp$=Ucase$(tmp$)
  if tmp$="END" let errflag=1 \ exit sub
  if tmp$=":" or tmp$="N" goto BegInput
  if tmp$<>"Y" goto CorrInput
  ;""
  if BegKey$ let EndKey$=BegKey$," " else let EndKey$="~"
else
  ;"error";spc(8);" at line ";spc(10)
   stop
end try
!
End Sub ! inputsection
!
! ------------------------------------------------
Sub CheckForIndex(I8$)
!
Try
  !
  I8$="N" ! not index file
  !
  DirKey$=DH.FileName$
  DirRec=-2
  search >= #c[2],1;DirKey$
  do
    try read record #c[2],DirRec;DK. else exit do
	if DK.FileName$=DH.FileName$ let I8$="Y"
	exit do
  loop
  !
else
  if xport
   if spc(8)<>10000
    call dfsuberr(e$,Spc(8),Spc(10),Msc$(2))
    !call programdump("")
   end if
   error 10000
  else
   ;"error";spc(8);" at line ";spc(10)
   stop
  end if
end try
!
end Sub ! checkforindex
!
! ------------------------------------------------
Sub ProcessIncSection(I8$)
!
Try
  !
  ! build 'inc' file
  
  FileName$="file",CurFile$,".inc"
  tmp$= PathInc$,Filename$," ",pathinc$,"backup/",Filename$,dateusing$(tim#(0),"YYYYMMDDHHNNSS")
  try
   duplicate tmp$ !make a backup copy
  else
    if spc(8)<>42 e$=spc(8),"Error trying to make backup copy of ",filename$,"!"\error 10000
  end try
  tmp$=PathInc$,FileName$,"!"
  build #c[11],+ tmp$
  ;#c[11];"Def Struct ";CurFile$;" ! ";DH.Desc$;"  generated by dfcreatestruct on ";DateUsing$(tim#(0),"MM/DD/YY")
  FieldKey$=DH.FileName$
  FieldRec=-2
  search >= #c[1],1;FieldKey$
  do
    try read record #c[1],FieldRec;DF. else exit do
    if DF.FileName$<>DH.FileName$ exit do
    !
    ! set up text string with field info
    tmptext$="  Member "
    tmp$=str$(int(abs(DF.Precision)))
    if DF.Precision<0 let tmptext$=tmptext$,tmp$,"%," ! numeric
    tmptext$=tmptext$,Rtrim$(DF.VarName$)
    if DF.Precision>0 let tmptext$=tmptext$,"[",tmp$,"]" ! string
    tmptext$=tmptext$,Blank$
    tmptext$=tmptext$[1,39],": Item "
    position = df.position
    If df.position = -1
        position = lastbyte + 1 !default
    End If 
    If df.precision > 0
        lastbyte = position + df.precision - 1
    Else 
        If position / 2 <> Int(position / 2) Let position = position + 1 !numerics must start on even byte
        lastbyte = position + (Int(df.precision * -1) * 2) - 1
    End If    
    !
    tmptext$=tmptext$,str$(position)," ! ",replace$(rtrim$(DF.LongDesc$),"\15\"," ") !remove CR's if there
    ;#c[11];tmptext$ ! write to text file
    !
    FieldRec=-1 ! next field defs record
  loop
  !
  ;#c[11];"End Def"
  ;#c[11];"!"
  ;#c[11];"! ";U$[1,40]
  !
  ! external lib statements
  ;#c[11];"!"
  ;#c[11];"! external lib statements"
  ;#c[11];"!"
  print #c[11];"External Lib ''libfile";CurFile$;".lib''"
  if I8$="Y" print #c[11];"declare external function fileget";CurFile$;",fileupdate";CurFile$
  ;#c[11];"declare external sub filedroplist";CurFile$
  !
  close #c[11]
  tmp$=PathInc$,FileName$, " <644>"
  Modify tmp$
  !
else
  if xport
   if spc(8)<>10000
    call dfsuberr(e$,Spc(8),Spc(10),Msc$(2))
    !call programdump("")
   end if
   error 10000
  else
   ;"error";spc(8);" at line ";spc(10)
   stop
  end if
end try
!
End Sub ! processincsection
!
! ------------------------------------------------
sub ProcessLibSection(I8$)
!
try
  !
  ! build 'inc' file
  FileName$="libfile",CurFile$,".src"
  tmp$=PathLib$,FileName$,"!"
  build #c[12],+ tmp$
  !
  ;#c[12];"! ";FileName$[1,len(FileName$)-4];".lib"
  ;#c[12];"!"
  ;#c[12];"! supporting library of file maintenance routines for browser"
  ;#c[12];"!"
  ;#c[12];"! 1.0 generated by dfcreatestruct on ";DateUsing$(tim#(0),"MM/DD/YY");" new"
  ;#c[12];"!"
  ;#c[12];"include ''";PathLib$;"copyright.inc''"
  ;#c[12];"!"
  ;#c[12];"! file maintenance sub routines for ";CurFile$;" File"
  ;#c[12];"!"
  if I8$="Y" print #c[12];"!  function  fileget";CurFile$
  if I8$="Y" print #c[12];"!  function  fileupdate";CurFile$
  ;#c[12];"!  function  filedroplist";CurFile$
  ;#c[12];"!"
  if i8$="Y" print #c[12];"Declare external function dfaudit !libgeneral.lib"
  ;#c[12];"Declare Intrinsic Sub Env,GetGlobals"
  ;#c[12];"Declare Intrinsic Function crc32,callstat$,trim$,findchannel"
  ;#c[12];"External Lib ''dfgeneral.lib''"
  ;#c[12];"Declare External Function dfDTConvert$"
  ;#c[12];"External Lib ''ubsfunc.dl4''"  !custom
  ;#c[12];"Declare External Function Openfile" !custom
  ;#c[12];"!"
  ;#c[12];"include ''";PathInc$;"file";CurFile$;".inc''"
  ;#c[12];"!"
  ;#c[12];"! ";U$[1,40]
  !
  If I8$="Y" ! index file
    !
    call CreateGet() ! creates get function
    call CreateUpdate() ! creates update function
    !
  endif
  !
  call CreateDropList(I8$) ! creates drop list
  !
  if I8$="Y" call CreateMain() ! creates main code  (maintenance verify on file code)
  !
  close #c[12]
  tmp$=PathLib$,FileName$, " <644>"
  Modify tmp$
else
  if xport
   if spc(8)<>10000
    call dfsuberr(e$,Spc(8),Spc(10),Msc$(2))
    !call programdump("")
   end if
   error 10000
  else
   ;"error";spc(8);" at line ";spc(10)
   stop
  end if
end try
End Sub ! ProcessLibSection
!
! ------------------------------------------------
sub CreateGet()
!
Try
  !
  ;#c[12];"external function fileget";CurFile$;
  ;#c[12];"(e$,chan,mode$,keyno,keyval$,";CurFile$;". as ";CurFile$;",...)"
  ;#c[12];"!"
  ;#c[12];"! get a ";CurFile$;" record"
  ;#c[12];"!"
  ;#c[12];"! pass e$ to return error msg if any"
  ;#c[12];"! pass chan channel # of file"
  ;#c[12];"! pass mode$ =,>,>=,<,<=,next,prev"
  ;#c[12];"! pass keyno for key number to search on"
  ;#c[12];"! pass keyval$ populated with key to search for"
  ;#c[12];"! pass structure to return record in"
  ;#c[12];"! optionals"
  ;#c[12];"!     pass lockflag<>0 to lock record"
  ;#c[12];"!     pass timeout period"
  ;#c[12];"!     pass CrcValue for crc value to be calculated and returned"
  ;#c[12];"!"
  ;#c[12];"! returns record # and record structure if found"
  ;#c[12];"! returns a negative number on an error, e$=routine error, -123=record locked"
  ;#c[12];"!"
  ;#c[12];"Try"
  ;#c[12];"!"
  ;#c[12];"  Try Enter lockflag,... Else Let lockflag = 0"
  ;#c[12];"  Try Enter timeout,... else let timeout = 100000"
  ;#c[12];"  Try Enter CrcValue else let CrcValue=-1" 
  ;#c[12];"  !"
  ;#c[12];"  dim hold$[300],tmp$[300],errmsg$[200],3%"
  ;#c[12];"  !"
  ;#c[12];"  if mode$=''='' or mode$=''>='' or mode$=''<='' let mode=2"
  ;#c[12];"  if mode$=''>'' or lcase$(mode$)=''next'' let mode=3"
  ;#c[12];"  if mode$=''<'' or lcase$(mode$)=''prev'' let mode=6"
  ;#c[12];"  !"
  ;#c[12];"  hold$ = keyval$"
  ;#c[12];"  search #chan,mode,keyno;keyval$,r1,e2"
  ;#c[12];"  if mode$=''=''"
  !!!!!!!previous code, but = should mean exact match, not partial match....for partial use >=   (if have to change back, change dfcreatestruct to do compare after for exact)
  !!!only thing is a lot of programs pass keyval$ with extra spaces, so compare using rtrim$
  ;#c[12];"   if rtrim$(keyval$) <> rtrim$(hold$) let e2=1"
  !!!!!!!;#c[12];"    if len(keyval$)<len(hold$) let e2=1"
  !!!!!!!;#c[12];"    tmp$=hold$"
  !!!!!!!;#c[12];"    if len(hold$)>len(keyval$) let tmp$=hold$[1,len(keyval$)]"
  !!!!!!!;#c[12];"    if e2=0 if keyval$[1,len(hold$)] <> tmp$ let e2 = 1"
  ;#c[12];"  endif"
  ;#c[12];"  if e2 if mode=2 if mode$<>''=''"
  ;#c[12];"    if mode$=''>='' let mode=3 else let mode=6"
  ;#c[12];"    search #chan,mode,keyno;keyval$,r1,e2"
  ;#c[12];"  end if"
  ;#c[12];"  if e2 = 0"
  ;#c[12];"    if lockflag=0 read record #chan,r1,0,timeout;";CurFile$;".; ";
  ;#c[12];"else read record #chan,r1,0,timeout;";CurFile$;"." ! continued line
  ;#c[12];"    CrcValue=crc32(hex$(";CurFile$;".))"
  ;#c[12];"  else"
  ;#c[12];"    r1 = e2 * -1 ! <0 error"
 ! ;#c[12];"    e$ = ''msg";CurFile$;"NOF''" !dxmsg.txt not on file message
  ;#c[12];"    e$ = ''msg Record Not On File''" !dxmsg.txt not on file message
  ;#c[12];"  end if"
  ;#c[12];"else"
  ;#c[12];"  if spc(8) = 123 exit function -123 ! record locked"
  ;#c[12];"  dim msc4$[100] \\ msc4$=msc$(4)"
  ;#c[12];"  if Pos(msc4$, = ''/'',-1) let msc4$=msc4$[pos(msc4$,=''/'',-1)+1]"
  ;#c[12];"  select case spc(8)"
  ;#c[12];"    case 10000"
  ;#c[12];"      ! this is default ''message'' error"
  ;#c[12];"      ! e$ should be set with message to display"
  ;#c[12];"    case 11000"
  ;#c[12];"      ! search error"
  ;#c[12];"      call env(2,''PROGNAME'',msc4$)"
  ;#c[12];"      call programdump()"
  ;#c[12];"      call searcherr(e$, e, Spc(10), e$)"
  ;#c[12];"    case else"
  ;#c[12];"      e$=''fileget";CurFile$;" mode='',mode,'' keyno='',keyno,'' r1='',r1,'' e2='',e2,'' keyval$='',keyval$"
  ;#c[12];"      if spc(8) <> 0 if spc(8) < 10000"
  ;#c[12];"        call env(2,''PROGNAME'',msc4$)"
  ;#c[12];"        call programdump()"
  ;#c[12];"        call suberr(e$,Spc(8),Spc(10),Msc$(2))"
  ;#c[12];"      end if"
  ;#c[12];"  end select"
  ;#c[12];"  error 10000"
  ;#c[12];"end try"
  ;#c[12];"end function r1 ! fileget";CurFile$
  ;#c[12];"!"
  ;#c[12];"! ";U$[1,40]
else
  if xport
   if spc(8)<>10000
    call dfsuberr(e$,Spc(8),Spc(10),Msc$(2))
    !call programdump("")
   end if
   error 10000
  else
   ;"error";spc(8);" at line ";spc(10)
   stop
  end if
end try
End Sub ! createget
!
! ------------------------------------------------
sub CreateUpdate()
!
Try
  !
  ;#c[12];"external function fileupdate";CurFile$; ! line is continued on next lib
  ;#c[12];"(e$,chan,mode$,rcdno,";CurFile$;". as ";CurFile$;",...)"
  ;#c[12];"!"
  ;#c[12];"! adds, changes or deletes a ";CurFile$;" record"
  ;#c[12];"!"
  ;#c[12];"! pass e$     : to return error msg if any"
  ;#c[12];"  ! pass chan   : channel # of file"
  ;#c[12];"  ! pass mode$  : a = add, c = change, d = delete"
  ;#c[12];"  ! pass rcdno  : on change or delete,"
  ;#c[12];"  !      if -4 is passed routine will get record (index 1 can't change on change)"
  ;#c[12];"  ! pass record : structure"
  ;#c[12];"  ! optionally pass lockflag to keep record locked"
  ;#c[12];"  ! optionally pass timeout period"
  ;#c[12];"  ! optionally pass chan# of audit log, -1 to audit but log not open"
  ;#c[12];"  ! optionally pass reason (up to 80 char) reason for change,writes to audit"
  ;#c[12];"  ! returns 0 or negative # if error, -9=already on file, -123=record locked"
  ;#c[12];"  ! returns rcdno added on add"
  ;#c[12];"  !"
  ;#c[12];"  ! search used in update call"
  ;#c[12];"  !"
  ;#c[12];"  Declare sub DoSearch,AddKeys,DeleteKeys,ChangeKeys"
  ;#c[12];"  !"
  !
  ;#c[12];"Try"
  ;#c[12];"  !"
  ;#c[12];"  Try Enter lockflag,... Else Let lockflag = 0"
  ;#c[12];"  Try enter timeout,... else let timeout = 100000"
  ;#c[12];"  Try enter auditchan,... else let auditchan = 0"
  ;#c[12];"  Try enter reason$ else dim reason$[1]"
  ;#c[12];"  !"
  ;#c[12];"  dim K$[300]"
  ;#c[12];"  dim 3%"
  ;#c[12];"  dim Dir1$[300],Dir2$[300],Dir3$[300],Dir4$[300],Dir5$[300]"
  ;#c[12];"  dim Dir6$[300],Dir7$[300],Dir8$[300],Dir9$[300]"
  ;#c[12];"  dim OldDir1$[300],OldDir2$[300],OldDir3$[300],OldDir4$[300],OldDir5$[300]"
  ;#c[12];"  dim OldDir6$[300],OldDir7$[300],OldDir8$[300],OldDir9$[300]"
  ;#c[12];"  dim errmsg$[200],Lmode$[1],3%"
  ;#c[12];"  dim old?[3072],new?[3072],auditk$[30]"
  ;#c[12];"  dim Blank$[300] \\ Blank$='' '',Blank$"
  ;#c[12];"  !"
  ;#c[12];"  Lmode$ = lcase$(mode$[1,1]) ! convert mode to lower case,just in case"
  ;#c[12];"  !"
  call CreateUpdateKeyVaribles() ! Gets key field names
  call CreateUpdateAddRecord() ! Add record and keys
  ;#c[12];"  if lmode$ = ''c'' or lmode$ = ''d'' ! change or delete, verify record"
  ;#c[12];"    dim old";CurFile$;". as ";CurFile$
  ;#c[12];"    if rcdno = -4 ! need to get the record first"
  ;#c[12];"      r=rcdno \\ oldr=rcdno ! if record # is used in the key"
  ;#c[12];"      k$=";Dir1$
  ;#c[12];"      call dosearch(k$,2,1,1) ! mode 2, dir 1, errflag 1 never trap as hard error"
  ;#c[12];"      if e"
  ;#c[12];"        ! Customer not on file!"
 ! ;#c[12];"        e$=''msg";CurFile$;"NOF'' ! set to not on file msg # in dxmsg.txt file"
   ;#c[12];"        e$=''msg Record Not On File'' ! set to not on file msg # in dxmsg.txt file"
  ;#c[12];"        exit function e * -1"
  ;#c[12];"      end if"
  ;#c[12];"    else"
  ;#c[12];"      r = rcdno \\ oldr=rcdno"
  ;#c[12];"    end if"
  ;#c[12];"    if auditchan mat read #chan,r;old?"
  ;#c[12];"    read record #chan,r,0,timeout;old";CurFile$;"."
  ;#c[12];"  endif"
  call CreateUpdateDeleteRecord() ! Delete record and keys
  call CreateUpdateChangeRecord() ! Change record and keys
  ;#c[12];"  !"
  ;#c[12];"  if auditchan"
  ;#c[12];"   r=dfaudit(e$,auditchan,''";curfile$;"'',lmode$,auditk$,old?,new?,reason$)"
  ;#c[12];"  end if !auditchan"
  ;#c[12];"else"
  ;#c[12];"  if spc(8) = 123 exit function -123 ! record locked"
  ;#c[12];"  dim msc4$[100] \\ msc4$=msc$(4)"
  ;#c[12];"  if Pos(msc4$, = ''/'',-1) let msc4$=msc4$[pos(msc4$,=''/'',-1)+1]"
  ;#c[12];"  select case spc(8)"
  ;#c[12];"    case 10000"
  ;#c[12];"      ! this is default ''message'' error"
  ;#c[12];"      ! e$ should be set with message to display"
  ;#c[12];"    case 11000"
  ;#c[12];"      ! search error"
  ;#c[12];"      call env(2,''PROGNAME'',msc4$)"
  ;#c[12];"      call programdump()"
  ;#c[12];"      call searcherr(e$, e, Spc(10))"
  ;#c[12];"    case else"
  ;#c[12];"      if spc(8) < 10000"
  ;#c[12];"        call env(2,''PROGNAME'',msc4$)"
  ;#c[12];"        call programdump()"
  ;#c[12];"        call suberr(e$,Spc(8),Spc(10),Msc$(2))"
  ;#c[12];"      end if"
  ;#c[12];"  end select"
  ;#c[12];"  error 10000"
  ;#c[12];"End Try"
  ;#c[12];"!"
  ;#c[12];"!";U$[1,40]
  ;#c[12];"sub dosearch(k$,m,k,...)"
  ;#c[12];"  !"
  ;#c[12];"  !pass k$=keyvalue, m=mode, k=keyno, optionally errflag <>0 return e, don't err"
  ;#c[12];"  !"
  ;#c[12];"  try enter errflag else let errflag=0"
  ;#c[12];"  search #chan,m,k;k$,r,e"
  ;#c[12];"  if e if errflag=0 let e$=''syserrorfile fileupdate";CurFile$;" mode (m)='',m,'' keyno (k)='',k,'' r='',r,'' e='',e,'' keyval (k$)='',k$"
  ;#c[12];"  if e if errflag=0 error 11000 !hard search error"
  ;#c[12];"end sub ! dosearch"
  ;#c[12];"!"
  ;#c[12];"!";U$[1,40]
  ;#c[12];"sub AddKeys(BegDir,EndDir)"
  ;#c[12];"  !"
  ;#c[12];"  ! BegDir = Beginning Directory"
  ;#c[12];"  ! EndDir = Ending Directory"
  ;#c[12];"  !"
  ;#c[12];"  try"
  ;#c[12];"    Dim CurKey$[300],3%,CurRec"
  ;#c[12];"    !"
  ;#c[12];"    For CurDir=BegDir to EndDir"
  ;#c[12];"      CurKey$=''''"
  if Dir1$ print#c[12];"      if CurDir=1 let CurKey$=";Dir1$
  if Dir1$ print#c[12];"      if CurDir=1 let auditk$=curkey$"
  if Dir2$ print#c[12];"      if CurDir=2 let CurKey$=";Dir2$
  if Dir3$ print#c[12];"      if CurDir=3 let CurKey$=";Dir3$
  if Dir4$ print#c[12];"      if CurDir=4 let CurKey$=";Dir4$
  if Dir5$ print#c[12];"      if CurDir=5 let CurKey$=";Dir5$
  if Dir6$ print#c[12];"      if CurDir=6 let CurKey$=";Dir6$
  if Dir7$ print#c[12];"      if CurDir=7 let CurKey$=";Dir7$
  if Dir8$ print#c[12];"      if CurDir=8 let CurKey$=";Dir8$
  if Dir9$ print#c[12];"      if CurDir=9 let CurKey$=";Dir9$
  ;#c[12];"      call DoSearch(CurKey$,4,CurDir) ! add key to directory"
  ;#c[12];"    next CurDir"
  ;#c[12];"else"
  ;#c[12];"  dim msc4$[100] \\ msc4$=msc$(4)"
  ;#c[12];"  if Pos(msc4$, = ''/'',-1) let msc4$=msc4$[pos(msc4$,=''/'',-1)+1]"
  ;#c[12];"  select case spc(8)"
  ;#c[12];"    case 10000"
  ;#c[12];"      ! this is default ''message'' error"
  ;#c[12];"      ! e$ should be set with message to display"
  ;#c[12];"    case 11000"
  ;#c[12];"      ! search error"
  ;#c[12];"      call env(2,''PROGNAME'',msc4$)"
  ;#c[12];"      call programdump()"
  ;#c[12];"      call searcherr(e$, e, Spc(10),e$)"
  ;#c[12];"    case else"
  ;#c[12];"      if spc(8) < 10000"
  ;#c[12];"        call env(2,''PROGNAME'',msc4$)"
  ;#c[12];"        call programdump()"
  ;#c[12];"        call suberr(e$,Spc(8),Spc(10),Msc$(2))"
  ;#c[12];"      end if"
  ;#c[12];"  end select"
  ;#c[12];"  error 10000"
  ;#c[12];"End Try"
  ;#c[12];"End Sub ! AddKeys"
  ;#c[12];"!"
  ;#c[12];"!";U$[1,40]
  ;#c[12];"sub DeleteKeys(BegDir,EndDir)"
  ;#c[12];"  !"
  ;#c[12];"  ! BegDir = Beginning Directory"
  ;#c[12];"  ! EndDir = Ending Directory"
  ;#c[12];"  !"
  ;#c[12];"  Try"
  ;#c[12];"    Dim CurKey$[300],3%,CurRec"
  ;#c[12];"    !"
  ;#c[12];"    For CurDir=EndDir to BegDir Step -1"
  ;#c[12];"      CurKey$=''''"
  if Dir1$ print#c[12];"      if CurDir=1 let CurKey$=";OldDir1$
  if Dir2$ print#c[12];"      if CurDir=2 let CurKey$=";OldDir2$
  if Dir3$ print#c[12];"      if CurDir=3 let CurKey$=";OldDir3$
  if Dir4$ print#c[12];"      if CurDir=4 let CurKey$=";OldDir4$
  if Dir5$ print#c[12];"      if CurDir=5 let CurKey$=";OldDir5$
  if Dir6$ print#c[12];"      if CurDir=6 let CurKey$=";OldDir6$
  if Dir7$ print#c[12];"      if CurDir=7 let CurKey$=";OldDir7$
  if Dir8$ print#c[12];"      if CurDir=8 let CurKey$=";OldDir8$
  if Dir9$ print#c[12];"      if CurDir=9 let CurKey$=";OldDir9$
  ;#c[12];"      if CurDir=1 let auditk$ = CurKey$"
  ;#c[12];"      call DoSearch(CurKey$,5,CurDir) ! add key to directory"
  ;#c[12];"    next CurDir"
  ;#c[12];"else"
  ;#c[12];"  dim msc4$[100] \\ msc4$=msc$(4)"
  ;#c[12];"  if Pos(msc4$, = ''/'',-1) let msc4$=msc4$[pos(msc4$,=''/'',-1)+1]"
  ;#c[12];"  select case spc(8)"
  ;#c[12];"    case 10000"
  ;#c[12];"      ! this is default ''message'' error"
  ;#c[12];"      ! e$ should be set with message to display"
  ;#c[12];"    case 11000"
  ;#c[12];"      ! search error"
  ;#c[12];"      call env(2,''PROGNAME'',msc4$)"
  ;#c[12];"      call programdump()"
  ;#c[12];"      call searcherr(e$, e, Spc(10),e$)"
  ;#c[12];"    case else"
  ;#c[12];"      if spc(8) < 10000"
  ;#c[12];"        call env(2,''PROGNAME'',msc4$)"
  ;#c[12];"        call programdump()"
  ;#c[12];"        call suberr(e$,Spc(8),Spc(10),Msc$(2))"
  ;#c[12];"      end if"
  ;#c[12];"  end select"
  ;#c[12];"  error 10000"
  ;#c[12];"End Try"
  ;#c[12];"End Sub ! DeleteKeys"
  ;#c[12];"!"
  ;#c[12];"!";U$[1,40]
  ;#c[12];"sub ChangeKeys()"
  ;#c[12];"  !"
  ;#c[12];"  try"
  ;#c[12];"    Dim CurKey$[300],OldKey$[300],3%"
  ;#c[12];"    !"
  if Dir9$
    ;#c[12];"    ! Directory #9"
    ;#c[12];"    OldKey$=";OldDir9$
    ;#c[12];"    CurKey$=";Dir9$
    ;#c[12];"    if CurKey$<>OldKey$"
    ;#c[12];"      call DoSearch(OldKey$,5,9)"
    ;#c[12];"      call DoSearch(Curkey$,4,9)"
    ;#c[12];"    endif"
    ;#c[12];"    !"
  endif
  if Dir8$
    ;#c[12];"    ! Directory #8"
    ;#c[12];"    OldKey$=";OldDir8$
    ;#c[12];"    CurKey$=";Dir8$
    ;#c[12];"    if CurKey$<>OldKey$"
    ;#c[12];"      call DoSearch(OldKey$,5,8)"
    ;#c[12];"      call DoSearch(Curkey$,4,8)"
    ;#c[12];"    endif"
    ;#c[12];"    !"
  endif
  if Dir7$
    ;#c[12];"    ! Directory #7"
    ;#c[12];"    OldKey$=";OldDir7$
    ;#c[12];"    CurKey$=";Dir7$
    ;#c[12];"    if CurKey$<>OldKey$"
    ;#c[12];"      call DoSearch(OldKey$,5,7)"
    ;#c[12];"      call DoSearch(Curkey$,4,7)"
    ;#c[12];"    endif"
    ;#c[12];"    !"
  endif
  if Dir6$
    ;#c[12];"    ! Directory #6"
    ;#c[12];"    OldKey$=";OldDir6$
    ;#c[12];"    CurKey$=";Dir6$
    ;#c[12];"    if CurKey$<>OldKey$"
    ;#c[12];"      call DoSearch(OldKey$,5,6)"
    ;#c[12];"      call DoSearch(Curkey$,4,6)"
    ;#c[12];"    endif"
    ;#c[12];"    !"
  endif
  if Dir5$
    ;#c[12];"    ! Directory #5"
    ;#c[12];"    OldKey$=";OldDir5$
    ;#c[12];"    CurKey$=";Dir5$
    ;#c[12];"    if CurKey$<>OldKey$"
    ;#c[12];"      call DoSearch(OldKey$,5,5)"
    ;#c[12];"      call DoSearch(Curkey$,4,5)"
    ;#c[12];"    endif"
    ;#c[12];"    !"
  endif
  if Dir4$
    ;#c[12];"    ! Directory #4"
    ;#c[12];"    OldKey$=";OldDir4$
    ;#c[12];"    CurKey$=";Dir4$
    ;#c[12];"    if CurKey$<>OldKey$"
    ;#c[12];"      call DoSearch(OldKey$,5,4)"
    ;#c[12];"      call DoSearch(Curkey$,4,4)"
    ;#c[12];"    endif"
    ;#c[12];"    !"
  endif
  if Dir3$
    ;#c[12];"    ! Directory #3"
    ;#c[12];"    OldKey$=";OldDir3$
    ;#c[12];"    CurKey$=";Dir3$
    ;#c[12];"    if CurKey$<>OldKey$"
    ;#c[12];"      call DoSearch(OldKey$,5,3)"
    ;#c[12];"      call DoSearch(Curkey$,4,3)"
    ;#c[12];"    endif"
    ;#c[12];"    !"
  endif
  if Dir2$
    ;#c[12];"    ! Directory #2"
    ;#c[12];"    OldKey$=";OldDir2$
    ;#c[12];"    CurKey$=";Dir2$
    ;#c[12];"    if CurKey$<>OldKey$"
    ;#c[12];"      call DoSearch(OldKey$,5,2)"
    ;#c[12];"      call DoSearch(Curkey$,4,2)"
    ;#c[12];"    endif"
    ;#c[12];"    !"
  endif
  if Dir1$
    ;#c[12];"    ! Directory #1"
    ;#c[12];"    OldKey$=";OldDir1$
    ;#c[12];"    CurKey$=";Dir1$
	;#c[12];"    auditk$=curkey$"
    ;#c[12];"    if CurKey$<>OldKey$"
    ;#c[12];"      call DoSearch(OldKey$,5,1)"
    ;#c[12];"      call DoSearch(Curkey$,4,1)"
    ;#c[12];"    endif"
  endif
  ;#c[12];"    !"
  ;#c[12];"else"
  ;#c[12];"  dim msc4$[100] \\ msc4$=msc$(4)"
  ;#c[12];"  if Pos(msc4$, = ''/'',-1) let msc4$=msc4$[pos(msc4$,=''/'',-1)+1]"
  ;#c[12];"  select case spc(8)"
  ;#c[12];"    case 10000"
  ;#c[12];"      ! this is default ''message'' error"
  ;#c[12];"      ! e$ should be set with message to display"
  ;#c[12];"    case 11000"
  ;#c[12];"      ! search error"
  ;#c[12];"      call env(2,''PROGNAME'',msc4$)"
  ;#c[12];"      call programdump()"
  ;#c[12];"      call searcherr(e$, e, Spc(10),e$)"
  ;#c[12];"    case else"
  ;#c[12];"      if spc(8) < 10000"
  ;#c[12];"        call env(2,''PROGNAME'',msc4$)"
  ;#c[12];"        call programdump()"
  ;#c[12];"        call suberr(e$,Spc(8),Spc(10),Msc$(2))"
  ;#c[12];"      end if"
  ;#c[12];"  end select"
  ;#c[12];"  error 10000"
  ;#c[12];"End Try"
  ;#c[12];"End Sub  ! ChangeKeys"
  ;#c[12];"!"

  ;#c[12];"End Function e ! update";CurFile$
  ;#c[12];"!"
  ;#c[12];"! ";U$[1,40]
  !
else
  if xport
   if spc(8)<>10000
    call dfsuberr(e$,Spc(8),Spc(10),Msc$(2))
    !call programdump("")
   end if
   error 10000
  else
   ;"error";spc(8);" at line ";spc(10)
   stop
  end if
end try
End Sub ! createupdate
!
! ------------------------------------------------
sub CreateUpdateKeyVaribles()
!
Try
  !
  dim tmpDF. as FileDefFields
  !
  ! reset dir#$ varibles
  Dir1$="" \ Dir2$="" \ Dir3$="" \ Dir4$="" \ Dir5$=""
  Dir6$="" \ Dir7$="" \ Dir8$="" \ Dir9$=""
  OldDir1$="" \ OldDir2$="" \ OldDir3$="" \ OldDir4$="" \ OldDir5$=""
  OldDir6$="" \ OldDir7$="" \ OldDir8$="" \ OldDir9$=""
  !
  DirKey$=DH.FileName$
  DirRec=-2
  search >= #c[2],1;DirKey$
  do
    try read record #c[2],DirRec;DK. else exit do
    if DK.FileName$<>DH.FileName$ exit do
    !
    ! get field def record for key
    tmpDFrec=-2
    ! --- tmp1=DK.RcdPosition
    search >= #c[1],1;DK.FileName$,DK.Version$,DK.RcdPosition
    try read record #c[1],tmpDFrec;tmpDF. else exit do
    !
    ! setup variable to insert into directory field
    tmp$=CurFile$,".",tmpDF.VarName$ ! field name
	if holddir1$="" let holddir1$=tmp$
    tmpold$="old", CurFile$,".",tmpDF.VarName$
	!
	!!too complicated to deal with keyonly-need to Dim parts and pass in old and new values
	!!xpos=pos(ucase$(DK.opts$),="KEYONLY")
	!!if xpos let tmp$="key",str$(dk.seq),"part",str$(dk.keypart),"$" \tmpold$="old",tmp$
    !
    tmp1=0 \ pos1=0 \ pos2=0
	DK.Opts$=ucase$(DK.Opts$)
    tmpDF.Opts$=ucase$(tmpDF.Opts$)
	!first convert field value with fieldopts$ if needed
	!begin field DTOC
	tmp1$ = tmp$
	tmp1old$ = tmpold$
	xpos=pos(ucase$(tmpDF.Opts$),="DTOC(''")
    if xpos let ypos=pos(ucase$(tmpDF.Opts$[xpos+6]),="'')")
    if xpos if ypos !date field conversion option
     tmp1$= "dfDTconvert$(e$,",tmp$,",''",tmpDF.Opts$[xpos+6,xpos+6+ypos-2],"'',''MMDDYY'')"
     tmp1old$= "dfDTconvert$(e$,",tmpold$,",''",tmpDF.Opts$[xpos+6,xpos+6+ypos-2],"'',''MMDDYY'')"
    end if
	!end field DTOC
	!
	!now convert value with keyopts$ if needed
    !begin key DTOC
	xpos=pos(ucase$(DK.opts$),="DTOC(''")
    if xpos let ypos=pos(ucase$(DK.opts$[xpos+6]),="'')")
    if xpos if ypos !date field conversion option
     tmp$= "dfDTconvert$(e$,",tmp1$,",''MMDDYY'',''",DK.opts$[xpos+6,xpos+6+ypos-2],"'')"
     tmpold$= "dfDTconvert$(e$,",tmp1old$,",''MMDDYY'',''",DK.opts$[xpos+6,xpos+6+ypos-2],"'')"
    end if
	!end key DTOC
	!
    ! check for numeric masking
    call StringSearch(DK.opts$,1,"NTOC",tmp1) 
    if tmp1>0 call StringSearch(DK.opts$,tmp1,"(",pos1)
    if pos1>0 call StringSearch(DK.opts$,pos1+1,")",pos2)
    if pos2>0     
      call StringSearch(DK.opts$,pos2,"RECNO",tmp2)
	  if tmp2>0 let tmp1$="r" else tmp1$=tmp$ ! record # or field name
	  if DK.opts$[pos1+1,pos1+1]="''"
	   let tmp$=tmp1$," using ",DK.opts$[pos1+1,pos2-1]  !note NTOC("##") format already has quotes
       let tmpold$="old",tmp1$," using ",DK.opts$[pos1+1,pos2-1]
	  else
	   let tmp$=tmp1$," using ''",DK.opts$[pos1+1,pos2-1],"''"  ! NTOC DOES NOT HAVE QUOTES!
       let tmpold$="old",tmp1$," using ''",DK.opts$[pos1+1,pos2-1],"''"
	  end if
	endif
    !
    tmp11=0 \ pos11=0 \ pos12=0
    call StringSearch(DK.opts$,1,"NFTOC",tmp11) 
    if tmp11>0 call StringSearch(DK.opts$,tmp11,"(",pos11)
    if pos11>0 call StringSearch(DK.opts$,pos11+1,")",pos12)
	if pos12>0 
	  let tmp1$=tmp$
	  if DK.opts$[pos11+1,pos11+1]="''"
       let tmp$="FRA(",tmp1$,")*100 using ",DK.opts$[pos11+1,pos12-1]
	   let tmpold$="FRA(old",tmp1$,")*100 using ",DK.opts$[pos11+1,pos12-1]
	  else
       let tmp$="FRA(",tmp1$,")*100 using ''",DK.opts$[pos11+1,pos12-1],"''"
	   let tmpold$="FRA(old",tmp1$,")*100 using ''",DK.opts$[pos11+1,pos12-1],"''"
	  end if
	endif
    !
    ! check if partial field length is used
    tmpkeylen=0
    if tmpDF.Precision > 0 if tmpDF.Precision<>DK.Precision let tmpkeylen=DK.Precision
    if tmpkeylen let tmp$=tmp$,"[1,",tmpkeylen,"]" \ let tmpold$=tmpold$,"[1,",tmpkeylen,"]"
    !
    DirNo=DK.Seq ! directory #
    ! 
    ! Creates varibles for new & old keys
    Select Case DirNo
      Case 1 ! Dir #1
        if Dir1$ let Dir1$=Dir1$,"," ! add break for next field in key
        Dir1$=Dir1$,tmp$
        if OldDir1$ let OldDir1$=OldDir1$,","
        OldDir1$=OldDir1$,tmpold$
	    NumDir=1
      Case 2 ! Dir #2
        if Dir2$ let Dir2$=Dir2$,","
  	    Dir2$=Dir2$,tmp$
	    if OldDir2$ let OldDir2$=OldDir2$,","
	    OldDir2$=OldDir2$,tmpold$
	    NumDir=2
      Case 3 ! Dir #3
        if Dir3$ let Dir3$=Dir3$,","
	    Dir3$=Dir3$,tmp$
	    if OldDir3$ let OldDir3$=OldDir3$,","
	    OldDir3$=OldDir3$,tmpold$
	    NumDir=3
      Case 4 ! Dir #4
        if Dir4$ let Dir4$=Dir4$,","
	    Dir4$=Dir4$,tmp$
	    if OldDir4$ let OldDir4$=OldDir4$,","
	    OldDir4$=OldDir4$,tmpold$
	    NumDir=4
      Case 5 ! Dir #5
	    if Dir5$ let Dir5$=Dir5$,","
        Dir5$=Dir5$,tmp$
	    if OldDir5$ let OldDir5$=OldDir5$,","
	    OldDir5$=OldDir5$,tmpold$
	    NumDir=5
      Case 6 ! Dir #6
        if Dir6$ let Dir6$=Dir6$,","
		Dir6$=Dir6$,tmp$
	    if OldDir6$ let OldDir6$=OldDir6$,","
	    OldDir6$=OldDir6$,tmpold$
	    NumDir=6
      Case 7 ! Dir #7
        if Dir7$ let Dir7$=Dir7$,","
	    Dir7$=Dir7$,tmp$
	    if OldDir7$ let OldDir7$=OldDir7$,","
	    OldDir7$=OldDir7$,tmpold$
	    NumDir=7
      Case 8 ! Dir #8
        if Dir8$ let Dir8$=Dir8$,","
	    Dir8$=Dir8$,tmp$
	    if OldDir8$ let OldDir8$=OldDir8$,","
	    OldDir8$=OldDir8$,tmpold$
	    NumDir=8
      Case 9 ! Dir #9
        if Dir9$ let Dir9$=Dir9$,","
	    Dir9$=Dir9$,tmp$
	    if OldDir9$ let OldDir9$=OldDir9$,","
	    OldDir9$=OldDir9$,tmpold$
	    NumDir=9
      end Select
    !
    DirRec=-1 ! next key record
  loop
  !
else
  if xport
   if spc(8)<>10000
    call dfsuberr(e$,Spc(8),Spc(10),Msc$(2))
    !call programdump("")
   end if
   error 10000
  else
   ;"error";spc(8);" at line ";spc(10)
   stop
  end if
end try
End Sub ! closesection
!
! ------------------------------------------------
sub CreateUpdateAddRecord()
!
Try
  !
  ;#c[12];"  if Lmode$ = ''a'' ! add: set defaults, check not on file, get free record"
  ;#c[12];"    k$=";Dir1$
  ;#c[12];"    call dosearch(k$,2,1,1) ! search mode=2 dir=1 errflag"
  ;#c[12];"    if e = 0 ! record already on file, can't add error"
  !;#c[12];"      e$ = ''msg";CurFile$;"OnFile'' ! set to already on file msg # in dxmsg.txt file"
  ;#c[12];"      e$ = ''msg Record Already On File'' ! set to already on file msg # in dxmsg.txt file"
  ;#c[12];"      exit function -9 ! -9 indicates already on file!"
  ;#c[12];"    end if"
  ;#c[12];"    !"
  ;#c[12];"    e=2"
  ;#c[12];"    call dosearch('''',1,0) ! get record #"
  ;#c[12];"    !"
  !8/30/11 move to below write ;#c[12];"    call AddKeys(1,";NumDir;") ! add keys, all directories"
  ;#c[12];"    !"
  ;#c[12];"    if auditchan"
  ;#c[12];"     write record #chan,r,0,timeout;";CurFile$;".;"
  ;#c[12];"     if lockflag=0 mat read #chan,r;old?; else mat read #chan,r;old?"
  ;#c[12];"    else"
  ;#c[12];"     if lockflag=0 write record #chan,r,0,timeout;";CurFile$;".; else write record #chan,r,0,timeout;";CurFile$;"."
  ;#c[12];"    end if"    
  ;#c[12];"    !"
		;#c[12];"    call AddKeys(1,";NumDir;") ! add keys, all directories"
  ;#c[12];"    e=r !return record # added"
  ;#c[12];"  endif"
  ;#c[12];"  !"
else
  if xport
   if spc(8)<>10000
    call dfsuberr(e$,Spc(8),Spc(10),Msc$(2))
    !call programdump("")
   end if
   error 10000
  else
   ;"error";spc(8);" at line ";spc(10)
   stop
  end if
end try
End Sub ! createupdateaddrecord
!
! ------------------------------------------------
sub CreateUpdateDeleteRecord()
!
Try
  !
  ;#c[12];"  !"
  ;#c[12];"  if Lmode$ = ''d'' ! deletes keys and record #"  
  ;#c[12];"    !"
  ;#c[12];"    read record #chan,r,0,timeout;";CurFile$;".;" !added 8/30/11 to unlock record
  ;#c[12];"    call DeleteKeys(1,";NumDir;") ! delete keys, all directories"
  ;#c[12];"    !"
  ;#c[12];"    e=3"
  ;#c[12];"   call dosearch('''',1,0) ! releases record #"
  ;#c[12];"  endif"
else
  if xport
   if spc(8)<>10000
    call dfsuberr(e$,Spc(8),Spc(10),Msc$(2))
    !call programdump("")
   end if
   error 10000
  else
   ;"error";spc(8);" at line ";spc(10)
   stop
  end if
end try
End Sub ! createupdatedeleterecord
!
! ------------------------------------------------
Sub CreateUpdateChangeRecord()
!
Try
  !
  ;#c[12];"  !"
  ;#c[12];"  if Lmode$ = ''c'' ! change record and keys"
  ;#c[12];"    !"
  ;#c[12];"    if auditchan"
  ;#c[12];"     write record #chan,r,0,timeout;";CurFile$;".;"
  ;#c[12];"     if lockflag=0 mat read #chan,r;new?; else mat read #chan,r;new?"
  ;#c[12];"    else"
  ;#c[12];"     if lockflag=0 write record #chan,r,0,timeout;";CurFile$;".; else write record #chan,r,0,timeout;";CurFile$;"."
  ;#c[12];"    end if"
  ;#c[12];"    if auditchan=0 if lockflag write record #chan,r,0,timeout;";CurFile$;"."
  ;#c[12];"    !"
  ;#c[12];"    call ChangeKeys() ! deletes old keys & add new keys"
  ;#c[12];"  endif"
else
  if xport
   if spc(8)<>10000
    call dfsuberr(e$,Spc(8),Spc(10),Msc$(2))
    !call programdump("")
   end if
   error 10000
  else
   ;"error";spc(8);" at line ";spc(10)
   stop
  end if 
end try
End Sub ! createupdatechangerecord
!
! ------------------------------------------------
Sub CreateDropList(I8$)
!
Try
  !
  !  Create drop down list  
  !
  ;#c[12];"external sub filedroplist";CurFile$;"(e$,list$[],maxcnt,Chan,...)" ! line is continued on next lib
  ;#c[12];"  !"
  ;#c[12];"  ! creates a drop list"
  ;#c[12];"  !"
  ;#c[12];"  ! e$          : to return error msg if any"
  ;#c[12];"  ! List$[]     : the record created from the field array"
  ;#c[12];"  ! maxcnt      : maxmium # of lines for list array"
  ;#c[12];"  ! Chan        : the channel # of the file"
  ;#c[12];"  !"
  ;#c[12];"  ! Optional parameters"
  ;#c[12];"  ! Section$    : .net, the section to be created and sent to web"
  ;#c[12];"  ! Field$[]    : the fields being created in the drop down list"
  ;#c[12];"  !               in the order of being displayed"
  if I8$="Y" print #c[12];"  ! KeyNo       : the directory # to search"
  if I8$="Y" print #c[12];"  ! KeyVal$     : beginning key / compare to"
  ;#c[12];"  ! Others$     : list of flags to display other drop list options 0=None,A=All"
  ;#c[12];"  !"
  ;#c[12];"  Try"
  ;#c[12];"    !"
  print #c[12];"    Try enter iSection$,... else dim iSection$[1]"
  call createdropheading(1)
  print #c[12];"    Try enter iField$[],... else dim iField$[1,30]"
  if I8$="Y"
    ;#c[12];"    Try enter KeyNo,... else let KeyNo=1"
    ;#c[12];"    Try enter KeyVal$,... else Dim KeyVal$[300]"
  endif
  print #c[12];"    Try enter Others$ else dim Others$[1]"
  ;#c[12];"    !"
  ;#c[12];"    option string redim is legal"
  ;#c[12];"    !"
  ;#c[12];"    dim tmp$[50],tmpfield$[50],tmpline$[500],calling$[14],errtype$[1],Section$[30],Field$[";fieldcnt;",30]"
  ;#c[12];"    dim bsdel$[20],esdel$[20],rdel$[20],fdel$[20]"
  if I8$="Y" print #c[12];"    dim SearKey$[300],Mode$[5]"
  ;#c[12];"    dim 2%,row"
  ;#c[12];"    dim 2%,tmpcnt,3%"
  ;#c[12];"    !"
  ;#c[12];"    dim ";CurFile$;". as ";CurFile$
  ;#c[12];"    Section$ = iSection$"
  ;#c[12];"    for i=0 to ubound(iField$[],1)"
  ;#c[12];"     Field$[i]=iField$[i]"
  ;#c[12];"    next i"
  ;#c[12];"    calling$=callstat$(1,errtype$)"
  ;#c[12];"    if calling$=''libfilehandler'' let blockformat=1 !dxblock <data> format"
  ;#c[12];"    !"
  ;#c[12];"    call env(1,''BSDEL'',bsdel$)"
  ;#c[12];"    call env(1,''ESDEL'',esdel$)"
  ;#c[12];"    call env(1,''RDEL'',rdel$)"
  ;#c[12];"    call env(1,''FDEL'',fdel$)"
  ;#c[12];"    !"
  ;#c[12];"    if Section$='''' let Section$=''droplist";CurFile$;"''"
  ;#c[12];"    tmpcnt=ubound(list$[],1)"
  ;#c[12];"    row=0"
  ;#c[12];"    !"
  ;#c[12];"    ! beginning section"
  ;#c[12];"    Clear list$[]" !080612
  ;#c[12];"    List$[0]=bsdel$,Section$,fdel$ ! beginning section"
  ;#c[12];"    !"
  ;#c[12];"    ! heading section for .net"
  ;#c[12];"    cnt=0"
  ;#c[12];"    if field$=''''"
  call CreateDropHeading() ! get field names for heading & field name variables
  ;#c[12];"    else"
  ;#c[12];"      tmpline$=''ID'',fdel$"
  ;#c[12];"      while Field$[cnt]"
  ;#c[12];"        tmpline$=tmpline$,trim$(Field$[cnt]),fdel$ ! field name"
  ;#c[12];"        cnt=cnt+1"
  ;#c[12];"      wend"
  ;#c[12];"    endif"
  ;#c[12];"    if blockformat=0"
  ;#c[12];"     List$[1]=tmpline$"
   ;#c[12];"    row=2"
  ;#c[12];"    end if"
  ;#c[12];"    !"
  !this piece not used, because tied to filedef not page block, instead put Others flags in pagedef inp field userdef2 and the droplist routine will look for flags
  !if dh.userdef2$ <> ""  !additional droplist values format value~desc|value~desc   ie 0~No Service Charge
  ! tmp$=dh.userdef2$
  ! do
  !  xpos=pos(tmp$,="~")
  !  if xpos<2 or xpos=len(tmp$) exit do !formatting problem
  !  Searkey$=tmp$[1,xpos-1] !value
  !  tmp$=tmp$[xpos+1]
  !  xpos=pos(tmp$,="|")
  !  tmpline$=""
  !  if xpos=0 let tmpline$=tmp$ else if xpos>1 let tmpline$=tmp$[1,xpos-1]
  !  if tmpline$<>""
  !   ;#c[12];"          if blockformat=0 List$[row]=''";SearKey$;"'',fdel$,''";tmpline$;"'',fdel$"
  !   ;#c[12];"          if blockformat let list$[row]=''";tmpline$;"'',fdel$,''";trim$(searkey$);"'',fdel$,fdel$"
  !   ;#c[12];"          row=row+1"
  !  end if
  !  if xpos=0 or xpos=len(tmp$) exit do !done
  !  tmp$=tmp$[xpos+1]
  ! loop
  !end if  !dh.userdef2$
  ;#c[12];" !any other optional elements to include in drop list (defined in page block userdef2"
    ;#c[12];"       sub tmpline(tmp$) !needed to put right # of fields in others"
  	;#c[12];"        tmpline$=''''"
	;#c[12];"        for fcnt=0 to ubound(Field$[],1)"
	;#c[12];"          if Field$[fcnt] = '''' exit for"
	;#c[12];"          tmpfield$='' ''"
	;#c[12];"          if fcnt=0 let tmpfield$=tmp$"
	;#c[12];"          if blockformat"
	;#c[12];"           let tmpline$=tmpline$,rtrim$(tmpfield$),'' ''"
	;#c[12];"          else"
	;#c[12];"           let tmpline$=tmpline$,rtrim$(tmpfield$),fdel$"
	;#c[12];"          end if"
	;#c[12];"        next fcnt"
	;#c[12];"       end sub"
  ;#c[12];" xpos=pos(ucase$(others$),=''A'')"
  ;#c[12];" if xpos"
  ;#c[12];"          call tmpline(''All'')"
  ;#c[12];"          if blockformat=0 List$[row]=''A'',fdel$,tmpline$"
  ;#c[12];"          if blockformat let list$[row]=tmpline$,fdel$,''A'',fdel$,fdel$"
  ;#c[12];"          row=row+1"
  ;#c[12];" end if"
  ;#c[12];" xpos=pos(ucase$(others$),=''0'')"
  ;#c[12];" if xpos"
  ;#c[12];"          call tmpline(''None'')"
  ;#c[12];"          if blockformat=0 List$[row]=''0'',fdel$,tmpline$"
  ;#c[12];"          if blockformat let list$[row]=tmpline$,fdel$,''0'',fdel$,fdel$"
  ;#c[12];"          row=row+1"
  ;#c[12];" end if"  
  ;#c[12];" xpos=pos(ucase$(others$),=''B'') !blank"
  ;#c[12];" if xpos"
  ;#c[12];"          call tmpline('''')"
  ;#c[12];"          if blockformat=0 List$[row]='''',fdel$,tmpline$"
  ;#c[12];"          if blockformat let list$[row]=tmpline$,fdel$,'''',fdel$,fdel$"
  ;#c[12];"          row=row+1"
  ;#c[12];" end if"  
  ;#c[12];" xpos=pos(ucase$(others$),=''C'')"
  ;#c[12];" if xpos"
  ;#c[12];"          call tmpline(''Total of Selected'')"
  ;#c[12];"          if blockformat=0 List$[row]=''C'',fdel$,tmpline$"
  ;#c[12];"          if blockformat let list$[row]=tmpline$,fdel$,''C'',fdel$,fdel$"
  ;#c[12];"          row=row+1"
  ;#c[12];" end if"  
  ;#c[12];"    ! create data section"
  if I8$="Y" ! index file
    ;#c[12];"      SearKey$=KeyVal$"
    ;#c[12];"      Mode$=''>''"
    ;#c[12];"      do"
    ;#c[12];"        RecNo=FileGet";CurFile$;"(e$,Chan,Mode$,KeyNo,SearKey$,";CurFile$;".)"
    ;#c[12];"        if RecNo<0 exit do"
    ;#c[12];"        if KeyVal$ if SearKey$[1,len(KeyVal$)]<>KeyVal$ exit do"
    ;#c[12];"        !"
    ;#c[12];"        if row>tmpcnt let tmpcnt=expandarray(e$,List$[])"
    ;#c[12];"        !"
	;#c[12];"        tmpline$=''''"
	;#c[12];"        for fcnt=0 to ubound(Field$[],1)" 
    ;#c[12];"          if Field$[fcnt] = '''' exit for"
	;#c[12];"          tmpfield$=''''"
	call CreateDropFields() ! drop list fields
    ;#c[12];"          !"
	;#c[12];"		   if tmpfield$<>'''' let tmpfield$=RTrim$(tmpfield$) \\ if tmpfield$='''' let tmpfield$='' '' !even if field all spaces, include it"   !081023  was tmpfield$=RTrim$(tmpfield$) !no spaces for next check"
	;#c[12];"          if tmpfield$"
	;#c[12];"           if blockformat"
	;#c[12];"            let tmpline$=tmpline$,rtrim$(tmpfield$),'' ''"
	;#c[12];"           else"
	;#c[12];"            let tmpline$=tmpline$,rtrim$(tmpfield$),fdel$"
	;#c[12];"           end if"
	;#c[12];"          end if"
	;#c[12];"        next fcnt"
    ;#c[12];"        !"
	;#c[12];"        if tmpline$"
    ;#c[12];"          if blockformat=0 List$[row]=SearKey$,fdel$,tmpline$"
	;#c[12];"          if blockformat let list$[row]=tmpline$,fdel$,trim$(searkey$),fdel$,fdel$"
    ;#c[12];"          row=row+1"
	;#c[12];"          !if row > maxcnt+1 exit do !to limit # in drop list"
	;#c[12];"        endif"
    ;#c[12];"        !"
    ;#c[12];"	   loop"
  else
    begrcdno=1 !default
    if dh.userdef1$ = "0" let begrcdno=0  !override to start at rcd 0 (ie  whinfo)
	!old see line above  if dh.filename$="WHINFO" let begrcdno=0 !temporary patch
    ;#c[12];"      for cnt=";str$(begrcdno);" to chf(chan)-1"
    ;#c[12];"        read record #chan,cnt;";CurFile$;".;"
    ;#c[12];"        if row>tmpcnt let tmpcnt=expandarray(E$,List$[])"  
    ;#c[12];"        !"
 	;#c[12];"        tmpline$=''''"
	if requiredvarname$<>""
	;#c[12];"        if rtrim$(";CurFile$;".";requiredvarname$;")<>'''' !indicates active record in non-indexed file"
    ;#c[12];"          for fcnt=0 to ubound(Field$[],1)"
	;#c[12];"           if Field$[fcnt] = '''' exit for"
	;#c[12];"           tmpfield$=''''"
	call CreateDropFields() ! drop list fields
    ;#c[12];"           !"
	;#c[12];"		   if tmpfield$<>'''' let tmpfield$=RTrim$(tmpfield$) \\ if tmpfield$='''' let tmpfield$='' '' !even if field all spaces, include it"   !081023  was tmpfield$=RTrim$(tmpfield$) !no spaces for next check"
    ;#c[12];"          if tmpfield$"
	;#c[12];"           if blockformat"
	;#c[12];"            let tmpline$=tmpline$,rtrim$(tmpfield$),'' ''"
	;#c[12];"           else"
	;#c[12];"            let tmpline$=tmpline$,rtrim$(tmpfield$),fdel$"
	;#c[12];"           end if"
	;#c[12];"          end if"
    ;#c[12];"          next fcnt"
    ;#c[12];"        !"
	;#c[12];"        if tmpline$"
    ;#c[12];"          if blockformat=0 List$[row]=Str$(cnt),fdel$,tmpline$"
	;#c[12];"          if blockformat let list$[row]=tmpline$,fdel$,str$(cnt),fdel$,fdel$"
    ;#c[12];"          row=row+1"
	;#c[12];"        endif"
	;#c[12];"       end if !requiredfieldname <>''''"
	end if
    ;#c[12];"        !"
    ;#c[12];"      next cnt"
  end if
  ;#c[12];"    !"
  ;#c[12];"    if row>tmpcnt let tmpcnt=expandarray(e$,List$[])"
  ;#c[12];"    if blockformat=0 let List$[row]=esdel$ ! end of section delimiter"
  ;#c[12];"    !"
  ;#c[12];"else"
  ;#c[12];"  dim msc4$[100] \\ msc4$=msc$(4)"
  ;#c[12];"  if Pos(msc4$, = ''/'',-1) let msc4$=msc4$[pos(msc4$,=''/'',-1)+1]"
  ;#c[12];"  select case spc(8)"
  ;#c[12];"    case 10000"
  ;#c[12];"      ! this is default ''message'' error"
  ;#c[12];"      ! e$ should be set with message to display"
  ;#c[12];"    case 11000"
  ;#c[12];"      ! search error"
  ;#c[12];"      call env(2,''PROGNAME'',msc4$)"
  ;#c[12];"      call programdump()"
  ;#c[12];"      call searcherr(e$, e, Spc(10),e$)"
  ;#c[12];"    case else"
  if I8$="Y" print #c[12];"      e$=''filedroplist";CurFile$;" mode='',mode,'' keyno='',keyno,'' error='',recno,'' keyval$='',keyval$"
  if I8$<>"Y" print #c[12];"      e$=''error in filedroplist ";CurFile$;"''"
  ;#c[12];"      if spc(8) = 123 let e$='' record locked''"
  ;#c[12];"      if spc(8)<10000 if spc(8)<>123"
  ;#c[12];"        call env(2,''PROGNAME'',msc4$)"
  ;#c[12];"        call programdump()"
  ;#c[12];"        call suberr(e$,Spc(8),Spc(10),Msc$(2))"
  ;#c[12];"      end if"
  ;#c[12];"  end select"
  ;#c[12];"  error 10000"
  ;#c[12];"end try"
  ;#c[12];"end sub ! filedroplist";CurFile$
  ;#c[12];"!"
  ;#c[12];"! ";U$[1,40]
  !
else
  if xport
   if spc(8)<>10000
    call dfsuberr(e$,Spc(8),Spc(10),Msc$(2))
    !call programdump("")
   end if
   error 10000
  else
   ;"error";spc(8);" at line ";spc(10)
   stop
  end if 
end try
End Sub ! createdroplist
!
! ------------------------------------------------
Sub CreateMain()
  ! 
  ! Create main procedure code, if library is chained to will get executed
  ! code to verify record on file
  !
  Try
  !
  ;#c[12];"!"
  ;#c[12];"! **main procedure"
  ;#c[12];"!"
  ;#c[12];"! dim variables used by program"
  ;#c[12];"!"
  ;#c[12];"dim e$[500],buttonlist$[5,50],nextlist$[5,100] !error handling variables"
  ;#c[12];"try"
  ;#c[12];"!"
  ;#c[12];" dim blockid$[8],tmp$[100],id$[100],readonly$[1]"
  ;#c[12];" dim action$[30],options$[30],userid$[8],3%,fdel$[10],rstr$[3000],bsdel$[10],esdel$[10],rdel$[10]"
  ;#c[12];" dim ";CurFile$;". as ";CurFile$
  ;#c[12];" !"
  ;#c[12];" call getglobals(''blockx'',0,blockid$,CTLC,options$,action$,userid$,intCO,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$)"
  ;#c[12];" !open data file"
  ;#c[12];" let readonly$=''R'' !ropen"
  ! ;#c[12];" ropen #chan,";rtrim$(DH.filename$)
  ;#c[12];" chan = OpenFile(''";CurFile$;"'',intCo*-1,readonly$)" !custom
  ;#c[12];" if chan < 0 error 10000"
  ;#c[12];" !"
  ;#c[12];" call dxget(''ID'',id$)  !record # or key"
  ;#c[12];" !"
  ;#c[12];" if action$=''VERIFY''"
  !need to use key 1
  ;#c[12];"  ";holddir1$;"=id$"
  ;#c[12];"  id$=";dir1$
  ;#c[12];"  r = fileget";CurFile$;"(e$,chan,''='',1,ID$,";CurFile$;".)"
  ;#c[12];"  if r < 0 "
 ! ;#c[12];"   let e$=''msg";CurFile$;"NOF''"
  ;#c[12];"   let e$=''msg Record Not on File''"
  ;#c[12];"   error 10000 !not on file return error"
  ;#c[12];"  end if"
  ;#c[12];"  tmp$=''ID'',fdel$,''Desc'',fdel$,rdel$  !always going to return ID (key) and first droplist field"
  ;#c[12];"  tmp$=tmp$,rtrim$(id$),fdel$"
  if requiredvarname$<>""  !(1st required fieldname, determined in createdropheader
   ;#c[12];"  tmp$=tmp$,rtrim$(";CurFile$;".";requiredvarname$;")"
  end if
  ;#c[12];"  tmp$=tmp$,fdel$,rdel$"     
  ;#c[12];"  call addtostr(e$,rstr$,tmp$)  !return formatted key and first required field"
  ;#c[12];" end if"
  ;#c[12];" !"
  ;#c[12];" Call addtostr(e$,rstr$,esdel$) !end section"
  ;#c[12];" !!!!!!print rstr$"
  ;#c[12];" Call setoutput(e$,rstr$,1,e$) !1 flag puts 0 status section in, puts </page> in, e$ is message"
  ;#c[12];"else"
  ;#c[12];" ! error routine"
  ;#c[12];"  dim msc4$[100] \\ msc4$=msc$(4)"
  ;#c[12];"  if Pos(msc4$, = ''/'',-1) let msc4$=msc4$[pos(msc4$,=''/'',-1)+1]"
  ;#c[12];"  select case spc(8)"
  ;#c[12];"    case 10000"
  ;#c[12];"      ! this is default ''message'' error"
  ;#c[12];"      ! e$ should be set with message to display"
  ;#c[12];"    case 11000"
  ;#c[12];"      ! search error"
  ;#c[12];"      call env(2,''PROGNAME'',msc4$)"
  ;#c[12];"      call programdump()"
  ;#c[12];"      call searcherr(e$, e, Spc(10),e$)"
  ;#c[12];"    case else"
  ;#c[12];"      if spc(8) <> 10000"
  ;#c[12];"        call env(2,''PROGNAME'',msc4$)"
  ;#c[12];"        call programdump()"
  ;#c[12];"        call suberr(e$,Spc(8),Spc(10),Msc$(2))"
  ;#c[12];"      end if"
  ;#c[12];"  end select"
  ;#c[12];"  call mainerr(e$,spc(8),buttonlist$[],nextlist$[],rstr$)"
  ;#c[12];"end try"
  ;#c[12];"end"
  !
else
  if xport
   if spc(8)<>10000
    call dfsuberr(e$,Spc(8),Spc(10),Msc$(2))
    !call programdump("")
   end if
   error 10000
  else
   ;"error";spc(8);" at line ";spc(10)
   stop
  end if 
end try
End Sub ! createmain
!
! ------------------------------------------------
Sub CreateDropHeading(...)
  ! 
  ! Create drop list heading and fields, if field$ isn't passed
  !
  Try
    Try Enter JustCount else let JustCount=0
    !
	! create .net heading line
	!
    requiredvarname$=""
	tmp$="''ID'',fdel$"
	fieldcnt=0
	FieldKey$=DH.FileName$
    FieldRec=-2
    search >= #c[1],1;FieldKey$
    do
      try read record #c[1],FieldRec;DF. else exit do
      if DF.FileName$<>DH.FileName$ exit do
	  if lcase$(DF.DropList$)="y"
		tmp1$=DF.VarName$ \ if tmp1$[len(tmp1$)]="$" let tmp1$=tmp1$[1,len(tmp1$)-1]
		tmp$=tmp$,",''",tmp1$,"'',fdel$"
		fieldcnt=fieldcnt+1 ! number of fields
      endif
      !
      FieldRec=-1 ! next field defs record
    loop
	if JustCount exit sub
    ;#c[12];"      tmpline$=";tmp$ ! .net heading line
	;#c[12];"      !"
	!
	! create field$ names
	!
	if fieldcnt>0
	  dim Field$[fieldcnt] ! # of fields for drop list
	  fieldcnt=0
	  FieldKey$=DH.FileName$
      FieldRec=-2
      search >= #c[1],1;FieldKey$
      do
        try read record #c[1],FieldRec;DF. else exit do
        if DF.FileName$<>DH.FileName$ exit do
	    if lcase$(DF.DropList$)="y"
		  if lcase$(DF.required$)="y" if requiredvarname$="" let requiredvarname$=DF.VarName$
	      ;#c[12];"      Field$[";str$(fieldcnt);"]=''";DF.VarName$;"''"
		  fieldcnt=fieldcnt+1 ! number of fields
        endif
        !
        FieldRec=-1 ! next field defs record
	  loop
    endif
    !
  else
   if xport
   if spc(8)<>10000
    call dfsuberr(e$,Spc(8),Spc(10),Msc$(2))
    !call programdump("")
   end if
   error 10000
  else
   ;"error";spc(8);" at line ";spc(10)
   stop
  end if 
  end try
end sub ! createdropheading
!
! ------------------------------------------------
Sub CreateDropFields()
  Try
    !
    FieldKey$=DH.FileName$
    FieldRec=-2
    search >= #c[1],1;FieldKey$
    do
      try read record #c[1],FieldRec;DF. else exit do
      if DF.FileName$<>DH.FileName$ exit do
	  if lcase$(DF.DropList$)="y"
	    if I8$<>"Y" print #c[12];"  ";
		;#c[12];"          if Field$[fcnt]=''";DF.VarName$;"'' let ";
	    if DF.Precision>0 ! alpha
		  ;#c[12];"tmpfield$=";CurFile$;".";DF.VarName$;",'' ''" ! line continued
        else
		  ;#c[12];"tmpfield$=str$(";CurFile$;".";DF.VarName$;")" ! line continued
		endif
      endif
      !
      FieldRec=-1 ! next field defs record
    loop
  else
   if xport
   if spc(8)<>10000
    call dfsuberr(e$,Spc(8),Spc(10),Msc$(2))
    !call programdump("")
   end if
   error 10000
  else
   ;"error";spc(8);" at line ";spc(10)
   stop
  end if 
  end try
End Sub ! createdropfields
