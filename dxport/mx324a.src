! >>> Program mx324a
!
! description Miscellaneous Receipts Accept 
! loadsave -w -n 100,10 -o prog/dxport/mx324a.dl4 src/mx324a.src
!
! 1.0 mm/dd/yyyy change??
!
include "src/copyright.inc"
include "src/inc/filecosthist.inc"
Rem  MX324a   STOCK RECEIPTS Journal Part 2 - ACCEPT
Rem           *** REPLACES MX325 ***
Rem  LAST UPDATE: G.DOSCHER  7/21/80
Rem BEDIT Version: 2.2 OBJECT CODE     Created: OCT 30, 2008  13:45:08
Rem /w2/papermaster/r2005//usr/acct/jcs/work/custom/xrev9/mx324a.src (univ2) [jcs] {50712}
Rem  Copyright (c) 2008 Universal Business Systems, Inc.
Rem    **** ALL CHANGES MUST BE MADE IN SOURCE!!! ****
Rem

Declare Intrinsic Sub DateToJulian,FindF,InpBuf,String,Time,VerifyDate

Declare Intrinsic Sub getglobals
Declare Intrinsic sub programdump,env
Declare Intrinsic function findchannel
! external libs for subs/functions
External Lib "libgeneral.lib"
Declare External Sub suberr,mainerr,GetSession,AddToStr,SetOutput,CreateNetStatus
External Lib "ubsfunc.dl4"
Declare External Function OpenFile,OpenMySQLMirror
Include "src/inc/fileinvtrans.inc"
External Lib "invttrans.dl4"
Declare External Sub Maketrans
External Lib "libprodwh.lib"    
Declare External Sub mxwhcreate 
External Lib "libprod.lib"
Declare External Sub mkcosthist
include "src/inc/sql_prod.inc"

Try
Enter sprec,whse,jrnl,eflg,rec_uac,message$,IntCo,rstr$,e$
dim action$[30],options$[30],userid$[8],3%,fdel$[10],bsdel$[10],esdel$[10],rdel$[10]
!dim rstr$[5000]
dim 1%,PFU1[20],CNVTU[2],3%,PFU2[6],CNVTA,A[33]

!dim 3%,SPREC,rec_uac
!dim 2%,WHSE,JRNL
!dim 1%,IntCo,eflg
!dim e$[500] ! ,Message$[600]
! If Err 0 Gosub ERR_TRAP
Def FNP(H) = Sgn(H) * (Int(Abs(H) * 100000 + .5) * .00001)
Def FNR(H) = Sgn(H) * (Int(Abs(H) * 100 + .5) * .01)
Dim 1%,MODE,FL1[2],FL1$[80],2%,FL2[3],3%,FL3[14],FL4[1]
Dim 1%,FT1[3],FT1$[72],2%,FT2[3],3%,FT3[3]
Dim 3%,GLDETLAVAIL
Dim P61$[256],FSKEY$[30],3%,FC2[1]
Dim 2%,WHBLD[2],FIFL,P60$[50],FLT$[50],3%,FQ9[2],FQTY,FLK$[50],R[23]
Dim 2%,D3[1],JARDATE,SCRATCH$[80]
Dim 3%,MRTS0[5],MRTS4[2]
Dim MRTS0$[34],MRTS1$[22],MRTS2$[18],MRTS3$[12],1%,MRTS2[3],2%,MRTS3[4]
Dim 3%,DISP_EXT,DISP_COST,DISP_QTY
Dim 3%,BUNITCOST,DISP_QTY1,COSTUM,OLDAVGCOST,OLDLASTCOST
Dim 3%,LBSUNIT,LBSFACTOR,FLBSUNIT,FLBSFACTOR,PRODLBS,PRODFACT
Dim 1%,FIFOSPECCH[10],FIFOSPEC1[10],FIFOSPEC$[150],2%,FIFOSPEC2[10],3%,FIFOSPEC3[16]
Dim LOT$[12],STKLOC$[6],Blank$[100]
Dim 1%,D,E,I,K,K3,L5[3],P2[1],S,P5,W1[2],W0[3],WH8[47],CH_INVTR
Dim 1%,CH_GLARCNTRL,CH_GLTEMP,CFLAG,C0[3],WPF[1023],FChan[5]
Dim 2%,B[24],C,ARDATE,P3[2],R1[2],R4,R6,T,W2[9],WH7[3],W7[14],C4[8],X2,COID
Dim 2%,GTEMP1[3],CLIENT,CL[2]
Dim 3%,A[33],L7[5],P4[4],Q1[1],W3[24],W5[25],WH9[23],A1[7],INVBAL,P1$[6]
Dim 3%,RECDATE,UNITGLCOST,FCOST[1],GLCOST[1],REC_GLARCNTRL
Dim 3%,QTY,UCOST,COST,PRPARC[3],WHLBS[1]
Dim 3%,REC_GLTEMP,GTEMP0[2],RSN[99],REC_PROD
Dim GLTKEY$[50],K20$[50],P8$[7],CMD$[50],KEYMRTS1$[30],KEYMRTS2$[30],PRODKEY$[12]
Dim FRPROD$[12],TOPROD$[12]
Dim L1$[56],L2$[60],A$[156],P2$[66],R6$[50],DATE$[20]
Dim P9$[50],S$[15],X$[10],K6$[50],W1$[32],W2$[16],2%
Dim 2%,LTL0$[6],BLK$[10],WHPROD$[12],R0
Dim SNK$[50],SNK1$[50],SNKE$[50],SNKE1$[50],SN1$[54],SN$[224]
Dim 1%,SN0[2],SN1[2],3%,SN3[6],2%,OSN,SN2[9],R7,R8
Dim 1%,ACCEPTED,CH_FIFOS,3%
Dim 2%,WHOS
Dim 3%,FTRECA,FTRECB,LETTER$[1],REC_FIFOS
Dim 3%,CUNIT,CUNIT$[4],CQTY,CCOST,CCQTY,EQTY
Rem dim glmrdetl variables
Dim 2%,GLD[4],GLD1$[40],GLD$[12],GLD0$[12],1%,GLD0[1],3%,GLD1[5],4%,GLD2
Dim 3%,REC_GLD,GLDKEY1$[40],GLDKEY2$[40]
Dim 2%,POSTDATE,POSTPER
Rem {begin src/inc/dim.glarcntrl.i}
Dim 1%,GLC[2]
Dim 2%,GLC0
Dim 3%,GLC1[10],GLC2[20],GLC3[20],GLC4[20],GLC5[20],GLC6[20],GLC7[20]
Dim 3%,GLC8[20],GLC9[20],GLC10[20],GLC11[20],GLC12[20],GLC13[20],GLC14[20]
Rem {end dim.glarcntrl.i}
Dim 3%
Dim DEV$[20],HM$[30],nextblockid$[8],WebStr$[600]
Dim buttonlist$[5,50],nextlist$[5,100] ! dx error handling variables
Dim tmp$[800],tmp1$[200],blockid$[100],msg$[100]

!Call getglobals("blockx",0,blockid$,CTLC,options$,action$,userid$,intCO,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$)
! Call getsession(e$,CTLC,options$,action$,userid$,intCO,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$)
Dim PCH. as costhist
dim ITR. as invtrans
call "proglock.dl4","324A",1,msg$
for x=1 to 89
	try close #x else rem
next x
Blank$=" ",Blank$
!X2 = Spc(5)
!COID = Int((X2 - Int(X2 / 16384) * 16384) / 64)
coid=intco
S$ = COID Using "cntrl/CNTRL#"
OPEN #1,S$
Mat Read #1,19,50;P9$;
Mat Read #1,60,50;P60$;
Mat Read #1,61,0;P61$;
Mat Read #1,3,192;FIFL;
Mat Read #1,52,60;P8$;
Mat Read #1,52,0;CL;
S$ = "6/MISCRTS" + Str$(COID) \ Open #2,S$
S$ = "2/RSNRTS" + Str$(COID) \ Ropen #10,S$
For I = 2 To 8
  Read T \ If T = -1 Goto L_850
  Read #1,88,T;S$;
  Open #I,S$
L_850: Next I
Data "-1","1792","2528","2512","1744","2976","416"
Rem#2=miscrts #3=SPROD #4=SPRODLOT #5=LOTTRANS #6=PRODWHSE #10=rsnrts
Rem#19=fifolot #20=fifotrans #22=glmrstemp #23=glarcntrl #26=whinfo
Rem#29-mrswork, #30-fifospc
Read #1,88,2768;S$; \ open #26,S$
If P60$[9,9] = "F" Or P60$[9,9] = "L"
  For I = 19 To 20
    Read T \ If T = -1 Goto L_890
    Mat Read #1,88,T;S$;
    Open #I,S$
L_890: Next I
  Data "3008","3024"
  If P61$[60,60] = "Y"
    S$ = "4/fifospc" + Str$(COID) \ Ropen #30,S$
    CH_FIFOS = 30
  End If 
End If 
If Not(SPREC) ! not from pronto accept
  If P9$[17,17] = "Y"
    CH_GLARCNTRL = 23
    Read #1,88,464;S$; \ Ropen #23,S$
    CH_GLTEMP = 22
    S$ = COID Using "6/GLMRSTEMP#" \ Open #22,S$
    Mat Read #1,51,0;C0;
    CFLAG = 0
    If C0[3] And P8$[7,7] = "W" Let CLFLAG = 99
    S$ = COID Using "4/GLMRDETL#"
    Call FindF(S$,GLDETLAVAIL)
    If GLDETLAVAIL
      Open #55,S$
    End If 
    CH_CCODE = 54
    Read #1,88,1728;S$; \ Ropen #54,S$
  End If 
  CMD$ = " ",CMD$
  S$ = rec_uac Using "files/6/MRSWERP&&&&"
  CMD$ = "[1:1] ",S$,"!"
  Build #29,CMD$
  CH_MRSW = 29
  REC_MRTS = 5
  Search #CH_MRSW,0,1;KEYMRTS1$,REC_MRTS,E \ If E Gosub ERR_SEARCH
  REC_MRTS = 1
  Search #CH_MRSW,0,0;KEYMRTS1$,REC_MRTS,E \ If E Gosub ERR_SEARCH
  Try Close #29 Else Rem
  Open #29,S$
End If
sqlChan = OpenMySQLMirror(e$)
L_900: Rem "====================================== init vars
BLK$ = " ",BLK$
Read #1,20;S;
Read #1,3,172;ARDATE;
X2 = ARDATE \ Gosub L_7820 \ X2 = 0
If X2 Let JARDATE = X2 Else Gosub L_7650
Read #1,0,108;POSTDATE;
X$ = POSTDATE Using "&&&&&&"
POSTPER = X$[1,4]
If S <> 4 And Not(SPREC)
  !If S = 0 Print @0,22;"NO STOCK RECEIPTS TO ACCEPT"
  !If S > 0 If S < 4 Print @0,22;"JOURNAL HAS NOT BEEN RUN"
  !Print 'RB';
  !Signal 3,30
  let eflg=eflg+1
  if not (s) 
	let message$=message$+str$(eflg)+" No Stock Receipts To Accept. "
  else
	let message$=message$+str$(eflg)+" Journal Had Not Been Run. "
  endif
  Goto OUTEND
End If 
Read #1,19,50;P9$;
If SPREC
  REC_MRTS = SPREC
  Gosub PROCESSREC
  Goto OUTEND
End If 
! Print @0,23;'CL';"Accepting Miscellaneous Receipt to Stock Entries.  Please Wait.";
KEYMRTS1$ = " ",KEYMRTS1$
SRCHMRTS: Rem start search of misc receipts file
Search #2,3,1;KEYMRTS1$,REC_MRTS,E \ If E = 2 Goto L_8900
If E Gosub ERR_SEARCH
Gosub PROCESSREC
If WHSE
  If WHSE <> MRTS2[2] Goto SRCHMRTS
End If 
If MRTS2[3] <> 2 Goto SRCHMRTS
If MRTS3[0] = -3
  If P61$[73,73] = "Y"
    REC_PROD = MRTS0[1]
    Gosub L_3800
    If A$[127,127] = "Y" And MRTS4[1] <> 0 Goto GLUPDATESECTION
  End If 
Else 
  If MRTS0[0] Goto GLUPDATESECTION
End If 
Gosub ADDMRSWORK
Goto SRCHMRTS
GLUPDATESECTION: Rem check for g/l
If P9$[17,17] = "Y"
  Rem!!! converted to get unit of measure
  REC_PROD = MRTS0[1]
  Gosub L_3800
  If MRTS0[0]
    CNVTU[0] = 0;CNVTU[1] = MRTS3[0];CNVTU[2] = 1
    CNVTA = MRTS0[0]
    Gosub L_20000
    CQTY = AMOUNT
    If MRTS3[0] = -3 Let CQTY = 0
  End If 
  CCOST = 0
  If MRTS0[3]
    CNVTU[0] = 0;CNVTU[1] = MRTS3[1];CNVTU[2] = 2
    CNVTA = MRTS0[3]
    Gosub L_20000
    CCOST = AMOUNT
  End If 
  CCQTY = 0
  If MRTS2[0] = 99 ! reason code #99
    If MRTS4[0]
      PRODKEY$ = " ",PRODKEY$;PRODKEY$[1,12] = MRTS3$[1,12]
      Search #3,2,1;PRODKEY$,REC_PROD,E \ If E Gosub ERR_SEARCH
      If Not(E)
        Gosub L_3800
        CNVTU[0] = 0;CNVTU[1] = MRTS3[3];CNVTU[2] = 1
        CNVTA = MRTS4[0]
        Gosub L_20000
        CCQTY = AMOUNT
      End If 
    End If 
  End If 
  REC_PROD = MRTS0[1]
  Gosub L_3800
  If MRTS2[1] ! already accepted
    GLCOST[0] = MRTS0[4]
    GLCOST[1] = MRTS4[2]
  End If 
  Gosub GETGLARCNTRL
  CLIENT = 0
  If CFLAG
    If (MRTS2[2] - 1) >= 0
      Mat Read #26,(MRTS2[2] - 1),844;CLIENT;
    End If 
  End If 
  If Not(CLIENT) Let CLIENT = CL[0]
  Gosub GETGLINVENT
  If MRTS2[0] <> 99
    Gosub GETGLREASON
  Else 
    PRODKEY$ = " ",PRODKEY$;PRODKEY$[1,12] = MRTS3$[1,12]
    Search #3,2,1;PRODKEY$,REC_PROD,E \ If E Gosub ERR_SEARCH
    If Not(E)
      Gosub L_3800
      GLCOST[0] = - (MRTS0[4])
      GLCOST[1] = - (MRTS4[2])
      Gosub GETGLINVENT
    End If 
  End If 
End If 
Gosub ADDMRSWORK
Goto SRCHMRTS
PROCESSREC: Rem process record info here
Mat Read #2,REC_MRTS,0;MRTS0;
Mat Read #2,REC_MRTS,36;MRTS0$;
Mat Read #2,REC_MRTS,70;MRTS1$;
Mat Read #2,REC_MRTS,104;MRTS2;
Mat Read #2,REC_MRTS,112;MRTS3;
Mat Read #2,REC_MRTS,132;MRTS2$;
Mat Read #2,REC_MRTS,150;MRTS3$;
Mat Read #2,REC_MRTS,174;MRTS4;
If Not(SPREC)
  If WHSE
    If WHSE <> MRTS2[2] Return 
  End If 
  If MRTS2[3] <> 2 Return 
End If 
If Not(MRTS0[0]) Return 
Mat Read #2,REC_MRTS,0;MRTS0
If MRTS2[1] Return 
REC_PROD = MRTS0[1]
Gosub L_3800
LBSFACTOR = A[5]
LBSUNIT = A[6]
If A$[127,127] = "Y"
  If Abs(MRTS0[0]) > 0 And Abs(MRTS4[1] > 0) And Sgn(MRTS0[0]) = Sgn(MRTS4[1])
    LBSUNIT = Abs(MRTS4[1] / MRTS0[0] * LBSFACTOR)
  End If 
End If 
FRPROD$ = " ",FRPROD$;TOPROD$ = " ",TOPROD$
If MRTS2[0] = 99
  FRPROD$ = A$[140,151]
  TOPROD$ = MRTS3$[1,12]
End If 
If MRTS0[3] <= 0 Goto L_2150
If MRTS0[0] <= 0 Goto L_2150
If MRTS3[0] = -3 Goto L_2150
BUNITCOST = MRTS0[3]
If A$[127,127] = "Y" And MRTS0[0] > 0 And MRTS0[3] > 0 And MRTS4[1] > 0
  DISP_QTY = MRTS0[0];DISP_COST = MRTS0[3]
  Gosub CALC_DISP_EXT
  BUNITCOST = DISP_EXT / MRTS0[0]
End If 
If P60$[21,21] <> "N" Let B[10] = MRTS0[3]
If A[0] <= 0 Let B[21] = BUNITCOST \ If A[0] <= 0 Goto L_2150
If (A[0] + MRTS0[0]) <= 0 Let B[21] = BUNITCOST \ Goto L_2150
If (A[0] * B[21]) <= 0 Let B[21] = BUNITCOST \ Goto L_2150
B[21] = FNP(((B[21] * A[0]) + (MRTS0[0] * BUNITCOST)) / (A[0] + MRTS0[0]))
L_2150: If MRTS3[0] <> -3 Let A[0] = A[0] + MRTS0[0]
If MRTS3[0] = -3 Or A$[127,127] = "Y"
  PRPARC[3] = PRPARC[3] + MRTS4[1]
End If 
Gosub L_3850
QTY = MRTS0[0];COST = BUNITCOST
LOT$ = MRTS0$[1,12];STKLOC$ = MRTS0$[13,18]
Gosub L_5000
If MRTS3[0] = -3 And A$[127,127] = "Y" And P61$[73,73] <> "Y" Goto UPDONE
Gosub L_4500
Gosub L_6000
If P9$[17,17] = "Y"
  Gosub GETGLCOST
  MRTS0[4] = GLCOST[0]
  MRTS4[2] = GLCOST[1]
  If MRTS0[0] < 0
    MRTS0[4] = - (Abs(GLCOST[0]))
    MRTS4[2] = - (Abs(GLCOST[1]))
  End If 
  MRTS3[2] = ARDATE
  MRTS3[4] = JRNL
  Mat Write #2,REC_MRTS,0;MRTS0
  Mat Write #2,REC_MRTS,112;MRTS3
  Mat Write #2,REC_MRTS,174;MRTS4;
End If 
If A$[127,127] = "Y" And MRTS3[0] = -3 Goto UPDONE
Gosub L_3000
UPDONE: Rem " If Catch wgt and U/M=-3 Only adjusting LBS - NO QTY/Cost/etc
MRTS2[1] = 99 \ Write #2,REC_MRTS,106;MRTS2[1];
STARTREASON99: Rem start reason code 99
If MRTS2[0] = 99
  PRODKEY$ = PRODKEY$," ",PRODKEY$
  PRODKEY$[1,12] = MRTS3$[1,12]
  Search #3,2,1;PRODKEY$,REC_PROD,E \ If E > 1 Gosub ERR_SEARCH
  If Not(E)
    Gosub L_3800
    UCOST = Abs(GLCOST[0] / MRTS4)
    If UCOST
      If P60$[21,21] <> "N" Let B[10] = UCOST
      If A[0] <= 0
        B[21] = UCOST
      Else 
        If (A[0] + MRTS4) <= 0
          B[21] = UCOST
        Else 
          If (A[0] * B[21]) <= 0
            B[21] = UCOST
          Else 
            B[21] = FNP(((B[21] * A[0]) + (MRTS4 * UCOST)) / (A[0] + MRTS4))
          End If 
        End If 
      End If 
    End If 
    A[0] = A[0] + MRTS4
    Gosub L_3850
    QTY = MRTS4;COST = UCOST
    LOT$ = MRTS2$[1,12];STKLOC$ = MRTS2$[13,18]
    Gosub L_5000
    Gosub L_4500
    Gosub L_6000
  End If 
  Gosub L_3000
End If !!! process 99
Return 
L_3000: Rem "=================================== update lots
If A$[127,127] = "Y" And MRTS3[0] = -3 Return 
If P9$[1,1] = "N" Gosub L_4300 \ Goto L_3060
If P9$[1,1] = "Y" Goto L_3060
If A$[113,113] = "N" Gosub L_4300 \ Goto L_3060
LOTCNT = 1
L_3060: Gosub L_3090
Gosub L_3930
Return 
L_3090: Rem "============================ insert to lot file
if p9$[9,9]<>"Y" goto L_3260: ! no lot control any way
L1$ = " ",L1$
clear itr.
itr.ProdCode$ =	 A$[140,151] ! product code L1$[1,12] =
itr.LotNum$ = lot$[1,12] ! L1$[13,Len(LOT$) + 12] = LOT$[1,12]
itr.SrcCode$= "MISC RTS     "  ! L1$[25,36] = "MISC RTS     " 
itr.Comment$[1,16]=MRTS0$[19,34]  !L1$[37,52] = MRTS0$[19,34] 
itr.comment$[17,17]="/"
itr.comment$[18,20]=MRTS2[0] Using "###" ! L1$[53,53] = "/";L1$[54,56] = MRTS2[0] Using "###"
if qty<=0
	itr.TrnsType=30
else
	itr.TrnsType=7
endif
itr.Whse = MRTS2[2] ! L5[1] =  L1[1]                                       
itr.EntBy = rec_uac ! Spc(6) !!!! mtg lt1[2]
itr.Tiebrkr = 0                    
itr.TrnsDate  = 0 ! Julian Date is assigned during maketrans                      
itr.RunInvt  =INVBAL  !L7[1] = INVBAL  
itr.Qty=Abs(QTY) ! L7[2] = Abs(QTY)
itr.CostLoad=MRTS0[3] ! L7[3] = MRTS0[3]
If MRTS3[1] = -3 And MRTS0[0] > 0 And MRTS4[1] > 0 And MRTS0[3] > 0
  itr.CostLoad=  BUNITCOST ! L7[3] = BUNITCOST
End If 
! L7[4] = B[21] \ If P9$[32,32] = "Y" If W3[15] Let L7[4] = W3[15]
 itr.CostAvg  = B[21]                  
 If P9$[32,32] = "Y" And W3[15]<>0
	Let itr.CostAvg = W3[15]
 endif
CH_INVTR = 5 ! L5[2] = Spc(6);L5[3] = 0;L7[5] = 0;
itr.NetPrice =0   
If P9$[17,17] = "Y"
  itr.NetPrice =(Sgn(QTY) * (Abs(MRTS0[4]))) ! L7[5] = (Sgn(QTY) * (Abs(MRTS0[4])))
End If 
P1$[1,6] = STKLOC$[1,6]

itr.Loc$ = STKLOC$[1,6] ! LTL0$ = " ",LTL0$ \ LTL0$[1,6] = STKLOC$[1,6]
If SPREC
	itr.EntBy = -(rec_uac) 
	itr.ProntoAcpt =99 
        !Let L5[2] = - L5[2]
endif
Gosub L_3260
Return 
L_3260: Rem "======================================== write to lottrans
If P9$[9,9] <> "Y" Goto L_3460
Call MakeTrans(e$,IntCo,CH_INVTR,status,itr.) !  as invtrans)
! Call "MAKETRANS",L1$,L5[],L7[],LTL0$,CH_INVTR
L_3460: Rem "============================= write into sprodlot
P2$ = " ",P2$
P2$[1,12] = itr.ProdCode$  ! product code L1$[1,12] =L1$[1,12]
P2$[13,14] = itr.Whse  Using "##"
P2$[15,20] = STKLOC$[1,6]
P2$[21,32] = itr.LotNum$ ! L1$[13,Len(LOT$) + 12] = LOT$[1,12]!L1$[13,24]
P2 = itr.Whse !L5[1] \
P2[1] = 1
If itr.TrnsDate !"          julian date assign in maketrans
  X2 = itr.TrnsDate \ Gosub L_7840 \ X2 = D3[0]
  RECDATE = X2
End If 
If P9$[9,9] <> "Y" !"      skip the maketrans - L7 not assign
  DATE$ = Tim(8) Using "&&",Tim(9) Using "&&",Tim(10) Using "&&"
  RECDATE = DATE$
End If 
P3 = RECDATE \ P3[1] = 0
P4[0] = itr.QTY \ P4[1] = 0 \ P4[2] = itr.CostLoad \ P4[3] = 0
P4[4] = 0
If itr.TrnsType >= 15 Let P4[0] = 0 \ P4[1] = itr.QTY
Search #4,2,2;P2$,R4,E \ If E > 1 Gosub ERR_SEARCH
If Not(E) Goto L_4350
E = 2 \ Search #4,1,0;L2$,R4,E \ If E Gosub ERR_SEARCH
L2$[1,12] = LOT$[1,12] \ L2$[13,22] = BLK$[1,10] \ L2$[23,30] = P2$[13,20] \ L2$[31,42] = itr.Prodcode$ ! L1$[1,12]
Search #4,4,1;L2$,R4,E \ If E Gosub ERR_SEARCH
Search #4,4,2;P2$,R4,E \ If E Gosub ERR_SEARCH
L2$[1,12] = itr.prodcode$ \ L2$[13,20] = P2$[23,30]
L2$[1,8] = P2$[13,20] \ L2$[9,20] = itr.prodcode$ \ L2$[21,32] = itr.LotNum$ ! LOT$[1,12]
L2$[33,42] = BLK$[1,10]
Search #4,4,3;L2$,R4,E \ If E Gosub ERR_SEARCH
L2$ = " ",L2$ \ L2$[1,12] = itr.prodcode$ \ L2$[13,14] = P2$[13,14] \ L2$[15,26] = itr.LotNum$ ! LOT$[1,12]
L2$[37,52] = P2$[15,20]
Search #4,4,4;L2$,R4,E \ If E Gosub ERR_SEARCH
P2$[13,24] = itr.LotNum$ ! LOT$[1,12]
P2$[55,64] = BLK$[1,10]
Mat Write #4,R4;P2$
L_3765: Mat Write #4,R4,66;P2
Mat Write #4,R4,70;P3
Mat Write #4,R4,82;P4
P5 = 0 \ Write #4,R4,112;P5
Write #4,R4,114;STKLOC$[1,6];
Return 
L_3800: Rem "================================= read product file
Mat Read #3,REC_PROD;A$
Mat Read #3,REC_PROD,156;B
Mat Read #3,REC_PROD,256;A
Mat Read #3,REC_PROD,460;A1
Mat Read #3,REC_PROD,512;PFU1
Mat Read #3,REC_PROD,554;PFU2
Mat Read #3,REC_PROD,596;PRPARC
Mat Read #3,REC_PROD,894;C4
PRODLBS = A[6];PRODFACT = A[5]
oldavgcost=b[21]
oldlastcost=b[10]
Return 
L_3850: Rem "================================= write product file
A[6] = PRODLBS;A[5] = PRODFACT
Mat Write #3,REC_PROD,156;B
Mat Write #3,REC_PROD,256;A
Mat Write #3,REC_PROD,596;PRPARC;
if sqlChan >= 0 ! MySQL enabled and channel opened
	e = prod_UpdateSQLFromDL4(e$, intCo, A$[140,151], sqlChan, 3)
	if e <> 1 ! returns the number of records add/updated/deleted
		gosub ERR_SEARCH
	end if
end if
pch.whse=0
if oldavgcost<>b[21]                     
	pch.CType=6                              
	pch.OldCost=OLDAVGCOST                     
	pch.NewCost=B[21]                          
	GOSUB update_cost_hist: ! cost hist log  
ENDIF                      
if oldlastcost<>b[10]                          
	pch.Ctype=3                                    
	pch.OldCost=OLDLASTCOST                          
	pch.NewCost=B[10]                                
	GOSUB update_cost_hist: ! cost hist log        
ENDIF                   
Return 
L_3930: Rem "========================= clear vars
For K = 0 To 4
  If K <= 3 Let L5[K] = 0
  L7[K] = 0
Next K
K = 0
Return 
L_4300: Rem "========================== set up stock lot (no lot control)
LOT$[1,7] = MRTS2[2] Using "STOCK&&"
LOTCNT = 0
Return 
L_4350: Rem "========================== lot exists! add the two together
Mat Read #4,R4,66;P2
Mat Read #4,R4,70;P3
Mat Read #4,R4,82;P4
P3[2] = P3[2] + 1
P2 = itr.Whse !L5[1]
If itr.TrnsType >= 15 Let P3[1] = RECDATE
If itr.TrnsType < 15 And (Not(P2[0]) Or P3[0] - P3[1] = 0) Let P3[0] = RECDATE
Q1 = 0 \ Q1 = (P4[0] - P4[1]) * P4[2]
If Q1 < 0 Let Q1 = 0
Q1[1] = Q1 + (MRTS0[0] * MRTS0[3])
Q1 = 0 \ Q1 = (P4[0] - P4[1]) + itr.QTY \ If Q1 < 0 Let Q1 = MRTS0[0]
If MRTS0[3] <= 0 Goto L_4470
P4[2] = MRTS0[3]
If Q1 <= 0 Goto L_4470
P4[2] = FNP(Q1[1] / Q1)
L_4470: If itr.TrnsType< 15 Let P4 = P4 + itr.QTY
If itr.TrnsType >= 15 Let P4[1] = P4[1] + itr.QTY
Goto L_3765
L_4500: Rem "=================================== serial numbers
If A$[127,127] = "Y" And MRTS3[0] = -3 Return 
If A$[8,8] <> "Y" Return ! not a serial number
SNKE1$ = " ",SNKE1$;SNKE1$[1,9] = MRTS0[5] Using "R########"
L_4520: Search #7,3,1;SNKE1$,R7,E \ If E > 2 Gosub ERR_SEARCH
If E Goto L_4990
PO = SNKE1$[2,9] \ If SNKE1$[1,1] <> "R" Goto L_4990
If PO <> MRTS0[5] Goto L_4990
Mat Read #7,R7,0;SN1$;
Read #7,R7,54;OSN;
Mat Read #7,R7,58;SN0;
If QTY = 0 Goto L_4955
If A$[8,8] <> "Y" Goto L_4955
If Not(LOTCNT) Let SN1$[13,24] = "STOCK        "
If SN1$[13,17] = "STOCK" Let SN1$[13,24] = SN0[1] Using "STOCK&&      "
If SN0[2] = -1 Goto L_4900
SN$ = " ",SN$;SN$[1,24] = SN1$[1,24];SN$[35,64] = SN1$[25,54]
SN$[85,144] = A$[9,38],A$[63,92]
SN1[0] = MRTS2[2];SN1[1] = PFU1[0];SN1[2] = 0
SN2[0] = MRTS0[5];SN2[1] = ARDATE;SN2[2] = 0;SN3[0] = MRTS0[3]
Read #3,MRTS0[1],632;SN$[65,84];
Read #3,MRTS0[1],652;SN2[9];
SNK$ = " ",SNK$;SNK$[1,30] = SN$[35,64]
SNK1$ = " ",SNK1$;SNK1$[1,24] = SN$[1,24]
E = 2;R8 = 0
Search #8,1,0;SNK$,R8,E \ If E Gosub ERR_SEARCH
SNK$[31] = R8 Using "##########";SNK1$[25] = SNK$[31];SN$[25,34] = SNK$[31,40]
Search #8,4,1;SNK$,R8,E \ If E Gosub ERR_SEARCH
Search #8,4,2;SNK1$,R8,E \ If E Gosub ERR_SEARCH
Mat Write #8,R8,0;SN$;
Mat Write #8,R8,290;SN1;
Mat Write #8,R8,298;SN2;
Mat Write #8,R8,342;SN3;
Goto L_4955
L_4900: Rem Q SAYS DELETE
R8 = OSN \ If R8 <= 0 Goto L_4955
Mat Read #8,R8,0;SN$;
SNK$ = " ",SNK$;SNK$[1,30] = SN$[35,64];SNK$[31] = SN$[25,34]
SNK1$ = " ",SNK1$;SNK1$[1,24] = SN$[1,24];SNK1$[25] = SN$[25,34]
Search #8,5,1;SNK$,R8,E \ If E > 1 Gosub ERR_SEARCH
If E Goto L_4955
Search #8,5,2;SNK1$,R8,E \ If E Gosub ERR_SEARCH
E = 3
Search #8,1,0;SNK$,R8,E \ If E Gosub ERR_SEARCH
L_4955: Rem DEL
SNKE$ = " ",SNKE$;SNKE$[1,30] = SN1$[25,54];SNKE$[31] = MRTS0[1] Using "######"
Search #7,5,1;SNKE1$,R7,E \ If E>1 Gosub ERR_SEARCH
Search #7,5,2;SNKE$,R7,E \ If E>1 Gosub ERR_SEARCH
E = 3 \ Search #7,1,0;SNKE$,R7,E \ If E Gosub ERR_SEARCH
Goto L_4520
L_4990: Return 
L_5000: Rem "===================================== prodwhse file
K6$ = " ",K6$
K6$[1,12] = A$[140,151]
K6$[13,14] = MRTS2[2] Using "##"
Search #6,2,1;K6$,R6,E \ If E > 1 Gosub ERR_SEARCH
If E = 1
  Gosub L_5150
End If 
Gosub L_5800
If COST <= 0 Goto L_5110
If QTY <= 0 Goto L_5110
If MRTS3[0] = -3 Goto L_5110
If P60$[21,21] <> "N"
	IF P9$[32,32]="Y"
		LET W3[16]=cost !SET LAST COST
	endif
Endif
If P9$[32,32] <> "Y" Let W3[15] = B[21] \ Goto L_5110
If W3[0] <= 0 Let W3[15] = COST \ Goto L_5110
If (W3[0] + QTY) <= 0 Let W3[15] = COST \ Goto L_5110
If (W3[15] * W3[0]) <= 0 Let W3[15] = COST \ Goto L_5110
W3[15] = FNP(((W3[15] * W3[0]) + (QTY * COST)) / (W3[0] + QTY))
L_5110: If MRTS3[0] <> -3 Let W3[0] = W3[0] + QTY
If MRTS3[0] = -3 Or A$[127,127] = "Y" ! "Catch Weight
  WHLBS[0] = WHLBS[0] + MRTS4[1]
End If 
INVBAL = W3[0]
Gosub L_5900
Return 
L_5150: Rem "========= create new record
WHPROD$[1,12] = A$[140,151];WHBLD[0] = 6;WHBLD[1] = MRTS2[2];WHBLD[2] = B[24]
Call "MXWHCREATE",WHPROD$,WHBLD[]
R6 = WHBLD[2];E = 0;WHBLD[2] = 0
Return 
L_5800: Rem "======================================= read prodwhse rec
Mat Read #6,R6,0;W1$
Mat Read #6,R6,32;W1
Mat Read #6,R6,38;W2
Mat Read #6,R6,78;W3
Mat Read #6,R6,228;W5
Mat Read #6,R6,404;W2$
Mat Read #6,R6,420;W0
Mat Read #6,R6,428;WH7
Mat Read #6,R6,444;WH8
Mat Read #6,R6,540;WH9
Mat Read #6,R6,696;W7
Mat Read #6,R6,980;WHLBS
OLDWHAVGCOST=W3[15]
OLDWHLASTCOST=W3[16]
Return 
L_5900: Rem "======================================= write prodwhse rec
Mat Write #6,R6,0;W1$
Mat Write #6,R6,32;W1
Mat Write #6,R6,38;W2
Mat Write #6,R6,78;W3
Mat Write #6,R6,228;W5
Mat Write #6,R6,404;W2$
Mat Write #6,R6,420;W0
Mat Write #6,R6,428;WH7
Mat Write #6,R6,444;WH8
Mat Write #6,R6,540;WH9
Mat Write #6,R6,696;W7
Mat Write #6,R6,980;WHLBS;
IF P9$[32,32]="Y"
	pch.Whse=MRTS2[2]
	if oldwhavgcost<> w3[15]                  
		pch.Ctype=6                               
		Pch.OldCost=OLDwhavgCOST                    
		pch.Newcost= W3[15]                         
		GOSUB update_cost_hist: ! cost hist log   
	ENDIF                                     
	if oldwhlastcost<> W3[16]                  
		pch.CType=3                                
		pch.OldCost=OLDwhLASTCOST                    
		pch.NewCost= W3[16]                          
		GOSUB update_cost_hist: ! cost hist log    
	ENDIF
ENDIF
Return 
L_6000: Rem UPDATE FIFOLOT & FIFOTRANS
FLBSFACTOR = LBSFACTOR
FLBSUNIT = LBSUNIT
FCOST = 0;FCOST[1] = 0
If P60$[9,9] <> "F" And P60$[9,9] <> "L" Return 
FCOST = 0
If A$[127,127] = "Y" And P61$[73,73] = "Y"
  If Not(MRTS4[1]) Return 
Else 
  If Not(QTY) Return 
End If 
For CTR = 0 To 16
  If CTR < 11 Let FIFOSPECCH[CTR] = 0;FIFOSPEC1[CTR] = 0;FIFOSPEC2[CTR] = 0
  FIFOSPEC3[CTR] = 0
Next CTR
FIFOSPEC$ = " ",FIFOSPEC$
Rem set fifo spec variable for channel #
FIFOSPECCH[0] = 19
FIFOSPECCH[1] = 20
FIFOSPECCH[2] = 30
FIFOSPECCH[3] = 26
FIFOSPECCH[4] = 3
FIFOSPECCH[5] = 6
FIFOSPECCH[6] = 0
Rem set fifospec 1 variables
FIFOSPEC1[0] = 324
FIFOSPEC1[1] = MRTS2[2]
FIFOSPEC1[2] = MRTS2[2]
FIFOSPEC1[3] = MRTS2[2]
FIFOSPEC1[4] = 0
FIFOSPEC1[5] = MRTS2[0]
Rem set fifospec 2 variables
FIFOSPEC2[0] = JARDATE
FIFOSPEC2[1] = POSTPER
Rem set fifospec 3 variables
FIFOSPEC3[0] = QTY
FIFOSPEC3[1] = MRTS0[5]
FIFOSPEC3[2] = 0
FIFOSPEC3[3] = COST
FIFOSPEC3[4] = FLBSUNIT
FIFOSPEC3[5] = FLBSFACTOR
FIFOSPEC3[6] = QTY
FIFOSPEC3[7] = Abs(MRTS4[1])
FIFOSPEC3[8] = 0
FIFOSPEC3[9] = 0
Rem set fifospec$ variable
FIFOSPEC$ = " ",FIFOSPEC$
FIFOSPEC$[1,12] = A$[140,151]
FIFOSPEC$[13,24] = LOT$[1,12]
FIFOSPEC$[25,34] = BLK$[1,10]
FIFOSPEC$[35,40] = STKLOC$[1,6]
If MRTS2[0] = 99 ! reason code #99
  If A$[140,151] = TOPROD$[1,12]
    FIFOSPEC$[75,86] = FRPROD$[1,12]
  Else 
    FIFOSPEC$[75,86] = TOPROD$[1,12]
  End If 
End If 
FIFOSPEC$[87,102] = MRTS0$[19,34]
If A$[127,127] = "Y" And P61$[73,73] = "Y"
  If Not(MRTS4[1]) Return 
  FIFOSPEC3[0] = MRTS4[1]
  If MRTS4[1] >= 0 ! positive qty  check cost
    If MRTS0[3] ! cost has been calculated ! need price per lb
      If MRTS3[1] <> -3 ! enter um <>-3
        FIFOSPEC3[3] = Abs((MRTS0[3] * QTY) / MRTS4[1])
      Else 
        CNVTA = MRTS0[3]
        CNVTU[0] = 0;CNVTU[1] = -3;CNVTU[2] = 2
        Gosub L_20000
        FIFOSPEC3[3] = AMOUNT
      End If 
    End If 
  Else 
    FIFOSPEC3[3] = 0
  End If 
End If
Call "MXFIFO.dl4",FIFOSPECCH[],FIFOSPEC1[],FIFOSPEC2[],FIFOSPEC3[],FIFOSPEC$,e$,IntCo,rstr$
!Call "MXFIFO",FIFOSPECCH[],FIFOSPEC1[],FIFOSPEC2[],FIFOSPEC3[],FIFOSPEC$
FCOST[0] = FIFOSPEC3[8]
FCOST[1] = FIFOSPEC3[9]
Return 
FQ9[0] = Int(QTY) \ FQ9[1] = 0 \ FQ9[2] = 0
FLK$ = " ",FLK$ \ FLK$[1,12] = A$[140,151] \ FLK$[13,14] = MRTS2[2] Using "##" \ MODE = 3
If P60$[9,9] = "L" Let FLK$[15] = "999999" \ MODE = 6
L_6030: Search #19,MODE,1;FLK$,R[19],E \ If E = 2 Goto L_6200
If E Gosub ERR_SEARCH
If FLK$[1,12] <> A$[140,151] Goto L_6200
S9 = FLK$[13,14] \ If S9 <> MRTS2[2] Goto L_6200
Mat Read #19,R[19],102;FL3; \ If Not(FL3 - FL3[1]) Goto L_6030
FQ9[2] = FQ9[0] - FQ9[1]
If FQ9[2] > 0 If (FL3[0] - FL3[1]) < 0 Goto L_6095
FQTY = FL3[0]
For S9 = 1 To 5 \ FQTY = FQTY - FL3[S9] \ Next S9
For S9 = 8 To 11 \ FQTY = FQTY - FL3[S9] \ Next S9
If FQ9[2] < 0 If FQTY > 0 Goto L_6095
If FQ9[2] >= 0 Goto L_6030
If FL3[0] Goto L_6030
Mat Read #19,R[19],86;FL2;
If JARDATE = FL2[1] Goto L_6095
Goto L_6030
L_6095: Gosub L_6800
If FQ9[2] < 0 Goto L_6130
If (FL3[1] - FL3[0]) > 0 If (FL3[1] - FL3[0]) < FQ9[2] Let FQ9[2] = (FL3[1] - FL3[0])
FL3[0] = Int(FL3[0] + FQ9[2])
Goto L_6145
L_6130: If FQ9[2] > 0 Goto L_6145
FQTY = FL3[0]
For S9 = 1 To 5 \ FQTY = FQTY - FL3[S9] \ Next S9
For S9 = 8 To 11 \ FQTY = FQTY - FL3[S9] \ Next S9
If FL3[0] If FQTY < Abs(FQ9[2]) Let FQ9[2] = - (FQTY)
FL3[1] = Int(FL3[1] - FQ9[2])
L_6145: FL2[2] = JARDATE
GETFIFOCOST: Rem get fifo cost
If FL3[6] If COST <= 0 Goto EXTFIFOCOST
If COST > 0 Let FL3[6] = COST
FL3[7] = FL3[6] + ((FL3[6] * FIFL) / 100)
EXTFIFOCOST: Rem get extended fifo cost
DISP_QTY = FQ9[2];DISP_COST = 0
If P8$[5,5] = "I" Let DISP_COST = FL3[7]
If P8$[5,5] = "F" Let DISP_COST = FL3[6]
DISP_EXT = FNR(DISP_COST * DISP_QTY)
If DISP_COST
  If PFU1[11] > 0 And PFU1[11] <> PFU1[0]
    Gosub CALC_DISP_EXT
  End If 
  If MRTS3[1] = -3 And MRTS0[0] > 0 And MRTS0[3] > 0 And MRTS4[1] > 0
    Gosub CALC_DISP_EXT
  End If 
End If 
FCOST = FCOST + Abs(DISP_EXT)
If P61$[60,60] = "Y"
  If FQ9[2] > 0 ! adding in check for special cost
    REC_WHSE = MRTS2[2] - 1
    If REC_WHSE < 0 Goto ENDADDSPCCOST
    If REC_WHSE > 99 Goto ENDADDSPCCOST
    Read #26,REC_WHSE,2970;WHOS;
    If Not(WHOS) Goto ENDADDSPCCOST
    FSKEY$ = " ",FSKEY$;FSKEY$[1,12] = A$[140,151]
    FSKEY$[13,16] = WHOS Using "####"
    Search #CH_FIFOS,2,1;FSKEY$,REC_FIFOS,E \ If E > 1 Gosub ERR_SEARCH
    If Not(E)
      Mat Read #CH_FIFOS,REC_FIFOS,38;FC2;
      FL3[14] = FC2[0]
    End If 
  End If 
ENDADDSPCCOST: Rem end adding of special cost
  If FL3[14] <> 0 ! get special cost
    DISP_EXT = FNR(FL3[14] * FQ9[2])
    If FL3[14]
      If PFU1[11] > 0 And PFU1[11] <> PFU1[0]
        DISP_QTY = FQ9[2];DISP_COST = FL3[14]
        Gosub CALC_DISP_EXT
      End If 
    End If 
    FCOST[1] = FCOST[1] + DISP_EXT
  Else 
    FCOST[1] = FCOST[1] + DISP_EXT
  End If 
End If 
Gosub L_6850
Gosub L_6400
FQ9[1] = Int(FQ9[1] + FQ9[2])
If FQ9[0] = FQ9[1] Return 
Goto L_6030
Stop 
L_6200: Rem CREATE FIFOLOT
FL1$ = " ",FL1$
For S9 = 0 To 14
  If S9 < 3 Let FL1[S9] = 0
  If S9 < 3 Let FL2[S9] = 0
  If S9 < 2 Let FL4[S9] = 0
  FL3[S9] = 0
Next S9
FQ9[2] = FQ9[0] - FQ9[1]
FL1[0] = MRTS2[2] \ FL1[1] = 7 \ If FQ9[2] < 0 Let FL1[1] = 30
FL1[2] = PFU1[0]
FL1$[1,12] = A$[140,151]
FL1$[13,24] = LOT$[1,12]
FL1$[25,34] = BLK$[1,10]
FL1$[35,40] = STKLOC$[1,6]
FL1$[41,56] = MRTS0$[19,34]
FL1$[57,57] = "/";FL1$[58,60] = MRTS2[0] Using "###"
FL4[0] = FLBSUNIT
FL4[1] = FLBSFACTOR
If MRTS2[0] = 99
  If FL1$[1,12] = TOPROD$[1,12]
    FL1$[71,80] = FRPROD$
  Else 
    FL1$[71,80] = TOPROD$
  End If 
End If 
FL2[1] = JARDATE
If FQ9[2] > 0 Let FL3[0] = Int(FQ9[2])
If FQ9[2] < 0 Let FL3[1] = Int(Abs(FQ9[2]))
GETFIFOCOST1: Rem get the fifo cost "
If COST > 0 Let FL3[6] = COST
If FL3[6] Goto L_6335
If MRTS2[0] = 99 And FQ9[2] > 0 Goto L_6335
FLK$[1,12] = FL1$[1,12] \ FLK$[13,14] = FL1[0] Using "##" \ FLK$[15] = "999999" \ MODE = 6
If P60$[9,9] = "L" Let FLK$[15] = "" \ MODE = 3
Search #19,MODE,1;FLK$,R[19],E \ If E = 2 Goto L_6325
If E Gosub ERR_SEARCH
S9 = FLK$[13,14]
If FLK$[1,12] = FL1$[1,12] And S9 = FL1[0]
  Mat Read #19,R[19],192;FL4;
  Read #19,R[19],186;FL3[14];
  Read #19,R[19],138;FL3[6]; \ Goto L_6335
End If 
L_6325: If P9$[32,32] = "Y" And W3[16] <> 0 Let FL3[6] = W3[16] \ Goto L_6335
FL3[6] = B[10]
L_6335: FL3[7] = FL3[6] + ((FL3[6] * FIFL) / 100)
If P61$[60,60] = "Y"
  REC_WHSE = MRTS2[2] - 1
  If REC_WHSE < 0 Goto CREATEFIFOLOT
  If REC_WHSE > 99 Goto CREATEFIFOLOT
  Read #26,REC_WHSE,2970;WHOS;
  If Not(WHOS) Goto CREATEFIFOLOT
  If FQ9[2] > 0 ! adding in check for special cost
    FSKEY$ = " ",FSKEY$;FSKEY$[1,12] = A$[140,151]
    FSKEY$[13,16] = WHOS Using "####"
    Search #CH_FIFOS,2,1;FSKEY$,REC_FIFOS,E \ If E > 1 Gosub ERR_SEARCH
    If Not(E)
      Mat Read #CH_FIFOS,REC_FIFOS,38;FC2;
      FL3[14] = FC2[0]
    End If 
  End If 
End If 
CREATEFIFOLOT: Rem create fifo lot
FLK$ = " ",FLK$
E = 2 \ Search #19,1,0;FLK$,R[19],E \ If E Gosub ERR_SEARCH
FL2 = R[19]
Gosub L_6850
FLK$ = " ",FLK$ \ FLK$[1,12] = FL1$[1,12] \ FLK$[13,14] = FL1 Using "##"
FLK$[15,20] = FL2[1] Using "######" \ FLK$[21,26] = FL2 Using "######"
Search #19,4,1;FLK$,R[19],E \ If E Gosub ERR_SEARCH
Gosub L_6400
DISP_QTY = FQ9[2];DISP_COST = 0
If P8$[5,5] = "I" Let DISP_COST = FL3[7]
If P8$[5,5] = "F" Let DISP_COST = FL3[6]
DISP_EXT = FNR(DISP_QTY * DISP_COST)
If DISP_COST
  If PFU1[11] > 0 And PFU1[11] <> PFU1[0]
    Gosub CALC_DISP_EXT
  End If 
  If MRTS3[1] = -3 And MRTS0[0] > 0 And MRTS0[3] > 0 And MRTS4[1] > 0
    Gosub CALC_DISP_EXT
  End If 
End If 
FCOST = FCOST + Abs(DISP_EXT)
If P61$[60,60] = "Y"
  If FL3[14]
    DISP_QTY = FQ9[2];DISP_COST = FL3[14]
    DISP_EXT = FNR(DISP_QTY * DISP_COST)
    If DISP_COST
      If PFU1[11] > 0 And PFU1[11] <> PFU1[0]
        Gosub CALC_DISP_EXT
      End If 
    End If 
    FCOST[1] = FCOST[1] + Abs(DISP_EXT)
  Else 
    FCOST[1] = FCOST[1] + Abs(DISP_EXT)
  End If 
End If 
Return 
L_6400: Rem FIFOTRANS FILE UPDATE
FT1$ = " ",FT1$
For S9 = 0 To 3 \ FT1[S9] = 0 \ FT2[S9] = 0 \ FT3[S9] = 0 \ Next S9
FT1$[1,12] = A$[140,151] \ FT1$[13,24] = LOT$[1,12]
FT1$[25,34] = BLK$[1,10] \ FT1$[35,40] = STKLOC$[1,6]
FT1$[41,48] = "PROG 325"
FT1$[53,68] = MRTS0$[19,34]
FT1$[69,69] = "/";FT1$[70,72] = MRTS2[0] Using "###"
FT1[0] = 7 \ If FQ9[2] < 0 Let FT1[0] = 30
FT1[1] = MRTS2[2]
FT1[2] = Spc(6) \ FT2[0] = FL2[0]
FT2[2] = JARDATE \ FT3[0] = FQ9[2]
FT3[1] = FL3[6] \ FT3[2] = FL3[7] \ FT3[3] = FL3[14]
FLT$ = " ",FLT$
E = 2 \ Search #20,1,0;FLT$,R[20],E \ If E Gosub ERR_SEARCH
If R[20] <= 999999 Let FT2[1] = R[20]
Gosub L_6900
FLT$[1,6] = FT2[0] Using "######" \ FLT$[7,12] = FT2[2] Using "######"
If R[20] <= 999999
  FLT$[13,18] = FT2[1] Using "######"
Else 
  FTRECA = Int((R[20] - 1000000) / 100000)
  FTRECB = Fra(R[20] / 100000) * 100000
  Call String(4,FTRECA + 193,LETTER$)
  FLT$[13,13] = LETTER$[1,1]
  FLT$[14,18] = FTRECB Using "#####"
End If 
Search #20,4,1;FLT$,R[20],E \ If E Gosub ERR_SEARCH
Return 
L_6800: Rem READ FIFOLOT
Mat Read #19,R[19],0;FL1
Mat Read #19,R[19],6;FL1$
Mat Read #19,R[19],86;FL2
Mat Read #19,R[19],102;FL3
Mat Read #19,R[19],192;FL4
Return 
L_6850: Rem WRITE FIFOLOT
Mat Write #19,R[19],0;FL1
Mat Write #19,R[19],6;FL1$
Mat Write #19,R[19],86;FL2
Mat Write #19,R[19],102;FL3;
Mat Write #19,R[19],192;FL4;
Return 
L_6900: Rem WRITE FIFOTRANS
Mat Write #20,R[20],0;FT1$;
Mat Write #20,R[20],72;FT1;
Mat Write #20,R[20],80;FT2;
Mat Write #20,R[20],96;FT3;
Return 
update_cost_hist: ! rem                                 
! get rest of costhist data
LET pch.ProdCode$=A$[140,151]+Blank$
pch.AccessCode$=Blank$ ! gets in call
pch.Source$="MRTS Updt"+Blank$
pch.sOpen$=blank$
pch.Blankforkey$=blank$
lET pch.CDate=0                                         
LET pch.CTime=0                                         
LET pch.CostUm=PFU1[11]                                  
IF pch.CostUm>0                                          
	FOR XCST=0 TO 7                                         
		IF PFU1[XCST]=PFU1[11]                                  
			IF XCST=0                                               
				LET pch.CstUmFactor=1                                         
			ELSE                                                    
				LET pch.CstUmFactor=PFU2[XCST-1]                              
			ENDIF                                                   
		ENDIF                                                   
	NEXT XCST                                               
ENDIF                                                   
rem whse is set                                     
! CALL "mkcosthist",CSTHST$,CSTHST[],CHAN   
call MkCostHist(e$,IntCo,fchan[],pch.)
return 
L_7650: Rem GET JULIAN DATE
SCRATCH$ = "" \ Call Time(SCRATCH$)
SCRATCH$[13] = "" \ Call VerifyDate(SCRATCH$,X$,E) \ If E Gosub ERR_SEARCH
ARDATE = X$
Call DateToJulian(1,X$,X$,E) \ If E Gosub ERR_SEARCH
X2 = X$[1,5]
JARDATE = X2
Return 
X$ = " ",X$ \ X$[10] = ""
X$[1,3] = Int(X2 / 10 ^ 2 - Int(X2 / 10 ^ 4) * 10 ^ 2) + 10 ^ 2 Using "###"
X$[4,6] = Fra(X2 / 10 ^ 2) * 10 ^ 2 + 10 ^ 2 Using "###"
X$[7,9] = Int(X2 / 10 ^ 4) + 10 ^ 2 Using "###"
X$[4,4] = "/" \ X$[7,7] = "/" \ X$ = X$[2]
Return 
D3[0] = X2;FLAG = 1;X$ = " "
Call "JULIANUTIL",D3[],X$,FLAG
Return 
Call VerifyDate(X$,X$,E) \ If E Let X$ = "    "
X2 = X$[1,6] \ Return 
L_7820: Rem  CONVERT YYMMDD TO JULIAN (RETURN=NOGOOD, +1=OKAY)
X$ = X2 Using "&&&&&&"
Call DateToJulian(1,X$,X$,E) \ If E Return 
X2 = X$[1,5] \ Return 1
L_7840: Rem CONVERT JULIAN TO YYMMDD
D3[0] = X2;D3[1] = X2;FLAG = 0
Call "JULIANUTIL",D3[],X$,FLAG
Return 
X$ = X2 Using "&&&&"
D3[0] = X$[1,2];D3[1] = X$[3,4]
If D3[0] > 67 Let D3[0] = 1900 + D3[0]
If D3[0] < 68 Let D3[0] = 2000 + D3[0]
X$[1,4] = D3[0] Using "&&&&";X$[5,6] = D3[1] Using "&&"
X2 = X$[1,6] \ Return 
L_8900: Rem "======================================= done OK
If Not(SPREC)
  KEYMRTS1$ = " ",KEYMRTS1$
SRCHMRSW: Rem delete accepted keys from work file and misc rts file
  Search #CH_MRSW,3,1;KEYMRTS1$,REC_MRTS,E \ If E = 2 Goto ENDSRCHMRSW
  If E Gosub ERR_SEARCH
  Mat Read #2,REC_MRTS,0;MRTS0;
  Mat Read #2,REC_MRTS,104;MRTS2;
  KEYMRTS2$ = " ",KEYMRTS2$
  KEYMRTS2$[1,2] = MRTS2[2] Using "##"
  KEYMRTS2$[3,10] = MRTS0[5] Using "########"
  Search #2,5,2;KEYMRTS2$,REC_MRTS,E \ If E Gosub ERR_SEARCH
  Search #2,5,1;KEYMRTS1$,REC_MRTS,E \ If E Gosub ERR_SEARCH
  E = 3 \ Search #2,1,0;KEYMRTS1$,REC_MRTS,E \ If E Gosub ERR_SEARCH
  Goto SRCHMRSW
ENDSRCHMRSW: Rem end search kill work file
  !If Err 0 Rem
  Try Close #CH_MRSW Else Rem
  ! If Err 0 Gosub ERR_TRAP
  S$ = rec_uac Using "files/6/MRSWERP&&&&"
  Call FindF(S$,A9)
  If A9
    Kill S$
  End If 
  If P9$[17,17] = "Y"
    !If Err 0 Rem
    For X1 = 2 To 99
	try Close #X1 Else Rem
    Next X1
    !If Err 0 Gosub ERR_TRAP
    !Chain "MX324B.dl4"
    Call "mx324b.dl4",sprec,whse,jrnl,eflg,rec_uac,message$,IntCo,rstr$,e$
    goto L_9010:
  End If
  ! check if entries are outstanding for another warehouse
  let keymrts1$=" ",keymrts1$
  search #2,3,1;keymrts1$,rec_mrts,e
  if e=2
	S = 0
  else
	s=2
  endif
  Write #1,20;S;
  Mat Read #26,99,900;WPF;
  WPF[324] = 0
  Mat Write #26,99,900;WPF;
  !Signal 3,10
  !Print @0,23;'CL';"Receipt to Stock Entries Accepted";
  !Signal 3,25
  !Chain "MX000"
End If 
GETGLARCNTRL: Rem find glarcntrl record
K20$ = " ",K20$ \ K20$[1,2] = MRTS2[2] Using "##"
Search #CH_GLARCNTRL,2,1;K20$,REC_GLARCNTRL,E
If E > 1 Gosub ERR_SEARCH
If E = 1
  K20$ = "DFAULT"
  Search #CH_GLARCNTRL,2,1;K20$,REC_GLARCNTRL,E \ If E Gosub ERR_SEARCH
End If 
Rem {begin src/inc/read.glarcntrl.i}
Mat Read #CH_GLARCNTRL,REC_GLARCNTRL,0;GLC;
Mat Read #CH_GLARCNTRL,REC_GLARCNTRL,8;GLC1;
Mat Read #CH_GLARCNTRL,REC_GLARCNTRL,80;GLC2;
Mat Read #CH_GLARCNTRL,REC_GLARCNTRL,206;GLC3;
Mat Read #CH_GLARCNTRL,REC_GLARCNTRL,332;GLC4;
Mat Read #CH_GLARCNTRL,REC_GLARCNTRL,458;GLC5;
Mat Read #CH_GLARCNTRL,REC_GLARCNTRL,584;GLC6;
Mat Read #CH_GLARCNTRL,REC_GLARCNTRL,710;GLC7;
Mat Read #CH_GLARCNTRL,REC_GLARCNTRL,836;GLC8;
Mat Read #CH_GLARCNTRL,REC_GLARCNTRL,962;GLC9;
Mat Read #CH_GLARCNTRL,REC_GLARCNTRL,1088;GLC10;
Mat Read #CH_GLARCNTRL,REC_GLARCNTRL,1214;GLC11;
Mat Read #CH_GLARCNTRL,REC_GLARCNTRL,1340;GLC12;
Mat Read #CH_GLARCNTRL,REC_GLARCNTRL,1718;GLC0;
Rem {end read.glarcntrl.i}
Return 
GETGLINVENT: Rem add to gltemp file
For X = 0 To 2 \ GTEMP0[X] = 0 \ Next X
For X = 0 To 3 \ GTEMP1[X] = 0 \ Next X
If P9$[2,2] = "M"
  If A$[152,155] = "LABR"
    If P8$[3,3] = "Y"
      GTEMP0[0] = GLC8[B[11]]
    Else 
      GTEMP0[0] = GLC8[0]
    End If 
  Else 
    If A$[152,155] = "MACH"
      If P8$[3,3] = "Y"
        GTEMP0[0] = GLC10[B[11]]
      Else 
        GTEMP0[0] = GLC10[0]
      End If 
    Else 
      If A$[152,155] = "TIME"
        If P8$[3,3] = "Y"
          GTEMP0[0] = GLC9[B[11]]
        Else 
          GTEMP0[0] = GLC9[0]
        End If 
      Else 
        If A$[139,139] = "M" !finished good
          If P8$[3,3] = "Y"
            GTEMP0[0] = GLC4[B[11]]
          Else 
            GTEMP0[0] = GLC4[0]
          End If 
        Else 
          If A$[139,139] = "B" ! raw material inventory
            If P8$[3,3] = "Y"
              GTEMP0[0] = GLC11[B[11]]
            Else 
              GTEMP0[0] = GLC11[0]
            End If 
          End If 
        End If 
      End If 
    End If 
  End If 
Else 
  If P8$[3,3] = "Y"
    GTEMP0[0] = GLC4[B[11]]
  Else 
    GTEMP0[0] = GLC4[0]
  End If 
End If 
Gosub ADDGLTEMP
Return 
GETGLREASON: Rem get gl account for reason code
For X = 0 To 2 \ GTEMP0[X] = 0 \ Next X
GLCOST[0] = - GLCOST[0]
GLCOST[1] = - GLCOST[1]
Mat Read #10,MRTS2[0],30;RSN;
GTEMP0[0] = RSN[MRTS2[2]]
If Not(GTEMP0[0]) Let GTEMP0[0] = RSN[0]
Gosub ADDGLTEMP
Return 
ADDGLTEMP: Rem add to gl temp file
GTEMP0[1] = 0
GTEMP1[0] = CLIENT
GTEMP1[1] = MRTS2[2]
If MRTS3[2]
  GTEMP1[2] = MRTS3[2]
Else 
  GTEMP1[2] = ARDATE
End If 
GTEMP1[3] = MRTS2[0]
GLTKEY$ = " ",GLTKEY$;GLTKEY$[1,4] = CLIENT Using "####"
GLTKEY$[5,12] = GTEMP0[0] Using "########"
GLTKEY$[13,14] = GTEMP1[1] Using "##"
GLTKEY$[15,20] = GTEMP1[2] Using "######"
GLTKEY$[21,24] = GTEMP1[3] Using "####"
Search #CH_GLTEMP,2,1;GLTKEY$,REC_GLTEMP,E \ If E > 1 Gosub ERR_SEARCH
If E = 1
  E = 2 \ Search #CH_GLTEMP,1,0;GLTKEY$,REC_GLTEMP,E \ If E Gosub ERR_SEARCH
  Gosub WRITEGLTEMP
  Search #CH_GLTEMP,4,1;GLTKEY$,REC_GLTEMP,E \ If E Gosub ERR_SEARCH
End If 
Gosub READGLTEMP
If P61$[60,60] = "Y"
  GTEMP0[1] = GTEMP0[1] + GLCOST[1]
Else 
  GTEMP0[1] = GTEMP0[1] + GLCOST[0]
End If 
Gosub WRITEGLTEMP
Gosub UPGLDET
Return 
READGLTEMP: Rem read general ledger temp file
Mat Read #CH_GLTEMP,REC_GLTEMP,0;GTEMP0
Mat Read #CH_GLTEMP,REC_GLTEMP,18;GTEMP1
Return 
WRITEGLTEMP: Rem write general ledger temp file
Mat Write #CH_GLTEMP,REC_GLTEMP,0;GTEMP0
Mat Write #CH_GLTEMP,REC_GLTEMP,18;GTEMP1;
Return 
UPGLDET: Rem up gl detail file
If Not(GLDETLAVAIL) Return 
For X9 = 0 To 4 \ GLD[X9] = 0 \ GLD1[X9] = 0 \ Next X9
GLD1[5] = 0
GLD0[0] = 0;GLD0[1] = 0
GLD$ = " ",GLD$;GLD1$ = " ",GLD1$;GLD0$ = " ",GLD0$
GLD2 = 0
GLD[0] = CLIENT
GLD[1] = POSTPER
GLD[2] = MRTS3[2]
GLD[3] = POSTDATE
GLD[4] = JRNL
GLD1$[1,12] = MRTS1$[1,12]
GLD1$[13,28] = MRTS0$[19,34]
GLD1$[29,40] = MRTS3$[1,12]
GLD$[1,9] = GTEMP0[0] Using "#########"
CUNIT = MRTS3[0]
Gosub GETCCODE
GLD0$[1,4] = CUNIT$[1,4]
CUNIT = MRTS3[1]
Gosub GETCCODE
GLD0$[5,8] = CUNIT$[1,4]
If MRTS3[3] ! converted qty
  CUNIT = MRTS3[3]
  Gosub GETCCODE
  GLD0$[9,12] = CUNIT$[1,4]
End If 
GLD0[0] = MRTS2[0]
GLD0[1] = MRTS2[2]
GLD1[0] = CQTY
GLD1[1] = CCOST
GLD1[2] = MRTS0[5]
GLD1[3] = MRTS4[1]
GLD1[4] = CCQTY
If P61$[60,60] = "Y"
  GLD1[5] = Abs(GLCOST[1])
Else 
  GLD1[5] = Abs(GLCOST[0])
End If 
GLDKEY1$ = " ",GLDKEY1$
GLDKEY1$[1,4] = GLD[1] Using "&&&&"
GLDKEY1$[5,16] = GLD$[1,12]
GLDKEY1$[17,22] = GLD[4] Using "######"
GLDKEY1$[23,30] = GLD1[2] Using "########"
GLDKEY1$[31,32] = GLD0[1] Using "##"
Search #55,2,1;GLDKEY1$,REC_GLD,E \ If E > 1 Gosub ERR_SEARCH
If E = 1
  E = 2 \ Search #55,1,0;GLDKEY1$,REC_GLD,E \ If E Gosub ERR_SEARCH
  Mat Write #55,REC_GLD,0;GLD;
  Mat Write #55,REC_GLD,32;GLD1$;
  Mat Write #55,REC_GLD,72;GLD$;
  Mat Write #55,REC_GLD,84;GLD0$;
  Mat Write #55,REC_GLD,102;GLD0;
  Mat Write #55,REC_GLD,118;GLD1;
  Mat Write #55,REC_GLD,160;GLD2;
  Search #55,4,1;GLDKEY1$,REC_GLD,E \ If E Gosub ERR_SEARCH
  GLDKEY2$ = " ",GLDKEY2$
  GLDKEY2$[1,8] = GLD1[2] Using "########"
  GLDKEY2$[9,10] = GLD0[1] Using "##"
  GLDKEY2$[11,14] = GLD[1] Using "&&&&"
  GLDKEY2$[15,26] = GLD$[1,12]
  GLDKEY2$[27,32] = GLD[4] Using "######"
  Search #55,4,2;GLDKEY2$,REC_GLD,E \ If E Gosub ERR_SEARCH
End If 
Mat Read #55,REC_GLD,160;GLD2
If P61$[60,60] = "Y"
  GLD2 = GLD2 + GLCOST[1]
Else 
  GLD2 = GLD2 + GLCOST[0]
End If 
Mat Write #55,REC_GLD,160;GLD2;
Return 
GETCCODE: Rem get codes
CUNIT$ = " ",CUNIT$
If CUNIT > 0
  Read #54,CUNIT,10;CUNIT$;
Else 
  If CUNIT = -1
    CUNIT$ = "CWT "
  Else 
    If CUNIT = -2
      CUNIT$ = "LOT "
    Else 
      If CUNIT = -3
        CUNIT$ = "LB  "
      End If 
    End If 
  End If 
End If 
Return 
GETGLCOST: Rem get the general ledger cost
If P9$[17,17] <> "Y" Return 
If MRTS2[1] ! accepted already
  GLCOST[0] = MRTS0[4]
  GLCOST[1] = MRTS4[2]
  Return 
End If 
If P60$[9,9] = "F" Or P60$[9,9] = "L"
  If P8$[5,5] = "F" Or P8$[5,5] = "I"
    GLCOST[0] = FCOST[0] \ GLCOST[1] = FCOST[1]
    Return 
  End If 
End If 
If MRTS0[3] And MRTS0[0] > 0
  DISP_EXT = FNR(MRTS0[0] * MRTS0[3])
  If PFU1[11] > 0 And PFU1[11] <> PFU1[0]
    DISP_QTY = MRTS0[0];DISP_COST = MRTS0[3]
    Gosub CALC_DISP_EXT
  End If 
  If MRTS3[1] = -3 And MRTS0[0] > 0 And MRTS0[3] > 0 And MRTS4[1] > 0
    DISP_QTY = MRTS0[0];DISP_COST = MRTS0[3]
    Gosub CALC_DISP_EXT
  End If 
  GLCOST[0] = DISP_EXT
  If P61$[60,60] = "Y" ! get the special cost
    FSKEY$ = " ",FSKEY$
    FSKEY$[1,12] = A$[140,151];FSKEY$[13,14] = MRTS2[2]
    Search #CH_FIFOS,2,1;FSKEY$,REC_FIFOS,E \ If E > 1 Gosub ERR_SEARCH
    If E = 1
      FSKEY$[13,14] = " 0"
      Search #CH_FIFOS,2,1;FSKEY$,REC_FIFOS,E \ If E > 1 Gosub ERR_SEARCH
      If E = 1 Goto ENDADDGLCOST1
    End If 
    Mat Read #CH_FIFOS,REC_FIFOS,38;FC2;
    DISP_EXT = FNR(MRTS0[0] * FC2[0])
    If PFU1[11] > 0 And PFU1[11] <> PFU1[0]
      DISP_QTY = MRTS0[0];DISP_COST = FC2[0]
      Gosub CALC_DISP_EXT
    End If 
  End If 
ENDADDGLCOST1: Rem end of glcost 1 update
  GLCOST[1] = DISP_EXT
  Return 
End If 
UNITGLCOST = 0;GLCOST[0] = 0;GLCOST[1] = 0
If P60$[9,9] = "F" Or P60$[9,9] = "L"
  If P8$[5,5] = "F" Or P8$[5,5] = "I"
    GLCOST[0] = FCOST[0] \ GLCOST[1] = FCOST[1]
    Return 
  End If 
End If 
If P9$[32,32] = "Y"
  K6$ = " ",K6$ \ K6$[1,12] = A$[140,151] \ K6$[13,14] = MRTS2[2] Using "##"
  Search #6,2,1;K6$,R6,E
  If Not(E)
    Mat Read #6,R6,78;W3;
    If P8$[5,5] = "R" Or P8$[5,5] = "F"
      UNITGLCOST = W3[16]
    Else 
      If P8$[5,5] = "I"
        UNITGLCOST = W3[16] + FNR((W3[16] * FIFL) / 100)
      Else 
        If P8$[5,5] = "W"
          UNITGLCOST = W3[17]
        Else 
          If P8$[5,5] = "B"
            UNITGLCOST = W3[18]
          Else 
            UNITGLCOST = W3[15]
          End If 
        End If 
      End If 
    End If 
  End If 
End If 
If Not(UNITGLCOST)
  If P8$[5,5] = "R" Or P8$[5,5] = "F"
    UNITGLCOST = B[10]
  Else 
    If P8$[5,5] = "I"
      UNITGLCOST = B[10] + FNR((B[10] * FIFL) / 100)
    Else 
      If P8$[5,5] = "W"
        UNITGLCOST = B[8]
      Else 
        If P8$[5,5] = "B"
          UNITGLCOST = PR_C4[4]
        Else 
          UNITGLCOST = B[21]
        End If 
      End If 
    End If 
  End If 
End If 
If Not(UNITGLCOST) Let UNITGLCOST = W7[3]
DISP_EXT = FNR(MRTS0[0] * UNITGLCOST)
If PFU1[11] > 0 And PFU1[11] <> PFU1[0]
  DISP_QTY = MRTS0[0];DISP_COST = UNITGLCOST
  Gosub CALC_DISP_EXT
End If 
If MRTS3[1] = -3 And MRTS0[0] > 0 And MRTS0[3] > 0 And MRTS4[1] > 0
  DISP_QTY = MRTS0[0];DISP_COST = UNITGLCOST
  Gosub CALC_DISP_EXT
End If 
GLCOST[0] = DISP_EXT
GLCOST[1] = DISP_EXT
Return 
ADDMRSWORK: Rem add transaction to work file for delete at end
Search #CH_MRSW,4,1;KEYMRTS1$,REC_MRTS,E \ If E Gosub ERR_SEARCH
Return 
CALC_DISP_EXT: Rem convert qty and cost to cost um, then calc ext cost
COSTUM = PFU1[11]
If MRTS0[3] > 0 Let COSTUM = MRTS3[1]
If Not(COSTUM) Let COSTUM = PFU1[11]
DISP_QTY1 = DISP_QTY
!! CNVTA = DISP_QTY;CNVTU[0] = 0;CNVTU[1] = COSTUM;CNVTU[2] = 1 \ Gosub L_20000
CNVTA = DISP_QTY;CNVTU[0] = 0;CNVTU[1] = COSTUM;CNVTU[2] = 5 \ Gosub L_20000
DISP_QTY = AMOUNT
CNVTA = DISP_COST;CNVTU[0] = 0;CNVTU[1] = COSTUM;CNVTU[2] = 2 \ Gosub L_20000
DISP_COST = AMOUNT
DISP_EXT = FNR(DISP_QTY * DISP_COST)
If MRTS3[1] = -1 Let DISP_EXT = FNR(DISP_COST * (LBSUNIT * DISP_QTY1) / LBSFACTOR / 100)
If MRTS3[1] = -3 Let DISP_EXT = FNR(DISP_COST * (LBSUNIT * DISP_QTY1) / LBSFACTOR)
Return 
L_20000: Rem UNIT CONVERSION RETURNS AMOUNT  (rev 01/07/1992)   ! 20040 REM
If CNVTU[2] = 3 Goto L_20050
If CNVTU[2] = 1 And CNVTU[1] = CNVTU[0] Let AMOUNT = CNVTA \ Goto L_20160
If CNVTU[0] = -2 Or CNVTU[1] = -2 Let AMOUNT = CNVTA \ Goto L_20160
If CNVTU[2] = 0 Goto L_20050
If Not(CNVTA) Let AMOUNT = 0 \ Goto L_20160
L_20050: goto L_20120: ! If Spc(4) > 1280 Goto L_20120
Swap 1,"MXPRCONV"
If CNVTU[2] = 3 Goto L_20160
L_20080: Signal 2,X1,AMOUNT,FLAG \ If X1 = -1 Let E = 0 \ Gosub ERR_SEARCH
If X1 <> Spc(6) Goto L_20080
If CNVTU[2] = 0 Goto L_20160
If FLAG Let E = FLAG \ Gosub ERR_SEARCH
Goto L_20160
L_20120: Rem "====== unibasic 5+ logic
Call "MXPRCONV5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
If CNVTU[2] = 0 Goto L_20160
If FLAG Let E = FLAG \ Gosub ERR_SEARCH
AMOUNT = CNVTA
L_20160: Return 
Rem {begin rtn.error.s}
ERR_SEARCH: Rem
ENUM = E ;ELINE = Spc(16);CTERR = 0
If E = 5 Let CTERR = Err(8)
msg$ = "RETURN STATUS",(E + (CTERR * .001))
msg$ = msg$,"/ STATEMENT",ELINE," IN PROGRAM "
E$=msg$ \ Error 11000
Return ! En

OUTEND: Rem "================================= exit
!Print 'CS'
If Not(SPREC)
  !If Err 0 Rem
  Try Close #CH_MRSW Else Rem
  !If Err 0 Gosub ERR_TRAP
  S$ = rec_uac Using "6/MRSWERP&&&&"
  Call FindF(S$,A9)
  If A9
    Kill S$
  End If 
  If P9$[17,17] = "Y"
    !If Err 0 Rem
    For X1 = 2 To 99 
	Try Close #X1 Else Rem
    Next X1
    !If Err 0 Gosub ERR_TRAP
    !Chain "MX324B"
    Call "mx324b.dl4",sprec,whse,jrnl,eflg,rec_uac,message$,IntCo,rstr$,e$
    goto L_9010:
  End If 
  S = 0
  Write #1,20;S;
  Mat Read #26,99,900;WPF;
  WPF[324] = 0
  Mat Write #26,99,900;WPF;
  if not(eflg)
	let message$=message$+"Miscellaneous Receipts to Stock Accepted"
endif
  L_9010: ! check status
 ! Call addtostr(e$,rstr$,esdel$) !end section -- DXBLOCK 
!let returnstatus=0 ! report needs to print
!if not(eflg)
!	let message$=message$+"Miscellaneous Receipts to Stock Accepted"
!endif
!call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
!call AddToStr(e$,rstr$,WebStr$)
!call SetOutPut(e$,rstr$)
!try Call dxclose() else rem
  !Print @0,23;'CL';"Receipt to Stock Entries Accepted";
  !Signal 3,25
  !Chain "MX000"
Else 
  Mat Read #26,99,900;WPF;
  WPF[324] = 0
  Mat Write #26,99,900;WPF;
  !If Err 0 Rem
  For X1 = 2 To 99 
	tRY Close #X1 eLSE rEM
  Next X1
  !If Err 0 Gosub ERR_TRAP
  !Chain "mx321"
  
  let returnstatus=1 ! pronto accept from web
  if not(eflg)
	let message$=message$+"Miscellaneous Receipts Entry Accepted "
  else
	let returnstatus=0
  endif
call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
call AddToStr(e$,rstr$,WebStr$)
call SetOutPut(e$,rstr$)
call "proglock.dl4","324A",0,msg$   !! do unlock
try Call dxclose() else rem
outend9: ! everyting done in other programs
End If 
Else
ERR_TRAP: Rem *Error routine (escape trap)   V3.1 8/94 G.DOSCHER/REK
!
include "src/callmainerrnet_call.inc"
end try
End ! the whole program
