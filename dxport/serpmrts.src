!"serpmrts" === description  synergy erp  Misc Receipts To Stock Entry/Edit
!loadsave -w -n 100,10 -o prog/dxport/serpmrts.dl4 src/serpmrts.src
!
!
External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus

External Lib "libprodconv.lib"           
Declare External Function ConvProdAmount 

External Lib "ubsprconv.dl4"     
Declare External Function XUnit$ 
!
External Lib "libgeneralcode.lib"
Declare External Function ConvertDate
!
External Lib "ubsfunc.dl4"
Declare External Sub getportdefault,GetCostLevels,LogAccess
Declare External Function OpenFile,PDate$,FormatDate2$
Declare External Function getuidrec,getuidinfo$

External Lib "libprod.lib"
Declare External Sub ProdList,ProdGroup,UMDList
Declare External Function getpravail,getumrec,ChkPrdUM

External Lib "libprodwh.lib"    
Declare External Sub mxwhcreate 


External Lib "getglname.lib"        
Declare External Function getglname$

External Lib "invttrans.dl4"
Declare External Sub Maketrans

External Lib "libfilespoflenz.lib"                           
Declare External Function filegetspoflenz,fileupdatespoflenz 

Declare Intrinsic Sub StringSearch
Declare Intrinsic Sub DateToJulian,FindF,JulianToDate,VerifyDate,CheckNumber,Time
Declare Intrinsic Sub String
Declare Intrinsic function findchannel
!
!
Declare sub OpenFiles
Declare sub VerifyVendor
Declare sub GetProdDetail,SubmitMRTS, GETMRTSENTRY
Declare sub GetProdXfer,gettoprlotloc,submitlocx
Declare sub StartReason,GetReason,SubmitReason
declare sub getfifoprod,getfifolot,submitfifolot
declare sub createprodlotx
Declare Function umtofactor
  
!****** includes ********
include "src/copyright.inc"
!
include "src/inc/fileprod.inc" ! product
include "src/inc/filevendtag.inc" ! vendor tag file
include "src/inc/filea80vm.inc" ! vendor file
include "src/inc/fileprodwhse.inc" ! prodwhse 
include "src/inc/filewhinfoz.inc" ! warehouse
include "src/inc/filemiscrts.inc" ! misc rts file
include "src/inc/filersnrts.inc" ! reason code
include "src/inc/filewhloc.inc" ! warehouse locations
include "src/inc/filesprodlot.inc" ! product lots
include "src/inc/filefifolot.inc" ! fifo lot
include "src/inc/filefifotrans.inc" ! fifo transaction file
! commodity code
Include "src/inc/fileprtdefault.inc" ! port default
include "src/inc/filephyslot.inc" ! physical inventory file
Include "src/inc/fileinvtrans.inc" ! inventory transaction file
include "src/inc/filespoflenz.inc"  ! PO serial # file
!
!--------------------------------------------------------------------
!
!
! ** main procedure
!
OPTION GOSUB NESTING 16  ! Default is 8
try
  !
  Dim action$[30],options$[30],userid$[8],3%,fdel$[10],bsdel$[10],esdel$[10],rdel$[10]
  Dim rstr$[5000]
  Dim 2%,WHSE
  Dim 1%,IntCo
  Dim 3%,SPREC,rec_uac
  Dim 1%,WL1[2],WLA[7],TIER$[6],BIN$[3],3%,BINTMP

  dim e$[500],buttonlist$[5,50],nextlist$[5,100] ! error handling variables
  dim Section$[30],Field$[20,30]
  dim mergedir$[60],action1$[20],action2$[30]
  dim Company$[2],keyvend$[10]
  dim xdate$[10]
  dim tmpkey$[50]
  dim 1%,editstatus,source,acceptrts
  dim 1%,ua5[10]
  dim 1%,tmp1,intSls,CTLC,errflag,WH,Div,portnum,chan[25],flag
  dim 2%,tmp2,maxcnt \ maxcnt=2000 ! max records in arrays
  dim 3%,tmp3,JDepositDate,DocNo
  DIM 3%,parm[25],ORGTOT[10]
  dim 2%,vendid,vendid$[6]
  dim 2%,currdate
  dim 4%,tmp4,VALUE_RECV,WEIGHT_RECV,CUBES_RECV,QTY_RECV 
  Dim 1%,flags[11],FLAG,CNVTU[2],ERRTYPE
  dim 3%,qty,cost,amount,baseqty,cnvta
  dim 3%,totrcvdamt,totrcvdqty,totrcvdwgt,totrcvdcube
  dim 3%,totordamt,totordqty,totordwgt,totordcube
  dim 3%,lineqty,lineum,linecost,lineextamt,lbsunit,lbsfact                                        
  dim 3%,rec_tmp,a4[1]
  dim WORK$[600]
  dim whlist$[100,100]
  dim p60$[50],p61$[256],P9$[50]
  dim List$[maxcnt,2000],sdate$[50]
  dim SList$[maxcnt,800] ! for .net selector(drop down) list
  dim logfname$[50],comment$[30]
  dim custom_customer$[30]
  dim SearKey$[64],BegKey$[64],mode$[3]
  dim Desc$[50],PayFlag$[1],RecType$[1],DocNo$[10],ARInvKey$[64],InvType$[3]
  dim tmp$[200],tmp1$[200],WebStr$[1000],Message$[200],MSG$[500]
  dim locid$[6],lotid$[12],lotflag$[1],K4$[50]
  dim tolocid$[6],tolotid$[12],3%,baseqtu
  dim blank$[200] \ blank$=" ",blank$
   Dim 1%,WPF[1023]
  ! misc rts file
  dim keymrts$[50]
  dim 3%,rec_mrts,rec_rsn
  ! poflen
  dim keyspoflen$[50]
  dim rec_spoflen
  ! product file
  Dim Prod$[12],KeyProd$[60]
  Dim 3%,rec_prod,rec_tmp
  ! warehouse location
  dim keywhloc$[50]
  dim 3%,rec_whloc
  ! product warehouse
  dim keyprwh$[30]
  dim 3%,rec_prwh
  Dim 3%,Whbld[2]
  ! sprodlot
  dim keyprlot$[50],fname$[50],keytprlot$[50]
  dim 3%,rec_prlot
  ! physical invetory
  dim keyphy$[50],keyphy2$[50],sprod$[12]
  dim 1%,ch_phy,3%,rec_phy,tagid$[6],etagid$[6]
  ! process flags
  dim 1%,wpf[1023],rtsflag,ch_tmp
  Dim 1%,cost_lev[4],2%,Q0[1]
  dim 3%,keytmp$[50],filename$[50],USR$[40]
  dim 3%,entnum,workqty,workcost,workcqty
  dim QMask$[30],PMask$[20],COSTUM$[4],QTYUM$[4]
  dim sloc$[6],eloc$[6]
  dim keyfl$[50],3%,rec_fl,transid
  dim keyft$[50],3%,rec_ft
  dim M3$[3] \ M3$="###"
  dim M10$[10] \ M10$="##########"
  dim 3%
  let tmp$=tim(4) using "&&&&&&"
  let work$=tmp$[5,6],tmp$[1,2],tmp$[3,4]
  let currdate=work$
 
  !!! define structures !!! 
  dim pr. as prod ! prod
  dim cpr. as prod ! used for reason code 99 
  dim vend. as a80vm ! vendor file
  dim vtag. as vendtag ! vendor tag file
  dim pw. as prodwhse ! prod warehouse
  dim wh. as whinfo ! warehouse file
  dim prlot. as sprodlot ! sprodlot file
  ! cc codes 
  dim prt. as prtdefault ! port defaults
  dim mrts. as miscrts ! misc rts file
  dim rsn. as rsnrts ! misc reason code file
  dim whloc. as whloc ! warehouse location
  dim fl. as fifolot ! fifo lot
  dim ft. as fifotrans ! fifo transaction file
  dim phy. as physlot ! physical inventory file
  dim ITR. as invtrans ! inventory transaction file
  dim posn. as spoflenz ! po serial #
  
  Def FNR(H) = Int(Abs(H) * 100 + .5) * .01 * Sgn(H) ! rounding to nearest penny
  !
  call dxopen()
  Call dxget("S_USER.AppID",tmp$) !company #               
                                                         
  Try Let intCo = Val(tmp$) Else Let intCo = 1 !company #  
  ctlc = OpenFile(9999,intCo) \ If ctlc = -1 Error 42 !control   ! openning with read/write
  call GetSession(e$,CTLC,options$,action$,UserID$,intCo,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$,action1$,action2$)
  call LogAccess(e$)
  
  If action$ = "CYCLE_COUNT" chain "serpcycle_count.dl4"
  
  call GetPortDefault(e$,IntCO,UserID$,portnum,rec_uac,prt.) ! get port default
  Call GetCostLevels(e$,cost_lev[],IntCo,Userid$) ! get cost security 
  mat read #ctlc,60,50;p60$; ! system flag variable
  mat read #ctlc,61,0;p61$;
  mat read #ctlc,19,50;p9$;                                                 
  Mat Read #ctlc,115,40;Q0; 
  mat read #ctlc,115,60;custom_customer$;
  let custom_customer$=rtrim$(custom_customer$)
  QMask$ = "--------,---,--#.##"                                              
  tmp$ = "#",tmp$                                                         
  If Q0[1] <= 0 Let Q0[1] = 2                                             
  If Q0[1] Let PMask$ = "-----------#.",tmp$[1,Q0[1]] !price mask
  CH_UCC=OpenFile(9988,Intco)
  if ch_ucc>=0
	if rec_uac
		mat read #ch_ucc,rec_uac,300;a4;
		whchg=Not(a4[1]) ! 0=NO DFLT WHSE CHANGE, 1=ok
	Endif
	Try close #ch_ucc else rem
  Endif

  !
  call dxget("s_view.mergedir",mergedir$)
  
  !
  
  call OpenFiles()
  
  !
  select case action$

  case "DROPLIST" !   send droplists 
    
  !================================= Begin Action Droplist ================================================
	
	  !
	  if action1$="WHINFO"
	    if prt.wh and not(whchg) ! can only use default whse
			whse=prt.wh-1
			clear whlist$[]
			whList$[0]=bsdel$,"droplistwhinfo",fdel$ ! beginning section
			whList$[1]="ID",fdel$,"WhName",fdel$ ! from droplistwhinfoz
			Try
				read record #ch_wh,whse;wh.;
			Else
				clear wh.
				wh.WhName$="Whse "+Str$(whse+1)
			End try
			whlist$[2]=Str$(whse+1),fdel$,Str$(whse+1),": ",RTrim$(wh.WhName$),fdel$
			whlist$[3]=esdel$
		Else ! send all
		 call FileDropListWhinfoz(e$,whList$[],100,ch_wh)
		Endif
		 call AddToStr(e$,rstr$,whList$[])
	  endif
	  if action1$="REASON"
		CLEAR LIST$[]
		call FileDropListRsnRts(e$,List$[],100,ch_rsn)
		call AddToStr(e$,rstr$,List$[])
	  endif
	  If Action1$="UMDROPLIST" ! doc = mrts.produmdroplist.doc
		Call DXGet("PRODID",prod$) \ prod$=UCase$(rtrim$(prod$))
		Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
		KeyProd$=Prod$
		Call DXGET("UTYPE",tmp$) ! tmp$=QTY, PRICE, COST
		rec_prod=filegetprod(e$,ch_prod,"=",1,KeyProd$,PR.) ! product mode=2 dir=1
		If rec_prod<0 ! Product record not found
			 clear PR.
			 ReturnStatus=0
			 Message$="Error, Product not found"
		else ! continue with list
			E$="" ! clear message
			if rtrim$(tmp$)="" let tmp$=" " ! is passed

			Call UMDList(e$,tmp$,ch_prod,rec_prod,List$[],IntCo,Pr.)
			Let ReturnStatus=1
			Message$="OK"
			If E$<>""
			   Let ReturnStatus=0
			   Message$=E$
			Endif
			call AddToStr(e$,rstr$,List$[])
			!Call AddToStr(e$,rstr$,esdel$) ! end of section 
		Endif ! valid prod
	  Endif ! action1=umdroplist
	 
	  If action1$="WHLOC"! droplist for warehouse locations
		returnstatus=1
		message$="OK"
		Call DXGet("WHSE",tmp$) 
		let whse=tmp$
		if whse<=0 or whse>99
			let returnstatus=0
			let message$="Invalid Warehouse Number "+str$(whse)
		endif
		call dxget("SLOC",tmp$)
		let sloc$=rtrim$(tmp$)+blank$
		call dxget("ELOC",tmp$)
		let eloc$=rtrim$(tmp$)+blank$
		clear list$[]
		LIST$[0]=bsdel$+"WarehouseLocation"+fdel$
		LIST$[1]="Location",fdel$,"Comment",fdel$
		ctr = 2                                                       
		tmpcnt = maxcnt 
		if not(returnstatus) goto endwhlocdrop:
		let keywhloc$=" ",keywhloc$
		let keywhloc$[1,2]=whse using "##"
		let keywhloc$[3,8]=sloc$[1,6]
		do
			search #ch_whloc,3,1;keywhloc$,rec_whloc,e
			if e<>0 exit dO
			let tmp3=keywhloc$[1,2]
			if tmp3<>whse exit DO
			let tmp$=keywhloc$[3,8]
			if tmp$>eloc$ exit do
			read record #ch_whloc, rec_whloc;whloc.;
			if rtrim$(whloc.loc$)<>""
				webstr$=""
				webstr$=rtrim$(whloc.Loc$),fdel$
				webstr$=webstr$,Rtrim$(whloc.Comment$),fdel$
				list$[ctr]=webstr$
				ctr=ctr+1
				If ctr > tmpcnt Let tmpcnt = expandarray(e$,List$[])
				if row>2500 ! 2501 ! need limit on data returned (row 1 used by headers)
					returnstatus=5 ! special status to tell web MORE TO COME
					!message$="WHSE="+sTR$(wHSE)+"&STAGID="+phy.tagid$+"&SPRODID="+RTrim$(pr.prodcode$)+"&"
					message$="WHSE="+sTR$(wHSE)+"&SLOC="+RTrim$(whloc.loc$)+"&"
					goto endwhlocdrop:
				Endif
			endif
               loop
	       endwhlocdrop: ! end warehouse location droplist 
               Call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string    
               Call AddToStr(e$,rstr$,esdel$) ! end of section                                       
	       Call CreateNetStatus(e$,returnstatus,message$,webstr$) 
               Call AddToStr(e$,rstr$,webstr$)
	endif   ! action1 = whloc
	  ! droplist for lots
	 If action1$="PRODLOC"! droplist for warehouse locations
	  	returnstatus=1
		message$="OK"
		Call DXGet("WHSE",tmp$) 
		let whse=tmp$
		if whse<=0 or whse>99
			let returnstatus=0
			let message$="Invalid Warehouse Number "+str$(whse)
		endif
		Call DXGet("PRODID",prod$) \ prod$=UCase$(rtrim$(prod$))
		Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
		KeyProd$=Prod$
		!Call DXGET("UTYPE",tmp$) ! tmp$=QTY, PRICE, COST
		rec_prod=filegetprod(e$,ch_prod,"=",1,KeyProd$,PR.) ! product mode=2 dir=1
		If rec_prod<0 ! Product record not found
			 clear PR.
			 ReturnStatus=0
			 Message$="Error, Product not found"
		endif	
		clear list$[]
	    LIST$[0]=bsdel$+"ProductLocation"+fdel$
		LIST$[1]="Location",fdel$,"QtyOnHand",fdel$,"QtyAvail",fdel$
		ctr = 2                                                       
		tmpcnt = maxcnt 
		if not(returnstatus) goto endprodlotdrop:
		let totrec=0
		let keyprlot$=" ",keyprlot$
		let keyprlot$[1,12]=prod$
		let keyprlot$[13,14]=whse using "##"
		do
			search #ch_sprodlot,3,2;keyprlot$,rec_prlot,e
			if e<>0 exit dO
			if keyprlot$[1,12]<>prod$[1,12] exit do
			let tmp3=keyprlot$[13,14]
			if tmp3<>whse exit DO
			read record #ch_sprodlot, rec_prlot;prlot.;
			if rtrim$(prlot.loc$)<>""
				webstr$=""
				webstr$=rtrim$(prlot.Loc$),fdel$
				! LET ONHND=ONHND+(P3[0]-P3[1])    
				! LET AVAL=AVAL+(P3[0]-P3[1]-P3[3])
				! qty on hand =
				 X3=0
				LET CNVTA=PRLOT.QtyRcvd-prlot.qtyused
				CNVTU[0] = 0;CNVTU[1] = pr.UMStkDefault;CNVTU[2] = 1    
     				If CNVTA <> 0                                           
					X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)   
				End If                                                  
				WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty on hand
				
				! qty avail = 
				x3=0
				let cnvta=PRLOT.QtyRcvd-prlot.qtyused-prlot.QtyAlloc
				CNVTU[0] = 0;CNVTU[1] = pr.UMStkDefault;CNVTU[2] = 1    
     				If CNVTA <> 0                                           
					X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)   
				End If                                                  
				WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty available
				list$[ctr]=webstr$
				ctr=ctr+1
				If ctr > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
				totrec=totrec+1
			endif
               loop
	       if not(totrec) ! add stock as a location
			webstr$=""
			webstr$="STOCK",fdel$
			 X3=0                                 
			WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty on hand
			WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty available
			list$[ctr]=webstr$
			ctr=ctr+1
			If ctr > tmpcnt Let tmpcnt = expandarray(e$,List$[])
		   endif
	       endprodlotdrop: ! end warehouse location droplist 
               Call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string    
               Call AddToStr(e$,rstr$,esdel$) ! end of section                                       
	       Call CreateNetStatus(e$,returnstatus,message$,webstr$) 
               Call AddToStr(e$,rstr$,webstr$)  
		  endif !!! droplist for product lots/location
		If action1$="PRODLOTLOC"! droplist for prod/whse/lot and locations
			returnstatus=1
			message$="OK"
			Dim dfltrloc$[6],dfltcmloc$[6],dfltdock$[6]
			MAT  READ #ctlc,69,52;DFLTRLOC$;    
			MAT  READ #ctlc,69,160;DFLTCMLOC$;
			let dfltdock$="DOCK"
			Call DXGet("WHSE",tmp$) 
			let whse=tmp$
			if whse<=0 or whse>99
				let returnstatus=0
				let message$="Invalid Warehouse Number "+str$(whse)
			endif
			Call DXGet("PRODID",prod$) \ prod$=UCase$(rtrim$(prod$))
			Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
			KeyProd$=Prod$
			!Call DXGET("UTYPE",tmp$) ! tmp$=QTY, PRICE, COST
			rec_prod=filegetprod(e$,ch_prod,"=",1,KeyProd$,PR.) ! product mode=2 dir=1
			If rec_prod<0 ! Product record not found
				clear PR.
				ReturnStatus=0
				Message$="Error, Product not found"
			endif
			Call DXGet("RASL",tmp$) \ Let Rasl=0
			if UCASE$(rtrim$(tmp$))="Y" let RASL=99
			Call DXGet("LOTCNTRL",tmp$) \ Let lotflag=0
			if UCASE$(rtrim$(tmp$))="Y" let lotflag=99
			if rasl=0 and lotflag=0
				returnstatus=0
				message$="Error, No Location or Lot for this Product"
			endif
			Call Dxget ("UMID",tmp$)
			let umid=tmp$
			if not(umid) let umid=pr.UMStkDefault
			if custom_customer$="ACME" or custom_customer$="SWP"
				if rtrim$(dfltdock$)=rtrim$(dfltrloc$) let dfltdock$=""
				if rtrim$(dfltdock$)=rtrim$(dfltcmloc$) let dfltdock$=""
				if rtrim$(dfltrloc$)=rtrim$(dfltcmloc$) let dfltcmloc$=""
				if rtrim$(dfltrloc$)<>""
					Keywhloc$ = " ",Keywhloc$                        
					Keywhloc$[1,2] = whse Using "##" 
					keywhloc$[3,8]= rtrim$(dfltrloc$)+blank$
					Search #CH_WHLOC,2,1;Keywhloc$,rec_whloc,e
					if e<>0
						let dfltrloc$=""
					endif
				endif
				if rtrim$(DFLTCMLOC$)<>""
					Keywhloc$ = " ",Keywhloc$                        
					Keywhloc$[1,2] = whse Using "##" 
					keywhloc$[3,8]= rtrim$(dfltcmloc$)+blank$
					Search #CH_WHLOC,2,1;Keywhloc$,rec_whloc,e
					if e<>0
						let dfltcmloc$=""
					endif
				endif
				if rtrim$(DFLTDOCK$)<>""
					Keywhloc$ = " ",Keywhloc$                        
					Keywhloc$[1,2] = whse Using "##" 
					keywhloc$[3,8]= rtrim$(dfltDOCK$)+blank$
					Search #CH_WHLOC,2,1;Keywhloc$,rec_whloc,e
					if e<>0
						let dfltdock$=""
					endif
				endif
			endif		
			clear list$[]	
			LIST$[0]=bsdel$+"ProdLocLot"+fdel$
			let webstr$=""
			let webstr$="Location",fdel$,"Lot",fdel$
			let webstr$=webstr$,"DateRecd",fdel$,"QtyRecd",fdel$
			let webstr$=webstr$,"LastUsed",fdel$,"QtyUsed",fdel$
			let webstr$=webstr$,"QtyOnOrd",fdel$,"QtyAvail",fdel$
			LIST$[1]=webstr$
			ctr = 2                                                       
			tmpcnt = maxcnt 
			if not(returnstatus) goto endprlotlocdrop:
			let totrec=0
			let keyprlot$=" ",keyprlot$
			let keyprlot$[1,12]=prod$
			let keyprlot$[13,14]=whse using "##"
			do
				search #ch_sprodlot,3,2;keyprlot$,rec_prlot,e
				if e<>0 exit dO
				if keyprlot$[1,12]<>prod$[1,12] exit do
				let tmp3=keyprlot$[13,14]
				if tmp3<>whse exit DO
				read record #ch_sprodlot, rec_prlot;prlot.;
				webstr$=""
				if rasl<>0
					webstr$=rtrim$(prlot.Loc$),fdel$
				else
					let tmp$=""
					webstr$=tmp$,fdel$
				endif
				if lotflag<>0
					let webstr$=webstr$+rtrim$(prlot.LotNum$),fdel$
				else
					let tmp$=""
					let webstr$=webstr$,tmp$,fdel$
				endif
				let tmp$=prlot.DateRcvd using "&&&&&&"
				let webstr$=webstr$,tmp$[3,4],"/",tmp$[5,6],"/",tmp$[1,2],fdel$
				X3=0
				LET CNVTA=PRLOT.QtyRcvd
				CNVTU[0] = 0;CNVTU[1] = umid;CNVTU[2] = 1    
     			If CNVTA <> 0                                           
					X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)   
				End If                                                  
				WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty on received
				let tmp$=prlot.LastDateUsed using "&&&&&&"
				let webstr$=webstr$,tmp$[3,4],"/",tmp$[5,6],"/",tmp$[1,2],fdel$
				X3=0
				LET CNVTA=prlot.qtyused
				CNVTU[0] = 0;CNVTU[1] = pr.UMStkDefault;CNVTU[2] = 1    
     			If CNVTA <> 0                                           
					X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)   
				End If                                                  
				WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty on used
				X3=0
				LET CNVTA=prlot.QtyAlloc
				CNVTU[0] = 0;CNVTU[1] = umid;CNVTU[2] = 1    
     			If CNVTA <> 0                                           
					X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)   
				End If                                                  
				WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty on order 
				x3=0
				let cnvta=PRLOT.QtyRcvd-prlot.qtyused-prlot.QtyAlloc
				CNVTU[0] = 0;CNVTU[1] = umid;CNVTU[2] = 1    
     			If CNVTA <> 0                                           
					X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)   
				End If                                                  
				WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty available
				list$[ctr]=webstr$
				ctr=ctr+1
				If ctr > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
				totrec=totrec+1
				if custom_customer$="ACME" OR Custom_customer$="SWP"
					if rtrim$(prlot.Loc$)=rtrim$(DFLTRLOC$) let dfltrloc$=""
					if rtrim$(prlot.Loc$)=rtrim$(dfltcmloc$) let dfltcmloc$=""
					if rtrim$(prlot.loc$)=rtrim$(dfltdock$) let dfltdock$=""
				endif
			loop
			
			if custom_customer$="ACME" or custom_customer$="SWP"
				let tmp$="STOCK"+(WHSE USING "&&")
				if rtrim$(DFLTRLOC$)<>"" 
					webstr$=""
					webstr$=rtrim$(DFLTRLOC$),fdel$ ! Location
					webstr$=webstr$+tmp$,fdel$! lot
					webstr$=webstr$+"00/00/00",fdel$ ! date recd
					X3=0                                 
					WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty rec
					webstr$=webstr$+"00/00/00",fdel$ ! last used
					WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty used
					WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty on ord
					WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty available
					totrec=totrec+1
					list$[ctr]=webstr$
					ctr=ctr+1
					If ctr > tmpcnt Let tmpcnt = expandarray(e$,List$[])
				endif
				if rtrim$(dfltcmloc$)<>""
					webstr$=""
					webstr$=rtrim$(DFLTCMLOC$),fdel$
					webstr$=webstr$+tmp$,fdel$! lot
					webstr$=webstr$+"00/00/00",fdel$ ! date recd
					X3=0                                 
					WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty rec
					webstr$=webstr$+"00/00/00",fdel$ ! last used
					WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty used
					WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty on ord
					WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty avail
					totrec=totrec+1
					list$[ctr]=webstr$
					ctr=ctr+1
					If ctr > tmpcnt Let tmpcnt = expandarray(e$,List$[])
				endif			
				if rtrim$(dfltdock$) <>""
					webstr$=""
					webstr$=rtrim$(DFLTDOCK$),fdel$
					webstr$=webstr$+tmp$,fdel$! lot
					webstr$=webstr$+"00/00/00",fdel$ ! date recd
					X3=0                                 
					WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty rec
					webstr$=webstr$+"00/00/00",fdel$ ! last used
					WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty used
					WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty on ord
					WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty avail
					totrec=totrec+1
					list$[ctr]=webstr$
					ctr=ctr+1
					If ctr > tmpcnt Let tmpcnt = expandarray(e$,List$[])
				endif
			endif
			if not(totrec) ! add stock as a location
				let returnstatus=0
				let message$="No Lots/Locations Available for Product"
			endif
			endprlotlocdrop: ! end product lot/location droplist 
			Call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string    
			Call AddToStr(e$,rstr$,esdel$) ! end of section                                                                        
			Call CreateNetStatus(e$,returnstatus,message$,webstr$)
			Call AddToStr(e$,rstr$,webstr$)
		!!! end droplist for product lots/ locations
		!endif   ! action1 = whloc
       Endif   ! end droplist -- sent output
	  ! droplist for entries
	  If action1$="MISCENT"! droplist for misc receipts entry
		returnstatus=1
		message$="OK"
		Call DXGet("WHSE",tmp$) 
		let whse=tmp$
		clear list$[]
		LIST$[0]=bsdel$+"MiscEntryList"+fdel$
		LIST$[1]="EntryNum",fdel$,"Product",fdel$,"Description",fdel$,"Comment",fdel$,"Whse",fdel$
		ctr = 2                                                       
		tmpcnt = maxcnt 
		if not(returnstatus) goto endmiscentdrop:
		let keymrts$=" ",keymrts$
		do
			search #ch_mrts,3,1;keymrts$,rec_mrts,e
			if e<>0 exit dO
			read record #ch_mrts,rec_mrts,0;mrts.;
			if whse<>0 and whse<>mrts.whse goto getnxtent:
			if mrts.ProntoAcpt<>0 goto getnxtent: ! already accept
			if mrts.qty=0 and mrts.qtylbs=0 goto getnxtent: ! already deleted
			if mrts.status<>0 goto getnxtent: ! in journal /accept process
			KeyProd$=mrts.ProdCode$
			rec_prod=filegetprod(e$,ch_prod,"=",1,KeyProd$,PR.) ! product mode=2 dir=1
			If rec_prod<0 ! Product record not found
				goto getnxtent:
			endif
			webstr$=""
			webstr$=str$(mrts.entrynum),fdel$
			webstr$=webstr$+rtrim$(mrts.prodcode$),fdel$
			webstr$=webstr$+rtrim$(pr.desc1$),fdel$
			webstr$=webstr$+rtrim$(mrts.comment$),fdel$
			webstr$=webstr$+str$(mrts.whse),fdel$
			list$[ctr]=webstr$
			ctr=ctr+1
			If ctr > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
			getnxtent: ! 
               loop
	       endmiscentdrop: ! end warehouse location droplist 
               Call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string    
               Call AddToStr(e$,rstr$,esdel$) ! end of section                                       
	       Call CreateNetStatus(e$,returnstatus,message$,webstr$) 
               Call AddToStr(e$,rstr$,webstr$)                        
	endif   ! action1 = miscentry
          call SetOutput(e$,rstr$)

CASE "STARTMRTS" !  set flags and sends warehouse list
	let returnstatus=1
	let message$="OK"
	ch_tmp=findchannel()
	read #ch_wh,99,900;wpf;
    if wpf[323]<>0 or wpf[324]<>0 !        
		IF WPF[323]<>0                                                          
			LET UIDREC=WPF[323]
			REturnstatus=0
			let message$="Misc RTS Delete(323) in Process "
			E=3  ! CHECK with time check
			call "proglock.dl4","321",e,message$  !! no special flag for delete
			if not(e)  !! did not find entry
				! remove other locking
				read #ch_wh,99,900;wpf
				wpf[323]=0  ! if UIDREC=WPF[323] then wpf[323]=0
				write #ch_wh,99,900;wpf;
			else
				If UIDRec > 0                           
					USR$ = GetUIDInfo$(e$,IntCo,UIDRec) 
					message$=message$+"By User "+rtrim$(usr$[21])
				endif
				goto endstartmrts:
			endif
		endif                
		IF WPF[324]<>0                                                          
			LET UIDREC=WPF[324]
			REturnstatus=0
			let message$="Misc RTS Accept (324) in Process "
			message$="checking lock"
			e=3 ! check if flag set  with time checking
			call "proglock.dl4","324",e,message$
			if not(e)  !! did not find entry
				! remove other locking
				read #ch_wh,99,900;wpf
				wpf[324]=0  !if UIDREC=WPF[324] then wpf[324]=0
				write #ch_wh,99,900;wpf;
			else
				If UIDRec > 0                           
					USR$ = GetUIDInfo$(e$,IntCo,UIDRec)  
					message$=message$+"By User "+rtrim$(usr$[21])
				endif
				goto endstartmrts:
			Endif
		endif                                                                                                 
	endif

  	mat read #ctlc,20,0;rtsflag;
	if rtsflag<=2 goto setmrtsflags:
	if rtsflag=3
		e=3  !! search for prog entry
		call "proglock.dl4","321",e,message$  ! no flag for 323
		if not(e)
			mat read #ctlc,20,0;rtsflag
			if rtsflag=3 then rtsflag=2   ! 2 MEANS ENTRIES IN FILE
			mat write #ctlc,20,0;rtsflag;
		else
			let returnstatus=0
			let message$="Program (323) Misc Receipts to Stock Delete is in Process Elsewhere"
			goto endstartmrts:
		endif
	endif
	if rtsflag>=4
		e=3  !! search for prog entry
		call "proglock.dl4","324",e,message$
		if not(e)
			mat read #ctlc,20,0;rtsflag
			if rtsflag=4 then rtsflag=2
			mat write #ctlc,20,0;rtsflag;
		else
			let returnstatus=0
			let message$="Misc Receipts to Stock Accept (324) is in Process Elsewhere"
			goto endstartmrts:
		endif
	endif

	setmrtsflags: ! 
	if p9$[17,17]="Y"
		ch_tmp=findchannel()
		let filename$="6/GLMRSTEMP"+STR$(INTCO)
		open #ch_tmp,filename$
		let keytmp$=" ",keytmp$
		search #ch_tmp,2,1;keytmp$,rec_tmp,e
		if not(e)
			e=5  !! search for prog entry
			call "proglock.dl4","324A",e,message$
			if not(e)
				!! looks ok to clear glmrstemp
				let keytmp$=" ",keytmp$
clrloop:		search #ch_tmp,3,1;keytmp$,rec_tmp,e
				if not(e)
					search #ch_tmp,5,1;keytmp$,rec_tmp,e
					e=3
					search #ch_tmp,1,0;keytmp$,rec_tmp,e
					goto clrloop:
				endif
			else
				let returnstatus=0
				let message$="Misc Receipt To Stock Being Updated Elsewhere. Try Later."
				goto endstartmrts:
			endif
		endif
		
	endif
	MAT  READ #ctlc,20;rtsflag                                                                        
	IF rtsflag=0 OR rtsflag=2 !no one in entry at this time                          
		LET rtsflag=1                                                            
	ENDIF                                                                
	MAT  WRITE #ctlc,20;rtsflag;                                           
	IF rtsflag<>1                                                              
		let returnstatus=0
		let message$="MISC RECEIPTS TO STOCK STATUS PROBLEMS!! "      
	endif                                               
	endstartmrts: ! this is it
	! PRONTO ACCEPT
	clear list$[]
	let list$[0]=bsdel$,"PRONTOACCEPT",fdel$
	webstr$ = "PromptAcceptFlag",fdel$                             
	list$[1]=webstr$
	webstr$=p60$[45,45],fdel$
	list$[2]=webstr$
	call AddToStr(e$,rstr$,List$[]) 
	Call AddToStr(e$,rstr$,esdel$)	! end of section 
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
    call SetOutput(e$,rstr$) ! "STARTMISCRTS"
	message$="do a lock"
	call "proglock.dl4","321",1,message$

Case "EXITMRTS"
	returnstatus=1
	message$="OK"
	MAT  READ #Ctlc,20;rtsflag                                                   
	IF rtsflag<>1 AND rtsflag<>2                                                    
		 MAT  READ #ctlc,20;rtsflg;                                                
		 message$="MISC RECEIPTS TO STOCK STATUS PROBLEMS!! " 
	ENDIF                                                               
	REM KEEP TRACK OF PORTS USING 321                                   
	MAT  READ #ch_wh,99,900;WPF                                            
	LET I=321                                                           
	IF WPF[321]=UIDREC[1] LET WPF[I]=0                                  
	MAT  WRITE #ch_wh,99,900;WPF;                                          
	LET rtsflag=2                                                             
	FOR I=0 TO 1023                                                     
		IF WPF[I]=321 LET rtsflag=1                                             
	NEXT I                                                              
	MAT  WRITE #ctlc,20;rtsflag;   
	message$="do a unlock"
	call "proglock.dl4","321",0,message$
                                                    
	endexitmrts: ! this is it
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutput(e$,rstr$) ! "EXITMISCRTS"

Case "GETPRODDETAIL"
	returnstatus=1
	message$="OK"
	call getproddetail()

Case "SUBMITMRTS"
	returnstatus=1
	message$="OK"
	call submitmrts()
	message$="do a lock"
	call "proglock.dl4","321",1,message$

Case "GETMRTSENTRY"
	returnstatus=1
	message$="OK"
	call getmrtsentry()

Case "STARTREASON"
	! gl acct droplist, reason code, 
	returnstatus=1
	message$="OK"
	call startreason()

Case "GETREASON"
	! gets an unique reason code
	returnstatus=1
	message$="OK"
	call getreason()



Case "SUBMITREASON"
	returnstatus=1
	message$="OK"
	call submitreason()

!  774 Location transfer calls
Case "GETPRODXFER" ! product info for location transfer 774
	returnstatus=1
	message$="OK"
	call getprodxfer()

Case "GETTOPRLOTLOC" ! location transfer 774
	call gettoprlotloc()

Case "SUBMITLOCX"	! location transfer 774
	dim tprlot. as sprodlot ! sprodlot file to lot/location
	ch_invtr = OpenFile(2512,intCo) \ If ch_invtr = -1 Error 42
	call submitlocx()

! 792 fifo lot cost / date edit
Case "GETFIFOPROD"
	returnstatus=1
	message$="OK"
	call getfifoprod()
	! 

Case "GETFIFOLOT"
	returnstatus=1
	message$="OK"
	call getfifolot()


Case "SUBMITFIFOLOT"
	returnstatus=1
	message$="OK"
	call submitfifolot()
! --- End 693 Manual Physical Inventory
CASE "STARTPHY" !  set flags and sends warehouse list
	let returnstatus=1
	let message$="OK"
	! whse droplist
	Call FileDropListWhinfoz(e$,whList$[],100,ch_wh)  
	Call AddToStr(e$,rstr$,whList$[])
	! Default Warehouse
	clear list$[]
	let list$[0]=bsdel$,"DfltWhse",fdel$
	webstr$ = "DfltWhse",fdel$                             
	list$[1]=webstr$
	let tmp3=prt.wh
	if tmp3<=0 or tmp3>99 let tmp3=1
	webstr$=str$(tmp3),fdel$ !!!
	list$[2]=webstr$
	list$[3]=esdel$
	call AddToStr(e$,rstr$,List$[]) 
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutput(e$,rstr$) ! StartPhys

CASE "VERIFYPHYWH" !  Verify if physical inventory is being updated for this warehouse
	let returnstatus=1
	let message$="OK"
	clear wh.
	let rasl=0
	Call DXGet("WHSE",tmp$) 
	let whse=tmp$
	if whse<1 or whse>99
		let returnstatus=0
		let message$="Invalid Warehouse Submitted"
		goto endverifyphywh
	endif
	if returnstatus<>0
		LET fname$="cntrl/puip"
		let tmp$=intco using "#" 
		let fname$=fname$+tmp$
		let tmp$=whse using "&&"
		let fname$=fname$+tmp$
		Call FindF(Fname$,fileflag)
		if fileflag<>0
			let returnstatus=0
			let message$="Physical Inventory Accept is in process. No Entry Allowed. "
			goto endverifyphywh
		endif
	endif
	let rec=whse-1
	read record #ch_wh,rec;wh.;
	let rasl=0
	If P9$[41,41] = "W" !  LET SRASL=1      
		If wh.UseRasl <> 0 Let rasl = 99
	endif
	if p9$[41,41]="Y" let rasl=99
	If rasl<>0
		let wh.binmask$="AAAAAA" ! set to anything must match a location
	else
		FOR ctr=1 TO 6 
			if wh.binmask$[ctr,ctr]="" or wh.binmask$[ctr,ctr]=" " let wh.binmask$[ctr,ctr]="A"
		next ctr
	endif
                                               
                                                                     

        endverifyphywh: ! end verify warehouse
        clear list$[]
	let list$[0]=bsdel$,"WhseFlags",fdel$
	webstr$ = "RASL",fdel$,"BinMask",fdel$,"TAGLOC",fdel$                           
	list$[1]=webstr$
	let tmp$="N"
	if rasl<>0 let tmp$="Y"
	webstr$=tmp$,fdel$ !!!
	webstr$=webstr$,rtrim$(wh.BinMask$),fdel$
	let tmp$="N"
	if rasl<>0 and wh.tagloc$="Y" let tmp$="Y"
	webstr$=webstr$,tmp$,fdel$
	list$[2]=webstr$
	list$[3]=esdel$
	call AddToStr(e$,rstr$,List$[]) 
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutput(e$,rstr$) ! StartPhys


CASE "VERIFYPHYTAG" !  Verify if physical inventory tag number being used
	let returnstatus=1
	let message$="OK"
	clear wh.
	let rasl=0
	Call DXGet("WHSE",tmp$) 
	let whse=tmp$
	if whse<1 or whse>99
		let returnstatus=0
		let message$="Invalid Warehouse Submitted"
		goto endverifyphytag
	endif
	let rec=whse-1
	read record #ch_wh,rec;wh.;
	let rasl=0
	If P9$[41,41] = "W" !  LET SRASL=1      
		If wh.UseRasl <> 0 Let rasl = 1
	endif
	if p9$[41,41]="Y" let rasl=99
	If rasl<>0
		let wh.binmask$="AAAAAA" ! set to anything must match a location
	else
		FOR ctr=1 TO 6 
			if wh.binmask$[ctr,ctr]="" or wh.binmask$[ctr,ctr]=" " let wh.binmask$[ctr,ctr]="A"
		next ctr
	endif
    Call DXGet("TAGID",tmp$) 
	let TAGID$=rtrim$(tmp$)
	if rtrim$(tagID$)="" or len (tagID$)>6
		let returnstatus=0
		let message$="Invalid Tag Id Submitted"
		goto endverifyphytag
	endif                                                 
	IF len(tagid$)<6 let tagid$=tagid$+"      "
	let tagok=0
	if tagid$[1,5]="STOCK"
		LET TAGOK=99
	ELSE
		IF NOT(RASL)
			IF WH.BINMASK$="AAAAAA"
				LET TAGOK=99
				LET wh.tagloc$="N"
			ELSE
				dim 1%,testpos
				for ctr=1 to 6
					if wh.binmask$[ctr,ctr]="" or wh.binmask$[ctr,ctr]=" " let wh.binmask$[ctr,ctr]="A"
					if wh.binmask$[ctr,ctr]="A"
						! rem ok
					else
						if wh.binmask$="L"
							if tagid$[ctr,ctr]>"@" AND tagid$[ctr,ctr]<"["
								! rem ok 
							else
								goto endchkloc:
							endif
						else
							if wh.binmask$="N"
								if tagid$[ctr,ctr]>"/" AND tagid$[ctr,ctr]<":"
									! rem ok 
								else
									goto endchkloc:
								endif
							endif
						endif
					endif
				next ctr
				tagok=99
				endchkloc: ! end checking the location
				if not(tagok)
					let returnstatus=0
					let message$="Invalid Format for Tag "+rtrim$(tagid$)
				endif
			endif
		else
			let tagok=99
			if wh.TagLoc$="Y" ! check if location is in warehouse
				Keywhloc$ = " ",Keywhloc$                        
				Keywhloc$[1,2] = whse Using "##" 
				keywhloc$[3,8]=tagid$
				Search #CH_WHLOC,2,1;Keywhloc$,rec_whloc,e
				if e<>0
					let message$="Tag Location "+rtrim$(tagid$)+" has not be defined for warehouse "+str$(whse)
					let returnstatus=0
					tagok=0
				endif
			endif
		endif
	endif
	endverifyphytag:! verify tag number entered is ok
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutput(e$,rstr$) ! VERIFYPHYTAG


CASE "VERIFYPHYPROD" !  Verify if physical inventory product being used
	let returnstatus=1
	let message$="OK"
	clear wh.
	let rasl=0
	Call DXGet("WHSE",tmp$) 
	let whse=tmp$
	if whse<1 or whse>99
		let returnstatus=0
		let message$="Invalid Warehouse Submitted"
		goto endverifyphyprod
	endif
	let rec=whse-1
	read record #ch_wh,rec;wh.;
	let rasl=0
	If P9$[41,41] = "W" !  LET SRASL=1      
		If wh.UseRasl <> 0 Let rasl = 1
	endif
	if p9$[41,41]="Y" let rasl=99
        !Call DXGet("TAGID",tmp$) 
	!let TAGID$=rtrim$(tmp$)
	!if rtrim$(tagID$)="" or len (tagID$)>6
	!	let returnstatus=0
	!	let message$="Invalid Tag Id Submitted"
	!	goto endverifyphyprod
	!endif                                                 
	!IF len(tagid$)<6 let tagid$=tagid$+"      "
	Call DXGet("PRODID",prod$) \ prod$ = UCase$(rtrim$(prod$))                  
	prod$ = prod$ + blank$ \ If Len(prod$) > 12 Let prod$[13] = ""      
	Keyprod$ = prod$                                                                       
	rec_prod = filegetprod(e$,ch_prod,"=",1,Keyprod$,pr.) ! product mode
                                                                    
	If rec_prod < 0 ! Product record not found                          
		Clear pr.                                                         
		ReturnStatus = 0                                                  
		Message$ = "Product "+rtrim$(keyprod$)+" Not on File "
		goto endverifyphyprod:
	endif
	if p61$[59,59]="Y" ! verify if product belongs in that warehouse
		Keyprwh$ = " ",Keyprwh$                                                   
		Keyprwh$[1,12] = prod$[1,12]                                              
		Keyprwh$[13] = whse Using "##"                                            
		rec_prwh = filegetprodwhse(e$,ch_prwh,"=",1,Keyprwh$,pw.,e)               
		If rec_prwh < 0 ! NOT FOUND                                               
			Clear pw.                                                               
			returnstatus=0      
			Message$ = "Product " + RTrim$(prod$) + " Not Available In Warehouse "+str$(whse)
			goto endverifyphyprod: !  
		endif
        End If                                                                  
                                              
	endverifyphyprod:! verify tag number entered is ok
	! set list header                                                         
	Clear List$[]                                                             
	List$[0] = bsdel$,"PRODPHYDETAIL",fdel$                                   
	WebStr$ = "ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$                         
	WebStr$ = WebStr$,"QtyUm1",fdel$,"QtyUmId1",fdel$,"QtyFactor1",fdel$ ! default stock unit of measure
	WebStr$ = WebStr$,"QtyUm2",fdel$,"QtyUmId2",fdel$,"QtyFactor2",fdel$ ! default base unit of measure
	WebStr$ = WebStr$,"RASL",fdel$,"LotCntrl",fdel$,"CatchWgt",fdel$                                                              
	List$[1] = WebStr$
	row=2
	if returnstatus<>0
		 WebStr$ = RTrim$(pr.prodcode$),fdel$      
		 WebStr$ = WebStr$,RTrim$(pr.desc1$),fdel$ 
		 WebStr$ = WebStr$,RTrim$(pr.desc2$),fdel$ 
		! QTY 1 - DEFAULT STOCKING UNIT OF MEASURE
		!Webstr$=Webstr$,"QtyUm",fdel$,"QtyUmId",fdel$,"QtyFactor",fdel$
		qtyum$ = XUnit$(pr.UMStkDefault,ch_ccode) ! u/m                 
		WebStr$ = WebStr$,RTrim$(qtyum$),fdel$     ! UM NAME                      
		WebStr$ = WebStr$,Str$(pr.UMStkDefault),fdel$ ! UM REC #                   
		X3 = umtofactor(pr.UMStkDefault) ! get qty um factor  ! FACTORE           
		WebStr$ = WebStr$,Str$(X3),fdel$ ! qty factor   
		! QTY 2 - DEFAULT BASE UNIT OF MEASURE
		qtyum$ = XUnit$(pr.BaseUM,ch_ccode) ! u/m                 
		WebStr$ = WebStr$,RTrim$(qtyum$),fdel$                          
		WebStr$ = WebStr$,Str$(pr.BaseUM),fdel$                   
		X3 = umtofactor(pr.BaseUM) ! get qty um factor            
		WebStr$ = WebStr$,Str$(X3),fdel$ ! qty factor 
		! rasl check                            
		tmp$ = "N"                              
		If P9$[41,41] = "Y" Let tmp$ = "Y"      
		If P9$[41,41] = "W" !  LET SRASL=1      
			If whse > 0 And whse < 100            
				Read Record #ch_wh,(whse - 1),0;wh.;
				If wh.UseRasl<> 0 Let tmp$ = "Y" 
			End If                                
		End If                                  
		WebStr$ = WebStr$,tmp$,fdel$   
		! LOT CONTROL                                  
		tmp$ = "N"                                                     
		If P9$[1,1] = "Y" Let tmp$ = "Y"                               
		If pr.LotCtrl$ = "Y" Let tmp$ = "Y"                            
		If pr.CatchwgtItem$ = "Y" Let tmp$ = "N" ! catch weight item   
		WebStr$ = WebStr$,tmp$,fdel$ ! lot control                     
		WebStr$ = WebStr$,pr.CatchwgtItem$,fdel$ 
		LIST$[2]=webstr$
		row=3
        endif
	let list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutput(e$,rstr$) ! VERIFYPHYPROD


CASE "GETPHYENT" !  Verify the lot and verify location if needed
	let returnstatus=1
	let message$="OK"
	clear wh.
	let rasl=0
	Call DXGet("WHSE",tmp$) 
	let whse=tmp$
	if whse<1 or whse>99
		let returnstatus=0
		let message$="Invalid Warehouse Submitted"
		goto endverifyphyentry
	endif
	let rec=whse-1
	read record #ch_wh,rec;wh.;
	let rasl=0
	If P9$[41,41] = "W" !  LET SRASL=1      
		If wh.UseRasl <> 0 Let rasl = 1
	endif
	if p9$[41,41]="Y" let rasl=99
        Call DXGet("TAGID",tmp$) 
	let TAGID$=rtrim$(tmp$)
	if rtrim$(tagID$)="" or len (tagID$)>6
		let returnstatus=0
		let message$="Invalid Tag Id Submitted"
		goto endverifyphyentry
	endif                                                 
	IF len(tagid$)<6 let tagid$=tagid$+"      "
	Call DXGet("PRODID",prod$) \ prod$ = UCase$(rtrim$(prod$))                  
	prod$ = prod$ + blank$ \ If Len(prod$) > 12 Let prod$[13] = ""      
	Keyprod$ = prod$                                                                       
	rec_prod = filegetprod(e$,ch_prod,"=",1,Keyprod$,pr.) ! product mode
                                                                    
	If rec_prod < 0 ! Product record not found                          
		Clear pr.                                                         
		ReturnStatus = 0                                                  
		Message$ = "Product "+rtrim$(keyprod$)+" Not on File "
		goto endverifyphyentry:
	endif
	if p61$[59,59]="Y" ! verify if product belongs in that warehouse
		Keyprwh$ = " ",Keyprwh$                                                   
		Keyprwh$[1,12] = prod$[1,12]                                              
		Keyprwh$[13] = whse Using "##"                                            
		rec_prwh = filegetprodwhse(e$,ch_prwh,"=",1,Keyprwh$,pw.,e)               
		If rec_prwh < 0 ! NOT FOUND                                               
			Clear pw.                                                               
			returnstatus=0      
			Message$ = "Product " + RTrim$(prod$) + " Not Available In Warehouse "+str$(whse)
			goto endverifyphyentry: !  
		endif
        End If                                                                  
        ! verify if entry lot if needed
	lotflag$ = "N"                                                     
	If P9$[1,1] = "Y" Let lotflag$ = "Y"                               
	If pr.LotCtrl$ = "Y" Let lotflag$ = "Y"                            
	If pr.CatchwgtItem$ = "Y" Let lotflag$ = "N" ! catch weight item 
	if lotflag$="N"
		let lotid$=whse using "STOCK&&"
		let lotid$=lotid$+blank$
	else

		Call DXGet("LOTID",tmp$)
		let tmp$=rtrim$(tmp$)
		if len(tmp$)>6
			let returnstatus=0
			let message$="Lot may only be a max of 6 characters"
			goto endverifyphyentry:
		endif
		if len(tmp$)<=0
			let returnstatus=0
			let message$="Invalid Lot Submitted"
			goto endverifyphyentry:
		endif
		lotid$ = UCase$(tmp$)
		let lotid$=lotid$+blank$
		if lotid$[1,5]="STOCK"
			let lotid$=whse using "STOCK&&"
			let lotid$=lotid$+blank$
		endif
	endif
	if not (rasl)
		let locid$="STOCK "
	else
		Call DXGet("LOCID",tmp$)
		let tmp$=rtrim$(tmp$)
		if len(tmp$)>6
			let returnstatus=0
			let message$="Location may only be a max of 6 characters"
			goto endverifyphyentry:
		endif
		if len(tmp$)<=0
			let returnstatus=0
			let message$="Invalid Location Submitted"
			goto endverifyphyentry:
		endif	
		locid$ = UCase$(tmp$)
		let locid$=locid$+blank$
		if locid$[1,6]<>"STOCK "
			Keywhloc$ = " ",Keywhloc$                        
			Keywhloc$[1,2] = whse Using "##" 
			keywhloc$[3,8]=locid$
			Search #CH_WHLOC,2,1;Keywhloc$,rec_whloc,e
			if e<>0
				let message$="Location "+rtrim$(locid$)+" has not be defined for warehouse "+str$(whse)
				let returnstatus=0
				goto endverifyphyentry:
			endif
		endif
	endif
	let rec_prlot=0
	if lotflag$="Y"
		! validate the lotnumber
		! if lotid$[1,5]<>"STOCK"
			let keyprlot$=" ",keyprlot$
			let keyprlot$[1,12]=pr.prodcode$
			let keyprlot$[13,14]=whse using "##"
			let keyprlot$[15,26]=lotid$
			Do
				! KEYPRLOT$ = " ",KEYPRLOT$                 
				Search #Ch_sprodlot,3,4;KEYPRLOT$,rec_prlot,e
				IF e<>0 
					if lotid$[1,5]<>"STOCK"
						let message$="Lot Control "+rtrim$(lotid$)+" Is Not on File."
						let returnstatus=0
						goto endverifyphyentry:
					else
						let rec_prlot=0
					endif
				endif
				if keyprlot$[1,12]<>pr.prodcode$ ! not the same product
					if lotid$[1,5]<>"STOCK"
						let message$="Lot Control "+rtrim$(lotid$)+" Is Not on File for Product "+rtrim$(pr.prodcode$)
						let returnstatus=0
						goto endverifyphyentry:
					else
						let rec_prlot=0
					endif
				endif
				let tmp3=keyprlot$[13,14]
				if tmp3<>whse
					if lotid$[1,5]<>"STOCK"
						let message$="Lot Control "+rtrim$(lotid$)+" Is Not on File For Warehouse "+str$(whse)
						let returnstatus=0
						goto endverifyphyentry:
					else
						let rec_prlot=0
					endif
				endif
				if keyprlot$[15,26]<>lotid$
					if lotid$[1,5]<>"STOCK"
						let message$="Lot Control "+rtrim$(lotid$)+" Is Not on File."
						let returnstatus=0
						goto endverifyphyentry:
					else
						let rec_prlot=0
					endif
				endif
				if not(rasl) exit do
				if locid$[1,6]="STOCK " exit do
				if keyprlot$[37,42]=locid$ exit do

			loop
		!endif
	else  ! lotflag=n
			! 7314          >ANMELTB      1STOCK01               STOCK < 
			!PRODUCT-WH-LOT-STOCK#-LOC
			let keyprlot$=" ",keyprlot$
			let keyprlot$[1,12]=pr.prodcode$
			let keyprlot$[13,14]=whse using "##"
			let keyprlot$[15,26]=lotid$
			! STOCK # NOT USED
			let keyprlot$[37,42]=locid$               
			Search #Ch_sprodlot,2,4;KEYPRLOT$,rec_prlot,e
			if e<>0 let rec_prlot=0
	endif
	! check to see if entry is in physical inventory file                     
	clear phy.
	let keyphy$=" ",keyphy$
	let keyphy$[1,2]=whse using "##"
	let keyphy$[3,8]=locid$[1,6]
	let keyphy$[9,14]=tagid$[1,6]
	let keyphy$[15,20]=rec_prod using "######"
	let keyphy$[21,26]=rec_prlot using "######"
	qty1=0
	qty2=0
	newrecord=0
	search #ch_phy,2,1;keyphy$,rec_phy,e
	if not (e)
		
		read record #ch_phy,rec_phy;phy.;
		qty1=0
		qty2=0

	else
		IF rasl<>0
			let keyphy2$=" ",keyphy2$
			let keyphy2$[1,2]=whse using "##"
			let keyphy2$[3,8]=rec_prod using "######"
			let keyphy2$[9,14]=locid$[1,6]
			let tmp$=keyphy2$[1,14]
			do
				search #ch_phy,3,2;keyphy2$,rec,e
				if e<>0 exit do
				if keyphy2$[1,14]<>tmp$[1,14] exit do
				let message$="Tag "+keyphy2$[21,26]+" already exists for this product, warehouse and location" 
				let returnstatus=0
				goto endverifyphyentry:
				exit do
			loop
		endif
		phy.TagId$=tagid$               
		phy.ProdId$=pr.prodcode$      
		newrecord=1                
		phy.Whse$=whse using "##"                                 
		phy.QTY=0                             
		phy.QTY1=0            
		phy.CountUM=pr.UMStkDefault  
		if lotid$[1,5]="STOCK" and whse<>0
			let tmp3=lotid$[6,7]
			if tmp3<>whse
				let lotid$[6,7]=whse using "&&"
			endif
		endif
		phy.LotCode$=lotid$+blank$ !  
		phy.Pallet$=" ",phy.pallet$ ! [10]    
		phy.Loc$=locid$+blank$                 
		phy.Wgt=0 !                       : Item 72 ! PWGT          Catch Wgt Item 
		phy.aVGWGT=0 !                    : Item 78 !                              
		phy.BinLoc$=" ",phy.BinLoc$ ! [8]                    : Item 84 !                              
		phy.ProdRec=rec_prod                                        
		phy.LotRec=rec_prlot                                                      
	endif
	endverifyphyentry:! verify tag number entered is ok
	! set list header                                                         
	Clear List$[]                                                             
	List$[0] = bsdel$,"PHYENTRY",fdel$                                   
	WebStr$ = "ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$                         
	WebStr$ = WebStr$,"QTY1",fdel$,"QtyUm1",fdel$,"QtyUmId1",fdel$,"QtyFactor1",fdel$ ! default stock unit of measure
	WebStr$ = WebStr$,"QTY2",fdel$,"QtyUm2",fdel$,"QtyUmId2",fdel$,"QtyFactor2",fdel$ ! default base unit of measure
	WebStr$ = WebStr$,"RASL",fdel$,"LotCntrl",fdel$,"CatchWgt",fdel$,"NewRecord",fdel$ 
	WebStr$ = WebStr$,"STKQTY",fdel$,"StkQtyUm",fdel$,"StkQtyUmId",fdel$,"StkQtyFactor",fdel$
	Webstr$ = Webstr$,"BASEQTY",fdel$,"BaseQtyUm",fdel$,"BaseQtyUmId",fdel$,"BaseQtyFactor",fdel$
	Webstr$ = Webstr$,"PoundsCnt",fdel$
	List$[1] = WebStr$
	row=2
	if returnstatus<>0
		 WebStr$ = RTrim$(pr.prodcode$),fdel$      
		 WebStr$ = WebStr$,RTrim$(pr.desc1$),fdel$ 
		 WebStr$ = WebStr$,RTrim$(pr.desc2$),fdel$ 
		! QTY 1 - DEFAUL Counted UNIT OF MEASURE
		! WebStr$ = WebStr$,"QTY1",fdel$,"QtyUm1",fdel$,"QtyUmId1",fdel$,"QtyFactor1",fdel$ ! default stock unit of measure
		! --- need qty 1 --------------qt
		If phy.qty=-99 let phy.qty=0
		let qty=phy.QTY
		if not (phy.CountUM)
			phy.CountUM=pr.UMStkDefault
		endif
		if phy.qty<>0
			! convert quantity                                       
			CNVTU[0] = 0;CNVTU[1] = phy.CountUM;CNVTU[2] = 1        
			CNVTA = phy.qty ! qty orders                             
			qty = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)
		endif
		webstr$=webstr$+(qty USING "#######.#####"),fdel$ 
		qtyum$ = XUnit$(phy.countum,ch_ccode) ! u/m  
		WebStr$ = WebStr$,RTrim$(qtyum$),fdel$     ! UM NAME                      
		WebStr$ = WebStr$,Str$(phy.countum),fdel$ ! UM REC #                   
		X3 = umtofactor(phy.countum) ! get qty um factor  ! FACTORE           
		WebStr$ = WebStr$,Str$(X3),fdel$ ! qty factor  
		! QTY 2 - DEFAULT BASE UNIT OF MEASURE
		!WebStr$ = WebStr$,"QTY2",fdel$,"QtyUm2",fdel$,"QtyUmId2",fdel$,"QtyFactor2",fdel$
		QTY=0 ! allows 0
		webstr$=webstr$+(qty USING "#######.#####"),fdel$
		! 0=Base, 1=Stock, 2=Sell, 3=Purch, 4=Cost, 5=Price, 6=prdctn
		let tmp3=p61$[78,78]
		if tmp3<0 or tmp3>6 let tmp3=0
		let qtyum2=pr.Baseum
		if tmp3=1 and pr.UMStkDefault>0 ! stock unit of measure
			let qtyum2=pr.UMStkDefault
		else
			if tmp3=2 and pr.UMSellDefault>0 ! selling unit of measure
				let qtyum2=pr.UMSellDefault
			else
				if tmp3=3 and pr.UMPurchDefault>0   ! purchasing unit of measure
					let qtyum2=pr.UMPurchDefault
				else
					if tmp3=4 and pr.UMCostDefault>0	! costing unit of measure
						let qtyum2=pr.UMCostDefault
					else
						if tmp3=5 and pr.UMPriceDefault>0
							let qtyum2=pr.UMPriceDefault 
						else
							if tmp3=6 and pr.UMPrdtnDefault
								let qtym2=pr.UMPrdtnDefault>0
							endif
						endif
					endif
				endif
			endif
		endif

				
		!	0=Base, 1=Stock, 2=Sell, 3=Purch, 4=Cost, 5=Price, 6=prdctn
		qtyum$ = XUnit$(qtyum2,ch_ccode) ! u/m                 
		WebStr$ = WebStr$,RTrim$(qtyum$),fdel$                          
		WebStr$ = WebStr$,Str$(qtyum2),fdel$                   
		X3 = umtofactor(qtyum2) ! get qty um factor            
		WebStr$ = WebStr$,Str$(X3),fdel$ ! qty factor 
		! WebStr$ = WebStr$,"RASL",fdel$,"LotCntrl",fdel$,"CatchWgt",fdel$,"NewRecord",fdel$ 
		! rasl check                            
		tmp$ = "N"                              
		If P9$[41,41] = "Y" Let tmp$ = "Y"      
		If P9$[41,41] = "W" !  LET SRASL=1      
			If whse > 0 And whse < 100            
				Read Record #ch_wh,(whse - 1),0;wh.;
				If wh.UseRasl <> 0 Let tmp$ = "Y" 
			End If                                
		End If                                  
		WebStr$ = WebStr$,tmp$,fdel$   
		! LOT CONTROL                                  
		tmp$ = "N"                                                     
		If P9$[1,1] = "Y" Let tmp$ = "Y"                               
		If pr.LotCtrl$ = "Y" Let tmp$ = "Y"                            
		If pr.CatchwgtItem$ = "Y" Let tmp$ = "N" ! catch weight item   
		WebStr$ = WebStr$,tmp$,fdel$ ! lot control                     
		WebStr$ = WebStr$,pr.CatchwgtItem$,fdel$ 
		let tmp$="N"
		if newrecord<>0 let tmp$="Y"
		webstr$=webstr$,tmp$,fdel$

		! WebStr$ = WebStr$,"STKQTY",fdel$,"StkQtyUm",fdel$,"StkQtyUmId",fdel$,"StkQtyFactor",fdel$
		qty=0
		if phy.qty<>0
			! convert quantity                                       
			CNVTU[0] = 0;CNVTU[1] =pr.UMStkDefault;CNVTU[2] = 1        
			CNVTA = phy.qty ! qty orders                             
			qty = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)
		endif
		webstr$=webstr$+(qty USING "#######.#####"),fdel$ 
		qtyum$ = XUnit$(pr.UMStkDefault,ch_ccode) ! u/m                 
		WebStr$ = WebStr$,RTrim$(qtyum$),fdel$     ! UM NAME                      
		WebStr$ = WebStr$,Str$(pr.UMStkDefault),fdel$ ! UM REC #                   
		X3 = umtofactor(pr.UMStkDefault) ! get qty um factor  ! FACTORE           
		WebStr$ = WebStr$,Str$(X3),fdel$ ! qty factor   
       		!Webstr$ = Webstr$,"BASEQTY",fdel$,"BaseQtyUm",fdel$,"BaseQtyUmId",fdel$,"BaseQtyFactor",fdel$
		Webstr$=webstr$,(phy.qty USING "#######.#####"),fdel$
		qtyum$ = XUnit$(pr.BaseUM,ch_ccode) ! u/m                 
		WebStr$ = WebStr$,RTrim$(qtyum$),fdel$                          
		WebStr$ = WebStr$,Str$(pr.BaseUM),fdel$                   
		X3 = umtofactor(pr.BaseUM) ! get qty um factor            
		WebStr$ = WebStr$,Str$(X3),fdel$ ! qty factor 
		! Webstr$ = Webstr$,"PoundsCnt",fdel$
		WebStr$ = WebStr$,( phy.Wgt USING "#######.##"),fdel$ 
		row=3
		LIST$[2]=webstr$
        endif
	let list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutput(e$,rstr$) ! VERIFYPHYPROD
	! done with it
! start submit 
CASE "SUBMITPHYENT" !  Verify the lot and verify location if needed
	let returnstatus=1
	let message$="OK"
	clear wh.
	let rasl=0
	Call DXGet("WHSE",tmp$) 
	let whse=tmp$
	if whse<1 or whse>99
		let returnstatus=0
		let message$="Invalid Warehouse Submitted"
		goto endsubmitphyentry
	endif
	let rec=whse-1
	read record #ch_wh,rec;wh.;
	let rasl=0
	If P9$[41,41] = "W" !  LET SRASL=1      
		If wh.UseRasl <> 0 Let rasl = 1
	endif
	if p9$[41,41]="Y" let rasl=99
        Call DXGet("TAGID",tmp$) 
	let TAGID$=rtrim$(tmp$)
	if rtrim$(tagID$)="" or len (tagID$)>6
		let returnstatus=0
		let message$="Invalid Tag Id Submitted"
		goto endsubmitphyentry
	endif                                                 
	IF len(tagid$)<6 let tagid$=tagid$+"      "
	Call DXGet("PRODID",prod$) \ prod$ = UCase$(prod$)                  
	prod$ = prod$ + blank$ \ If Len(prod$) > 12 Let prod$[13] = ""      
	Keyprod$ = prod$                                                                       
	rec_prod = filegetprod(e$,ch_prod,"=",1,Keyprod$,pr.) ! product mode
                                                                    
	If rec_prod < 0 ! Product record not found                          
		Clear pr.                                                         
		ReturnStatus = 0                                                  
		Message$ = "Product "+rtrim$(keyprod$)+" Not on File "
		goto endsubmitphyentry:
	endif
	if p61$[59,59]="Y" ! verify if product belongs in that warehouse
		Keyprwh$ = " ",Keyprwh$                                                   
		Keyprwh$[1,12] = prod$[1,12]                                              
		Keyprwh$[13] = whse Using "##"                                            
		rec_prwh = filegetprodwhse(e$,ch_prwh,"=",1,Keyprwh$,pw.,e)               
		If rec_prwh < 0 ! NOT FOUND                                               
			Clear pw.                                                               
			returnstatus=0      
			Message$ = "Product " + RTrim$(prod$) + " Not Available In Warehouse "+str$(whse)
			goto endsubmitphyentry: !  
		endif
        End If                                                                  
        ! verify if entry lot if needed
	lotflag$ = "N"                                                     
	If P9$[1,1] = "Y" Let lotflag$ = "Y"                               
	If pr.LotCtrl$ = "Y" Let lotflag$ = "Y"                            
	If pr.CatchwgtItem$ = "Y" Let lotflag$ = "N" ! catch weight item 
	if lotflag$="N"
		let lotid$=whse using "STOCK&&"
		let lotid$=lotid$+blank$
	else
		Call DXGet("LOTID",lotid$) \ lotid$ = rtrim$(UCase$(lotid$))
		let lotid$=lotid$+blank$
		if lotid$[1,5]="STOCK"
			let lotid$=whse using "STOCK&&"
			let lotid$=lotid$+blank$
		endif
	endif
	if not (rasl)
		let locid$="STOCK "
	else
		Call DXGet("LOCID",locid$) \ locid$ = UCase$(locid$)
		let locid$=locid$+blank$
		if locid$[1,6]<>"STOCK "
			Keywhloc$ = " ",Keywhloc$                        
			Keywhloc$[1,2] = whse Using "##" 
			keywhloc$[3,8]=locid$
			Search #CH_WHLOC,2,1;Keywhloc$,rec_whloc,e
			if e<>0
				let message$="Location "+rtrim$(locid$)+" for tag "+rtrim$(tagid$)+" Has not been defined for warehouse "+str$(whse)
				let returnstatus=0
				goto endsubmitphyentry:
			endif
		endif
	endif
	let rec_prlot=0
	if lotflag$="Y"
		! validate the lotnumber
		if lotid$[1,5]<>"STOCK"
			let keyprlot$=" ",keyprlot$
			let keyprlot$[1,12]=pr.prodcode$
			let keyprlot$[13,14]=whse using "##"
			let keyprlot$[15,26]=lotid$
			Do
				! KEYPRLOT$ = " ",KEYPRLOT$                 
				Search #Ch_sprodlot,3,4;KEYPRLOT$,rec_prlot,e
				IF e<>0
					let message$="Lot Control "+rtrim$(lotid$)+" Is Not on File."
					let returnstatus=0
					goto endsubmitphyentry:
				endif
				if keyprlot$[1,12]<>pr.prodcode$ ! not the same product
					let message$="Lot Control "+rtrim$(lotid$)+" Is Not on File for Product "+rtrim$(pr.prodcode$)
					let returnstatus=0
					goto endsubmitphyentry:
				endif
				let tmp3=keyprlot$[13,14]
				if tmp3<>whse
					let message$="Lot Control "+rtrim$(lotid$)+" Is Not on File For Warehouse "+str$(whse)
					let returnstatus=0
					goto endsubmitphyentry:
				endif
				if keyprlot$[15,26]<>lotid$
					let message$="Lot Control "+rtrim$(lotid$)+" Is Not on File."
					let returnstatus=0
					goto endsubmitphyentry:
				endif
				if not(rasl) exit do
				if locid$[1,6]="STOCK " exit do
				if keyprlot$[37,42]=locid$ exit do

			loop
		endif
	else  ! lotflag=n
			! 7314          >ANMELTB      1STOCK01               STOCK < 
			!PRODUCT-WH-LOT-STOCK#-LOC
			let keyprlot$=" ",keyprlot$
			let keyprlot$[1,12]=pr.prodcode$
			let keyprlot$[13,14]=whse using "##"
			let keyprlot$[15,26]=lotid$
			! STOCK # NOT USED
			let keyprlot$[37,42]=locid$               
			Search #Ch_sprodlot,2,4;KEYPRLOT$,rec_prlot,e
			if e<>0 let rec_prlot=0
	endif
	Call DXGet("DELETEREC",tmp$) 
	let deleteflag=0
	if ucase$(rtrim$(tmp$))="Y" let deleteflag=99
	! check to see if entry is in physical inventory file                     
	clear phy.
	let keyphy$=" ",keyphy$
	let keyphy$[1,2]=whse using "##"
	let keyphy$[3,8]=locid$[1,6]
	let keyphy$[9,14]=tagid$[1,6]
	let keyphy$[15,20]=rec_prod using "######"
	let keyphy$[21,26]=rec_prlot using "######"
	qty1=0
	qty2=0
	newrecord=0
	search #ch_phy,2,1;keyphy$,rec_phy,e
	if not (e)
		read record #ch_phy,rec_phy;phy.;
		if deleteflag<>0
		
			search #ch_phy,5,1;keyphy$,rec_phy,e
			if e<>0
				returnstatus=0
				let message$="Search Error "+str$(e)+ "Has Occured Deleting Key from Dir 1"+keyphy$
				goto endsubmitphyentry:
			endif
			let keyphy2$=" ",keyphy2$
			let keyphy2$[1,2]=whse using "##"
			let keyphy2$[3,8]=rec_prod using "######"
			let keyphy2$[9,14]=locid$[1,6]
			let keyphy2$[15,20]=rec_prlot using "######"
			let keyphy2$[21,26]=tagid$[1,6]
			search #ch_phy,5,2;keyphy2$,rec_phy,e
			if e<>0
				returnstatus=0
				let message$="Search Error "+str$(e)+ "Has Occured Deleting Key from Dir 2"+keyphy2$
				goto endsubmitphyentry:                    
			endif                                                                
			let keyphy2$=" ",keyphy2$
			let keyphy2$[1,2]=whse using "##"
			let keyphy2$[3,8]=tagid$[1,6] 
			let keyphy2$[9,20]=phy.ProdId$ ! rec_prod using "######" 
			let keyphy2$[21,26]=locid$[1,6]
			let keyphy2$[27,32]=rec_prlot using "######"
			search #ch_phy,5,3;keyphy2$,rec_phy,e
			if e<>0
				returnstatus=0
				let message$="Search Error "+str$(e)+ "Has Occured Deleting Key from Dir 3"+keyphy2$
				goto endsubmitphyentry:                    
			endif 
			let e=3\ search #ch_phy,1,0;keyphy$,rec_phy,e
			if e<>0
				returnstatus=0
				let message$="Search Error "+str$(e)+ "Has Occured Deleting Record "
				goto endsubmitphyentry:
			endif
			let message$="Entry Deleted. "
			goto endsubmitphyentry:	
		endif

	
	else
		let newrecord=99
		if deleteflag<>0 
			let message$="Entry Deleted. "
			goto endsubmitphyentry: ! entry is not there
		endif
		clear phy.
		phy.TagId$=tagid$               
		phy.ProdId$=pr.prodcode$      	                  
		phy.Whse$=whse using "##"                                 
		phy.QTY=0                             
		phy.QTY1=0            
		phy.CountUM=pr.UMStkDefault 
		! verify lot code
		if lotid$[1,5]="STOCK" and whse<>0
			let tmp3=lotid$[6,7]
			if tmp3<>whse
				let lotid$[6,7]=whse using "&&"
			endif
		endif
		phy.LotCode$=lotid$+blank$ !  
		phy.Pallet$=phy.Pallet$+blank$ ![10]    
		phy.Loc$=locid$+blank$                  
		!phy.Wgt                        : Item 72 ! PWGT          Catch Wgt Item 
		!phy.aVGWGT                     : Item 78 !                              
		phy.BinLoc$=" ",phy.BinLoc$ ! [8]                    : Item 84 !                              
		phy.ProdRec=rec_prod                                        
		phy.LotRec=rec_prlot
		let e=2\ search #ch_phy,1,0;keyphy$,rec_phy,e
		if e<>0
			returnstatus=0
			let message$="Search Error "+str$(e)+ "Has Occured Getting a New Record "
			goto endsubmitphyentry:
		endif
		write record #ch_phy,rec_phy;phy.;
		search #ch_phy,4,1;keyphy$,rec_phy,e
		if e<>0
			returnstatus=0
			let message$="Search Error "+str$(e)+ "Has Occured Adding Key to Dir 1"+keyphy$
			goto endsubmitphyentry:
		endif
		let keyphy2$=" ",keyphy2$
		let keyphy2$[1,2]=whse using "##"
		let keyphy2$[3,8]=rec_prod using "######"
		let keyphy2$[9,14]=locid$[1,6]
		let keyphy2$[15,20]=rec_prlot using "######"
		let keyphy2$[21,26]=tagid$[1,6]
		search #ch_phy,4,2;keyphy2$,rec_phy,e
		if e<>0
			returnstatus=0
			let message$="Search Error "+str$(e)+ "Has Occured Adding Key to Dir 2"+keyphy2$
			goto endsubmitphyentry:                    
                endif                                                                
		let keyphy2$=" ",keyphy2$
		let keyphy2$[1,2]=whse using "##"
		let keyphy2$[3,8]=tagid$[1,6] 
		let keyphy2$[9,20]=phy.ProdId$ ! rec_prod using "######" 
		let keyphy2$[21,26]=locid$[1,6]
		let keyphy2$[27,32]=rec_prlot using "######"

		
		search #ch_phy,4,3;keyphy2$,rec_phy,e
		if e<>0
			returnstatus=0
			let message$="Search Error "+str$(e)+ "Has Occured Adding Key to Dir 3"+keyphy2$
			goto endsubmitphyentry:                    
                endif                                                                                                                                                
	endif
	
	qty=0
	Call DXGet("QTY1",tmp$)    
	workqty = tmp$ ! 
	If workqty >= 0                                               
		Call DXGet("QTYUMID1",tmp$)                                  
		r = tmp$                                                    
		If tmp$[1,1] > "9" ! sent text?                             
			r = getumrec(e$,ch_ccode,tmp$,IntCo,pr.)                  
			If r <> 0 Let tmp$ = Str$(r)                              
		End If                                                      
		If Not(r)                                                   
			ReturnStatus = 0                                          
			Message$ = "Invalid Quantity Unit of Measure Entered"     
			Goto endsubmitphyentry:                                       
		End If   
		let phy.qty1=0;phy.qty=0
		! phy.qty1 = counted
		! phy.qty = base
		phy.CountUm = r  
		CNVTU[0] = phy.CountUm;CNVTU[1] = 0;CNVTU[2] = 1         
		CNVTA = workqty ! qty orders                              
		qty = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)
		let phy.qty=phy.qty+qty
	else
		if phy.qty<>-99 let phy.qty=0
	endif
	qty=0;workqty=0
	Call DXGet("QTY2",tmp$)    
	workqty = tmp$ ! 
	If workqty <> 0                                               
		Call DXGet("QTYUMID2",tmp$)                                  
		r = tmp$                                                    
		If tmp$[1,1] > "9" ! sent text?                             
			r = getumrec(e$,ch_ccode,tmp$,IntCo,pr.)                  
			If r <> 0 Let tmp$ = Str$(r)                              
		End If                                                      
		If Not(r)                                                   
			ReturnStatus = 0                                          
			Message$ = "Invalid Quantity Unit of Measure Entered"     
			Goto endsubmitphyentry:                                       
		End If   
		CNVTU[0] = r;CNVTU[1] = 0;CNVTU[2] = 1         
		CNVTA = workqty ! qty orders                              
		qty = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)
		let phy.qty=phy.qty+qty
	endif
	if phy.qty<>-99
		if phy.qty<>0 ! calculate qty in counted unit of measure
			CNVTU[0] = 0;CNVTU[1] =phy.countum;CNVTU[2] = 1        
			CNVTA = phy.qty ! qty orders                             
			phy.qty1 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)
		endif
	endif
	If pr.CatchwgtItem$ = "Y" 
		Call DXGet("POUNDSCNT",tmp$) 
		let phy.Wgt=tmp$
	endif
	write record #ch_phy,rec_phy;phy.;
	
	endsubmitphyentry:! verify tag number entered is ok
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutput(e$,rstr$) ! SUBMITPHYENT\
! START VOID
CASE "SUBMITVOIDTAG" !  SUBMIT TAG TO BE VOIDED
	let returnstatus=1
	let message$="OK"
	clear wh.
	let rasl=0
	Call DXGet("WHSE",tmp$) 
	let whse=tmp$
	if whse<1 or whse>99
		let returnstatus=0
		let message$="Invalid Warehouse Submitted"
		goto endsubmitphyentry
	endif
	let rec=whse-1
	read record #ch_wh,rec;wh.;
	
        Call DXGet("TAGID",tmp$) 
	let TAGID$=rtrim$(tmp$)
	if rtrim$(tagID$)="" or len (tagID$)>6
		let returnstatus=0
		let message$="Invalid Tag Id Submitted"
		goto endsubmitphyentry
	endif                                                 
	                              
        
	clear phy.
	let rec_prlot=0
	let locid$=" ",locid$
	phy.Prodid$="VOID TAG            "
	qty1=0
	qty2=0
	newrecord=0
	Let keyphy2$=" ",keyphy2$
	let keyphy2$[1,2]=whse using "##"
	let keyphy2$[3,8]=tagid$[1,6] 
	let keyphy2$[9,20]=phy.ProdId$ ! rec_prod using "######" 
	!let keyphy2$[21,26]=locid$[1,6]
	!let keyphy2$[27,32]=rec_prlot using "######"
	search #ch_phy,2,3;keyphy2$,rec_phy,e
	if not (e)
		returnstatus=0
		let message$="Tag "+tagid$+" Already Voided"
		goto endsubvoidtag:
	else
		let newrecord=99
		clear phy.
		phy.TagId$=tagid$               
		phy.ProdId$="VOID TAG       "
		phy.Whse$=whse using "##"                                 
		phy.QTY=0                             
		phy.QTY1=0            
		phy.CountUM=pr.UMStkDefault                      
		phy.LotCode$=" ",phy.lotcode$!  
		phy.Pallet$=" ",phy.Pallet$ ! [10]    
		phy.Loc$=" ",phy.loc$ !locid$                   
		!phy.Wgt                        : Item 72 ! PWGT          Catch Wgt Item 
		!phy.aVGWGT                     : Item 78 !                              
		phy.BinLoc$=" ",phy.BinLoc$ ! [8]                    : Item 84 !                              
		phy.ProdRec=rec_prod                                        
		phy.LotRec=rec_prlot
		let keyphy$=" ",keyphy$
		let keyphy$[1,2]=whse using "##"
		let keyphy$[3,8]=locid$[1,6]
		let keyphy$[9,14]=tagid$[1,6]
		!let keyphy$[15,20]=rec_prod using "######"
		!let keyphy$[21,26]=rec_prlot using "######"
		let keyphy$[15,18]="VOID"
		let e=2\ search #ch_phy,1,0;keyphy$,rec_phy,e
		if e<>0
			returnstatus=0
			let message$="Search Error "+str$(e)+ "Has Occured Getting a New Record "
			goto endsubvoidtag:
		endif
		write record #ch_phy,rec_phy;phy.;
		search #ch_phy,4,1;keyphy$,rec_phy,e
		if e<>0
			returnstatus=0
			let message$="Search Error "+str$(e)+ "Has Occured Adding Key to Dir 1"+keyphy$
			goto endsubvoidtag:
		endif
		let keyphy2$=" ",keyphy2$
		let keyphy2$[1,2]=whse using "##"
		let keyphy2$[3,6]="VOID" ! rec_prod using "######"
		!let keyphy2$[9,14]=locid$[1,6]
		!let keyphy2$[15,20]=rec_prlot using "######"
		let keyphy2$[21,26]=tagid$[1,6]
		search #ch_phy,4,2;keyphy2$,rec_phy,e
		if e<>0
			returnstatus=0
			let message$="Search Error "+str$(e)+ "Has Occured Adding Key to Dir 2"+keyphy2$
			goto endsubvoidtag:                    
                endif                                                                
		Let keyphy2$=" ",keyphy2$
		let keyphy2$[1,2]=whse using "##"
		let keyphy2$[3,8]=tagid$[1,6] 
		let keyphy2$[9,20]=phy.ProdId$ ! rec_prod using "######" 
		search #ch_phy,4,3;keyphy2$,rec_phy,e
		if e<>0
			returnstatus=0
			let message$="Search Error "+str$(e)+ "Has Occured Adding Key to Dir 3"+keyphy2$
			goto endsubvoidtag:                    
                endif
		write record #ch_phy,rec_phy;phy.;
	endif
	endsubvoidtag:! verify tag number entered is ok
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutput(e$,rstr$) ! SUBVOIDTAG
! --- End 693 Manual Physical Inventory
! ---------------------------------------------
! --- start 693 Auto Physical Inventory ----
CASE "STARTAUTOPHY" !  set flags and sends warehouse list
	let returnstatus=1
	let message$="OK"
	! whse droplist
	Call FileDropListWhinfoz(e$,whList$[],100,ch_wh)  
	Call AddToStr(e$,rstr$,whList$[])
	! Default Warehouse
	clear list$[]
	let list$[0]=bsdel$,"DfltWhse",fdel$
	webstr$ = "DfltWhse",fdel$                             
	list$[1]=webstr$
	let tmp3=prt.wh
	if tmp3<=0 or tmp3>99 let tmp3=1
	webstr$=str$(tmp3),fdel$ !!!
	list$[2]=webstr$
	list$[3]=esdel$
	call AddToStr(e$,rstr$,List$[]) 
	clear list$[]
	let list$[0]=bsdel$,"BinOpts",fdel$
	list$[1]="BinId",fdel$,"Description",fdel$
	List$[2]="0",fdel$,"All Bin Locations ",fdel$
	list$[3]="1",fdel$,"Odds-Alpha-Blank Only",fdel$
	list$[4]="2",fdel$,"Evens Only",fdel$
	list$[5]=esdel$
	call AddToStr(e$,rstr$,List$[]) 
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutput(e$,rstr$) ! StartPhys

CASE "GETPHYAUTO" !  Verify the lot and verify location if needed
	let returnstatus=1
	let message$="OK"
	Clear List$[]                                                             
	List$[0] = bsdel$,"PHYAUTOENTRY",fdel$                                   
	WebStr$ = "ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$                         
	WebStr$ = WebStr$,"QTY1",fdel$,"QtyUm1",fdel$,"QtyUmId1",fdel$,"QtyFactor1",fdel$ ! default stock unit of measure
	WebStr$ = WebStr$,"QTY2",fdel$,"QtyUm2",fdel$,"QtyUmId2",fdel$,"QtyFactor2",fdel$ ! default base unit of measure
	WebStr$ = WebStr$,"TAGID",fdel$,"LOTID",fdel$,"LOCID",fdel$,"CatchWgt",fdel$
	Webstr$ = Webstr$,"PoundsCnt",fdel$
	List$[1] = WebStr$
	row=2
	clear wh.
	let rasl=0
	Call DXGet("WHSE",tmp$) 
	let whse=tmp$
	if whse<1 or whse>99
		let returnstatus=0
		let message$="Invalid Warehouse Submitted"
		goto endgetphyauto
	endif
	let rec=whse-1
	read record #ch_wh,rec;wh.;
	let rasl=0
	If P9$[41,41] = "W" !  LET SRASL=1      
		If wh.UseRasl <> 0 Let rasl = 1
	endif
	if p9$[41,41]="Y" let rasl=99
        Call DXGet("STAGID",tmp$) 
	let TAGID$=rtrim$(tmp$)       
	IF len(tagid$)<6 let tagid$=tagid$+"      "
	Call DXGet("ETAGID",tmp$) 
	let  ETAGID$=rtrim$(tmp$)       
	IF len(etagid$)<6 let etagid$=etagid$+"zzzzzz"

	Call DXGet("SPRODID",sprod$) \ sprod$ = UCase$(rtrim$(sprod$))                 
	sprod$ = sprod$ + blank$  ! \ If Len(sprod$) > 12 Let sprod$[13] = "" 
	let binflag=0
	if rasl<>0
		Call DXGet("BINID",tmp$) \ tmp3=tmp$
		if tmp3<0 or tmp3>2
			let returnstatus=0
			let message$="Invalid Bin Option Submitted"
			goto endgetphyauto
		endif
		LET binflag=tmp3
		if binflag<>0  
			LET FILTER=BINFLAG
			LET WL1[1]=0;WL1[2]=0                                          
			LET kEYWHLOC$=" ",kEYWHLOC$
			LET kEYWHLOC$[1,2]=WHSE USING "##"
			LET kEYWHLOC$[5,5]="@"        
			SEARCH #CH_WHLOC,2,1;kEYWHLOC$,Rec_whloc,E             
			IF NOT (E)                                          
				MAT  READ #CH_WHLOC,REC_WHLOC,40;WL1;                                       
				MAT  READ #CH_WHLOC,REC_WHLOC,76;WLA; 
			else
				let returnstatus=0
				let message$="Missing Warehouse Location Control Record. "
				goto endgetphyauto:
			ENDIF                                
			IF WL1[1]<2 OR WL1[1]>3 LET WL1[1]=2                           
			IF WL1[2]<2 OR WL1[2]>3 OR WL1[2]=WL1[1] LET WL1[1]=2;WL1[2]=3 
		endif
	endif
	let keyphy$=" ",keyphy$
	let keyphy$[1,2]=whse using "##"
	let keyphy$[3,8]=tagid$[1,6]
	let keyphy$[9,20]=sprod$[1,12]
	DO
		search #ch_phy,3,3;keyphy$,rec_phy,e
		if e<>0 exit do
		let tmp3=keyphy$[1,2]\if tmp3<>whse exit do
		if keyphy$[3,8]<tagid$[1,6] goto endthistag: ! keyphy$[3,8]exit do
		if keyphy$[3,8]>etagid$[1,6] goto endgetphyauto: ! 
		! if keyphy$[9,20]<sprod$[1,12] goto endthistag:
		read record #ch_phy,rec_phy;phy.;
		if binflag<>0	                            
			LET BINTMP=0;TIER$=""                                                        
			LET ALPHA=0                                                               
			IF WL1[1]=2                                                               
				LET BINTMP=phy.loc$[1+WLA[3],WLA[3]+WLA[4]]                                     
				LET TIER$=phy.loc$[1+WLA[3]+WLA[4],6]                                        
				LET BIN$=phy.loc$[1+WLA[3],WLA[3]+WLA[4]]                                    
			ENDIF                                                                     
			IF WL1[1]=3                                                               
				LET TIER$=phy.loc$[1+WLA[3],WLA[3]+WLA[5]]                                   
				LET BINTMP=phy.loc$[1+WLA[3]+WLA[5],6]                                          
				LET BIN$=phy.loc$[1+WLA[3]+WLA[5],6]                                         
			ENDIF                                                                     
			LET BIN$=BIN$+"   "                                                       
			IF Rtrim$(BIN$)=""
				LET ALPHA=99
			else                       
				FOR X=1 TO 3                                                              
					IF BIN$[X,X]<>" " AND (BIN$[X,X]<"0" OR BIN$[X,X]>"9") LET ALPHA=99     
				NEXT X                                                                    
			endif                                                                       
			IF FILTER=1 AND NOT (ALPHA) AND NOT (FRA(BINTMP/2)) GOTO endthistag:                      
			IF FILTER=2 AND (ALPHA<>0 OR FRA(BINTMP/2)<>0) GOTO endthistag:     
		endif
!		if keyphy$[9,20]<sprod$[1,12] !
!			goto endthistag:! bypass
!	else
		read record #ch_phy,rec_phy;phy.;
		let prod$=phy.ProdId$
		if phy.Prodid$[1,8]="VOID TAG" goto endthistag: ! bypass get the next one
		Keyprod$ = prod$                                                                       
		rec_prod = filegetprod(e$,ch_prod,"=",1,Keyprod$,pr.) ! product mode                                         
		If rec_prod >0 ! Product record not found 
			if row>1001 ! 2501 ! need limit on data returned (row 1 used by headers)
				returnstatus=5 ! special status to tell web MORE TO COME
				message$="WHSE="+sTR$(wHSE)+"&STAGID="+phy.tagid$+"&SPRODID="+RTrim$(pr.prodcode$)+"&"
				goto endgetphyauto
			Endif
			!WebStr$ = "ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$                         
			WebStr$ = RTrim$(pr.prodcode$),fdel$      
			WebStr$ = WebStr$,RTrim$(pr.desc1$),fdel$ 
			WebStr$ = WebStr$,RTrim$(pr.desc2$),fdel$ 
			! QTY 1 - DEFAUL Counted UNIT OF MEASURE
			! WebStr$ = WebStr$,"QTY1",fdel$,"QtyUm1",fdel$,"QtyUmId1",fdel$,"QtyFactor1",fdel$ ! default stock unit of measure
			! --- need qty 1 --------------qt
			If phy.qty=-99 let phy.qty=0
			let qty=phy.QTY
			If qty=-99 let qty=0
			if not (phy.CountUM)
				phy.CountUM=pr.UMStkDefault
			endif
			if phy.qty<>0
				! convert quantity                                       
				CNVTU[0] = 0;CNVTU[1] = phy.CountUM;CNVTU[2] = 1        
				CNVTA = phy.qty ! qty orders                             
				qty = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)
			endif
			webstr$=webstr$+(qty USING "#######.#####"),fdel$ 
			qtyum$ = XUnit$(phy.countum,ch_ccode) ! u/m  
			WebStr$ = WebStr$,RTrim$(qtyum$),fdel$     ! UM NAME                      
			WebStr$ = WebStr$,Str$(phy.countum),fdel$ ! UM REC #                   
			X3 = umtofactor(phy.countum) ! get qty um factor  ! FACTORE           
			WebStr$ = WebStr$,Str$(X3),fdel$ ! qty factor  
			! QTY 2 - DEFAULT BASE UNIT OF MEASURE
			!WebStr$ = WebStr$,"QTY2",fdel$,"QtyUm2",fdel$,"QtyUmId2",fdel$,"QtyFactor2",fdel$
			QTY=0 ! allows 0
			webstr$=webstr$+(qty USING "#######.#####"),fdel$ 
			! 0=Base, 1=Stock, 2=Sell, 3=Purch, 4=Cost, 5=Price, 6=prdctn
			let tmp3=p61$[78,78]
			if tmp3<0 or tmp3>6 let tmp3=0
			let qtyum2=pr.Baseum
			if tmp3=1 and pr.UMStkDefault>0 ! stock unit of measure
				let qtyum2=pr.UMStkDefault
			else
				if tmp3=2 and pr.UMSellDefault>0 ! selling unit of measure
					let qtyum2=pr.UMSellDefault
				else
					if tmp3=3 and pr.UMPurchDefault>0   ! purchasing unit of measure
						let qtyum2=pr.UMPurchDefault
					else
						if tmp3=4 and pr.UMCostDefault>0	! costing unit of measure
							let qtyum2=pr.UMCostDefault
						else
							if tmp3=5 and pr.UMPriceDefault>0
								let qtyum2=pr.UMPriceDefault 
							else
								if tmp3=6 and pr.UMPrdtnDefault
									let qtym2=pr.UMPrdtnDefault>0
								endif
							endif
						endif
					endif
				endif
			endif
			!	0=Base, 1=Stock, 2=Sell, 3=Purch, 4=Cost, 5=Price, 6=prdctn
			qtyum$ = XUnit$(qtyum2,ch_ccode) ! u/m                 
			WebStr$ = WebStr$,RTrim$(qtyum$),fdel$                          
			WebStr$ = WebStr$,Str$(qtyum2),fdel$                   
			X3 = umtofactor(qtyum2) ! get qty um factor            
			WebStr$ = WebStr$,Str$(X3),fdel$ ! qty factor 
			!WebStr$ = WebStr$,"TAGID",fdel$,"LOTID",fdel$,"LOCID",fdel$,"CatchWgt",fdel$
			if whse<>0
				if lotid$[1,5]="STOCK" 
					let tmp3=lotid$[6,7]
					if tmp3<>whse
						let lotid$[6,7]=whse using "&&"
					endif
				endif
			endif
			webstr$=webstr$,phy.tagid$,fdel$,phy.LotCode$,fdel$
			webstr$=webstr$,phy.loc$,fdel$			                  
			WebStr$ = WebStr$,pr.CatchwgtItem$,fdel$ 
			! Webstr$ = Webstr$,"PoundsCnt",fdel$
			WebStr$ = WebStr$,( phy.Wgt USING "#######.##"),fdel$ 
			LIST$[row]=webstr$
			let row=row+1
        	If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
				
		endif ! valid product
		!endif ! product code check
		endthistag: ! end this tag 
	loop
	endgetphyauto:! verify tag number entered is ok

		
	let list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutput(e$,rstr$) ! Getphyauto
	! done with it

CASE "SUBMITPHYAUTO" !  Verify the lot and verify location if needed
	let returnstatus=1
	let message$="OK"
	clear wh.
	let rasl=0
	Call DXGet("WHSE",tmp$) 
	let whse=tmp$
	if whse<1 or whse>99
		let returnstatus=0
		let message$="Invalid Warehouse Submitted"
		goto endsubmitphyauto
	endif
	let rec=whse-1
	read record #ch_wh,rec;wh.;
	let rasl=0
	If P9$[41,41] = "W" !  LET SRASL=1      
		If wh.UseRasl <> 0 Let rasl = 1
	endif
	if p9$[41,41]="Y" let rasl=99
	call DxGet ("TOTREC",tmp$)
	let totrec=tmp$
	if totrec<1
		let returnstatus=0
		let message$="Invalid Number of Record Submitted "
		goto endsubmitphyauto
	endif
	message$=""
	for cnt=1 to totrec
		! mtg 
		Call DXGet("TAGID"+ Str$(cnt),tmp$) 
		let TAGID$=rtrim$(tmp$)
		Call DXGet("PRODID"+ Str$(cnt),prod$) \ prod$ = UCase$(rtrim$(prod$))  
		! verify tag
		if rtrim$(tagID$)="" or len (tagID$)>6
			let returnstatus=2
			let message$=message$+"Invalid Tag Id "+rtrim$(tagid$)+" Submitted. "
			goto getnxttag: 
		endif                                                 
		IF len(tagid$)<6 let tagid$=tagid$+"      "
		! verify product               
		prod$ = prod$ + blank$ \ If Len(prod$) > 12 Let prod$[13] = ""      
		Keyprod$ = prod$                                                                       
		rec_prod = filegetprod(e$,ch_prod,"=",1,Keyprod$,pr.) ! product mode
                                                                    
		If rec_prod < 0 ! Product record not found                          
			Clear pr.                                                         
			ReturnStatus = 2                                                 
			Message$ = Message$+ "Product "+rtrim$(keyprod$)+" Not on File "
			goto getnxttag:
		endif
	    
		 ! verify if entry lot if needed
		lotflag$ = "N"                                                     
		If P9$[1,1] = "Y" Let lotflag$ = "Y"                               
		If pr.LotCtrl$ = "Y" Let lotflag$ = "Y"                            
		If pr.CatchwgtItem$ = "Y" Let lotflag$ = "N" ! catch weight item 
		if lotflag$="N"
			let lotid$=whse using "STOCK&&"
			let lotid$=lotid$+blank$
		else

			Call DXGet("LOTID"+Str$(cnt),lotid$) \ lotid$ = UCase$(lotid$)
			let lotid$=lotid$+blank$
			if lotid$[1,5]="STOCK"
				let lotid$=whse using "STOCK&&"
				let lotid$=lotid$+blank$
			endif
		endif
		if not (rasl)
			let locid$="STOCK "
		else
			Call DXGet("LOCID"+Str$(cnt),locid$) \ locid$ = UCase$(locid$)
			let locid$=locid$+blank$
			if locid$[1,6]<>"STOCK "
				Keywhloc$ = " ",Keywhloc$                        
				Keywhloc$[1,2] = whse Using "##" 
				keywhloc$[3,8]=locid$
				Search #CH_WHLOC,2,1;Keywhloc$,rec_whloc,e
				if e<>0
					let message$="Location "+rtrim$(locid$)+" for tag "+rtrim$(tagid$)+" Has not been defined for warehouse "+str$(whse)
					let returnstatus=2
					goto getnxttag: 
				endif
			endif
		endif
		let rec_prlot=0
		if lotflag$="Y"
			! validate the lotnumber
			! if lotid$[1,5]<>"STOCK"
			let keyprlot$=" ",keyprlot$
			let keyprlot$[1,12]=pr.prodcode$
			let keyprlot$[13,14]=whse using "##"
			let keyprlot$[15,26]=lotid$
			Do
				Search #Ch_sprodlot,3,4;KEYPRLOT$,rec_prlot,e
				IF e<>0
					If lotid$[1,5]<>"STOCK"
						let message$=message$+"Lot Control "+rtrim$(lotid$)+" Is Not on File."
						let returnstatus=2
						goto getnxttag: ! goto endsubmitphyauto:
					else
						let rec_prlot=0
					endif
				endif
				if keyprlot$[1,12]<>pr.prodcode$ ! not the same product
					If lotid$[1,5]<>"STOCK"
						let message$=message$+"Lot Control "+rtrim$(lotid$)+" Is Not on File for Product "+rtrim$(pr.prodcode$)
						let returnstatus=2
						goto getnxttag: ! goto endsubmitphyauto:
					else
						let rec_prlot=0
					endif
				endif
				let tmp3=keyprlot$[13,14]
				if tmp3<>whse
					If lotid$[1,5]<>"STOCK"
						let message$=message$+"Lot Control "+rtrim$(lotid$)+" Is Not on File For Warehouse "+str$(whse)
						let returnstatus=2
						goto getnxttag:
					else
						let rec_prlot=0
					endif
				
				endif
				if keyprlot$[15,26]<>lotid$
					If lotid$[1,5]<>"STOCK"
						let message$=message$+"Lot Control "+rtrim$(lotid$)+" Is Not on File."
						let returnstatus=2
						goto getnxttag: 
					else
						let rec_prlot=0
					endif
				endif
				if not(rasl) exit do
				if locid$[1,6]="STOCK " exit do
				if keyprlot$[37,42]=locid$ exit do
			loop
			! endif ! lot <> stock 
		else  ! lotflag=n
			! 7314          >ANMELTB      1STOCK01               STOCK < 
			!PRODUCT-WH-LOT-STOCK#-LOC
			let keyprlot$=" ",keyprlot$
			let keyprlot$[1,12]=pr.prodcode$
			let keyprlot$[13,14]=whse using "##"
			let keyprlot$[15,26]=lotid$
			! STOCK # NOT USED
			let keyprlot$[37,42]=locid$              
			Search #Ch_sprodlot,2,4;KEYPRLOT$,rec_prlot,e
			if e<>0 let rec_prlot=0

		endif ! lotflag=y
		Call DXGet("DELETEREC"+Str$(cnt),tmp$) 
		let deleteflag=0
		if ucase$(rtrim$(tmp$))="Y" let deleteflag=99
		! check to see if entry is in physical inventory file                     
		clear phy.
		let keyphy$=" ",keyphy$
		let keyphy$[1,2]=whse using "##"
		let keyphy$[3,8]=locid$[1,6]
		let keyphy$[9,14]=tagid$[1,6]
		let keyphy$[15,20]=rec_prod using "######"
		getphyprlot: ! get rec_prlot
		let keyphy$[21,26]=rec_prlot using "######"
		qty1=0
		qty2=0
		newrecord=0
		search #ch_phy,2,1;keyphy$,rec_phy,e
		if e=1 and rec_prlot<>0
			let rec_prlot=0
			goto getphyprlot:
		endif
		if not (e)
			read record #ch_phy,rec_phy;phy.;
			if deleteflag<>0
				search #ch_phy,5,1;keyphy$,rec_phy,e
				if e<>0
					returnstatus=0
					let message$=message$+"Search Error "+str$(e)+ "Has Occured Deleting Key from Dir 1"+keyphy$
					goto endsubmitphyauto:
				endif
				let keyphy2$=" ",keyphy2$
				let keyphy2$[1,2]=whse using "##"
				let keyphy2$[3,8]=rec_prod using "######"
				let keyphy2$[9,14]=locid$[1,6]
				let keyphy2$[15,20]=rec_prlot using "######"
				let keyphy2$[21,26]=tagid$[1,6]
				search #ch_phy,5,2;keyphy2$,rec_phy,e
				if e<>0
					returnstatus=0
					let message$=message$+"Search Error "+str$(e)+ "Has Occured Deleting Key from Dir 2"+keyphy2$
					goto endsubmitphyauto:                    
				endif                                                                
				let keyphy2$=" ",keyphy2$
				let keyphy2$[1,2]=whse using "##"
				let keyphy2$[3,8]=tagid$[1,6] 
				let keyphy2$[9,20]=phy.ProdId$ ! rec_prod using "######" 
				let keyphy2$[21,26]=locid$[1,6]
				let keyphy2$[27,32]=rec_prlot using "######"
				search #ch_phy,5,3;keyphy2$,rec_phy,e
				if e<>0
					returnstatus=0
					let message$=message$+"Search Error "+str$(e)+ "Has Occured Deleting Key from Dir 3"+keyphy2$
					goto endsubmitphyauto:                    
				endif 
				let e=3\ search #ch_phy,1,0;keyphy$,rec_phy,e
				if e<>0
					returnstatus=0
					let message$=message$+"Search Error "+str$(e)+ "Has Occured Deleting Record "
					goto endsubmitphyauto:
				endif
				! let message$="Entry Deleted. "
				goto getnxttag: ! goto endsubmitphyauto:	
			endif

	
		else
			let returnstatus=2
			let message$=message$+"Transaction for Product "+rtrim$(keyprod$)+" and Tag "+tagid$+" Not found "
			goto getnxttag: 
		endif ! delete flag	                                                                                                                 
		qty=0
		Call DXGet("QTY1"+Str$(cnt),tmp$)    
		workqty = tmp$ ! 
		                                            
		Call DXGet("QTYUMID1"+Str$(cnt),tmp$)                                  
		r = tmp$                                                    
		If tmp$[1,1] > "9" ! sent text?                             
			r = getumrec(e$,ch_ccode,tmp$,IntCo,pr.)                  
			If r <> 0 Let tmp$ = Str$(r)                              
		End If                                                      
		If Not(r)                                                   
			ReturnStatus = 2                                         
			Message$ = Message$+rtrim$(keyprod$)+" Invalid Qty UM Entered "     
			 goto getnxttag:                                    
		End If   
		let phy.qty1=0;phy.qty=0
		! phy.qty1 = counted
		! phy.qty = base
		phy.CountUm = r  
		If workqty <> 0 
			CNVTU[0] = phy.CountUm;CNVTU[1] = 0;CNVTU[2] = 1         
			CNVTA = workqty ! qty orders                              
			qty = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)
			let phy.qty=phy.qty+qty
		endif
		qty=0;workqty=0
		Call DXGet("QTY2"+Str$(cnt),tmp$)    
		workqty = tmp$ !                                               
		Call DXGet("QTYUMID2"+Str$(cnt),tmp$)                                  
		r = tmp$                                                    
		If tmp$[1,1] > "9" ! sent text?                             
			r = getumrec(e$,ch_ccode,tmp$,IntCo,pr.)                  
			If r <> 0 Let tmp$ = Str$(r)                              
		End If                                                      
		If Not(r)                                                   
			ReturnStatus = 2                                         
			Message$ = Message$+rtrim$(keyprod$)+" Invalid Qty UM Entered "
			goto getnxttag:                                   
		End If 
		If workqty <> 0 
			CNVTU[0] = r;CNVTU[1] = 0;CNVTU[2] = 1         
			CNVTA = workqty ! qty orders                              
			qty = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)
			let phy.qty=phy.qty+qty
		endif
		if phy.qty<>0 ! calculate qty in counted unit of measure
			CNVTU[0] = 0;CNVTU[1] =phy.countum;CNVTU[2] = 1        
			CNVTA = phy.qty ! qty orders                             
			phy.qty1 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)
		endif
		If pr.CatchwgtItem$ = "Y" 
			Call DXGet("POUNDSCNT"+Str$(cnt),tmp$) 
			let phy.Wgt=tmp$
		endif
		write record #ch_phy,rec_phy;phy.;
		getnxttag:  ! end of this tag
	next cnt ! next tag
	endsubmitphyauto:! verify tag number entered is ok
	if returnstatus=1 and message$="" let message$="Complete"
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutput(e$,rstr$) ! SUBMITPHYAUTO
! ---- Edn 693 - Autoupdate
! end submit

 end select
  ! call dxclose()
else
  include "src/callmainerrnet.inc"
  call dxclose()
end try
end

!--------------------------------------------------------------------
sub OpenFiles()
  
  Try
    !
    Ch_Prod = OpenFile(1792,intCo) \ If Ch_Prod = -1 Error 42  !product file 
    Ch_Vend = OpenFile(2400,intCo) \ If Ch_Vend = -1 Error 42  ! vend
    ch_vtag=OpenFile(1120,intCo) \ If Ch_vtag = -1 Error 42 ! vemdtag
    Ch_PrWh = OpenFile(1744,intCo) \ If Ch_PrWh = -1 Error 42  !"product warehouse file
    Ch_Wh = OpenFile(2768,intCo) \ If Ch_Wh = -1 Error 42  !" warehouse file
    Ch_Ccode = OpenFile(-1728,intCo) \ If Ch_Ccode = -1 Error 42  !u/m codes file  
    Ch_WHloc= OpenFile(-2736,intCo) \ If Ch_Whloc = -1 Error 42  !warehouse location
    ch_sprodlot=OpenFile(-2528,intCo) \ If Ch_sprodlot = -1 Error 42 !sprodlot file
    ch_rsn=OpenFile(-9958,intCo) \ If Ch_rsn = -1 Error 42 !misc rts reason codes
    ch_mrts=OpenFile(9945,intCo) \ If Ch_mrts = -1 Error 42 !sprodlot file
    ch_fl=OpenFile(3008,intCo) \ If Ch_fl = -1 Error 42 !fifolot file 
    ch_ft=OpenFile(3024,intCo) \ If Ch_ft = -1 Error 42 !fifotrans file
    ch_phy=OpenFile(704,intCo) \ if ch_phy = -1 Error 42 ! physical inventory file
   else
    include "src/callsuberr.inc"
  end try
end sub ! openfiles

! ------------------------------------------------------------------------
Sub VerifyVendor() 

try
	  keyvend$=" ",keyvend$
	  keyvend$=vendid using "######"
	  mode$="=" ! search mode 2
	  dir=1
	  clear vend.
	  Rec_vend=filegeta80vm(e$,ch_vend,mode$,dir,keyvend$,vend.)
	  if rec_vend<0
		let returnstatus=0
		let message$="Vendor "+str$(vendid)+" Not On File. "
	  endif
	  if returnstatus>0
		keyvend$=" ",keyvend$
		keyvend$=vendid using "######"
		mode$="=" ! search mode 2
		dir=1
		clear vtag.
		Rec_vtag=filegetvendtag(e$,ch_vtag,mode$,dir,keyvend$,vtag.)
		if rec_vtag<0
			let returnstatus=0
			let message$="Vendor "+str$(vendid)+" Not In Tag File . "
		endif	
	  endif
		
else
	! this is a remark
end try
end sub ! Verify Vendor  

! --------------------------------------------------------------------
Sub getPRODDETAIL()! take pad list - send line details
 Try
	ReturnStatus=1
	Message$="OK" 
	! set list header
	Clear List$[]
	List$[0]=bsdel$,"PRODUCTDETAIL",fdel$
	WebStr$="ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$
	Webstr$=Webstr$,"Last Cost",fdel$,"AvailableQty",fdel$,"OnhandQty",fdel$,"CommitQty",fdel$
	Webstr$=Webstr$,"PackSize",fdel$,"CatchWeight",fdel$,"AvailableLbs",fdel$
	Webstr$=Webstr$,"CostUm",fdel$,"CostUmID",fdel$,"CostFactor",fdel$
	Webstr$=Webstr$,"QtyUm",fdel$,"QtyUmId",fdel$,"QtyFactor",fdel$
	Webstr$=Webstr$,"SerialNum",fdel$,"CostSecurity",fdel$,"RASL",fdel$,"LotCntrl",fdel$
	Webstr$=webstr$,"Pronto",fdel$
        List$[1]=WebStr$
	Call DXGet("PRODID",tmp$)
	tmp$=Ucase$(RTrim$(tmp$))
	if tmp$="" 
		let returnstatus=0
		Let message$="Invalid Product Code Submitted"
		goto endproddetail:
	endif
	Prod$=tmp$+blank$
	Let keyprod$=Prod$
	Let keyprod$[13]="";e=0 ! no lock
        rec_prod = filegetprod(e$,ch_prod,"=",1,Keyprod$,PR.,e)
	If rec_prod<=0 ! not found
		Let message$="PRODUCT "+rtrim$(prod$)+" NOT FOUND"
		Let ReturnStatus=0
		goto endproddetail:
	Endif
	! check if in product warehouse
	Call dxget ("WHSE",tmp$)
	let whse=tmp$
	if whse<=0 or whse>99
		let returnstatus=0
		let message$="Invalid Warehouse Number Submitted"
		goto endproddetail:
	endif
	let keyprwh$=" ",keyprwh$
	let keyprwh$[1,12]=prod$[1,12]
	let keyprwh$[13]=whse using "##"
	rec_prwh=filegetprodwhse(e$,ch_prwh,"=",1,Keyprwh$,pw.,e)
	if rec_prwh<0 ! NOT FOUND
		clear pw.
		If P61$[59,59]="Y" ! not allowed new prodwhse
			Let message$="Product "+rtrim$(PROD$)+" Not Available In Warehouse "+str$(whse)
			Let ReturnStatus=0
			goto endproddetail:
		Endif
		If rec_prwh=-1 ! not found - add now?
			Whbld[0]=ch_prwh;Whbld[1]=whse;WhBld[2]=pr.PrimVend
			Call mxwhcreate(e$,IntCo,prod$,WHBLD[])
			rec_prwh=Whbld[2];E$=""
			Read record #ch_prwh,rec_prwh,0;PW.;
		Endif
	 Endif ! of whse not found
	 Webstr$=""
	 !WebStr$="ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$
	 Webstr$=rtrim$(pr.prodcode$),fdel$
	 Webstr$=webstr$,rtrim$(pr.desc1$),fdel$
	 Webstr$=webstr$,rtrim$(pr.desc2$),fdel$
	 
	 ! Webstr$=Webstr$,"LastCost",fdel$,"AvailableQty",fdel$,"OnhandQty",fdel$,"CommitQty",fdel$
	 ! Last cost   
	 let cnvta=0
	 if p9$[32,32]="Y"
		let cnvta=pw.CostLastPo
	 endif
	 if not(cnvta) let cnvta=pr.costpo
	 if not(cnvta) let cnvta=pr.costavg
	 CNVTU[0] = 0;CNVTU[1] =pr.UMCostDefault;CNVTU[2] = 2                                                                   
	 X3 = 0                                                              
	 If CNVTA <> 0                                                       
		X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)               
	 End If                                                              
	 If X3 <> 0 And cost_lev[2] <> 0                                     
		WebStr$ = WebStr$,LTrim$(X3 Using PMask$),fdel$ !  last cost  
	Else                                                                
		WebStr$ = WebStr$,"",fdel$                                        
	End If  
	
	! availableqty
	LET CNVTU[0]=0;Cnvtu[1]=pr.umStkDefault;CNVTU[2]=1
	x3=0
	CNVTA=pw.QtyOnHand-pw.QtyOnOrd !W3[0]-W3[2] 
	If CNVTA <> 0                                                       
		X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)               
	 End If 
	 WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$  ! avail
	 ! on hand qty
	 LET CNVTU[0]=0;Cnvtu[1]=pr.umStkDefault;CNVTU[2]=1
	 x3=0
	 CNVTA=pw.QtyOnHand !W3[0]-W3[2] 
	 If CNVTA <> 0                                                       
		X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)               
	 End If 
	 WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! on hand 
	 ! committed qty
	 LET CNVTU[0]=0;Cnvtu[1]=pr.umStkDefault;CNVTU[2]=1
	 x3=0
	 CNVTA=pw.QtyOnOrd !W3[2] 
	 If CNVTA <> 0                                                       
		X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)               
	 End If 
	 WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$  ! Committed 
	 
	!Webstr$=Webstr$,"PackSize",fdel$,"CatchWeight",fdel$,"AvailableLbs",fdel$
	 webstr$=webstr$,pr.PackSize$,fdel$ 
	 if rtrim$(pr.CatchwgtItem$)<>"Y"  let pr.CatchwgtItem$="N"
	 Webstr$=webstr$,pr.CatchwgtItem$,fdel$
	 if pr.CatchwgtItem$="Y" ! catch weight item
		X3 = pw.LbsOnHand-LbsOnOrder
		WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$  ! Lbs On Hand
	 else
		WebStr$ = WebStr$,"",fdel$ ! 
	 endif
	!Webstr$=Webstr$,"CostUm",fdel$,"CostUmID",fdel$,"CostFactor",fdel$
	 CostUM$ = XUnit$(pr.umcostDefault,ch_ccode) ! u/m 
	 Webstr$=webstr$,rtrim$(costum$),fdel$
	 webstr$=webstr$,str$(pr.umcostDefault),fdel$
	 X3 = umtofactor(pr.umcostDefault) ! get um for factor  
	 WebStr$ = WebStr$,Str$(X3),fdel$ ! cost um factor
	 
	!Webstr$=Webstr$,"QtyUm",fdel$,"QtyUmId",fdel$,"QtyFactor",fdel$
	QTYUM$= XUnit$(pr.umStkDefault,ch_ccode) ! u/m 
	Webstr$=webstr$,rtrim$(qtyum$),fdel$
	Webstr$=webstr$,str$(pr.UMStkDefault),fdel$
	X3 = umtofactor(pr.UMStkDefault) ! get qty um factor   
	WebStr$ = WebStr$,Str$(X3),fdel$ ! qty factor    
	
	!Webstr$=Webstr$,"SerialNum",fdel$,"CostSecurity",fdel$,"RASL",fdel$,"LotCntrl",fdel$,"Pronto",fdel$
	webstr$=webstr$,pr.SerNoTrack$,fdel$
	WebStr$ = WebStr$,Str$(cost_lev[2]),fdel$ !  cost security
	! rasl check
	let tmp$="N"
	IF P9$[41,41]="Y"  let tmp$="Y"
	if P9$[41,41]="W" !  LET SRASL=1
		if whse>0 and whse<100
			read record #ch_wh,(whse-1),0;wh.;
			if wh.UseRasl<>0 let tmp$="Y"
		endif
	endif
	let webstr$=webstr$,tmp$,fdel$
	! lot control
	let tmp$="N"
	if p9$[1,1]="Y" let tmp$="Y"
	IF PR.LotCtrl$="Y" let tmp$="Y"
	if pr.CatchwgtItem$="Y" let tmp$="N" ! catch weight item
	webstr$=webstr$,tmp$,fdel$ ! lot control
	webstr$=webstr$,p60$[45,45],fdel$ ! pronto
	list$[2]=webstr$	
        endproddetail: ! end the product detail entry
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	clear list$[]
	LIST$[0]=bsdel$+"ProductLocation"+fdel$
	LIST$[1]="Location",fdel$,"QtyOnHand",fdel$,"QtyAvail",fdel$
	ctr = 2                                                       
	tmpcnt = maxcnt 
	if not(returnstatus) goto endprodlocdrop:
	let totrec=0
	let keyprlot$=" ",keyprlot$
	let keyprlot$[1,12]=prod$
	let keyprlot$[13,14]=whse using "##"
	do
		search #ch_sprodlot,3,2;keyprlot$,rec_prlot,e
		if e<>0 exit dO
		if keyprlot$[1,12]<>prod$[1,12] exit do
		let tmp3=keyprlot$[13,14]
		if tmp3<>whse exit DO
		read record #ch_sprodlot, rec_prlot;prlot.;
		if rtrim$(prlot.loc$)<>""
			webstr$=""
			webstr$=rtrim$(prlot.Loc$),fdel$
			X3=0
			LET CNVTA=PRLOT.QtyRcvd-prlot.qtyused
			CNVTU[0] = 0;CNVTU[1] = pr.UMStkDefault;CNVTU[2] = 1    
     			If CNVTA <> 0                                           
				X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)   
			End If                                                  
			WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty on hand
			! qty avail = 
			x3=0
			let cnvta=PRLOT.QtyRcvd-prlot.qtyused-prlot.QtyAlloc
			CNVTU[0] = 0;CNVTU[1] = pr.UMStkDefault;CNVTU[2] = 1    
     			If CNVTA <> 0                                           
				X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)   
			End If                                                  
			WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty available
			list$[ctr]=webstr$
			ctr=ctr+1
			If ctr > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
			totrec=totrec+1
		endif
	loop
	if not(totrec) ! add stock as a location
		webstr$=""
		webstr$="STOCK",fdel$
		 X3=0                                 
		WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty on hand
		WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty available
		list$[ctr]=webstr$
		ctr=ctr+1
		If ctr > tmpcnt Let tmpcnt = expandarray(e$,List$[])
	endif
	endprodlocdrop: ! end product location droplist
	list$[ctr]=esdel$ ! end of section
        Call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string                 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
 else
    include "src/callsuberr.inc"
 end try
end sub ! SetNewProdline



!--------------------------------------------------------------------------------------------------------
Function UMtoFactor(UMRec)
! from sent um # - get um factor for it
! if no match - send factor back as one (base?)
 Try
	
	dim 3%,factor
	let factor=0
	if umrec<=0 exit function 0 ! no um - no factor!
	If umrec=Pr.BaseUM let factor=1
	if umrec=PR.UM2 let factor=pr.UM2Fact
	if umrec=PR.UM3 let factor=pr.UM3Fact
	if umrec=PR.UM4 let factor=pr.UM4Fact
	if umrec=PR.UM5 let factor=pr.UM5Fact
	if umrec=PR.UM6 let factor=pr.UM6Fact
	if umrec=PR.UM7 let factor=pr.UM7Fact
	if umrec=PR.UM8 let factor=pr.UM8Fact
	
 else
    include "src/callsuberr.inc"
  end try
end Function Factor ! umtofactor
! 
!--------------------------------------------------------------------
Sub SubmitMRTS()! submit misc receipts to stock
 Try
	ReturnStatus=1
	Message$="OK" 
	! set list header
	
	Call DXGet("WHSE",tmp$) 
	let whse=tmp$
	if whse<=0 or whse>99
		let returnstatus=0
		let message$="Invalid Warehouse Number "+str$(whse)
		goto endsubmitmrts:
	endif
	Call DXGet("PRODID",prod$) \ prod$=UCase$(rtrim$(prod$))
	Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
	KeyProd$=Prod$
	!Call DXGET("UTYPE",tmp$) ! tmp$=QTY, PRICE, COST
	rec_prod=filegetprod(e$,ch_prod,"=",1,KeyProd$,PR.) ! product mode=2 dir=1
	If rec_prod<0 ! Product record not found
		 clear PR.
		 ReturnStatus=0
		 Message$="Error, Product not found "+prod$
		 goto endsubmitmrts:
	endif
        clear mrts.
	mrts.prodrec=rec_prod
	mrts.userrec=rec_uac
	Call DXGet("ENTRYNUM",tmp$)
	mrts.Entrynum=tmp$
	! let mrts.Entrynum=0 ! for now just adds
	if mrts.Entrynum<>0
		keymrts$=" ",keymrts$
		keymrts$[1,8]=mrts.Entrynum using "########"
		rec_mrts=filegetmiscrts(e$,ch_mrts,"=",1,KeyMrts$,mrts.) ! misc rts mode=2 dir=1
		If rec_mrts<0 ! Entry  record not found
			 ReturnStatus=0
			 Message$="Entry ",+str$(mrts.EntryNum)+" not on file "
			 goto endsubmitmrts:
		endif
		if mrts.status<>0
			returnStatus=0
			Message$="Entry ",+str$(mrts.EntryNum)+" is in process elswhere "
			goto endsubmitmrts:
		endif
		if mrts.ProntoAcpt<>0
			returnstatus=0
			Message$="Entry ",+str$(mrts.EntryNum)+" has already been accepted. Maynot change. "
			goto endsubmitmrts:
		endif
		Call DxGet("DELENT",tmp$)
		if rtrim$(ucase$(tmp$))="Y" 
			let mrts.qty=0
			let mrts.qtylbs=0
			write record #ch_mrts,rec_mrts,0;mrts.;
			let returnstatus=0

			ch_spoflen=OpenFile(2976,intCo) \ If Ch_spoflen = -1 Error 42 !spoflen

			keyspoflen$=" ",keyspoflen$
			keyspoflen$="R"+(mrts.Entrynum USING "########")
spoflen_loop: rec_spoflen=filegetspoflenz(e$,ch_spoflen,">=",1,keyspoflen$,posn.)
			!           filegetspoflenz(e$,chan      ,Mode$,keyno,keyval$,spoflen. As spoflenz,...)
			if REC_SPOFLEN>0 and posn.poline=mrts.Entrynum
				e$="321"  ! setting flag
				rec_spoflen=fileupdatespoflenz(e$,ch_spoflen,"d",rec_spoflen,posn.,rec_prod)
				goto spoflen_loop:
			endif
			close #ch_spoflen
			let message$="Entry "+str$(mrts.entrynum)+" Deleted."
			goto endsubmitmrts:
		Endif
		Call DxGet("QTY",tmp$)
		workqty=tmp$ ! mrts.qty
		if pr.CatchwgtItem$="Y"
			Call DxGet("QTYLB",tmp$)
			let mrts.qtylbs=tmp$
		endif
		if not (workqty) and not(mrts.qtylbs)
			let returnstatus=0
			let message$="No Quantity Has Been Entered. Cannot Update"
			goto endsubmitmrts:
		endif
		if abs(workqty)>9999999999
			let returnstatus=0
			let message$="Quantity Exceeds 9999999999"
		endif
		
	endif! lookup the entry info

	
	mrts.prodrec=rec_prod
	mrts.userrec=rec_uac
	mrts.AccessCode$=UserId$+blank$
	mrts.ProdCode$=Prod$+blank$
	mrts.whse=whse
	Call DxGet("QTY",tmp$)
	workqty=tmp$ ! mrts.qty
	if pr.CatchwgtItem$="Y"
		Call DxGet("QTYLB",tmp$)
		let mrts.qtylbs=tmp$
	endif
	if not (workqty) and not(mrts.qtylbs)
		let returnstatus=0
		let message$="No Quantity Has Been Entered. Cannot Update"
		goto endsubmitmrts:
	endif
	Call Dxget("REASONID",tmp$)
	let mrts.reasoncode=tmp$
	if mrts.reasoncode<=0 or mrts.reasoncode>99
		let returnstatus=0
		let Message$="Invalid Reason Code Entered "+str$(mrts.Reasoncode)
		goto endsubmitmrts:
	endif
	rec_rsn=mrts.reasoncode
	read record #ch_rsn,rec_rsn,0;rsn.;
	if rtrim$(rsn.Description$)="" ! validate description of reason code
		let returnstatus=0
		let Message$="Invalid Reason Code Entered "+str$(mrts.Reasoncode)
		goto endsubmitmrts:
	endif
	if p9$[17,17]="Y" ! gl interface
		if not(rsn.DefaultGL) and mrts.reasoncode<>99 ! if gl validate the default gl
			let returnstatus=0
			let Message$="Default G/L Account Not Set-Up for Reason Code "+str$(mrts.Reasoncode)
			goto endsubmitmrts:
		endif
	endif
	if workqty<>0 
		Call Dxget("QTYUMID",tmp$)
		let r=tmp$
		If tmp$[1,1] > "9" ! sent text?       
			 r = getumrec(e$,ch_ccode,tmp$,IntCo,pr.) 
			If r <> 0 Let tmp$ = Str$(r)        
		End If
		if not(r)
			returnstatus=0
			let message$="Invalid Quantity Unit of Measure Entered"
			goto endsubmitmrts:
		endif
		let mrts.Enterum=r
	else
		if pr.CatchwgtItem$="Y" and mrts.qtylbs
			let mrts.Enterum=-3
		else
			let returnstatus=0
			let message$="Invalid Qty Entered"
		endif
	endif
	! convert quantity                                             
 	CNVTU[0] = Mrts.enterum;CNVTU[1] = 0;CNVTU[2] = 1                
	CNVTA = workqty ! qty orders                                   
	mrts.qty = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.) 
                                         
	Call Dxget("COST",tmp$)
	workcost=tmp$ ! mrts.cost
	Call Dxget("COSTUMID",tmp$)
	let r=tmp$
	If tmp$[1,1] > "9" ! sent text?       
		 r = getumrec(e$,ch_ccode,tmp$,IntCo,pr.) 
		If r <> 0 Let tmp$ = Str$(r)        
	End If
	if not(r)
		returnstatus=0
		let message$="Invalid Cost Unit of Measure Entered"
		goto endsubmitmrts:
	endif
	let mrts.CostUm=tmp$
	! convert quantity                                             
 	CNVTU[0] = Mrts.Costum;CNVTU[1] = 0;CNVTU[2] = 2               
	CNVTA = workcost ! qty orders                                   
	mrts.cost = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.) 
	! validate ok um
        Call Dxget("COMMENT",tmp$)
	mrts.Comment$=tmp$+blank$
	
	IF P9$[1,1]="N" or pr.LotCtrl$<>"Y" or (pr.CatchwgtItem$="Y" and mrts.EnterUm=-3)
		let mrts.lotnum$=" ",mrts.lotnum$
		LET mrts.lotnum$[1,7]=whse USING "STOCK&&"
	else
		Call Dxget("LOTID",tmp$)
		mrts.LotNum$=tmp$+blank$
		if rtrim$(mrts.LotNum$)="" let tmp$="STOCK"
		if tmp$="STOCK" let mrts.lotnum$[6,7]=whse using "&&"
		          

	endif ! lot control chk
	if rtrim$(mrts.LotNum$)=""
		let mrts.lotnum$=" ",mrts.lotnum$
		LET mrts.lotnum$[1,7]=whse USING "STOCK&&"
	endif
	! validate correct lot is used
	! rasl check                             
	RASL=0 ! no                                
	If P9$[41,41] = "Y" Let rasl=99       
	If P9$[41,41] = "W" !  LET SRASL=1       
		If whse > 0 And whse < 100             
			Read Record #ch_wh,(whse - 1),0;wh.; 
			If wh.UseRasl <> 0 Let rasl = 99
		End If  
	Endif
	if mrts.qty=0 let rasl=0 ! no need for rasl if qty=0 
	if not(rasl)
		let mrts.location$=" ",mrts.location$
		let mrts.location$[1,5]="STOCK"
	else
		! validate location 
		Call Dxget("LOCID",tmp$)
		let mrts.location$=tmp$+blank$
		LET Keywhloc$=" ",Keywhloc$                                     
		LET Keywhloc$[1,2]=WHse USING "##"                          
		LET Keywhloc$[3,8]=mrts.location$[1,6]                                
		SEARCH #CH_WHLOC,2,1;Keywhloc$,Rec_loc,E                       
		IF E<>0
			if mrts.location$[1,5]<>"STOCK"
				let returnstatus=0
				let message$="LOCATION "+rtrim$(mrts.location$)+" IS NOT VALID FOR WH "+WHSE
				goto endsubmitmrts:
			endif
		endif
	endif	 ! end rasl chk	
	
	if mrts.reasoncode=99
		if mrts.qty>=0
			let returnstatus=0
			let message$="Quantity Entered Must be Greater than Zero"
			goto endsubmitmrts:
		endif
		Call Dxget("CONVPRODID",tmp$)
		mrts.cnvprodcode$=ucase$(rtrim$(tmp$))+blank$
		KeyProd$=mrts.cnvProdCode$
		rec_tmp=filegetprod(e$,ch_prod,"=",1,KeyProd$,cPR.) ! product mode=2 dir=1
		If rec_tmp<0 ! Product record not found
			 clear cPR.
			ReturnStatus=0
			Message$="Error, Product not found "+mrts.cnvprodcode$
			goto endsubmitmrts:
		endif
		Call DxGet("CONVQTY",tmp$)
		workcqty=tmp$ ! mrts.cnvqty
		let mrts.cnvqty=tmp$
		if workcqty<=0
			returnstatus=0
			let message$="Convert Quantity Has Not Been Entered Correctly"
			goto endsubmitmrts:
		endif
		Call DxGet("CONVQTYUMID",tmp$)
		let r=tmp$
		If tmp$[1,1] > "9" ! sent text?       
			 r = getumrec(e$,ch_ccode,tmp$,IntCo,cpr.) 
			If r <> 0 Let tmp$ = Str$(r)        
		End If
		if not(r)
			returnstatus=0
			let message$="Invalid Convert Quantity Unit of Measure Entered"
			goto endsubmitmrts:
		endif
		let mrts.CnvEnterUm=r
		! convert quantity                                             
 		CNVTU[0] = Mrts.enterum;CNVTU[1] = 0;CNVTU[2] = 1                
		CNVTA = workcqty ! qty orders                                   
		mrts.cnvqty = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,cpr.) 
		! validate if proper um for this product
		IF P9$[1,1]<>"Y" or cpr.LotCtrl$<>"Y" or (cpr.CatchwgtItem$="Y" and mrts.EnterUm=-3)
			let mrts.Cnvlotnum$=" ",mrts.cnvlotnum$
			LET mrts.cnvlotnum$[1,7]=whse USING "STOCK&&"
		else
			Call Dxget("CONVLOTID",tmp$)
			mrts.cnvLotNum$=tmp$+blank$
			if rtrim$(ucase$(tmp$))="STOCK" mrts.cnvlotnum$[6,7]=whse using "&&"
		endif
		if rtrim$(mrts.cnvLotNum$)=""
			let mrts.Cnvlotnum$=" ",mrts.cnvlotnum$
			LET mrts.cnvlotnum$[1,7]=whse USING "STOCK&&"
		endif
		if not(rasl)
			let mrts.cnvlocation$=" ",mrts.cnvlocation$
			let mrts.cnvlocation$[1,5]="STOCK"
		else
			! validate location 
			Call Dxget("CNVLOCID",tmp$)
			let mrts.cnvlocation$=tmp$+blank$
			LET Keywhloc$=" ",Keywhloc$                                     
			LET Keywhloc$[1,2]=WHse USING "##"                          
			LET Keywhloc$[3,8]=mrts.cnvlocation$[1,6]                                
			SEARCH #CH_WHLOC,2,1;Keywhloc$,Rec_loc,E                       
			IF E  
				if mrts.cnvlocation$[1,5]<>"STOCK"
					let returnstatus=0
					let message$="LOCATION "+rtrim$(mrts.location$)+" IS NOT VALID FOR WH "+WHSE
					goto endsubmitmrts:
				endif
			endif
		endif ! end rasl check
	 endif ! end of reason code # 99
	! CHECK THE LOT
	if mrts.lotnum$[1,5]="STOCK" goto bypasslotchk:
	if mrts.qty>0 goto bypasslotchk:
	if p9$[1,1]="N" goto bypasslotchk:
	if p9$[1,1]<>"Y" and pr.lotCtrl$<>"Y" goto bypasslotchk:
	IF P9$[1,1]<>"Y" and pr.CatchwgtItem$="Y" and mrts.EnterUm=-3 goto bypasslotchk:
	let keyprlot$=" ",keyprlot$
	let keyprlot$[1,12]=mrts.LotNum$[1,12]
        let keyprlot$[23,24]=Whse using "##"         
	let keyprlot$[25,30]=mrts.location$[1,6] 
	LET Keyprlot$[31,42]=mrts.prodcode$[1,12]                         
	SEARCH #Ch_sprodlot,2,1;KEYPRLOT$,REC_PRLOT,E                            
	IF e<>0 
		returnstatus=0
		let message$="Lot "+rtrim$(mrts.lotnum$)+" Not on File"
		goto endsubmitmrts:
	endif 
	read record #Ch_sprodlot,rec_prlot,0;prlot.;                               
	IF ABS(MRTS0[0])>(prlot.QtyRcvd-prlot.QtyUsed-prlot.QtyAlloc)                                       
		let returnstatus=0
		message$="Insufficient stock available for this lot. Please Adjust Quantity."
		goto endsubmitmrts:
	endif
	bypasslotchk: ! end lot control check
	! validate extended cost
	if mrts.qty>0 and mrts.cost>0
		! validate if exceptional
		let tmp4=mrts.qty*mrts.cost
		if tmp4>9999999999.99
			let returnstatus=0
			message$="Total Adjustment to Inventory Exceeds 9999999999.99"
			goto endsubmitmrts:
		endif
	endif
	if not(mrts.EntryNum)
		READ #ctlc,20,174;ENTNUM                          
		LET ENTNUM=ENTNUM+1 \ IF ENTNUM<1 LET ENTNUM=1 
		IF ENTNUM>99999999 LET ENTNUM=1                
		WRITE #ctlc,20,174;ENTNUM; 
		mrts.entrynum=entnum
		mode$ = "a" ! add                                                 
		UpdStatus = fileupdatemiscrts(e$,ch_mrts,mode$,rec_mrts,mrts.) 
		if updstatus>=0
			let rec_mrts=updstatus
		else
			returnstatus=0
			let message$="Error in Adding Entry "+str$(mrts.entrynum)
			goto endsubmitmrts:
		endif
	endif
	if rec_mrts>0
		write record #ch_mrts,rec_mrts,0;mrts.;
	endif

	! check if pronto ! check to see what needs to be open
	Call DXGet("ACCEPT",tmp$) \ tmp$=UCase$(tmp$)
	if rtrim$(tmp$)="Y"
		Call "mx324a.dl4",rec_mrts,whse,jrnl,eflg,rec_uac,message$,IntCo,rstr$,e$
		if eflg<>0
			returnstatus=2
		else
			let returnstatus=0
			let message$="Entry Accepted"
		endif
	endif

	endsubmitmrts: ! end submit of purchase order entry
	clear list$[]
	List$[0]=bsdel$,"SUBMITENTRY",fdel$
	WebStr$="EntryNum",fdel$
	list$[1]=webstr$
	if returnstatus>0
		webstr$=str$(mrts.entrynum),fdel$
	endif
	list$[2]=webstr$
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! Submitmrts
! ----------------------------------------------------------------------------------------------------
Sub GETMRTSENTRY()! Get mrtsentry
 Try
	ReturnStatus=1
	Message$="OK" 
	! set get entry
	Call DXGet("ENTRYNUM",tmp$)
	mrts.Entrynum=tmp$
	if mrts.EntryNum<=0 or mrts.EntryNum>99999999
		let returnstatus=0
		let Message$="Invalid Entry Number "+str$(EntryNum)
		goto endgetmrtsentry:
	endif
	keymrts$=" ",keymrts$
	keymrts$[1,8]=mrts.Entrynum using "########"
	rec_mrts=filegetmiscrts(e$,ch_mrts,"=",1,KeyMrts$,mrts.) ! misc rts mode=2 dir=1
	If rec_mrts<0 ! Entry  record not found
		 ReturnStatus=0
		 Message$="Entry ",+str$(mrts.EntryNum)+" not on file "
		 goto endgetmrtsentry:
	endif
	if mrts.status<>0
		returnStatus=0
		Message$="Entry ",+str$(mrts.EntryNum)+" is in process elswhere "
		goto endgetmrtsentry:
	endif
	if mrts.ProntoAcpt<>0
		returnstatus=0
		Message$="Entry ",+str$(mrts.EntryNum)+" has already been accepted. Maynot change. "
		goto endgetmrtsentry:
	endif
	if mrts.qtylbs=0 and mrts.qty=0
		returnstatus=0
		Message$="Entry ",+str$(mrts.EntryNum)+" has already been deleted. Maynot change. "
		goto endgetmrtsentry:
	endif
	Call DXGet("WHSE",tmp$)
	whse=tmp$
	iF whse<>0 
		if whse<=0 or whse>99
			let returnstatus=0
			let message$="Invalid Warehouse Number "+str$(mrts.whse)
			goto endgetmrtsentry:
		endif
		if mrts.whse<>whse
			let returnstatus=0
			let message$="Entry Warehouse Does Not Match Selected Warehouse"
			goto endgetmrtsentry:
		endif
	endif 
	
	! send over "QTY", "QTYLBS", "WHSE","PRODID"
	KeyProd$=mrts.ProdCode$
	rec_prod=filegetprod(e$,ch_prod,"=",1,KeyProd$,PR.) ! product mode=2 dir=1
	If rec_prod<0 ! Product record not found
		 clear PR.
		 ReturnStatus=0
		 Message$="Error, Product not found "+mrts.prodCode$
		 goto endgetmrtsentry:
	endif
	! send over "QTY", "QTYLBS", "WHSE","PRODID","REASONID"
        ! QTYUMID, COST, COSTUMID, COMMENT
	! LOTID, LOCID, CONVPRODID,CONVQTY, CONVQTYUMID,CONVLOTID,CONVLOCID
	IF MRTS.REASONCODE=99
		KeyProd$=mrts.cnvProdCode$
		rec_tmp=filegetprod(e$,ch_prod,"=",1,KeyProd$,cPR.) ! product mode=2 dir=1
		If rec_tmp<0 ! Product record not found
			 clear cPR.
			ReturnStatus=0
			Message$="Error, Product not found "+mrts.cnvprodcode$
			goto endgetmrtsentry:
		endif
	ENDIF
	

	endgetmrtsentry: ! end getmrtsentry
	! set section 1 - product 
	Clear List$[]
	List$[0]=bsdel$,"ENTRYDETAIL",fdel$
	WebStr$="ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$
	Webstr$=Webstr$,"Last Cost",fdel$,"AvailableQty",fdel$,"OnhandQty",fdel$,"CommitQty",fdel$
	Webstr$=Webstr$,"PackSize",fdel$,"CatchWeight",fdel$,"AvailableLbs",fdel$
	Webstr$=Webstr$,"CostUm",fdel$,"CostUmID",fdel$,"CostFactor",fdel$
	Webstr$=Webstr$,"QtyUm",fdel$,"QtyUmId",fdel$,"QtyFactor",fdel$
	Webstr$=Webstr$,"SerialNum",fdel$,"CostSecurity",fdel$,"RASL",fdel$,"LotCntrl",fdel$
	Webstr$=webstr$,"Pronto",fdel$
	Webstr$=webstr$,"QTY",fdel$,"QTYLBS",fdel$,"WHSE",fdel$,"WHNAME",fdel$,"REASONID",fdel$
	Webstr$=webstr$,"REASONDESC",fdel$,"COMMENT",fdel$,"LOTID",fdel$,"LOCID",fdel$
	webstr$=webstr$,"COST",fdel$
	
	! send over "QTY", "QTYLBS", "WHSE","PRODID","REASONID"
        ! QTYUMID, COST, COSTUMID, COMMENT
	! LOTID, LOCID, CONVPRODID,CONVQTY, CONVQTYUMID,CONVLOTID,CONVLO
        List$[1]=WebStr$
	IF returnstatus<>0
		 Webstr$=""
		!WebStr$="ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$
		 Webstr$=rtrim$(pr.prodcode$),fdel$
		 Webstr$=webstr$,rtrim$(pr.desc1$),fdel$
		 Webstr$=webstr$,rtrim$(pr.desc2$),fdel$
	 
		! Webstr$=Webstr$,"LastCost",fdel$,"AvailableQty",fdel$,"OnhandQty",fdel$,"CommitQty",fdel$
		! Last cost 
		if mrts.costum=0 and mrts.cost=0
			let mrts.costum=pr.UMCostDefault
		endif
		let cnvta=0
		if p9$[32,32]="Y"
			let cnvta=pw.CostLastPo
		 endif
		if not(cnvta) let cnvta=pr.costpo
		if not(cnvta) let cnvta=pr.costavg
		CNVTU[0] = 0;CNVTU[1] =mrts.CostUm ;CNVTU[2] = 2                                                                   
		X3 = 0                                                              
		If CNVTA <> 0                                                       
			X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)               
		End If                                                              
		If X3 <> 0 And cost_lev[2] <> 0                                     
			WebStr$ = WebStr$,LTrim$(X3 Using PMask$),fdel$ !  last cost  
		Else                                                                
			WebStr$ = WebStr$,"",fdel$                                        
		End If  
	
		! availableqty
		LET CNVTU[0]=0;Cnvtu[1]=mrts.EnterUm;CNVTU[2]=1
		x3=0
		CNVTA=pw.QtyOnHand-pw.QtyOnOrd !W3[0]-W3[2] 
		If CNVTA <> 0                                                       
			X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)               
		End If 
		WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$  ! avail
		! on hand qty
		LET CNVTU[0]=0;Cnvtu[1]=mrts.EnterUm;CNVTU[2]=1
		x3=0
		CNVTA=pw.QtyOnHand !W3[0]-W3[2] 
		If CNVTA <> 0                                                       
			X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)               
		End If 
		WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! on hand 
		! committed qty
		LET CNVTU[0]=0;Cnvtu[1]=mrts.EnterUm;CNVTU[2]=1
		x3=0
		CNVTA=pw.QtyOnOrd !W3[2] 
		If CNVTA <> 0                                                       
			X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)               
		End If 
		WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$  ! Committed 
	 
		!Webstr$=Webstr$,"PackSize",fdel$,"CatchWeight",fdel$,"AvailableLbs",fdel$
		 webstr$=webstr$,pr.PackSize$,fdel$
		 !if p61$[73,73]<>"Y" let pr.CatchwgtItem$="N"
	 if rtrim$(pr.CatchwgtItem$)<>"Y" let pr.CatchwgtItem$="N"
		 Webstr$=webstr$,pr.CatchwgtItem$,fdel$
		if pr.CatchwgtItem$="Y" ! catch weight item
			X3 = pw.LbsOnHand-LbsOnOrder
			WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$  ! Lbs On Hand
		else
			WebStr$ = WebStr$,"",fdel$ ! 
		endif
		!Webstr$=Webstr$,"CostUm",fdel$,"CostUmID",fdel$,"CostFactor",fdel$
		 CostUM$ = XUnit$(mrts.costum,ch_ccode) ! u/m 
		 Webstr$=webstr$,rtrim$(costum$),fdel$
		webstr$=webstr$,str$(mrts.costum),fdel$
		X3 = umtofactor(mrts.costum) ! get um for factor  
		WebStr$ = WebStr$,Str$(X3),fdel$ ! cost um factor
	 
		!Webstr$=Webstr$,"QtyUm",fdel$,"QtyUmId",fdel$,"QtyFactor",fdel$
		QTYUM$= XUnit$(mrts.EnterUm,ch_ccode) ! u/m 
		Webstr$=webstr$,rtrim$(qtyum$),fdel$
		Webstr$=webstr$,str$(mrts.Enterum),fdel$
		X3 = umtofactor(mrts.Enterum) ! get qty um factor   
		WebStr$ = WebStr$,Str$(X3),fdel$ ! qty factor    
	
		!Webstr$=Webstr$,"SerialNum",fdel$,"CostSecurity",fdel$,"RASL",fdel$,"LotCntrl",fdel$,"Pronto",fdel$
		webstr$=webstr$,pr.SerNoTrack$,fdel$
		WebStr$ = WebStr$,Str$(cost_lev[2]),fdel$ !  cost security
		! rasl check
		let tmp$="N"
		IF P9$[41,41]="Y"  let tmp$="Y"
		if P9$[41,41]="W" !  LET SRASL=1
			if whse>0 and whse<100
				read record #ch_wh,(whse-1),0;wh.;
				if wh.UseRasl<>0 let tmp$="Y"
			endif
		endif
		let webstr$=webstr$,tmp$,fdel$
		! lot control
		let tmp$="N"
		if p9$[1,1]="Y" let tmp$="Y"
		IF PR.LotCtrl$="Y" let tmp$="Y"
		if pr.CatchwgtItem$="Y" let tmp$="N" ! catch weight item
		webstr$=webstr$,tmp$,fdel$ ! lot control
		webstr$=webstr$,p60$[45,45],fdel$ ! pronto
		! qty
		LET CNVTU[0]=0;Cnvtu[1]=mrts.EnterUm;CNVTU[2]=1
		x3=0
		CNVTA=mrts.qty 
		If CNVTA <> 0                                                       
			X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)               
		End If 
		WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$  ! qty
		! qtylbs
		if pr.CatchwgtItem$="Y" ! catch weight item
			X3 = mrts.QtyLbs 
			WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$  ! Lbs On Hand
		else
			WebStr$ = WebStr$,"",fdel$ ! 
		endif
		webstr$=webstr$+str$(mrts.whse),fdel$
		clear wh.
		if mrts.whse>0 and mrts.whse<0
			read record #ch_wh,(mrts.whse-1),0;wh.;
		endif
		webstr$=webstr$+rtrim$(wh.WhName$),fdel$
		webstr$=webstr$+str$(mrts.ReasonCode),fdel$
		clear rsn.
		if mrts.reasoncode>0 and mrts.reasoncode<100
			read record #ch_rsn,mrts.reasoncode,0;rsn.;
		endif
		webstr$=webstr$+rtrim$(rsn.description$),fdel$! reason name
		webstr$=webstr$+rtrim$(mrts.comment$),fdel$
		webstr$=webstr$+rtrim$(mrts.LotNum$),fdel$
		webstr$=webstr$+rtrim$(mrts.Location$),fdel$
	        let cnvta=mrts.cost
		CNVTU[0] = 0;CNVTU[1] =mrts.CostUm ;CNVTU[2] = 2                                                                   
		X3 = 0                                                              
		If CNVTA <> 0                                                       
			X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)               
		End If
		if x3<>0
			WebStr$ = WebStr$,LTrim$(X3 Using PMask$),fdel$
		else
			Webstr$=webstr$,"",fdel$
		endif
		list$[2]=webstr$
	endif ! return <>0 
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	
	! CONVPRODID,CONVQTY, CONVQTYUMID,CONVLOTID,CONVLOCID
	Clear List$[]
	List$[0]=bsdel$,"ENTRYCONVDETAIL",fdel$
	WebStr$="CONVProdID",fdel$,"CONVDesc1",fdel$,"CONVDesc2",fdel$
	Webstr$=Webstr$,"ConvQtyUm",fdel$,"ConvQtyUmId",fdel$,"ConvQtyFactor",fdel$
	Webstr$=Webstr$,"ConvLotCntrl",fdel$
	Webstr$=webstr$,"CONVQTY",fdel$
	Webstr$=webstr$,"CONVLOTID",fdel$,"CONVLOCID",fdel$
	! send over "QTY", "QTYLBS", "WHSE","PRODID","REASONID"
        ! QTYUMID, COST, COSTUMID, COMMENT
	! LOTID, LOCID, CONVPRODID,CONVQTY, CONVQTYUMID,CONVLOTID,CONVLO
        List$[1]=WebStr$
	if returnstatus<>0 and mrts.reasoncode=99
		Webstr$=""
		!WebStr$="ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$
		 Webstr$=rtrim$(cpr.prodcode$),fdel$
		 Webstr$=webstr$,rtrim$(cpr.desc1$),fdel$
		 Webstr$=webstr$,rtrim$(cpr.desc2$),fdel$
		!Webstr$=Webstr$,"QtyUm",fdel$,"QtyUmId",fdel$,"QtyFactor",fdel$
		QTYUM$= XUnit$(mrts.CnvEnterUm,ch_ccode) ! u/m 
		Webstr$=webstr$,rtrim$(qtyum$),fdel$
		Webstr$=webstr$,str$(mrts.CnvEnterUm),fdel$
		X3 = umtofactor(mrts.CnvEnterUm) ! get qty um factor   
		WebStr$ = WebStr$,Str$(X3),fdel$ ! qty factor 
		! lot control for reason code #99 product
		let tmp$="N"
		if p9$[1,1]="Y" let tmp$="Y"
		IF cPR.LotCtrl$="Y" let tmp$="Y"
		if cpr.CatchwgtItem$="Y" let tmp$="N" ! catch weight item
		webstr$ = Webstr$,tmp$,fdel$
		! qty
		LET CNVTU[0]=0;Cnvtu[1]=mrts.CnvEnterUm;CNVTU[2]=1
		x3=0
		CNVTA=mrts.cnvqty 
		If CNVTA <> 0                                                       
			X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,cpr.)               
		End If 
		WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$  ! qty -- reason #99
		webstr$=webstr$+rtrim$(mrts.CnvLotNum$),fdel$
		webstr$=webstr$+rtrim$(mrts.CnvLocation$),fdel$
		list$[2]=webstr$
	endif
      	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! getmrtsentry

!!!! startreason --- 328 misc receipts to stocks reason code
! ----------------------------------------------------------------------------------------------------
Sub startreason()! Get mrtsentry
 Try
	include "src/inc/fileglglmz.inc" ! general ledger master file
	Dim glm. As glglm ! gl master file 
	dim keyglm$[50],3%,glmrec
	if p9$[17,17]="Y" or p9$[17,17]="M"
		ch_glm = OpenFile(-176,intCo) \ If ch_glm = -1 Error 42 !
	endif
	ReturnStatus=1
	Message$="OK" 
	Clear List$[]
	List$[0]=bsdel$,"General Ledger Account",fdel$
	WebStr$="GLACCTID",fdel$,"GLDESC",fdel$
        List$[1]=WebStr$
		if returnstatus<>0 
			Webstr$=""
			Webstr$="0",fdel$
			Webstr$=webstr$,"Default",fdel$
			list$[2]=webstr$
			let row=3
		endif
	If p9$[17,17]="Y" or p9$[17,17]="M"
		if returnstatus<>0 
			let tmpcnt=maxcnt ! 2000
			let keyglm$=" ",keyglm$
			do
				search #ch_glm,3,1;keyglm$,glmrec,e
				if e>0 exit do
				read record #ch_glm,glmrec;glm.;
				if glm.rectype$[1,1]="0" ! normal posting account
					let webstr$=Rtrim$(keyglm$),fdel$
					let webstr$=webstr$,rtrim$(glm.Desc$),fdel$
					let list$[row]=webstr$
					let row=row+1
					If row > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
				endif
			loop ! for the do
		endif
	endif
      	call AddToStr(e$,rstr$,List$[])          
	Call AddToStr(e$,rstr$,esdel$) ! end of section  ! gl
	Call FileDropListWhinfoz(e$,whList$[],100,ch_wh)  
	Call AddToStr(e$,rstr$,whList$[])
	Clear List$[]                                   
	Call FileDropListRsnRts(e$,List$[],100,ch_rsn)
	Call AddToStr(e$,rstr$,List$[])
	CLEAR LIST$[]
	List$[0]=bsdel$,"ReasonFlag",fdel$
	WebStr$="GLFLAG",fdel$
	list$[1]=webstr$
	let tmp$="N"
	if p9$[17,17]="M" let tmp$="Y"
	if p9$[17,17]="Y" let tmp$="Y"
	webstr$=tmp$,fdel$
	list$[2]=webstr$
	Call AddToStr(e$,rstr$,List$[]) 
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! startreason
! ------- getreason -----
! ----------------------------------------------------------------------------------------------------
Sub getreason()! Get mrtsentry
 Try
	dim 1%,reasonid
	dim glname$[22],keyglm$[12]
	dim 3%,rec,whsegl[99]
	ReturnStatus=1
	Message$="OK"
	Call Dxget("REASONID",tmp$)
	let reasonid=tmp$
	if reasonid<=0 or reasonid>99
		let returnstatus=0
		let message$="Invalid Reason Code ",str$(reasonid)
	endif
	read record #ch_rsn,reasonid,0;rsn.;
	if p9$[17,17]="Y" or p9$[17,17]="M"
		ch_glm = OpenFile(-176,intCo) \ If ch_glm = -1 Error 42 !
	endif
	Clear List$[]
	List$[0]=bsdel$,"ReasonInfo",fdel$
	WebStr$="REASONID",fdel$,"RSNDESC",fdel$
	WEBSTR$=WEBSTR$,"DFLTGLACCTID",FDEL$,"DFLTGLDESC",FDEL$,"GLFLAG",FDEL$
        List$[1]=WebStr$
	if returnstatus<>0
		Webstr$=str$(reasonid),fdel$
		WebStr$ = WebStr$ + RTrim$(rsn.description$),fdel$ ! reason name
		let tmp$=""
		if reasonid=99 let p9$[17,17]="N" ! no gl on reason code 
		if p9$[17,17]="Y" or p9$[17,17]="M"
			let webstr$=webstr$+str$(rsn.DefaultGL),fdel$
			let glname$=""
			if rsn.DefaultGl<>0
				let keyglm$=" ",keyglm$
				let keyglm$[2,9]=rsn.DefaultGl using "########"
				glname$ = getglname$(ch_glm,keyglm$,intco)
			endif
			webstr$=webstr$+rtrim$(glname$),fdel$ !gl description
			let tmp$="Y"
			if reasonid=99 let tmp$="N"
			let webstr$=webstr$,tmp$,fdel$

		else
			let webstr$=webstr$,"0",fdel$ ! gl acct #
			let webstr$=webstr$,tmp$,fdel$ ! gl description
			let webstr$=webstr$,"N",fdel$ ! gl flag
		endif
		let list$[2]=webstr$
	endif
    	call AddToStr(e$,rstr$,List$[])          
	Call AddToStr(e$,rstr$,esdel$) ! end of section  ! gl
	clear list$[]
	List$[0]=bsdel$,"ReasonWhGl",fdel$
	WebStr$="WhId",fdel$,"WhseName",fdel$
	WEBSTR$=WEBSTR$,"GLAcctId",FDEL$,"GLAcctName",FDEL$
        List$[1]=WebStr$
	if reasonid=99 let p9$[17,17]="N"
	if returnstatus<>0
		if p9$[17,17]="Y" or p9$[17,17]="M"
			mat read #ch_rsn,reasonid,30;whsegl;
			let row=2
			let tmpcnt=maxcnt ! 2000
			for rec=1 to 99
				read record #ch_wh,(rec-1),0;wh.;
				if rtrim$(wh.WhName$)<>""
					webstr$=""
					webstr$=str$(rec),fdel$
					webstr$=webstr$,rtrim$(wh.whname$),fdel$
					if not(whsegl[rec])
						webstr$=webstr$+"0"+fdel$
						webstr$=webstr$+"Default"+fdel$
					else
						let keyglm$=" ",keyglm$
						let keyglm$[2,9]=whsegl[rec] using "########"
						glname$ = getglname$(ch_glm,keyglm$,intco)
						webstr$=webstr$+str$(whsegl[rec]),fdel$
						webstr$=webstr$+rtrim$(glname$),fdel$
					endif
					let list$[row]=webstr$
					let row=row+1
					If row > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
				endif		
			next rec
		endif
	endif
	Call AddToStr(e$,rstr$,List$[])    
	Call AddToStr(e$,rstr$,esdel$) 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! get reason
!----------------------------------------------------------------------------------------------


!===========================================================================
Sub submitreason()! 
 Try
	dim 1%,reasonid
	dim glname$[22],keyglm$[12]
	dim 3%,rec,glrec,whsegl[99]
	Try Close #ch_rsn Else Rem
	ch_rsn=OpenFile(9958,intCo) \ If Ch_rsn = -1 Error 42 !misc rts reason codes
	ReturnStatus=1
	Message$="OK"
	Call Dxget("REASONID",tmp$)
	let reasonid=tmp$
	if reasonid<=0 or reasonid>99
		let returnstatus=0
		let message$="Invalid Reason Code ",str$(reasonid)
	endif
	read record #ch_rsn,reasonid,0;rsn.;
	if p9$[17,17]="Y" or p9$[17,17]="M"
		ch_glm = OpenFile(-176,intCo) \ If ch_glm = -1 Error 42 !
	endif
	Call Dxget("UPDATETYPE",tmp$)
	IF UCASE$(RTRIM$(TMP$))="D" ! delete the transaction
		! need to verify if reasoncode is in use
		let keymrts$=" ",keymrts$
		do
			search #ch_mrts,3,1;keymrts$,rec_mrts,e
			if e<>0 exit dO
			read record #ch_mrts,rec_mrts,0;mrts.;
			if mrts.reasoncode=reasonid
			    if mrts.qty<>0 or mrts.qtylbs<>0
					let returnstatus=0
					let message$="Reason Code In Use. Maynot Delete. "
					goto endsubmitreason:
				endif
			endif
		loop
		clear rsn.
		write record #ch_rsn,reasonid,0;rsn.;
		let Message$="Reason Code Deleted"
		goto endsubmitreason:
	endif
	if ucase$(rtrim$(tmp$))="A" ! adding new transaction
		clear rsn.
		rsn.reason$=reasonid using "###"
	endif
	Call Dxget("RSNDESC",tmp$)
	rsn.Description$=tmp$+blank$
	if rtrim$(rsn.Description$)=""
		returnstatus=0
		let message$="Description Needs to Be Entered"
		goto endsubmitreason:
	endif
	if p9$[17,17]="M" or p9$[17,17]="Y"
		if reasonid<>99
			Call dxget ("DFLTGLACCTID",tmp$)
			let rsn.DefaultGL=tmp$
			if not(rsn.DefaultGl)
				let message$="G/L Account Number Must Be Entered."
				let returnstatus=0
				goto endsubmitreason:
			endif
			if rsn.DefaultGl<>0
				let keyglm$=" ",keyglm$
				let keyglm$[2,9]=rsn.DefaultGl using "########"
				search #ch_glm,2,1;keyglm$,glrec,e
				if e<>0
					let message$="G/L Account Number "+str$(rsn.DefaultGl)+" Not on File."
					let returnstatus=0
					goto endsubmitreason:
				endif
			endif
			Call Dxget("TOTREC",tmp$)
			let totrec=tmp$
			if totrec<0 or totrec>99
				let message$="Invalid Number of Warehouses for General Account Submitted."
				let returnstatus=0
				goto endsubmitreason:
			endif
			if totrec>0
				mat read #ch_rsn,reasonid,30;whsegl;
				for rec=1 to totrec
					Call dxget("WHID" + Str$(REC),tmp$)
					let wh=tmp$
					if wh<1 or wh>99
						let message$="Invalid Warehouse Number Submitted"
						let returnstatus=0
						goto endsubmitreason:
					endif
					CALL dxget ("GLACCTID"+STR$(REC),tmp$)
					let whsegl[wh]=tmp$
					if whsegl[wh]<>0
						let keyglm$=" ",keyglm$
						let keyglm$[2,9]=whsegl[wh] using "########"
						search #ch_glm,2,1;keyglm$,glrec,e
						if e<>0
							let message$="G/L Account Number "+str$(rsn.DefaultGl)+" For Warehouse "+str$(wh)+" Not on File."
							let returnstatus=0
							goto endsubmitreason:
						endif
					endif
				next rec
			endif ! endif totrec
		endif ! endif reason code #99
	endif ! gl flag
	write record #ch_rsn,reasonid,0;rsn.;
	if p9$[17,17]="M" or p9$[17,17]="Y"
		if reasonid<>99
			whsegl[0]=rsn.DEFAULTGL
			mat write #ch_rsn,reasonid,30;whsegl;
		endif
	endif
	endsubmitreason: ! end of reason submit
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! submitreason
! --------------------------------------------------------------------
Sub getFifoPROD()! send detail for fifoedit
 Try
	ReturnStatus=1
	Message$="OK" 
	! set list header
	Call DXGet("PRODID",tmp$)
	tmp$=Ucase$(RTrim$(tmp$))
	if tmp$="" 
		let returnstatus=0
		Let message$="Invalid Product Code Submitted"
		goto endgetfifoprod:
	endif
	Prod$=tmp$+blank$
	Let keyprod$=Prod$
	Let keyprod$[13]="";e=0 ! no lock
        rec_prod = filegetprod(e$,ch_prod,"=",1,Keyprod$,PR.,e)
	If rec_prod<=0 ! not found
		Let message$="PRODUCT "+rtrim$(prod$)+" NOT FOUND"
		Let ReturnStatus=0
		goto endgetfifoprod:
	Endif
	endgetfifoprod: ! 
	clear List$[]
	List$[0]=bsdel$,"PRODUCTDETAIL",fdel$
	WebStr$="ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$
	List$[1]=WebStr$
	row=2
	if returnstatus<>0
		Webstr$=""
		!WebStr$="ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$
		Webstr$=rtrim$(pr.prodcode$),fdel$
		Webstr$=webstr$,rtrim$(pr.desc1$),fdel$
		Webstr$=webstr$,rtrim$(pr.desc2$),fdel$
		list$[row]=webstr$
		let row=row+1
	endif
	let list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])
	               
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
 else
    include "src/callsuberr.inc"
 end try
end sub ! GetFifoProd

! --------------------------------------------------------------------
Sub getFifolot()! send detail for fifoedit
 Try
	dim 2%,fifl
	MAT  READ #CTLC,3,192;FIFL;
	ReturnStatus=1
	Message$="OK" 
	! set list header
	Call DXGet("PRODID",tmp$)
	tmp$=Ucase$(RTrim$(tmp$))
	if tmp$="" 
		let returnstatus=0
		Let message$="Invalid Product Code Submitted"
		goto endgetfifolot:
	endif
	Prod$=tmp$+blank$
	Let keyprod$=Prod$
	Let keyprod$[13]="";e=0 ! no lock
        rec_prod = filegetprod(e$,ch_prod,"=",1,Keyprod$,PR.,e)
	If rec_prod<=0 ! not found
		Let message$="PRODUCT "+rtrim$(prod$)+" NOT FOUND"
		Let ReturnStatus=0
		goto endgetfifolot:
	Endif
	Call DXGet("WHSE",tmp$)
	tmP3=RTrim$(tmp$)
	if tmp3<1 OR tmp3>99
		let returnstatus=0
		Let message$="Invalid Warehouse Submitted"
		goto endgetfifolot:
	endif
	let whse=tmp3
	Call DXGet("TRANSID",tmp$)
	tmP3=RTrim$(tmp$)
	if tmp3<1 OR tmp3>999999
		let returnstatus=0
		Let message$="Invalid Transaction Code Submitted"
		goto endgetfifolot:
	endif
	transid=tmp3
	let keyfl$=" ",keyfl$
	let keyfl$[1,12]=prod$[1,12]
	let keyfl$[13,14]=whse using "##"
	!let keyfl$[15,20]=transid using "######"
	Do
		search #ch_fl,3,1;keyfl$,rec_fl,e
		if e<>0 exit do
		if keyfl$[1,12]<>prod$[1,12] exit do
		let tmp3=keyfl$[13,14] 
		if whse<>tmp3 exit do
		if rec_fl=transid exit do
	loop
	if rec_fl<>transid
		let returnstatus=0
		Let message$="Transaction Not on File"
		goto endgetfifolot:
	endif
	LET REC_FL=TRANSID
	read record #ch_fl,rec_fl;fl.;
	IF PROD$[1,12]<>FL.ProductCode$[1,12]
		let returnstatus=0
		Let message$="Invalid Transaction for this product"
		goto endgetfifolot:
	endif
	if whse<>fl.WarehouseNumber
		let returnstatus=0
		Let message$="Invalid Transaction for this product/warehouse"
		goto endgetfifolot:
	endif
	endgetfifolot: ! 
	clear List$[]
	List$[0]=bsdel$,"FIFOLOTDETAIL",fdel$
	WebStr$="ProdID",fdel$,"Whse",fdel$,"Transid",fdel$
	webstr$=webstr$,"Comment",fdel$
	webstr$=webstr$,"Qty",fdel$,"QtyUm",fdel$
	webstr$=webstr$,"TransDate",fdel$
	webstr$=webstr$,"ActualCost",fdel$
	webstr$=webstr$,"LoadCost",fdel$
	webstr$=webstr$,"CostUm",Fdel$
	webstr$=webstr$,"CostUmID",fdel$
	webstr$=webstr$,"CostFactor",fdel$
	webstr$=webstr$,"LoadPct",fdel$
	webstr$=webstr$,"Wgtfact",fdel$
	webstr$=webstr$,"WgtUm",fdel$
	List$[1]=WebStr$
	row=2
	if returnstatus<>0
		Webstr$=""
		Webstr$=rtrim$(pr.prodcode$),fdel$
		Webstr$=webstr$,str$(whse),fdel$
		Webstr$=webstr$,str$(transid),fdel$
		Webstr$=webstr$,rtrim$(fl.Comment$),fdel$
		! ADD THE WEIGHT FACTOR
		if fl.LbsUnit<>0 and fl.LbsFactor<>0
			 pr.LbsFact=fl.LbsFactor  
			 pr.LbsUnit=fl.LbsUnit
		endif
		IF PR.CatchwgtItem$="Y" AND P61$[73,73]="Y"                 
			LET QTY=FL.OrigQtyRecd
			let pr.umcostdefault=-2
		else
			LET CNVTA=FL.OrigQtyRecd
			CNVTU[0]=0;CNVTU[1]=pr.UMCostDefault;CNVTU[2]=1 
			qty=0
			If CNVTA <> 0                                            
				qty = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)    
			End If  
		endif
		WebStr$ = WebStr$,LTrim$(qty Using QMask$),fdel$
		costum$ = XUnit$(pr.UMCostDefault,ch_ccode) ! u/m      
		WebStr$ = WebStr$,RTrim$(costum$),fdel$ 
		xdate$ = ""                                 
		If fl.origindate <> 0                         
			xdate$ = fl.origindate Using "&&&&&&"       
			Call JulianToDate(1,xdate$,xdate$,errFlag)
		End If  
		webstr$=webstr$,xdate$,fdel$   
		! actual cost
		LET CNVTA=fl.CostReceivedAt
		CNVTU[0]=0;CNVTU[1]=pr.UMCostDefault;CNVTU[2]=2 
		X3=0
		If CNVTA <> 0                                            
			X3= ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)    
		End If  
		WebStr$ = WebStr$,LTrim$(X3 Using PMask$),fdel$ ! ACTUAL COST
		! load cost
		LET CNVTA=fl.LoadCost
		CNVTU[0]=0;CNVTU[1]=pr.UMCostDefault;CNVTU[2]=2 
		X3=0
		If CNVTA <> 0                                            
			X3= ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)    
		End If  
		WebStr$ = WebStr$,LTrim$(X3 Using PMask$),fdel$! LoadCost
		costum$ = XUnit$(pr.UMCostDefault,ch_ccode) ! u/m  !webstr$=webstr$,"CostUm",Fdel$     
		WebStr$ = WebStr$,RTrim$(costum$),fdel$  ! um description 
		WebStr$ = WebStr$,Str$(pr.UMCostDefault),fdel$    ! cost um id     
		X3 = umtofactor(pr.UMCostDefault) ! get um for factor id 
		WebStr$ = WebStr$,Str$(X3),fdel$ ! cost um factor 
		webstr$=webstr$,STR$(FIFL),fdel$ ! LOAD %
                webstr$=webstr$,STR$(fl.LbsFactor),fdel$ ! Wgtfact
		webstr$=webstr$,str$(fl.LbsUnit),fdel$                      
		list$[row]=webstr$
		let row=row+1
	Endif
	let list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])             
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
 else
    include "src/callsuberr.inc"
 end try
end sub ! GetFifoProd


! --------------------------------------------------------------------
Sub submitfifolot()! get detail for fifoedit
 Try
	DIM 1%,FT1[3],FT1$[72],2%,FT2[3],3%,FT3[3]
	DIM 2%,FIFOSPECCH[10]
	DIM LETTER$[1]
	dim 1%,poglflag,spo,c0[4],spcflag
	dim 2%,fifl,olddate,newdate,postper,currjdate,ardate,currdate
	dim 3%,newcost,oldcost,FTREA,FTREB
	MAT  READ #CTLC,3,192;FIFL;
	MAT  READ #ctlc,51,88;POGLFLAG;
	MAT  READ #ctlc,51,76;SPO;
	MAT  READ #ctlc,0,108;ARDATE;   
	MAT  READ #CTLC,51,18;C0;
	LET Xdate$=ARDATE USING "&&&&&&" \ LET POSTPER=Xdate$[1,4] 
	tmp$ = Tim(4) Using "&&&&&&"          
	work$ = tmp$[5,6],tmp$[1,2],tmp$[3,4] 
	currdate = work$  ! YYMMDD FORMAT
	tmp$ = currdate Using "&&&&&&" ! yymmdd format
	Call DateToJulian(1,tmp$,tmp1$,errFlag)     
	currjdate = tmp1$                             
	     
	ReturnStatus=1
	Message$="OK" 
	! set list header
	Call DXGet("PRODID",tmp$)
	tmp$=Ucase$(RTrim$(tmp$))
	if tmp$="" 
		let returnstatus=0
		Let message$="Invalid Product Code Submitted"
		goto endsubmitfifolot:
	endif
	Prod$=tmp$+blank$
	Let keyprod$=Prod$
	Let keyprod$[13]="";e=0 ! no lock
        rec_prod = filegetprod(e$,ch_prod,"=",1,Keyprod$,PR.,e)
	If rec_prod<=0 ! not found
		Let message$="PRODUCT "+rtrim$(prod$)+" NOT FOUND"
		Let ReturnStatus=0
		goto endsubmitfifolot:
	Endif
	Call DXGet("WHSE",tmp$)
	tmP3=RTrim$(tmp$)
	if tmp3<1 OR tmp3>99
		let returnstatus=0
		Let message$="Invalid Warehouse Submitted"
		goto endsubmitfifolot:
	endif
	let whse=tmp3
	Call DXGet("TRANSID",tmp$)
	tmP3=RTrim$(tmp$)
	if tmp3<1 OR tmp3>999999
		let returnstatus=0
		Let message$="Invalid Transaction Code Submitted"
		goto endsubmitfifolot:
	endif
	transid=tmp3
	let keyfl$=" ",keyfl$
	let keyfl$[1,12]=prod$[1,12]
	let keyfl$[13,14]=whse using "##"
	!let keyfl$[15,20]=transid using "######"
	Do
		search #ch_fl,3,1;keyfl$,rec_fl,e
		if e<>0 exit do
		if keyfl$[1,12]<>prod$[1,12] exit do
		let tmp3=keyfl$[13,14] 
		if whse<>tmp3 exit do
		if rec_fl=transid exit do
	loop
	if rec_fl<>transid
		let returnstatus=0
		Let message$="Transaction Not on File"
		goto endsubmitfifolot:
	endif
	LET REC_FL=TRANSID
	read record #ch_fl,rec_fl;fl.;
	IF PROD$[1,12]<>FL.ProductCode$[1,12]
		let returnstatus=0
		Let message$="Invalid Transaction for this product"
		goto endsubmitfifolot:
	endif
	if whse<>fl.WarehouseNumber
		let returnstatus=0
		Let message$="Invalid Transaction for this product/warehouse"
		goto endsubmitfifolot:
	endif
	CHNGFLAG=0
	Call DXGet("TRANSDATE",tmp$)
	if tmp$=""
		let returnstatus=0
		let message$="Invalid Date Submitted "
		goto endsubmitfifolot:
	endif
	xdate$ = formatdate2$(tmp$)
	let tmp3=xdate$[3,8] ! yymmdd format
	if not(tmp3)
		let returnstatus=0
		let message$="Invalid Date Submitted "
		goto endsubmitfifolot:
	endif
	let olddate=fl.origindate
        xdate$ = tmp3 Using "&&&&&&"                 
	Call DateToJulian(5,xdate$,xdate$,errFlag)   
	If (errFlag)                                 
		let returnstatus=0
		let message$="Invalid Date Submitted "
		goto endsubmitfifolot:
	endif
	let newdate = xdate$ ! needs to be in julian
	if fl.LbsUnit<>0 and fl.LbsFactor<>0
		 pr.LbsFact=fl.LbsFactor  
		 pr.LbsUnit=fl.LbsUnit
	endif
	CALL DXGET("ActualCost",TMP$)
	let cost=tmp$
        Call DXGet("COSTUMID",tmp$)                                
	r = tmp$                                                   
	If tmp$[1,1] > "9" ! sent text?                            
		r = getumrec(e$,ch_ccode,tmp$,intCo,pr.)                 
		If r <> 0 Let tmp$ = Str$(r)                             
	End If                                                     
	If Not(r)                                                  
		ReturnStatus = 0                                         
		Message$ = "Invalid Cost Unit of Measure Entered"        
		Goto  endsubmitfifolot:                                      
	End If
	cnvta=cost
	cnvtu[0]=tmp$ !                                         
	CNVTU[1] = 0;CNVTU[2] = 2                                        
	newcost = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.) 
	oldcost=fl.CostReceivedAt 
	if olddate=newdate and oldcost=newcost
		goto endsubmitfifolot
	endif
	if oldcost<>newcost
		fl.LoadCost=newcost+(newcost*(fifl/100))
		fl.costreceivedat=newcost
	endif
	if olddate<>newdate
		let fl.origindate=newdate
		let keyfl$=" ",keyfl$
		let keyfl$[1,12]=prod$[1,12]
		let keyfl$[13,14]=whse using "##"
		let keyfl$[15,20]=olddate using "######"
		let keyfl$[21,26]=transid using "######"
		search #ch_fl,5,1;keyfl$,rec_tmp,e
		let keyfl$[15,20]=newdate using "######"
		search #ch_fl,4,1;keyfl$,rec_fl,e
	endif
	write record #ch_fl,rec_fl;fl.;
	! Update the fifo transaction 
	Clear ft.
	ft.ProductCode$=fl.ProductCode$   
	ft.LotCode$=fl.LotCode$                  
	ft.SerialNumber$=fl.SerialNumber$
	ft.Location$=fl.Location$ 
	ft.Source$=" ",ft.source$
	ft.source$[1,8]="PROG 792"
	ft.Comment$=" ",ft.Comment$
	IF olddate<>newdate AND oldcost<>newcost                                 
		LET ft.Comment$="COST & DATE ADJUST  "                               
	ELSE                                                                   
		IF olddate<>newdate                                                 
			LET FT.Comment$="DATE ADJUSTMENT     " 
		ELSE                                                                 
			IF oldcost<>newcost                                                   
				LET FT.Comment$="COST ADJUSTMENT     "
			endif
		endif
	endif
	ft.TransactionType=6     
	ft.Warehouse=fl.WarehouseNumber      
	ft.PortOfTrans=rec_uac            
	ft.FifolotTrans=rec_fl
	ft.Fifotrans=rec_ft      
	ft.TransactionDate=currjdate!  julian date !! need t    
	ft.NotUsed1=postper!  post period yymm    
	ft.Quantity=0      
	ft.FifoCost=fl.CostReceivedAt     
	ft.FifoLoadCost=fl.LoadCost     
	ft.SpecialCost=0  
	let keyft$=" ",keyft$
	LET E=2 \ SEARCH #ch_ft,1,0;keyft$,rec_ft,E
	if e<>0
		let returnstatus=0
		let message$="Error Updating Fifo Transaction File"
		goto endsubmitfifolot:
	endif              
	IF rec_ft<=999999 
		let ft.Fifotrans=rec_ft
	endif
	write record #ch_ft,rec_ft;ft.;
	! write fifo trans! GOSUB L_8100:                                                             
	LET KEYFT$[1,6]=ft.FifolotTrans USING "######"
	LET KEYFT$[7,12]=ft.TransactionDate USING "######"
	IF ft.Fifotrans<=999999                                    
		LET KEYFT$[13,18]=ft.Fifotrans USING "######"            
	ELSE                                               
		LET FTRECA=INT((ft.Fifotrans-1000000)/100000)            
		LET FTRECB=FRA(ft.Fifotrans/100000)*100000 
		Call String(4,FTRECA + 193,LETTER$)              
		LET KEYFT$[13,13]=LETTER$[1,1]                     
		LET KEYFT$[14,18]=FTRECB USING "#####"             
	ENDIF                                              
	SEARCH #CH_FT,4,1;KEYFT$,REC_FT,E  
        if e<>0
		let returnstatus=0
		let message$="Error Updating Fifo Transaction File"
		goto endsubmitfifolot:
	endif                                                    
	IF oldcost<>newcost                                          
	    IF P9$[17,17]="Y" AND POGLFLAG<>0 AND C0[4]<>0 AND SPO<>0  	
		LET FIFOSPECCH[0]=ch_fl                                                
		LET FIFOSPECCH[1]=ch_ft                                                
		MAT  read #ch_ft,rec_ft,0;FT1$; 
		MAT  read #ch_ft,rec_ft,72;FT1; 
		MAT  read #ch_ft,rec_ft,80;FT2; 
		MAT  read #ch_ft,rec_ft,96;FT3; 
		Call "MXFIFOVAR.dl4",FIFOSPECCH[],rec_fl,rec_ft,oldcost,newcost,FT1$,FT1[],FT2[],SPCFLAG,e$,IntCo,rstr$                                                  
	    endif
	endif

	endsubmitfifolot: !   
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
 else
    include "src/callsuberr.inc"
 end try
end sub ! GetFifoProd

! --------------------------------------------------------------------
Sub getPRODxfer()! for location transfers
 Try
	ReturnStatus=1
	Message$="OK" 
	! set list header
	Clear List$[]
	List$[0]=bsdel$,"PRODDETAIL",fdel$
	WebStr$="ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$
	Webstr$=Webstr$,"QtyUm",fdel$,"QtyUmId",fdel$,"QtyFactor",fdel$
	Webstr$=Webstr$,"SerialNum",fdel$,"CostSecurity",fdel$,"RASL",fdel$,"LotCntrl",fdel$
    Webstr$=Webstr$,"CostUm",fdel$,"CostUmID",fdel$,"CostFactor",fdel$,"LastCost",fdel$
	List$[1]=WebStr$
	row=2
	Call DXGet("PRODID",tmp$)
	tmp$=Ucase$(RTrim$(tmp$))
	if tmp$="" 
		let returnstatus=0
		Let message$="Invalid Product Code Submitted"
		goto endprodxfer:
	endif
	Prod$=tmp$+blank$
	Let keyprod$=Prod$
	Let keyprod$[13]="";e=0 ! no lock
        rec_prod = filegetprod(e$,ch_prod,"=",1,Keyprod$,PR.,e)
	If rec_prod<=0 ! not found
		Let message$="PRODUCT "+rtrim$(prod$)+" NOT FOUND"
		Let ReturnStatus=0
		goto endprodxfer:
	Endif
	! check if in product warehouse
	Call dxget ("WHSE",tmp$)
	let whse=tmp$
	if whse<=0 or whse>99
		let returnstatus=0
		let message$="Invalid Warehouse Number Submitted"
		goto endprodxfer:
	endif
	let keyprwh$=" ",keyprwh$
	let keyprwh$[1,12]=prod$[1,12]
	let keyprwh$[13]=whse using "##"
	rec_prwh=filegetprodwhse(e$,ch_prwh,"=",1,Keyprwh$,pw.,e)
	if rec_prwh<0 ! NOT FOUND
		clear pw.
		If P61$[59,59]="Y" ! not allowed new prodwhse
			Let message$="Product "+rtrim$(PROD$)+" Not Available In Warehouse "+str$(whse)
			Let ReturnStatus=0
			goto endprodxfer:
		Endif
		If rec_prwh=-1 ! not found - add now?
			Whbld[0]=ch_prwh;Whbld[1]=whse;WhBld[2]=pr.PrimVend
			Call mxwhcreate(e$,IntCo,prod$,WHBLD[])
			rec_prwh=Whbld[2];E$=""
			Read record #ch_prwh,rec_prwh,0;PW.;
		Endif
	 Endif ! of whse not found

	 Webstr$=""
	 !WebStr$="ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$
	 Webstr$=rtrim$(pr.prodcode$),fdel$
	 Webstr$=webstr$,rtrim$(pr.desc1$),fdel$
	 Webstr$=webstr$,rtrim$(pr.desc2$),fdel$
	
	 
	!Webstr$=Webstr$,"QtyUm",fdel$,"QtyUmId",fdel$,"QtyFactor",fdel$
	QTYUM$= XUnit$(pr.umStkDefault,ch_ccode) ! u/m 
	Webstr$=webstr$,rtrim$(qtyum$),fdel$
	Webstr$=webstr$,str$(pr.UMStkDefault),fdel$
	X3 = umtofactor(pr.UMStkDefault) ! get qty um factor   
	WebStr$ = WebStr$,Str$(X3),fdel$ ! qty factor    
	
	!Webstr$=Webstr$,"SerialNum",fdel$,"CostSecurity",fdel$,"RASL",fdel$,"LotCntrl",fdel$,"Pronto",fdel$
	webstr$=webstr$,pr.SerNoTrack$,fdel$
	WebStr$ = WebStr$,Str$(cost_lev[2]),fdel$ !  cost security
	! rasl check
	let tmp$="N"
	IF P9$[41,41]="Y"  let tmp$="Y"
	if P9$[41,41]="W" !  LET SRASL=1
		if whse>0 and whse<100
			read record #ch_wh,(whse-1),0;wh.;
			if wh.UseRasl<>0 let tmp$="Y"
		endif
	endif
	let webstr$=webstr$,tmp$,fdel$
	let srasl=0
	if tmp$="Y" let srasl=1
	! lot control
	let tmp$="N"
	if p9$[1,1]="Y" let tmp$="Y"
	IF PR.LotCtrl$="Y" let tmp$="Y"
	if pr.CatchwgtItem$="Y" let tmp$="N" ! catch weight item
	if not(srasl) and tmp$="N" ! No locations/No Lots
		let message$="No locations or lots for this product"
		let returnstatus=0
	endif
	webstr$=webstr$,tmp$,fdel$ ! lot control
	!!! cost
	CostUM$ = XUnit$(pr.umcostDefault,ch_ccode) ! u/m 
	 Webstr$=webstr$,rtrim$(costum$),fdel$
	 webstr$=webstr$,str$(pr.umcostDefault),fdel$
	 X3 = umtofactor(pr.umcostDefault) ! get um for factor  
	 WebStr$ = WebStr$,Str$(X3),fdel$ ! cost um factor
	let cnvta=0
	 if p9$[32,32]="Y"
		let cnvta=pw.CostLastPo
	 endif
	 if not(cnvta) let cnvta=pr.costpo
	 if not(cnvta) let cnvta=pr.costavg
	 CNVTU[0] = 0;CNVTU[1] =pr.UMCostDefault;CNVTU[2] = 2                                                                   
	 X3 = 0                                                              
	 If CNVTA <> 0                                                       
		X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)               
	 End If                                                              
	 If X3 <> 0 And cost_lev[2] <> 0                                     
		WebStr$ = WebStr$,LTrim$(X3 Using PMask$),fdel$ !  last cost  
	Else                                                                
		WebStr$ = WebStr$,"",fdel$                                        
	End If  
	
	list$[2]=webstr$
	row=3
    endprodxfer: ! end the product detail entry
	list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
 else
    include "src/callsuberr.inc"
 end try
end sub ! getprodxfer

Sub gettoprlotloc()! verifies lot/locaton
Try
	ReturnStatus=1
	Message$="OK" ! 
	Call DXGet("WHSE",tmp$) 
	let whse=tmp$
	if whse<=0 or whse>99
		let returnstatus=0
		let message$="Invalid Warehouse Number "+str$(whse)
		goto endtoprlotloc:
	endif
	Call DXGet("PRODID",prod$) \ prod$=UCase$(rtrim$(prod$))
	Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
	KeyProd$=Prod$
	rec_prod=filegetprod(e$,ch_prod,"=",1,KeyProd$,PR.) ! product mode=2 dir=1
	If rec_prod<0 ! Product record not found
			clear PR.
			ReturnStatus=0
			Message$="Error, Product not found"
			goto endtoprlotloc:
	endif
	Call DXGet("RASL",tmp$) \ Let Rasl=0
	if UCASE$(rtrim$(tmp$))="Y" let RASL=99
	If rasl=0
		let locid$="STOCK "
	else
		Call DXGet("TOLOCID",locid$) \ locid$ = UCase$(locid$)
		let locid$=locid$+blank$
		if locid$[1,6]<>"STOCK "
			Keywhloc$ = " ",Keywhloc$                        
			Keywhloc$[1,2] = whse Using "##" 
			keywhloc$[3,8]=locid$
			Search #CH_WHLOC,2,1;Keywhloc$,rec_whloc,e
			if e<>0
				let message$="Location "+rtrim$(locid$)+" for tag "+rtrim$(tagid$)+" Has not been defined for warehouse "+str$(whse)
				let returnstatus=0
				goto endtoprlotloc:
			endif
		endif
	endif
	Call DXGet("LOTCNTRL",tmp$) \ Let lotflag=0
	if UCASE$(rtrim$(tmp$))="Y" let lotflag=99
	if rasl=0 and lotflag=0
		returnstatus=0
		message$="Error, No Location or Lot for this Product"
		goto endtoprlotloc:
	endif
	if not (lotflag)
		let lotid$=whse using "STOCK&&"
		let lotid$=lotid$+blank$
	else
		Call DXGet("TOLOTID",loTid$) \ lotid$ = UCase$(loTid$)
		let loTid$=loTid$+blank$
		If rtrim$(lotid$)=""
			returnstatus=0
			message$="Error, No Location or Lot for this Product"
			goto endtoprlotloc:
		endif
	endif
	Call Dxget ("UMID",tmp$)
	let umid=tmp$
	if not(umid) let umid=pr.UMStkDefault
	endtoprlotloc:! end
	clear list$[]	
	LIST$[0]=bsdel$+"ProdToLocLot"+fdel$
	let webstr$=""
	let webstr$="Location",fdel$,"Lot",fdel$
	let webstr$=webstr$,"DateRecd",fdel$,"QtyRecd",fdel$
	let webstr$=webstr$,"LastUsed",fdel$,"QtyUsed",fdel$
	let webstr$=webstr$,"QtyOnOrd",fdel$,"QtyAvail",fdel$
	LIST$[1]=webstr$
	ctr = 2
	if returnstatus<>0 ! find the lot
		let keyprlot$=" ",keyprlot$
		let keyprlot$[1,12]=pr.prodcode$
		let keyprlot$[13,14]=whse using "##"
		let keyprlot$[15,26]=lotid$
		! STOCK # NOT USED
		let keyprlot$[37,42]=locid$               
		Search #Ch_sprodlot,2,4;KEYPRLOT$,rec_prlot,e
		if e<>0
			let rec_prlot=0
			returnstatus=2
			let message$="Create New "
			if lotflag$="Y"
				let message$=message$+"Lot"
				if rasl<>0 let message$=message$+" and Location "
			else
				let message$=message$+"Location"
			endif
			clear prlot.
			let prlot.loc$=locid$
			let prlot.lotnum$=lotid$
		else
			read record #ch_sprodlot, rec_prlot;prlot.;
		endif
		webstr$=""
		if rasl<>0
			webstr$=rtrim$(prlot.Loc$),fdel$
		else
			let tmp$=""
			webstr$=tmp$,fdel$
		endif
		if lotflag<>0
			let webstr$=webstr$+rtrim$(prlot.LotNum$),fdel$
		else
			let tmp$=""
			let webstr$=webstr$,tmp$,fdel$
		endif
		let tmp$=prlot.DateRcvd using "&&&&&&"
		let webstr$=webstr$,tmp$[3,4],"/",tmp$[5,6],"/",tmp$[1,2],fdel$
		X3=0
		LET CNVTA=PRLOT.QtyRcvd
		CNVTU[0] = 0;CNVTU[1] = umid;CNVTU[2] = 1    
     	If CNVTA <> 0                                           
			X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)   
		End If                                                  
		WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty on received
		let tmp$=prlot.LastDateUsed using "&&&&&&"
		let webstr$=webstr$,tmp$[3,4],"/",tmp$[5,6],"/",tmp$[1,2],fdel$
		X3=0
		LET CNVTA=prlot.qtyused
		CNVTU[0] = 0;CNVTU[1] = pr.UMStkDefault;CNVTU[2] = 1    
     	If CNVTA <> 0                                           
			X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)   
		End If                                                  
		WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty on used
		X3=0
		LET CNVTA=prlot.QtyAlloc
		CNVTU[0] = 0;CNVTU[1] = umid;CNVTU[2] = 1    
     	If CNVTA <> 0                                           
			X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)   
		End If                                                  
		WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty on order 
		x3=0
		let cnvta=PRLOT.QtyRcvd-prlot.qtyused-prlot.QtyAlloc
		CNVTU[0] = 0;CNVTU[1] = umid;CNVTU[2] = 1    
     	If CNVTA <> 0                                           
			X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)   
		End If                                                  
		WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty available
		list$[ctr]=webstr$
		ctr=ctr+1
	endif
	list$[ctr]=esdel$
	Call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string                                                                       
	Call CreateNetStatus(e$,returnstatus,message$,webstr$)
	Call AddToStr(e$,rstr$,webstr$)
	Call SetOutPut(e$,rstr$) 
else
    include "src/callsuberr.inc"
 end try
end sub ! gettoprlotloc


!--------------------------------------------------------------------
Sub Submitlocx()! submit location transfer
 Try
     Dim dfltrloc$[6],dfltcmloc$[6],dfltdock$[6]
	   MAT  READ #ctlc,69,52;DFLTRLOC$;    
	   MAT  READ #ctlc,69,160;DFLTCMLOC$;
	   let dfltdock$="DOCK"
	ReturnStatus=1
	Message$="OK" 
	! set list header
	Close #ch_sprodlot ! need read/write
	Ch_prodlot=OpenFile(2528,intCo) \ If Ch_sprodlot = -1 Error 42 !sprodlot file
	Call DXGet("WHSE",tmp$) 
	let whse=tmp$
	if whse<=0 or whse>99
		let returnstatus=0
		let message$="Invalid Warehouse Number "+str$(whse)
		goto endsubmitlocx:
	endif
	Call DXGet("PRODID",prod$) \ prod$=UCase$(rtrim$(prod$))
	Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
	KeyProd$=Prod$
	rec_prod=filegetprod(e$,ch_prod,"=",1,KeyProd$,PR.) ! product mode=2 dir=1
	If rec_prod<0 ! Product record not found
		 clear PR.
		 ReturnStatus=0
		 Message$="Error, Product not found "+prod$
		 goto endsubmitlocx:
	endif
	Keyprwh$ = " ",Keyprwh$                                                   
	Keyprwh$[1,12] = prod$[1,12]                                              
	Keyprwh$[13] = whse Using "##"                                            
	rec_prwh = filegetprodwhse(e$,ch_prwh,"=",1,Keyprwh$,pw.,e)               
	If rec_prwh < 0 ! NOT FOUND                                               
		Clear pw.                                                               
		returnstatus=0      
		Message$ = "Product " + RTrim$(prod$) + " Not Available In Warehouse "+str$(whse)
		goto endsubmitlocx: !  
	endif
                 
	Call DxGet("QTY",tmp$)
	workqty=tmp$ ! 
	if not (workqty)
		let returnstatus=0
		let message$="No Quantity Has Been Entered. Cannot Update"
		goto endsubmitlocx:
	endif
	if workqty<>0 
		Call Dxget("QTYUMID",tmp$)
		let r=tmp$
		If tmp$[1,1] > "9" ! sent text?       
			 r = getumrec(e$,ch_ccode,tmp$,IntCo,pr.) 
			If r <> 0 Let tmp$ = Str$(r)        
		End If
		if not(r)
			returnstatus=0
			let message$="Invalid Quantity Unit of Measure Entered"
			goto endsubmitlocx:
		endif
		let umid=r
	endif
	! convert quantity                                             
 	CNVTU[0] = umid;CNVTU[1] = 0;CNVTU[2] = 1                
	CNVTA = workqty ! qty orders                                   
	baseqty= ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)                                         
    Call Dxget("COMMENT",tmp$)
	Comment$=tmp$+blank$
	IF P9$[1,1]="N" or pr.LotCtrl$<>"Y" 
		let lotid$=" ",lotid$
		LET lotid$[1,7]=whse USING "STOCK&&"
	else
		Call Dxget("LOTID",tmp$)
		Lotid$=rtrim$(tmp$)+blank$
		if rtrim$(Lotid$)="" let tmp$="STOCK"
		if tmp$="STOCK" let lotid$[6,7]=whse using "&&"
	endif ! lot control chk
	if rtrim$(LotId$)=""
		let lotid$=" ",lotid$
		LET lotid$[1,7]=whse USING "STOCK&&"
	endif
	! validate correct lot is used
	! rasl check                             
	RASL=0 ! no                                
	If P9$[41,41] = "Y" Let rasl=99       
	If P9$[41,41] = "W" !  LET SRASL=1       
		If whse > 0 And whse < 100             
			Read Record #ch_wh,(whse - 1),0;wh.; 
			If wh.UseRasl <> 0 Let rasl = 99
		End If  
	Endif
	if not(rasl)
		let locid$=" ",locid$
		let locid$[1,5]="STOCK"
	else
		! validate location 
		Call Dxget("LOCID",tmp$)
		let locid$=tmp$+blank$
		LET Keywhloc$=" ",Keywhloc$                                     
		LET Keywhloc$[1,2]=WHse USING "##"                          
		LET Keywhloc$[3,8]=locid$[1,6]                                
		SEARCH #CH_WHLOC,2,1;Keywhloc$,Rec_loc,E                       
		IF E<>0
			if locid$[1,5]<>"STOCK"
				let returnstatus=0
				let message$="LOCATION "+rtrim$(locid$)+" IS NOT VALID FOR WH "+WHSE
				goto endsubmitlocx:
			endif
		endif
	endif	 ! end rasl chk	
	! to product lot/info
	IF P9$[1,1]="N" or pr.LotCtrl$<>"Y" 
		let tolotid$=" ",tolotid$
		LET tolotid$[1,7]=whse USING "STOCK&&"
	else
		Call Dxget("TOLOTID",tmp$)
		toLotId$=tmp$+blank$
		if rtrim$(ucase$(tmp$))="STOCK" let tolotid$[6,7]=whse using "&&"
	endif
	if rtrim$(toLotid$)=""
		let tolotid$=" ",tolotid$
		LET tolotid$[1,7]=whse USING "STOCK&&"
	endif
	if not(rasl)
		let tolocid$=" ",tolocid$
		let tolocid$[1,5]="STOCK"
	else
		! validate location 
		Call Dxget("TOLOCID",tmp$)
		let tolocid$=tmp$+blank$
		LET Keywhloc$=" ",Keywhloc$                                     
		LET Keywhloc$[1,2]=WHse USING "##"                          
		LET Keywhloc$[3,8]=tolocid$[1,6]                                
		SEARCH #CH_WHLOC,2,1;Keywhloc$,Rec_loc,E                       
		IF E  
			if tolocid$[1,5]<>"STOCK"
				let returnstatus=0
				let message$="LOCATION "+rtrim$(tolocid$)+" IS NOT VALID FOR WH "+WHSE
				goto endsubmitlocx:
			endif
		endif
	endif ! end rasl check
	if lotid$=tolotid$ and locid$=tolocid$
		returnstatus=0
		let message$="Cannot Transfer to the Same "
		if pr.lotctrl$="Y"
			let message$=message$+"Lot "
			if rasl<>0 let message$=message$+" and Location "
		else
			let message$=message$+"Location"
		endif
		goto endsubmitlocx:
	endif
	! verify sprodlot
	let keyprlot$=" ",keyprlot$
	let keyprlot$[1,12]=LotId$[1,12]
    let keyprlot$[23,24]=Whse using "##"         
	let keyprlot$[25,30]=Locid$[1,6] 
	LET Keyprlot$[31,42]=prod$[1,12]                         
	SEARCH #Ch_sprodlot,2,1;KEYPRLOT$,REC_PRLOT,E                            
	IF e<>0 
		If custom_customer$="ACME" or custom_customer$="SWP"
		if rtrim$(locid$)=rtrim$(dfltrloc$) or rtrim$(locid$)=rtrim$(dfltcmloc$) or rtrim$(locid$)=rtrim$(dfltdock$)
			call createprodlotx()! create sprodlot record
			if returnstatus<>1 goto endsubmitlocx:
			goto readsprodlotx:
		endif
		endif
		returnstatus=0
		let message$="Lot "+rtrim$(lotid$)+" Not on File"
		goto endsubmitlocx:
	endif 
	Readsprodlotx: ! read sprodlot for location transfer
	read record #Ch_sprodlot,rec_prlot,0;prlot.;
	
	Call Dxget("COMMENT",tmp$)
	Comment$=RTRIM$(tmp$)+blank$
	! get to lot/sprod sprodlot
	let keytprlot$=" ",keytprlot$
	let keytprlot$[1,12]=toLotId$[1,12]
    let keytprlot$[23,24]=Whse using "##"         
	let keytprlot$[25,30]=toLocid$[1,6] 
	LET Keytprlot$[31,42]=prod$[1,12]                         
	SEARCH #Ch_sprodlot,2,1;KEYtPRLOT$,REC_tPRLOT,E                            
	IF not(e)
			read record #Ch_sprodlot,rec_tprlot,0;tprlot.;
	else
		if e=1
			clear tprlot.
			tprlot.ProdCode$ =prod$  
			tprlot.LotNum$=tolotid$    
			tprlot.Comment$=" ",tprlot.Comment$    
			tprlot.Stock$=" ",tprlot.Stock$           
			tprlot.Whse=whse        
			tprlot.SrcType=prlot.srctype     
			tprlot.DateRcvd=prlot.DateRcvd     
			tprlot.LastDateUsed=0 
			tprlot.NumRcpt=0    
			tprlot.QtyRcvd=0     
			tprlot.QtyUsed=0     
			tprlot.AvgCost= prlot.AvgCost     
			tprlot.QtyAlloc=0    
			tprlot.QtyBO=0       
			tprlot.PhysUpdt=0     
			tprlot.Loc$=tolocid$        
			tprlot.QtyOnXfer=0
			let e=2\search #ch_sprodlot,1,0;keytprlot$,rec_tprlot,e
			if e<>0
				returnstatus=0
				let message$="Error in creating to Lot/Location. Allocation"
				goto endsubmitlocx: 	
			endif
			write record #Ch_sprodlot,rec_tprlot,0;tprlot.;
			search #ch_sprodlot,4,1;keytprlot$,rec_tprlot,e
			if e<>0
				returnstatus=0
				let message$="Error in creating to Lot/Location. Dir 1"
				goto endsubmitlocx: 
			endif
			! directory #2 
			LET K4$=" ",K4$                     
			LET K4$[1,12]=KEYTPRLOT$[31,42]            
			LET K4$[13,14]=KEYTPRLOT$[23,24]           
			LET K4$[15,20]=KEYTPRLOT$[25,30]           
			LET K4$[21,42]=KEYTPRLOT$[1,22]            
			SEARCH #CH_SPRODLOT,4,2;K4$,rec_tprlot,E
			if e<>0 
				returnstatus=0
				let message$="Error in creating to Lot/Location, Dir 2"
				goto endsubmitlocx:
			endif
			! Directory #3                    
			LET K4$=" ",K4$                                      
			LET K4$[1,8]=KEYTPRLOT$[23,30]                              
			LET K4$[9,20]=KEYTPRLOT$[31,42]                             
			LET K4$[21,42]=KEYTPRLOT$[1,22]                             
			SEARCH #CH_SPRODLOT,4,3;K4$,rec_tprlot,E                  
			if e<>0 
				returnstatus=0
				let message$="Error in creating to Lot/Location, Dir 3"
				goto endsubmitlocx:
			endif                              
			LET K4$=" ",K4$ \ LET K4$[1,12]=KEYTPRLOT$[31,42]           
			LET K4$[13,14]=KEYTPRLOT$[23,24] \ LET K4$[15,36]=KEYTPRLOT$[1,22] 
			LET K4$[37,42]=KEYTPRLOT$[25,30]                            
			SEARCH #CH_SPRODLOT,4,4;K4$,rec_tprlot,E                  
			if e<>0 
				returnstatus=0
				let message$="Error in creating to Lot/Location, Dir 4"
				goto endsubmitlocx:
			endif                              
		else
			returnstatus=0
			let message$="Error in finding to Lot/Location"
			goto endsubmitlocx:
		endif
	endif 
	! update the from record
	read record #Ch_sprodlot,rec_prlot,0;prlot.;
	! need sprodlot from update
	let prlot.QtyUsed=prlot.qtyused+baseqty
	READ #CTLC,3,172;currdate; 
	let prlot.lastdateused=currdate
	write record #Ch_sprodlot,rec_prlot,0;prlot.; ! current date
	! need invtran update
	
	If P9$[9,9] <> "N" ! TRANS HIST
		clear itr.
		itr.ProdCode$ = prlot.prodcode$                 
		itr.LotNum$ = prlot.lotnum$               
		itr.SrcCode$[1,12] = "774         "
		IF rtrim$(comment$)=""                 
			itr.comment$="WHS TRANSFER  -- 774" +blank$                   
		ELSE                                                       
			itr.comment$=rtrim$(comment$)+"-774" +blank$
		endif
		itr.TrnsType=28 ! 28=from/ 10=to   
		itr.Whse = prlot.Whse                                      
		itr.EntBy = urec 
		itr.Tiebrkr = 0                    
		itr.TrnsDate  = 0 ! set in maketrans -- CurrDate                          
		itr.RunInvt  =pw.QtyOnHand                    
		itr.Qty   = baseqty 
		itr.CostLoad = prlot.AvgCost
		itr.CostAvg  = CostAvg                  
		itr.NetPrice =0                    
		itr.Loc$ = prlot.Loc$                  
		Call MakeTrans(e$,IntCo,CH_INVTR,status,itr.) !  as invtrans)
	Endif
	!!!! update TO sprodlot
	read record #Ch_sprodlot,rec_tprlot,0;tprlot.;
	! need sprodlot from update
	let tprlot.QtyRcvd=tprlot.QtyRcvd+baseqty
	write record #Ch_sprodlot,rec_tprlot,0;tprlot.;
	! need invtran update
	If P9$[9,9] <> "N" ! TRANS HIST
		clear itr.
		itr.ProdCode$ = tprlot.prodcode$                 
		itr.LotNum$ = tprlot.lotnum$               
		itr.SrcCode$[1,12] = "774         "
		IF rtrim$(comment$)=""                 
			itr.comment$="WHS TRANSFER  -- 774" +blank$                   
		ELSE                                                       
			itr.comment$=rtrim$(comment$)+"-774" +blank$
		endif
		itr.TrnsType=10 ! 28=from/ 10=to   
		itr.Whse = tprlot.Whse                                      
		itr.EntBy = urec 
		itr.Tiebrkr = 0                    
		itr.TrnsDate  = 0 ! set in maketrans -- CurrDate                          
		itr.RunInvt  =pw.QtyOnHand                    
		itr.Qty   = baseqty 
		itr.CostLoad = tprlot.AvgCost
		itr.CostAvg  = CostAvg                  
		itr.NetPrice =0                    
		itr.Loc$ = tprlot.Loc$                  
		Call MakeTrans(e$,IntCo,CH_INVTR,status,itr.) !  as invtrans)
	Endif


	endsubmitlocx: ! end submit of update
	
	! Call AddToStr(e$,rstr$,esdel$) ! end of section 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! Submitlocx


!------------------------------------------------------------
Sub createprodlotx()! for location transfers
Try

	let keyprlot$=" ",keyprlot$
	let keyprlot$[1,12]=LotId$[1,12]
        let keyprlot$[23,24]=Whse using "##"         
	let keyprlot$[25,30]=Locid$[1,6] 
	LET Keyprlot$[31,42]=prod$[1,12]                         
	SEARCH #Ch_sprodlot,2,1;KEYPRLOT$,REC_PRLOT,E                            
	IF not(e) exit sub
	Call Dxget("COMMENT",tmp$)
	Comment$=RTRIM$(tmp$)+blank$
	clear prlot.
	prlot.ProdCode$ =prod$  
	prlot.LotNum$=lotid$    
	prlot.Comment$=comment$+blank$    
	prlot.Stock$=" ",prlot.Stock$           
	prlot.Whse=whse        
	prlot.SrcType= 3 
        READ #CTLC,3,172;currdate; 
	prlot.lastdateused=currdate
	prlot.DateRcvd=currdate    
	prlot.LastDateUsed=0 
	prlot.NumRcpt=0    
	prlot.QtyRcvd=0     
	prlot.QtyUsed=0     
	prlot.AvgCost= pr.CostAvg
	prlot.QtyAlloc=0    
	prlot.QtyBO=0       
	prlot.PhysUpdt=0     
	prlot.Loc$=locid$        
	prlot.QtyOnXfer=0
	let e=2\search #ch_sprodlot,1,0;keyprlot$,rec_prlot,e
	if e<>0
		returnstatus=0
		let message$="Error in creating to Lot/Location. Allocation"
		exit sub 	
	endif
	write record #Ch_sprodlot,rec_prlot,0;prlot.;
	search #ch_sprodlot,4,1;keyprlot$,rec_prlot,e
	if e<>0
		returnstatus=0
		let message$="Error in creating to Lot/Location. Dir 1"
		exit sub
	endif
	! directory #2 
	LET K4$=" ",K4$                     
	LET K4$[1,12]=KEYPRLOT$[31,42]            
	LET K4$[13,14]=KEYPRLOT$[23,24]           
	LET K4$[15,20]=KEYPRLOT$[25,30]           
	LET K4$[21,42]=KEYPRLOT$[1,22]            
	SEARCH #CH_SPRODLOT,4,2;K4$,rec_prlot,E
	if e<>0 
		returnstatus=0
		let message$="Error in creating to Lot/Location, Dir 2"
		exit sub
	endif
	! Directory #3                    
	LET K4$=" ",K4$                                      
	LET K4$[1,8]=KEYPRLOT$[23,30]                              
	LET K4$[9,20]=KEYPRLOT$[31,42]                             
	LET K4$[21,42]=KEYPRLOT$[1,22]                             
	SEARCH #CH_SPRODLOT,4,3;K4$,rec_prlot,E                  
	if e<>0 
		returnstatus=0
		let message$="Error in creating to Lot/Location, Dir 3"
		exit sub
	endif                              
	LET K4$=" ",K4$ \ LET K4$[1,12]=KEYPRLOT$[31,42]           
	LET K4$[13,14]=KEYPRLOT$[23,24] \ LET K4$[15,36]=KEYPRLOT$[1,22] 
	LET K4$[37,42]=KEYPRLOT$[25,30]                            
	SEARCH #CH_SPRODLOT,4,4;K4$,rec_prlot,E                  
	if e<>0 
		returnstatus=0
		let message$="Error in creating to Lot/Location, Dir 4"
		exit sub
	endif                              
else
    include "src/callsuberr.inc"
end try
end sub ! createprodlotx
