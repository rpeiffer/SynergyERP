! --- custm
! description Customer Inquiry
!
! loadsave -w -n 100,10 -o prog/dxport/custm.dl4 src/custm.src
!
! 1.0 mm/dd/yyyy change??
!
!include copyright, common libs, common intrinsics
! 05/14/09  rjs cct225460 - master delivery cust# 
! task#21594 - Master Delivery Customer - system flag P61$[109,109]
include "src/copyright.inc"
!
include "src/inc/filecust.inc"
include "src/inc/filecustnotes.inc"
include "src/inc/filecustshnote.inc" ! "customer ship/pack notes
include "src/inc/fileccctype.inc" ! credit cards for Customer
include "src/inc/filecontlist.inc" ! "address book file
include "src/inc/filedocdeliv.inc" ! document delivery
include "src/inc/filecslkeywrd.inc" ! "cust/shiplist keywords
include "src/inc/filecustspec.inc" ! "customer specs(notes)
Include "src/inc/filecszone.inc"
include "src/inc/filecustsls.inc" ! cust sales
include "src/oovars.inc"

include "src/inc/fileprod.inc" ! product
include "src/inc/filesprodlot.inc" ! product lots

Include "src/inc/fileshiplist.inc" ! shiplist
include "src/inc/filecurrency.inc" ! currency file
include "src/inc/filecustbank.inc" ! customer bank file

! NO - BROKEN!
! include "src/inc/filecustslsm.inc" ! customer/shiplist multi-slsm comm split

!
External Lib "libfilecustspecx.lib"
Declare External Function fileupdatecustspecx  !special, key not part of record,pass key
!
External Lib "libfilecustshnotex.lib"
Declare External Function fileupdatecustshnotex !special, key not part of record,pass key
!
! *declare additional dl4 intrinsic subs & functions
Declare Intrinsic Function FindChannel
Declare Intrinsic Sub Logic, programdump, datetojulian, findf
!
! *declare additional external libs & subs & functions
!
External Lib "libgeneral.lib"
Declare External Sub SubErr, CreateNetStatus, GetDelimiters
External Lib "libprodconv.lib"           
Declare External Function ConvProdAmount
!
External Lib "ubsfunc.dl4"
Declare External Function OpenFile,JDate$,formatdate2$,PDate$
Declare External Function formatdate$,FMTphone2$,numericonly$
Declare External Sub ArBuck,UserCntrl,GetCostLevels,LogAccess
Declare External Function ChkBadChars
!
External Lib "libcpi.lib"
Declare External Sub cpiinquiry
!
External Lib "ubsoolist.dl4"
Declare External Sub OOList
!
External Lib "ubsoodet.dl4"
Declare External Sub OODet
!
External Lib "ubsiidet.dl4"
Declare External Sub iiDet
!
External Lib "ubslplist.dl4"
Declare External Sub GetLplist
!
External Lib "ubsbolist.dl4"
Declare External Sub BOList
!
External Lib "ubsqolist.dl4"
Declare External Sub QOList
!
External Lib "getartermd.lib"
Declare External Function GetArTermd$
!
External Lib "getsvcchgd.lib"
Declare External Function GetSvcChgd$
!
External Lib "gettaxcdd.lib"
Declare External Function Gettaxcdd$
!
External Lib "getcusttaxtyd.lib"
Declare External Function Getcusttaxtyd$
!
External Lib "getcredcdd.lib"
Declare External Function Getcredcdd$
!
External Lib "getstattyd.lib"
Declare External Function Getstattyd$
!
External Lib "getpricetyd.lib"
Declare External Function Getpricetyd$
!
External Lib "getcustcatd.lib"
Declare External Function Getcustcatd$
!
External Lib "getdivname.lib"
Declare External Function GetdivName$
!
External Lib "getcustname.lib"
Declare External Function GetCustName$
!
External Lib "getslsmname.lib"
Declare External Function GetSlsmName$
!
External Lib "ubscustsplist.dl4" 
Declare External Sub custspList
!
External lib "libcustlist.lib"
Declare external sub GetCustNoteOI,getCustSpecN,GetCustSHNotes,GetCustKeyWords
Declare External Sub GetCustGeneral,GetCustCCard,GetCustABook,GetCustRoute
Declare External Sub GetCustClass,GetCustComm,GetCustDocd,GetCustRebate,CustList
!
External Lib "libcustdisplay.lib"
Declare External Sub GetCustCred,GetCustAR,GetCustSales,GetCustWkSls,GetCustCallNts
Declare External Sub GetCustCRHist,GetCustRefDtl
!
External lib "libshipldisplay.lib"
Declare External Sub GetCustShipL
!
External lib "libfilehandler.lib"
Declare External sub filedroplistcntrlfile,filedroplistaddons
!
!!-!dci2
External lib "libfilesslsm.lib"
Declare External sub filedroplistsslsm
!
External lib "libfileartermcode.lib"
Declare External sub fileDropListArTermCode
!
External lib "libfileprtypefle.lib"
Declare External sub filedroplistprtypefle
!
External lib "libfilecustcat.lib"
Declare External sub filedroplistcustcat
!
External lib "libfiledivifle.lib"
Declare External sub filedroplistdivifle
!
External lib "libfiletaxcode.lib"
Declare External sub filedroplisttaxcode
!
External lib "libfilecusttax.lib"
Declare External sub filedroplistcusttax
!
External lib "libfilesvchgcd.lib"
Declare External sub filedroplistsvchgcd
!
External lib "libfilezonefle.lib"
Declare External sub filedroplistzonefle
!
External Lib "libfilewhinfoz.lib"
Declare External Sub filedroplistwhinfoz
!
External Lib "libfilecusttax.lib"
Declare External sub filedroplistcusttax
!
External Lib "libfilebrktbl.lib"
Declare External sub filedroplistbrktbl
!
External Lib "libfilecollagent.lib"
Declare External sub filedroplistcollagent
!
External Lib "libfilecustgp.lib"
declare external sub filedroplistcustgp
!
External Lib "libimaging.lib"
Declare External Sub GetImage
!
Declare Sub OOrders, OpenFiles, BankRoute, Taxation,UDAFlds, Custsp, orddet, invdet, orddetlines
Declare Sub CustMain,SndLists,CustCopy,CustSave,CustDel,Whatfor
Declare Sub updtarpost,ChkCWhse,GetBInfo,MSlsm,CheckImages
Declare Function chkDateFrmt$,rmbadchar$
Declare Sub ProcessCommissionSplits
Declare Sub CustConsInv, UpdateWebCust, UpdateWebShiplist

! Declare External Function YN$
!
! **main procedure
!
! dim variables used by program
!

dim e$[500],buttonlist$[5,50],nextlist$[5,100] !error handling variables
OPTION GOSUB NESTING 12  ! Default is 8
try
 Option String Redim is legal ! in case subs dim/use same names
 dim cust. As cust,tmpcust. as cust
 dim cnotes. As custnotes
 dim CSHN. as custshnote
 dim CSZone. as cszone
 dim CCType. as ccctype
 dim CABook. as contlist
 dim Docd. as docdeliv ! document delivery file
 dim CKW. as cslkeywrd
 dim CSN. as custspec
 dim csls. as custsls

 dim prod. as prod
 dim prlot. as sprodlot

 Dim SL. as shiplist ! ship list file
  dim curr. as currency ! 

 !
 ! sprodlot
  dim keyprlot$[50],fname$[50],keyprod$[50]
  dim 3%,rec_prlot,rec_prod
 dim keyrom$[50],keyinvm$[50],X$[20]
 dim action$[30],options$[30],userid$[10],b$[200],Action1$[30],Action2$[30],3%
 dim cust$[64],pum$[4],matdesc$[25],pcatdesc$[24],sub1desc$[30],sub2desc$[30],custidfrom$[64],aux$[64]
 Dim arbuck$[5,10],mode$[3],udadesc$[14],XDate$[10],SearKey$[60]
 dim Message$[200],WebStr$[400],P9$[50],fields$[1,30],P60$[50],p61$[256]
 dim ccpswd$[10],a2$[50],custom_customer$[30]
 dim 2%,currdate,maxcnt \ maxcnt=100 ! init max records in arrays for list
 Dim 3%,UIDREC[1],cost_lev[3]
 Dim 1%,X1[9],2%,X2[9],3%,X3[9],R[99],SCType
 Dim 2%,PChan[9],3%,passinfo[9],ofldschg[5],Msg$[200] ! alertfile
 dim 1%,keyno,valact1,vers,2%,ReturnStatus,CustID
 dim 1%,CNC,CUC,CSPC,CSHNC,CKWC,CRCDC,CABC,ZNC,a5[10]
 dim List$[maxcnt,700] ! for .net
 dim SList$[maxcnt,700] ! for .net selector(drop down) list
 dim DList$[maxcnt,700] ! for a third .net data list
 dim oldCPIHold$[1]

 dim 1%,ch_curr,keycurr$[50],3%,rec_curr
 !
  Dim bsdel$[10],esdel$[10],rdel$[10],fdel$[10],rstr$[1200],tmp$[3500]
  dim tmp2$[100],tmp3$[100],custkey$[64],QMask$[20],PWEnt$[10]
  dim 1%,tmpch,artermd$[16],taxcoded$[20],custtaxtyped$[16],credcoded$[16],stattyped$[16],svcchgd$[20]
  dim custname$[30],slsmname$[30],pricetyped$[24],custcatd$[30],divname$[24]
  Dim 1%,VNE,VNC,vendname$[30],VNK$[6],3%,VNR
  Dim 1%,WHE,WHC,WHK$[14],3%,WHR
  Dim 2%,CustSec[1]

  Dim DOCTYPE$[4],CODE$[6],1%,MODE
  !
  dim cckey$[26],tmp1$[100],cabckey$[10],ddkey$[12],ckwkey$[13],cskey$[10]
  Dim 3%
  ! 
 b$=" ",b$
 !
 call dxopen()
 !
 
 !
 Call GetSession(e$,CTLC,options$,action$,UserID$,intCo,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$,Action1$,Action2$)
 Call GetCostLevels(e$,cost_lev[],IntCo,Userid$) ! get cost security 
 ! open files
 action$=UCase$(action$)
 action$=RTrim$(Action$) ! "trim spaces from end
 action1$=UCase$(action1$)
 action1$=RTrim$(Action1$) ! "trim spaces from end
 action2$=UCase$(action2$)
 action2$=RTrim$(Action2$) ! "trim spaces from end
 Mat read #CTLC,19,50;P9$;
 Mat read #CTLC,60,50;P60$;
 Mat read #CTLC,61,0;P61$;
 mat read #CTLC,115,60;custom_customer$;

 Custom_customer$=UCase$(Trim$(custom_customer$))
 SCType=0 !using split commissions?
 If P9$[21,21] <> "Y" ! split by category takes priority
	SCType = P61$[72,72]
	If P61$[72,72] = "Y" Let SCType = 1
 end if
 call OpenFiles() ! open any/all here and NOW
 tmp$=tim(8) using "&&"
 tmp$=tmp$+tim(9) using "&&"
 tmp$=tmp$+tim(10) using "&&" ! yymmdd
 currdate=tmp$
 QMask$="---------#.##"
 !! add customer/salesman security!
 Call UserCntrl(USERID$,A2$,A5[],status,intCo)
 Call DXGet("custid",cust$) \ custid=cust$
 call LogAccess(e$,"Customer: "+str$(custid))
  cust$=custid using "######"
  custkey$=cust$
 If Custid>0 ! sent one - check it now
	
	if CUC>0
		CUR = filegetcust(e$,CUC,"=",1,cust$,cust.)
		if CUR>0 ! "found cust - otherwise new?
			Custsec[0]=custid;custsec[1]=1 ! id & NO ALERT
			call "custsec.dl4",Custsec[],ctlc,userid$,e$,rstr$
			if custsec[0]=-1 ! not allowed
				returnstatus=0
				message$="You do not have access this customer"
				goto MCMDone
			Endif
		Endif
		!get cnote record
		CNRec = filegetcustnotes(e$,CNC,"=",1,Cust$,cnotes.)
		If CNRec <= 0 Clear cnotes.\cnotes.customer=cust$
		!Close #CUC
	Endif ! file not opened
 Endif ! no custid - accessing search, etc?
 ! in case needed - save all inputs from front end
 !if userid$[1,4]="JIMS" ! ! track EVERY WEB CALL!
!	x=0
!	getnxtsv: ! loop til not found
!	tmp$="tmp/cenedin"+Str$(x)+".txt"
!	Call FindF(tmp$,FOUND)
!	if found let x=x+1 \ goto getnxtsv ! til new one to save all web submits
!	call dxsave(0,tmp$)
 ! Endif
!  Call dxsave(0,"tmp/custin.txt!") !   Stop
!Call programdump("tmp/cmlog1in!","") ! dump program vars
if action$="OORDERS" or action$="BOORDERS"  or action$="QUOTES"
	! docs= CustOpenBackOrders-BOrders.doc  CustOpenOrders-OOrders.doc  CustOpenQuotes-Quotes.doc
	Call OOrders()
	End  ! done with prog??
End if
  Returnstatus=0
  Message$="ACTION NOT FOUND"
Select Case action$
  Case "MAIN","READ" ! inquiry main & edit options  Inq doc=CustRefDetail-GetCustRefDtl.doc
	returnstatus=1
	Message$="OK"
	call CustMain()
	! End of Main
  case "SEARCH" ! customer Scan (STANDARD)					  doc=CustScan.doc
	!
	Let ReturnStatus=1
	Message$="OK"
	if action1$="POSTTO" let cuc=0-cuc ! set flag
	if action1$="BILLTO" let ctlc=0-ctlc ! set flag
		
	Call CustList(e$,IntCo,List$[],maxcnt,ctlc,cuc,0,"",UserId$)
	If E$<>""
	  Let ReturnStatus=0
	  Message$=E$
	Endif
	call AddToStr(e$,rstr$,List$[])
	!
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	!if debugdetail
	!	dmsg$="Customer Search sent "+Message$ \ Call updatelog(debug)
	!Endif
	END
		! end of custsearch
  Case "CUSTNAME" ! for post/billto							doc=Custm-GetCustName.doc
	returnstatus=1
	Message$="OK"
	call dxget("CUSTNO",tmp$)
	Custno=tmp$
	if custno=0 let custno=custid;tmp$=Cust.Name$
	if custno<>custid ! only diff
		tmp$=Custno using "######"
		CCUR=filegetcust(e$,CUC,"=",1,tmp$,tmpcust.)
		if ccur<=0
			returnstatus=0
			message$="Customer not found"
			goto MCMDone
		Else
		  If Action1$="POSTTO"
				if tmpcust.ARPostCust<>Custno ! no multilevel
					returnstatus=0
					message$="Post to Customer posts to Customer "+Str$(tmpcust.ARPostCust)
					goto MCMDone
				Endif
		  Endif
		  if action1$="MASTDELV"
		  endif		
		  if action1$="PRICEMASTER"
		  	if p61$[100,100]="Y"
				cust.LpPpGrpCust=Custno
				if cust.LpPpGrpCust=0 let cust.LpPpGrpCust=cust.CustomerCode
				if cust.LpPpGrpCust<>cust.CustomerCode and cust.LpPpGrpCust<>0
					tmp$=cust.LpPpGrpCust using "######"
					CCUR = filegetcust(e$,CUC,"=",1,tmp$,tmpcust.) 
					if CCUR < 0 
						message$="Price Master customer # not on file"
						Returnstatus=0
						goto MCMDone
					Else
						if tmpcust.LpPpGrpCust=0 let tmpcust.LpPpGrpCust=tmpcust.CustomerCode
						if tmpcust.LpPpGrpCust<>cust.LpPpGrpCust ! no multilevel
							returnstatus=0
							message$="Entered Price Master Cust "+str$(cust.LpPpGrpCust)+" already assigned to another Price Master Cust "+Str$(tmpcust.LpPpGrpCust)
							goto MCMDone
						endif
					Endif ! ccur
				endif
			endif  !! p61$
		  endif !pricemaster
		Endif
		tmp$=tmpcust.Name$
	Else ! same
		tmp$=Cust.Name$
	Endif
	Clear List$[]
	List$[0]=bsdel$,"CUSTINFO",fdel$
	List$[1]="CUSTNUM",fdel$,"CUSTNAME",fdel$
	List$[2]=Str$(CustNo),fdel$,RTrim$(tmp$),fdel$
	List$[3]=esdel$
	call addtostr(e$,rstr$,List$[])
	goto MCMDone
  Case "DLISTS" ! edit mode - flag/droplists				doc=Custm-GetDLists.doc
	! send droplists needed for entry/edit
	returnstatus=1
	Message$="OK"
	call SndLists()
  Case "SPLIST" ! spec price								doc=CustSpecPriceList.doc
	!! ** customer special price ** !!   Mtg
	Call CustSp()
       End
	! end of splist
  Case "ORDDET" ! order details								doc=CustOrderDetail.doc
	Call OrdDet()
     End
	! end of orddet
 Case "ORDDETLINES" ! order details								doc=CustOrderDetailLines.doc
	Call OrdDetLines()
     End
  Case "INVDET" ! inv details								doc=CustInvoiceDetail.doc
	Call InvDet()
	end
	! end of Invdet
  Case "SALESHIST" ! this year/last year sales				doc=CustMthlySales-GetCustSales.doc
	returnstatus=1
	Message$="OK"
	Call GetCustSales(e$,List$[],maxcnt,intCo,ReturnStatus,Message$)
	! finish off the section
  	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	! end of saleshist
  Case "WEEKLYSALES" ! this year/last week sales			doc=CustWeeklySales-GetCustWkSls.doc
	returnstatus=1
	Message$="OK"
	Call GetCustWkSls(e$,List$[],maxcnt,intCo,ReturnStatus,Message$)
	! finish off the section
  	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	! end of weeklysales
  Case "ARDETAIL","ARDTLHIST" ! a/r current & History		doc=CustARDetail-GetCustAR.doc
	!														doc=CustARDtlHist-GetCustAR.doc
	! vers - 0=curr ar only, 1=both curr & history, 2=history ar only 
	if a2$[33,33]="Y" ! SUPPRESS AHR
		RETURNSTATUS=0;MESSAGE$="You are not allowed to view A/R Details!"
		goto MCMDone
	Endif
	returnstatus=1
	Message$="OK"
	let vers=0 ! current only is the default
	if action$="ARDTLHIST" let vers=2 ! adding maxrow - only 1 file (hist) sent
    Call GetCustAR(e$,vers,List$[],maxcnt,intCo,ReturnStatus,Message$)
	! finish off the section
  	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	! end of ardetail/ardtlhist
  Case "CREDITHIST" ! 24 month credit history				doc=CustCredHist-GetCustCRHist.doc
	returnstatus=1
	Message$="OK"
	Call GetCustCRHist(e$,List$[],maxcnt,intCo,ReturnStatus,Message$)
	! finish off the section
  	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	! end of credithist
  Case "REFDETAIL" ! Reference Detail (R Option)			doc=CustRefDetail-GetCustRefDtl.doc
	if a2$[33,33]="Y" ! SUPPRESS AHR
		RETURNSTATUS=0;MESSAGE$="You are not allowed to view A/R Details!"
		goto MCMDone
	Endif
	Call GetCustRefDtl(e$,List$[],SList$[],DList$[],maxcnt,intCo,ReturnStatus,Message$)
	call AddtoStr(e$,rstr$,SList$[]) ! add selector list first
	! finish off the section
  	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	call AddtoStr(e$,rstr$,DList$[]) ! add pay detail list last
	! end of refdetail
  Case "SHIPLIST" ! ShipList Detail (L Option)				doc=CustShipList-GetCustShipL.doc
	returnstatus=1
	Message$="OK"
	Call GetCustShipL(e$,List$[],SList$[],maxcnt,intCo,ReturnStatus,Message$)
	call AddtoStr(e$,rstr$,SList$[]) ! add selector list first
	! finish off the section
  	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	! end of shiplist
  Case "PRICELIST" ! Price list								doc=CustPriceList-GetLpList.doc
	returnstatus=1
	Message$="OK"
	Call GetLpList(e$,List$[],maxcnt,intCo,ReturnStatus,Message$)
	!call AddtoStr(e$,rstr$,SList$[]) ! add selector list first
	! finish off the section
  	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	! end of pricelist
  Case "CONSINVENT" ! consignment inventory
    call CustConsInv()
  Case "UPDATEWEBCUST" ! web side maint is update cust rec
    call UpdateWebCust()
  Case "UPDATEWEBSHIPLIST" ! web side maint is update cust rec
    call UpdateWebShiplist()

! ** RELATED LINKS SECTION **
  Case "RELATEDLINKS"
	returnstatus=1
	Message$="OK"
	Call DXGet("action1",action1$) \ action1$=UCase$(action1$)
	action1$=RTrim$(action1$) ! "trim spaces from right end
	Call DXGet("custid",cust$) \ custid=cust$
	cust$=custid using "######"
	custkey$=cust$
	! Open any files for related links
	! Call OpenFiles()
	mode$="="
	keyno=1
	CUR = filegetcust(e$,CUC,mode$,keyno,cust$,cust.)
	if CUR<=0 ! "not found
		Clear cust.
		!e$="Customer Not Found"\error 10000
		Returnstatus=0
		Message$="Customer Not Found"
		goto RLDone
	else
		! status section - always sent with related?
		ReturnStatus=1
		Message$="OK"
	end if

	valact1=-1 ! default - action1 not found
	! any/all  action1$ go here
	if action1$="OINOTES" ! "order/invoice notes (note 1/2 from custnotes file)doc=CustOrdInvNotes-GetCustNoteOI.doc
		valact1=0 ! valid action1
		Call GetCustNoteOI(e$,Cust$,List$[],CUR,maxcnt,CTLC,CNC,CUC,cust.)
	end if
	if action1$="CUSTNOTES" ! "notes from custspec file		doc=CustSpecNotes-GetCustSpecN.doc
		valact1=0 ! valid action1
		if action2$="SAVE" ! save notes							doc=Custm-SubmitSNotes.doc
			call dxget("STRTLINE",tmp$) !! 33263 - grps of 100
			CSSLine=tmp$ ! should be 0,100,200,300,400,etc
			if cssline<>0 goto RLDone ! limit to 1-99 ONLY!!!
			if FRA(CSSLINE/100) ! not allowed!!
				returnstatus=0
				message$="STRTLINE IS NOT A MULTIPLE OF 100!"
				goto RLDone
			Endif
			If CSSLINE<0 or CSSLINE>900
				returnstatus=0
				Message$="STRTLINE IS INVALID"
				goto RLDone
			Endif
			!if userid$[1,4]="JIMS" and cssline=0
			!  Call dxsave(0,"tmp/custin.txt!") !   Stop
			!endif
			slp=1 ! cssline+1 ! 1,101,201,etc
			elp=99 ! cssline+100 ! 100,200,300,etc
			for i=slp to elp !  was   i=1 to 25
				CSKey$=CustKey$+" "+i using "###"
				CSRec=filegetcustspec(e$,CSPC,"=",1,CSKey$,CSN.)
				if CSRec<0
					clear CSN.
				end if
				call dxget("note"+str$(i),tmp$)\CSN.Message$=tmp$,b$ ! Note
				If CSRec<0 let mode$="a" else let mode$="c"
				if rtrim$(tmp$)="" let mode$="d"
				if CSrec<0 if mode$="d" 
					! ignore delete as not there anyway!
				else
					CSrec=fileupdatecustspecx(e$,CSPC,mode$,CSrec,CSN.,CSKey$)
				end if
			next i
			message$="Record saved"  !record saved
		else
			Call getCustSpecN(e$,Cust$,List$[],CUR,maxcnt,CTLC,CSPC,CUC,cust.)
			if e$[1,15]="RS=5  NEXTLINE=" ! 33263 - limit 100 per request
				returnstatus=5
				message$=E$[7] ! "NEXTLINE=" and the line(spec) number
				Clear e$ ! clear bogus e$
			endif
		end if !save
	endif
  if action1$="SHIPNOTES" ! "notes from custshnote file		doc=CustShipNotes-GetCustSHNotes.doc
    valact1=0 ! valid action1
    Call GetCustSHNotes(e$,Cust$,List$[],CUR,maxcnt,CTLC,CSHNC,CUC,cust.)
  endif
  if action1$="KEYWORDS" ! list of keywords					doc=CustKeyWords-GetCustKeyWords.doc
    valact1=0 ! valid action1
	if action2$="SAVE" or action2$="DELETE" ! save kwords	doc=Custm-SubmitKeywords.doc
	 CKWKey$=CustKey$," " !					delete kwords	doc=Custm-DeleteKeywords.doc
	 CKWRec=filegetcslkeywrd(e$,CKWC,"=",1,CKWKey$,CKW.)
	 If CKWRec<0
	  Clear CKW.
	  CKW.Customer=CustKey$
	  CKW.RecordKey$=CKWKey$
	 end if
	 if Ckwrec>0 ! not new - delete old ones first
		x=0;x1=10 ! no slrec,mode=10(delete)
		call "cslkeywrd.dl4",CKWKey$,CUR,x,x1,e$,Intco ! delete old keywords
	 Endif
	 ! a "delete" does not actually delete the record, it clears kw's 1-17
	 delkw=0 \ if action2$="DELETE" let delkw=1;tmp$=b$
     call dxget("Keyword1",tmp$)\if delkw let tmp$=b$
	 CKW.Keyword1$=tmp$,b$
     call dxget("Keyword2",tmp$)\if delkw let tmp$=b$
	 CKW.Keyword2$=tmp$,b$
     call dxget("Keyword3",tmp$)\if delkw let tmp$=b$
	 CKW.Keyword3$=tmp$,b$
     call dxget("Keyword4",tmp$)\if delkw let tmp$=b$
	 CKW.Keyword4$=tmp$,b$
     call dxget("Keyword5",tmp$)\if delkw let tmp$=b$
	 CKW.Keyword5$=tmp$,b$
     call dxget("Keyword6",tmp$)\if delkw let tmp$=b$
	 CKW.Keyword6$=tmp$,b$
     call dxget("Keyword7",tmp$)\if delkw let tmp$=b$
	 CKW.Keyword7$=tmp$,b$
     call dxget("Keyword8",tmp$)\if delkw let tmp$=b$
	 CKW.Keyword8$=tmp$,b$
     call dxget("Keyword9",tmp$)\if delkw let tmp$=b$
	 CKW.Keyword9$=tmp$,b$
     call dxget("Keyword10",tmp$)\if delkw let tmp$=b$
	 CKW.Keyword10$=tmp$,b$
     call dxget("Keyword11",tmp$)\if delkw let tmp$=b$
	 CKW.Keyword11$=tmp$,b$
     call dxget("Keyword12",tmp$)\if delkw let tmp$=b$
	 CKW.Keyword12$=tmp$,b$
     call dxget("Keyword13",tmp$)\if delkw let tmp$=b$
	 CKW.Keyword13$=tmp$,b$
     call dxget("Keyword14",tmp$)\if delkw let tmp$=b$
	 CKW.Keyword14$=tmp$,b$
     call dxget("Keyword15",tmp$)\if delkw let tmp$=b$
	 CKW.Keyword15$=tmp$,b$
     call dxget("Keyword16",tmp$)\if delkw let tmp$=b$
	 CKW.Keyword16$=tmp$,b$
     call dxget("Keyword17",tmp$)\if delkw let tmp$=b$
	 CKW.Keyword17$=tmp$,b$
     ! keywords 18-30 are SYSTEM MAINTAINED ONLY!
     If CKWRec<0 let mode$="a" else let mode$="c"
	 if action2$="DELETE" let mode$="c"
	 rec=fileupdatecslkeywrd(e$,CKWC,mode$,CKWrec,CKW.)
	 if rec<0  ! error 10000 !issue updating,adding or deleting record
		returnstatus=0
		Message$="ERROR: Update Keywords "+e$
		goto RLDone
	 Endif
	 if action2$="DELETE" let message$="Record deleted" Else  message$="Record saved"  !record saved
	 if mode$="a" let CKWRec=Rec
	 !if mode$<>"d" ! not deleted - re-save now
		x=0;x1=9  ! no slrec,mode=9 (cust keyword only update)
		call "cslkeywrd.dl4",CKWKey$,CUR,x,x1,e$,Intco ! update old keywords
	 !Endif
	else ! inquiry
     if len(Cust$)=6 let Cust$=Cust$+" " ! "make it 7 chars MINIMUM
     Call GetCustKeyWords(e$,Cust$,List$[],CUR,maxcnt,CTLC,CKWC,CUC,cust.)
	end if !save
  endif
  if action1$="GENERAL" ! misc fields						doc=CustGeneralFields-GetCustGeneral.doc
      valact1=0 ! valid action1
	Call GetCustGeneral(e$,Cust$,List$[],CUR,maxcnt,CTLC,CNC,CUC,cust.)
  endif
  if action1$="CREDITCARD" ! credit card display			doc=CustCreditCards-GetCustCCard.doc
      valact1=0 ! valid action1
	if action2$<>"" and a2$[30,30]<>"Y"  ! user cannot access this
		returnstatus=0
		message$="User can not access credit cards!"
		goto RLDone
	Endif
	call dxget("CCPSWD",PWEnt$) ! always enter password
	PWEnt$=UCase$(RTrim$(PWEnt$))
	mat read #ctlc,2,120;ccpswd$;
	ccpswd$=RTrim$(UCase$(ccpswd$))
	! PWEnt$=ccpswd$ ! TEST - SEND IT  REMOVE WHEN READY
	if action2$<>"" ! not inquiry
		 if ccpswd$<>"" and ccpswd$<>PWEnt$ 
			returnstatus=0
			message$="Can not edit credit cards!"
			goto RLDone
		 Endif
	Endif
	if action2$="EDIT" or action2$="ADD" or action2$="COPY" !need types drop list
     !!-!Building section for credit card types				doc=Custm-EditCreditCard.doc
     call filedroplistcntrlfile(e$,list$[],49,10,10)   !rcd 49, 10fields of  10char
     call addToStr(e$,rstr$,list$[])
    end if
	if action2$="SAVE" or action2$="DELETE" ! submit		doc=Custm-SubmitCreditCard.doc
     call dxget("cardnumber",tmp$)	!		  delete		doc=Custm-DeleteCreditCard.doc
	 tmp$=Trim$(tmp$)
	 if tmp$=""
		returnstatus=0
		message$="NO Credit card entered"
		goto RLDone
	 Endif
	 CCKey$=CustKey$,tmp$,b$
	 CCrec=filegetccctype(e$,CRCDC,"=",1,CCKey$,CCType.)
	 if CCrec<0 clear CCType.
	 CCType.CustID=CustKey$
	 if action2$="DELETE" goto BPCCEntry ! can't enter
     call dxget("CardType",tmp$)
	 x2=tmp$
	 if x2<1 or x2>10 or fra(x2)
		RETURNSTATUS=0
		Message$="Credit card type Invalid!"
		goto RLDone
	 Endif
	 CCType.CCType=tmp$
     call dxget("expires",tmp$)\tmp1$=tmp$[1,2],tmp$[4]\CCType.ExpDate=tmp1$,b$ !mm/yyyy to mmyyyy
	 if CCType.ExpDate=0
		returnstatus=0
		Message$="No Expire Date!"
		goto RLDone
	 Endif
     call dxget("cardnumber",tmp$)\CCType.CCnum$=tmp$,b$ ! also above
	 call dxget("name",tmp$)\CCType.CCName$=tmp$,b$ !name
	 call dxget("address",tmp$)\CCType.CCAddr$=tmp$,b$ ! address of cardholder
	 call dxget("City",tmp$) \ CCType.CCCITY$=tmp$,b$ ! city
	 call dxget("State",tmp$) \ CCType.CCState$=tmp$,b$ ! state
	 call dxget("zipcode",tmp$)\CCType.CCZip$=tmp$,b$ ! zip of cardholder
	 call dxget("SECCODE",tmp$) \ cctype.CCSCODE$=tmp$,b$ ! sec code
	 BPCCEntry: ! bypass on delete
	 If CCRec<0 let mode$="a" else let mode$="c"
	 if action2$="DELETE" let mode$="d"
	 if mode$="d" and ccrec<0 goto CCEDone ! not there - can't delete!
	 CCrec=fileupdateccctype(e$,CRCDC,mode$,CCrec,CCType.)
	 if CCrec<0 ! error 10000 !issue updating,adding or deleting record
		returnstatus=0
		message$="Error "+Str$(CCREC)+" on credit card update"
		goto RLDone
	 Endif
	 CCEDone: ! finish
	 if action2$="DELETE" let message$="Record deleted" Else  message$="Record saved"  !record saved
	else
	 Call GetCustCCard(e$,Cust$,List$[],SList$[],CUR,maxcnt,CTLC,CRCDC,CUC,Intco,PWEnt$,cust.)
	 Call AddtoStr(e$,rstr$,SList$[]) ! add selector list to string before data (list$[])
	end if !SAVE
  endif
  if action1$="ADDRESSBOOK" ! contact list					doc=CustAddressBook-GetCustABook.doc
      valact1=0 ! valid action1					submit		doc=Custm-SubmitAddrBook.doc
	if action2$="SAVE" or action2$="DELETE" !   delete		doc=Custm-DeleteAddrBook.doc
     call dxget("cont",tmp$)
	 x3=tmp$
	 if X3=0 AND action2$="SAVE" !add mode, determine next seq #
	  cabckey$="CS",CustKey$,"zz"
	  CABCrec=filegetcontlist(e$,CABC,"<",1,cabcKey$,CABook.)
	  if str$(CABook.CustCode)<>ltrim$(CustKey$) or CABook.ContactType$<>"CS" let CABCRec=-1
	  if CABCrec>=0 let tmp$=CABook.Contact+1 using "##" Else tmp$="1"
	  if tmp$="**"  ! >99 = **
		  let message$="You can only add 99 Contacts per customer"
		  Returnstatus=0 ! \error 10000
		goto RLDONE
	   Endif
	 Else ! sent # or delete
		tmp=tmp$\tmp$=tmp using "##"
		cabckey$="CS",CustKey$,tmp$
		CABCrec=filegetcontlist(e$,CABC,"=",1,cabcKey$,CABook.)
		if CABCrec<0 and action2$<>"DELETE"
			returnstatus=0
			message$="Contact not found"
			goto RLDone
		Endif
	 end if
	 tmp=tmp$\tmp$=tmp using "##"
     cabckey$="CS",CustKey$,tmp$
	 CABCrec=filegetcontlist(e$,CABC,"=",1,cabcKey$,CABook.)
	 if CABCrec<0 clear CABook.
	 CABook.CustCode=CustKey$
	 CABook.Contact=tmp$
     CABook.ContactType$="CS"
	 if action2$="DELETE" goto BPABEntry
	 call dxget("FirstName",tmp$)\CABook.FirstName$=tmp$,b$
	strgok=chkbadchars(e$,CABook.FirstName$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in First Name"
		goto rldone
	Endif
	 call dxget("LastName",tmp$)\CABook.LastName$=tmp$,b$
	 strgok=chkbadchars(e$,CABook.LastName$)
	 if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Last Name"
		goto rldone
	Endif
	 call dxget("Title",tmp$)\CABook.TitlePos$=tmp$,b$
	 strgok=chkbadchars(e$,CABook.TitlePos$)
	 if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Title"
		goto rldone
	Endif
	 call dxget("PhoneNumber",tmp$)\CABook.Phone=numericonly$(tmp$)
	 call dxget("PhoneExt",tmp$)\CABook.PhoneExt=numericonly$(tmp$)
	 call dxget("EMail",tmp$)\CABook.EmailAddr$=tmp$,b$
	 call dxget("Pager",tmp$)\CABook.Pager=numericonly$(tmp$)
	 call dxget("PagerPIN",tmp$)\CABook.PagerPin=numericonly$(tmp$)
	 call dxget("FAXNumber",tmp$)\CABook.Fax=numericonly$(tmp$)
	 call dxget("CellNumber",tmp$)\CABook.CellPhone=numericonly$(tmp$)
	 call dxget("Phone2",tmp$)\CABook.Phone2=numericonly$(tmp$)
	 call dxget("FAX2",tmp$)\CABook.Fax2=numericonly$(tmp$)
	 call dxget("Comment1",tmp$)\CABook.Comment1$=tmp$,b$
	 strgok=chkbadchars(e$,CABook.Comment1$)
	 if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Email CC 1"
		goto rldone
	Endif
	call dxget("Comment2",tmp$)\CABook.Comment2$=tmp$,b$
	strgok=chkbadchars(e$,CABook.Comment2$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Email CC 2"
		goto rldone
	Endif
	call dxget("Comment3",tmp$)\CABook.Comment3$=tmp$,b$
	strgok=chkbadchars(e$,CABook.Comment3$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Email CC 3"
		goto rldone
	Endif
	 call dxget("CRTYPE",tmp$)\x=tmp$
	 if x<1 or x>3 let x=1
	 CABook.ContrecordType=x
	 CABook.EditDate= tim(6) !Last Edit, today julian
	 BPABEntry: ! bypass entry if delete
	 If CABCRec<0 let mode$="a" else let mode$="c"
	 if action2$="DELETE" let mode$="d"
	 If mode$="d" 
		if CABCRec<=0 goto CABSDone ! can't delete - not there
		ddkey$=" ",ddkey$
		ddkey$="CS"+Custkey$
		DCDChan=OpenFile(-9968,intCo) \ if DCDChan = -1 Error 42
		do ! check if used in docs
			DCDRec=filegetdocdeliv(e$,DCDChan,">",1,DDKey$,Docd.)
			if ddkey$[1,2]<>"CS" or ddkey$[3,8]<>Custkey$ let dcdrec=-1
			if dcdrec<=0 exit do
			if dcdrec>0
				if CABook.Contact=docd.AddrEntry
					returnstatus=0
					message$="Can not delete - used in Document Delivery"
					goto RLDone
				Endif	
			Endif
		loop
		TRY close #DCDChan Else Rem
	 Endif ! of delete
	 CABCrec=fileupdatecontlist(e$,CABC,mode$,CABCrec,CABook.)
	 if CABCrec<0 ! error 10000 !error
		returnstatus=0
		Message$="Error "+Str$(CABREC)+" on Addr Book Update"
		goto RLDONE
	 Endif
	 CABSDone: ! finished
	 if action2$="DELETE" let message$="Record deleted" 
	 message$="Record saved"  !record saved
	else ! is inquiry
	 Call GetCustABook(e$,Cust$,SList$[],List$[],CUR,maxcnt,CTLC,CABC,CUC,cust.)
	 Call AddtoStr(e$,rstr$,SList$[]) ! add selector list to string before data (list$[])
	end if !SAVE
  endif
  if action1$="ROUTING" ! zone / stop info					doc=CustRouting-GetCustRoute.doc
      valact1=0 ! valid action1
	Call GetCustRoute(e$,Cust$,List$[],CUR,maxcnt,intCo,CTLC,ZNC,CUC,cust.)
  endif
  if action1$="BANKROUTE" ! "bank routing info (internal sub)doc=CustBankRouting-BankRoute.doc
      valact1=0 ! valid action1
	Call BankRoute(e$,Cust$,List$[],CUR,maxcnt,CTLC,CUC,cust.)
  endif
  if action1$="CLASSIFY" ! "Classification (ABC, and other misc fields)doc=CustClassify-GetCustClass.doc
      valact1=0 ! valid action1
	Call GetCustClass(e$,Cust$,List$[],CUR,maxcnt,intCo,CTLC,CUC,cust.)
  endif
  if action1$="CREDIT" ! customer credit & A/R (like mx102a)doc=CustCredit-GetCustCred_GetCustCallNts.doc
      valact1=0 ! valid action1
	  UserId$=UserId$+"          " ! space fill
	  !IF A5[6]=0 
		!LET RETURNSTATUS=0
		!MESSAGE$="USER CAN NOT VIEW COLLECTION SCREEN"
		! e$=message$ \ error 10000
		!GOTO RLDONE
	  !ENDIF
	Call GetCustCred(e$,Cust$,UserID$,List$[],CUR,maxcnt,intCo,CTLC,CNC,CUC,cust.)
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string before next call
	Call GetCustCallNts(e$,Cust$,List$[],SList$[],CUR,maxcnt,intCo,CTLC,CUC,cust.)
	Call AddtoStr(e$,rstr$,SList$[]) ! add selector list to string before data (list$[])
	IF A2$[33,33]="Y" ! A5[6]=0
		LET MESSAGE$="Invalid Access to Credit/Collection. Please see System Administrator for access. "
		let returnstatus=0
	endif
  endif
  if action1$="TAXATION" ! tax info - moved to own screen	doc=CustTax-Taxation.doc
      valact1=0 ! valid action1
	Call Taxation(e$,Cust$,List$[],CUR,maxcnt,intCo,Cust.) 
  end if 
  If action1$="COMMISSION" ! commission info				doc=CustComm-GetCustComm.doc
      valact1=0 ! valid action1
	Call GetCustComm(e$,Cust$,List$[],CuR,maxcnt,intCo,CTLC,CuC,cust.,cnotes.)
  Endif
  If action1$="DOCDELIV" ! document delivery				doc=CustDocDelivery-GetCustDocD.doc
	valact1=0 ! valid action1					submit		doc=Custm-SubmitCustDocD.doc
	if action2$="SAVE" or action2$="DELETE" !   delete		doc=Custm-DeleteCustDocD.doc
	DCDChan=OpenFile(9968,intCo) \ if DCDChan = -1 Error 42
	call dxget("doctype",tmp$) !??tmp$ 4 char field
	 tmp$=UCASE$(TRIM$(tmp$))
	 if tmp$<>"INV" AND TMP$<>"PO" AND TMP$<>"SO" AND TMP$<>"STM" ! 4 types avail
		returnstatus=0
		message$="Document type not found"
		goto RLDone
	Endif
	DDkey$="CS",CustKey$,tmp$,"    "\DDKey$=DDKey$[1,12]
	 DCDRec=filegetdocdeliv(e$,DCDChan,"=",1,DDKey$,Docd.)
	 if DCDRec<0
		clear Docd.
		Docd.CustomerCode=Custkey$
		Docd.ContactType$="CS"
		Docd.DocumentType$=tmp$,"    "
	 end if
	 call dxget("VIA",tmp$)\Docd.via=tmp$
	 !if docd.via<0 if docd.via>3 let e$="Invalid Via Code!"\error 10000
	 call dxget("contkey",tmp$)
	 if tmp$<>"0" let Docd.addrentry=tmp$[9,10] else let docd.addrentry=0 ! # from drop list just the contact #.... or 0 for none
	 if (Docd.via=1 or Docd.via=2) and Docd.addrentry=0
		returnstatus=0
		message$="No Contact selected"
		goto RLDone
	 Endif
	 if docd.addrentry>0
		tmp$= Docd.addrentry using "##"
		cabckey$="CS",CustKey$,tmp$
		CABCrec=filegetcontlist(e$,CABC,"=",1,cabcKey$,CABook.)
		if CABCRec<=0
			returnstatus=0
			message$="Contact Not found"
			goto RLDone
		Endif
		If docd.via=1 ! fax
			if cabook.Fax=0 and cabook.Fax2=0
				returnstatus=0
				message$="No Fax number on Contact"
				goto RLDone
			Endif
		Endif
		if docd.via=2 ! email
			if Rtrim$(cabook.EmailAddr$)=""
				returnstatus=0
				message$="No Email Address for Contact"
				goto RLDone
			Endif
		Endif
	 Endif 
	 If DCDRec<0 let mode$="a" else let mode$="c"
	 if action2$="DELETE" let mode$="d"
	 DCDrec=fileupdatedocdeliv(e$,DCDChan,mode$,DCDrec,DocD.)
	 if DCDrec<0 ! error 10000 !issue updating,adding or deleting record
		returnstatus=0
		Message$="ERROR "+Str$(DCDREC)+" updating Doc Delivery"
		goto RLDONE
	 Endif
	 if action2$="DELETE" let message$="Record deleted" Else message$="Record saved"  !record saved
	else ! not save or delete - inquiry or EDIT
	 ! If action2$="EDIT" in Call sends droplists			doc=Custm-EditCustDocD.doc
		
	 Call GetCustDocd(e$,Cust$,List$[],SList$[],CUR,maxcnt,intCo,CTLC,CUC,cust.,rstr$)
	 Call AddtoStr(e$,rstr$,SList$[]) ! add selector list to string before data (list$[])
	end if
  endif
  If action1$="UDAFIELDS" ! internal & Detail				doc=CustUDA-UDAFlds.doc
    valact1=0 ! valid action1
	Call UDAFlds(e$,Cust$,List$[],CUR,maxcnt,intCo,Cust.)
  endif
  If action1$="CUSTREBATE" ! internal & Detail				doc=CustUDA-UDAFlds.doc
    valact1=0 ! valid action1
	Call GetCustRebate(e$,Cust$,List$[],CUR,maxcnt,intCo,CUC,Cust.)
  endif
! finish off the related links section
  	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	If valact1=-1 ! action1$ is NOT ON LIST
	  ReturnStatus=0 ! show problem
	  Message$="ACTION NOT DEFINED"
	endif
	!
   RLDone: ! finish
	! end of ! action="relatedlinks"
  case "BUDGETPO" ! related link budgets/blanketpo		doc=Custm-GetBudget.doc
		ReturnStatus=1 !					submit		doc=Custm-SubmitBudget.doc
		Message$="OK" !						edit		doc=Custm-EditBudget.doc
		
		Call DXGet("CUSTID",tmp$)
		X2=tmp$
		Cust$=X2 Using "######"
		CUR = filegetcust(e$,CUC,"=",1,cust$,cust.)
		If cur<0
			ReturnStatus=0
			Message$="CUSTOMER "+Cust$+" NOT FOUND"
			Goto BCustInv
		Endif
		Custid=Cust$
		
		Clear List$[]
		Call GetBInfo()
		
		BCustInv: ! 
		
		! end of budgetpo
  case "MULTISLSM" ! related link Multi-Slsm				doc=Custm-GetMSlsm.doc
		ReturnStatus=1 !					submit			doc=Custm-SubmitMSlsm.doc
		Message$="OK"
		Call DXGet("CUSTID",tmp$)
		X2=tmp$
		Cust$=X2 Using "######"
		CUR = filegetcust(e$,CUC,"=",1,cust$,cust.)
		If cur<0
			ReturnStatus=0
			Message$="CUSTOMER "+Cust$+" NOT FOUND"
			Goto MSCustInv
		Endif
		Custid=Cust$
		Call MSLSM()

		MSCustInv: ! done
		! end of Multislsm

  case "SPLITCOMMISSION"
		ReturnStatus=1
		Message$="OK"
		Call DXGet("CUSTID",tmp$)
		X2=tmp$
		Cust$=X2 Using "######"
		CUR = filegetcust(e$,CUC,"=",1,cust$,cust.)
		If cur<0
			ReturnStatus=0
			Message$="CUSTOMER "+Cust$+" NOT FOUND"
		else
			! got the customer
			Custid=Cust$
			if action2$="SAVECATSPLIT"
				Try Close #CUC  Else Rem
				CUC = OpenFile(1808,intCo) \ If CUC = -1 Error 42 !cust
				call dxget("SPLITFLAG", tmp$)
				cust.CommissionByCategory = tmp$
				aa=fileupdatecust(e$,CUC,"c",CUR,cust.,0,0,-1)
				if aa<0 ! a problem
					returnstatus=0
					message$="ERROR ON UPDATE "+Str$(aa)+" "+e$
				Endif
			else
				Call ProcessCommissionSplits()
			end if
		Endif
		! end of Split Commission
  case "IMGLIST"
  	DOCTYPE$ = "CD"	! Customer Document                               
	CODE$ = cust$	! "######"                                  
	MODE = 1		! return list of docs available
	!
	! Call dxsave(0,"tmp/custin.txt!") !   Stop
	! Call programdump("tmp/imglist!","") ! dump program vars
	!
	Call "IMVREL.DL4",DOCTYPE$,CODE$,MODE,List$[]    
	!
	Call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	Let ReturnStatus=1
	Message$="OK"
  Case "CPI"
    If p61$[111,111]="Y"
		Let ReturnStatus=1
		Message$="OK"
		CustNo=Custid
		call cpiinquiry(e$,intco,maxcnt,userid$,Custno,"",List$[])
		Call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Else
		let returnstatus=0
		Message$="CPI is not active"
	Endif
!
   End Select
	!
   MCMDone: ! finished
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
!
	Call SetOutput(e$,rstr$)
! end of main
else
 include "src/callmainerrnet.inc"
end try
end  ! end of Custm program
!
! ---------------------------------------------------------------------
! may want to make this a sub custmain()
Sub CustMain()
 Try
	! assumes return main record info
	!Call OpenFiles() ! open any/all
	If action2$<>"" ! entry/edit - some read-only - Need RW
		Try Close #CUC  Else Rem
		Try Close #CNC  Else rem
		Try Close #CSHNC Else Rem
		CUC = OpenFile(1808,intCo) \ If CUC = -1 Error 42 !cust
		CNC = OpenFile(720,intCo) \ If CNC = -1 Error 42 !custnotes
		CSHNC=OpenFile(9973,intCo) \ if CSHNC = -1 Error 42 !custshnote
	Endif
	!etc for all files needed
	!
	! get custuct record
	Call DXGet("custid",cust$) \ custid=cust$
	cust$=custid using "######"
	cust$ = cust$+"            "
	cust$[7]="" ! "must be 6 only
	if action2$<>"" ! entry/edit
		If action2$<>"ADD" and action2$<>"COPY" !				doc=Custm-GetDataDirection.doc
			mode$=b$
			if action1$="NEXT" ! next from curr
				mode$=">"
			Endif
			if action1$="PREV" ! back 1 from curr
				mode$="<"
			Endif
			if action1$="FIRST" ! first on file
				Cust$=b$
				mode$=">"
			Endif
			If Action1$="LAST" ! last on file
				Cust$="}}}"
				mode$="<"
			Endif
			if RTrim$(mode$)<>"" ! do it
				SearKey$=Cust$
				custrec = filegetcust(e$,CUC,mode$,1,SearKey$,cust.)
				If Custrec<=0
					returnstatus=0
					message$="End of Index reached"
					goto CMDone
				Endif
				cust$=SearKey$
				Cust$[7]=""
				custid=cust$ ! need for later
			Endif
		Endif ! of not add or copy
	Endif ! of entry/edit
	If custid<=0 or custid>999999 or fra(custid) ! MUST HAVE ONE
		returnstatus=0
		Message$="Invalid Customer Number"
		goto CMDone
	Endif
	mode$="="
	keyno=1
	!!!!!!!!!later replace filegetcust with same routine named filegetcustedit  located as external sub in this program, to used an abbreviated def struct for crc and writes!!!!
	!!!!!!!!!how should we pass the crc value to .net?   as part of status section??
	CUR = filegetcust(e$,CUC,mode$,keyno,cust$,cust.,0,100000,crc)    !0,100000,crc 0 is don't lock,100000 is timeout, crc is to get crc value returned
	If CUR<=0 Clear cust.
	if (action2$="" or action2$="EDIT") and CUR<=0 ! normal - no cust found
			!E$="msgcustNOF" \ error 10000 ! save new allow - a2$="ADD" & CUR<0
			returnstatus=0
			Message$="CUSTOMER NOT FOUND"
			goto CMDone
	Endif
	!
	!get cnote record
	mode$ = "="
	keyno = 1
	CNRec = filegetcustnotes(e$,CNC,mode$,keyno,Cust$,cnotes.)
	If CNRec <= 0 Clear cnotes.\cnotes.customer=cust$
	!
	returnstatus=1
	valact2=0 ! -1(not checking)

	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	If action2$="COPY" ! copy									doc=Custm-CopyCustomer.doc
		valact2=0
		call CustCopy()
		! fall thru normal display
		if returnstatus=0 goto CMDone ! was a problem
	End If
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 
	if action2$="ADD" if CUR>=0 !requesting to add custid, already on file, error
		!e$="msgcustOnFile" \error 10000 !Customer already on file!
		returnstatus=0
		message$="Customer already exists"
		goto CMDone
	end if

	if action2$="SAVE" ! save data								doc=Custm-MainSave.doc
		valact2=0
		! call dxsave(0,"tmp/csvin.txt!")
		if Rtrim$(action1$)<>"" ! front end sent type (ADD/EDIT) toggle
			if action1$="ADD" and CUR>0 ! dupe id now - do as above ADD does
				returnstatus=0 ! surmise someone added while user was entering?
				message$="Customer already exists"
				goto CMDone
			endif
			if action1$="EDIT" and CUR<=0 ! missing now - do as above EDIT does
				returnstatus=0 ! surmise someone deleted while user had it on screen?
				Message$="CUSTOMER NOT FOUND"
				goto CMDone
			endif
		endif ! of action1 sent (program always does "CUR = filegetcust" above)
		!!!!!
		Call CustSave()
		goto CMDone ! no redisplay
	endif ! of save

	If action2$="DELETE" ! delete(after check)					doc=Custm-DeleteCustomer.doc
		valact2=0
		If CUR>0 
			Call CustDel()
		Else
			returnstatus=1
			Message$="Deleted - No Record"
		Endif
		Goto CMDone ! never redisplay
	Endif
	If action2$="ADD" or action2$="EDIT" Let Valact2=0
	If action2$="ADD" ! new customer - default?					doc=Custm-AddCustomer.doc
		cust.CustomerCode=custid
		cust.CustomerBillTo=custid
		cust.ARPostCust=custid
		cust.LpPpGrpCust=custid
		if custom_customer$="MORRISETTE" let cust.DeliverChgLevel=1
		let cust.BoSAllowedFlag=1 ! everyone?
		cust.KeepDetailSales=1
		cust.ManualShiplist=1
		if custom_customer$="HTBERRY" let cust.ManualShiplist=0
		cust.Division=1
		cust.Substitutes=1
		cnotes.DateOpened=tim(6) ! julian
		cnotes.Customer=custid
		cnotes.PRMCUST$="N" ! default on new
		CUR=0
		! CUSTOM DEFAULTS HERE!!
		if custom_customer$="PIEDMONT" let cust.Terms=21;cust.CreditLimit=99;cust.CreditCode=1;cust.CreditCheckDays=45
	Endif
	!   edit mode send data										doc=Custm-GetCustData.doc
	!
	! cust rec section  ---------------------------------------------------------------------------------
	tmp$=bsdel$+"CustomerDetail"+fdel$+rdel$
	tmp$=tmp$+"CustomerID"+fdel$
	tmp$=tmp$+"CustomerName"+fdel$
	tmp$=tmp$+"Address1"+fdel$
	tmp$=tmp$+"Address2"+fdel$
	tmp$=tmp$+"City"+fdel$
	tmp$=tmp$+"State"+fdel$
	tmp$=tmp$+"ZipCode"+fdel$
	tmp$=tmp$+"Country"+fdel$
	tmp$=tmp$+"DateOpened"+fdel$
	tmp$=tmp$+"Telephone"+fdel$
	tmp$=tmp$+"Fax"+fdel$
	tmp$=tmp$+"Contact"+fdel$
	tmp$=tmp$+"SalesRep"+fdel$
	tmp$=tmp$+"Bill To"+fdel$
	tmp$=tmp$+"Post To"+fdel$
	Call AddToStr(e$,rstr$,tmp$)  ! put 1st part of header into rstr$

	!-------------------------------------------------Add Edit ID alone fields
	tmp$="Tax Code"+fdel$
	tmp$=tmp$+"Tax Type"+fdel$
	tmp$=tmp$+"Tax Exempt"+fdel$!!+rdel$
	tmp$=tmp$+"Commission Grid"+fdel$
	tmp$=tmp$+"CommissionByCategory"+fdel$
	tmp$=tmp$+"CommissionCBT"+fdel$
	tmp$=tmp$+"Bank Account"+fdel$
	tmp$=tmp$+"Bank Transit"+fdel$
	tmp$=tmp$+"AbcOverheadFactor"+fdel$
	tmp$=tmp$+"AbcScore"+fdel$
	tmp$=tmp$+"AuthBuyList"+fdel$
	tmp$=tmp$+"DefaultWhse"+fdel$
	tmp$=tmp$+"DeliverChgLevel"+fdel$
	tmp$=tmp$+"sicCode"+fdel$
	tmp$=tmp$+"Priority"+fdel$
	tmp$=tmp$+"CustSalesZone"+fdel$
	tmp$=tmp$+"EccosFlag"+fdel$
	tmp$=tmp$+"ManualShiplist"+fdel$
	tmp$=tmp$+"Customer Discount"+fdel$
	tmp$=tmp$+"Default Order Type"+fdel$
	tmp$=tmp$+"Prevent Mass Delete"+fdel$
	tmp$=tmp$+"CustomerGroup"+fdel$
	tmp$=tmp$+"AllowCCScrn"+fdel$
	tmp$=tmp$+"PMCUST"+fdel$
	tmp$=tmp$+"AllowCreditScrn"+fdel$
	tmp$=tmp$+"DELIVCUST"+fdel$
	tmp$=tmp$+"USECPI"+fdel$
	tmp$=tmp$+"CURRENCYID"+fdel$
	tmp$=tmp$+"CURRENCYDESC"+fdel$
	tmp$=tmp$+"PREMIERCUST"+fdel$ ! send flag!
	tmp$=tmp$+"PREMIERCUSTOMER"+fdel$
	REM ADD UPS FIELDS?

	! tmp$=tmp$+"CPIHOLD"+fdel$ ! send here? ERG wants in Credit Section!
	tmp$=tmp$+rdel$

	!-------------------------------------------------
	Call AddToStr(e$,rstr$,tmp$)  ! put 2nd part header into rstr$

	If action2$="COPY" ! make sure new custid is shown
		Call DxGEt("CustId",cust$)
		Call AddToStr(e$,rstr$,trim$(cust$)+fdel$)	! custcode
	else
		Call AddToStr(e$,rstr$,Str$(cust.CustomerCode)+fdel$)	! custcode
	endif

	Call AddToStr(e$,rstr$,RTrim$(cust.Name$)+fdel$)			! custname
	Call AddToStr(e$,rstr$,RTrim$(cust.Addr1$)+fdel$)		! add1
	Call AddToStr(e$,rstr$,RTrim$(cust.Addr2$)+fdel$)		! add2
	Call AddToStr(e$,rstr$,RTrim$(cust.City$)+fdel$)			! city
	Call AddToStr(e$,rstr$,RTrim$(cust.State$)+fdel$)		! state
	Call AddToStr(e$,rstr$,RTrim$(cust.Zip4$)+fdel$)			! zipcode
	Call AddToStr(e$,rstr$,RTrim$(cust.Country$)+fdel$)		! country
	if cnotes.DateOpened<>0
		xdate$=JDate$(cnotes.DateOpened) ! julian date to mm/dd/yyyy
	else
		xdate$=""
	endif
	Call AddToStr(e$,rstr$,RTrim$(xdate$)+fdel$)		! dateopened
	Call AddToStr(e$,rstr$,rtrim$(cust.Phone$)+fdel$)	! telephone
	Call AddToStr(e$,rstr$,RTrim$(cnotes.FaxNumber$)+fdel$)	! fax
	Call AddToStr(e$,rstr$,RTrim$(cust.Contact$)+fdel$)		! contact
	! sales person
	let tmpch=-1
	let slsmname$=getslsmname$(tmpch,cust.SalesmanCode,intco)
	Call AddToStr(e$,rstr$,Str$(cust.SalesmanCode)+" "+rtrim$(slsmname$)+fdel$)		! salesrep
	! bill to customer name
	if cust.CustomerBillto=cust.CustomerCode ! bill to cust = cust code
			let custname$=cust.Name$
	else
		let tmpch=cuc
		let custname$=getcustname$(tmpch,cust.CustomerBillto,intco)
	endif
	Call AddToStr(e$,rstr$,Str$(cust.CustomerBillto)+" "+rtrim$(custname$)+fdel$)		! billto
	! post to customer name
	if cust.ARPostCust=cust.CustomerCode ! post to cust = cust code
		let custname$=cust.Name$
	else
		let tmpch=cuc
		let custname$=getcustname$(tmpch,cust.ARPostCust,intco)
	endif
	Call AddToStr(e$,rstr$,Str$(cust.ARPostCust)+" "+rtrim$(custname$)+fdel$)	!removed rdel$	! post to
   


	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!TAXATION!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	Call AddToStr(e$,rstr$,Str$(cust.TaxCode)+fdel$)
	Call AddToStr(e$,rstr$,Str$(cust.TaxType)+fdel$)
	Call AddToStr(e$,rstr$,Rtrim$(cust.TaxExemp$)+fdel$)
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!COMMISSION!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	Call AddToStr(e$,rstr$,Str$(cust.CommissionGrid)+fdel$)
	call AddToStr(e$,rstr$,str$(cust.CommissionByCategory)+fdel$)
	call AddToStr(e$,rstr$,str$(cnotes.CommCBTable)+fdel$)
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!BANKROUTE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	if p9$[49,49]="Y" 
		dim cbnk. as custbank
		dim kcbnk1$[50],kcbnk2$[50],3%,rec_cbnk
		ch_cbnk=OpenFile(9605,intCo)
		let cbnk.routing$=" ",cbnk.routing$
		let cbnk.bankid$=" ",cbnk.bankid$
		let custid=cust$
		let kcbnk1$[1,6]=custid using "######"
		search #ch_cbnk,2,1;kcbnk1$,rec_cbnk,e
		if not(e)		 
			read record #ch_cbnk,rec_cbnk;cbnk.;
		endif
		call AddToStr(e$,rstr$,Rtrim$(cbnk.BankId$)+fdel$) ! 
		call AddToStr(e$,rstr$,Rtrim$(cbnk.Routing$)+fdel$) ! 
	else
		call AddToStr(e$,rstr$,""+fdel$) ! 
		call AddToStr(e$,rstr$,""+fdel$) ! 
	endif
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CLASSIFY!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	call AddToStr(e$,rstr$,Str$(cust.AbcOverheadFactor)+fdel$)
	call AddToStr(e$,rstr$,Str$(cust.AbcScore)+fdel$)
	if cust.AuthBuyList$="" let cust.AuthBuyList$="N"
	call AddToStr(e$,rstr$,Rtrim$(cust.AuthBuyList$)+fdel$)
	call AddToStr(e$,rstr$,Str$(cust.DefaultWhse)+fdel$)
	call AddToStr(e$,rstr$,Str$(cust.DeliverChgLevel)+fdel$)
	if custom_customer$="WENELSON"
		call AddToStr(e$,rstr$,trim$(cust.UserDefined3$[11,20])+fdel$)
	else
		call AddToStr(e$,rstr$,Str$(cust.sicCode)+fdel$)
	endif
	call AddToStr(e$,rstr$,Str$(cust.Priority)+fdel$)
	call AddToStr(e$,rstr$,Str$(cust.CustSalesZone)+fdel$)
	tmp$="N" \if cust.Eccosflag=1 let tmp$="Y"
	call AddToStr(e$,rstr$,tmp$+fdel$)
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CUSTOMER GENERAL!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	tmp$="N" \if cust.ManualShiplist=1 let tmp$="Y"
	call AddToStr(e$,rstr$,tmp$+fdel$)
	call AddToStr(e$,rstr$,Str$(cust.CustomerDiscount)+fdel$)
	call AddToStr(e$,rstr$,Str$(cust.DefaultOrderType)+fdel$)
	tmp$="N" \if cust.PreventMassDelete=1 let tmp$="Y"
	call AddToStr(e$,rstr$,tmp$+fdel$)
	Call AddtoStr(e$,rstr$,Str$(cust.CustomerGroup)+fdel$)
	tmp$="N" \ if a2$[30,30]="Y" let tmp$="Y"
	call AddToStr(e$,rstr$,tmp$+fdel$) ! allow cc scrn
	if not(cust.LpPpGrpCust) let cust.LpPpGrpCust=cust.customercode
	if cust.LpPpGrpCust=cust.CustomerCode ! price master to cust = cust code
		let custname$=cust.Name$
	else
		let tmpch=cuc
		let custname$=getcustname$(tmpch,cust.LpPpGrpCust,intco)
	endif
	Call AddToStr(e$,rstr$,Str$(cust.LpPpGrpCust)+" "+rtrim$(custname$)+fdel$)	!removed rdel$	! post to
	tmp$="N" \ IF A2$[33,33]<>"Y" let tmp$="Y"
	call AddToStr(e$,rstr$,tmp$+fdel$) ! allow credit scrn
	! delivery customer 
	if cust.MastDelvCust<1 or cust.MastDelvCust>999999
		let cust.MastDelvCust=cust.customercode
	endif
	if cust.MastDelvCust=cust.CustomerCode ! price master to cust = cust code
		let custname$=cust.Name$
	else
		let tmpch=cuc
		let custname$=getcustname$(tmpch,cust.MastDelvCust,intco)
	endif
	REM ADD UPS??
	Call AddToStr(e$,rstr$,Str$(cust.MastDelvCust)+" "+rtrim$(custname$)+fdel$)	!removed rdel$
	tmp$="N" \ if p61$[111,111]="Y" let tmp$="Y" ! cpi
	Call AddtoStr(e$,rstr$,tmp$[1,1],fdel$)
	if p61$[136,136]<>"Y" let cnotes.currid=0
	If cnotes.currid<0 or cnotes.currid>7999 let cnotes.currid=0
	Call AddtoStr(e$,rstr$,str$(cnotes.currid),fdel$)
	let curr.desc$=""
	if p61$[136,136]="Y"
		if cnotes.currid<>0
			ch_curr=findchannel()
			tmp$="2/CURRENCY"+str$(Intco)
			ROpen #ch_curr,tmp$
			let keycurr$=cnotes.currid using "####"
			search #ch_curr,2,1;keycurr$,rec_curr,e
			if e<>0
				let curr.desc$="Currency ID is not on File "
			else
				read record #ch_curr,rec_curr;curr.;
			endif
			try
				close #ch_curr
			else
				rem
			end try
		else
			curr.desc$="No Currency Rate"
		endif
	endif
	Call AddtoStr(e$,rstr$,rtrim$(curr.desc$),fdel$)
	! send Premier flag for Inquiry? 
	tmp$="N" \ if cnotes.PRMCUST$="A" or cnotes.PRMCUST$="S" let tmp$="Y"
	call addtostr(E$,rstr$,tmp$,fdel$) ! 62459 addition - word Premier on Inquiry
	tmp$="N" \ if cnotes.PRMCUST$="A" or cnotes.PRMCUST$="S" let tmp$=cnotes.PRMCUST$
	call addtostr(E$,rstr$,tmp$,fdel$) ! 62459 addition - the actual field
	call AddToStr(e$,rstr$,rdel$) !end of row
	Call AddToStr(e$,rstr$,esdel$)  ! end of section

	!
	! -----------------Credit section ---------------------------------------------------------------------
	tmp$=bsdel$+"Credit"+fdel$+rdel$
	tmp$=tmp$+"Credit"+fdel$
	tmp$=tmp$+"Values"+fdel$+rdel$
	Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$
	let tmpch=-1
	let artermd$=getartermd$(tmpch,cust.Terms,intco)
	Call AddToStr(e$,rstr$,"Terms"+fdel$+Str$(cust.Terms)+" "+rtrim$(artermd$)+fdel$+rdel$)	! terms
   
	!Call AddToStr(e$,rstr$,"CreditLimit"+fdel$+Str$(cust.CreditLimit )+fdel$+rdel$)	! credit limit
	tmp$=cust.CreditLimit  using "##########.##"
	if action2$="" let tmp$=cust.CreditLimit  using "$$$$$$$$$$$$.##"
	Call AddToStr(e$,rstr$,"CreditLimit"+fdel$+ltrim$(tmp$)+fdel$+rdel$)	! credit limit
	! STATEMENT TYPE
	let tmpch=ctlc
	let stattyped$=getstattyd$(tmpch,cust.StmtType,intco)
	Call AddToStr(e$,rstr$,"Stmt Type"+fdel$+Str$(cust.StmtType)+" "+rtrim$(stattyped$)+fdel$+rdel$)	! stmt type
	! CREDIT CODE
	let tmpch=ctlc
	let credcoded$=getcredcdd$(tmpch,cust.CreditCode,intco)
	Call AddToStr(e$,rstr$,"Credit Code"+fdel$+Str$(cust.CreditCode)+" "+rtrim$(credcoded$)+fdel$+rdel$)	! credit code

	Call AddToStr(e$,rstr$,"Credit CK Days"+fdel$+Str$(cust.CreditCheckDays)+fdel$+rdel$)	! credit ck days
	! Service  Charge
	let tmpch=-1
	let svcchgd$=getsvcchgd$(tmpch,cust.SCStatus,intco)
	Call AddToStr(e$,rstr$,"S/C Status"+fdel$+Str$(cust.SCStatus)+" "+rtrim$(svcchgd$)+fdel$+rdel$)		! S/C Status
	If p61$[111,111]="Y" ! CPI
		tmp$="N" \ if cust.CPIHOLD$="Y" let tmp$="Y"
		if action2$="ADD" let tmp$="Y"
		Call AddToStr(e$,rstr$,"CPI Hold"+fdel$+tmp$[1,1]+fdel$+rdel$)
	Else
		if action2$<>"" ! inquiry - no send - send in entry/Edit always
			Call AddToStr(e$,rstr$,"CPI Hold"+fdel$+"N"+fdel$+rdel$)
		Endif
	Endif ! or else to send blank
	LET XDATE$=" ",XDATE$
	IF cust.CreditApplicatDate<>0
		LET XDATE$=PDATE$(cust.CreditApplicatDate)
	endif
	Call AddToStr(e$,rstr$,"Credit App Date"+fdel$+rtrim$(xdate$)+fdel$+rdel$)	! 
	Call AddToStr(e$,rstr$,esdel$)	! end of section

	! -----------------Controls section ---------------------------------------------------------------------
	tmp$=bsdel$+"Controls"+fdel$+rdel$
	tmp$=tmp$+"Control"+fdel$
	tmp$=tmp$+"Value"+fdel$+rdel$
	Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$
	tmp$=""
	if cust.PoRequiredFlag=0 let tmp$="No"
	if cust.PORequiredFlag=1 let tmp$="Required-Dupes OK"
	if cust.PoRequiredFlag=2 let tmp$="No - No Dupes"
	if cust.PoRequiredFlag=3 let tmp$="Required-No Dupes"
	Call AddToStr(e$,rstr$,"PO Required"+fdel$+Str$(cust.PoRequiredFlag)+" "+rtrim$(tmp$)+fdel$+rdel$)	! PO Required
	!  Call AddToStr(e$,rstr$,"Allow Substitute"+fdel$+YN$(cust.Substitutes)+fdel$+rdel$)	! Allow Substitute
	!  Call AddToStr(e$,rstr$,"Price Inc. Note"+fdel$+YN$(cust.NotifyPriceChg)+fdel$+rdel$)	! Price Inc. Note
	! Call AddToStr(e$,rstr$,"Back Order"+fdel$+YN$(cust.BoSAllowedFlag)+fdel$+rdel$)	! Back Order
	! Call AddToStr(e$,rstr$,"# Duplicate Inv"+fdel$+cust.NoDupInvToPrt$+fdel$+rdel$)	! # Duplicate Inv.
	! price type
	let tmpch=-1
	let pricetyped$=getpricetyd$(tmpch,cust.PriceType,intco)
	Call AddToStr(e$,rstr$,"Price Type"+fdel$+Str$(cust.PriceType)+" "+rtrim$(pricetyped$)+fdel$+rdel$)	! Price Type

	! Customer Sales Category
	let tmpch=-1
	let custcatd$=getcustcatd$(tmpch,cust.CustomerCategory,intco)
	Call AddToStr(e$,rstr$,"Customer Ctgy"+fdel$+Str$(cust.CustomerCategory)+" "+rtrim$(custcatd$)+fdel$+rdel$)	! Customer Category

	! Customer Division
	let tmpch=-1
	let divname$=getdivname$(tmpch,cust.Division,intco)
	Call AddToStr(e$,rstr$,"Division"+fdel$+Str$(cust.Division)+" "+rtrim$(divname$)+fdel$+rdel$)	! Division 
	chan=Openfile(-9934,IntCo)
	tmp$=b$
	if chan>0
		tmp3$=" ",tmp3$
		tmp3$=cust.CustomerGroup using "######"
		if cust.CustomerGroup>=1
			search #chan,2,1;tmp3$,R,E
		Else
			let e=1
		endif
		if not(e)
			mat read #chan,r,0;tmp$;
			tmp$[31]=""
		Else
			if cust.CustomerGroup=0 let tmp$="None"+b$ Else tmp$="Group not found"
		Endif
		Try close #Chan Else Rem
	Endif
	clear webstr$
	webstr$="Customer Group"+fdel$+Str$(cust.CustomerGroup)
	if action2$="" ! inquiry
		webstr$=webstr$+" "+RTrim$(tmp$)
	Endif
	Call AddToStr(e$,rstr$,webstr$,fdel$,rdel$) ! cust group
	!Call Addtostr(e$,rstr$,"Customer Group"+fdel$+Str$(cust.CustomerGroup)+" "+RTrim$(tmp$)+fdel$+rdel$)
	
	Clear webstr$
	if cnotes.residential=1
		tmp$="Y"
	else
		tmp$="N"
	endif
	webstr$=webstr$+"residential"+fdel$+RTrim$(tmp$)+fdel$+rdel$
	if cnotes.sendemail=1
		tmp$="Y"
	else
		tmp$="N"
	endif
	webstr$=webstr$+"Send E-mail"+fdel$+RTrim$(tmp$)+fdel$+rdel$
	webstr$=webstr$+"E-mail Address"+fdel$+RTrim$(cnotes.email$)+fdel$+rdel$
	Call Addtostr(e$,rstr$,webstr$) 
	Clear webstr$
	! Call AddToStr(e$,rstr$,"Ship w/Inv."+fdel$+cust.ShpWithInvoiceYN$+fdel$+rdel$)	! Ship w/Inv. ! remove per err 8/6/7
	! Call AddToStr(e$,rstr$,"Price on Order"+fdel$+YN$(cust.PrintOrderPrices)+fdel$+rdel$)	! Price on Order ! remove per err 8/6/7
	Call AddToStr(e$,rstr$,esdel$)	! end of section

! -----------------AR section ---------------------------------------------------------------------
	Call ArBuck(arbuck$[],intCo)
	tmp$=bsdel$+"CustAR"+fdel$+rdel$
	tmp$=tmp$+"Bucket"+fdel$
	tmp$=tmp$+"Dollars"+fdel$+rdel$
	Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$
	Call AddToStr(e$,rstr$,ARBuck$[1]+fdel$+RTrim$(cust.CurrentArAgeBal using "--------.##")+fdel$+rdel$)
	Call AddToStr(e$,rstr$,ARBuck$[2]+fdel$+RTrim$(cust.AgeArAmt1 using "--------.##")+fdel$+rdel$)
	Call AddToStr(e$,rstr$,ARBuck$[3]+fdel$+RTrim$(cust.AgeArAmt2 using "--------.##")+fdel$+rdel$)
	Call AddToStr(e$,rstr$,ARBuck$[4]+fdel$+RTrim$(cust.AgeArAmt3 using "--------.##")+fdel$+rdel$)
	Call AddToStr(e$,rstr$,ARBuck$[5]+fdel$+RTrim$(cust.AgeArAmt4 using "--------.##")+fdel$+rdel$)

	if cust.UnappliedCredit <> 0 ! unapplied
		let tmp$="Unapplied Cr"
		Call AddToStr(e$,rstr$,tmp$+fdel$+rTrim$(cust.UnappliedCredit using "--------.##")+fdel$+rdel$)
	endif
	Call AddToStr(e$,rstr$,ARBuck$[0]+fdel$+rTrim$((cust.CurrentArAgeBal+cust.AgeArAmt1+cust.AgeArAmt2+cust.AgeArAmt3+cust.AgeArAmt4)-cust.UnappliedCredit using "--------.##")+fdel$+rdel$)
	Call AddToStr(e$,rstr$,esdel$)	! end of section
	! -----------------U.D.A. section ---------------------------------------------------------------------
	tmp$=bsdel$+"CustomerUDA"+fdel$+rdel$
	tmp$=tmp$+"FieldDesc"+fdel$
	tmp$=tmp$+"UDAValue"+fdel$+rdel$
	Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$
	! evidently the ctlc file is closed somewhere, need a check/open
	try
		mat read #ctlc,67,112;udadesc$;
	else ! "failed
		CTLC = OpenFile(-9999,intCo) \ If CTLC = -1 Error 42 !control
	end try
	! get descriptions of uda fields from control file record 67, fields 9-12
	Mat read #ctlc,67,112;udadesc$;
	if udadesc$="" let udadesc$="CUST UDA FLD 1"
	Call AddtoStr(e$,rstr$,udadesc$+fdel$+RTrim$(cust.UserDefined1$)+fdel$+rdel$)
	mat read #ctlc,67,126;udadesc$;
	if udadesc$="" let udadesc$="CUST UDA FLD 2"
	Call AddtoStr(e$,rstr$,udadesc$+fdel$+RTrim$(cust.UserDefined2$)+fdel$+rdel$)
	mat read #ctlc,67,140;udadesc$;
	if udadesc$="" let udadesc$="CUST UDA FLD 3"
	if custom_customer$="WENELSON"
		Call AddtoStr(e$,rstr$,udadesc$+fdel$+RTrim$(cust.UserDefined3$[1,10])+fdel$+rdel$)
	else
		Call AddtoStr(e$,rstr$,udadesc$+fdel$+RTrim$(cust.UserDefined3$)+fdel$+rdel$)
	endif
	mat read #ctlc,67,154;udadesc$;
	if udadesc$="" let udadesc$="CUST UDA FLD 4"
	Call AddtoStr(e$,rstr$,udadesc$+fdel$+RTrim$(cust.UserDefined4 using "-----------.####")+fdel$+rdel$)
!	
	Call AddToStr(e$,rstr$,esdel$)	! end of section

	!
	!
	!   if add/edit need to send back most related link sections as well
	if action2$="EDIT" or action2$="ADD" or action2$="COPY"
		! Open any files for related links
		! Call OpenFiles()
		!"TAXATION" ! tax info !needed, already done above ??
		Call Taxation(e$,Cust$,List$[],CUR,maxcnt,intCo,Cust.) 
		call AddToStr(e$,rstr$,List$[])
		!"ROUTING" ! zone / stop info
		Call GetCustRoute(e$,Cust$,List$[],CUR,maxcnt,intCo,CTLC,ZNC,CUC,cust.)
		call AddToStr(e$,rstr$,List$[])
		!"OINOTES" ! "order/invoice notes (note 1/2 from custnotes file)
		Call GetCustNoteOI(e$,Cust$,List$[],CUR,maxcnt,CTLC,CNC,CUC,cust.)
		call AddToStr(e$,rstr$,List$[])
		!"SHIPNOTES" ! "notes from custshnote file
		Call GetCustSHNotes(e$,Cust$,List$[],CUR,maxcnt,CTLC,CSHNC,CUC,cust.)
		call AddToStr(e$,rstr$,List$[])

		!"COMMISSION" ! commission info
		Call GetCustComm(e$,Cust$,List$[],CuR,maxcnt,intCo,CTLC,CuC,cust.,cnotes.)
		call AddToStr(e$,rstr$,List$[])
		! user defined fields  !needed, already done above ??
		! Call UDAFlds(e$,Cust$,List$[],CUR,maxcnt,intCo,Cust.)
		!"BANKROUTE" ! "bank routing info (internal sub) !nneded, already done above ??
		Call BankRoute(e$,Cust$,List$[],CUR,maxcnt,CTLC,CUC,cust.)
		call AddToStr(e$,rstr$,List$[])
		!"CLASSIFY" ! "Classification (ABC, and other misc fields)
		Call GetCustClass(e$,Cust$,List$[],CUR,maxcnt,intCo,CTLC,CUC,cust.)
		call AddToStr(e$,rstr$,List$[])
		!"GENERAL" ! misc fields
		Call GetCustGeneral(e$,Cust$,List$[],CUR,maxcnt,CTLC,CNC,CUC,cust.)
		call AddToStr(e$,rstr$,List$[])
		!"CUSTREBATE" ! customer rebate related fields
		Call GetCustRebate(e$,Cust$,List$[],CUR,maxcnt,intCo,CUC,Cust.)
		call AddToStr(e$,rstr$,List$[])
	end if !add/edit

 	If valact2=-1 ! action1$ is NOT ON LIST
		ReturnStatus=0 ! show problem
		Message$="ACTION2 NOT DEFINED"
	endif
	!
  CMDone: ! finish CustMain
	! status section
	!call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	!call AddToStr(e$,rstr$,WebStr$)
	!
	!Call SetOutput(e$,rstr$)
! end of main
else
 include "src/callsuberr.inc"
end try
end sub ! custmain
!----------------------------------------------------------------------------
!!! section for order list , back order list, and quote list
Sub OOrders()
Try 
	Dim  dlog$[50]

	!tmp$="1212"+fdel$+"RAIN MAKER"+fdel$+"1"+fdel$+"1"+fdel$+"221683"+fdel$+" "+fdel$+"02/24/2007"+fdel$+"02/24/2007"+fdel$+"4-212-1D"+fdel$+"$167.04"+fdel$+"$53.84"+fdel$+"32.23%"+fdel$+" "+fdel$ +"Mike L."+fdel$+rdel$
	!Call AddToStr(e$,rstr$,tmp$+esdel$)  ! end of section
	!Call SetOutput(e$,rstr$)

	Declare External sub oolist
	Declare Sub updatelog,errTrap

	Include "src/bovars.inc"

	
	Dim arrSales[999],custid$[10],3%,maxrow ! ,cost_lev[3]

	maxrow=3000
	Dim bo.[maxrow] as boInfo
	Dim oo.[maxrow] as ooInfo
	Dim bi.[maxrow] as bInfo
	!cost_lev[0]=2
	!cost_lev[1]=2
	!cost_lev[2]=2
	!cost_lev[3]=2

	Call DXGet("custid",custid$) \ custid = custid$
	if not(custid) Call DXGet("U_FOCUS",custid$) \ custid = custid$

	Select Case Action$
		Case "OORDERS"
			tmp$=bsdel$+"OpenOrders"+fdel$+rdel$
			tmp$=tmp$+"Customer"+fdel$+ "Name"+fdel$+"Type"+fdel$+"Status"+fdel$+"Order#"+fdel$+"PO#"+fdel$
			tmp$=tmp$+"Order Date"+fdel$+"Ship Date"+fdel$+"Truck-Stop-Rte"+fdel$+"Total Sale"+fdel$+"G/P"+fdel$
			tmp$=tmp$+"GTM"+fdel$+"Hold Code"+fdel$+"Entered By" +fdel$+"OrigOrder"+fdel$+rdel$
			Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$


			Call OOList(intCo,999,debug,"files/6/dx.log",oo.[], ii,ss, maxRow, arrsales[], custid)
			if ii > maxrow let ii=maxrow
			tmp$=Trim$(oo.[0].CustId$)
			if ii=0 and tmp$="" goto noodata
			For i=0 to ii
			   tmp$=oo.[i].CustId$+fdel$
			   tmp$=tmp$+oo.[i].CustName$+fdel$
			   tmp$=tmp$+oo.[i].Type$+fdel$
			   tmp$=tmp$+oo.[i].Status$+fdel$
			   tmp$=tmp$+oo.[i].OrderNo$+fdel$
			   tmp$=tmp$+oo.[i].PO$+fdel$
			   tmp$=tmp$+oo.[i].Ordered$+fdel$
			   tmp$=tmp$+oo.[i].ShipDT$+fdel$
			   tmp$=tmp$+oo.[i].RS$+fdel$
			   tmp$=tmp$+oo.[i].TResale$+fdel$
			   tmp$=tmp$+oo.[i].TGPP$+fdel$	! \if nocost$="Y" let col10$[i]=" "
			   tmp$=tmp$+oo.[i].GTM$+fdel$
			   tmp$=tmp$+oo.[i].Hold$+fdel$
			   tmp$=tmp$+oo.[i].EnteredBy$+fdel$
			   tmp$=tmp$+oo.[i].Product$+fdel$ ! actually oref[2](origorder) ! instead of mass re-compile
			   tmp$=tmp$+rdel$
			   Call AddToStr(e$,rstr$,tmp$)  ! put into rstr$
			Next i
			Noodata: ! none
			call AddToStr(e$,rstr$,esdel$)
			call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
			call AddToStr(e$,rstr$,WebStr$)
			Call SetOutput(e$,rstr$)

			!! BEGIN THE QUOTES !!
			Case "QUOTES"
			tmp$=bsdel$+"Open Quotes"+fdel$+rdel$
			tmp$=tmp$+"Customer"+fdel$+ "Name"+fdel$+"Type"+fdel$+"Status"+fdel$+"Quoted#"+fdel$+"PO#"+fdel$
			tmp$=tmp$+"Order Date"+fdel$+"Ship Date"+fdel$+"Truck-Stop-Rte"+fdel$+"Total Sale"+fdel$
			tmp$=tmp$++"G/P"+fdel$+"GTM"+fdel$+"Hold Code"+fdel$+"Entered By" +fdel$+rdel$
			Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$


			Call Qolist(intCo,999,debug,"files/6/dx.log",oo.[],bi.,ii,ss, maxRow, cost_lev[],arrsales[], custid)

			if ii > maxrow let ii=maxrow
			tmp$=Trim$(oo.[0].CustId$)
			if ii=0 and tmp$="" goto noqdata
			For i=0 to ii
			   tmp$=oo.[i].CustId$+fdel$
			   tmp$=tmp$+oo.[i].CustName$+fdel$
			   tmp$=tmp$+oo.[i].Type$+fdel$
			   tmp$=tmp$+oo.[i].Status$+fdel$
			   tmp$=tmp$+oo.[i].OrderNo$+fdel$
			   tmp$=tmp$+oo.[i].PO$+fdel$
			   tmp$=tmp$+oo.[i].Ordered$+fdel$
			   tmp$=tmp$+oo.[i].ShipDT$+fdel$
			   tmp$=tmp$+oo.[i].RS$+fdel$
			   tmp$=tmp$+oo.[i].TResale$+fdel$
			   tmp$=tmp$+oo.[i].TGPP$+fdel$	! \if nocost$="Y" let col10$[i]=" "
			   tmp$=tmp$+oo.[i].GTM$+fdel$
			   tmp$=tmp$+oo.[i].Hold$+fdel$
			   tmp$=tmp$+oo.[i].EnteredBy$+fdel$+rdel$
			   Call AddToStr(e$,rstr$,tmp$)  ! put into rstr$
			Next i
			noqdata: ! none
			call AddToStr(e$,rstr$,esdel$)
			call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
			call AddToStr(e$,rstr$,WebStr$)
			Call SetOutput(e$,rstr$)
!!! End the quotes !!! 

		Case "BOORDERS"
			tmp$=bsdel$+"BackOrders"+fdel$+rdel$
			! the following header is oorders using for demo
			! tmp$=tmp$+"Customer"+fdel$+ "Name"+fdel$+"Type"+fdel$+"Status"+fdel$+"Order#"+fdel$+"PO#"+fdel$+"Order Date"+fdel$+"Ship Date"+fdel$+"Truck-Stop-Rte"+fdel$+"Total Sale"+fdel$+"G/P"+fdel$+"GTM"+fdel$+"Hold Code"+fdel$+"Entered By" +fdel$+rdel$
			! this is the real BO header
			tmp$=tmp$+"Customer"+fdel$+ "Name"+fdel$+"Order#"+fdel$+"PO#"+fdel$
			tmp$=tmp$+"Order Date"+fdel$+"Item"+fdel$+"Item Desc"+fdel$+"Qty Ord."+fdel$
			tmp$=tmp$+"UM"+fdel$+"Qty on BO"+fdel$+"Shipdate"+fdel$+"Entered By" +fdel$
			tmp$=tmp$+"ONPO"+fdel$+"PODue"+fdel$+"Buyer"+fdel$+rdel$
			Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$

		  Call BOList(intCo,999,debug,"files/6/dx.log",bo.[], ii,ss,maxRow, arrSales[], custid)
			if ii > MaxRow let ii = MaxRow
			tmp$=Trim$(bo.[0].CustId$)
			if ii=0 and tmp$="" goto nobdata
			For i=0 to ii
			   !tmp$=bo.[i].SalesMan$+fdel$
			   tmp$=bo.[i].CustId$+fdel$
			   tmp$=tmp$+bo.[i].CustName$+fdel$
			   tmp$=tmp$+bo.[i].OrderNo$+fdel$
			   !tmp$=tmp$+bo.[i].OrderIT$+fdel$
			   !tmp$=tmp$+bo.[i].Vendor$+fdel$
			   tmp$=tmp$+bo.[i].PO$+fdel$
			   tmp$=tmp$+bo.[i].Ordered$+fdel$
			   tmp$=tmp$+bo.[i].Item$+fdel$
			   tmp$=tmp$+bo.[i].Desc1$+fdel$
			   tmp$=tmp$+bo.[i].QtyOrd$+fdel$
			   tmp$=tmp$+bo.[i].OrdUM$+fdel$
			   tmp$=tmp$+bo.[i].QtyBord$+fdel$
			   tmp$=tmp$+bo.[i].ShipDT$+fdel$
			   tmp$=tmp$+bo.[i].EnteredBy$+fdel$
			   !tmp$=tmp$+bo.[i].Desc2$+fdel$
			   !tmp$=tmp$+bo.[i].QtyOrdWT$+fdel$
			   !tmp$=tmp$+bo.[i].QtyBordWT$+fdel$+rdel$
			   tmp$=tmp$+bo.[i].BOPO$+fdel$
			   tmp$=tmp$+bo.[i].PODue$+fdel$
			   tmp$=tmp$+bo.[i].POBuyer$+fdel$
			   tmp$=tmp$+rdel$ 
			   Call AddToStr(e$,rstr$,tmp$)  ! put into rstr$
			Next i
			nobdata: ! none
			call AddToStr(e$,rstr$,esdel$)
			call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
			call AddToStr(e$,rstr$,WebStr$)
			Call SetOutput(e$,rstr$)
	End Select
else
	include "src/callsuberr.inc"
end try

End Sub

!!! ------------------section for special price list ------ ! mtg
! action = "splist"
Sub CustSp()
Try 
	Dim  dlog$[50]
	!! Declare External Sub custspList      mtg
	
	Declare Sub updatelog,errTrap

	Include "src/custspvars.inc"
	! need for customer special price file ! "src/bovars.inc"

	dim 2%,returnstatus, message$[200]
	Dim arrSales[999],custid$[10],3%,maxrow !,cost_lev[3]

	maxrow=5000
    Dim sp.[maxrow] as custspinfo
	
	Call DXGet("custid",custid$) \ custid = custid$
	if not(custid) Call DXGet("U_FOCUS",custid$) \ custid = custid$

	
	tmp$=bsdel$+"Special Price List"+fdel$+rdel$
	tmp$=tmp$+"Item Code"+fdel$
	! tmp$=tmp$+ "Comm"+fdel$
	tmp$=tmp$+"Decription"+fdel$
	tmp$=tmp$+"Contract#"+fdel$
	tmp$=tmp$+"Start"+fdel$
	tmp$=tmp$+"Cancel"+fdel$
	tmp$=tmp$+"Minimum"+fdel$
	tmp$=tmp$+"Fact/Type"+fdel$
	tmp$=tmp$+rdel$ ! also the last heading line
	Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$
	
	Call CustspList(intco,sp.[], ii,returnstatus,message$,maxrow, custid)
	if ii > maxrow let ii=maxrow
	if ii>0
	For i=1 to ii
	   tmp$=sp.[i].ProdCode$+fdel$
	   ! tmp$=tmp$+sp.[i].CommCode$+fdel$
	   tmp$=tmp$+sp.[i].ProdDesc1$+fdel$
	   tmp$=tmp$+sp.[i].ContractNo$+fdel$
	   tmp$=tmp$+sp.[i].StartDate$+fdel$
	   tmp$=tmp$+sp.[i].CancelDate$+fdel$
	   tmp$=tmp$+sp.[i].MinimumQty$+fdel$
	   tmp$=tmp$+sp.[i].FactorType$+fdel$ 
	   tmp$=tmp$+rdel$ 
	   Call AddToStr(e$,rstr$,tmp$)  ! put into rstr$
	Next i
	endif
	call AddToStr(e$,rstr$,esdel$)
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	Call SetOutput(e$,rstr$)
else
	include "src/callsuberr.inc"
end try

End Sub ! -- mtg
!!! end special price list
!!! endcomment   --- mtg
!!! section for invoice detail 
!!! ------------------section for orderdetail ------ ! mtg
!action$= "INVDET"
Sub  InvDet()

Try 
	Dim  dlog$[50]
	
	
	Declare Sub updatelog,errTrap
	Include "src/inc/fileinvm.inc" ! invoice message file
	Include "src/iivars.inc"
        DIM CO$[1],SLS$[3]
	DIM 1%,UCA5[10],STATUS
	dim 1%,UCA2$[50]
	dim 1%,returnstatus, message$[200],invno$[10],custid$[10]
	Dim arrSales[999],3%,maxrow ! ,cost_lev[3]
	dim 3%,invid,tmp3,rec_invm
	maxrow=5000
	
	
	 Dim il. as iInfo
	Dim ils.[maxRow] as iItem
	Dim invm. as invm

!!!!!!! Invoice detail !!!!!
	 Call UserCntrl(USERID$,UCA2$,UCA5[],status,intCo) 
    
    Call DXGet("invno",invno$)  
    !get the specific order detail
      Call DXGet("S_USER.AppID",CO$) ! Company
      Call DXGet("S_USER.Userdef1",SLS$) ! Salesman Number
      Call DXGet("custid",CustID$) ! Customer Number
      let sls$="999" ! set salesperson to 999
     Call IIdet(Val(CO$),Val(SLS$),debug,dlog$,invno$,Custid$,il.,ils.[],ii,ss,MaxRow,cost_lev[],arrSales[])                                               
!     Call OOdet(Val(CO$),Val(SLS$),debug,dlog$,ordno$,Cust$,ol.,ols.[],ii,ss,maxRow,cost_lev[],arrSales[])
	  If ss=10000 e$="Not authorized to view this Invoice."  
	  If ss Error 10000                             

tmp$=bsdel$+"InvoiceHeader"+fdel$+rdel$ ! section 1

Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$
!! order header headings ^M   
tmp$="Invoice"+fdel$
tmp$=tmp$+"Invoice Date"+fdel$
tmp$=tmP$+"Order"+fdel$               
tmp$=tmp$+"Order Date"+fdel$     
tmp$=tmp$+"Whse"+fdel$           
tmp$=tmp$+"Truck"+fdel$          
tmp$=tmp$+"Salesman"+fdel$  
tmp$=tmp$+"Salesman Name"+fdel$
tmp$=tmp$+"Total Cost"+fdel$     
!! order header 2nd line^M       
tmp$=tmp$+"Status"+fdel$         
tmp$=tmp$+"Ship Date"+fdel$      
tmp$=tmp$+"Div"+fdel$            
tmp$=tmp$+"Stop"+fdel$           
tmp$=tmp$+"Entered By"+fdel$     
tmp$=tmp$+"Attn"+fdel$           
tmp$=tmp$+"GTM"+fdel$            
!!! order header 3rd line^M      
tmp$=tmp$+"Due Date"+fdel$       
tmp$=tmp$+"Type"+fdel$           
tmp$=tmp$+"Zone"+fdel$           
tmp$=tmp$+"Terms"+fdel$          
tmp$=tmp$+"GP%"+fdel$
tmp$=tmp$+"GLJEFLAG"+fdel$
tmp$=tmp$+"Cust PO"+fdel$
tmp$=tmp$+"Ship Type"+fdel$
tmp$=tmp$+"Routing"+fdel$
tmp$=tmp$+rdel$
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$  
! invoice first line
tmp$=invno$+fdel$
tmp$=tmp$+il.InvDate$+fdel$
tmp$=tmp$+il.Order$+fdel$
tmp$=tmp$+il.OrderDate$+fdel$
tmp$=tmp$+il.WHSE$+fdel$
tmp$=tmp$+il.truck$+fdel$
tmp$=tmp$+il.slsno$+fdel$
tmp$=tmp$+il.slsname$+fdel$
tmp$=tmp$+il.tcost$+fdel$
! invoice 2nd line
tmp$=tmp$+il.status$+fdel$
tmp$=tmp$+il.shipdate$+fdel$
tmp$=tmp$+il.division$+fdel$
tmp$=tmp$+il.stp$+fdel$
tmp$=tmp$+il.EnteredBy$+fdel$
tmp$=tmp$+il.attn$+fdel$
tmp$=tmp$+il.gtm$+fdel$
! invoice 3rd line

tmp$=tmp$+ il.duedate$+fdel$                  
tmp$=tmp$+ il.Type$+fdel$                     
tmp$=tmp$+ il.zne$+fdel$                      
tmp$=tmp$+ il.term$+fdel$                     
tmp$=tmp$+ il.tgpp$+fdel$ 
tmp$=tmp$+uca2$[42,42]+fdel$
tmp$=tmp$+RTrim$(il.CustPO$)+fdel$
tmp$=tmp$+Rtrim$(il.ShipCMType$)+fdel$
tmp$=tmp$+Rtrim$(il.Routing$)+fdel$
tmp$=tmp$+ rdel$   
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$                               
Call AddToStr(e$,rstr$,esdel$)	! end of section
!! ---- start order shipto/soldto section ---
tmp$=bsdel$+"InvoiceAddress"+fdel$+rdel$
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$   
!! Invoice address heading
tmp$="CustomerNo"+fdel$
tmp$=tmp$+"SoldAddress1"+fdel$
tmp$=tmp$+"SoldAddress2"+fdel$
tmp$=tmp$+"SoldAddress3"+fdel$
tmp$=tmp$+"SoldAddress4"+fdel$
tmp$=tmp$+"ShipAddress1"+fdel$
tmp$=tmp$+"ShipAddress2"+fdel$
tmp$=tmp$+"ShipAddress3"+fdel$
tmp$=tmp$+"ShipAddress4"+fdel$
tmp$=tmp$+"BillToID"+fdel$
tmp$=tmp$+rdel$
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$
tmp$=il.custnumber$+fdel$
tmp$=tmp$+il.SoldAddr1$+fdel$
tmp$=tmp$+il.SoldAddr2$+fdel$
tmp$=tmp$+il.SoldAddr3$+fdel$
tmp$=tmp$+il.SoldAddr4$+fdel$
tmp$=tmp$+il.S2Addr1$+fdel$
tmp$=tmp$+il.S2Addr2$+fdel$
tmp$=tmp$+il.S2Addr3$+fdel$
tmp$=tmp$+il.S2Addr4$+fdel$
tmp$=tmp$+il.BillToID$+fdel$
tmp$=tmp$+rdel$
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$
Call AddToStr(e$,rstr$,esdel$)	! end of section

!! ---- end invoice address section ----
!! invoice total section
tmp$=bsdel$+"InvoiceTotal"+fdel$+rdel$
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$
!!! heading line
tmp$="Total Weight"+fdel$ 
!tmp$=tmp$+"Subtotal"+fdel$
tmp$=tmp$+"Total Cube"+fdel$
tmp$=tmp$+"Subtotal"+fdel$
tmp$=tmp$+"Tax"+fdel$
tmp$=tmp$+"Freight"+fdel$
tmp$=tmp$+"Misc"+fdel$
tmp$=tmp$+"Discount"+fdel$
tmp$=tmp$+"Other"+fdel$
tmp$=tmp$+"Grand Total"+fdel$
!tmp$=tmp$+"Other"+fdel$
tmp$=tmp$+rdel$
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$
!!! second line data
tmp$=il.totweight$+fdel$ 
!tmp$=tmp$+il.Tresale$+fdel$
tmp$=tmp$+il.totcube$+fdel$ 
tmp$=tmp$+il.Tresale$+fdel$
tmp$=tmp$+il.Tax$+fdel$
tmp$=tmp$+il.Freight$+fdel$
tmp$=tmp$+il.misc$+fdel$
tmp$=tmp$+il.discount$+fdel$
tmp$=tmp$+il.other$+fdel$
tmp$=tmp$+il.grandtotal$+fdel$
!tmp$=tmp$+il.other$+fdel$
tmp$=tmp$+rdel$
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$
Call AddToStr(e$,rstr$,esdel$)	! end of section
!! --- end invoice total section ---


!!! ---- start Invoice line section ---- ! start section 4
tmp$=bsdel$+"InvoiceLine"+fdel$+rdel$
tmp$=tmp$+"Line"+fdel$
tmp$=tmp$+ "Item"+fdel$
tmp$=tmp$+"Description1"+fdel$
tmp$=tmp$+"Description2"+fdel$
tmp$=tmp$+"Order Qty"+fdel$
tmp$=tmp$+"Ship Qty"+fdel$
tmp$=tmp$+"B/O Qty"+fdel$
tmp$=tmp$+"UM"+fdel$
tmp$=tmp$+"Unit Price"+fdel$
tmp$=tmp$+"Extended"+fdel$
tmp$=tmp$+"Substitute"+fdel$
tmp$=tmp$+"Ext. Weight"+fdel$
tmp$=tmp$+"GP%"+fdel$
tmp$=tmp$+"Unit Cost"+fdel$
tmp$=tmp$+"LTYPE"+fdel$
tmp$=tmp$+"ONPO"+fdel$
tmp$=tmp$+rdel$                              
         
Call AddToStr(e$,rstr$,tmp$)  ! put heading into rstr$ ! Start of section
    For i=0 to ii-1
	tmp$=""
	tmp$=tmp$+ils.[i].li$+fdel$ ! line # 
	tmp$=tmp$+ils.[i].item$+fdel$ ! item # 
	tmp$=tmp$+ils.[i].desc1$+fdel$ 
	tmp$=tmp$+ils.[i].desc2$+fdel$
	tmp$=tmp$+ils.[i].qtyord$+fdel$ 
	tmp$=tmp$+ils.[i].qtyshp$+fdel$ 
	tmp$=tmp$+ils.[i].qtybord$+fdel$ 
	tmp$=tmp$+ils.[i].uom$+fdel$ 
      	tmp$=tmp$+ils.[i].UnitPrice$+"/"+ils.[i].UPUoM$+fdel$
        tmp$=tmp$+ils.[i].Extended$+fdel$
	tmp$=tmp$+ils.[i].Substitute$,fdel$ ! substitute 
        tmp$=tmp$+ils.[i].ExtWeight$+fdel$
      	tmp$=tmp$+ils.[i].GPP$+fdel$
      	tmp$=tmp$+ils.[i].UnitCost$+"/"+ils.[i].UCUoM$+fdel$
	tmp1$="STK"
	if ils.[i].LineType$<>"ST" let tmp1$="NSTK"
	tmp$=tmp$+tmp1$+fdel$
	tmp$=tmp$+ils.[i].INVPO$+fdel$ ! task 66963
	tmp$=tmp$+rdel$
	Call AddToStr(e$,rstr$,tmp$)  ! put heading into rstr$
	
    Next i
Call AddToStr(e$,rstr$,esdel$)	! end of section
! invoice message section 

Clear List$[]                                                
List$[0] = bsdel$,"InvoiceMsg",fdel$                          
WebStr$ = "Line",fdel$,"Message",fdel$
List$[1] = WebStr$ 
let row=2
let tmpcnt=maxcnt
 let ch_invm=0
 Ch_invm = OpenFile(9955,intco) \ If Ch_invm = -1 Error 42 !  order message file	
 If ch_invm>0
	let invid=invno$
	keyinvm$ = " ",keyinvm$                                      
	keyinvm$ = invid Using "##########"   
	dir = 1                                                    
	mode$ = ">"                                                
	Do ! removes existing message lines                        
              	rec_invm = filegetinvm(e$,Ch_invm,mode$,dir,keyinvm$,invm.)   
		If rec_invm<= 0 Exit Do                                  
		TMP3 = keyinvm$[1,10] \ If TMP3 <> invid Exit Do         
		let  WebStr$ = (invm.messageline using "###"),fdel$ ! message line
		let  webstr$=webstr$,invm.message$,fdel$ ! message
		list$[row]=webstr$
		let row=row+1
		If row > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
	Loop                                                       	
	close #ch_invm
 endif
 Call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string    
 Call AddToStr(e$,rstr$,esdel$) ! end of section
 Call CheckImages()	! look for delivery receipt
 returnstatus=1;message$="OK"
! end invoice message section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	Call SetOutput(e$,rstr$)
else
	include "src/callsuberr.inc"
end try

End Sub !inv det

!!! end invoice detail
!!! ------------------section for orderdetail ------ ! mtg
! action = "ORDDET"
Sub  OrdDet()

Try 
	Dim  dlog$[50]
	
	
	Declare Sub updatelog,errTrap
	Include "src/inc/filerom.inc" ! order message file
    DIM CO$[1],SLS$[3]
	dim 2%,returnstatus, message$[200],orderno$[10],custID$[10]
	Dim arrSales[999],3%,maxrow ! ,cost_lev[3]
	dim 3%,orderid,tmp3,rec_rom
	dim 3%,vendid,rec_vend,vendname$[30],keyvend$[10]
	maxrow=4000
	
	Dim ol. as oInfo
	Dim ols.[maxrow] as oItem
    dim rom. as rom ! order message file
	
	Ch_Vend = OpenFile(2400,intCo) \ If Ch_Vend = -1 Error 42  ! vend

!!!!!!! order detail !!!!!

    Call DXGet("orderno",orderno$)
    !get the specific order detail
      Call DXGet("S_USER.AppID",CO$) ! Company
      Call DXGet("S_USER.Userdef1",SLS$) ! Salesman Number
      Call DXGet("custid",CustID$) ! Customer Number
      LET SLS$="999" ! FOR ALL SALESMAN
          Call OOdet(Val(CO$),Val(SLS$),debug,dlog$,orderno$,CustID$,ol., ols.[],ii,ss,maxRow,cost_lev[], arrSales[])
	  If ss=10000 e$="Not authorized to view this order."  
	  If ss Error 10000                             

  
!! --- start order header section --- 
tmp$=bsdel$+"OrderHeader"+fdel$+rdel$
!tmp$=tmp$+"Order"+fdel$
!tmp$=tmp$+"Header"+fdel$+rdel$
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$
!! order header headings ^M      
tmp$="Order"+fdel$               
tmp$=tmp$+"Order Date"+fdel$     
tmp$=tmp$+"Whse"+fdel$           
tmp$=tmp$+"Truck"+fdel$          
tmp$=tmp$+"Salesman"+fdel$       
tmp$=tmp$+"Total Cost"+fdel$     
!! order header 2nd line^M       
tmp$=tmp$+"Status"+fdel$         
tmp$=tmp$+"Ship Date"+fdel$      
tmp$=tmp$+"Div"+fdel$            
tmp$=tmp$+"Stop"+fdel$           
tmp$=tmp$+"Entered By"+fdel$     
tmp$=tmp$+"Attn"+fdel$           
tmp$=tmp$+"GTM"+fdel$            
!!! order header 3rd line^M      
tmp$=tmp$+"Due Date"+fdel$       
tmp$=tmp$+"Type"+fdel$           
tmp$=tmp$+"Zone"+fdel$           
tmp$=tmp$+"Terms"+fdel$          
tmp$=tmp$+"GP%"+fdel$ 
tmp$=tmp$+"CustPO"+fdel$
tmp$=tmp$+rdel$
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$  
tmp$=orderno$+fdel$                           
tmp$=tmp$+ ol.OrderDate$+fdel$                
tmp$=tmp$+ ol.WHSE$+fdel$                     
tmp$=tmp$+ ol.truck$+fdel$                    
tmp$=tmp$+ ol.slsno$+" "+rtrim$(ol.slsname$)+fdel$
tmp$=tmp$+ ol.tcost$+fdel$                    
!! order header 2nd line                      
tmp$=tmp$+ol.status$+fdel$                    
tmp$=tmp$+ ol.shipdate$+fdel$                 
tmp$=tmp$+ ol.division$+fdel$                 
tmp$=tmp$+ ol.stp$+fdel$                      
tmp$=tmp$+ ol.EnteredBy$+fdel$                
tmp$=tmp$+ ol.attn$+fdel$                     
tmp$=tmp$+ ol.gtm$+fdel$                      
!!! order header 3rd line                     
tmp$=tmp$+ ol.duedate$+fdel$                  
tmp$=tmp$+ ol.Type$+fdel$                     
tmp$=tmp$+ ol.zne$+fdel$                      
tmp$=tmp$+ ol.term$+fdel$                     
tmp$=tmp$+ ol.tgpp$+fdel$
tmp$=tmp$+ ol.CustPO$+fdel$
tmp$=tmp$+ rdel$   
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$                               
Call AddToStr(e$,rstr$,esdel$)	! end of section
!! ---- start order shipto/soldto section ---
tmp$=bsdel$+"OrderAddress"+fdel$+rdel$
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$   

!! order address heading
tmp$="CustomerNo"+fdel$
tmp$=tmp$+"SoldAddress1"+fdel$
tmp$=tmp$+"SoldAddress2"+fdel$
tmp$=tmp$+"SoldAddress3"+fdel$
tmp$=tmp$+"SoldAddress4"+fdel$
tmp$=tmp$+"ShipAddress1"+fdel$
tmp$=tmp$+"ShipAddress2"+fdel$
tmp$=tmp$+"ShipAddress3"+fdel$
tmp$=tmp$+"ShipAddress4"+fdel$
tmp$=tmp$+rdel$
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$
tmp$=ol.custnumber$+fdel$
tmp$=tmp$+ol.SoldAddr1$+fdel$
tmp$=tmp$+ol.SoldAddr2$+fdel$
tmp$=tmp$+ol.SoldAddr3$+fdel$
tmp$=tmp$+ol.SoldAddr4$+fdel$
tmp$=tmp$+ol.S2Addr1$+fdel$
tmp$=tmp$+ol.S2Addr2$+fdel$
tmp$=tmp$+ol.S2Addr3$+fdel$
tmp$=tmp$+ol.S2Addr4$+fdel$
tmp$=tmp$+rdel$
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$
Call AddToStr(e$,rstr$,esdel$)	! end of section

!! ---- end order address section ----
!! order total section
tmp$=bsdel$+"OrderTotal"+fdel$+rdel$
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$
!!! heading line
tmp$="Total Weight"+fdel$ 
tmp$=tmp$+"Subtotal"+fdel$
tmp$=tmp$+"Total Cube"+fdel$
tmp$=tmp$+"Tax"+fdel$
tmp$=tmp$+"Freight"+fdel$
tmp$=tmp$+"Misc"+fdel$
tmp$=tmp$+"Discount"+fdel$
tmp$=tmp$+"Grand Total"+fdel$
tmp$=tmp$+rdel$
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$
!!! second line data
tmp$=ol.totweight$+fdel$ 
tmp$=tmp$+ol.Tresale$+fdel$
tmp$=tmp$+ol.totcube$+fdel$ 
tmp$=tmp$+ol.Tax$+fdel$
tmp$=tmp$+ol.Freight$+fdel$
tmp$=tmp$+ol.misc$+fdel$
tmp$=tmp$+ol.discount$+fdel$
tmp$=tmp$+ol.grandtotal$+fdel$
tmp$=tmp$+rdel$
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$
Call AddToStr(e$,rstr$,esdel$)	! end of section
!! --- end order total section ---
!!! ---- start order line section ----
tmp$=bsdel$+"OrderLine"+fdel$+rdel$
tmp$=tmp$+"Line"+fdel$
tmp$=tmp$+ "Item"+fdel$
tmp$=tmp$+"Description1"+fdel$
tmp$=tmp$+"Order Qty"+fdel$
tmp$=tmp$+"Ship Qty"+fdel$
tmp$=tmp$+"B/O Qty"+fdel$
tmp$=tmp$+"UM"+fdel$
tmp$=tmp$+"Unit Price"+fdel$
tmp$=tmp$+"Extended"+fdel$
tmp$=tmp$+"PO No."+fdel$
tmp$=tmp$+"Ext. Weight"+fdel$
tmp$=tmp$+"GP%"+fdel$
tmp$=tmp$+"Unit Cost"+fdel$
tmp$=tmp$+"Description2"+fdel$
tmp$=tmp$+"LTYPE"+fdel$
tmp$=tmp$+"Vendor"+fdel$
tmp$=tmp$+rdel$
Call AddToStr(e$,rstr$,tmp$)  ! put heading into rstr$
    For i=0 to ii-1
	tmp$=ols.[i].li$+fdel$ ! line # 
	tmp$=tmp$+ols.[i].item$+fdel$ ! item # 
	tmp$=tmp$+ols.[i].desc1$+fdel$  
	tmp$=tmp$+ols.[i].qtyord$+fdel$ 
	tmp$=tmp$+ols.[i].qtyshp$+fdel$ 
	tmp$=tmp$+ols.[i].qtybord$+fdel$ 
	tmp$=tmp$+ols.[i].uom$+fdel$ 
     	tmp$=tmp$+ols.[i].UnitPrice$+"/"+ols.[i].UPUoM$+fdel$
        tmp$=tmp$+ols.[i].Extended$+fdel$
	tmp3$=rtrim$(ols.[i].spo$)
	tmp2$=""
	if tmp3$<>""
		ctr=0
		ctr=pos(tmp3$, = ";") 
		if ctr>1 let tmp2$=tmp3$[1,(ctr-1)]
	else
		tmp2$=rtrim$(ols.[i].spo$)
	endif
	IF ols.[i].LineType$ = "NS" and rtrim$(tmp3$)="Auto" and rtrim$(tmp2$)=""
		let tmp2$=tmp3$         ! 26176                                                  
	endif                                                                     
	tmp$=tmp$+tmp2$+fdel$
       ! tmp$=tmp$+ols.[i].SPO$+fdel$
	tmp$=tmp$+ols.[i].ExtWeight$+fdel$
      	tmp$=tmp$+ols.[i].GPP$+fdel$
      	tmp$=tmp$+ols.[i].UnitCost$+"/"+ols.[i].UCUoM$+fdel$
	tmp$=tmp$+ols.[i].desc2$+fdel$ 
	tmp1$="STK"
	if ols.[i].LineType$<>"ST" let tmp1$="NSTK"
	tmp$=tmp$+tmp1$+fdel$
	!tmp$=tmp$+ols.[i].vendor$+fdel$ ! vendor code
	let vendid=ols.[i].vendor$
	if vendid>999999 let vendid=0
	if vendid<>0
		let keyvend$=vendid using "######"
		search #ch_vend,2,1;keyvend$,rec_vend,e
		if e<>0
			let vendid=0
		else
			read #ch_vend,rec_vend,0;vendname$;
		endif
	endif
	if not(vendid)
		let tmp$=tmp$+""+fdel$
	else
		let tmp$=tmp$+keyvend$+" "+rtrim$(vendname$)+fdel$
	endif
	tmp$=tmp$+rdel$
	Call AddToStr(e$,rstr$,tmp$)  ! put heading into rstr$
    Next i
Call AddToStr(e$,rstr$,esdel$)	! end of section
!! --- end order line section
!! --- begin order total section ---
!! ---- order message section -----
Clear List$[]                                                
List$[0] = bsdel$,"OrderMsg",fdel$                          
WebStr$ = "Line",fdel$,"Message",fdel$
List$[1] = WebStr$ 
let row=2
let tmpcnt=maxcnt
 let ch_rom=0
 Ch_Rom = OpenFile(1968,intco) \ If Ch_Rom = -1 Error 42 !  order message file	
 If ch_rom>0
	let orderid=orderno$
	keyrom$ = " ",keyrom$                                      
	keyrom$ = orderid Using "######"                           
	dir = 1                                                    
	mode$ = ">"                                                
	Do ! removes existing message lines                        
                                              
		rec_rom = filegetrom(e$,Ch_Rom,mode$,dir,keyrom$,rom.)   
		If rec_rom<= 0 Exit Do                                  
		TMP3 = keyrom$[1,6] \ If TMP3 <> orderid Exit Do         
		let  WebStr$ = (rom.messageline using "###"),fdel$ ! message line
		let  webstr$=webstr$,rom.message$,fdel$ ! message
		list$[row]=webstr$
		let row=row+1
		If row > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
	Loop                                                       	
	close #ch_rom
 endif
 Call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string    
 Call AddToStr(e$,rstr$,esdel$) ! end of section

	!
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	Call SetOutput(e$,rstr$)
else
	include "src/callsuberr.inc"
end try

End Sub ! -- mtg
!! order header 1st line
!Call AddToStr(e$,rstr$,"Order"+fdel$+orderno$+fdel$)! +rdel$)
!Call AddToStr(e$,rstr$,"Order Date"+fdel$+ol.OrderDate$+fdel$)! +rdel$)
!Call AddToStr(e$,rstr$,"Whse"+fdel$+ol.WHSE$+fdel$)! +rdel$)
!Call AddToStr(e$,rstr$,"Truck"+fdel$+ol.truck$+fdel$)! +rdel$)
!Call AddToStr(e$,rstr$,"Salesman"+fdel$+ol.slsno$+fdel$+ol.slsname$+fdel$)! +rdel$)
!Call AddToStr(e$,rstr$,"Total Cost"+fdel$+ol.tcost$+fdel$+rdel$)
!! order header 2nd line
!Call AddToStr(e$,rstr$,"Status"+fdel$+ol.status$+fdel$)! +rdel$)
!Call AddToStr(e$,rstr$,"Ship Date"+fdel$+ol.shipdate$+fdel$)! +rdel$)
!Call AddToStr(e$,rstr$,"Div"+fdel$+ol.division$+fdel$)! +rdel$)
!Call AddToStr(e$,rstr$,"Stop"+fdel$+ol.stp$+fdel$)! +rdel$)
!Call AddToStr(e$,rstr$,"Entered By"+fdel$+ol.EnteredBy$+fdel$)! +rdel$)
!Call AddToStr(e$,rstr$,"Attn"+fdel$+ol.attn$+fdel$)! +rdel$)
!Call AddToStr(e$,rstr$,"GTM"+fdel$+ol.gtm$+fdel$+rdel$)
!!! order header 3rd line
!Call AddToStr(e$,rstr$,"Due Date"+fdel$+ol.duedate$+fdel$)! +rdel$)
!Call AddToStr(e$,rstr$,"Type"+fdel$+ol.Type$+fdel$)! +rdel$)
!Call AddToStr(e$,rstr$,"Zone"+fdel$+ol.zne$+fdel$)! +rdel$)
!Call AddToStr(e$,rstr$,"Terms"+fdel$+ol.term$+fdel$)! +rdel$)
!Call AddToStr(e$,rstr$,"GP%"+fdel$+ol.tgpp$+fdel$+rdel$)
!Call AddToStr(e$,rstr$,esdel$)	! end of section
!! ---- end order header section ----

!!! end special price list
!!! endcomment   --- mtg

! begin Order Detail Lines Only
!!! ------------------section for orderdetaillines ------ ! mtg
! action = "ORDDETLINES"
Sub  OrdDetLines()

Try 
	Dim  dlog$[50]
	
	
	Declare Sub updatelog,errTrap
    DIM CO$[1],SLS$[3]
	dim 2%,returnstatus, message$[200],orderno$[10],custID$[10]
	Dim arrSales[999],3%,maxrow ! ,cost_lev[3]
	dim 3%,orderid,tmp3,rec_rom
	dim 3%,vendid,rec_vend,vendname$[30],keyvend$[10]
	maxrow=4000
	
	Dim ol. as oInfo
	Dim ols.[maxrow] as oItem
    
	
	Ch_Vend = OpenFile(2400,intCo) \ If Ch_Vend = -1 Error 42  ! vend

!!!!!!! order detail !!!!!

    Call DXGet("orderno",orderno$)
    !get the specific order detail
      Call DXGet("S_USER.AppID",CO$) ! Company
      Call DXGet("S_USER.Userdef1",SLS$) ! Salesman Number
      Call DXGet("custid",CustID$) ! Customer Number
      LET SLS$="999" ! FOR ALL SALESMAN
          Call OOdet(Val(CO$),Val(SLS$),debug,dlog$,orderno$,CustID$,ol., ols.[],ii,ss,maxRow,cost_lev[], arrSales[])
	  If ss=10000 e$="Not authorized to view this order."  
	  If ss Error 10000                             

 !! ---- start order line section ----
tmp$=bsdel$+"OrderLine"+fdel$+rdel$
tmp$=tmp$+"Line"+fdel$
tmp$=tmp$+ "Item"+fdel$
tmp$=tmp$+"Description1"+fdel$
tmp$=tmp$+"Ship Qty"+fdel$
tmp$=tmp$+"B/O Qty"+fdel$
tmp$=tmp$+"UM"+fdel$
tmp$=tmp$+"Unit Price"+fdel$
tmp$=tmp$+"Extended"+fdel$
tmp$=tmp$+rdel$
Call AddToStr(e$,rstr$,tmp$)  ! put heading into rstr$
    For i=0 to ii-1
	tmp$=ols.[i].li$+fdel$ ! line # 
	tmp$=tmp$+ols.[i].item$+fdel$ ! item # 
	tmp$=tmp$+ols.[i].desc1$+fdel$  
	tmp$=tmp$+ols.[i].qtyshp$+fdel$ 
	tmp$=tmp$+ols.[i].qtybord$+fdel$ 
	tmp$=tmp$+ols.[i].uom$+fdel$ 
    tmp$=tmp$+ols.[i].UnitPrice$+"/"+ols.[i].UPUoM$+fdel$
    tmp$=tmp$+ols.[i].Extended$+fdel$
	tmp$=tmp$+rdel$
	Call AddToStr(e$,rstr$,tmp$)  ! put heading into rstr$
    Next i
Call AddToStr(e$,rstr$,esdel$)	! end of section


	!
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	Call SetOutput(e$,rstr$)
else
	include "src/callsuberr.inc"
end try

End Sub ! OrdDetLines
! end order detail lines only








!External Function YN$ (var)
!	Dim var$[1]
!	Select Case var
!		Case 0
!			var$="N"
!		Case 1
!			var$="Y"
!	End Select
! End Function var$

! Open files used by links -------------------------------------------------
Sub OpenFiles()

  Try
    !
	CTLC = OpenFile(-9999,intCo) \ If CTLC = -1 Error 42 !control
	CUC = OpenFile(-1808,intCo) \ If CUC = -1 Error 42 !cust
	CNC = OpenFile(-720,intCo) \ If CNC = -1 Error 42 !custnotes
	CSPC = OpenFile(1680,intCo) \ if CSPC = -1 Error 42 !custspec
	CSHNC=OpenFile(-9973,intCo) \ if CSHNC = -1 Error 42 !custshnote
	CKWC=OpenFile(9972,intCo) \ if CKWC = -1 Error 42 ! cslkeywrd
	CRCDC=OpenFile(9970,intCo) \ if CRCDC = -1 Error 42 ! ccctype
	CABC = OpenFile(9998,intCo) \ If CABC = -1 Error 42 ! contlist (address book)
	ZNC = OpenFile(-1920,intCo) \ if ZNC = -1 Error 42 ! zone file
	CSLC = OpenFile(2064,IntCo) \ if cslc = -1 Error 42 ! custsls
	CCBT = OpenFile(-9601,IntCo) \ if CCBT = -1 Error 42 ! commission charge back tables
	if P61$[34,34]="Y" ! uses cszone
		CSZ=OpenFile(-9997,intCo) \ if CSZ= -1 let P61$[34,34]="N" ! not found = not used
	Endif
    !
  else
    include "src/callsuberr.inc"
  end try
end sub ! openfiles
!----------------------------------------------------------------------------
Sub BankRoute(e$,Cust$,List$[],CustRec,maxcnt,CTLC,CustChan,cust. as cust)

  ! Creates a list of the customer's Bank routing Info
  ! 
  ! e$         : error message
  ! Cust$      : Cust #
  ! List$[]    : Customer notes list (2)
  ! CustRec	   : Customer Rec
  ! maxcnt     : max # of lines for list$[]
  ! CTLC	   : control file channel
  ! CustChan   : customer file channel
  ! cust.      : customer data
  Try
	dim 1%,dir
	dim 2%,tmpcnt,row
	dim 3%,tmp,rec_cbnk
	dim CustKey$[64],kcbnk1$[50],kcbnk2$[50]

	call GetDelimiters(e$,bsdel$,esdel$,rdel$,fdel$)

	mat read #ctlc,19,50;p9$;
	tmpcnt=maxcnt
	clear List$[]

!
 	List$[0]=bsdel$,"BANKROUTE",fdel$
	!
	WebStr$="ID",fdel$,"Bank Route",fdel$,"Bank Account",fdel$
    List$[1]=WebStr$
	!
	row=2 ! starting row for data
	if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	!
	if p9$[49,49]="Y" ! "flag is ON 
		dim cbnk. as custbank
		dim ncbnk. as custbank
		dim kcbnk1$[50],kcbnk2$[50],3%,rec_cbnk
		ch_cbnk=OpenFile(9605,intCo)
		let cbnk.routing$=" ",cbnk.routing$
		let cbnk.bankid$=" ",cbnk.bankid$
		let custid=cust$
		let kcbnk1$=" ",kcbnk1$
		let kcbnk1$[1,6]=custid using "######"
		search #ch_cbnk,2,1;kcbnk1$,rec_cbnk,e
		if not(e)
			read record #ch_cbnk,rec_cbnk;cbnk.;
		endif
		WebStr$=CustKey$,fdel$ ! Customer key
		WebStr$=WebStr$,RTrim$(cbnk.routing$),fdel$ ! Routing
		WebStr$=WebStr$,RTrim$(cbnk.BankId$),fdel$ ! Account
		!
		List$[row]=WebStr$
		row=row+1
		if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	Else ! flag is N
		WebStr$=CustKey$,fdel$ ! Customer key
        WebStr$=WebStr$,"Option not active",fdel$ ! Routing
		WebStr$=WebStr$,"Not available",fdel$ ! Account
		!
		List$[row]=WebStr$
		row=row+1
		if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
    endif ! flag is Y
	!
	List$[row]=esdel$ ! end of section
  else
    include "src/callsuberr.inc"
  end try
  !
end sub ! BankRoute
! -------------------------------------------------------------------------------------
Sub Taxation(e$,Cust$,List$[],CustRec,maxcnt,intCo,Cust. as cust)
  ! Creates a list of the customer's Taxation Info
  ! 
  ! e$         : error message
  ! Cust$      : Cust #
  ! List$		: list of fields/data
  ! CustRec		: Customer Rec #
  ! maxcnt		: max rows of data
  ! intCo	   : Company ID Number
  ! cust.      : customer data
  Try
   Dim 2%,Row,tmpcnt
   call GetDelimiters(e$,bsdel$,esdel$,rdel$,fdel$)
   tmpcnt=maxcnt
   Clear List$[]
    List$[0]=bsdel$+"TAXATION"+fdel$ ! section name
	WebStr$="Fields"+fdel$
	WebStr$=WebStr$+"Values"+fdel$
	List$[1]=WebStr$  ! put header into rstr$
	row=2 ! starting row for data
	if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
     WebStr$="ID",fdel$,Cust$," ",RTrim$(Cust.Name$),fdel$ ! Customer key
	 List$[row]=WebStr$
	 row=row+1
	 if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	 ! TAX CODE
     let tmpch=-1
     let taxcoded$=gettaxcdd$(tmpch,cust.TaxCode,intco)
     WebStr$="TaxCode"+fdel$+Str$(cust.TaxCode)+" "+rtrim$(taxcoded$)+fdel$	! TaxCode
	 List$[row]=WebStr$
	 row=row+1
	 if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	 ! custtax TYPE
     let tmpch=-1
     let custtaxtyped$=getcusttaxtyd$(tmpch,cust.TaxType,intco)
     WebStr$="TaxType"+fdel$+Str$(cust.TaxType)+" "+rtrim$(custtaxtyped$)+fdel$	! TaxType
	 List$[row]=WebStr$
	 row=row+1
	 if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
     WebStr$="TaxExempt#"+fdel$+RTrim$(cust.TaxExemp$)+fdel$	! TaxExempt
	 List$[row]=WebStr$
	 row=row+1
	 if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
   List$[row]=esdel$ ! end of section
  else
    include "src/callsuberr.inc"
  end try
  !
end sub ! Taxation
! -------------------------------------------------------------------------------------
Sub UDAFlds(e$,Cust$,List$[],CustRec,maxcnt,intCo,Cust. as cust)
  ! Creates a list of the customer's UDA Info - as they can pull from CustMain?
  ! 
  ! e$         : error message
  ! Cust$      : Cust #
  ! List$		: list of fields/data
  ! CustRec		: Customer Rec #
  ! maxcnt		: max rows of data
  ! intCo	   : Company ID Number
  ! cust.      : customer data
  Try
   Dim 2%,Row,tmpcnt
   call GetDelimiters(e$,bsdel$,esdel$,rdel$,fdel$)
   tmpcnt=maxcnt
   Clear List$[]
! -----------------U.D.A. section ---------------------------------------------------------------------
	List$[0]=bsdel$+"CustomerUDA"+fdel$
	WebStr$="FieldDesc"+fdel$
    WebStr$=WebStr$,"UDAValue"+fdel$ 
	List$[1]=WebStr$  ! put header into rstr$
	row=2 ! starting row for data
	if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	If CustRec>0
! evidently the ctlc file is closed somewhere, need a check/open
	try
		mat read #ctlc,67,112;udadesc$;
	else ! "failed
		CTLC = OpenFile(-9999,intCo) \ If CTLC = -1 Error 42 !control
	end try
	! get descriptions of uda fields from control file record 67, fields 9-12
	Mat read #ctlc,67,112;udadesc$;
	WebStr$="ID",fdel$,Cust$," ",RTrim$(Cust.Name$),fdel$ ! Customer key
	 List$[row]=WebStr$
	 row=row+1
	 if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	if udadesc$="" let udadesc$="CUST UDA FLD 1"
	WebStr$=udadesc$+fdel$+RTrim$(cust.UserDefined1$)+fdel$
	List$[row]=WebStr$
	 row=row+1
	 if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	mat read #ctlc,67,126;udadesc$;
	if udadesc$="" let udadesc$="CUST UDA FLD 2"
	WebStr$=udadesc$+fdel$+RTrim$(cust.UserDefined2$)+fdel$
	List$[row]=WebStr$
	 row=row+1
	 if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	mat read #ctlc,67,140;udadesc$;
	if udadesc$="" let udadesc$="CUST UDA FLD 3"
	if custom_customer$="WENELSON"
		WebStr$=udadesc$+fdel$+RTrim$(cust.UserDefined3$[1,10])+fdel$
	else
		WebStr$=udadesc$+fdel$+RTrim$(cust.UserDefined3$)+fdel$
	ENDIF
	List$[row]=WebStr$
	 row=row+1
	 if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	mat read #ctlc,67,154;udadesc$;
	if udadesc$="" let udadesc$="CUST UDA FLD 4"
	WebStr$=udadesc$+fdel$+RTrim$(cust.UserDefined4 using "-----------.####")+fdel$
	List$[row]=WebStr$
	 row=row+1
	 if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
   end if
   List$[row]=esdel$ ! end of section
  else
    include "src/callsuberr.inc"
  end try
  !
end sub ! UDAFlds
! -------------------------------------------------------------------------------------
Sub SndLists()
! send all droplists
 Try
  Dim ZS$[60],ZNDSC$[100],WhName$[30]
  Dim 3%
  tmpcnt=maxcnt
  Clear List$[]
  List$[0]=bsdel$,"SYSFLAGS",fdel$
  Webstr$="MZONE",fdel$,"POSTCUST",fdel$,"ABCFACT",fdel$,"BANKRTE",fdel$,"MSLSM",fdel$
  webstr$=webstr$,"SCTYPE",fdel$,"PRMAST",fdel$,"DELVMAST",fdel$
  List$[1]=webstr$
  WebStr$=P61$[34,34],fdel$,P61$[41,41],fdel$,P61$[42,42],fdel$
  Webstr$=webstr$,P9$[49,49],fdel$,P9$[21,21],fdel$,str$(SCType),fdel$
  let tmp$="N"
  if p61$[100,100]="Y" ! price master flag is on
	!if p60$[33,33]="Y" let tmp$="Y" ! last price perm price in one
	tmp$="Y"
  endif
  webstr$=webstr$,tmp$,fdel$
  let tmp$="N"
  if p61$[109,109]="Y" ! Delivery Customer Master is on
	let tmp$="Y"
  endif
  webstr$=webstr$,tmp$,fdel$
  List$[2]=webstr$
  List$[3]=esdel$
  call addToStr(e$,rstr$,list$[])
!	if action2$="EDIT" or action2$="ADD" or action2$="COPY"
 valact2=0
  !!-!Building section for SSLSM
  chan=openfile(-1824,Intco) ! "SSLSM",intco,"R")
  call fileDropListsslsm(e$,list$[],100,chan)
  call addToStr(e$,rstr$,list$[])
  close #chan
  !!-!Building section for ARTERMCODE
  chan=openfile(-9981,IntCo) ! "ARTERMCODE",intco,"R")
  call fileDropListArTermCode(e$,list$[],100,chan)
  call addToStr(e$,rstr$,list$[])
  close #chan
  !!-!Building section for Statement Type
  call filedroplistcntrlfile(e$,list$[],50,9,16,0,"")   !rcd 50, 9fields of 16 char
  call addToStr(e$,rstr$,list$[])
  !!-!Building section for Credit Code
  call filedroplistcntrlfile(e$,list$[],22,16,16)  !rcd 22, 16fields of 16 char
  call addToStr(e$,rstr$,list$[])
  !!-!Building section for Price Type
  chan=openfile(-752,IntCo) ! "PRTYPEFLE",intco,"R")
  call filedroplistprtypefle(e$,list$[],100,chan)
  call addToStr(e$,rstr$,list$[])
  close #chan
  !!-!Building section for Cust Category
  chan=openfile(-2096,Intco) ! "CUSTCAT",intco,"R")
  call filedroplistcustcat(e$,list$[],100,chan)
  call addToStr(e$,rstr$,list$[])
  close #chan
  !!-!Building section for Division
  chan=openfile(-688,IntCo) ! "DIVIFLE",intco,"R")
  call filedroplistdivifle(e$,list$[],100,chan)
  call addToStr(e$,rstr$,list$[])
  close #chan
  !!-!Building section for TAXCODE
  chan=openfile(-2176,IntCo) ! "TAXCODE",intco,"R")
  !!-!call filedroplisttaxcode(e$,list$[],100,chan)!!-!old call
  call filedroplisttaxcode(e$,list$[],100,chan,"droplisttaxcode","Desc$")
  call addToStr(e$,rstr$,list$[])
  close #chan
  !!-!Building section for CUSTTAX (taxation)
  chan=openfile(-928,IntCo) ! "CUSTTAX",intco,"R")
  call filedroplistcusttax(e$,list$[],100,chan)
  call addToStr(e$,rstr$,list$[])
  close #chan

  !!-!Building section for SVCHGCD
  chan=openfile(-2160,IntCo) ! "SVCHGCD",intco,"R")
  fields$=""
  call filedroplistsvchgcd(e$,list$[],100,chan,"",fields$[],"0")  !"0" parameter adds  0 None to drop list
  call addToStr(e$,rstr$,list$[])
  close #chan

  !!081124  send back most related link drop lists as well
  

  !!-!Building section for ZONEFLE (routing)
  chan=openfile(-1920,Intco) ! "ZONEFLE",intco,"R")
  call filedroplistzonefle(e$,list$[],100,chan)
  call addToStr(e$,rstr$,list$[])
  close #chan

  !!-!Building section for brktbl (commissions) SHOULD BE COMMGRID (HAS NO DLIST)
  ! - DELIVERY CHRG LEVEL
  Clear List$[]
  List$[0]=bsdel$,"DELCHRGLVL",fdel$
  List$[1]="ID",fdel$,"DESC",fdel$
  List$[2]="0",fdel$,"NO LEVEL",fdel$
  List$[3]="1",fdel$,"LEVEL 1",fdel$
  List$[4]="2",fdel$,"LEVEL 2",fdel$
  List$[5]="3",fdel$,"LEVEL 3",fdel$
  List$[6]="4",fdel$,"LEVEL 4",fdel$
  List$[7]="5",fdel$,"LEVEL 5",fdel$
  List$[8]=esdel$
  call addToStr(e$,rstr$,list$[])

  !!-!Building section for WHINFO (default,conswh)
  chan=openfile(-2768,IntCo) ! "WHINFO",intco,"R")
  ! call filedroplistwhinfoz(e$,list$[],100,chan) ! need a zero whse!!
  clear list$[]
  list$[0]=bsdel$,"droplistwhinfo",fdel$
  List$[1]="ID",fdel$,"WhName",fdel$
  List$[2]="0",fdel$,"None",fdel$
  row=3
  for x=0 to 98
	mat read #chan,x,4;whname$;
	tmp$=Trim$(whname$)
	if tmp$<>""
		webstr$=Str$(X+1),fdel$,tmp$,fdel$
		list$[row]=webstr$
		row=row+1 \ If row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	End if
  Next X
  list$[row]=esdel$
  call addToStr(e$,rstr$,list$[])
  close #chan


  !!-!Building section for Acct Mgr COLLAGENT (classification)
  chan=openfile(-3040,IntCo) ! "COLLAGENT",intco,"R")
  call filedroplistcollagent(e$,list$[],100,chan)
  call addToStr(e$,rstr$,list$[])
  close #chan

  !!-!Building section for Sales Area (classification)
  !call filedroplistaddons(e$,list$[],"     0",26,10,10)  !key 0, starting at byte 26, 10fields of 10car
  ! Sales area - even blank is valid!
  AOC=Openfile(-2832,Intco)
  if AOC>0
	LET ZS$=" ",ZS$;ZNDSC$=" ",ZNDSC$                
	LET ZS$="     0"                                 
	SEARCH #AOC,2,1;ZS$,R6,E 
	IF Not(E)                              
		MAT  READ #AOC,R6,26;ZNDSC$;
	Endif
   Else
	ZNDSC$=" ",ZNDSC$
   Endif
	Clear List$[]
	List$[0]=bsdel$,"SALESAREA",FDEL$
	List$[1]="ID",fdel$,"DESC",fdel$
	List$[2]="0",fdel$,"NOT ASSIGNED",fdel$
	row=3
	For x2=1 to 10
		tmp$=ZNDSC$[x2*10-9,x2*10]
		if tmp$="" or tmp$=B$[1,10] let tmp$=Str$(X2)+" no descr."
		List$[row]=Str$(X2),fdel$,tmp$,fdel$
		row=row+1
		If row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	Next x2
	List$[row]=esdel$
	Try Close #AOC Else Rem
    call addToStr(e$,rstr$,list$[])

!!-!Building section for Order Type (general)
  call filedroplistcntrlfile(e$,list$[],62,38,20,0,"","0")   !rcd 62, 34fields of  20char
  call addToStr(e$,rstr$,list$[])
  
  ! PO REQUIRED
  Clear List$[]
  List$[0]=bsdel$,"POREQDLIST",fdel$
  List$[1]="ID",fdel$,"DESC",fdel$
  List$[2]="0",fdel$,"0 No PO-Dupes OK",fdel$
  List$[3]="1",fdel$,"1 PO Required-Dupes OK",fdel$
  List$[4]="2",fdel$,"2 No PO - No Dupes",fdel$
  List$[5]="3",fdel$,"3 PO Required-No Dupes",fdel$
  List$[6]=esdel$
  call addToStr(e$,rstr$,list$[])

  !!-!Building section for groups
  chan=openfile(-9934,IntCo) ! 
  fields$=""
  call filedroplistcustgp(e$,list$[],100,chan,"",fields$[],1,"","0")  !"0" parameter adds  0 None to drop list
  call addToStr(e$,rstr$,list$[])
  close #chan
  ! currency
  clear list$[]
	 list$[0]=bsdel$,"droplistcurrency",fdel$ ! this is using the validation but using the same section heading
	 list$[1]="ID",fdel$,"Desc",fdel$
	if p61$[136,136]<>"Y"
		list$[2]="0",fdel$,"None",fdel$
	else
		list$[2]="0",fdel$,"No Currency Rate",fdel$
	endif
	let row=3
	if p61$[136,136]="Y"
		ch_curr=findchannel()
		tmp$="2/CURRENCY"+str$(Intco)
		ROpen #ch_curr,tmp$
		let keycurr$=" ",keycurr$
		do
			search #ch_curr,3,1;keycurr$,rec_curr,e
			if e<>0 exit do
			read record #ch_curr,rec_curr;curr.;
			let list$[row]=str$(curr.CurrId),fdel$,rtrim$(curr.desc$),fdel$
			let row=row+1
			if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
		loop
		try
			close #ch_curr
		else
			rem
		end try
	endif ! sysflg for currency
	list$[row]=esdel$
	call addtostr(e$,rstr$,list$[])
	endcurrency: ! 
	!  added 08/2017 premier customer 62459
	clear list$[]
	 list$[0]=bsdel$,"droplistpremiercust",fdel$ ! currently 3 hard code selections
	 list$[1]="ID",fdel$,"Desc",fdel$ ! next line is default!
	 List$[2]="N",fdel$,"N - System Calc NOT Premier",fdel$ ! system says do not meet criteria
	 List$[3]="S",fdel$,"S - System Calc Premier",fdel$ ! system says they meet criteria
	 List$[4]="A",fdel$,"A - Always Premier",fdel$
	 ! there is no permanent off detailed in specs
	 List$[5]=esdel$
	 call addToStr(e$,rstr$,list$[])

! endif  !add,edit,copy drop lists
  else
    include "src/callsuberr.inc"
  end try
  !
end sub ! SndLists
! -------------------------------------------------------------------------------------
Sub CustCopy()
! copy from a diff existing Customer
  Try
	! Call dxsave(0,"tmp/custin.txt!") !   Stop
	if custid<=0 Or custid>999999 or fra(Custid)
		returnstatus=0
		message$="New Customer Number Invalid"
		goto CCPDone
	Endif
	If CUR>0 ! already exists
		Returnstatus=0
		Message$="Customer already on file"
		goto CCPDone
	Endif
	Call DxGEt("CustIdFrom",cust$)
	CPcustid=cust$
	cust$=CPcustid using "######"
	cust$ = cust$+"            "
	cust$[7]="" ! "must be 6 only
	mode$="="
	keyno=1
	CUR = filegetcust(e$,CUC,mode$,keyno,cust$,cust.) ! ,0,100000,crc) 
	if CUR < 0 ! let e$="msgcustNOF" \error 10000 !copy from not on file
		Returnstatus=0
		Message$="From Customer not found"
		goto CCPDone
	Endif
	Custsec[0]=CPcustid;custsec[1]=1 ! id & NO ALERT
	call "custsec.dl4",Custsec[],ctlc,userid$,e$,rstr$
	if custsec[0]=-1 ! not allowed
		returnstatus=0
		message$="You do not have access the copy customer"
		goto CCPDone
	Endif
	! AN ALT WAY - END NOW, SEND & MAKE SUBMIT ADD NEW ONE
	! ok - clear sales,etc
	!LET C1[5]=0;C1[10]=0;C1[11]=0;C1[12]=0     
	!LET C3[0]=0;C3[1]=0                        
	!FOR K=0 TO 9                               
	!  IF K<=6 LET C4[K]=0                      
	!  IF K<=5 LET C5[K]=0                      
	!  IF K<=5 LET C10[K]=0                     
	!  LET C6[K]=0                              
	!NEXT K                                     
	!LET CFIN[0]=0;CFIN[1]=0;CFIN[2]=0;CFIN[3]=0
	!LET CFIN[5]=0
	cust.name$=UCase$(cust.Name$) ! make sure
	cust.CustomerCode=custid ! new cust#
	cust.LastOrderDate=0;cust.AvgPayDays=0
	cust.Pays=0;cust.YtdCashDisc=0
	cust.LastInvoiceDate=0;cust.LastPayDate=0
	cust.CurrentArAgeBal=0;cust.UnappliedCredit=0
	cust.AgeArAmt1=0;cust.AgeArAmt2=0;cust.AgeArAmt3=0
	cust.AgeArAmt4=0;cust.LastAmountPaid=0
	cust.UnitsMtd=0;cust.UnitsYtd=0;cust.NetSalesMtd=0
	cust.NetSalesYtd=0;cust.GrProfitMtd=0;cust.GrProfitYtd=0
	cust.SalesTxMtd=0;cust.SlsTxYtd=0;cust.FreightSalesMtd=0
	cust.FreightSalesYtd=0;cust.DiscountMtd=0;cust.DiscountYtd=0
	cust.MiscChrgMtd=0;cust.MiscChgYtd=0;cust.SvcMtd=0
	cust.SvcYtd=0;cust.FreightCostMtd=0;cust.FreightCostYtd=0
	cust.MtdPayments=0;cust.DateEditUps=0;cust.CustomerDiscount=0
	cust.OmahaCPMup=0;cust.InvoiceMtd=0;cust.InvoiceYtd=0
	cust.CreditsMtd=0;cust.CreditsYtd=0;cust.FollowUpDate=0
	cust.OpenOrder=0;cust.AbcOverheadFactor=1;cust.PrepaidMin=0
	cust.AbcScore=0;cust.BankTransit$=b$
	cust.BankAcct$=b$
	cust.s2ndCust$=Custid using "######"
	cust.DateEdit=currdate
	cust.CustomerBillTo=CustId ! pm does this?
	cust.ARPostCust=Custid ! and this
	cust.LpPpGrpCust=Custid
	cust.MASTDELVCUST=Custid ! don't forget this
	cust.LastEditDate=currdate
	cust.DateEditUps=currdate
	cust.ElectronicCust$=b$;cust.PrntMfgPart$=b$
	cust.CPIHOLD$=b$
	If p61$[111,111]="Y" ! CPI
		let cust.CPIHOLD$="Y" 
	endif
	cust.BlankForKey$=b$
    cust.CreditApplicatDate=0
	! cust.SpareReserved$=b$[1,2] ! not all way!
	newcust=0
	let mode$="a";CUR=0  !add new record
	aa=fileupdatecust(e$,CUC,mode$,CUR,cust.,0,0,-1)
	if aa>0 ! new rec successful
		let CUR=aa ! new rec
		clear csls. ! will be NO SALES YET!
		csls.CustomerCode=custid
		write record #CSLC,CUR,0;csls.;
		cust.sRecord=CUR
		write record #CUC,CUR,0;cust.;
		newcust=custid
	Else ! add problem
		returnstatus=0
		message$="ERROR ON ADD "+e$
		goto ccpdone
	Endif
	!!Updating or adding CSZONE record 
	If P61$[34,34]="Y" ! "only if there/used
		try close #CSZ Else Rem  ! close readonly - 
		 CSZ=OpenFile(9997,intCo) \ if CSZ= -1 error 42 ! not found = not used
		CustKey$=Cust$+".000000" ! from id
		CSRec=filegetcszone(e$,CSZ,"=",1,CustKey$,cszone.)
		If CSRec>0 ! exists - copy it
		 Cszone.Customer=custid ! new cust
		 let mode$="a";CSRec=0
		 CSRec=fileupdatecszone(e$,CSZ,mode$,CSREC,CSZone.)
		Endif
	endif
	!!Updating or adding CN customer notes record 
	CustKey$=Cust$ ! from id
	CNRec=filegetcustnotes(e$,CNC,"=",1,CustKey$,cnotes.)
	if CNRec>0 ! from exists - copy it
		let mode$="a";CNRec=0
		CNotes.Customer=custid ! new cust
		CNotes.DateOpened=tim(6) ! add date
		CNotes.PRMCUST$="N" ! no is default on new
		CNRec=fileupdatecustnotes(e$,CNC,mode$,CNRec,CNotes.)
	Endif
	!!Updating or adding CSHN customer ship/pack notes record
	CustKey$=Cust$ ! from id
	
	CSHNRec=filegetcustshnote(e$,CSHNC,"=",1,CustKey$,cshn.)
	if CSHNRec>0 ! exists on from - copy it
		let mode$="a";CSHNRec=0
		Cust$=CustId Using "######" ! set new into cust$
		!!!issue with key not in record, need to use special x version 
		CSHNRec=fileupdatecustshnotex(e$,CSHNC,mode$,CSHNRec,CSHN.,cust$)
		!if CSHNRec<0 error 10000 !error updating or adding record
	Endif
	message$="Record added"  !record saved
	x=0;x1=7  ! no slrec,mode=7 (cust name update)
	CKWKey$=Custid using "######"
	CKWKey$[7]=" " ! so not shiplist
	call "cslkeywrd.dl4",CKWKey$,CUR,x,x1,e$,Intco ! update name keywords
	if newcust<>0 ! it's new - do the alert
		passinfo[0]=1;passinfo[1]=CUR;passinfo[2]=newcust ! alert#,rec,custid
		pchan[1]=ctlc;pchan[2]=CUC;pchan[3]=0;pchan[4]=CSPC ! cntrl,cust,slsm,cspec
		msg$="New Customer Copy from "+Str$(CPCustid)
		call "libalertproc.lib",Passinfo[],Pchan[],msg$
	Endif	

	CCPDone: ! finished
	! Call programdump("tmp/cmlog1in!","") ! dump program vars
  else
    include "src/callsuberr.inc"
  end try
  !
end sub ! CustCopy
! -------------------------------------------------------------------------------------
Sub CustSave()
! save out customer - options checked before calling sub
  Try
	onFile = 0
	clear ofldschg[]
	If CUR<=0 ! new - clear flds not editted/referenced/flagged 
		cust.FaxOrdersYN$=b$
		cust.PersnlGuaranty$=b$
		cust.BankTransit$=b$
		cust.BankAcct$=b$
		cust.BlktPoType$=b$
		cust.BudgDateType$=b$
		cust.ElectronicCust$=b$;cust.PrntMfgPart$=b$
		cust.CPIHOLD$=b$
		cust.BlanketPo$=b$
		cnotes.sOpen$=b$
		cnotes.AVL$=b$
		cnotes.SpareOpen$[1,50]=b$ ! not all way
		onFile = 1
	else
		oldCPIHold$ = cust.CPIHOLD$
	End if
	cust.CustomerCode=custid
	cust.s2ndcust$=custid using "######"
	call DXGet("CustomerName",tmp$)
	if rtrim$(tmp$)=""
		returnstatus=0
		Message$="NAME IS REQUIRED!"
		goto csdone
	Endif
	cust.Name$=UCase$(tmp$),b$
	strgok=chkbadchars(e$,cust.Name$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Customer Name"
		goto csdone
	Endif
	call DXGet("Address1",tmp$)\cust.Addr1$=tmp$,b$
	strgok=chkbadchars(e$,cust.Addr1$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Address 1"
		goto csdone
	Endif
	call DXGet("Address2",tmp$)\cust.Addr2$=tmp$,b$
	strgok=chkbadchars(e$,cust.Addr2$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Address 2"
		goto csdone
	Endif
	call DXGet("City",tmp$)\cust.City$=tmp$,b$
	strgok=chkbadchars(e$,cust.City$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in City"
		goto csdone
	Endif
	call DXGet("State",tmp$)\cust.State$=tmp$,b$
	strgok=chkbadchars(e$,cust.State$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in State"
		goto csdone
	Endif
	call DXGet("ZipCode",tmp$)\cust.Zip4$=tmp$,b$
	call DXGet("Country",tmp$)\cust.Country$=tmp$,b$
	strgok=chkbadchars(e$,cust.Country$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Country"
		goto csdone
	Endif
	call DXGet("DateOpened",tmp$)   !mm/dd/yyyy format
	if tmp$="" let tmp$=tim(9) using "&&","/",tim(10) using "&&","/",tim(16) using "&&&&" !on add, default to today if needed
	tmp$=chkDateFrmt$(tmp$)
	if tmp$[1,1]<"0" and tmp$[1,1]>"9" let tmp$=""
	tmp1$=formatdate2$(tmp$) ! mm/dd/yyyy to yyyymmdd
	tmp2$=tmp1$ ! [3,8]
	call datetojulian(5,tmp2$,tmp3$,e) !convert yyyymmdd to julian ddddd (tmp3$)
	if e=0 let cnotes.dateopened=tmp3$ else cnotes.dateopened=tim(6)
	call DXGet("Phone",tmp$)\cust.Phone$=numericonly$(tmp$),b$   !format to numbers only
	call DXGet("Fax",tmp$)\cnotes.faxnumber$=numericonly$(tmp$),b$ !format to numbers only
	call DXGet("Contact",tmp$)\cust.Contact$=tmp$,b$
	strgok=chkbadchars(e$,cust.Contact$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Contact Name"
		goto csdone
	Endif
	call DXGet("SalesRep",tmp$)		\ x2=tmp$
	if x2<=0 or x2>999 or fra(x2) ! use x2 (temp var)
		returnstatus=0
		message$="Invalid Salesman Code"
		goto csdone
	Endif
	slsmchg=0
	if cur>0 and cust.SalesmanCode>0 and x2<>cust.SalesmanCode
		let slsmchg=9;orgslsm=cust.SalesmanCode
	endif
	cust.SalesmanCode=tmp$
	call DXGet("BillTo",tmp$)
	if Trim$(tmp$)="" let tmp$=Str$(CustID)
	cust.CustomerBillTo=tmp$
	if tmp$<>"" if cust.CustomerBillTo<>cust.CustomerCode
		tmp$=cust.CustomerBillTo using "######"
		TCUR = filegetcust(e$,CUC,"=",1,tmp$,tmpcust.) 
		if TCUR < 0
			returnstatus=0
			message$="Bill to customer # not on file"
			goto CSDone
		Endif
	end if
	call DXGet("PostTo",tmp$)\if p61$[41,41]<>"Y" let tmp$=Str$(cust.CustomerBillTo)
	if trim$(tmp$)="" let tmp$=Str$(cust.CustomerBillTo)
	cust.ARPostCust=tmp$
	if cust.ARPostCust<>cust.CustomerCode and cust.ARPostCust<>Cust.CustomerBillTo
		tmp$=cust.ARPostCust using "######"
		TCUR = filegetcust(e$,CUC,"=",1,tmp$,tmpcust.) 
		if TCUR < 0 
			message$="Post to customer # not on file"
			Returnstatus=0
			goto CSDone
		Else
			if tmpcust.ARPostCust<>cust.ARPostCust ! no multilevel
				returnstatus=0
				message$="Post to Customer posts to Customer "+Str$(tmpcust.ARPostCust)
				goto CSDone
			Endif
		Endif
	end if
	call DXGet("PMCUST",tmp$)
	!if p60$[33,33]<>"Y" or 
	if p61$[100,100]<>"Y"
		let tmp$=Str$(cust.CustomerCode)
		cust.LpPpGrpCust=tmp$
	else
		if trim$(tmp$)="" let tmp$=Str$(cust.CustomerCode)
		cust.LpPpGrpCust=tmp$
		if cust.LpPpGrpCust=0 let cust.LpPpGrpCust=cust.CustomerCode
		if cust.LpPpGrpCust<>cust.CustomerCode and cust.LpPpGrpCust<>0
			tmp$=cust.LpPpGrpCust using "######"
			TCUR = filegetcust(e$,CUC,"=",1,tmp$,tmpcust.) 
			if TCUR < 0 
				message$="Price Master customer # not on file"
				Returnstatus=0
				goto CSDone
			Else
				if tmpcust.LpPpGrpCust=0 let tmpcust.LpPpGrpCust=tmpcust.CustomerCode
				if tmpcust.LpPpGrpCust<>cust.LpPpGrpCust ! no multilevel
					returnstatus=0
					message$="Entered Price Master Cust "+str$(cust.LpPpGrpCust)+" already assigned to another Price Master Cust "+Str$(tmpcust.LpPpGrpCust)
					goto CSDone
				Endif
			Endif
		end if
	endif
!!!! Delivery Cust
	if p61$[109,109]="Y"
		call DXGet("DELIVCUST",tmp$)
		if trim$(tmp$)="" let tmp$=Str$(cust.CustomerCode)
		let cust.MastDelvCust=tmp$
		if cust.MastDelvCust<>cust.CustomerCode
			if cust.MastDelvCUst<>0
				tmp$=cust.MastDelvCust using "######"
				TCUR = filegetcust(e$,CUC,"=",1,tmp$,tmpcust.) 
				if TCUR < 0 
					message$="Delivery Master customer # not on file"
					Returnstatus=0
					goto CSDone
				endif
			else
				let tmp$=Str$(cust.CustomerCode)
				cust.MASTDELVCUST=cust.CustomerCode
			endif
		endif
    else ! deliver master customer is not used default to customer code
		if cust.mastdelvcust<1 or cust.mastdelvcust>999999
			cust.MASTDELVCUST=cust.CustomerCode
		endif
	endif
	
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
If p61$[136,136]="Y"
		call dxget("CURRENCYID",tmp$)\cnotes.currid=tmp$
		if  cnotes.currid<0 or cnotes.currid>7999
			let returnstatus=0
			let Message$="Invalid Currency Id Entered "
			goto csdone:
		endif
		if cnotes.currid<>0
			ch_curr=findchannel()
			tmp$="2/CURRENCY"+str$(Intco)
			ROpen #ch_curr,tmp$
			let keycurr$=cnotes.currid using "####"
			search #ch_curr,2,1;keycurr$,rec_curr,e
			if e<>0
				let returnstatus=0
				let Message$="Currency ID is not on File "
				goto csdone:
			endif
			try
				close #ch_curr
			else
				rem
			end try
		endif
	endif
	call DxGet("taxCode",tmp$)		\  cust.TaxCode=tmp$
	if cust.TaxCode<=0
		returnstatus=0
		message$="Please enter a Tax Code"
		goto csdone
	Endif
	call DxGet("taxType",tmp$)      \  cust.TaxType=tmp$
	if cust.TaxType<=0
		returnstatus=0
		message$="Please enter a Tax Type"
		goto csdone
	Endif
	call DxGet("taxExemp",tmp$)\cust.TaxExemp$=tmp$,b$
	strgok=chkbadchars(e$,cust.TaxExemp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Tax Exempt Number"
		goto csdone
	Endif
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	call dxget("CommServCharge",tmp$) \ Cust.SlsComServiceChar=tmp$
	call DxGet("CommissionGrid",tmp$)\ cust.CommissionGrid=tmp$ 
	call DxGet("CommissionByCategory",tmp$) \ cust.CommissionByCategory=tmp$
	call DxGet("CommCBTable",tmp$) \ cnotes.CommCBTable=tmp$
	! verify commCBTable is on file
	tmp$ = cnotes.CommCBTable using "######"
	search #CCBT,2,1;tmp$,r,e
	if e
		returnstatus=0
		message$="Commission chargeback table not on file!"
		goto CSDONE
	end if
	if cust.CommissionByCategory
		P9$[21,21] = "Y"
	end if
	if p9$[49,49]="Y" 
		dim cbnk. as custbank
		dim ncbnk. as custbank
		dim kcbnk1$[50],kcbnk2$[50],3%,rec_cbnk
		ch_cbnk=OpenFile(9605,intCo)
		let custid=cust$
		let kcbnk1$=" ",kcbnk1$
		let kcbnk1$[1,6]=custid using "######"	
		search #ch_cbnk,2,1;kcbnk1$,rec_cbnk,e
		if not(e)
			read record #ch_cbnk,rec_cbnk;cbnk.;
			let mode$="d"
			rec_cbnk=fileupdatecustbank(e$,ch_cbnk,mode$,rec_cbnk,cbnk.)
			if rec_cbnk<0 ! error 10000 !issue updating,adding or deleting record
				returnstatus=0
				message$="Error Deleting "+Str$(rec_cbnk)+" on customer bank info"
				goto csdone:
			Endif
		endif		
		clear cbnk.
		cbnk.CustId=custid      
		cbnk.Spare1$=" ",cbnk.Spare1$	 
		cbnk.Routing$=" ",cbnk.Routing$	 
		cbnk.BankID$=" ",cbnk.Bankid$ 	 
		cbnk.Name$=" ",cbnk.Name$	 
		cbnk.Email$=" ",cbnk.Email$ 
		cbnk.Spare2$=" ",cbnk.Spare2$	 
		call DxGet("BankAcct",tmp$) 
		cbnk.bankid$=rtrim$(ucase$(tmp$)),b$ 
		call DxGet("BankTransit",tmp$) 
		cbnk.routing$=rtrim$(ucase$(tmp$)),b$
		if rtrim$(cbnk.routing$)="" and rtrim$(cbnk.bankid$)=""
			! do not add no data
		else
			if rtrim$(cbnk.bankid$)=""
				let message$="Customer's Bank Acct Id needs to be entered "
				let returnstatus=0
				goto csdone:
			else
				let mode$="a"
				rec_cbnk=fileupdatecustbank(e$,ch_cbnk,mode$,rec_cbnk,cbnk.)
				if rec_cbnk<0 ! error 10000 !issue updating,adding or deleting record
					returnstatus=0
					message$="Error Adding "+Str$(rec_cbnk)+" on customer bank info"
					goto csdone:
				Endif
			endif
		endif
	else
		cust.BankAcct$=b$ 
		cust.BankTransit$=b$
		cbnk.routing$=b$
		cbnk.bankid$=b$
	endif
	call DxGet("AbcOverheadFactor",tmp$)
	x3=tmp$
	if x3<=0 or x3>=2
		returnstatus=0
		message$="ABC Overhead factor must be greater than 0 and less than 2"
		goto CSDONE
	Endif
	cust.AbcOverheadFactor=tmp$
	call DxGet("AbcScore",tmp$) \ cust.AbcScore=tmp$
	call DxGet("AuthBuyList",tmp$)\cust.AuthBuyList$=tmp$,b$
	if cust.AuthBuyList$<>"Y" let cust.AuthBuyList$="N"
	call DxGet("DefaultWhse",tmp$) \ cust.DefaultWhse=tmp$
	x2=tmp$
	if x2<0 or x2>99 or fra(x2)
		returnstatus=0
		message$="Invalid Default Warehouse"
		goto CSDone
	Endif
	call DxGet("DeliverChgLevel",tmp$)
	X2=tmp$
	if x2<0 or x2>5
		returnstatus=0
		message$="Delivery Level is 0-5"
		goto CSDONE
	Endif
	cust.DeliverChgLevel=tmp$
	call DxGet("sicCode",tmp$) 
	if custom_customer$="WENELSON"
		if len(rtrim$(tmp$))>10
			let returnstatus=0
			let message$="SIC Code may not exceed 10 characters"
			goto csdone
		endif
		If rtrim$(tmp$)<>"" 
			strgok=chkbadchars(e$,tmp$)
			if not(strgok)
				returnstatus=0
				Message$="Invalid Characters in Sic Code"
				goto csdone
			Endif
		endif
		let cust.UserDefined3$[11,20]=rtrim$(tmp$)+b$
	else
		if len(rtrim$(tmp$))>6
			let returnstatus=0
			let message$="SIC Code may not exceed 6 numbers"
			goto csdone	
		endif
		cust.SicCode=tmp$
		if rtrim$(tmp$)<>"0"
			if rtrim$(tmp$)<>"" and cust.SicCode=0
				let returnstatus=0
				let message$="Invalid SIC entered, may only be numbers "
			endif
		endif
	endif
	call DxGet("Priority",tmp$)
	x2=tmp$
	if x2<0 or x2>9 or fra(x2)
		returnstatus=0
		message$="Priority is 0-9"
		goto CSDone
	Endif
	cust.Priority=tmp$
	!call DxGet("CustSalesZone",tmp$)
	
	call DxGet("EccosFlag",tmp$) \ cust.EccosFlag=0 \if tmp$="Y" let cust.Eccosflag=1
	call DxGet("ManualShiplist",tmp$) \ cust.ManualShipList=0 \ if tmp$="Y" let Cust.ManualShiplist=1
	Call DxGet("CustomerDiscount",tmp$) \ cust.CustomerDiscount=tmp$ !%
	Call DxGet("DefaultOrderType",tmp$) \ cust.DefaultOrderType=tmp$
	CAll DxGet("PreventMassDelete",tmp$) \ cust.PreventMassDelete=0\if tmp$="Y" let cust.PreventMassDelete=1
	Call dxget("CustomerGroup",tmp$) \ cust.CustomerGroup=tmp$
!!!!!!!!!!!!!!!!!!!!!!!!!!!!custclass
	 call dxget("AcctMgr",tmp$) \Cust.CollectionAgent=tmp$
	 call dxget("ConsWhse",tmp$)
	 X2=tmp$
	 if x2<0 or x2>99 or fra(x2)
		returnstatus=0
		message$="Invalid Consignment Warehouse"
		goto CSDone
	 Endif
	 !if x2 and X2=cust.DefaultWhse ! can't be same YES it can!
	!	returnstatus=0
	!	message$="Consignment must differ from "+Str$(Cust.DefaultWhse)
	!	goto CSDONE
	 !Endif
	 hwhse=x2
	 If x2 And x2 <> Cust.ConsignWh   
		call ChkCWhse()
		If returnstatus=0 goto CSDone
	 Endif
	 Cust.ConsignWh=hwhse
	 call dxget("SalesArea",tmp$)
	 x2=tmp$
	if x2<0 or x2>10 or fra(x2)
		returnSTATUS=0
		message$="Sales Area is 0-10"
		goto CSDone
	Endif
	cust.CustSalesZone=tmp$
	 call dxget("BGASN",tmp$) \cust.networkasn$=tmp$
	 if cust.networkasn$<>"Y" let cust.networkasn$="N"

!!!!!!!!!!!!!!!!!!!!!!!!!!!custgeneral
	call dxget("APContact",tmp$)\CNotes.ApContact$=tmp$,b$
	strgok=chkbadchars(e$,CNotes.ApContact$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in AP Contact"
		goto csdone
	Endif
	call dxget("APPhone",tmp$)\CNotes.ApPhone$=rtrim$(tmp$)+b$ ! numericonly$(tmp$),b$
	call dxget("PriceonOrder",tmp$)\Cust.PrintOrderPrices=0\if tmp$="Y" let Cust.PrintOrderPrices=1
	call dxget("ShipWithInvoice",tmp$)\Cust.ShpWithInvoiceYN$=tmp$,b$
	call dxget("AllowSubstitute",tmp$)\cust.Substitutes=0\if tmp$="Y" let cust.Substitutes=1
	call dxget("PriceIncNote",tmp$)
	cust.NotifyPriceChg=0\if tmp$="Y" let cust.NotifyPriceChg=1
	if tmp$="F" let cust.NotifyPriceChg=3
	call dxget("BackOrder",tmp$)\cust.BoSAllowedFlag=0\if tmp$="Y" let cust.BoSAllowedFlag=1
	call dxget("DuplicateInv",tmp$)\cust.NoDupInvToPrt$=tmp$,b$
	call dxget("CPIHOLD",tmp$)
	cust.CPIHOLD$="N" \ if tmp$="Y" and p61$[111,111]="Y" let cust.CPIHOLD$="Y"
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  
	!droplists
	call DXGet("Terms",tmp$)		\ x2=tmp$
	if x2<=0 or x2>99 or fra(x2)
		returnstatus=0
		message$="Invalid Terms"
		goto csdone
	Endif
	if cur>0 and cust.terms>0 and x2<>cust.terms
		ofldschg=9;ofldschg[2]=cust.terms
	endif
	cust.terms=x2
	call DXGet("CreditLimit",tmp$)
	x3=tmp$
	if x3<0 or x3>9999999999
		returnstatus=0
		message$="Credit Limit invalid"
		goto CSDone
	Endif
	if cur>0 and cust.CreditLimit>0 and x3<>cust.CreditLimit
		ofldschg=9;ofldschg[3]=cust.CreditLimit
	endif
	cust.CreditLimit=tmp$
	call DXGet("StmtType",tmp$)		\ cust.StmtType=tmp$
	if cust.StmtType<0 or cust.StmtType>9 or fra(cust.StmtType)
		returnstatus=0
		message$="Invalid Statement Type"
		goto csdone
	Endif
	call DXGet("CreditCode",tmp$)	\ cust.CreditCode=tmp$
	if cust.CreditCode<=0 or cust.CreditCode>16 OR FRA(cust.CreditCode)
		returnstatus=0
		message$="Invalid Credit Code"
		goto csdone
	Endif
	call DXGet("CreditCKDays",tmp$)
	x2=tmp$
	if x2<0 or x2>999 or fra(x2)
		returnstatus=0
		message$="Credit Check is 0-999 only"
		goto CSDONE
	Endif
	if cur>0 and cust.CreditCheckDays>0 and x2<>cust.CreditCheckDays
		ofldschg=9;ofldschg[1]=cust.CreditCheckDays
	endif
	cust.CreditCheckDays=tmp$
	call DXGet("SCStatus",tmp$)		\ cust.SCStatus=tmp$
	if cust.SCStatus<0 or cust.SCStatus>99 or fra(cust.SCStatus)
		returnstatus=0
		message$="Invalid S/C Status"
		goto csdone
	Endif
	call DXGet("CreditAppDate",tmp$)   !mm/dd/yyyy format
	if rtrim$(tmp$)="" 
		let cust.CreditApplicatDate=0
	else
		tmp$=chkDateFrmt$(tmp$)
		if tmp$[1,1]<"0" and tmp$[1,1]>"9" let tmp$=""
		tmp1$=formatdate2$(tmp$) ! mm/dd/yyyy to yyyymmdd
		tmp2$=tmp1$ ! [3,8]
		call datetojulian(5,tmp2$,tmp3$,e) !convert yyyymmdd to julian ddddd (tmp3$)
		if e<>0
			let returnstatus=0
			let message$="Invalid Date"
			goto csdone:
		ELSE
			let cust.CreditApplicatDate=tmp1$[3,8]
		endif
	endif
	call DXGet("PORequired",tmp$)
	X2=tmp$
	if x2<0 or x2>3
		returnstatus=0
		message$="PO REQUIRED NOT ON LIST"
		goto CSDone
	Endif
	cust.PoRequiredFlag=tmp$
	call DXGet("PriceType",tmp$)	\ cust.PriceType=tmp$
	call DXGet("CustomerCtgy",tmp$) \ cust.CustomerCategory=tmp$
	call DXGet("Division",tmp$)		\ cust.Division=tmp$
	call DXGet("Residential",tmp$)		
	if tmp$="Y"
	let cnotes.residential=1
	else 
	let cnotes.residential=0
	endif
	call DXGet("Sendemail",tmp$)		
	if tmp$="Y"
	let cnotes.sendemail=1
	else
    let cnotes.sendemail=0
	endif
	call DXGet("Email",tmp$)		\ cnotes.email$=tmp$
	!!-!Filling cust.
	!!cust.LastEditDate=  today   yymmdd  ??

	!!uda section
	call dxget("custudafld1",tmp$)\cust.UserDefined1$=tmp$,b$
	strgok=chkbadchars(e$,cust.UserDefined1$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in UDA Field 1"
		goto csdone
	Endif
	call dxget("custudafld2",tmp$)\cust.UserDefined2$=tmp$,b$
	strgok=chkbadchars(e$,cust.UserDefined2$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in UDA Field 2"
		goto csdone
	Endif
	call dxget("custudafld3",tmp$)
	strgok=chkbadchars(e$,rtrim$(tmp$))
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in UDA Field 3"
		goto csdone
	Endif
	if custom_customer$="WENELSON"
		if len(rtrim$(tmp$))>10
			let returnstatus=0
			message$="UDA Field 3 is only allowed 10 characters"
			goto csdone
		endif
		cust.UserDefined3$[1,10]=rtrim$(tmp$),b$
	else
		cust.UserDefined3$=rtrim$(tmp$),b$
	Endif
	call dxget("custudafld4",tmp$)\cust.UserDefined4=tmp$
	if custom_customer$="OMAHA" ! task#10448 cut punch mu%
		call dxget ("CUTMUPCT",tmp$)
		cust.Omahacpmup=tmp$
		if cust.Omahacpmup<0 
			let message$="Cut Punch Percent may not be less than 0"
			let returnstatus=0
			goto CSDONE
		endif
	endif
	if custom_customer$="WENELSON" ! task#27666 Print MFG Part #
		call dxget ("PRTMFGPART",tmp$)
		if rtrim$(tmp$)="" let tmp$="N"
		let tmp$=rtrim$(ucase$(tmp$))
		
		if tmp$="Y" or tmp$="N"
			cust.PrntMfgPart$=tmp$
		else
			let message$="Print Manufacturer's Part Number must be Y or N "
			let returnstatus=0
			goto CSDONE
		endif
	else
		if rtrim$(cust.prntmfgpart$)="" let cust.PrntMfgPart$="N"
	endif
	!!zone section
	CustKey$=Cust$+".000000" ! use zero shiplist as customer
	mode$="=" ! match only
	Dir=1 ! "cszone dir 1 = Customer No/Shiplist #
	CSRec=0
	mat read #CTLC,61,0;P61$; ! system flags
	if P61$[34,34]="Y" ! uses cszone
		try close #CSZ Else Rem  ! close readonly - 
		CSZ=OpenFile(9997,intCo) \ if CSZ= -1 error 42 ! not found = not used
		
		CSRec=filegetcszone(e$,CSZ,mode$,dir,CustKey$,CSZone.) 

		If CSRec<0 Clear CSZone. 
		CSZone.customer=cust.CustomerCode
		!
		call dxget("leadtime",tmp$) \CSZone.LeadTime=tmp$
		call dxget("sunzone",tmp$)\CSZone.SunZone$=tmp$,b$
		call dxget("sunstop",tmp$)
		x2=tmp$
		if x2<0 or x2>6999
			returnstatus=0
			message$="Stop Number is 1-6999"
			goto CSDone
		Endif
		CSZone.SunStop=tmp$
		call dxget("monzone",tmp$)\CSZone.MonZone$=tmp$,b$
		call dxget("monstop",tmp$)
		x2=tmp$
		if x2<0 or x2>6999
			returnstatus=0
			message$="Stop Number is 1-6999"
			goto CSDone
		Endif
		CSZone.MonStop=tmp$
		call dxget("tuezone",tmp$)\CSZone.TueZone$=tmp$,b$
		call dxget("tuestop",tmp$)
		x2=tmp$
		if x2<0 or x2>6999
			returnstatus=0
			message$="Stop Number is 1-6999"
			goto CSDone
		Endif
		CSZone.TueStop=tmp$
		call dxget("wedzone",tmp$)\CSZone.WedZone$=tmp$,b$
		call dxget("wedstop",tmp$)
		x2=tmp$
		if x2<0 or x2>6999
			returnstatus=0
			message$="Stop Number is 1-6999"
			goto CSDone
		Endif
		CSZone.WedStop=tmp$
		call dxget("thuzone",tmp$)\CSZone.ThuZone$=tmp$,b$
		call dxget("thustop",tmp$)
		x2=tmp$
		if x2<0 or x2>6999
			returnstatus=0
			message$="Stop Number is 1-6999"
			goto CSDone
		Endif
		CSZone.ThuStop=tmp$
		call dxget("frizone",tmp$)\CSZone.FriZone$=tmp$,b$
		call dxget("fristop",tmp$)
		x2=tmp$
		if x2<0 or x2>6999
			returnstatus=0
			message$="Stop Number is 1-6999"
			goto CSDone
		Endif
		CSZone.FriStop=tmp$
		call dxget("satzone",tmp$)\CSZone.SatZone$=tmp$,b$
		call dxget("satstop",tmp$)
		x2=tmp$
		if x2<0 or x2>6999
			returnstatus=0
			message$="Stop Number is 1-6999"
			goto CSDone
		Endif
		CSZone.SatStop=tmp$
	Else ! in cust file - 1 entry
		call dxget("custzone",tmp$)\cust.ZoneNumber$=tmp$,b$
		call dxget("custstop",tmp$)
		x2=tmp$
		if x2<0 or x2>6999
			returnstatus=0
			message$="Stop Number is 1-6999"
			goto CSDone
		Endif
		cust.sStop=tmp$
	endif ! of daily zone
	!
	!!cust notes 1 & 2
	call dxget("note1",tmp$)\CNotes.NotesLine1$=tmp$,b$ ! Note 1
	strgok=chkbadchars(e$,CNotes.NotesLine1$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Note Line 1"
		goto csdone
	Endif
	call dxget("note2",tmp$)\CNotes.NotesLine2$=tmp$,b$ ! Note 2
	strgok=chkbadchars(e$,CNotes.NotesLine2$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Note Line 2"
		goto csdone
	Endif
        !!ship/pack notes
	!Try Close #CSHNC Else rem
	!CSHNC=OpenFile(9973,intCo) \ if CSHNC = -1 Error 42 !custshnote
	CustKey$=Cust$
	mode$="=" ! "match
	Dir=1 ! "custshnotes dir 1 = Customer No
	CSHNrec=filegetcustshnote(e$,CSHNC,mode$,dir,CustKey$,CSHN.) 
	If CSHNRec<0 Clear CSHN.
    Call dxget("shipnote1",tmp$) \ CSHN.ShipNote1$ = rmbadchar$(tmp$),b$ ! Note 1                                                                               
    Call dxget("shipnote2",tmp$) \ CSHN.ShipNote2$ = rmbadchar$(tmp$),b$ ! Note 2                                                                               
    Call dxget("shipnote3",tmp$) \ CSHN.ShipNote3$ = rmbadchar$(tmp$),b$ ! Note 3                                                                               
    Call dxget("packnote1",tmp$) \ CSHN.PickingNote1$ = rmbadchar$(tmp$),b$ ! Note 1                                                                            
    Call dxget("packnote2",tmp$) \ CSHN.PickingNote2$ = rmbadchar$(tmp$),b$ ! Note 2    
	call dxget("custrebatetype",tmp$) \ cust.CustRebateType=tmp$
	if cust.CustRebateType < 0 OR cust.CustRebateType > 2
		returnstatus=0
		message$="Customer rebate type must be between 0 and 2."
		goto CSDone
	end if
	call dxget("custrebatedays",tmp$) \ cust.CustRebateDays=tmp$
	call dxget("custrebategracedays",tmp$) \ cust.CustRebateGrace=tmp$
	call dxget("custrebatepercent",tmp$) \ cust.CustRebatePercent=tmp$
	call dxget("poscustonly",tmp$) ! the variable name is wrong in erp layout.
	if rtrim$(tmp$)="" let tmp$="N" ! it should be fixed upon next file expand.
	let tmp$=rtrim$(ucase$(tmp$))
	if tmp$<>"Y" and tmp$<>"N"
		returnstatus=0
		message$="Point of Sale Customer Only is a Y or N field"
		goto CSDone
	end if
	cust.PrepaidMin=0 \ if tmp$="Y" let cust.PrepaidMin=1 ! POSCustOnly
	clear tmp$
	call dxget("premiercustomer",tmp$) \ tmp$[2]="" ! cut to size?
	if tmp$<>"A" and tmp$<>"S" let tmp$="N"
	CNotes.PRMCUST$=UCase$(tmp$[1,1])
	! done
	cust.LastEditDate=currdate
	cust.KeepDetailSales=1 ! ALWAYS!!
	cust.FaxOrdersYN$=b$ ! not ref'd
	
	cust.BlankForKey$=b$
	! cust.SpareReserved$=b$[1,2] ! not all way
	cust.PermPrcUpdate$=b$
	cnotes.sOpen$=b$
	cnotes.AVL$=b$
	cnotes.SpareOpen$[1,50]=b$ ! not all way
	if not(cust.MultiSlsmList1) or P9$[21,21]<>"Y" let cust.MultiSlsmList1=cust.SalesmanCode
	if not(cust.MultiSlsmList2) or P9$[21,21]<>"Y" let cust.MultiSlsmList2=cust.SalesmanCode
	if not(cust.MultiSlsmList3) or P9$[21,21]<>"Y" let cust.MultiSlsmList3=cust.SalesmanCode
	if not(cust.MultiSlsmList4) or P9$[21,21]<>"Y" let cust.MultiSlsmList4=cust.SalesmanCode
	if not(cust.MultiSlsmList5) or P9$[21,21]<>"Y" let cust.MultiSlsmList5=cust.SalesmanCode
	if not(cust.MultiSlsmList6) or P9$[21,21]<>"Y" let cust.MultiSlsmList6=cust.SalesmanCode
	if not(cust.MultiSlsmList7) or P9$[21,21]<>"Y" let cust.MultiSlsmList7=cust.SalesmanCode
	if not(cust.MultiSlsmList8) or P9$[21,21]<>"Y" let cust.MultiSlsmList8=cust.SalesmanCode
	if not(cust.MultiSlsmList9) or P9$[21,21]<>"Y" let cust.MultiSlsmList9=cust.SalesmanCode
	if not(cust.MultiSlsmList10) or P9$[21,21]<>"Y" let cust.MultiSlsmList10=cust.SalesmanCode
	if not(cust.MultiSlsmList11) or P9$[21,21]<>"Y" let cust.MultiSlsmList11=cust.SalesmanCode
	if not(cust.MultiSlsmList12) or P9$[21,21]<>"Y" let cust.MultiSlsmList12=cust.SalesmanCode
	if not(cust.MultiSlsmList13) or P9$[21,21]<>"Y" let cust.MultiSlsmList13=cust.SalesmanCode
	if not(cust.MultiSlsmList14) or P9$[21,21]<>"Y" let cust.MultiSlsmList14=cust.SalesmanCode
	if not(cust.MultiSlsmList15) or P9$[21,21]<>"Y" let cust.MultiSlsmList15=cust.SalesmanCode
	if not(cust.MultiSlsmList16) or P9$[21,21]<>"Y" let cust.MultiSlsmList16=cust.SalesmanCode
	if not(cust.MultiSlsmList17) or P9$[21,21]<>"Y" let cust.MultiSlsmList17=cust.SalesmanCode
	if not(cust.MultiSlsmList18) or P9$[21,21]<>"Y" let cust.MultiSlsmList18=cust.SalesmanCode
	if not(cust.MultiSlsmList19) or P9$[21,21]<>"Y" let cust.MultiSlsmList19=cust.SalesmanCode
	if not(cust.MultiSlsmList20) or P9$[21,21]<>"Y" let cust.MultiSlsmList20=cust.SalesmanCode
	if not(cust.MultiSlsmList21) or P9$[21,21]<>"Y" let cust.MultiSlsmList21=cust.SalesmanCode
	if cur>0 ! existing - check chgs
		Read record #CUC,CUR,0;tmpcust.;
		! if tmpcust.BlankForKey$="" ! cannot have null
			tmpcust.BlankForKey$=b$ ! it's always blank!
			write record #CUC,CUR,0;tmpcust.;
		!Endif ! always blank it!!
		naedt=0 ! change name/address
		if tmpcust.Name$<>cust.Name$ let naedt=1
		if tmpcust.Addr1$<>cust.Addr1$ let naedt=1
		if tmpcust.Addr2$<>cust.Addr2$ let naedt=1
		if tmpcust.City$<>cust.City$ let naedt=1
		if tmpcust.State$<>Cust.State$ let naedt=1
		if tmpcust.Zip4$<>cust.Zip4$ let naedt=1
		if tmpcust.Country$<>cust.Country$ let naedt=1
		if naedt 
			cust.DateEdit=currdate
			cust.DateEditUps=currdate
		Endif
		if tmpcust.ARPostCust<>Cust.ARPostCust ! chg'd post
			call dxget("UPTARPCUST",tmp$)
			if RTRIM$(UCASE$(tmp$))="Y" ! update to new
				call updtarpost()
			Else
				cust.ARPostCust=tmpcust.ARPostCust ! reset to orig & continue? or stop?
			Endif
		Endif
		! if cust.  ! more?
	Endif
	!!Updating or adding a record
	newcust=0
	cust.Blankforkey$=b$ ! always blank it
	if CUR<0 let mode$="a" else let mode$="c" !add new or change existing record
	IF mode$="a" ! need add'l flds
		cust.DateEditUps=currdate
		cust.DateEdit=currdate
	Endif
	aa=fileupdatecust(e$,CUC,mode$,CUR,cust.,0,0,-1)
	if aa<0 ! a problem
		returnstatus=0
		message$="ERROR ON UPDATE "+Str$(aa)+" "+e$
		goto CSDONE
	Endif
	if mode$="a" and aa>0 ! new rec successful
		let CUR=aa ! new rec
		clear csls.
		csls.CustomerCode=custid
		write record #CSLC,CUR,0;csls.;
		cust.sRecord=CUR ! record record
		write record #CUC,CUR,0;cust.; 
		Newcust=custid
	Endif

	!!Updating or adding CSZONE record 
	If P61$[34,34]="Y" ! "only if there/used
		try close #CSZ Else Rem  ! close readonly - 
		 CSZ=OpenFile(9997,intCo) \ if CSZ= -1 error 42 ! not found = not used
		 if CSRec<0 let mode$="a" else let mode$="c"
		 CSRec=fileupdatecszone(e$,CSZ,mode$,CSREC,CSZone.) 
	endif
	!!Updating or adding CN customer notes record 
	if CNRec<0 let mode$="a" else let mode$="c"
	CNRec=fileupdatecustnotes(e$,CNC,mode$,CNRec,CNotes.)
	!!Updating or adding CSHN customer ship/pack notes record 
        if CSHNRec<0 let mode$="a" else let mode$="c"
	!!!issue with key not in record, need to use special x version 
	CSHNRec=fileupdatecustshnotex(e$,CSHNC,mode$,CSHNRec,CSHN.,cust$)
        !if CSHNRec<0 error 10000 !error updating or adding record
	message$="Record saved"  !record saved
	x=0;x1=7  ! no slrec,mode=7 (cust name update)
	CKWKey$=Custid using "######"
	CKWKey$[7]=" " ! so not shiplist
	call "cslkeywrd.dl4",CKWKey$,CUR,x,x1,e$,Intco ! update name keywords
	if newcust<>0 ! it's new - do the alert
		passinfo[0]=1;passinfo[1]=CUR;passinfo[2]=newcust ! alert#,rec,custid
		pchan[1]=ctlc;pchan[2]=CUC;pchan[3]=0;pchan[4]=CSPC ! cntrl,cust,slsm,cspec
		msg$="New Customer Entry"
		call "libalertproc.lib",Passinfo[],Pchan[],msg$
	else
		If p61$[111,111]="Y" ! CPI - possible credit hold?
			if oldCPIHold$ <> "Y" and cust.CPIHOLD$ = "Y" ! went on hold
				passinfo[0]=56
				passinfo[1]=custid
				pchan[1]=ctlc;pchan[2]=CUC;pchan[3]=0
				msg$=""
				call "libalertproc.lib",Passinfo[],Pchan[],msg$
			end if
		end if
	Endif
	if slsmchg ! slsm chg on existing customer
		clear passinfo[]
		clear pchan[]
		pchan[1]=CTLC;pchan[2]=CUC ! channels
		passinfo[0]=4 ! alert#
		passinfo[1]=cur ! cust rec
		passinfo[2]=custid ! cust id
		passinfo[3]=orgslsm ! orig slsm
		clear msg$ ! used for additional text??
		call "libalertproc.lib",Passinfo[],pchan[],msg$
		slsmchg=0
	endif
	if ofldschg ! one of the 3 flds tracked has changed
		clear passinfo[]
		clear pchan[]
		pchan[1]=CTLC;pchan[2]=CUC ! channels
		passinfo[0]=6 ! alert#
		passinfo[1]=cur ! cust rec
		passinfo[2]=custid ! cust id
		passinfo[3]=ofldschg[1] ! orig ccdays
		passinfo[4]=ofldschg[2] ! orig terms
		passinfo[5]=ofldschg[3] ! orig credlimit
		clear msg$ ! used for additional text??
		call "libalertproc.lib",Passinfo[],pchan[],msg$
		clear ofldschg[]
	endif
	CSDONE: ! finished
  else
    include "src/callsuberr.inc"
  end try
  !
end sub ! CustSave
! -------------------------------------------------------------------------------------
Sub CustDel()
! delete customer (after check)
  Try
	! custdel deletes if not found or non-vital only
	cust$=custid using "######"
	! 1st check if cust is on file
	if custid=0
		returnstatus=0
		Message$="Zero Customer Code not allowed!"
		goto DLCustDone
	Endif
	CUR=filegetcust(e$,CUC,"=",1,cust$,cust.)
	if cur<=0
		returnstatus=0
		message$="Customer "+RTrim$(cust$)+" not on file!"
		goto DLCustDone
	Endif
	Call dxget("DELNVTL",tmp$) ! does non vital prevent deletion Y/N
	tmp$=UCase$(RTrim$(tmp$))
	if tmp$="N" or tmp$="" let X3=0-CUR Else Let X3=CUR
	tmp1$=" ",tmp1$
	tmp1$="" ! clear xfer
	! ok - so it's there now what?
	X2=-11 ! Customer maint flag
	Let X1[0]=IntCo;x1[1]=ctlc;x1[2]=CUC;x1[3]=CNC;e$=""
	call "custdel.dl4",x2,Cust$,X3,tmp1$,x1[],e$,rstr$
	if x2=0 ! ok 
		returnstatus=1
		Message$="OK - Customer "+RTrim$(CustKey$)+" DELETED"
	Else
		Returnstatus=0
		Message$=tmp1$
		if RTrim$(message$)="" let message$=E$
		if x2=9 let message$="NO CUSTOMER RECORD PASSED"
		if message$="" let Message$="CUSTDEL ERROR "+Str$(X2)
	Endif
	DLCustDone: ! finished
  else
    include "src/callsuberr.inc"
  end try
  !
end sub ! CustDel
! -------------------------------------------------------------------------------------
! don't know why or how used section
Sub Whatfor()
!!?? what are dxset's used for ?
!!!!!!!!!!!!!!!!!!!!!!!TAXATION!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
call dxSet("taxCode",Str$(cust.TaxCode))
call dxset("taxType",Str$(cust.TaxType))
call dxset("taxExemp",cust.TaxExemp$)
!!!!!!!!!!!!!!!!!!!!!!!!!!COMMISSION!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
call dxset("CommissionGrid",Str$(cust.CommissionGrid))
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!BANKROUTE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!call dxset("BankAccount",cust.BankAcct$)
! call dxset("BankTransit",cust.BankTransit$)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CLASSIFY!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
call dxset("AbcOverheadFactor",str$(cust.AbcOverheadFactor))
call dxset("AbcScore",str$(cust.AbcScore))
call dxset("AuthBuyList",cust.AuthBuyList$)
call dxset("DefaultWhse",str$(cust.DefaultWhse))
call dxset("DeliverChgLevel",str$(cust.DeliverChgLevel))
If custom_customer$="WENELSON"
	call dxset("sicCode",rtrim$(cust.UserDefined3$[11,20]))
else
	call dxset("sicCode",str$(cust.sicCode))
endif
call dxset("Priority",str$(cust.Priority))
call dxset("CustSalesZone",str$(cust.CustSalesZone))
call dxset("EccosFlag",str$(cust.EccosFlag))
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CUSTOMER GENERAL!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
call dxset("ManualShiplist",str$(cust.ManualShiplist))
call dxset("CustomerDiscount",str$(cust.CustomerDiscount))
call dxset("DefaultOrderType",str$(cust.DefaultOrderType))
call dxset("PreventMassDelete",str$(cust.PreventMassDelete))
call dxset("Contact",cust.Contact$)
call dxset("Phone",cust.Phone$)
End sub
! -------------------------------------------------------------------------------------
Sub updtarpost()
! update orig to new post
  Try
	Dim K60$[60],K61$[60]
	Dim 2%,OPC,PA3[13],POstARCust,CTB
	CBT=cust.CustomerBillTo ! is new one?
	OPC=tmpcust.ARPostCust ! Old Post Cust
	NPC=cust.ARPostCust ! new Post Cost
	! this is Paper Masters routine in mx101
	ARC=OpenFile(1504,IntCo) \ if arc=-1 exit sub
	LET K60$=" ",K60$;K60$[1,6]=OPC USING "######";K60$[7,12]=CBT USING "######"
	SRCHARPOST: REM "saract dir 3=ppppppccccccddddddrrrrrrrrrrtb
	SEARCH #ARC,3,3;K60$,R[60],E \ IF E=2 GOTO ENDARPOST:
	LET X2=K60$[1,6] \ IF X2<>OPC GOTO ENDARPOST:
	LET X2=K60$[7,12] \ IF X2<>CBT GOTO ENDARPOST:
	MAT  READ #ARC,R[60],24;PA3;
	MAT  READ #ARC,R[60],194;POSTARCUST
	LET POSTARCUST=NPC
	MAT  WRITE #ARC,R[60],194;POSTARCUST;
	LET K61$=K60$;K61$[1,6]=NPC USING "######"
	SEARCH #ARC,4,3;K61$,R[60],E ! \ IF E GOSUB ERR_SEARCH:
	SEARCH #ARC,5,3;K60$,R[60],E ! \ IF E GOSUB ERR_SEARCH:
	GOTO SRCHARPOST:
	ENDARPOST: REM end posting ar transaction lookup
	LET K60$=" ",K60$;K60$[1,6]=OPC USING "######"
	SRCHARPOST4: REM "dir 4=pppppprrrrrrrrrrcccccctb
	SEARCH #ARC,3,4;K60$,R[60],E \ IF E=2 GOTO ENDARPD4:
	LET X2=K60$[1,6] \ IF X2<>OPC GOTO ENDARPD4:
	LET X2=K60$[17,22] \ IF X2<>CBT GOTO SRCHARPOST4:
	MAT  READ #ARC,R[60],194;POSTARCUST
	LET POSTARCUST=NPC
	MAT  WRITE #ARC,R[60],194;POSTARCUST;
	LET K61$=K60$;K61$[1,6]=NPC USING "######"
	SEARCH #ARC,4,4;K61$,R[60],E ! \ IF E GOSUB ERR_SEARCH:
	SEARCH #ARC,5,4;K60$,R[60],E ! \ IF E GOSUB ERR_SEARCH:
	GOTO SRCHARPOST4:
	ENDARPD4: REM "done with dir 4 - next dir 5
	LET K60$=" ",K60$;K60$[1,6]=OPC USING "######"
	SRCHARPOST5: REM "dir 5=ppppppddddddrrrrrrrrrrcccccctb
	SEARCH #ARC,3,5;K60$,R[60],E \ IF E=2 GOTO ENDARPD5:
	LET X2=K60$[1,6] \ IF X2<>OPC GOTO ENDARPD5:
	LET X2=K60$[23,28] \ IF X2<>CBT GOTO SRCHARPOST5:
	MAT  READ #ARC,R[60],194;POSTARCUST
	LET POSTARCUST=NPC
	MAT  WRITE #ARC,R[60],194;POSTARCUST;
	LET K61$=K60$;K61$[1,6]=NPC USING "######"
	SEARCH #ARC,4,5;K61$,R[60],E ! \ IF E GOSUB ERR_SEARCH:
	SEARCH #ARC,5,5;K60$,R[60],E ! \ IF E GOSUB ERR_SEARCH:
	GOTO SRCHARPOST5:
	ENDARPD5: REM "that's all folks
	Close #ARC
  else
    include "src/callsuberr.inc"
  end try
  !
end sub ! updtarpost
! -------------------------------------------------------------------------------------
Sub ChkCWhse()
! in is x2(the new conswhse) j1 on pm
  Try
	if x2<0 or x2>99 exit sub
	Dim 2%,H0[12],H5[16]
	if cur>0 ! existing - check chgs
		Read record #CUC,CUR,0;tmpcust.;
	Endif
	if x2=0 and tmpcust.ConsignWh=0 goto CWDone
	READ #ctlc,60,16;x2[1];
	!! if >=x2[1] its consign. <x2[1] it's transfer
	! if x2 if x2<x2[1] ! is into regular whse (CWH)
	!	returnstatus=0
	!	message$="Invalid consignment whse. Must be greater than "+Str$(X2[1]-1)
	!	goto CWDone
	! Endif
	if x2 and x2>0 and x2<100 ! has whse still - see if used already
		if custom_customer$ = "PIEDMONT" goto SkipCustConsignCheck:
		chan=openfile(-816,Intco)
		if chan>0
			read #chan,x2;x2[1];
			IF X2[1] if x2[1]<>custid
				returnstatus=0
				message$="Consignment whse is used by Customer "+Str$(x2[1])
				goto CWDone
			Endif
			close #Chan
		Endif
		SkipCustConsignCheck: !
	Endif
	! now see if used
	if custom_customer$ = "PIEDMONT" goto SkipOrdConsignCheck:
	CHAN=openfile(-1840,IntCo)
	if chan>0
		SearKey$=Custid using "######"
		tmp$=searkey$
		Open_Ord_flag=0
		Do
			search #chan,3,2;searkey$,R,E
			if e exit do
			if searkey$[1,6]<>tmp$ exit do
			mat read #chan,r,0;h0;
			mat read #chan,r,104;H5;
			 IF (H5[7]=16 AND X2=0) OR (H5[7]<>16 AND x2)
				Message$="Please delete or process order"+H0[7]
				LET OPEN_ORD_FLAG=1;returnstatus=0
				exit do
			ENDIF                                                 
		Loop
		Close #Chan
	End if
	if Open_Ord_flag=1 goto CWDone
	SkipOrdConsignCheck: !
	! final - modify 2/conswhse
	chan=openfile(816,Intco)
	if chan>0
		LET X2[2]=0;x2[1]=tmpcust.ConsignWh
		IF x2[1]>0 IF X2=0 WRITE #CHAN,x2[1];x2[2];  ! chg to zero
		! IF x2[1]>0 IF X2>1 IF J1<>x2[1] GOTO L_4960:
		IF x2 WRITE #CHAN,X2;custid; ! write new
		if x2[1]>0 if x2>1 if x2<>x2[1] ! chg to diff
			x2[2]=0
			write #Chan,X2[1],0;x2[2]; ! clear old
		Endif
		Close #chan
	Endif
	CWDone: ! finish
  else
    include "src/callsuberr.inc"
  end try
  !
end sub ! ChkCWhse
! -------------------------------------------------------------------------------------
Sub GetBInfo()
! send budget Info
  Try
	!
	Clear List$[]
	tmpcnt=maxcnt
	if action2$<>"SAVE" ! inq
	  if action2$="EDIT" or action2$="ADD" or action2$="COPY" !need types drop list
		List$[0]=bsdel$,"EXPRTYPE",fdel$ !					doc=Custm-EditRLBudget.doc
		List$[1]="ID",fdel$,"DESC",fdel$
		List$[2]=" ",fdel$,"NOT USED",fdel$
		List$[3]="B",fdel$,"Budget",fdel$
		List$[4]="D",fdel$,"Date",fdel$
		List$[5]="N",fdel$,"Clear Budget",fdel$
		List$[6]=esdel$
		call addToStr(e$,rstr$,list$[])
		Clear List$[]
		List$[0]=bsdel$,"DATETYPE",fdel$
		List$[1]="ID",fdel$,"DESC",fdel$
		List$[2]=" ",fdel$,"NOT USED",fdel$
		List$[3]="M",fdel$,"Monthly",fdel$
		List$[4]="Q",fdel$,"Quarterly",fdel$
		List$[5]="S",fdel$,"Semi-Annual",fdel$
		List$[6]="A",fdel$,"Annual",fdel$
		List$[7]="C",fdel$,"Custom",fdel$
		List$[8]="N",fdel$,"Clear Budget",fdel$
		List$[9]=esdel$
		call addToStr(e$,rstr$,list$[])
      end if ! send droplist
		clear list$[]
		List$[0]=bsdel$,"BUDGETPO",fdel$
		WebStr$="ID",fdel$,"BLKTPO",fdel$,"BUDGDOL",fdel$
		webstr$=webstr$,"BUDGUSED",fdel$,"EXPRTYPE",fdel$
		webstr$=webstr$,"DATETYPE",fdel$,"STARTDT",fdel$,"ENDDATE",fdel$
		List$[1]=webstr$
		row=2
		webstr$=Str$(Custid),fdel$,RTrim$(cust.BlanketPo$),fdel$
		webstr$=webstr$,LTrim$(cust.Budget using QMask$),fdel$
		webstr$=webstr$,LTrim$(cust.BudgetUsed using QMask$),fdel$
		webstr$=webstr$,cust.BlktPoType$,fdel$,cust.BudgDateType$,fdel$
		if cust.BlktPoType$="D"
			tmp$="0"
			if cust.DateBPStart>0 let tmp$=PDate$(cust.DateBPStart)
			webstr$=webstr$,RTrim$(tmp$),fdel$
			tmp$="0"
			if cust.DateBPEnd>0 let tmp$=PDate$(cust.DateBPEnd)
			webstr$=webstr$,RTrim$(tmp$),fdel$
		Else ! not date based
			tmp$="0"
			webstr$=webstr$,RTrim$(tmp$),fdel$,RTrim$(tmp$),fdel$
		Endif
		List$[row]=WebStr$
		row=row+1
		!
		if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
		List$[row]=esdel$ ! end of section
		call AddToStr(e$,rstr$,List$[])
	Else ! save it											doc=Custm-SubmitBudget.doc
		Close #CUC ! close read-only
		CUC=Openfile(1808,Intco) \ if cuc=-1 error 42
		Call Dxget("BLKTPO",tmp$)
		cust.BlanketPo$=tmp$+B$
		Call DxGet("BUDGDOL",tmp$)
		x3=tmp$
		if x3<0 or x3>999999999 
			Returnstatus=0
			Message$="INVALID BUDGET"
			Exit sub
		Endif
		If X3=0 and cust.Budget<>0 ! cleared it
			let clrdbudg=1
		Endif
		cust.budget=X3
		! Call DxGet("BUDGUSED",tmp$) ! is this returned?
		if clrdbudg let cust.BudgetUsed=0
		Call DxGet("EPRTYPE",tmp$)
		tmp$=UCASE$(RTrim$(tmp$))
		if TMP$<>"" AND tmp$<>"B" AND TMP$<>"D" AND TMP$<>"N"
			ReturnStatus=0
			Message$="INVALID EXPIRE TYPE"
			exit sub
		Endif
		cust.BlktPoType$=tmp$
		if cust.BlktPoType$="B" and clrdbudg=1 ! cleared budget
			cust.BudgetUsed=0
			cust.BlktPoType$="N" ! to clear all
		Endif
		Call DxGet("DATETYPE",tmp$)
		tmp$=UCASE$(RTrim$(tmp$))
		if tmp$<>"" AND TMP$<>"M" AND TMP$<>"Q" AND TMP$<>"S" AND TMP$<>"A" AND TMP$<>"C" AND TMP$<>"N"
			ReturnStatus=0
			Message$="INVALID DATE TYPE"
			exit sub
		Endif
		cust.BudgDateType$=tmp$
		Call DxGet("STARTDT",tmp$)
		tmp$=chkDateFrmt$(tmp$)
		if tmp$[1,1]<"0" and tmp$[1,1]>"9" let tmp$=""
		tmp1$=formatdate2$(tmp$) ! mm/dd/yyyy to yyyymmdd
		cust.DateBPStart=tmp1$[3,8] ! drop to yymmdd
		Call DxGet("ENDDATE",tmp$)
		tmp$=chkDateFrmt$(tmp$)
		if tmp$[1,1]<"0" and tmp$[1,1]>"9" let tmp$=""
		tmp1$=formatdate2$(tmp$) ! mm/dd/yyyy to yyyymmdd
		cust.DateBPEnd=tmp1$[3,8] ! drop to yymmdd
		if cust.BlktPoType$="" or cust.BlktPoType$="N" ! not used - clear budget fields
			cust.BlanketPo$=B$
			cust.Budget=0;cust.BudgetUsed=0
			cust.BlktPoType$=b$
			cust.BudgDateType$=b$
			cust.DateBPStart=0;cust.DateBPEnd=0
		Endif
		if cust.BudgDateType$="" or cust.BudgDateType$="N" Or cust.BlktPoType$="B"
			cust.DateBPStart=0;cust.DateBPEnd=0 ! not date type
			if cust.BudgDateType$="N" ! clear ALL
				cust.BlanketPo$=B$
				cust.Budget=0;cust.BudgetUsed=0
				cust.BlktPoType$=b$
			Endif
			cust.BudgDateType$=b$
		Endif
		Write Record #CUC,CUR,0;cust.;
	Endif ! of edit
  else
    include "src/callsuberr.inc"
  end try
  !
end sub ! GetBInfo
! -------------------------------------------------------------------------------------
Function chkDateFrmt$(DIn$)
! see if date in is MM/DD/YY or MM/DD/YYYY
! if not make it MM/DD/YYYY
Try
	Dim DOut$[10],X$[20]
	Dim 1%,Mth,Day
	Dim 3%,Yr
	If DIn$[1,2]="00" or UCase$(DIn$[1,4])="NONE" or DIn$="0"
	  Let DOut$=UCase$(DIn$)
	  Exit Function DOut$ ! no reformat - send back as is
	Endif
	Mth=DIn$[1,2];Day=Din$[4,5];Yr=DIn$[7]
	if Din$[2,2]="/" or DIn$[2,2]="-" ! 1 digit month
	  Let Mth=DIn$[1,1]
	  If DIn$[4,4]="/" or DIn$[4,4]="-" ! 1 digit day
	     Let Day=DIn$[3,3]
		 Let Yr=DIn$[5]
	  Else
	     Let Day=Din$[3,4] ! try 2 digit
		 Let Yr=DIn$[6]
	  Endif
	Endif
	X$=Mth Using "&&"
	X$[3,4]=Day Using "&&"
	If Yr>1000 ! 4
		X$[5]=Yr Using "&&&&"
	Else ! 2 digit
		If YR<67 let yr=2000+yr Else Let Yr=yr+1900
		X$[5]=Yr Using "####"
	Endif
	Dout$=X$[1,2]+"/"+X$[3,4]+"/"+X$[5]
 else
    include "src/callsuberr.inc"
  end try
end Function DOut$ ! chkDateFrmt$
! 
!--------------------------------------------------------------------
Sub MSlsm()
! multiple slsm - 1 per Prodctgy
  Try
    ! P9$[21,21]="Y" ! FOR TEST / STARTUP ONLY!!!
	if cust.CommissionByCategory
		p9$[21,21] = "Y"
	end if
	if p9$[21,21]<>"Y"
		returnstatus=0
		message$="Option is not active!"
		exit sub
	Endif
	Dim PCDesc$[24]
	Dim 1%,S0[20],SLSM[999]
	Dim 3%
	PSC=Openfile(-1984,IntCo) \ if PSC=-1 Error 42
	if action2$<>"SAVE" ! it's inquiry/edit
		Clear List$[]
		List$[0]=bsdel$,"SLSMCTGY",fdel$
		List$[1]="PCTGY",fdel$,"SLSM",fdel$
		! let's use matrix to use a for/next
		Mat read #CUC,CUR,502;s0;
		tmpch=-1;x2=cust.SalesmanCode ! not open
		let slsmname$=getslsmname$(tmpch,x2,intco)
		List$[2]="MAIN",fdel$,Str$(cust.SalesmanCode)," ",RTrim$(slsmname$),fdel$ ! main cust slsm
		row=3
		for x=1 to 20
			if s0[x]=0 let s0[x]=cust.SalesmanCode
			Read #PSC,X,0;PCDesc$;
			tmp$=RTrim$(PCDesc$)
			if tmp$="" let tmp$="Product Ctgy "+Str$(X)
			Webstr$=Str$(X)," ",tmp$,fdel$
			tmpch=-1 ! not open
			let slsmname$=getslsmname$(tmpch,S0[x],intco)
			webstr$=webstr$,Str$(S0[x])
			if action2$<>"EDIT" ! send name too
				webstr$=webstr$," ",rtrim$(slsmname$)
			Endif
			webstr$=Webstr$,fdel$
			List$[row]=webstr$
			row=row+1
		Next X
		List$[row]=esdel$
		call AddToStr(e$,rstr$,List$[])
	Else ! it's save										doc=Custm-SubmitMSlsm.doc
		Close #CUC ! close read-only
		CUC=OpenFile(1808,IntCo) \ if cuc=-1 Error 42
		Mat read #CUC,CUR,502;s0
		for x=1 to 20
			call dxget("SLSM"+Str$(X),tmp$)
			x2=tmp$
			if x2<=0 or x2>999 or fra(x2) let x2=cust.SalesmanCode
			S0[x]=x2
		Next X
		! a check of # diff ones entered
		Slsm[cust.SalesmanCode]=1 ! always main
		For X=1 to 20
			slsm[s0[x]]=1 ! Flag selected ones
		Next x
		ctr=0
		for x=1 to 999
			if slsm[x] let ctr=ctr+1
		Next x
		if ctr>5
			returnstatus=0
			message$="A maximum of 5 different Slsm is allowed!"
			exit sub
		Endif
		Mat write #CUC,CUR,502;s0;
	Endif
  else
    include "src/callsuberr.inc"
  end try
  !
end sub ! MSlsm
! -------------------------------------------------------------------------------------
!--------------------------------------------------------------------
Sub ProcessCommissionSplits()
  Try
	Dim CSMKey$[14]
	Dim 1%,CSType[4,3]
	Dim 2%,Cs0,Cs1[4],CSPCT[4,3],csstdate[4,3],csedate[4,3],cs2
	dim 3%

	if action2$ = "GET"
		CSMC=OpenFile(-9969,intCo) \ if CSMC = -1 Let SCType = 0
	else
		CSMC=OpenFile(9969,intCo) \ if CSMC = -1 Let SCType = 0
	end if
	if SCType = 0
		returnstatus=0
		message$="Option is not active!"
		exit sub
	Endif
	
	call DXGet("SalesRep",tmp$) \ cust.SalesmanCode=tmp$

	CSMKey$=custID using "######"
	CSMKey$[7]=" " ! "so knows it not shiplist
	SEARCH #CSMC,2,1;CSMKey$,CSMRec,E \ if e>1 error 11000
	CSMnewRec = 0 \ if e CSMnewRec = 1
	if not(CSMnewRec)
		mat read #CSMC,CSMRec,4;cs1
		mat read #CSMC,CSMRec,184;cspct
		mat read #CSMC,CSMRec,268;cstype ! leave locked if open rw
	end if
	if cs1[0] <= 0 or cs1[0] <> cust.SalesmanCode
		cs1[0] = cust.SalesmanCode
	end if
	select case action2$
		case "CHECK" ! check to see if a customer level split exists
			clear List$[]
			list$[0]=bsdel$+"CUSTSPLITS"+fdel$
			list$[1]="Exists"+fdel$
			tmp$ = "0" \ if not(CSMnewRec) tmp$ = "1"
			list$[2]=tmp$+fdel$
			list$[3]=esdel$
			call AddToStr(e$,rstr$,List$[])
		case "GET" ! it's doc=Custm-GetCSplit.doc
			!if CSPCT[0,0] <= 0 and SCType <> 2 CSPCT[0,0] = 100
			Clear List$[]
			List$[0]=bsdel$,"CUSTSPLITS",fdel$
			webstr$="SCType"+fdel$
			for i = 0 to 4
				webstr$=webstr$+"SplitRep"+str$(i)+fdel$
			next i
			for i = 0 to 4
				webstr$=webstr$+"Split"+str$(i)+fdel$
			next i
			for i = 0 to 4
				webstr$=webstr$+"SplitPct"+str$(i)+fdel$
			next i
			List$[1]=webstr$
			webstr$=str$(SCTYPE)+fdel$
			for i = 0 to 4
				webstr$=webstr$+str$(cs1[i])+fdel$
			next i
			for i = 0 to 4
				if sctype = 2
					webstr$=webstr$+str$(cstype[i,0])+fdel$
				else
					webstr$=webstr$+str$(cspct[i,0])+fdel$
				end if
			next i
			for i = 0 to 4
				if sctype = 2
					webstr$=webstr$+str$(cspct[i,0])+fdel$
				else
					webstr$=webstr$+"0"+fdel$
				end if
			next i
			list$[2]=webstr$
			List$[3]=esdel$
			call AddToStr(e$,rstr$,List$[])
		case "SAVE" ! doc=Custm-SubmitCSplit.doc
			! OK - let's load 'em up and validate
			totPercent = 0
			for i = 0 to 4
				call dxget("SplitRep"+str$(i), tmp$) \ cs1[i] = tmp$
				if sctype = 2
					call dxget("Split"+str$(i), tmp$) \ cstype[i,0] = tmp$
					call dxget("SplitPct"+str$(i), tmp$) \ cspct[i,0] = tmp$
				else
					call dxget("Split"+str$(i), tmp$) \ cspct[i,0] = tmp$
					cstype[i,0] = 0
				end if
				if cs1[i]
					for j = 0 to i - 1
						if cs1[i] = cs1[j]
							returnstatus = 0
							message$ = "Same salesrep on more than 1 line!"
							exit sub
						end if
					next j
				else
					csplt[i,0] = 0
					cspct[i,0] = 0
				end if
				totPercent = totPercent + cspct[i,0]
			next i
			if cs1[0] <> cust.SalesmanCode
				returnstatus = 0
				message$ = "Main salesrep does not match first rep in splits!"
				exit sub
			end if
			if sctype = 1 and totPercent <> 100
				returnstatus = 0
				message$ = "Total split percentage <> 100%!"
				exit sub
			end if
			if sctype = 3 and totPercent > 100
				returnstatus = 0
				message$ = "Total split percentage > 100%!"
				exit sub
			end if
			if CSMnewRec ! new rec
				e=2 \ search #CSMC,1,0;CSMKey$,CSMRec,e
				if e error 11000
				search #CSMC,4,1;CSMKey$,CSMRec,e
				if e error 11000
				cs0 = custid
				mat write #CSMC,CSMRec,0;cs0
				mat write #CSMC,CSMRec,4;cs1
				mat write #CSMC,CSMRec,24;cssdate
				mat write #CSMC,CSMRec,104;csedate
				mat write #CSMC,CSMRec,184;cspct
				mat write #CSMC,CSMRec,264;cs2
				mat write #CSMC,CSMRec,268;cstype;
			else
				mat write #CSMC,CSMRec,4;cs1
				mat write #CSMC,CSMRec,184;cspct
				mat write #CSMC,CSMRec,268;cstype;
			end if
		case "DELETE" ! doc=Custm-DeleteCSplit.doc
			if not(CSMnewRec)
				search #CSMC,5,1;CSMKey$,CSMRec,e
				if e error 11000
				let e=3\search #CSMC,1,0;CSMKey$,CSMRec,e
				if e error 11000
			end if
		case else
			returnstatus = 0
			message$ = "Unknown action2: "+action2$+"!"
	end select
  else
    include "src/callsuberr.inc"
  end try
  !
end sub ! ProcessCommissionSplits
! -------------------------------------------------------------------------------------
!----------------------------------------
Sub CheckImages()
Try 
	Dim keyvar$[50],itype$[2],image$[255],xdate$[10],image$[100]
	!
	clear list$[]
	List$[0]=bsdel$,"Images",fdel$
	List$[1]="keyvar",fdel$,"type",fdel$
	row=2
	!
	Try
		itype$="DR"	! scanned delivery receipt
		mode=0		! just check for existance
		keyvar$[1,8]=Val(il.order$) using "DR######"
		keyvar$[9,14]=Val(il.custnumber$) using "######"
		tmp$=il.orderdate$ ! using "&&&&&&"
		tmp1$=formatdate2$(tmp$) ! mm/dd/yyyy to yyyymmdd
		Call DatetoJulian(1,tmp1$[3,8],xdate$,e)
		if not(e) keyvar$[15,20]=Val(xdate$) using "######"	! julian orddate
		!
		!
		Call GetImage(e$, intCo, IType$, mode, keyvar$, image$)
		!
		if image$
			list$[row]=keyvar$,fdel$,"Del Recpt",fdel$
			row=row+1
		end if
		! additional docs
		!                                                 
		itype$ = "OS" ! scanned order source              
		mode = 0 ! just check for existance               
		keyvar$[1,8] = Val(il.order$) using "OS######"       
		keyvar$[9] = ""                                   
		!                                                 
		call getimage(e$,intco,itype$,mode,keyvar$,image$)
		!                                                 
		if image$                                         
		  list$[row] = keyvar$,fdel$,"Order SRC",fdel$    
		  row = row + 1                                   
		end if                                            
		!     
		itype$="PD"	! scanned packing slips
		mode=0		! just check for existance
		keyvar$[1,8]=Val(il.order$) using "PD######"
		keyvar$[9,14]=Val(il.custnumber$) using "######"
		tmp$=il.orderdate$ ! using "&&&&&&"
		Call DatetoJulian(1,tmp$,xdate$,e)
		if not(e) keyvar$[15,20]=Val(xdate$) using "######"	! julian orddate
		!
		!
		Call GetImage(e$, intCo, IType$, mode, keyvar$, image$)
		!
		if image$
			list$[row]=keyvar$,fdel$,"Pick Docs",fdel$
			row=row+1
		end if
	Else
		!
	End Try
	!
	! add additional doc type here and add to list$ if needed
	!
	Call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
else
	include "src/callsuberr.inc"! ERROR 
end try
end sub !  checkimage
!----------------------------------------
!!! ------------------section for customer consignment------ ! mtg
! action = "splist"
Sub CustConsInv()
Try 
	Dim  dlog$[50]
	dim 2%,returnstatus, message$[200],WhName$[30]
	returnstatus=1
	message$="OK"
	
	
	Declare Sub updatelog,errTrap
	Ch_Prod = OpenFile(1792,intCo) \ If Ch_Prod = -1 Error 42 ! open product file
	ch_prlot=OpenFile(-2528,intCo) \ If Ch_prlot = -1 Error 42 !sprodlot file! open product lot file
	
	Call DXGet("custid",cust$) \ custid=cust$
	cust$=custid using "######"
	custkey$=cust$
	mode$="="
	keyno=1
	CUR = filegetcust(e$,CUC,mode$,keyno,cust$,cust.)
	if CUR<=0 ! "not found
		Clear cust.
		Returnstatus=0
		Message$="Customer Not Found"
		goto EndCustConsInv1:
	end if
	if cust.ConsignWh<=0 or cust.ConsignWh>99
		let returnstatus=0
		message$="Customer Not Assigned Warehouse"
		goto EndCustConsInv1:
	endif
	 !!-!Building section for WHINFO (default,conswh)
	 Try 
		chan=openfile(-2768,IntCo) ! "WHINFO",intco,"R")
		let x=(cust.ConsignWh-1)
		mat read #chan,x,4;whname$;
		close #chan
	else
		let whname$=" ",whname$
	end try
	EndCustConsInv1: ! 
	clear list$[]
	LIST$[0]=bsdel$+"CustConsignment"+fdel$
	LIST$[1]="CustId",fdel$,"Customer Name",fdel$,"WhId",fdel$,"WhseName",fdel$
	let row=2
	if returnstatus<>0
		webstr$=str$(custid),fdel$
		webstr$=webstr$,rtrim$(cust.name$),fdel$
		webstr$=webstr$,str$(cust.ConsignWh),fdel$
		webstr$=webstr$,rtrim$(whname$),fdel$
		list$[2]=webstr$
		row=3
	endif
	let list$[row]=esdel$
	Call AddToStr(e$,rstr$,List$[])
    clear list$[]
	LIST$[0]=bsdel$+"ConsignmentInventory"+fdel$
	let webstr$="Product",fdel$
	let webstr$=webstr$,"Description",fdel$
	let webstr$=webstr$,"Qty Received",fdel$
	let webstr$=webstr$,"Qty Used ",fdel$
	let webstr$=webstr$,"Qty Available",fdel$
	LIST$[1]=webstr$
	ctr = 2
	if returnstatus<>0
		tmpcnt = maxcnt 
		let keyprlot$=" ",keyprlot$
		let keyprlot$[1,2]=cust.ConsignWh using "##"
		do
			search #ch_prlot,3,3;keyprlot$,rec_prlot,e
			if e<>0 exit dO
			let tmp3=keyprlot$[1,2]
			if tmp3<>cust.ConsignWh exit DO
			read record #ch_prlot,rec_prlot;prlot.;
			let keyprod$=" ",keyprod$
			let keyprod$[1,12]=prlot.ProdCode$
			rec_prod=filegetprod(e$,ch_prod,"=",1,KeyProd$,PRod.) ! product mode=2 dir=1
			If rec_prod>=0 ! Product recordfound
				let webstr$=rtrim$(prlot.prodcode$),fdel$
				let webstr$=webstr$,rtrim$(prod.Desc1$),fdel$	
				X3=0
				LET CNVTA=PRLOT.QtyRcvd!
				CNVTU[0] = 0;CNVTU[1] = prod.UMStkDefault;CNVTU[2] = 1    
     			If CNVTA <> 0                                           
					X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,prod.)   
				End If                                                  
				WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty received
				X3=0
				LET CNVTA=prlot.qtyused
				CNVTU[0] = 0;CNVTU[1] = prod.UMStkDefault;CNVTU[2] = 1    
     			If CNVTA <> 0                                           
					X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,prod.)   
				End If                                                  
				WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty used
				! qty avail = 
				x3=0
				let cnvta=PRLOT.QtyRcvd-prlot.qtyused-prlot.QtyAlloc
				CNVTU[0] = 0;CNVTU[1] = prod.UMStkDefault;CNVTU[2] = 1    
     			If CNVTA <> 0                                           
					X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,prod.)   
				End If                                                  
				WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! qty available
				list$[ctr]=webstr$
				ctr=ctr+1
				If ctr > tmpcnt Let tmpcnt = expandarray(e$,List$[])
			endif
		loop
	endif
	list$[ctr]=esdel$ 
    Call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string    
        
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	Call SetOutput(e$,rstr$)
else
	include "src/callsuberr.inc"
end try

End Sub ! -- mtg
!-----------------------------------------------------------------------------
Sub UpdateWebCust()
 Try
	Dim blank$[255]
	blank$=" ",blank$

	Try Close #CUC  Else Rem
	Try Close #CNC  Else rem
	CUC = OpenFile(1808,intCo) \ If CUC = -1 Error 42 !cust
	CNC = OpenFile(720,intCo) \ If CNC = -1 Error 42 !custnotes

	ReturnStatus=1
	Message$="OK"

	Call DXGet("CUSTID",tmp$)
	X2=tmp$
	Cust$=X2 Using "######"

	! Get customer record
	CUR = filegetcust(e$,CUC,"=",1,cust$,cust.)
	If cur<0
		ReturnStatus=0
		Message$="CUSTOMER "+Cust$+" NOT FOUND"

	else	! Found Customer record
		!
		! Get custnotes record
		CNRec = filegetcustnotes(e$,CNC,"=",1,Cust$,cnotes.)
		If CNRec < 0
			returnstatus=0
			message$="NOTES RECORD IS MISSING"
			Exit Sub
		End If

		! cust fields
		call dxget("NEWNAME",tmp$)
		if Rtrim$(tmp$)="" ! empty send error
			returnstatus=0
			message$="NAME CANNOT BE BLANK"
			Exit Sub
		End If
		CUST.NAME$=UCase$(RTrim$(tmp$))+Blank$

		Call dxget("NEWADDR1",tmp$)
		if Rtrim$(tmp$)="" ! empty send error
			returnstatus=0
			message$="Add1 CANNOT BE BLANK"
			Exit Sub
		End If
		cust.addr1$=RTrim$(tmp$)+Blank$

		call dxget("NEWADDR2",tmp$)
		cust.addr2$=RTrim$(tmp$)+Blank$

		call dxget("NEWCITY",tmp$)
		if Rtrim$(tmp$)="" ! empty send error
			returnstatus=0
			message$="City CANNOT BE BLANK"
			Exit Sub
		End If
		cust.city$=RTrim$(tmp$)+Blank$

		call dxget("NEWSTATE",tmp$)
		if Rtrim$(tmp$)="" ! empty send error
			returnstatus=0
			message$="State CANNOT BE BLANK"
			Exit Sub
		End If
		cust.state$=RTrim$(tmp$)+Blank$

		call dxget("NEWZIP",tmp$)
		if Rtrim$(tmp$)="" ! empty send error
			returnstatus=0
			message$="Zip CANNOT BE BLANK"
			Exit Sub
		End If
		cust.zip4$=RTrim$(tmp$)+Blank$

		call dxget("NEWCOUNTRY",tmp$)
		cust.country$=RTrim$(tmp$)+Blank$

		call dxget("NEWPHONE",tmp$)
		!cust.phone$=RTrim$(tmp$)+Blank$
		cust.Phone$=numericonly$(tmp$)+blank$

		! cnotes fields
		call dxget("NEWRESIDENTAIL",tmp$)
		if tmp$[1,1]="Y"
			LET cnotes.residential=1
		else 
			LET cnotes.residential=0
		endif
		
		call dxget("NEWSENDEMAIL",tmp$)
		if tmp$[1,1]="Y"
			let cnotes.sendemail=1
		else
			let cnotes.sendemail=0
		endif

		call dxget("NEWEMAIL",tmp$)
		let cnotes.EMAIL$[1,50]=RTrim$(tmp$)+Blank$			

		! now update customer record
		aa=fileupdatecust(e$,CUC,"c",CUR,cust.,0,0,-1)
		if aa<0 ! a problem
			returnstatus=0
			message$="ERROR ON UPDATE "+Str$(aa)+" "+e$
			Exit Sub
		Endif
		
		! now update custnotes record
		aa=fileupdatecustnotes(e$,CNC,"c",CNRec,CNotes.)
		if aa<0 ! a problem
			returnstatus=0
			message$="ERROR ON UPDATE "+Str$(aa)+" "+e$
			Exit Sub
		Endif
	End If ! of if cur<0
 else
	include "src/callsuberr.inc"
 end try

End Sub ! UpdateWebCust
!-----------------------------------------------------------------------------

Sub UpdateWebShiplist()
 Try
	Dim blank$[255], slkey$[16],3%
	blank$=" ",blank$

	Try Close #SLC  Else Rem
	SLC = OpenFile(2112,IntCo) \ if slc = -1 Error 42 ! custshiplist

	ReturnStatus=1
	Message$="OK"

	Call DXGet("CUSTID",tmp$)
	X2=tmp$
	Cust$=X2 Using "######"

	Call DXGet("SHIPID",tmp$)
	If tmp$="" 
		ReturnStatus=0
		Message$="NO ShipList ID sent"
		Exit Sub ! none sent
	Endif
	If tmp$="999999" 
		ReturnStatus=1
		Message$="OK" ! this is so there are no error messages passed back for 999999
		Exit Sub ! none sent
	Endif

	! Get shiplist record
	let shipno=tmp$
	slkey$=" ",slkey$
	SLKey$=Cust$+"."+ShipNo Using "&&&&&&"
	SLR=FileGetshiplist(e$,SLC,"=",1,SLKey$,sl.)

	If slr<0
		ReturnStatus=0
		Message$="SHIPLIST "+slkey$+" NOT FOUND"

	else	! Found record
		!

		! sl fields
		call dxget("NEWNAME",tmp$)
		if Rtrim$(tmp$)="" ! empty send error
			returnstatus=0
			message$="NAME CANNOT BE BLANK"
			Exit Sub
		End If
		SL.NAME$=UCase$(RTrim$(tmp$))+Blank$
		Call dxget("NEWADDR1",tmp$)
		if Rtrim$(tmp$)="" ! empty send error
			returnstatus=0
			message$="ADDR1 CANNOT BE BLANK"
			Exit Sub
		End If
		sl.address$=RTrim$(tmp$)+Blank$
		call dxget("NEWADDR2",tmp$)
		sl.optaddress$=RTrim$(tmp$)+Blank$
		call dxget("NEWCITY",tmp$)
		if Rtrim$(tmp$)="" ! empty send error
			returnstatus=0
			message$="City CANNOT BE BLANK"
			Exit Sub
		End If
		sl.city$=RTrim$(tmp$)+Blank$
		call dxget("NEWSTATE",tmp$)
		if Rtrim$(tmp$)="" ! empty send error
			returnstatus=0
			message$="State CANNOT BE BLANK"
			Exit Sub
		End If
		sl.state$=RTrim$(tmp$)+Blank$
		call dxget("NEWZIP",tmp$)
		if Rtrim$(tmp$)="" ! empty send error
			returnstatus=0
			message$="ZIP CANNOT BE BLANK"
			Exit Sub
		End If
		sl.zipcode$=RTrim$(tmp$)+Blank$
		call dxget("NEWCOUNTRY",tmp$)
		sl.country$=RTrim$(tmp$)+Blank$
		call dxget("NEWCOUNTACT",tmp$)
		sl.contact$=RTrim$(tmp$)+Blank$
		call dxget("NEWPHONE",tmp$)
		sl.phonenumber$=RTrim$(tmp$)+Blank$
		call dxget("NEWRESIDENTAIL",tmp$)
		if tmp$[1,1]="Y"
			LET sl.residential=1
		else 
			LET sl.residential=0
		endif
		call dxget("NEWSENDEMAIL",tmp$)
		if tmp$[1,1]="Y"
			let sl.sendemail=1
		else
			let sl.sendemail=0
		endif
		call dxget("NEWEMAIL",tmp$)
		let cnotes.EMAIL$[1,50]=RTrim$(tmp$)+Blank$
		call dxget("NEWSHIPINS1",tmp$)
		let SL.ShipInstLine1$=RTrim$(tmp$)+Blank$
		call dxget("NEWSHIPINS2",tmp$)
		let SL.ShipInstLine2$=RTrim$(tmp$)+Blank$
		call dxget("NEWSHIPINS3",tmp$)
		let SL.ShipInstLine3$=RTrim$(tmp$)+Blank$
		call dxget("NEWSHIPINS4",tmp$)
		let SL.ShipInstLine4$=RTrim$(tmp$)+Blank$
		call dxget("NEWSHIPINS5",tmp$)
		let SL.ShipInstLine5$=RTrim$(tmp$)+Blank$
		call dxget("NEWSHIPINS6",tmp$)
		let SL.ShipInstLine6$=RTrim$(tmp$)+Blank$
		call dxget("NEWSHIPINS7",tmp$)
		let SL.ShipInstLine7$=RTrim$(tmp$)+Blank$
		call dxget("NEWSHIPINS8",tmp$)
		let SL.ShipInstLine8$=RTrim$(tmp$)+Blank$
		let SL.DATEEDIT = Tim(8) * 10 ^ 4 + Tim(9) * 10 ^ 2 + Tim(10)

		! now update shiplist record
		aa=fileupdateshiplist(e$,SLC,"c",slr,sl.)
		if aa<0 ! a problem
			returnstatus=0
			message$="ERROR ON UPDATE "+Str$(aa)+" "+e$
			Exit Sub
		Endif
		
	End If ! of if slr<0
 else
	include "src/callsuberr.inc"
 end try

End Sub ! UpdateWebShiplist
!-----------------------------------------------------------------------------

Function rmbadchar$(s_in$)                        
  Dim s_out$[1000]                                
  Dim 1%,i,j                                      
  Dim 3%

  s_out$ = " ",s_out$                             
  i = Len(s_in$)                                  
  If i > 1000 Let i = 1000 !! max size            
  If i                                            
    For j = 1 To i                                
      If s_in$[j,j] < " " Or s_in$[j,j] > "~"     
        s_out$[j,j] = " "                         
      Else                                        
        s_out$[j,j] = s_in$[j,j]                  
      End If                                      
    Next j                                        
  End If                                          
End Function s_out$                        
