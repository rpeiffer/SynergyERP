! >>> Program cch.xmlfle.in
!
! description  receive from cch an order to calc tax on  trans # 
!
! loadsave -w -n 100,10 -o prog/dxport/cch.xmlfle.in.dl4 src/cch.xmlfle.in.src
!
! 1.0 mm/dd/yyyy change?
!
include "src/copyright.inc" ! dx
!
Rem CCH.XMLFLE.IN.src - Receive back tax calc file
Rem 220549 / 221505
Rem file name passed in - generated by sending perl script/program that creates it
Rem BEDIT Version: 2.2 OBJECT CODE     Created: JAN 22, 2010  18:06:00
Rem /w2/papermaster/r2005//usr/acct/valerie/work/custom/htberry.r10/cch.xmlfle.in.src (univ2) [valerie] {41108}
Rem  Copyright (c) 2010 Universal Business Systems, Inc.
Rem    **** ALL CHANGES MUST BE MADE IN SOURCE!!! ****
Rem
External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus
Declare Intrinsic Sub FindF,InpBuf,String,programdump
declare intrinsic function FindChannel
!Option Default Dialect IRIS1

If Err 0 Gosub ERR_TRAP
Rem file for storing order & cch transid: 7/CCHORDTRANS#
Rem directory = OOOOOOTT-24-TT (ttl-30 char)
Enter ORDERNO,INXMLFLE$,intco,rstr$
Rem {begin src/inc/dim.getchan.i}
Dim 1%,CHNL
Dim 3%,CHNLSCR,CHNLFREE
Rem {end dim.getchan.i}
Dim WRKLINE$[1000],TMPLINE$[1000],VAR$[10],WORK$[1000],TEMP$[1000]
Dim FLE$[30],RETVAL$[512],CCHSERNO$[20],CCHDPC$[10],DIRTO$[64]
Dim CCHOID$[20],S1$[118],S2$[20],A1$[142],A2$[30],A3$[22],L1$[20]
Dim S3$[33],K1$[64],K2$[64],K3$[64],K4$[64],XMLFLE$[80],TMPFLE$[30]
Dim X$[20],VARNM$[60],CCHPC$[10],LOGFNM$[40],SPACES$[200],TEXNO$[20]
Dim FAULTSTRING$[256]
Dim 1%,X,X1[9],COID,CH_CNTRL,CH_CUST,CH_ROL,CH_ROS,CH_ROT,CH_ROL,CH_INFLE
Dim 1%,L3[3],S2[1],H4[2],TCB,CH_ROH,CH_TAX,POS0,POS1,POS2,POS3,CH_DTL
Dim 1%,CH_CCHTRNS,TTLLNS,LDLN,LNNO,SCR,CREDIT,RTAX,FLEFND,CCHAN[10]
Dim 1%,FOUND,BADDATA,RCOMMIT,RCANCEL,RESPFAULT,BADORD,RLINE
Dim 2%,X2[9],H0[12],MCODE[9],L4[3],H6[8],H5[16]
Dim 3%,X3[9],SRN[5],T2[25],MCHARGE[9,1],L5[3],L7[12]
Dim 3%,ORDREC,R[99],TAXAMT,E,H
Dim e$[500],buttonlist$[5,50],nextlist$[5,100] ! dx error handling variables
Dim WebStr$[256],msg$[100],message$[300]
SPACES$ = " ",SPACES$;SCOMMIT = 0
If ORDERNO < 0 ! if <0 it's a commit
  ORDERNO = Abs(ORDERNO);SCOMMIT = 1
End If 
If ORDERNO <= 0 Goto OUTEND
If INXMLFLE$ = "" Goto OUTEND
returnstatus=1;message$="OK"
COID = IntCo ! Int((Spc(5) - Int(Spc(5) / 16384) * 16384) / 64)
CH_CNTRL = 1
X2 = 0
try
X3 = Chf(CH_CNTRL)
Else
	x2=49
End try
If X2 ! cntrl not open
  Open #1,"cntrl/cntrl" + Str$(COID)
End If 
If CCHAN[1] <= 0 ! No cust
  CHNL = 97 \ Gosub GETCHAN
  If CHNL > 1 Let CCHAN[1] = CHNL
  Read #CH_CNTRL,88,1808;FLE$[1,16];
  Open #CCHAN[1],FLE$
  CCHAN[1] = 0 - CCHAN[1]
End If 
CH_CUST = Abs(CCHAN[1])
If CCHAN[2] <= 0 ! no roh
  CHNL = 97 \ Gosub GETCHAN
  If CHNL > 1 Let CCHAN[2] = CHNL
  Read #CH_CNTRL,88,1840;FLE$[1,16];
  Open #CCHAN[2],FLE$
  CCHAN[2] = 0 - CCHAN[2]
End If 
CH_ROH = Abs(CCHAN[2])
If CCHAN[3] <= 0 ! no ros
  CHNL = 97 \ Gosub GETCHAN
  If CHNL > 1 Let CCHAN[3] = CHNL
  Read #CH_CNTRL,88,1856;FLE$[1,16];
  Open #CCHAN[3],FLE$
  CCHAN[3] = 0 - CCHAN[3]
End If 
CH_ROS = Abs(CCHAN[3])
If CCHAN[4] <= 0 ! no rot
  CHNL = 97 \ Gosub GETCHAN
  If CHNL > 1 Let CCHAN[4] = CHNL
  Read #CH_CNTRL,88,1872;FLE$[1,16];
  Open #CCHAN[4],FLE$
  CCHAN[4] = 0 - CCHAN[4]
End If 
CH_ROT = Abs(CCHAN[4])
If CCHAN[5] <= 0 ! no rol
  CHNL = 97 \ Gosub GETCHAN
  If CHNL > 1 Let CCHAN[5] = CHNL
  Read #CH_CNTRL,88,1888;FLE$[1,16];
  Open #CCHAN[5],FLE$
  CCHAN[5] = 0 - CCHAN[5]
End If 
CH_ROL = Abs(CCHAN[5])
If CCHAN[6] <= 0 ! no TAX
  CHNL = 97 \ Gosub GETCHAN
  If CHNL > 1 Let CCHAN[6] = CHNL
  Read #CH_CNTRL,88,2176;FLE$[1,16];
  Open #CCHAN[6],FLE$
  CCHAN[6] = 0 - CCHAN[6]
End If 
CH_TAX = Abs(CCHAN[6])
CHNL = 97 \ Gosub GETCHAN
If Err 0 Gosub ERR_TRAP
If CHNL > 1 ! valid channel
  Call "progdflt","CCH","",CHNL,RETVAL$
  If RETVAL$[1,5] = "@@@@@" Let RETVAL$ = " ",RETVAL$
  CCHSERNO$ = RETVAL$[1,20]
  CCHDPC$ = RETVAL$[21,26]
  DIRTO$ = RETVAL$[31,95]
  LOGFNM$ = RETVAL$[100,139]
Else ! "NO DEFAULTS!?
  Message$="NO DEFAULTS DEFINED!"
  returnstatus=0
  Goto OUTDONE
End If 
CCHSERNO$=trim$(CCHSERNO$)
CCHDPC$=trim$(CCHDPC$)
DIRTO$=trim$(DIRTO$)
If CCHSERNO$ = "" Or DIRTO$ = "" ! "NEED THESE!! Or CCHDPC$="" OR
  Message$="MISSING DEFAULT VALUES!"
  returnstatus=0
  Goto OUTDONE
End If 
LOGFNM$=trim$(LOGFNM$)
If LOGFNM$ = "" ! no name defined - hardcode default name
  LOGFNM$ = "1/cchcalcdsout.log"
End If 
If CCHDPC$ = "" Let CCHDPC$ = " "
If DIRTO$ = "" Or DIRTO$[1,10] = SPACES$[1,10] Let DIRTO$ = "/tmp/"
RCFAIL = 0
RESTARTHERE: Rem retry receiving
XMLFLE$ = INXMLFLE$
CH_INFLE = CHNL
WORK$ = XMLFLE$
FLEFND = 0
CHK4FLE: Rem "wait and try again loop
Call FindF(WORK$,FOUND)
If FOUND ! it's there - open it
  Open #CH_INFLE,WORK$
Else 
  If FLEFND <= 4 ! not there yet? try 4 times(0,1,2,3)(=12 seconds), then give up
    FLEFND = FLEFND + 1
    ! Print @40,22;'CL';"NO FILE YET..";Str$(FLEFND);
    Signal 3,30
    Goto CHK4FLE
  End If 
  Message$="RESPONSE FILE MISSING!"
  returnstatus=0
  Goto OUTDONE
End If 
FLE$ = "7/CCHORDTRANS" + Str$(COID)
CHNL = 97 \ Gosub GETCHAN
If Err 0 Gosub ERR_TRAP
Call FindF(FLE$,H)
If Not(H) ! not found exit
  Message$="TRANSACTION FILE NOT FOUND"
  returnstatus=0
  Goto OUTDONE
End If 
If CHNL > 1 ! valid
  CH_CCHTRNS = CHNL
  Open #CH_CCHTRNS,FLE$
Else 
  Message$="TRANSACTION FILE NOT OPENED"
  returnstatus=0
  Goto OUTDONE
End If 
BADDATA = 0;RCOMMIT = 0;RCANCEL = 0;CREDIT = 0
INFLE_LOOP: Rem until done or EOF
WRKLINE$ = ""
Gosub READ_TEMPLATE
If WRKLINE$ = "" Goto FLEDONE
Rem the only way I see it is do hardcode literal search
VARNM$ = "COMMIT"
Gosub CHK_LINE
If POS1 ! yes it's a commit response
  RCOMMIT = 1
  Goto NODATAGET
End If 
VARNM$ = "ABANDON"
Gosub CHK_LINE
If POS1 ! yes it's an abandon response
  RCANCEL = 1
  Goto NODATAGET
End If 
VARNM$ = "CALCULATE_DS"
Gosub CHK_LINE
If POS1 ! yes it's an Taxcalc
  RTAX = 1
End If 
VARNM$ = "CALCULATE_DS_ED"
Gosub CHK_LINE
If POS1 ! yes it's an Taxcalc
  RTAX = 1
  CREDIT = 1
End If 
VARNM$ = "<CERTITAXTRANSACTIONID"
Gosub CHK_LINE
If POS1 ! Yes, this is the one
  Gosub PARS_DATA
  CCHOID$ = TEMP$
  CCHOID$=trim$(CCHOID$)
End If 
VARNM$ = "<SERIALNUMBER"
Gosub CHK_LINE
If POS1 ! Yes, this is the one
  Gosub PARS_DATA
  TEMP$=trim$(TEMP$)
  If TEMP$ = "" Let BADDATA = 1 \ Goto ORDFINISH
  If TEMP$ <> CCHSERNO$[1,Len(TEMP$)] Let BADDATA = 1 \ Goto ORDFINISH
End If 
VARNM$ = "<TOTALTAX"
Gosub CHK_LINE
If POS1 ! Yes, this is the one
  Gosub PARS_DATA
  X3 = TEMP$
  TAXAMT = Abs(X3)
End If 
VARNM$ = "FAULT"
Gosub CHK_LINE
If POS1 ! CCH found a problem
  RESPFAULT = 1
End If 
VARNM$ = "<FAULTSTRING"
Gosub CHK_LINE
If POS1 ! see if we can grab why it's a 'fault'
  Gosub PARS_DATA
  FAULTSTRING$ = TEMP$
  WORK$ = TEMP$
  POS0 = 1;POS2 = 0
  Search WORK$[POS0],";",POS2
  If POS2 ! okay all after semicolon is what we want
    POS1 = POS2 + 1
GETALLSC: Rem until no more found
    POS0 = POS1
    Search WORK$[POS0],";",POS2
    If POS2 ! found another - see if another
      POS1 = POS0 + POS2
      Goto GETALLSC
    End If 
    FAULTSTRING$ = " ",FAULTSTRING$
    FAULTSTRING$ = WORK$[POS1 + 1]
    Gosub STRPCHARS
  End If 
End If 
Goto INFLE_LOOP
READ_TEMPLATE: Rem read (needs any processing?)
Read #CH_INFLE;WRKLINE$;
STRPCCHAR: Rem "remove cr/lf etc
If Len(WRKLINE$) > 1 
  iF WRKLINE$[Len(WRKLINE$)] < " "
  WRKLINE$[Len(WRKLINE$)] = ""
  Goto STRPCCHAR
  Endif
End If 
Return 
CHK_LINE: Rem See if line holds what we're looking for
WORK$ = WRKLINE$
Call String(1,WORK$)
POS0 = 1;POS1 = 0;POS2 = 0
Search WORK$[POS0],VARNM$,POS1
Return 
PARS_DATA: Rem get the data from the line
WORK$ = "";TEMP$ = ""
Search WRKLINE$[POS0 + POS1],">",POS2
If POS2 ! got it
  WORK$ = "";TEMP$ = ""
  X = POS2 + POS0 + POS1
  Let WORK$ = WRKLINE$[X] To "<" : POS2
  For X1 = 1 To Len(WORK$)
    If WORK$[X1,X1] <> ">" And WORK$[X1,X1] <> "<" And WORK$[X1,X1] <> ""
      TEMP$ = TEMP$ + WORK$[X1,X1]
    End If 
  Next X1
End If 
Return 
FLEDONE: Rem file reading is done - write order files
If CCHOID$ = "" Let BADDATA = 2
If ORDERNO <= 0 Let BADORD = 1 \ Goto ORDFINISH
If Not(RTAX) Let BADDATA = 3
If RESPFAULT Let H0[7] = ORDERNO \ Goto ORDERFIN
If BADDATA Or RESPFAULT Goto ORDERFIN
If SCOMMIT Goto ORDFINISH
K1$ = " ",K1$;K1$[3] = ORDERNO Using "######"
For X = 1 To 99
  If X < 20 Or X > 22 ! no deleted search
    K1$[1,2] = X Using "##"
    Search #CH_ROH,2,1;K1$,R[2],E \ If E > 1 Gosub ERR_SEARCH
    If Not(E) Goto GOTORDER
  End If 
Next X
BADORD = 1
Goto ORDERFIN
GOTORDER: Rem found our target
ORDREC = R[2]
BADORD = 0
Mat Read #CH_ROH,R[2],0;H0;
Mat Read #CH_ROH,R[2],104;H5;
R[3] = H0[3]
Mat Read #CH_ROT,R[3],8;T2
T2[7] = TAXAMT
If H5[7] = 10 Or H5[7] = 6 Let T2[6] = 0 - T2[7]
T2[0] = T2[1] - T2[3] + T2[4] + T2[5] + T2[6] + T2[7]
Mat Write #CH_ROT,R[3],8;T2;
ORDERFIN: Rem "finish up
DELPTRNS: Rem delete any/all entries for this order
If H0[7] <= 0 Goto ORDFINISH
K1$ = " ",K1$;K1$ = H0[7] Using "######"
Search #CH_CCHTRNS,2,1;K1$,R,E \ If E > 1 Gosub ERR_SEARCH
If Not(E) ! found previous DELETE IT! (to prevent old or bad info accumulation)
  Search #CH_CCHTRNS,5,1;K1$,R,E \ If E Gosub ERR_SEARCH
  Goto DELPTRNS
End If 
If CCHOID$[1,1] <> "" And CCHOID$[1,10] <> SPACES$[1,10] ! don't record blank (out program handles it)
  K1$ = " ",K1$;K1$[1,6] = H0[7] Using "######"
  K1$[7] = CCHOID$ + SPACES$;R = ORDREC
  Search #CH_CCHTRNS,4,1;K1$,R,E \ If E > 1 Gosub ERR_SEARCH
End If 
Goto ORDFINISH
NODATAGET: Rem no data in file - just a response
RESPFAULT = 0;RLINE = 1;H0[7] = ORDERNO
RFLE_LOOP: Rem look to see if fault was sent
If RLINE > 1 ! in case a 1 line response - don't read next line yet
  WRKLINE$ = ""
  Gosub READ_TEMPLATE
End If 
If WRKLINE$ = "" Goto ORDFINISH
VARNM$ = "FAULT"
Gosub CHK_LINE
If POS1 ! CCH found a problem
  RESPFAULT = 1
End If 
VARNM$ = "<FAULTSTRING"
Gosub CHK_LINE
If POS1 ! see if we can grab why it's a 'fault'
  Gosub PARS_DATA
  FAULTSTRING$ = TEMP$
  WORK$ = TEMP$
  POS0 = 1;POS2 = 0
  Search WORK$[POS0],";",POS2
  If POS2 ! okay all after semicolon is what we want
    POS1 = POS2 + 1
GETALLSC2: Rem until no more found
    POS0 = POS1
    Search WORK$[POS0],";",POS2
    If POS2 ! found another - see if another
      POS1 = POS0 + POS2
      Goto GETALLSC2
    End If 
    FAULTSTRING$ = " ",FAULTSTRING$
    FAULTSTRING$ = WORK$[POS1 + 1]
    Gosub STRPCHARS
  End If 
End If 
RLINE = RLINE + 1
Goto RFLE_LOOP
STRPCHARS: Rem as we use cat - we need to strip 'invalid' chars
WORK$ = FAULTSTRING$
If Len(WORK$) = 0 Return 
For X = 1 To Len(WORK$)
  If WORK$[X,X] = ")" Let WORK$[X,X] = " "
  If WORK$[X,X] = "(" Let WORK$[X,X] = " "
Next X
FAULTSTRING$ = " ",FAULTSTRING$
FAULTSTRING$ = WORK$
Return 
ORDFINISH: Rem finish
!If Not(CREDIT) Print @0,23;'CL';"ORDER ";
!If CREDIT Print @0,23;'CL';"CREDIT ";
!Print H0[7];
!If Not(RCOMMIT) And Not(RCANCEL) Print "TAX ";
!If RCOMMIT Print "COMMIT ";
!If RCANCEL Print "CANCEL ";
!Print "RECEIVED. ";
If BADORD Or BADDATA Or RESPFAULT Message$="DATA ERROR" ! ; Else Print "NO PROBLEMS";
If RESPFAULT Message$=message$+FAULTSTRING$
If BADORD Or BADDATA Or RESPFAULT returnstatus=0
RFLEDONE: Rem close & audit
Close #CH_INFLE
Close #CH_CCHTRNS
If Not(CREDIT) Let TEMP$ = "ORDER: " + H0[7] Using "######"
If CREDIT Let TEMP$ = "CREDIT: " + H0[7] Using "######"
TEMP$ = TEMP$ + "  " + Msc$(3)
If RESPFAULT !
  TEMP$ = TEMP$ + " CCH REPORTED A XML DATA FAULT: "
  TEMP$ = TEMP$ + FAULTSTRING$
Else 
  If Not(RCOMMIT) And Not(RCANCEL) Let TEMP$ = TEMP$ + " CCHTID: " + CCHOID$
End If 
If RCOMMIT Let TEMP$ = TEMP$ + " COMMIT"
If RCANCEL Let TEMP$ = TEMP$ + " CANCEL"
If Not(BADDATA) And Not(BADORD) Let TEMP$ = TEMP$ + " RECV AS: " + INXMLFLE$
If BADORD Let TEMP$ = TEMP$ + " DATA ERROR: NO ORDER NUMBER"
If BADDATA = 1 Let TEMP$ = TEMP$ + " DATA ERROR: DIFFERENT CUSTOMER"
If BADDATA = 2 Let TEMP$ = TEMP$ + " DATA ERROR: NO TRANS ID RECEIVED"
If BADDATA = 3 And Not(RESPFAULT) Let TEMP$ = TEMP$ + " DATA ERROR: UNRECOGNIZED RESPONSE"
WORK$ = "echo " + TEMP$ + " >> " + LOGFNM$
System WORK$
WORK$ = INXMLFLE$
POS0 = 1;POS1 = 0
Search WORK$[POS0],"in.txt",POS1
If Not(POS1) Goto OUTDONE
XMLFLE$ = WORK$[1,POS1 - 1]
Rem as 'commits' seem to fail quite often - try a resend
If RCOMMIT And RESPFAULT And RCFAIL < 2 ! see type of fault (fail if failed 2x)
  POS0 = 1;POS1 = 0
  Search FAULTSTRING$[POS0],"try again later",POS1
  If POS1 ! "we'll try again
    WORK$ = XMLFLE$ + ".pl " + INXMLFLE$
    !Print @0,22;'CL';"RESENDING ";H0[7];" COMMIT REQUEST NOW - RETRY ";Str$(RCFAIL + 1);
    System WORK$
    RCFAIL = RCFAIL + 1
    Goto RESTARTHERE
  End If 
End If 
If SCOMMIT And (BADDATA = 3 Or RCOMMIT = 0) And RCFAIL < 2 ! commit got no response - try again
  WORK$ = XMLFLE$ + ".pl " + INXMLFLE$
  ! Print @0,22;'CL';"RESENDING ";H0[7];" COMMIT REQUEST NOW - RETRY ";Str$(RCFAIL + 1);
  System WORK$
  RCFAIL = RCFAIL + 1
  Goto RESTARTHERE
End If 
CDXFile=0 ! delete xml files
If not(badord) and not(baddata) and not(respfault) let CDXFile=1
if respfault ! check string - certain ones go bye-bye
	pos3=1;pos4=0
	Search FaultString$[pos3],"at least one line item",pos4
	if pos4 let CDXFile=1 ! yes - cxp/BH files generate a couple requests with no lines
Endif
if CDXFile ! "all ok - delete files
  Rem all trans(except faults) are saved on cch system
  WORK$ = "rm -f " + XMLFLE$ + "* >/dev/null 2>&1"
  System WORK$
End If 
OUTDONE: Rem finished
If Err 0 Rem
For X = 1 To 10
  If CCHAN[X] <= 0 ! we opened
    X1 = Abs(CCHAN[X])
    If X1 > 0 Close #X1
  End If 
Next X
If Err 0 Gosub ERR_TRAP
if returnstatus=0 goto outErr ! something amiss
OUTEND: Rem outta here
End 
Rem {begin src/inc/rtn.getchan.i}
GETCHAN: Rem search for open channel (counts down from supplied chnl #)
CHNL=FindChannel()
Return 
OutErr: ! something amiss
call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
call AddToStr(e$,rstr$,WebStr$)
call SetOutPut(e$,rstr$)
End
Rem {end rtn.getchan.i}
ERR_SEARCH: Rem
ENUM = E + 1000;ELINE = Spc(16);CTERR = 0
If E = 5 Let CTERR = Err(8)
msg$ = "RETURN STATUS",(E + (CTERR * .001))
msg$ = msg$,"/ STATEMENT",ELINE," IN PROGRAM "+MSC$(4)
Call programdump("tmp/cch.xmlfleinse!","")
returnstatus=0
message$=msg$
goto OutErr ! alt - send user info
Rem {begin rtn.error.s}
ERR_TRAP: Rem *Error routine (escape trap)   V3.1 8/94 G.DOSCHER/REK
!
include "src/callmainerrnet.inc"
End 
Rem {end rtn.error.s}