! blockcollagent.dl4
!
! supporting file handler for block ID 101CLAGT collagent file maintenance routines for browser
!
! loadsave -w -n 100,10 -o prog/dxport/blockcollagent.dl4 src/blockcollagent.src
!
! 1.0 generated by dxblockcreatemaint on 12/27/12 new
! modified from standard for validate of access code (like on buyer)
!
include "src/copyright.inc"
!
Declare external function dfaudit !libgeneral.lib
! *declare dl4 intrinsic subs & functions
declare intrinsic sub getglobals
declare intrinsic function replace$
!
external lib "ubsfunc.dl4"
declare external function OpenFile
!
external lib "dxblockcallsx.lib" !page block routines
declare external sub setblock,setproperties,setdata
declare external function blockDTconvert$
!
external lib "dxblockdeleteok.lib"
declare external function deleteok$
!
external lib "blockcollagent_cond.lib"
declare external function validate$
!
!include structure,filehandler libs & default structure dims
include "src/inc/filecollagent.inc"
dim collagent. as collagent
!
function setvalue$(fieldname$,mask$)
!-----------------------------------------------------------------
!moves value of fieldname$ in structure to value$
 try
  Select Case lcase$(fieldname$)
    Case "recordnumber"
	 value$=id$
    Case "collectionagentqqq"
	  value$=rtrim$(collagent.CollectionAgent$)
    Case "accesscodeqqq"
	  value$=rtrim$(collagent.AccessCode$)
    Case "holdcodebudpoexpi"
     if rtrim$(mask$)=""
      value$=str$(collagent.HoldcodeBudPoExpi)
     else
	   value$=collagent.HoldcodeBudPoExpi using mask$
      if value$[1,1]="*" let value$=str$(collagent.HoldcodeBudPoExpi) !bad mask
     end if
    Case "sparenotusedqqq"
	  value$=rtrim$(collagent.SpareNotUsed$)
  End Select
 !
 else
  include "src/callsuberr.inc"
 end try
end function value$ !setvalue$
!
sub setvalue(fieldname$,value$,mask$)
!-----------------------------------------------------------------
!moves value$ to fieldname$ in structure
 try
   value$=trim$(value$)
   Select Case lcase$(fieldname$)
    Case "collectionagentqqq"
     if rtrim$(mask$)=""
	  collagent.CollectionAgent$=value$,blank$
     else
	   value=value$
	  collagent.CollectionAgent$=value using mask$ !numeric with a mask,stored as a string
     end if
    Case "accesscodeqqq"
     if rtrim$(mask$)=""
	  collagent.AccessCode$=value$,blank$
     else
	   value=value$
	  collagent.AccessCode$=value using mask$ !numeric with a mask,stored as a string
     end if
    Case "holdcodebudpoexpi"
	  collagent.HoldcodeBudPoExpi=value$
    Case "sparenotusedqqq"
     if rtrim$(mask$)=""
	  collagent.SpareNotUsed$=value$,blank$
     else
	   value=value$
	  collagent.SpareNotUsed$=value using mask$ !numeric with a mask,stored as a string
     end if
   End Select
  else
   include "src/callsuberr.inc"
 end try
end sub !setvalue
!
sub loadcolscollagent()
!-----------------------------------------------------------------
!loads 2 dim array of data,then dxsets columns for table display
try
  dim colcnt$[3]
  call dxget(1,"colcnt",colcnt$) !from setblock
  maxrowlength=300    !value code generated from file structure!!!
  maxcnt=3000  !# rcds/rows per page
  cnt=0
  Dim rows$[maxcnt,maxrowlength] !will hold 2dim array of column,row data
  !
  !read in all the column fieldnames and masks set by setblock
  Dim varnames$[val(colcnt$),20],masks$[val(colcnt$),20]
  for column=0 to val(colcnt$)
   call dxget(10,"coldefvarname"+str$(column),varnames$[column])
   call dxget(10,"coldefmask"+str$(column),masks$[column])
  next column
  dim searchby$[20],begin1$[20],end1$[20],keynext$[100]
  call dxget("searchby",searchby$)
  searchcolumn = searchby$
  call dxget("begin",begin1$)
  call dxget("end",end1$)
  begin1=begin1$ !if numeric
  end1=end1$ !if numeric
  if end1=0 let end1=99999999999
  call dxget("keynext",keynext$)
  if end1$="" let end1$="zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz" !default to eof
  for rcd=0 to chf(chan)-2
  collagent.CollectionAgent$ = ""
     try read record #chan,rcd+1;collagent.; else rem
		id$=str$(rcd+1)
  if trim$(collagent.CollectionAgent$) <> "" !active record
   if cnt>=maxcnt exit for
   checkit=0
   if searchby$ <> ""
    tmp$=setvalue$(varnames$[searchcolumn],masks$[searchcolumn])
    if rtrim$(masks$[searchcolumn]) <> "" !numeric compare
     tmp = tmp$
     if tmp<begin1 let checkit = 1
     if tmp>end1 let checkit = 1
    else
     if len(tmp$) > 0 if len(tmp$)<= len(begin1$) if tmp$<begin1$[1,len(tmp$)] let checkit = 1
     if len(begin1$) > 0 if len(tmp$)> len(begin1$) if tmp$[1,len(begin1$)]<begin1$ let checkit = 1
     if len(tmp$) > 0 if len(tmp$)<= len(end1$) if tmp$>end1$[1,len(tmp$)] let checkit = 1
     if len(end1$) > 0 if len(tmp$)> len(end1$) if tmp$[1,len(end1$)]>end1$ let checkit = 1
    end if !mask$
   end if !searchby
   if checkit=0 !ok to include
    !fill in fields$
    if fdel$="GUI" !dl4 GUI display of records
	 stop
    else !fdel$  .net web
     rows$[cnt]=replace$(id$," ","_"),fdel$ !ID is record # (replacing spaces with _ to retain)
     for column=0 to val(colcnt$)
      tmp$=setvalue$(varnames$[column],masks$[column])
      rows$[cnt]=rows$[cnt],tmp$,fdel$
     next column
	   end if !fdel$
    cnt=cnt+1
   end if !checkit
   end if !active
  next rcd !next record
  !
  call addtostr(e$,rstr$,rows$[])  !add table of data to string
  call addtostr(e$,rstr$,"</block>")
  !
 else
  include "src/callsuberr.inc"
 end try
end sub !loadcolscollagent
!
Sub loadinpcollagent()
!-----------------------------------------------------------------
try
  if id$<>""
   !read existing record for field defaults, its always change mode here, add mode handled by dxblockcallsx, doesn't come here
   try read record #chan,val(id$);collagent.; else rem
  else !add, find first unused record #
   for cnt=1 to chf(chan)-1
  collagent.CollectionAgent$ = ""
    try read record #chan,cnt;collagent.; else rem
  if trim$(collagent.CollectionAgent$) = "" exit for
   next cnt
   if cnt>chf(chan-1) !out of room
    e$="Can not add any more entries!"
    error 10000
   end if
  end if
  !
  !create xml with default record values
  For field= 0 to inpcnt
   call dxget(10,"inpdef"+str$(field),fields$[])  !get all inp parameters from setblock
   !
   if fields$[3] = "Y" !active
    if fdel$="GUI" !dl4 GUI display of records
	 stop
    else !fdel$  .net web
     !set default from record
	    if id$<>"" let fields$[9]=trim$(setvalue$(fields$[4],fields$[22])) !set default values in struct on edit
     if fields$[7]="CHECK"
 	 if fields$[9]=rtrim$(fields$[23,1,10]) let fields$[9]="CHECKED" else let fields$[9]=""
  	end if
     if id$="" if fields$[4]="RecordNumber" let fields$[9]=str$(cnt) !next avail record # on add
	    call setproperties(e$,fields$[],rstr$) !create xml of control properties
	    call setdata(e$,chaninplst,blockid$,fields$[],rstr$)
	    call addtostr(e$,rstr$,"</control>") !add to string, but don't put eor at end
	   end if !fdel$
   end if !active
  Next field
  !
  if action$="EDIT"  !see if delete button should display
   deleteflag$ = deleteok$(e$,"collagent",id$,chan)
   if deleteflag$="" let deleteflag$="Y" !default to allow to delete on record # files
   if deleteflag$="Y" call env(2,"DXDELETE","Y")
  end if
 else
  include "src/callsuberr.inc"
 end try
end sub !loadinpcollagent
!
Sub savecollagent()
 try
   call dxget(10,"inpdef0",fields$[])  !fieldnames in [4]
   call dxget(fields$[4],tmp$) !get value entered in first input field, assumed to be the unique key field for IC or rcd #
  if rtrim$(fields$[22])<>""
	   value=tmp$
	   tmp$=value using fields$[22] !numeric with a mask,stored as a string
  end if
  if origid$<>"" if trim$(tmp$)<>trim$(origid$)  !key field changed, make sure not already on file
   mode$="c" !not ok
  id$=trim$(tmp$)
  try read record #chan,val(id$);collagent.; else rem  !
  if trim$(collagent.CollectionAgent$) = "" let mode$="a" !ok
   if mode$="c"
    e$=id$," already on file!"
    error 10000
   end if
  end if
  mode$ = "c"
  id$=trim$(tmp$)
  searchid$ = id$
  if origid$ <> "" let searchid$ = origid$
  try read record #chan,val(searchid$);collagent.; else rem !
  try mat read #chan,val(searchid$);old?; else rem !audit
  if trim$(collagent.CollectionAgent$) = "" let mode$="a" !add mode
  if origid$ = "" if mode$="c"  !means add mode, but already on file
   e$=searchid$," already on file!"
   error 10000
  end if
  if origid$ <> "" if mode$="a"
   e$=searchid$," not on file!"
   error 10000
  end if
  !add mode set defaults (from filedef)
  if mode$="a"
  end if
  For field= 0 to inpcnt
   call dxget(10,"inpdef"+str$(field),fields$[])  !fieldnames in [4],mask in [22]
   call dxget(fields$[4],tmp$) !get value entered
   tmp$=trim$(tmp$)
   if fields$[7]="CHECK"
    if tmp$ <> rtrim$(fields$[23,1,10]) let tmp$=rtrim$(fields$[23,11,20]) !if not checked, set field to 11,20 not checked value
   end if
   call setvalue(fields$[4],tmp$,fields$[22]) !put into record
  Next field
  !
  !if there are conditions,call function to check before saving
  e$ = validate$(collagent.) ! NON-STD - Manually added
  if e$ <>"" !failed condition check
   error 10000
  end if
  !save record
  write record #chan,val(searchid$);collagent.
   if mode$="a" mat read #chan,val(searchid$);old?; else mat read #chan,val(searchid$);new?; !audit
   r=dfaudit(e$,-1,"collagent",mode$,searchid$,old?,new?)
  e$=id$," saved!"
  !
 else
  include "src/callsuberr.inc"
 end try
end sub !savecollagent
!
Sub deletecollagent()
 try
  try read record #chan,val(id$);collagent.; else rem
  try mat read #chan,val(id$);old?; else rem !audit
  mode$="d"
   r=dfaudit(e$,-1,"collagent",mode$,searchid$,old?)
  collagent.CollectionAgent$="" !indicates deleted
  write record #chan,val(id$);collagent.
  e$=id$," deleted!"
 else
  include "src/callsuberr.inc"
 end try
end sub !deletecollagent
!
! **main procedure
!
! dim variables used by program
!
dim e$[500],buttonlist$[5,50],nextlist$[5,100] !error handling variables
try
!
 dim blockid$[8],tmp$[100],inpcnt$[3],id$[100],readonly$[1],searchid$[100],origid$[100]
 dim action$[30],options$[30],userid$[8],3%,fdel$[10],rstr$[3000],bsdel$[10],esdel$[10],rdel$[10]
 dim fields$[33,120] !array to load input field varnames into
 dim fieldname$[20],value$[120],mask$[20]
 dim mode$[10],keyval$[100],deleteflag$[1],3%,blank$[1000]
 blank$=" ",blank$
 dim old?[3072],new?[3072]
 !
 call getglobals("blockx",0,blockid$,CTLC,options$,action$,userid$,intCO,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$)
 call getglobals("blockxchan",0,chaninplst)  !channel # blockinplst is open on for setdata of droplist values
 !open data file
 if action$<>"SAVE" if action$<>"DELETE" let readonly$="R" !ropen
 chan = OpenFile("collagent",intCo*-1,readonly$)   !modify openfile and pass filename, code generated
 if chan < 0
  let e$="Could not open collagent file!"
  error 10000
 end if
 !
 call dxget(1,"inpcnt",inpcnt$) 
 inpcnt=inpcnt$ !# of input fields, set by setblock
 !
 call dxget("ID",id$)  !record # or key
 call dxget("ORIGID",origid$) !original record # or key, indicates if add or change mode
 id$=replace$(id$,"_"," ")
 origid$=replace$(origid$,"_"," ")
 !
 if action$="TABLE"
  call loadcolscollagent() !loads table columns with data from file
 else if action$="EDIT"
  call loadinpcollagent() !load edit page with input controls & record defaults
 else if action$="SAVE"
  call savecollagent() !save record (add or change)
 else if action$="DELETE"
  call deletecollagent() !delete record
 end if
 !
 Call addtostr(e$,rstr$,esdel$) !end section
 !!!!!!print rstr$
 Call setoutput(e$,rstr$,1,e$) !1 flag puts 0 status section in, puts </page> in, e$ is message
else
 ! error routine
  if spc(8)<>10000
   call suberr(e$,spc(8),spc(10),msc$(2))
   !call programdump("")
  end if
  call mainerr(e$,spc(8),buttonlist$[],nextlist$[],rstr$)   !rstr$ for xml
end try
end
