! serp105.dl4
!
! ShipList  (PM program 105)
! Inquiry & Edit
!
! 1.0 03/02/2009
!
! loadsave -w -n 100,10 -o prog/dxport/serp105.dl4 src/serp105.src
!
!
include "src/copyright.inc"
! internal files needed
Include "src/inc/filecust.inc" ! customer
Include "src/inc/filesslsmz.inc" ! Salesman ! uses array
Include "src/inc/filewhinfoz.inc" ! wh info file (rec 0 fix)
Include "src/inc/fileshiplist.inc" ! shiplist
Include "src/inc/filetaxcode.inc" ! tax code
include "src/inc/filecszone.inc" ! customer/shiplist zone (FOR LAYOUT ONLY!)
include "src/inc/filezonefle.inc" ! zone file
include "src/inc/filecslkeywrd.inc" ! "cust/shiplist keywords
include "src/inc/filedivifle.inc" ! division file

! other external functions / subs
External Lib "ubsfunc.dl4"
Declare External Function OpenFile,JDate$,PDate$
Declare External Function formatdate2$,getuidrec,chkbadchars
Declare External Sub UserCntrl

External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus

External Lib "libcustlist.lib"
Declare External Sub CustList

External lib "libshipldisplay.lib"
Declare External Sub GetCustShipL,CSLList,CSLSales

External Lib "getslsmname.lib"
Declare External Function GetSlsmName$

External Lib "gettaxcdd.lib"
Declare External Function Gettaxcdd$
!
External Lib "getcusttaxtyd.lib"
Declare External Function Getcusttaxtyd$

External Lib "getdivname.lib"
Declare External Function GetdivName$

External Lib "libdroplist.lib"
Declare External sub RoutingDropList

External Lib "ubsoolist.dl4"
Declare External Sub OOList

External Lib "ubsbolist.dl4"
Declare External Sub BOList

External Lib "ubsqolist.dl4"
Declare External Sub QOList

! internal subs/functions 

Declare Intrinsic sub programdump,env,Logic,FindF
Declare Intrinsic Sub DateToJulian,JulianToDate
Declare Intrinsic Function findchannel

Declare Sub Updatelog,OpenFiles,GetCust,SHMain,cpslrecs
Declare Sub SZone,GetKeyWords,GetBInfo,DelShipto,EdtShipto
Declare Sub SndDLists,OOrders,SVBUDG,SVZones,SVKYWRD
Declare Sub DelAKey,AddAKey
Declare Function chkDateFrmt$,ChkDupes
Declare Sub ProcessCommissionSplits

OPTION GOSUB NESTING 12  ! Default is 8 (called programs may add several nests)
Try
	Option String Redim is legal ! in case subs dim/use same names
	
	dim e$[500],buttonlist$[5,50],nextlist$[5,100] !error handling variables
	dim action$[30],options$[30],userid$[8],b$[200],action1$[30],Action2$[30]
	Dim bsdel$[10],esdel$[10],rdel$[10],fdel$[10],rstr$[2000]
	dim tmp$[1200],tmp1$[300],Msgdesc$[150],Field$[1,30]
	dim Message$[200],WebStr$[2000],SessionID$[200],J4$[60]
	Dim Prod$[12],ProdKey$[60],P9$[50],P60$[50],P61$[256]
	Dim QMask$[20],PMask$[20],Key1$[60],HKey$[60],Cust$[6]
	Dim Key2$[64],Msgdesc$[150],lpKey$[64],ZS$[60],ZNDSC$[100]
	Dim sfld$[5],bcdata$[5],TUID$[10],UCA2$[50],UTYPE$[10],tdesc$[16]
	Dim VName$[30],email$[50]
	Dim divname$[24]
	dim email$[50]
	dim Blank$[100] \ Blank$=" ",Blank$
	dim 1%,cost_lev[4],Whse,debug,Cnvtu[2],UCA5[10]
	Dim 2%,Q0[1],maxcnt \ maxcnt=50 ! init max records in arrays for list
	dim List$[maxcnt,1000] ! for .net (larger size - ZLines)
	Dim RList$[100,100] ! for fixed droplists (libdroplist.lib)
	dim 1%,X1[9],Chans[20],sctype,ch[10]
	Dim 2%,CustNo,x2[9],sysdate,ShipNo,DeptNo
	Dim 3%,SLR,PWR,CUR,VNR,RHR,RDR,SHR,SDR
	Dim 3%,CNVTA,Amount,X3[9],R[99],passinfo[10],CUSTOM_CUSTOMER$[30]  
	dim dmsg$[256],dblog$[60] \ dblog$="files/6/shl.log" ! fields for DEBUG

	
	Dim cust. as cust ! customer
	Dim WHI. as whinfo ! wh info file
	Dim SL. as shiplist ! ship list file
	Dim tax. as taxcode ! tax code file
	dim slm. as sslsm ! salesman
	dim div. as divifle ! division file

	! call dxopen() ! already done in menu
	call GetSession(e$,CTLC,options$,action$,UserID$,intCo,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$,action1$,action2$)
	
	debugDetail=0;debug=0 ! can do debug text by changing both to 1
	If debugDetail
		debug=1
		tmp$="serp105"
		dmsg$[1,50]="-",dmsg$ \ Call updatelog(debug)               
		dmsg$="start...program "+tmp$ \ Call updatelog(debug)
	Endif
	Action2$=UCase$(Action2$)
	ACtion2$=RTrim$(Action2$) ! make sure UPPERCASE and No blanks at end
	Action1$=UCase$(action1$)
	Action1$=RTrim$(action1$) ! UC and trimmed
	GAct=0 ! action not found
	if debugdetail
		dmsg$="SERP105 ACTION1 "+action1$
		If Action2$<>"" let dmsg$=dmsg$+" ACTION2 "+action2$
		Call updatelog(debug)
	Endif
	

	MAT  READ #CTLC,3,172;SysDate;
	Mat Read #ctlc,19,50;P9$;
	Mat Read #ctlc,60,50;P60$;
	Mat Read #ctlc,61,0;P61$;
    Mat Read #ctlc,115,60;custom_customer$; 
	custom_customer$ = UCase$(trim$(custom_customer$))    
	SCType=0 !using split commissions?
	If P9$[21,21] <> "Y" ! split by category takes priority
		SCType = P61$[72,72]
		If P61$[72,72] = "Y" Let SCType = 1
	end if
	Call OpenFiles() ! open any/all files (after reading flags!)
	Mat Read #CTLC,115,40;Q0;
	QMask$="---------#.##"
	tmp$="#",tmp$
	If q0[1]<=0 Let Q0[1]=2
	If Q0[1] Let Pmask$="-----------#.",tmp$[1,Q0[1]]     !price mask
	! get the Usercntrl Rec #
	If Userid$="" or UserID$[1,2]="  "
		Call DXGet("S_USER.ID",tmp$) ! get from system variable
	Else
		tmp$=UserID$
	Endif
	Let UserID$=UCase$(tmp$) ! make sure it's UPPERCASE as that's what PM uses
	TUID$=UserID$+Blank$
	If Len(TUID$)>10 let TUID$[11]=""
	Call UserCntrl(TUID$,UCA2$,UCA5[],status,intCo)
	Let COST_LEV[0]=UCA5[0]
	Let COST_LEV[1]=UCA5[1]
	Let COST_LEV[2]=UCA5[2]
	Let COST_LEV[3]=UCA5[3]
	Let COMM_LEV=UCA5[4]
	let rec_uac=GetUIDRec(e$,IntCo,Userid$)
	
	ReturnStatus=0
	Message$="ACTION1 NOT FOUND!"
	select case action1$
		case "DROPLIST" !   send droplists  ! all droplists happen
		!
		!If Action2$="ALLLIST" ! zero=none?					doc=SHL-GetDropLists.doc
			! THIS IS FOR EDIT MODE
			Let ReturnStatus=1
			Message$="OK";e$=""
			Call SndDLists()
			!call AddToStr(e$,rstr$,List$[])
		!Endif ! Alllist

	case "CUSTSEARCH" ! customer Scan						doc=SHL-CustScanList.doc
		!
		Let ReturnStatus=1
		Message$="OK"
		
		Call CustList(e$,IntCo,List$[],maxcnt,ctlc,cuc,debugdetail,dblog$,UserId$)
		If E$<>""
		  Let ReturnStatus=0
		  Message$=E$
		Endif
		call AddToStr(e$,rstr$,List$[])
		!
		
		if debugdetail
			dmsg$="Customer Search sent "+Message$ \ Call updatelog(debug)
		Endif
		GAct=1 ! okay
		! end of custsearch
	case "CUSTSHPSRCH" ! Shipto&cust Scan					doc=SHL-ShipCustScan.doc
		!
		Let ReturnStatus=1
		Message$="OK"
		
		Call CSLList(e$,IntCo,List$[],maxcnt,ctlc,cuc,slc,debugdetail,dblog$,UserId$)
		If E$<>""
		  Let ReturnStatus=0
		  Message$=E$
		Endif
		call AddToStr(e$,rstr$,List$[])
		!
		
		if debugdetail
			dmsg$="Shiplist / Customer Search sent "+Message$ \ Call updatelog(debug)
		Endif
		GAct=1 ! okay
		! end of CUSTSHPSRCH
	case "GETCUST" ! customer name							doc=SHL-GetCustomer.doc
		! get cust name
		
		Call DXGet("CUSTID",tmp$)
		X2=tmp$
		Cust$=X2 Using "######"
		Call GetCust()
		If cur<0
			ReturnStatus=0
			Message$="CUSTOMER "+Cust$+" NOT FOUND"
			Goto CustInv
		Endif
		CustNo=Cust$
		Clear List$[]
		List$[0]=bsdel$,"CUSTNAME",fdel$
		List$[1]="ID",fdel$,"NAME",fdel$
		List$[2]=Cust$,fdel$,RTrim$(Cust.Name$),fdel$
		List$[3]=esdel$
		ReturnStatus=1
		Message$="OK"
		call AddToStr(e$,rstr$,List$[])
		!
		CustInv: ! customer invalid
		
		if debugdetail
			dmsg$="Customer Lookup sent "+Message$ \ Call updatelog(debug)
		Endif
		GAct=1 ! okay
		! end of GetCust
	case "GETVEND" ! vendor name							doc=SHL-Getvendor.doc
		! get vend name
		
		Call DXGet("VENDID",tmp$)
		X2=tmp$
		If x2<>0
			Cust$=X2 Using "######"
			Search #VMC,2,1;cust$,Vmr,E
			If E
				ReturnStatus=0
				Message$="VENDOR "+Cust$+" NOT FOUND"
				Goto vendInv
			Else
				Mat Read #VMC,VMR,0;VName$;
			Endif
		Else
			VName$="NOT ASSIGNED"
		Endif
		VendNo=Cust$
		Clear List$[]
		List$[0]=bsdel$,"VENDNAME",fdel$
		List$[1]="ID",fdel$,"NAME",fdel$
		List$[2]=Cust$,fdel$,RTrim$(VName$),fdel$
		List$[3]=esdel$
		ReturnStatus=1
		Message$="OK"
		call AddToStr(e$,rstr$,List$[])
		!
		VendInv: ! customer invalid
		
		if debugdetail
			dmsg$="Vendor Lookup sent "+Message$ \ Call updatelog(debug)
		Endif
		GAct=1 ! okay
		! end of GetVend
	case "SHIPSEARCH" ! list of shiplists for Customer		doc=SHL-GetCustShipL.doc
		GAct=1 ! okay
		Call DXGet("CUSTID",tmp$)
		X2=tmp$
		Cust$=X2 Using "######"
		Call GetCust()
		If cur<0
			ReturnStatus=0
			Message$="CUSTOMER "+Cust$+" NOT FOUND"
			Goto CustSLInv
		Endif
		CustNo=Cust$
		Clear List$[]
		tmpcnt=maxcnt
		List$[0]=bsdel$,"SHIPSEARCH",fdel$
		List$[1]="ID",fdel$,"NAME",fdel$,"ADDRESS1",fdel$,"CITY",fdel$,"STATE",fdel$
		Row=2
		
			Key1$=" ",key1$
			key1$=Cust$+Blank$
			Key1$[7]=""
			do
				slr=FileGetshiplist(e$,SLC,">",1,Key1$,sl.)
				if slr<0 exit do
				if Key1$[1,6]<>Cust$ exit do
				Webstr$=Key1$[8,13],fdel$,RTrim$(sl.Name$),fdel$
				Webstr$=WebStr$,RTrim$(sl.Address$),fdel$
				Webstr$=WebStr$,RTrim$(sl.City$),fdel$,SL.State$,fdel$
				List$[row]=webstr$
				row=row+1
				If row>tmpcnt let tmpcnt=expandarray(e$,List$[])
			loop
			List$[row]=esdel$ ! all done
		
		ReturnStatus=1
		Message$="OK"
		call AddToStr(e$,rstr$,List$[])
		!
		CustSLInv: ! customer invalid
		
		if debugdetail
			dmsg$="ShipList List sent "+Message$ \ Call updatelog(debug)
		Endif
		! end of Shipsearch
	case "GETSHIPLIST" ! get shiplist data					doc=SHL-GetShiplistInq.doc
		GAct=1 ! ok											doc=SHL-GetShiplist.doc
		ReturnStatus=1 !									doc=SHL-AddShiplist.doc
		Message$="OK"
		Call DXGet("CUSTID",tmp$)
		X2=tmp$
		spos=1;dpos=0;fullent=0
		search tmp$[spos],".",dpos
		if dpos
			x2=tmp$[1,dpos-1]! cust
			X2[1]=tmp$[dpos+1] ! shipto
			fullent=1
		Endif
		Cust$=X2 Using "######"
		Call GetCust()
		If cur<0
			ReturnStatus=0
			Message$="CUSTOMER "+Cust$+" NOT FOUND"
			Goto CustSHInv
		Endif
		CustNo=Cust$
		Call DXGet("SHIPID",tmp$)
		if tmp$="" and fullent let tmp$=Str$(X2[1])
		If tmp$="" 
			ReturnStatus=0
			Message$="NO ShipList ID sent"
			goto CustSHINV ! none sent
		Endif
		let shipno=tmp$
		Key1$=" ",key1$
		Key1$=Cust$+"."+ShipNo Using "&&&&&&"
		SLR=FileGetshiplist(e$,SLC,"=",1,Key1$,sl.)
		If SLR<0 AND (ACTION2$="" or Action2$="EDIT") ! inquiry/edit
			ReturnStatus=0
			Message$="SHIPLIST "+Key1$+" NOT FOUND"
			Goto CustSHInv
		Endif
		If action2$="ADD"
			if slr>0 ! already there
				ReturnStatus=0
				Message$="SHIPLIST "+Key1$+" ALREADY ON FILE"
				Goto CustSHInv
			Else
				Clear SL.
				If CUSTOM_CUSTOMER$ = "MORRISETTE" Let sl.DeliveryChrgLvl = 1 
				If CUSTOM_CUSTOMER$ = "HTBERRY"  Let sl.UdaNumeric=1 
			
			Endif
		Endif
		Clear List$[]
		List$[0]=bsdel$,"CUSTNAME",fdel$
		List$[1]="ID",fdel$,"NAME",fdel$,"CommissionByCategory",fdel$
		List$[2]=Cust$,fdel$,RTrim$(Cust.Name$),fdel$,str$(Cust.CommissionByCategory),fdel$
		List$[3]=esdel$
		call AddToStr(e$,rstr$,List$[]) ! customer data
		Clear List$[]
		call SHMAIN()
		call AddToStr(e$,rstr$,List$[])
		!
		CustSHInv: ! customer invalid
		
		if debugdetail
			dmsg$="ShipList "+Key1$+" Lookup "+Message$ \ Call updatelog(debug)
		Endif
		!end of getshiplist

	case "SYSFLAGS" ! send up flags	(IF ANY)				doc=SHL-GetSysFlags.doc
		GAct=1 ! ok
		ReturnStatus=1
		Message$="OK"
		Clear List$[]
		List$[0]=bsdel$,"SYSFLAGS",fdel$
		List$[1]="MULTIZONE",fdel$,"SCType",fdel$,"TAXREQ",fdel$
		tmp$="N" \ if p61$[34,34]="Y" let tmp$="Y"
		webstr$=tmp$,fdel$,str$(SCType),fdel$
		tmp$="N"\if p61$[115,115]="Y" let tmp$="Y"
		webstr$=webstr$+tmp$+fdel$
		List$[2]=webstr$ 
		list$[3]=esdel$
		!
		call AddToStr(e$,rstr$,List$[])
		if debugdetail
			dmsg$="System Flags sent "+Message$ \ Call updatelog(debug)
		Endif
		! end of sysflags

	case "COPYSHIPTO" ! copy Shiplist						doc=SHL-CopyShipLists.doc
		! send from/to cust and overwrite - FOR EDIT MODE
		GAct=1 ! ok
		ReturnStatus=1
		Message$="OK"
		
		Clear List$[]
		Call DXGet("FRCUSTID",tmp$)
		X2=tmp$
		Cust$=X2 Using "######"
		Call GetCust()
		If cur<0
			ReturnStatus=0
			Message$="CUSTOMER "+Cust$+" NOT FOUND"
			Goto CPPPDone
		Endif
		FCustNo=Cust$
		Call DXGet("TOCUSTID",tmp$)
		X2=tmp$
		if x2=FCustNo
			ReturnStatus=0
			Message$="CANNOT COPY TO SAME CUSTOMER"
			Goto CPPPDone
		Endif
		Cust$=X2 Using "######"
		Call GetCust()
		If cur<0
			ReturnStatus=0
			Message$="CUSTOMER "+Cust$+" NOT FOUND"
			Goto CPPPDone
		Endif
		tCustNo=Cust$
		call dxget("BSHIPTO",tmp$)
		SShipto=tmp$
		CALL DXGET("ESHIPTO",tmp$)
		EShipto=tmp$
		if EShipto<SShipto
			ReturnStatus=0
			Message$="INVALID SHIPLIST RANGE!"
			Goto CPPPDone
		Endif
		! call routine to do copy
		call cpslrecs()
		CPPPDone: ! 
		
		if debugdetail
			dmsg$="Copy From "+Str$(FCustNo)+" TO "+Str$(TCustNo)+" "+Str$(SShipto)+" "+Str$(EShipto)+" "+Message$ \ Call updatelog(debug)
		Endif
		! end of copy
	case "GETSLSM" !	WILL ONLY SELECT FROM DROPLIST		doc=
		! validdate slsm USED IN EDIT MODE? (or only select from sent droplist?)
		GAct=1 ! ok
		ReturnStatus=1
		Message$="OK"
		call dxget("SLSM",tmp$)
		slsmno=tmp$
		clear list$[]
		List$[0]=bsdel$,"SLSPRSN",fdel$
		List$[1]="ID",fdel$,"NAME",fdel$
		if slsmno<>0
			key1$=" ",key1$
			key1$[1,3]=Slsmno Using "###"
			key1$[5]=""
			SMR=filegetsslsmz(e$,SMC,"=",1,key1$,slm.)
			If SMR<0
				ReturnStatus=0
				Message$="Salesperson not on file!"
				goto cslsmdone
			Endif
			list$[2]=Str$(Slsmno),fdel$,RTrim$(slm.Name$),fdel$
		Else ! zero = all
			List$[2]="0",fdel$,"ANY SALESPERSON",fdel$
		Endif
		List$[3]=esdel$
		call AddToStr(e$,rstr$,List$[])
		CSlsmDone: ! 
		
		if debugdetail
			dmsg$="Check Slsm "+Str$(SLSMNO)+" Done "+Message$ \ Call updatelog(debug)
		Endif
		! end of getslsm
	case "ZONES" ! related link - zones						doc=SHL-GetRLZones.doc
		ReturnStatus=1
		Message$="OK"
		Call DXGet("CUSTID",tmp$)
		X2=tmp$
		Cust$=X2 Using "######"
		Call GetCust()
		If cur<0
			ReturnStatus=0
			Message$="CUSTOMER "+Cust$+" NOT FOUND"
			Goto ZCustSHInv
		Endif
		CustNo=Cust$
		Call DXGet("SHIPID",tmp$)
		If tmp$="" goto ZCustSHINV ! none sent
		let shipno=tmp$
		Key1$=" ",key1$
		Key1$=Cust$+"."+ShipNo Using "&&&&&&"
		SLR=FileGetshiplist(e$,SLC,"=",1,Key1$,sl.)
		If SLR<0
			ReturnStatus=0
			Message$="SHIPLIST "+Key1$+" NOT FOUND"
			Goto ZCustSHInv
		Endif
		Clear List$[]
		call SZONE()
		call AddToStr(e$,rstr$,List$[])
		!
		ZCustSHInv: ! customer invalid
		if debugdetail
			dmsg$="Get Zone Info "+Key1$+" Done "+Message$ \ Call updatelog(debug)
		Endif
		! end of zones
	case "KEYWORDS" ! related link keywords					doc=SHL-GetRLKeywords.doc
		ReturnStatus=1
		Message$="OK"
		Call DXGet("CUSTID",tmp$)
		X2=tmp$
		Cust$=X2 Using "######"
		Call GetCust()
		If cur<0
			ReturnStatus=0
			Message$="CUSTOMER "+Cust$+" NOT FOUND"
			Goto KCustSHInv
		Endif
		CustNo=Cust$
		Call DXGet("SHIPID",tmp$)
		If tmp$="" goto KCustSHINV ! none sent
		let shipno=tmp$
		Key1$=" ",key1$
		Key1$=Cust$+"."+ShipNo Using "&&&&&&"
		SLR=FileGetshiplist(e$,SLC,"=",1,Key1$,sl.)
		If SLR<0
			ReturnStatus=0
			Message$="SHIPLIST "+Key1$+" NOT FOUND"
			Goto KCustSHInv
		Endif
		Clear List$[]
		Call GetKeyWords()
		call AddToStr(e$,rstr$,List$[])
		KCustSHInv: ! NG
		if debugdetail
			dmsg$="Get Keyword Info "+Key1$+" Done "+Message$ \ Call updatelog(debug)
		Endif
		! end of keywords
	case "BUDGETPO" ! related link budgets/blanketpo		doc=SHL-GetRLBudget.doc
		ReturnStatus=1
		Message$="OK"
		Call DXGet("CUSTID",tmp$)
		X2=tmp$
		Cust$=X2 Using "######"
		Call GetCust()
		If cur<0
			ReturnStatus=0
			Message$="CUSTOMER "+Cust$+" NOT FOUND"
			Goto BCustSHInv
		Endif
		CustNo=Cust$
		Call DXGet("SHIPID",tmp$)
		If tmp$="" goto BCustSHINV ! none sent
		let shipno=tmp$
		Key1$=" ",key1$
		Key1$=Cust$+"."+ShipNo Using "&&&&&&"
		SLR=FileGetshiplist(e$,SLC,"=",1,Key1$,sl.)
		If SLR<0
			ReturnStatus=0
			Message$="SHIPLIST "+Key1$+" NOT FOUND"
			Goto BCustSHInv
		Endif
		Clear List$[]
		Call GetBInfo()
		call AddToStr(e$,rstr$,List$[])
		BCustSHInv: ! 
		if debugdetail
			dmsg$="Get Budget Info "+Key1$+" Done "+Message$ \ Call updatelog(debug)
		Endif
		! end of budgetpo
	case "DELSHIPLIST" ! delete it							doc=SHL-DelShipList.doc
		ReturnStatus=1
		Message$="OK"
		Call DXGet("CUSTID",tmp$)
		X2=tmp$
		Cust$=X2 Using "######"
		Call GetCust()
		If cur<0
			ReturnStatus=0
			Message$="CUSTOMER "+Cust$+" NOT FOUND"
			Goto DCustSHInv
		Endif
		CustNo=Cust$
		Call DXGet("SHIPID",tmp$)
		If tmp$="" goto DCustSHINV ! none sent
		let shipno=tmp$
		Key1$=" ",key1$
		Key1$=Cust$+"."+ShipNo Using "&&&&&&"
		SLR=FileGetshiplist(e$,SLC,"=",1,Key1$,sl.)
		If SLR<0
			ReturnStatus=0
			Message$="SHIPLIST "+Key1$+" NOT FOUND"
			Goto DCustSHInv
		Endif
		Call DelShipto()
		DCustSHInv: ! 
		if debugdetail
			dmsg$="Delete Shiplist "+Key1$+" Done "+Message$ \ Call updatelog(debug)
		Endif
		! end of DELSHIPLIST
	case "SUBMITSHPL" ! submit it							doc=SHL-SubmitShipList.doc
		ReturnStatus=1
		Message$="OK"
		Close #SLC ! close readonly
		SLC=OpenFile(2112,IntCo) \ if SLC=-1 Error 42 ! Shiplist RW
		Call DXGet("CUSTID",tmp$)
		X2=tmp$
		Cust$=X2 Using "######"
		Call GetCust()
		If cur<0
			ReturnStatus=0
			Message$="CUSTOMER "+Cust$+" NOT FOUND"
			Goto ECustSHInv
		Endif
		CustNo=Cust$
		Call DXGet("SHIPID",tmp$)
		If tmp$="" goto ECustSHINV ! none sent
		let shipno=tmp$
		Key1$=" ",key1$
		Key1$=Cust$+"."+ShipNo Using "&&&&&&"
		SLR=FileGetshiplist(e$,SLC,"=",1,Key1$,sl.)
		If SLR<0
		  If Slr=-1 ! not found - okay to add
			Clear sl.
		  Else ! something else bad
		    ReturnStatus=0
			Message$=E$
			goto ECustSHINV
		  Endif
		Endif
		Call EdtShipto()
		ECustSHInv: ! 
		if debugdetail
			dmsg$="Submit Shiplist "+Key1$+" Done "+Message$ \ Call updatelog(debug)
		Endif
		! end of SUBMITSHPL
	case "SALESHIST" ! shiplist sales(total)				doc=SHL-GetSalesHistory.doc
		ReturnStatus=1
		Message$="OK"
		Call DXGet("CUSTID",tmp$)
		X2=tmp$
		Cust$=X2 Using "######"
		Call GetCust()
		If cur<0
			ReturnStatus=0
			Message$="CUSTOMER "+Cust$+" NOT FOUND"
			Goto CustSLSInv
		Endif
		CustNo=Cust$
		Call DXGet("SHIPID",tmp$)
		If tmp$="" goto CustSLSInv ! none sent
		let shipno=tmp$
		Key1$=" ",key1$
		Key1$=Cust$+"."+ShipNo Using "&&&&&&"
		SLR=FileGetshiplist(e$,SLC,"=",1,Key1$,sl.)
		If SLR<0
			ReturnStatus=0
			Message$="SHIPLIST "+Key1$+" NOT FOUND"
			Goto CustSLSInv
		Endif
		Clear List$[]
		Call CSLSales(e$,List$[],maxcnt,intCo,ReturnStatus,Message$)
		call AddToStr(e$,rstr$,List$[])
		CustSLSInv: ! no good
		if debugdetail
			dmsg$="Send Shiplist Sales "+Key1$+" Done "+Message$ \ Call updatelog(debug)
		Endif
		! end of saleshist
	case "OORDERS"  ! open orders							doc=SHL-GetOOrders.doc
		ReturnStatus=1
		Message$="OK"
		Call DXGet("CUSTID",tmp$)
		X2=tmp$
		Cust$=X2 Using "######"
		Call GetCust()
		If cur<0
			ReturnStatus=0
			Message$="CUSTOMER "+Cust$+" NOT FOUND"
			Goto CustSLOInv
		Endif
		CustNo=Cust$
		Call DXGet("SHIPID",tmp$)
		If tmp$="" goto CustSLOInv ! none sent
		let shipno=tmp$
		Key1$=" ",key1$
		Key1$=Cust$+"."+ShipNo Using "&&&&&&"
		SLR=FileGetshiplist(e$,SLC,"=",1,Key1$,sl.)
		If SLR<0
			ReturnStatus=0
			Message$="SHIPLIST "+Key1$+" NOT FOUND"
			Goto CustSLOInv
		Endif
		Clear List$[]
		call OOrders()
		! call AddToStr(e$,rstr$,List$[])
		CustSLOInv: ! ng
		if debugdetail
			dmsg$="Send Shiplist Orders "+Key1$+" Done "+Message$ \ Call updatelog(debug)
		Endif
		! end of OOrders
	case "BOORDERS"  ! open back orders						doc=SHL-GetBOrders.doc
		ReturnStatus=1
		Message$="OK"
		Call DXGet("CUSTID",tmp$)
		X2=tmp$
		Cust$=X2 Using "######"
		Call GetCust()
		If cur<0
			ReturnStatus=0
			Message$="CUSTOMER "+Cust$+" NOT FOUND"
			Goto CustSLBInv
		Endif
		CustNo=Cust$
		Call DXGet("SHIPID",tmp$)
		If tmp$="" goto CustSLBInv ! none sent
		let shipno=tmp$
		Key1$=" ",key1$
		Key1$=Cust$+"."+ShipNo Using "&&&&&&"
		SLR=FileGetshiplist(e$,SLC,"=",1,Key1$,sl.)
		If SLR<0
			ReturnStatus=0
			Message$="SHIPLIST "+Key1$+" NOT FOUND"
			Goto CustSLBInv
		Endif
		Clear List$[]
		call OOrders()
		! call AddToStr(e$,rstr$,List$[])
		CustSLBInv: ! ng
		if debugdetail
			dmsg$="Send Shiplist BackOrders "+Key1$+"Done "+Message$ \ Call updatelog(debug)
		Endif
		! end of BOOrders
	case "QUOTES"  ! open Quote								doc=SHL-GetQuotes.doc
		ReturnStatus=1
		Message$="OK"
		Call DXGet("CUSTID",tmp$)
		X2=tmp$
		Cust$=X2 Using "######"
		Call GetCust()
		If cur<0
			ReturnStatus=0
			Message$="CUSTOMER "+Cust$+" NOT FOUND"
			Goto CustSLQInv
		Endif
		CustNo=Cust$
		Call DXGet("SHIPID",tmp$)
		If tmp$="" goto CustSLQInv ! none sent
		let shipno=tmp$
		Key1$=" ",key1$
		Key1$=Cust$+"."+ShipNo Using "&&&&&&"
		SLR=FileGetshiplist(e$,SLC,"=",1,Key1$,sl.)
		If SLR<0
			ReturnStatus=0
			Message$="SHIPLIST "+Key1$+" NOT FOUND"
			Goto CustSLQInv
		Endif
		Clear List$[]
		call OOrders()
		! call AddToStr(e$,rstr$,List$[])
		CustSLQInv: ! ng
		if debugdetail
			dmsg$="Send Shiplist quotes "+Key1$+" Done "+Message$ \ Call updatelog(debug)
		Endif
		! end of Quotes
	case "SUBMITBPO" ! submit budget/po						doc=SHL-SubmitBudget.doc
		ReturnStatus=1
		Message$="OK"
		Try Close #SLC ELSE REM
		SLC=OpenFile(2112,IntCo) \ if SLC=-1 Error 42 ! Shiplist as RW
		Call DXGet("CUSTID",tmp$)
		X2=tmp$
		Cust$=X2 Using "######"
		Call GetCust()
		If cur<0
			ReturnStatus=0
			Message$="CUSTOMER "+Cust$+" NOT FOUND"
			Goto SBCustSLPInv
		Endif
		CustNo=Cust$
		Call DXGet("SHIPID",tmp$)
		If tmp$="" goto SBCustSLPInv ! none sent
		let shipno=tmp$
		Key1$=" ",key1$
		Key1$=Cust$+"."+ShipNo Using "&&&&&&"
		SLR=FileGetshiplist(e$,SLC,"=",1,Key1$,sl.)
		If SLR<0
			ReturnStatus=0
			Message$="SHIPLIST "+Key1$+" NOT FOUND"
			Goto SBCustSLPInv
		Endif
		call SVBUDG()
		SBCustSLPInv: ! ng
		if debugdetail
			dmsg$="Submit Budget "+Key1$+" Done "+Message$ \ Call updatelog(debug)
		Endif
		! end of SUBMITBPO
	case "SUBMITZNS" ! submit zone							doc=SHL-SubmitZones.doc
		ReturnStatus=1
		Message$="OK"
		Try Close #SLC ELSE REM
		SLC=OpenFile(2112,IntCo) \ if SLC=-1 Error 42 ! Shiplist as RW
		Call DXGet("CUSTID",tmp$)
		X2=tmp$
		Cust$=X2 Using "######"
		Call GetCust()
		If cur<0
			ReturnStatus=0
			Message$="CUSTOMER "+Cust$+" NOT FOUND"
			Goto SBCustSLZInv
		Endif
		CustNo=Cust$
		Call DXGet("SHIPID",tmp$)
		If tmp$="" goto SBCustSLZInv ! none sent
		let shipno=tmp$
		Key1$=" ",key1$
		Key1$=Cust$+"."+ShipNo Using "&&&&&&"
		SLR=FileGetshiplist(e$,SLC,"=",1,Key1$,sl.)
		If SLR<0
			ReturnStatus=0
			Message$="SHIPLIST "+Key1$+" NOT FOUND"
			Goto SBCustSLZInv
		Endif
		Call SVZones()
		SBCustSLZInv: ! ng
		if debugdetail
			dmsg$="Submit Zone "+Key1$+" Done "+Message$ \ Call updatelog(debug)
		Endif
		! end of SUBMITZNS
	case "SUBMITKWD" ! submit keywords						doc=SHL-SubmitKeywords.doc
		ReturnStatus=1
		Message$="OK"
		Call DXGet("CUSTID",tmp$)
		X2=tmp$
		Cust$=X2 Using "######"
		Call GetCust()
		If cur<0
			ReturnStatus=0
			Message$="CUSTOMER "+Cust$+" NOT FOUND"
			Goto SBCustSLKInv
		Endif
		CustNo=Cust$
		Call DXGet("SHIPID",tmp$)
		If tmp$="" goto SBCustSLKInv ! none sent
		let shipno=tmp$
		Key1$=" ",key1$
		Key1$=Cust$+"."+ShipNo Using "&&&&&&"
		SLR=FileGetshiplist(e$,SLC,"=",1,Key1$,sl.)
		If SLR<0
			ReturnStatus=0
			Message$="SHIPLIST "+Key1$+" NOT FOUND"
			Goto SBCustSLKInv
		Endif
		Call SVKYWRD()
		SBCustSLKInv: ! ng
		if debugdetail
			dmsg$="Submit Keywords "+Key1$+" Done "+Message$ \ Call updatelog(debug)
		Endif
		! end of SUBMITKWD
	case "SPLITCOMMISSION"
		ReturnStatus=1
		Message$="OK"
		Call DXGet("CUSTID",tmp$)
		X2=tmp$
		Cust$=X2 Using "######"
		Call GetCust()
		If cur<0
			ReturnStatus=0
			Message$="CUSTOMER "+Cust$+" NOT FOUND"
			goto EndSplitComission
		Endif
		CustNo=Cust$
		Call DXGet("SHIPID",tmp$)
		let shipno=tmp$
		Key1$=" ",key1$
		Key1$=Cust$+"."+ShipNo Using "&&&&&&"
		SLR=FileGetshiplist(e$,SLC,"=",1,Key1$,sl.)
		If SLR<0
			ReturnStatus=0
			Message$="SHIPLIST "+Key1$+" NOT FOUND"
		else
			Call ProcessCommissionSplits()
		Endif
		EndSplitComission: !
		! end of Split Commission

  end select
 
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)

  if debugdetail
		dmsg$="End of Program serp105" \ Call updatelog(debug)
  Endif
else
 include "src/callmainerrnet.inc"
end try
end  ! end of Main processing
!
!--------------------------------------------------------------------

! subs start now
!------------------------------------------------------------------------------------------
Sub OpenFiles()

 Try
    !
	CTLC = OpenFile(-9999,intCo) \ If CTLC = -1 Error 42 !control
	ZNC=OpenFile(-1920,IntCo) \ If ZNC=-1 Error 42 ! Zone file
	TTC=OpenFile(-928,IntCo) \ IF TTC=-1 Error 42 ! taxtype file
	CUC=OpenFile(-1808,IntCo) \ If CUC=-1 Error 42 ! customer
	SMC=OpenFile(-1824,IntCo) \ if SMC=-1 Error 42 ! Salesman file
	SLC=OpenFile(-2112,IntCo) \ if SLC=-1 Error 42 ! Shiplist
	WHI = OpenFile(-2768,IntCo) \ if whi = -1 Error 42 ! wh info file (rec 0 fix)
	TXC=OpenFile(-2176,IntCo) \ if TXC=-1 Error 42 ! tax code
	AOC=OpenFile(-2832,IntCo) \ if AOC=-1 Error 42 ! addon/sales area
	Ch_Div=OpenFile(-688,intCo) \ If Ch_div = -1 Error 42 !DIVISION 
	If p61$[34,34]="Y"
		Tmp$ = "3/CSZONE" + Str$(IntCo)
		Call FindF(tmp$,H)
		If Not(H)
		  Let P61$[34,34]="N" ! NO FILE - FLAG=N
		Else ! it's there open it
		  CSZ=OpenFile(-9997,IntCo) \ if CSZ=-1 Error 42 ! cszone
		End If 
	Endif
	VMC=OpenFile(-2400,Intco) \ if vmc=-1 Error 42 ! vendor
 	if debugdetail
		dmsg$="Files Opened" \ Call updatelog(debug)
    Endif
 else
    include "src/callsuberr.inc"
  end try
end sub ! openfiles
! 
!--------------------------------------------------------------------
Sub updatelog(debug)                                        
    If not(debug) Exit Sub                                    
	System "echo ''" + msc$(0) + " UID "+Userid$+" " + dmsg$ + "'' >> " + dblog$
End Sub 
! 
!--------------------------------------------------------------------

Sub GetCust()
! get Customer data - 
! PASS IN CUST$
  Try
	Dim Ckey$[60]
	Dim 2%,PRTYPE
	Dim 3%,CUR
	ckey$=" ",cKey$
	cKey$=Cust$
	
		CUR=filegetcust(e$,CUC,"=",1,CKey$,cust.)
		If CUR<0
			clear cust.
			cust.Name$="CUSTOMER NOT FOUND"+Blank$
		Endif

  else
    include "src/callsuberr.inc"
  end try
end sub ! GetCust
! 
!--------------------------------------------------------------------
Function chkDateFrmt$(DIn$)
! see if date in is MM/DD/YY or MM/DD/YYYY
! if not make it MM/DD/YYYY
Try
	Dim DOut$[10],X$[20]
	Dim 1%,Mth,Day
	Dim 3%,Yr
	If DIn$[1,2]="00" or UCase$(DIn$[1,4])="NONE" or DIn$="0"
	  Let DOut$=UCase$(DIn$)
	  Exit Function DOut$ ! no reformat - send back as is
	Endif
	Mth=DIn$[1,2];Day=Din$[4,5];Yr=DIn$[7]
	if Din$[2,2]="/" or DIn$[2,2]="-" ! 1 digit month
	  Let Mth=DIn$[1,1]
	  If DIn$[4,4]="/" or DIn$[4,4]="-" ! 1 digit day
	     Let Day=DIn$[3,3]
		 Let Yr=DIn$[5]
	  Else
	     Let Day=Din$[3,4] ! try 2 digit
		 Let Yr=DIn$[6]
	  Endif
	Endif
	X$=Mth Using "&&"
	X$[3,4]=Day Using "&&"
	If Yr>1000 ! 4
		X$[5]=Yr Using "&&&&"
	Else ! 2 digit
		If YR<67 let yr=2000+yr Else Let Yr=yr+1900
		X$[5]=Yr Using "####"
	Endif
	Dout$=X$[1,2]+"/"+X$[3,4]+"/"+X$[5]
 else
    include "src/callsuberr.inc"
  end try
end Function DOut$ ! chkDateFrmt$
! 
!--------------------------------------------------------------------
Sub SHMain()
! display all Shiplist data already read SLR, sl.
! in multiple sections 1:Name/address, 2:Misc, 3:shipping info, 4:UDA
  Try
	Dim UDAFIELDNAMES$[56],D2$[10]
	MAT  READ #ctlc,68,0;UDAFIELDNAMES$;
	READ #ctlc,18,210;D2$; ! SLS AREA
	if d2$="" or d2$[1,10]=Blank$[1,10] let d2$="SLS AREA"
	tmp$=UDAFIELDNAMES$[1,14]
	if tmp$="" or tmp$=blank$[1,14] let UDAFIELDNAMES$[1,14]="UDA1"+Blank$
	tmp$=UDAFIELDNAMES$[15,28]
	if tmp$="" or tmp$=blank$[1,14] let UDAFIELDNAMES$[15,28]="UDA2"+Blank$
	tmp$=UDAFIELDNAMES$[29,42]
	if tmp$="" or tmp$=blank$[1,14] let UDAFIELDNAMES$[29,42]="UDA3"+Blank$
	tmp$=UDAFIELDNAMES$[43,56]
	if tmp$="" or tmp$=blank$[1,14] let UDAFIELDNAMES$[43,56]="UDA4"+Blank$
	Clear List$[]
	tmpcnt=maxcnt
	List$[0]=bsdel$,"SHIPLIST",fdel$
	WebStr$="ID",fdel$,"NAME",fdel$,"ADDR1",fdel$,"ADDR2",fdel$
	WebStr$=WebStr$,"CITY",fdel$,"STATE",fdel$,"ZIPCODE",fdel$
	webstr$=webstr$,"COUNTRY",fdel$,"CONTACT",fdel$,"PHONE",fdel$
	List$[1]=webstr$
	row=2
	
	webstr$=key1$[8],fdel$,RTrim$(sl.Name$),fdel$,RTrim$(sl.Address$),fdel$
	webstr$=webstr$,RTrim$(sl.OptAddress$),fdel$,RTrim$(sl.City$),fdel$
	webstr$=webstr$,sl.State$,fdel$,sl.ZipCode$,fdel$,RTrim$(sl.Country$),fdel$
	webstr$=webstr$,RTrim$(sl.Contact$),fdel$,RTrim$(sl.PhoneNumber$),fdel$
	List$[row]=webstr$
	row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	List$[row]=esdel$
	row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	! section 2 - slsm,routing,inv,whse,slsarea
	If D2$="" or D2$=Blank$[1,10] or D2$="SALES AREA" let D2$="SALESAREA"
	List$[row]=bsdel$,"CONTROL",fdel$
	row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	webstr$="SLSPRSN",fdel$,"NAME",fdel$,"WHSE",fdel$,"WHNAME",fdel$,"ROUTING",fdel$
	webstr$=webstr$,RTrim$(D2$),fdel$,"DESC",fdel$,"INVSHIP",fdel$,"VENDID",fdel$
	webstr$=webstr$,"VENDNAME",fdel$
	webstr$=webstr$,"DIV",fdel$
	webstr$=webstr$,"DIVNAME",fdel$
	rem webstr$=webstr$,"RESIDENTIAL",fdel$
 rem    webstr$=webstr$,"SEND EMAIL",fdel$
	rem webstr$=webstr$,"EMAIL ADDRESS",fdel$
	List$[row]=webstr$
	row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	! sales person
	tmp$="NOT ASSIGNED"
	if sl.Slsm>0
	   let tmpch=SMC ! -1
	   let tmp$=getslsmname$(tmpch,sl.Slsm,intco)
	Endif
	webstr$=Str$(sl.Slsm),fdel$,RTrim$(tmp$),fdel$ ! slsm # / name
	tmp$="NOT ASSIGNED"
	if sl.DefaultWhse>0
		WHR=sl.DefaultWhse-1
		Read record #WHI,WHR,0;whi.;
		tmp$=whi.WhName$
	Endif
	Webstr$=webstr$,Str$(sl.DefaultWhse),fdel$,rtrim$(tmp$),fdel$ ! whse / name
	webstr$=webstr$,RTrim$(sl.Routing$),fdel$
	tmp$="NOT ASSIGNED"
	if sl.SalesZone>0 AND sl.SalesZone<11
		LET ZS$=" ",ZS$;ZNDSC$=" ",ZNDSC$                
		LET ZS$="     0"                                 
		SEARCH #AOC,2,1;ZS$,R6,E 
		IF Not(E)                              
			MAT  READ #AOC,R6,26;ZNDSC$;
		Endif
		tmp$=ZNDSC$[sl.SalesZone*10-9,sl.SalesZone*10]
	Endif
	webstr$=webstr$,Str$(sl.SalesZone),fdel$,RTrim$(tmp$),fdel$ ! sls area / desc
	tmp$="N" \ if UCase$(sl.ShpWithInvoiceYN$)="Y" let tmp$="Y"
	webstr$=webstr$,tmp$,fdel$
	vname$="NOT ASSIGNED"
	if sl.VendNum>0 and sl.VendNum<=999999
		tmp$=sl.VendNum using "######"
		Search #VMC,2,1;tmp$,VMR,e
		if e
			vname$="VENDOR NOT FOUND"
		Else
			mat read #vmc,vmr,0;VName$;
		Endif
	Else
		sl.Vendnum=0
	Endif
	webstr$=webstr$,Str$(sl.VendNum),fdel$,RTrim$(VName$),fdel$
	webstr$=webstr$,Str$(sl.ddiv),fdel$
	let tmpch=ch_div
    let divname$=getdivname$(tmpch,sl.dDiv,intco)
	webstr$=webstr$,rtrim$(divname$),fdel$ ! mtg
	rem was ups info
	List$[row]=webstr$
	row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	List$[row]=esdel$
	row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	! section 3 - shipping info, dclvl
	List$[row]=bsdel$,"SHIPPING",fdel$
	row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	webstr$="DCLVL",fdel$,"SHIPI1",fdel$,"SHIPI2",fdel$
	webstr$=webstr$,"SHIPI3",fdel$,"SHIPI4",fdel$
	webstr$=webstr$,"RESIDENTIAL",fdel$
    webstr$=webstr$,"SEND EMAIL",fdel$
	webstr$=webstr$,"EMAIL ADDRESS",fdel$
	List$[row]=webstr$
	row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	webstr$=Str$(sl.DeliveryChrgLvl),fdel$
	webstr$=webstr$,RTrim$(sl.ShipInstLine1$),fdel$
	webstr$=webstr$,RTrim$(sl.ShipInstLine2$),fdel$
	webstr$=webstr$,RTrim$(sl.ShipInstLine3$),fdel$
	webstr$=webstr$,RTrim$(sl.ShipInstLine4$),fdel$
	if sl.residential = 0
	Webstr$=webstr$,"N",fdel$
	else
    Webstr$=webstr$,"Y",fdel$
	endif
    if sl.sendemail = 0
	Webstr$=webstr$,"N",fdel$
	else
    Webstr$=webstr$,"Y",fdel$
	endif
    Webstr$=webstr$,rtrim$(sl.email$),fdel$
	List$[row]=webstr$
	row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	List$[row]=esdel$
	row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	! section 4 - tax info, UDA's
	List$[row]=bsdel$,"TAXUDA",fdel$
	row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	WebStr$="TAXCODE",fdel$,"DESC",fdel$,"TAXTYPE",fdel$,"DESC2",fdel$
	webstr$=webstr$,RTrim$(UDAFIELDNAMES$[1,14]),fdel$ !  UDA1=Numeric
	webstr$=webstr$,RTrim$(UDAFIELDNAMES$[15,28]),fdel$,RTrim$(UDAFIELDNAMES$[29,42]),fdel$
	Webstr$=webstr$,RTrim$(UDAFIELDNAMES$[43,56]),fdel$ ! all alpha
	List$[row]=webstr$
	row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	tmp$="NOT ASSIGNED"
	if sl.TaxCode>0
		! TAX CODE
		let tmpch=-1
		let tmp$=gettaxcdd$(tmpch,sl.TaxCode,intco)
	endif
	webstr$=Str$(sl.TaxCode),fdel$,RTrim$(tmp$),fdel$
	tmp$="NOT ASSIGNED"
	if sl.TaxType>0
		! custtax TYPE
		let tmpch=-1
		let tmp$=getcusttaxtyd$(tmpch,sl.TaxType,intco)
	Endif
	webstr$=webstr$,Str$(sl.TaxType),fdel$,RTrim$(tmp$),fdel$
	tmp$=Str$(sl.UdaNumeric)
	if tmp$[1,1]="0" let tmp$="0" ! get's garbage!?
	webstr$=webstr$,tmp$,fdel$
	webstr$=webstr$,RTrim$(sl.UdaAlpha1$),fdel$
	webstr$=webstr$,RTrim$(sl.UdaAlpha2$),fdel$
	webstr$=webstr$,RTrim$(sl.UdaAlpha3$),fdel$
	List$[row]=webstr$
	row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	List$[row]=esdel$
	row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	
  else
    include "src/callsuberr.inc"
  end try
end sub ! SHMain
! 
!--------------------------------------------------------------------
Sub cpslrecs()
! copy shiplists from customer to customer
! this is for edit mode!
  Try
	dim k1$[60],k2$[60],k3$[60],mode$[4]
	Dim 3%
	Close #SLC ! close Read-only
	SLC=OpenFile(2112,IntCo) \ if SLC=-1 Error 42 ! Shiplist
	
	if p61$[34,34]="Y" ! reopen Multizone as rw
		Try Close #CSZ  Else REM
		Tmp$ = "3/CSZONE" + Str$(IntCo)
		Call FindF(tmp$,H)
		If Not(H)
		  Let P61$[34,34]="N" ! NO FILE - FLAG=N
		Else ! it's there open it
		  CSZ=OpenFile(9997,IntCo) \ if CSZ=-1 Error 42
		End If 
	Endif
	
	dim csz. as cszone
	Dim fsl. as shiplist
	k1$=" ",k1$
	K1$[1,6]=FCustNo Using "######"
	K1$[7]="."
	K1$[8]=SShipto using "&&&&&&"
	mode$=">=" ! to start ONLY
	Numrec=0
	do
		FSLR=filegetshiplist(e$,SLC,mode$,1,K1$,fsl.)
		if FSLR<0 exit do
		MODE$=">" ! switch to NEXT
		X2=K1$[1,6] \ if x2<>FCustno exit do
		x2=k1$[8] \ if x2>EShipto exit do
		k2$=K1$
		k2$[1,6]=TCustNo using "######" ! replace with tocust
		Search #SLC,2,1;k2$,X3,e
		if e=1 ! not there - add it (ONLY WAY - NO OVERWRITE)
			read record #SLC,FSLR,0;sl.; ! read as "regular"
			sl.ShiplistNumber=k2$ ! shiplist #
			sl.Name$=UCase$(cust.name$)+Blank$ ! what PM does! ! move to cust.name in!?
			! clear sl.available$
			X3=0
			X3=fileupdateshiplist(e$,SLC,"a",x3,sl.)
			if x3<0 ! problem
				Returnstatus=0
				Message$=E$
				exit do
			Endif
			Numrec=numrec+1
			 KEYWRDCPU: REM " auto update for Copied Records (name keywrds)
			 LET X1=8;J1=x3;X1[1]=1 ! MODE,RECORD
			 CALL "CSLKEYWRD.dl4",K2$,J1,X1[1],X1,e$,IntCo
			If P61$[34,34]="Y" ! try a multizone copy
				K3$=" ",k3$
				K3$=K1$
				Search #CSZ,2,1;k3$,R,E
				if not(E) ! found from
					Read Record #CSZ,R,0;csz.;
					Let K3$[1,6]=TCustNo using "######" ! replace with tocust
					Search #CSZ,2,1;k3$,R[1],E
					if E=1 ! not found
						Let E=2;R[1]=0
						Search #CSZ,1,0;K3$,R[1],E
						If Not(E)
							csz.Customer=TCustNo
							csz.SpareFiller$=Blank$[1,5] ! not all the way!
							Write record #CSZ,R[1],0;csz.;
							Search #CSZ,4,1;K3$,R[1],E
							If E
								ReturnStatus=0
								Message$="Search Error "+Str$(E)+" adding CSZONE Key"
							Endif
						Else
							ReturnStatus=0
							Message$="Search Error "+Str$(E)+" adding CSZONE Record"
						Endif ! of got new record
					Endif ! of no new found
				Endif ! of found from
			Endif ! of uses cszone
		Endif ! of add new
	Loop
	if returnstatus=1 ! all ok
		Message$="ADDED "+Str$(numrec)+" Ship List records"
	Endif
  else
    include "src/callsuberr.inc"
  end try
end sub ! cpslrecs
! 
!--------------------------------------------------------------------
Sub SZone()
! get zone info - System Flag driven - SEND BOTH VERSIONS
! the web team looks at flag to display coorect one
  Try
	Dim CustKey$[64],ZNKey$[60],mode$[5]
	Dim 3%
	dim Zone. as zonefle
	dim CSZone. as cszone

	mat read #CTLC,61,0;P61$; ! system flags
	If P61$[34,34]<>"Y" Let P61$[34,34]="N"
	ZNChan=openfile(-1920,IntCo) \ if ZNCHAN=-1 error 42
	!CSZ=0 ! now open in openfiles!
	!if P61$[34,34]="Y" ! uses cszone
	!  CSZ=OpenFile(-9997,intCo) \ if CSZ= -1 let P61$[34,34]="N" ! not found = not used
	!endif
	tmpcnt=maxcnt
	Clear List$[]
	List$[0]=bsdel$,"SYSFLAG",fdel$
	List$[1]="MZONE",fdel$
	tmp$="N" \ if p61$[34,34]="Y" let tmp$="Y"
	List$[2]=tmp$[1,1],fdel$ ! send system flag as only field
	List$[3]=esdel$
	call AddToStr(e$,rstr$,List$[])
	
	clear List$[]
!
 	List$[0]=bsdel$,"SZONE",fdel$
	! If P61$[34,34]="N" ! send customer ONLY
		 WebStr$="ID",fdel$,"Zone",fdel$,"ZDESC",fdel$,"Stop",fdel$
	 List$[1]=WebStr$
	!
	row=2 ! starting row for data
	if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	ZNKey$=sl.Zone$+Blank$
		ZNKey$[3]=""
		mode$="="
		dir=1
		ZNRec=filegetzonefle(e$,ZNChan,mode$,dir,ZNKey$,Zone.)
		if ZNRec<0 Clear Zone.
		WebStr$=Key1$[8],fdel$ ! shiplist #
		if P61$[34,34]="N" ! customer data
		  WebStr$=WebStr$,RTrim$(sl.Zone$),fdel$,RTrim$(Zone.Desc$),fdel$ ! "zone & desc
		  WebStr$=WebStr$,RTrim$(sl.sStop$),fdel$ ! stop
		else
		  WebStr$=WebStr$,fdel$,fdel$,fdel$ ! "send nulls for zone/stop
		endif
	List$[row]=webstr$
	row=row+1
	if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	List$[row]=esdel$ ! end of section
	row=row+1
	if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	List$[row]=bsdel$,"MZONE",fdel$
	row=row+1
	if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	! Else ! send cszone (all one string)
	 WebStr$="ShipList",fdel$,"LeadTime",fdel$
	 WebStr$=WebStr$,"SunZone",fdel$,"ZDESC0",fdel$,"SunStop",fdel$
	 Webstr$=WebStr$,"MonZone",fdel$,"ZDESC1",fdel$,"MonStop",fdel$
	 WebStr$=WebStr$,"TueZone",fdel$,"ZDESC2",fdel$,"TueStop",fdel$
	 Webstr$=WebStr$,"WedZone",fdel$,"ZDESC3",fdel$,"WedStop",fdel$
	 WebStr$=WebStr$,"ThuZone",fdel$,"ZDESC4",fdel$,"ThuStop",fdel$
	 Webstr$=WebStr$,"FriZone",fdel$,"ZDESC5",fdel$,"FriStop",fdel$
	 WebStr$=WebStr$,"SatZone",fdel$,"ZDESC6",fdel$,"SatStop",fdel$
	 
	! endif - send both - web determines
    List$[row]=WebStr$
	row=row+1
	if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	CustKey$=Key1$
	mode$="=" ! "exact match
	Dir=1 ! "of customer code
	! CustRec=filegetcust(e$,CustChan,mode$,dir,CustKey$,cust.) - it's passed
	if SLR>0
	! if P61$[34,34]="N" ! customer data
		
	  ! Else ! cszone data sent
		!CustKey$=Cust$+".000000" ! use zero shiplist as customer
		mode$="=" ! match only
		Dir=1 ! "cszone dir 1 = Customer No/Shiplist #
		CSRec=0
		If P61$[34,34]="Y" ! "only if there/used
		 CSRec=filegetcszone(e$,CSZ,mode$,dir,CustKey$,CSZone.) 
		endif
		If CSRec<=0 Clear CSZone.

		! WebStr$=CustKey$[1,6],fdel$ ! Customer # in key (sent already)
		WebStr$=CustKey$[8,13],fdel$ ! shiplist number (000000)
		WebStr$=WebStr$,Str$(CSZone.LeadTime),fdel$ ! leadtime
		For tmp1=0 to 6
		  if tmp1=0 let ZNKey$=CSZone.SunZone$ \ tmp2=CSZone.SunStop
		  if tmp1=1 let ZNKey$=CSZone.MonZone$ \ tmp2=CSZone.MonStop
		  if tmp1=2 let ZNKey$=CSZone.TueZone$ \ tmp2=CSZone.TueStop
		  if tmp1=3 let ZNKey$=CSZone.WedZone$ \ tmp2=CSZone.WedStop
		  if tmp1=4 let ZNKey$=CSZone.ThuZone$ \ tmp2=CSZone.ThuStop
		  if tmp1=5 let ZNKey$=CSZone.FriZone$ \ tmp2=CSZone.FriStop
		  If tmp1=6 let ZNKey$=CSZone.SatZone$ \ tmp2=CSZone.SatStop
		  mode$="="
		  dir=1
		  ZNKey$=ZNKey$+"  " \ ZNKey$[3]="" 
		  If ZNKey$>"  "
		    ZNRec=filegetzonefle(e$,ZNChan,mode$,dir,ZNKey$,Zone.)
		  else
		    ZNRec=-1
		  endif
		  if ZNRec<0 Clear Zone.
		  WebStr$=WebStr$,RTrim$(ZNKey$),fdel$,RTrim$(Zone.Desc$),fdel$ ! day zone/desc
		  WebStr$=WebStr$,Str$(tmp2),fdel$ ! day Stop #
		Next tmp1
		
	  ! end if ! " get zone data based on flag (send both sets - populate actual one used)
	    
		
		!
		List$[row]=WebStr$
		row=row+1
		if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	endif ! valid cust rec
	!
	List$[row]=esdel$ ! end of section
	!If CSZ>0 
	!	Try Close #CSZ ELSE REM
	!Endif
	Try Close #ZNChan ELSE REM
  else
    include "src/callsuberr.inc"
  end try
end sub ! SZone
! 
!--------------------------------------------------------------------
Sub GetKeyWords()
! Creates a list of the SHiplist's keywords from cslkeywrd file
!
  try
!
    dim 1%,tmp1,Dir,CKWDir
	dim 2%,tmp2,tmpcnt
    dim 3%,tmp3,CKWRec
	dim bsdel$[20],esdel$[20],rdel$[20],fdel$[20],rstr$[500]
    dim tmp$[200],tmp1$[200],WebStr$[700],Message$[200]
	dim CustKey$[64],CKWKey$[64],Mode$[2],CKWMode$[2],blank$[100]
!
	dim CKW. as cslkeywrd
	! dim cust. as cust - pass it
!
	CKWC=OpenFile(-9972,intCo) \ if CKWC = -1 Error 42 ! cslkeywrd
!
	tmpcnt=maxcnt
	clear List$[]
!
 	List$[0]=bsdel$,"SHIPLISTKEYWORDS",fdel$
	WebStr$="ID",fdel$,"Keyword1",fdel$,"Keyword2",fdel$
	WebStr$=WebStr$,"Keyword3",fdel$,"Keyword4",fdel$
	WebStr$=WebStr$,"Keyword5",fdel$,"Keyword6",fdel$
	WebStr$=WebStr$,"Keyword7",fdel$,"Keyword8",fdel$
	WebStr$=WebStr$,"Keyword9",fdel$,"Keyword10",fdel$
	WebStr$=WebStr$,"Keyword11",fdel$,"Keyword12",fdel$
	WebStr$=WebStr$,"Keyword13",fdel$,"Keyword14",fdel$
	WebStr$=WebStr$,"Keyword15",fdel$,"Keyword16",fdel$
	WebStr$=WebStr$,"Keyword17",fdel$,"NameKeyword1",fdel$
	WebStr$=WebStr$,"NameKeyword2",fdel$
	WebStr$=WebStr$,"Addr1Keyword1",fdel$,"Addr1Keyword2",fdel$
	WebStr$=WebStr$,"Addr2Keyword1",fdel$,"Addr2Keyword2",fdel$
	WebStr$=WebStr$,"CityKeyword",fdel$,"StateKeyword",fdel$
	WebStr$=WebStr$,"ZipCodeKeyword",fdel$,"PhoneKeyword",fdel$
	WebStr$=WebStr$,"ContactKeyword",fdel$,"APPh#Keyword",fdel$
	WebStr$=WebStr$,"APContactKeyWord",fdel$
    List$[1]=WebStr$
	!
	row=2 ! starting row for data
	if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	!
	
	CustKey$=Key1$
	
	mode$="=" ! "exact match
	Dir=1 ! "of customer code
	! CustRec=filegetcust(e$,CustChan,mode$,dir,CustKey$,cust.) - it's passed
	if SLR>0
		CKWKey$=Key1$
		if len(CKWKey$)<7 let CKWKey$=CKWKey$+" " ! cust is 7, shiplist is 13 (.000000)
		CustKey$=Key1$ ! Cust$
		if len(CustKey$)<7 let CustKey$=CustKey$+" " ! "minimum 7 (space after Cust#)
	  	CKWMode$="=" ! "Equal to key
	    CKWDir=1 ! "only 1 dir

	    CKWRec=filegetcslkeywrd(e$,CKWC,CKWMode$,CKWDir,CKWKey$,CKW.)
        if CKWRec<0 or CKWKey$[1,len(CustKey$)]<>CustKey$ Clear CKW.
		!
		if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
		!		
		WebStr$=RTrim$(CustKey$[8]),fdel$ ! Shiplist key
		WebStr$=WebStr$,RTrim$(CKW.Keyword1$),fdel$ ! Note
		WebStr$=WebStr$,RTrim$(CKW.Keyword2$),fdel$ ! Note
		WebStr$=WebStr$,RTrim$(CKW.Keyword3$),fdel$ ! Note
		WebStr$=WebStr$,RTrim$(CKW.Keyword4$),fdel$ ! Note
		WebStr$=WebStr$,RTrim$(CKW.Keyword5$),fdel$ ! Note
		WebStr$=WebStr$,RTrim$(CKW.Keyword6$),fdel$ ! Note
		WebStr$=WebStr$,RTrim$(CKW.Keyword7$),fdel$ ! Note
		WebStr$=WebStr$,RTrim$(CKW.Keyword8$),fdel$ ! Note
		WebStr$=WebStr$,RTrim$(CKW.Keyword9$),fdel$ ! Note
		WebStr$=WebStr$,RTrim$(CKW.Keyword10$),fdel$ ! Note
		WebStr$=WebStr$,RTrim$(CKW.Keyword11$),fdel$ ! Note
		WebStr$=WebStr$,RTrim$(CKW.Keyword12$),fdel$ ! Note
		WebStr$=WebStr$,RTrim$(CKW.Keyword13$),fdel$ ! Note
		WebStr$=WebStr$,RTrim$(CKW.Keyword14$),fdel$ ! Note
		WebStr$=WebStr$,RTrim$(CKW.Keyword15$),fdel$ ! Note
		WebStr$=WebStr$,RTrim$(CKW.Keyword16$),fdel$ ! Note
		WebStr$=WebStr$,RTrim$(CKW.Keyword17$),fdel$ ! Note
		WebStr$=WebStr$,RTrim$(CKW.Keyword18$),fdel$ ! Name 1
		WebStr$=WebStr$,RTrim$(CKW.Keyword19$),fdel$ ! Name 2
		WebStr$=WebStr$,RTrim$(CKW.Keyword20$),fdel$ ! Addr1
		WebStr$=WebStr$,RTrim$(CKW.Keyword21$),fdel$ ! Addr1
		WebStr$=WebStr$,RTrim$(CKW.Keyword22$),fdel$ ! Addr2
		WebStr$=WebStr$,RTrim$(CKW.Keyword23$),fdel$ ! Addr2
		WebStr$=WebStr$,RTrim$(CKW.Keyword24$),fdel$ ! City
		WebStr$=WebStr$,RTrim$(CKW.Keyword25$),fdel$ ! State
		WebStr$=WebStr$,RTrim$(CKW.Keyword26$),fdel$ ! Zip
		WebStr$=WebStr$,RTrim$(CKW.Keyword27$),fdel$ ! Phone
		WebStr$=WebStr$,RTrim$(CKW.Keyword28$),fdel$ ! Contact
		WebStr$=WebStr$,RTrim$(CKW.Keyword29$),fdel$ ! AP Phone
		WebStr$=WebStr$,RTrim$(CKW.Keyword30$),fdel$ ! AP Contact
		List$[row]=WebStr$
		row=row+1
		!
		if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	endif
	Try Close #CKWC Else REM
	!
	List$[row]=esdel$ ! end of section
  else
    include "src/callsuberr.inc"
  end try
  !
end sub ! GetKeyWords
! -------------------------------------------------------------------------------------
Sub GetBInfo()
! send budget Info
  Try
	!
	Clear List$[]
	tmpcnt=maxcnt
	List$[0]=bsdel$,"BUDGETPO",fdel$
	WebStr$="ID",fdel$,"BLKTPO",fdel$,"BUDGDOL",fdel$
	webstr$=webstr$,"BUDGUSED",fdel$,"EPRTYPE",fdel$
	webstr$=webstr$,"DATETYPE",fdel$,"STARTDT",fdel$,"ENDDATE",fdel$
	List$[1]=webstr$
	row=2
	webstr$=Key1$[8,13],fdel$,RTrim$(sl.BlktPo$),fdel$
	webstr$=webstr$,LTrim$(sl.Budget using QMask$),fdel$
	webstr$=webstr$,LTrim$(sl.BudgetUsed using QMask$),fdel$
	webstr$=webstr$,sl.BPExpireType$,fdel$,sl.BudgDateType$,fdel$
	if sl.BPExpireType$="D"
		tmp$="0"
		if sl.BPDateStart>0 let tmp$=PDate$(sl.BPDateStart)
		webstr$=webstr$,RTrim$(tmp$),fdel$
		tmp$="0"
		if sl.BPDateEnd>0 let tmp$=PDate$(sl.BPDateEnd)
		webstr$=webstr$,RTrim$(tmp$),fdel$
	Else ! not date based
		tmp$="0"
		webstr$=webstr$,RTrim$(tmp$),fdel$,RTrim$(tmp$),fdel$
	Endif
	List$[row]=WebStr$
	row=row+1
	!
	if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	List$[row]=esdel$ ! end of section
  else
    include "src/callsuberr.inc"
  end try
  !
end sub ! GetBInfo
! -------------------------------------------------------------------------------------
Sub DelShipto()
! Delete Shiplist
  Try
	Dim 3%
	Close #SLC ! close readonly
	SLC=OpenFile(2112,IntCo) \ if SLC=-1 Error 42 ! Shiplist RW
	Dim J$[60]
	! FIRST SEE IF SALES
	LET CSSLS=0;CUSTNO=ABS(CUSTNO)                       
	LET X1=0;X1[1]=0   ! mode, channel(cslsales)                                  
	CALL "CUSTSHPSALES.dl4",CUSTNO,SHIPNO,X1,X1[1],CSSLS,e$,IntCo 
	If CSSLS ! has sales
	  IF UCA2$[43,43]="Y" ! can delete
		DELCSSALES: REM "delete the sales for shiplist SHIPNO
		LET CSSLS=0;CUSTNO=ABS(CUSTNO)                       
		LET X1=9;X1[1]=0  ! mode                                   
		CALL "CUSTSHPSALES.dl4",CUSTNO,SHIPNO,X1,X1[1],CSSLS,E$,IntCo
	  Else ! cannot delete
		ReturnStatus=0
		Message$="SHIPLIST HAS SALES - Cannot Delete"
		Goto DSDone
	  Endif
	Endif ! has sales - none = no need to delete them
	DELKEYWRD: REM "keyword delete (ALL for Shiplist)
	LET X1=6;j1=1;J4$=key1$   ! mode                                     
	CALL "CSLKEYWRD.DL4",J4$,slr,J1,X1,e$,IntCo 
	IF P61$[34,34]="Y" ! "multi cust/shipto zones
	  LET CUSTNO=0-CUSTNO  ! NEG=Delete                      
	  LET ZONECHAN=CSZ                                           
	  CALL "MXEDCSZONE.DL4",CUSTNO,SHIPNO,cust.name$,sl.name$,ZONECHAN,e$,IntCo
	ENDIF 
	IF P61$[64,64]="Y" ! "ship list last pricing        
	  LET E=3       ! mode = delete shiplist                                     
	  LET CUSTNO=ABS(CUSTNO);X1=0;J$=""                 
	  LET X1[1]=0;X1[2]=0;X1[3]=SLC                      
	  CALL "MX117SLDEL.DL4",CUSTNO,X1,X1,SHIPNO,J$,X1[],X1,E,e$,IntCo
	ENDIF  
	CustNo=ABS(CustNo) ! make sure not changed
	x3=fileupdateshiplist(e$,SLC,"d",SLR,sl.)
	if x3<0 ! problem
		ReturnStatus=0
		Message$=E$
	Endif
	DSDone: ! all done
  else
    include "src/callsuberr.inc"
  end try
  !
end sub ! DelShipto
! -------------------------------------------------------------------------------------
Sub EdtShipto()
! Add/Edit Shiplist - if SLR<0 = NEW SHIPLIST  >0 = EXISTING
  Try
	DIM 2%,Curdate,K1$[60]
	Dim 3%
	dim csl. as shiplist
	tmp$=Tim(8) using "&&" ! year
	tmp$[3]=Tim(9) using "&&" ! month
	tmp$[5]=Tim(10) using "&&" ! day
	curdate=tmp$[1,6]
	!call dxsave(0,"tmp/105in.txt!")
	if slr<=0 ! new - set up / clear string fields not sent
		sl.ShiplistNumber=key1$ ! key - cccccc.ssssss
		sl.DeliveryCode$=Blank$
		sl.SpareNotused2$=Blank$
		sl.SpareNotUsed$=Blank$
		! sl.Available$=Blank$[1,2]
		sl.BPExpireType$=blank$
		sl.BudgDateType$=blank$
		sl.BlktPo$=blank$
		sl.DateEdit=Curdate ! date added
		! field added in native on task #5588 - !!!
		sl.ShipInstLine5$=Blank$
		sl.ShipInstLine6$=Blank$
		sl.ShipInstLine7$=Blank$
		sl.ShipInstLine8$=Blank$
		IF CUSTOM_CUSTOMER$="MORRISETTE" LET sl.DeliveryChrgLvl=1
		If CUSTOM_CUSTOMER$ = "HTBERRY"  Let sl.UdaNumeric=1 
		if P61$[34,34]<>"Y" sl.zone$=cust.zonenumber$
		slr=0
	Else
		read record #SLC,SLR,0;csl.; ! FOR change address compare
	Endif
	Call dxget("NAME",tmp$)
	if RTrim$(tmp$)=""
		let returnstatus=0
		message$="Please enter a Ship to Name"
		goto SLDone
	Endif
	sl.Name$=UCase$(RTrim$(tmp$))+Blank$
	strgok=chkbadchars(e$,sl.Name$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Name"
		goto SLDone
	Endif
	if slr>0 and csl.Name$<>sl.Name$ let sl.DateEdit=curdate
	call dxget("ADDR1",tmp$)
	sl.Address$=tmp$+Blank$
	strgok=chkbadchars(e$,sl.Address$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Address 1"
		goto SLDone
	Endif
	if slr>0 and csl.Address$<>sl.Address$ let sl.DateEdit=curdate
	call dxget("ADDR2",tmp$)
	sl.OptAddress$=tmp$+Blank$
	strgok=chkbadchars(e$,sl.OptAddress$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Address 2"
		goto SLDone
	Endif
	if slr>0 and csl.OptAddress$<>sl.OptAddress$ let sl.DateEdit=curdate
	call dxget("CITY",tmp$)
	sl.City$=tmp$+Blank$
	strgok=chkbadchars(e$,sl.City$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in City"
		goto SLDone
	Endif
	if slr>0 and csl.City$<>sl.City$ let sl.DateEdit=curdate
	call dxget("STATE",tmp$)
	sl.State$=tmp$+Blank$
	strgok=chkbadchars(e$,sl.State$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in State"
		goto SLDone
	Endif
	if slr>0 and csl.State$<>sl.State$ let sl.DateEdit=curdate
	call dxget("ZIPCODE",tmp$)
	sl.ZipCode$=tmp$+Blank$
	if slr>0 and csl.ZipCode$<>sl.ZipCode$ let sl.DateEdit=curdate
	call dxget("COUNTRY",tmp$)
	sl.Country$=tmp$+Blank$
	strgok=chkbadchars(e$,sl.Country$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Country"
		goto SLDone
	Endif
	if slr>0 and csl.Country$<>sl.Country$ let sl.DateEdit=curdate
	call dxget("CONTACT",tmp$)
	sl.Contact$=tmp$+Blank$
	strgok=chkbadchars(e$,sl.Contact$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Contact"
		goto SLDone
	Endif
	call dxget("PHONE",tmp$)
	sl.PhoneNumber$=tmp$+Blank$
	call dxget("SLSPRSN",tmp$)
	X2=tmp$
	if x2<0 or x2>999 or fra(x2)
		ReturnStatus=0
		Message$="Salesperson not valid"
		goto SLDone
	Endif
	If X2 ! zero is valid!
		K1$=x2 using "###"
		Search #SMC,2,1;k1$,R,E
		if e
			ReturnStatus=0
			Message$="Salesperson not found"
			goto SLDone
		Endif
	Endif ! 0 is valid
	sl.Slsm=x2
	slsmchg=0 ! 37305 - add alert 5 for slsm chg (not from zero)
	if slr>0 and csl.Slsm>0 and csl.Slsm<>sl.Slsm let slsmchg=9
	call dxget("WHSE",tmp$)
	X2=tmp$
	if x2<0 or x2>99 or fra(x2)
		ReturnStatus=0
		Message$="Warehouse not valid"
		goto SLDone
	Endif
	sl.DefaultWhse=x2
	call dxget("ROUTING",tmp$)
	let sl.Routing$=tmp$+Blank$
	strgok=chkbadchars(e$,sl.Routing$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Routing"
		goto SLDone
	Endif
	call dxget("SLSAREA",tmp$)
	x2=tmp$
	if x2<0 or x2>10 or fra(x2)
		ReturnStatus=0
		Message$="Sales Area not valid"
		Goto SLDone
	Endif
	sl.SalesZone=x2
	call dxget("INVSHIP",tmp$)
	tmp$=UCase$(RTrim$(tmp$))
	if tmp$<>"N" and tmp$<>"Y"
		ReturnStatus=0
		Message$="Ship with Invoice is Y or N only"
		goto SLDone
	Endif
	sl.ShpWithInvoiceYN$=tmp$
	call dxget("VENDID",tmp$)
	sl.VendNum=tmp$
	if sl.VendNum<0 or sl.VendNum>999999 or Fra(SL.VendNum) let sl.vendnum=0
	call dxget("DCLVL",tmp$)
	x2=tmp$
	IF X2<0 or x2>5 or fra(x2)
		ReturnStatus=0
		Message$="Delivery Charge not valid (0-5 only)"
		goto SLDone
	Endif
	sl.DeliveryChrgLvl=x2
	call dxget("SHIPI1",tmp$)
	sl.ShipInstLine1$=tmp$+Blank$
	call dxget("SHIPI2",tmp$)
	sl.ShipInstLine2$=tmp$+Blank$
	call dxget("SHIPI3",tmp$)
	sl.ShipInstLine3$=tmp$+Blank$
	call dxget("SHIPI4",tmp$)
	sl.ShipInstLine4$=tmp$+Blank$
	call dxget("TAXCODE",tmp$)
	x3=tmp$
	if x3<0 or x3>chf(TXC)-1 or fra(X3)
		ReturnStatus=0
		Message$="Tax Code not valid"
		goto SLDone
	Endif
	IF P61$[115,115]="Y" and not(x3)
		ReturnStatus=0
		Message$="Tax Type is required"
		goto SLDone	
	endif
	sl.TaxCode=x3
	call dxget("TAXTYPE",tmp$)
	let x3=tmp$
	if x3<0 or x3>CHF(TTC)-1 or fra(x3)
		ReturnStatus=0
		Message$="Tax Type not valid"
		goto SLDone
	Endif
	IF P61$[115,115]="Y" and not(x3)
		ReturnStatus=0
		Message$="Tax Type is required"
		goto SLDone	
	endif
	sl.TaxType=x3
	call dxget("UDA1",tmp$)
	let sl.UdaNumeric=tmp$
	call dxget("UDA2",tmp$)
	sl.UdaAlpha1$=tmp$+Blank$
	strgok=chkbadchars(e$,sl.UdaAlpha1$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in UDA 2"
		goto SLDone
	Endif
	call dxget("UDA3",tmp$)
	sl.UdaAlpha2$=tmp$+Blank$
	strgok=chkbadchars(e$,sl.UdaAlpha2$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in UDA 3"
		goto SLDone
	Endif
	call dxget("UDA4",tmp$)
	sl.UdaAlpha3$=tmp$+Blank$
	strgok=chkbadchars(e$,sl.UdaAlpha3$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in UDA 4"
		goto SLDone
	Endif
	call dxget("DIV",tmp$)
	X2=tmp$
	if x2<0 or x2>99 or fra(x2)
		ReturnStatus=0
		Message$="Division not valid"
		goto SLDone
	Endif
	sl.dDiv=x2
	call dxget("RESIDENTAIL",tmp$)
	tmp$=UCase$(RTrim$(tmp$))
	if tmp$<>"N" and tmp$<>"Y"
		ReturnStatus=0
		Message$="Is this a residential address Y or N"
		goto SLDone
	Endif
	if tmp$[1,1]="Y"
	LET sl.residential=1
	else
    LET sl.residential=0
	endif
	call dxget("SENDEMAIL",tmp$)
	tmp$=UCase$(RTrim$(tmp$))
	if tmp$<>"N" and tmp$<>"Y"
		ReturnStatus=0
		Message$="Send UPS tracking #'s via e-mail Y or N"
		goto SLDone
	Endif
	if tmp$[1,1]="Y"
	LET sl.sendemail=1
	else
    LET sl.sendemail=0
	endif
 let Message$=""
	call dxget("EMAIL",tmp$)
	tmp$=UCase$(RTrim$(tmp$))
	let sl.email$=tmp$
	tmp$=" ",tmp$
	! clear sl.available$
	tmp$="a" \ if slr>0 let tmp$="c" ! add or change
	X3=fileupdateshiplist(e$,SLC,tmp$,slr,sl.)
	if x3<0 ! means problem
		ReturnStatus=0
		Message$=E$
	Else ! ok - now autoupdate keywords
		if SLR<=0 let SLR=X3
		LET X1=8;J1=SLR;X1[1]=1 ! MODE,RECORD (auto update name fields)
		j4$=Key1$
		CALL "CSLKEYWRD.dl4",J4$,J1,X1[1],X1,e$,IntCo
	Endif
	! finally - alert if slsm change
	if slsmchg ! slsm chg on existing shplst
		clear passinfo[]
		clear ch[]
		ch[1]=CTLC;ch[2]=CUC;ch[3]=SMC;ch[4]=SLC ! channels
		passinfo[0]=5 ! alert#
		passinfo[1]=cur ! cust rec
		passinfo[2]=custno ! cust id
		passinfo[3]=shipno ! shiplist id
		passinfo[4]=csl.Slsm ! orig slsm
		clear tmp$ ! used for additional text??
		call "libalertproc.lib",Passinfo[],ch[],tmp$
		slsmchg=0
	endif
	SLDone: ! finished
  else
    include "src/callsuberr.inc"
  end try
  !
end sub ! EdtShipto
! -------------------------------------------------------------------------------------
Sub SndDLists()
! droplists sent here - 9 of them
 Try
	Dim desc$[12]
	Clear List$[]
	tmpcnt=maxcnt
	tmp$=Action2$ ! section header
	!Call filedroplistwhinfoz(e$,list$[],tmpcnt,WHI,tmp$)
	!if e$<>"" Let Message$=e$;ReturnStatus=0  !! NEEDS A WHSE 0=NONE
	List$[0]=bsdel$,"WHSELIST",fdel$
	List$[1]="ID",fdel$,"WhName",fdel$
	row=2
	List$[row]="0",fdel$,"NOT ASSIGNED",FDEL$
	row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	maxwhse=CHF(WHI)-1 \ if maxwhse>98 let maxwhse=98
	For I=0 to maxwhse ! CHF(WHC)-1 (99 is the ALLWHSE record)
		read record #WHI,I,0;whi.;
		if rtrim$(whi.WhName$)<>"" !indicates active record in non-indexed file
			WebStr$=Str$(I+1),fdel$,rtrim$(whi.WhName$),fdel$
			List$[row]=webstr$
			row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
		Endif
	Next I
	List$[row]=esdel$
	
	call AddToStr(e$,rstr$,List$[]) ! add droplist to string
	! Slsm List
	ReturnStatus=1
	Message$="OK"
	clear list$[]
	! tmpcnt=maxcnt
	List$[0]=bsdel$,"SLSMLIST",fdel$
	List$[1]="ID",fdel$,"NAME",fdel$
	row=2
	List$[row]="0",fdel$,"NOT ASSIGNED",fdel$
	row=row+1
	If row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	key1$=" ",key1$
	Key1$[5]=""
	do
		SMR=filegetsslsmz(e$,SMC,">",1,key1$,slm.)
		If SMR<0 Exit do
		List$[row]=RTrim$(key1$),fdel$,Rtrim$(slm.Name$),fdel$
		row=row+1
		If row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	loop
	List$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])
	
	! now Tax selections
	clear list$[]
	List$[0]=bsdel$,"TAXLIST",fdel$
	List$[1]="ID",fdel$,"DESC",fdel$
	row=2
	List$[row]="0",fdel$,"NOT ASSIGNED",fdel$
	row=row+1
	If row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	
	For X2=1 to chf(txc)-1
		Try
			read record #txc,x2,0;tax.;
		Else
			clear tax.
		End try
		tmp$=RTrim$(tax.Desc$)
		if tmp$<>""
			List$[row]=Str$(X2),fdel$,tmp$,fdel$
			row=row+1
			If row>tmpcnt let tmpcnt=expandarray(e$,List$[])
		endif
	Next x2
	List$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])
	
	! now Tax type selections
	clear list$[]
	List$[0]=bsdel$,"TAXTYPE",fdel$
	List$[1]="ID",fdel$,"DESC",fdel$
	row=2
	List$[row]="0",fdel$,"NOT ASSIGNED",fdel$
	row=row+1
	If row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	ch_taxtype=openfile(-928,intco) \ if ch_taxtype=-1 Error 42
	X3=chf(ch_taxtype)-1
	for x2=1 to x3
		try
			mat read #ch_taxtype,x2,0;tdesc$;
		Else
			tmp$=""
		End try
		tmp1$=RTrim$(tdesc$)
		if tmp1$<>""
			List$[row]=Str$(X2),fdel$,tmp1$,fdel$
			row=row+1
			If row>tmpcnt let tmpcnt=expandarray(e$,List$[])
		Endif
	Next X2
	Close #ch_taxtype
	List$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])
	
	! Routing List
	Clear List$[]
	!call RoutingDropList(e$,RList$[],bsdel$,esdel$,fdel$,100,ctlc) ! ROUTING
	List$[0]=bsdel$,"ROUTINGLIST",fdel$ ! beginning of section
	List$[1]="DESCRIPTION",fdel$ ! we're only sending Desc # - NOT ID!
	row=2
	for cnt=1 to 106
		let dsp=(cnt-1)*12
	    read #ctlc,130,dsp;desc$;
		if rtrim$(desc$)<>""
			WebStr$=rtrim$(Desc$),fdel$
			List$[row]=WebStr$
			row=row+1
			if row>tmpcnt let tmpcnt=expandarray(E$,List$[])
		endif
	next cnt
	!
	List$[row]=esdel$ ! end section delimiter
	call AddToStr(e$,rstr$,List$[])
	
	! Zone droplist
	Clear List$[]
	Call filedroplistzonefle(e$,list$[],tmpcnt,ZNC)
	call AddToStr(e$,rstr$,List$[])
	
	! Sales area - even blank is valid!
	LET ZS$=" ",ZS$;ZNDSC$=" ",ZNDSC$                
	LET ZS$="     0"                                 
	SEARCH #AOC,2,1;ZS$,R6,E 
	IF Not(E)                              
		MAT  READ #AOC,R6,26;ZNDSC$;
	Endif
	Clear List$[]
	List$[0]=bsdel$,"SALESAREA",FDEL$
	List$[1]="ID",fdel$,"DESC",fdel$
	List$[2]="0",fdel$,"NOT ASSIGNED",fdel$
	row=3
	For x2=1 to 10
		tmp$=ZNDSC$[x2*10-9,x2*10]
		if tmp$="" or tmp$=Blank$[1,10] let tmp$=Str$(X2)+" no descr."
		List$[row]=Str$(X2),fdel$,tmp$,fdel$
		row=row+1
		If row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	Next x2
	List$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])
	clear list$[]
	List$[0]=bsdel$,"EPRTYPE",fdel$
	List$[1]="ID",fdel$,"DESC",fdel$
	List$[2]=" ",fdel$,"none",fdel$
	List$[3]="B",fdel$,"Budget",fdel$
	List$[4]="D",fdel$,"Date",fdel$
	List$[5]="N",fdel$,"Clear Budget",fdel$
	List$[6]=esdel$
	call AddToStr(e$,rstr$,List$[])
	clear list$[]
	List$[0]=bsdel$,"DATETYPE",fdel$
	List$[1]="ID",fdel$,"DESC",fdel$
	List$[2]=" ",fdel$,"none",fdel$
	List$[3]="M",fdel$,"Monthly",fdel$
	List$[4]="Q",fdel$,"Quarterly",fdel$
	List$[5]="S",fdel$,"Semi-Annual",fdel$
	List$[6]="A",fdel$,"Annual",fdel$
	List$[7]="C",fdel$,"Custom",fdel$
	List$[8]="N",fdel$,"Clear Budget",fdel$
	List$[9]=esdel$
	call AddToStr(e$,rstr$,List$[])
	clear list$[]
	lIST$[0]=bsdel$,"DCLVLLIST",fdel$
	List$[1]="ID",fdel$,"DESC",fdel$
	List$[2]="0",fdel$,"None",fdel$
	List$[3]="1",fdel$,"Level 1",fdel$
	List$[4]="2",fdel$,"Level 2",fdel$
	List$[5]="3",fdel$,"Level 3",fdel$
	List$[6]="4",fdel$,"Level 4",fdel$
	List$[7]="5",fdel$,"Level 5",fdel$
	List$[8]=esdel$
	call AddToStr(e$,rstr$,List$[])
	! add division list
    clear list$[]
	List$[0]=bsdel$,"DIVISION",fdel$
	List$[1]="ID",fdel$,"DESC",fdel$
	row=2
	List$[row]="0",fdel$,"NOT ASSIGNED",fdel$
	row=row+1
	If row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	for x2=1 to 99
		try
			read record #ch_div,x2,0;div.;
		Else
			clear div.
		End try
		tmp1$=RTrim$(div.desc$)
		if tmp1$<>""
			List$[row]=Str$(X2),fdel$,tmp1$,fdel$
			row=row+1
			If row>tmpcnt let tmpcnt=expandarray(e$,List$[])
		Endif
	Next X2
	List$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])
	
	! let callee add last list to string
	if debugdetail
		dmsg$="Wh, slsm, tax, taxt, rtg, zn, sa, bdgs, lvl List Done "+Message$ \ Call updatelog(debug)
	Endif
  else
    include "src/callsuberr.inc"
  end try
  !
end sub ! SndDLists
! -------------------------------------------------------------------------------------
Sub OOrders()
!!! section for order list , back order list, and quote list
Try 
	
	
	Include "src/bovars.inc"

	Dim bo.[1000] as boInfo, oo.[1000] as ooInfo
	Dim bi.[1000] as bInfo
	Dim arrSales[999],custid$[10],3%,maxrow

	maxrow=1000
	
	If Action1$="OORDERS"
			tmp$=bsdel$+"OpenOrders"+fdel$+rdel$
			tmp$=tmp$+"Customer"+fdel$+ "Name"+fdel$+"Type"+fdel$+"Status"+fdel$+"Order#"+fdel$+"PO#"+fdel$+"Order Date"+fdel$+"Ship Date"+fdel$+"Truck-Stop-Rte"+fdel$+"Total Sale"+fdel$+"G/P"+fdel$+"GTM"+fdel$+"Hold Code"+fdel$+"Entered By" +fdel$+rdel$
			Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$


			Call OOList(intCo,999,debug,"files/6/dx.log",oo.[], ii,ss, maxRow, arrsales[], custno, shipno)
			if ii > maxrow let ii=maxrow
			let tmp$=trim$(oo.[0].CustId$)
			If ii=0 and tmp$="" goto noodata
			For i=0 to ii
			   tmp$=oo.[i].CustId$+fdel$
			   tmp$=tmp$+oo.[i].CustName$+fdel$
			   tmp$=tmp$+oo.[i].Type$+fdel$
			   tmp$=tmp$+oo.[i].Status$+fdel$
			   tmp$=tmp$+oo.[i].OrderNo$+fdel$
			   tmp$=tmp$+oo.[i].PO$+fdel$
			   tmp$=tmp$+oo.[i].Ordered$+fdel$
			   tmp$=tmp$+oo.[i].ShipDT$+fdel$
			   tmp$=tmp$+oo.[i].RS$+fdel$
			   tmp$=tmp$+oo.[i].TResale$+fdel$
			   tmp$=tmp$+oo.[i].TGPP$+fdel$	! \if nocost$="Y" let col10$[i]=" "
			   tmp$=tmp$+oo.[i].GTM$+fdel$
			   tmp$=tmp$+oo.[i].Hold$+fdel$
			   tmp$=tmp$+oo.[i].EnteredBy$+fdel$+rdel$
			   Call AddToStr(e$,rstr$,tmp$)  ! put into rstr$
			Next i
			noodata: ! none
			Call AddToStr(e$,rstr$,esdel$)
	Endif ! of oorders
			!! BEGIN THE QUOTES !!
	If Action1$="QUOTES"
			tmp$=bsdel$+"Open Quotes"+fdel$+rdel$
			tmp$=tmp$+"Customer"+fdel$+ "Name"+fdel$+"Type"+fdel$+"Status"+fdel$+"Quoted#"+fdel$+"PO#"+fdel$+"Order Date"+fdel$+"Ship Date"+fdel$+"Truck-Stop-Rte"+fdel$+"Total Sale"+fdel$+"G/P"+fdel$+"GTM"+fdel$+"Hold Code"+fdel$+"Entered By" +fdel$+rdel$
			Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$


			Call Qolist(intCo,999,debug,"files/6/dx.log",oo.[],bi.,ii,ss, maxRow, cost_lev[],arrsales[], custno, shipno)

			if ii > maxrow let ii=maxrow
			let tmp$=TRIM$(oo.[0].CustId$)
			if ii=0 and tmp$="" goto noqdata
			For i=0 to ii
			   tmp$=oo.[i].CustId$+fdel$
			   tmp$=tmp$+oo.[i].CustName$+fdel$
			   tmp$=tmp$+oo.[i].Type$+fdel$
			   tmp$=tmp$+oo.[i].Status$+fdel$
			   tmp$=tmp$+oo.[i].OrderNo$+fdel$
			   tmp$=tmp$+oo.[i].PO$+fdel$
			   tmp$=tmp$+oo.[i].Ordered$+fdel$
			   tmp$=tmp$+oo.[i].ShipDT$+fdel$
			   tmp$=tmp$+oo.[i].RS$+fdel$
			   tmp$=tmp$+oo.[i].TResale$+fdel$
			   tmp$=tmp$+oo.[i].TGPP$+fdel$	! \if nocost$="Y" let col10$[i]=" "
			   tmp$=tmp$+oo.[i].GTM$+fdel$
			   tmp$=tmp$+oo.[i].Hold$+fdel$
			   tmp$=tmp$+oo.[i].EnteredBy$+fdel$+rdel$
			   Call AddToStr(e$,rstr$,tmp$)  ! put into rstr$
			Next i
			noqdata: ! none
			Call AddToStr(e$,rstr$,esdel$)
	Endif !!! End the quotes !!! 
	If Action1$="BOORDERS"
			tmp$=bsdel$+"BackOrders"+fdel$+rdel$
			! the following header is oorders using for demo
			! tmp$=tmp$+"Customer"+fdel$+ "Name"+fdel$+"Type"+fdel$+"Status"+fdel$+"Order#"+fdel$+"PO#"+fdel$+"Order Date"+fdel$+"Ship Date"+fdel$+"Truck-Stop-Rte"+fdel$+"Total Sale"+fdel$+"G/P"+fdel$+"GTM"+fdel$+"Hold Code"+fdel$+"Entered By" +fdel$+rdel$
			! this is the real BO header
			tmp$=tmp$+"Customer"+fdel$+ "Name"+fdel$+"Order#"+fdel$+"PO#"+fdel$
			tmp$=tmp$+"Order Date"+fdel$+"Item"+fdel$+"Item Desc"+fdel$+"Qty Ord."+fdel$
			tmp$=tmp$+"UM"+fdel$+"Qty on BO"+fdel$+"Shipdate"+fdel$+"Entered By" +fdel$
			tmp$=tmp$+"ONPO"+fdel$+"PODue"+fdel$+"Buyer"+fdel$+rdel$
			Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$

		  Call BOList(intCo,999,debug,"files/6/dx.log",bo.[], ii,ss,maxRow, arrSales[], custno, shipno)
			if ii > MaxRow let ii = MaxRow
			tmp$=TRIM$(bo.[0].CustId$)
			if ii=0 and tmp$="" goto nobdata
			For i=0 to ii
			   !tmp$=bo.[i].SalesMan$+fdel$
			   tmp$=bo.[i].CustId$+fdel$
			   tmp$=tmp$+bo.[i].CustName$+fdel$
			   tmp$=tmp$+bo.[i].OrderNo$+fdel$
			   !tmp$=tmp$+bo.[i].OrderIT$+fdel$
			   !tmp$=tmp$+bo.[i].Vendor$+fdel$
			   tmp$=tmp$+bo.[i].PO$+fdel$
			   tmp$=tmp$+bo.[i].Ordered$+fdel$
			   tmp$=tmp$+bo.[i].Item$+fdel$
			   tmp$=tmp$+bo.[i].Desc1$+fdel$
			   tmp$=tmp$+bo.[i].QtyOrd$+fdel$
			   tmp$=tmp$+bo.[i].OrdUM$+fdel$
			   tmp$=tmp$+bo.[i].QtyBord$+fdel$
			   tmp$=tmp$+bo.[i].ShipDT$+fdel$
			   tmp$=tmp$+bo.[i].EnteredBy$+fdel$
			   !tmp$=tmp$+bo.[i].Desc2$+fdel$
			   !tmp$=tmp$+bo.[i].QtyOrdWT$+fdel$
			   !tmp$=tmp$+bo.[i].QtyBordWT$+fdel$+rdel$
			   tmp$=tmp$+bo.[i].BOPO$+fdel$
			   tmp$=tmp$+bo.[i].PODue$+fdel$
			   tmp$=tmp$+bo.[i].POBuyer$+fdel$
			   tmp$=tmp$+rdel$ 
			   Call AddToStr(e$,rstr$,tmp$)  ! put into rstr$
			Next i
			nobdata: ! none
			Call AddToStr(e$,rstr$,esdel$)
	Endif
else
	include "src/callsuberr.inc"
end try

End Sub ! OORDERS
! -------------------------------------------------------------------------------------
Sub SVBUDG()
! save budget changes sl. already read
 Try
	
	Call Dxget("BLKTPO",tmp$)
	sl.BlktPo$=tmp$+Blank$
	Call DxGet("BUDGDOL",tmp$)
	x3=tmp$
	if x3<0 or x3>999999999 
		Returnstatus=0
		Message$="INVALID BUDGET"
		Goto SBDone
	Endif
	If X3=0 and sl.Budget<>0 ! cleared it
		let clrdbudg=1
	Endif
	sl.budget=X3
	Call DxGet("BUDGUSED",tmp$) ! is this returned?
	if clrdbudg let sl.BudgetUsed=0
	Call DxGet("EPRTYPE",tmp$)
	tmp$=UCASE$(RTrim$(tmp$))
	if TMP$<>"" AND tmp$<>"B" AND TMP$<>"D" AND TMP$<>"N"
		ReturnStatus=0
		Message$="INVALID EXPIRE TYPE"
		Goto SBDone
	Endif
	sl.BPExpireType$=tmp$
	if sl.BPExpireType$="B" and clrdbudg=1 ! cleared budget
		sl.BudgetUsed=0
		sl.BPExpireType$="N" ! to clear all
	Endif
	Call DxGet("DATETYPE",tmp$)
	tmp$=UCASE$(RTrim$(tmp$))
	if tmp$<>"" AND TMP$<>"M" AND TMP$<>"Q" AND TMP$<>"S" AND TMP$<>"A" AND TMP$<>"C" AND TMP$<>"N"
		ReturnStatus=0
		Message$="INVALID DATE TYPE"
		Goto SBDone
	Endif
	sl.BudgDateType$=tmp$
	Call DxGet("STARTDT",tmp$)
	tmp$=chkDateFrmt$(tmp$)
	if tmp$[1,1]<"0" and tmp$[1,1]>"9" let tmp$=""
	tmp1$=formatdate2$(tmp$) ! mm/dd/yyyy to yyyymmdd
	sl.BPDateStart=tmp1$[3,8] ! drop to yymmdd
	Call DxGet("ENDDATE",tmp$)
	tmp$=chkDateFrmt$(tmp$)
	if tmp$[1,1]<"0" and tmp$[1,1]>"9" let tmp$=""
	tmp1$=formatdate2$(tmp$) ! mm/dd/yyyy to yyyymmdd
	sl.BPDateEnd=tmp1$[3,8] ! drop to yymmdd
	if sl.BPExpireType$="" or sl.BPExpireType$="N" ! not used - clear budget fields
		sl.BlktPo$=Blank$
		sl.Budget=0;sl.BudgetUsed=0
		sl.BPExpireType$=blank$
		sl.BudgDateType$=blank$
		sl.BPDateStart=0;sl.BPDateEnd=0
	Endif
	if sl.BudgDateType$="" or sl.BudgDateType$="N" Or sl.BPExpireType$="B"
		sl.BPDateStart=0;sl.BPDateEnd=0 ! not date type
		if sl.BudgDateType$="N" ! clear ALL
			sl.BlktPo$=Blank$
			sl.Budget=0;sl.BudgetUsed=0
			sl.BPExpireType$=blank$
		Endif
		sl.BudgDateType$=blank$
	Endif
	Write Record #SLC,SLR,0;sl.;
	!Call dxsave(0,"/tmp/jcs.txt!")
	!call programdump("/tmp/shllog1!","")
	SBDone: ! finished
 else
	include "src/callsuberr.inc"
end try

End Sub ! SVBUDG
! -------------------------------------------------------------------------------------
Sub SVZones()
! do zone,stop
  Try
	dim csz. as cszone
	If p61$[34,34]="Y" ! multi-zone
		Try Close #CSZ ELSE REM
		Tmp$ = "3/CSZONE" + Str$(IntCo)
		Call FindF(tmp$,H)
		If Not(H)
		  Let P61$[34,34]="N" ! NO FILE - FLAG=N
		  ReturnStatus=0
		  Message$="COULD NOT FIND CSZONE FILE"
		  Goto SZDone
		Else ! it's there open it as rw
		  CSZ=OpenFile(9997,IntCo) \ if CSZ=-1 Error 42 ! cszone
		End If 
		Search #CSZ,2,1;Key1$,CSZR,E
		if e=1
			Clear csz.
			csz.Customer=CustNo
			csz.Shipto=ShipNo
			csz.SpareFiller$=Blank$[1,5] ! not all the way!
			E=2
			Search #CSZ,1,0;Key1$,R,E
			If E
				ReturnStatus=0
				Message$="Search Error "+Str$(E)+" getting new cszone record"
				Goto SZDone
			Else
				Search #CSZ,4,1;key1$,R,E
				if e
					ReturnStatus=0
					Message$="Search Error "+Str$(E)+" adding cszone new key"
					Goto SZDone
				Endif
				CSZR=R
			Endif
		Else
			if e ! any other error
				ReturnStatus=0
				Message$="Search Error "+Str$(E)+" getting cszone key"
				Goto SZDone
			Endif
			Read record #CSZ,CSZR,0;csz.
			NewRec=0
		Endif
		Call DXGet("LeadTime",tmp$)
		csz.LeadTime=tmp$
		call dxget("SunZone",tmp$)
		tmp1$=tmp$+Blank$
		tmp1$[3]=""
		Search #ZNC,2,1;tmp1$,R,E
		if e and tmp1$[1,2]<>"  "
			returnstatus=0
			Message$="ZONE NOT FOUND"
			Goto SZDone
		Endif
		csz.SunZone$=tmp1$+Blank$
		Call dxget("SunStop",tmp$)
		x2=tmp$ \ if x2<0 or x2>6999 or fra(x2) let x2=0
		csz.SunStop=x2
		Call dxget("MonZone",tmp$)
		tmp1$=tmp$+Blank$
		tmp1$[3]=""
		Search #ZNC,2,1;tmp1$,R,E
		if e and tmp1$[1,2]<>"  "
			returnstatus=0
			Message$="ZONE NOT FOUND"
			Goto SZDone
		Endif
		csz.MonZone$=tmp1$+Blank$
		Call dxget("MonStop",tmp$)
		x2=tmp$ \ if x2<0 or x2>6999 or fra(x2) let x2=0
		csz.MonStop=x2
	    Call dxget("TueZone",tmp$)
		tmp1$=tmp$+Blank$
		tmp1$[3]=""
		Search #ZNC,2,1;tmp1$,R,E
		if e and tmp1$[1,2]<>"  "
			returnstatus=0
			Message$="ZONE NOT FOUND"
			Goto SZDone
		Endif
		csz.TueZone$=tmp1$+Blank$
		Call dxget("TueStop",tmp$)
		x2=tmp$ \ if x2<0 or x2>6999 or fra(x2) let x2=0
		csz.TueStop=x2
		Call dxget("WedZone",tmp$)
		tmp1$=tmp$+Blank$
		tmp1$[3]=""
		Search #ZNC,2,1;tmp1$,R,E
		if e and tmp1$[1,2]<>"  "
			returnstatus=0
			Message$="ZONE NOT FOUND"
			Goto SZDone
		Endif
		csz.WedZone$=tmp1$+Blank$
		Call dxget("WedStop",tmp$)
		x2=tmp$ \ if x2<0 or x2>6999 or fra(x2) let x2=0
		csz.WedStop=x2
		Call dxget("ThuZone",tmp$)
		tmp1$=tmp$+Blank$
		tmp1$[3]=""
		Search #ZNC,2,1;tmp1$,R,E
		if e and tmp1$[1,2]<>"  "
			returnstatus=0
			Message$="ZONE NOT FOUND"
			Goto SZDone
		Endif
		csz.ThuZone$=tmp1$+Blank$
		Call dxget("ThuStop",tmp$)
		x2=tmp$ \ if x2<0 or x2>6999 or fra(x2) let x2=0
		csz.ThuStop=x2
		Call dxget("FriZone",tmp$)
		tmp1$=tmp$+Blank$
		tmp1$[3]=""
		Search #ZNC,2,1;tmp1$,R,E
		if e and tmp1$[1,2]<>"  "
			returnstatus=0
			Message$="ZONE NOT FOUND"
			Goto SZDone
		Endif
		csz.FriZone$=tmp1$+Blank$
		Call dxget("FriStop",tmp$)
		x2=tmp$ \ if x2<0 or x2>6999 or fra(x2) let x2=0
		csz.FriStop=x2
		Call dxget("SatZone",tmp$)
		tmp1$=tmp$+Blank$
		tmp1$[3]=""
		Search #ZNC,2,1;tmp1$,R,E
		if e and tmp1$[1,2]<>"  "
			returnstatus=0
			Message$="ZONE NOT FOUND"
			Goto SZDone
		Endif
		csz.SatZone$=tmp1$+Blank$
		Call dxget("SatStop",tmp$)
		x2=tmp$ \ if x2<0 or x2>6999 or fra(x2) let x2=0
		csz.SatStop=x2
		! same for both ! DO NOT USE FILEUPDATECSZONE !!!!
		Write record #CSZ,CSZR,0;csz.;
		
	Else ! zone,stop in shiplist
		Call Dxget("Zone",tmp$)
		tmp1$=tmp$+Blank$
		tmp1$[3]=""
		Search #ZNC,2,1;tmp1$,R,E
		if e and tmp1$[1,2]<>"  "
			returnstatus=0
			Message$="ZONE NOT FOUND"
			Goto SZDone
		Endif
		sl.Zone$=tmp1$+Blank$
		Call DXGet("Stop",tmp$)
		X3=tmp$ \ if x3<0 or x3>6999 or fra(x3) let x3=0
		sl.sStop$=x3 using "######"
		Write Record #SLC,SLR,0;sl.;
	Endif
	SZDone: ! finished
  else
	include "src/callsuberr.inc"
end try

End Sub ! SVZones
! -------------------------------------------------------------------------------------
Sub SVKYWRD()
! get / write keywords
! 2 files - 1 = keyword file, 2=keyword index
  Try
	Dim k1$[60],K2$[60],PKYW$[450],J$[30]
	Dim RKey$[13],SF$[30],J1$[80]
	Dim 1%,SLIn,2%,Cust
	Dim 3%
	CKWC=OpenFile(9972,intCo) \ if CKWC = -1 Error 42 ! cslkeywrd
	CKWI=OpenFile(9971,intco) \ if ckwi = -1 Error 42 ! keyword index
	k1$=kEY1$ ! cust.ship
	Search #CKWC,2,1;K1$,R,E
	if E=1 ! new
		Let E=2;R=0
		Search #CKWC,1,0;K1$,R,E
		if e 
			ReturnStatus=0
			Message$="Search Error "+Str$(E)+" getting new keyword record"
			Goto SKDone ! can't continue!
		endif
		Search #CKWC,4,1;k1$,R,E
		if e 
			ReturnStatus=0
			Message$="Search Error "+Str$(E)+" inserting new keyword index"
			Goto SKDone ! can't continue!
		endif
		Cust=Custno;Slin=1
		RKey$=K1$;SF$=Blank$
		write #CKWC,R,0;Cust;
		write #CKWC,R,4;slin;
		mat write #CKWC,R,456;RKey$;
		mat write #CKWC,R,469;SF$;
		PKYW$=" ",PKYW$
		mat write #CKWC,R,6;PKYW$;
	Else ! existing
		if e 
			ReturnStatus=0
			Message$="Search Error "+Str$(E)+" getting keyword index"
			Goto SKDone ! can't continue!
		endif
		LET X1=10;J1=SLR;X1[1]=1 ! MODE,RECORD (auto update name fields)
		CALL "CSLKEYWRD.dl4",K1$,J1,X1[1],X1,e$,IntCo
	Endif
	CKWR=R
	Mat read #CKWC,CKWR,6;PKYW$
	!! LETS USE THE STRING instead of individual fields!!
	
	For Fld=1 to 17
		Let Dsp=(fld-1)*15+1
		J1$=PKYW$[Dsp,Dsp+14]+Blank$ \ call DelAKey() ! delete old data
		PKyW$[dsp,dsp+14]=Blank$ ! clear prev
		Call dxget("Keyword"+Str$(fld),tmp$)
		J$=tmp$+Blank$
		E=Chkdupes()
		if e ! a dupe
			Numdupe=numdupe+1
			J$=Blank$ ! switch to nothing
		Endif
		
		K2$=J$+Blank$ \ call AddAKey() ! add new data
		PKYW$[Dsp,Dsp+14]=J$+Blank$
	Next Fld
	! all fields (except Name+) updated
	Mat Write #CKWC,CKWR,6;PKYW$;
	!Call dxsave(0,"/tmp/jcs.txt!")
	!call programdump("/tmp/shllog2!","")
	LET X1=9;J1=SLR;X1[1]=1 ! MODE,RECORD (auto update name fields)
	CALL "CSLKEYWRD.dl4",k1$,J1,X1[1],X1,e$,IntCo
	Try Close #CKWC ELSE REM
	Try Close #CKWI ELSE REM
	if numdupe>0 and returnstatus=1
		ReturnStatus=0
		Message$="DUPLICATED "+Str$(NumDupe)+" existing Keyword entries"
	Endif
	SKDone: ! finished
  else
	include "src/callsuberr.inc"
end try

End Sub ! SVKYWRD
! -------------------------------------------------------------------------------------
Function ChkDupes() 
! "prevent duplicates!
 Try 
	Let Dupe=0
	If J$[1,15]=Blank$[1,15] Exit function Dupe
	For X=1 to 30
	  Let X1=(X-1)*15+1
	  If J$[1,15]=PKYW$[x1,x1+14] Let Dupe=Dupe+1
	Next X
  else
    include "src/callsuberr.inc"
  end try
end Function Dupe ! ChkDupes
! 
!--------------------------------------------------------------------
Sub DelAKey() 
! "delete current key word
Try 
	Let K2$=UCase$(J1$[1,15])+Key1$
	Let R[CKWI]=SLR
	Search #CKWI,5,1;K2$,R[CKWI],E
	if e>1 
		ReturnStatus=0
		Message$="Search Error "+Str$(E)+" deleting Keyword Index"
	Endif
 else
	include "src/callsuberr.inc"
end try

End Sub ! DelAKey
! -------------------------------------------------------------------------------------
Sub AddAKey() 
! "add current key word (except spaces
 Try
	If K2$[1,1]="" Or K2$[1,15]="               " Goto AAKDone
	K2$=Ucase$(K2$)
	Let k2$[16]=Key1$
	Let R[CKWI]=SLR
	
	Search #CKWI,4,1;K2$,R[CKWI],E
	if e>1 
		ReturnStatus=0
		Message$="Search Error "+Str$(E)+" inserting Keyword Index"
	Endif
	AAKDone: ! finished
  else
	include "src/callsuberr.inc"
end try

End Sub ! AddAKey
! -------------------------------------------------------------------------------------
!--------------------------------------------------------------------
Sub ProcessCommissionSplits()
  Try
	Dim CSMKey$[14]
	Dim 1%,CSType[4,3]
	Dim 2%,Cs0,Cs1[4],CSPCT[4,3],csstdate[4,3],csedate[4,3],cs2,salesCode
	dim 3%

	if action2$ = "GET"
		CSMC=OpenFile(-9969,intCo) \ if CSMC = -1 Let SCType = 0
	else
		CSMC=OpenFile(9969,intCo) \ if CSMC = -1 Let SCType = 0
	end if
	if SCType = 0
		returnstatus=0
		message$="Option is not active!"
		exit sub
	Endif

	call DXGet("SalesRep",tmp$) \ salesCode=tmp$
	! if one not sent as part of shiplist, default main customer
	if not(salesCode) salesCode =  cust.SalesmanCode

	CSMKey$=custNo using "######"
	CSMKey$[7]="."
	CSMKey$[8] = shipno using "&&&&&&"
	SEARCH #CSMC,2,1;CSMKey$,CSMRec,E \ if e>1 error 11000
	CSMnewRec = 0 \ if e CSMnewRec = 1
	if not(CSMnewRec)
		mat read #CSMC,CSMRec,4;cs1
		mat read #CSMC,CSMRec,184;cspct
		mat read #CSMC,CSMRec,268;cstype ! leave locked if open rw
	end if
	if cs1[0] <= 0 or cs1[0] <> salesCode
		cs1[0] = salesCode
	end if
	select case action2$
		case "CHECK" ! check to see if a customer level split exists
			clear List$[]
			list$[0]=bsdel$+"CUSTSPLITS"+fdel$
			list$[1]="Exists"+fdel$
			tmp$ = "0" \ if not(CSMnewRec) tmp$ = "1"
			list$[2]=tmp$+fdel$
			list$[3]=esdel$
			call AddToStr(e$,rstr$,List$[])
		case "GET" ! it's doc=Custm-GetCSplit.doc
			if CSPCT[0,0] <= 0 and SCType <> 2 CSPCT[0,0] = 100
			Clear List$[]
			List$[0]=bsdel$,"CUSTSPLITS",fdel$
			webstr$="SCType"+fdel$
			for i = 0 to 4
				webstr$=webstr$+"SplitRep"+str$(i)+fdel$
			next i
			for i = 0 to 4
				webstr$=webstr$+"Split"+str$(i)+fdel$
			next i
			for i = 0 to 4
				webstr$=webstr$+"SplitPct"+str$(i)+fdel$
			next i
			List$[1]=webstr$
			webstr$=str$(SCTYPE)+fdel$
			for i = 0 to 4
				webstr$=webstr$+str$(cs1[i])+fdel$
			next i
			for i = 0 to 4
				if sctype = 2
					webstr$=webstr$+str$(cstype[i,0])+fdel$
				else
					webstr$=webstr$+str$(cspct[i,0])+fdel$
				end if
			next i
			for i = 0 to 4
				if sctype = 2
					webstr$=webstr$+str$(cspct[i,0])+fdel$
				else
					webstr$=webstr$+"0"+fdel$
				end if
			next i
			list$[2]=webstr$
			List$[3]=esdel$
			call AddToStr(e$,rstr$,List$[])
		case "SAVE" ! doc=Custm-SubmitCSplit.doc
			! OK - let's load 'em up and validate
			totPercent = 0
			for i = 0 to 4
				call dxget("SplitRep"+str$(i), tmp$) \ cs1[i] = tmp$
				if sctype = 2
					call dxget("Split"+str$(i), tmp$) \ cstype[i,0] = tmp$
					call dxget("SplitPct"+str$(i), tmp$) \ cspct[i,0] = tmp$
				else
					call dxget("Split"+str$(i), tmp$) \ cspct[i,0] = tmp$
					cstype[i,0] = 0
				end if
				if cs1[i]
					for j = 0 to i - 1
						if cs1[i] = cs1[j]
							returnstatus = 0
							message$ = "Same salesrep on more than 1 line!"
							exit sub
						end if
					next j
				else
					csplt[i,0] = 0
					cspct[i,0] = 0
				end if
				totPercent = totPercent + cspct[i,0]
			next i
			if sctype = 1 and totPercent <> 100
				returnstatus = 0
				message$ = "Total split percentage <> 100%!"
				exit sub
			end if
			if sctype = 3 and totPercent > 100
				returnstatus = 0
				message$ = "Total split percentage > 100%!"
				exit sub
			end if
			if CSMnewRec ! new rec
				e=2 \ search #CSMC,1,0;CSMKey$,CSMRec,e
				if e error 11000
				search #CSMC,4,1;CSMKey$,CSMRec,e
				if e error 11000
				cs0 = custno
				mat write #CSMC,CSMRec,0;cs0
				mat write #CSMC,CSMRec,4;cs1
				mat write #CSMC,CSMRec,24;cssdate
				mat write #CSMC,CSMRec,104;csedate
				mat write #CSMC,CSMRec,184;cspct
				mat write #CSMC,CSMRec,264;cs2
				mat write #CSMC,CSMRec,268;cstype;
			else
				mat write #CSMC,CSMRec,4;cs1
				mat write #CSMC,CSMRec,184;cspct
				mat write #CSMC,CSMRec,268;cstype;
			end if
		case "DELETE" ! doc=Custm-DeleteCSplit.doc
			if not(CSMnewRec)
				search #CSMC,5,1;CSMKey$,CSMRec,e
				if e error 11000
				let e=3\search #CSMC,1,0;CSMKey$,CSMRec,e
				if e error 11000
			end if
		case else
			returnstatus = 0
			message$ = "Unknown action2: "+action2$+"!"
	end select
  else
    include "src/callsuberr.inc"
  end try
  !
end sub ! ProcessCommissionSplits
! -------------------------------------------------------------------------------------! -------------------------------------------------------------------------------------
