! >>> Program acl.event.in
!
! description Airclic Event Poll receive 
! loadsave -w -n 100,10 -o prog/dxport/acl.event.in.dl4 src/acl.event.in.src
!
! 1.0 mm/dd/yyyy change??
!  look for dl4 test ********* for in-house changes
!  REM THEM OUT FOR FINAL INSTALL !!! or UNREM for in-house
!
include "src/copyright.inc"

Rem ACL.Event.IN.src - Receive back event file
Rem 18552
Rem file name passed in - generated by sending perl script/program that creates it
! POSSIBLE RECEIVE BACK FIELDS
! Several different events returned
! we determine what they are and handle appropriately
! Roadnet wants: orderstatussummary & userstatus
! we need a field "receiptnumber" to make a call for a pdf file
! the response has all data one 1 line (after the <?xml line) variable length
! up to 60-70,000 characters!
! FUTURE: update orders for qty actually delivered
!   and since no line numbers (product id is Airclic Line)
!   it should be fun (dupe items on order have a Letter(A-Z) appended)
Rem BEDIT Version: 2.3 OBJECT CODE     Created: MAY 24, 2013  11:31:13
Rem /w2/papermaster/r2005//usr/acct/jcs/work/custom/xrev9/acl.event.in.src (univ2) [jcs] {62682}
Rem  Copyright (c) 2013 Universal Business Systems, Inc.
Rem    **** ALL CHANGES MUST BE MADE IN SOURCE!!! ****
Rem
Declare Intrinsic Sub FindF,InpBuf,String,StringSearch,Time,VerifyDate
Declare Intrinsic Sub DateToJulian
Declare Intrinsic Function Findchannel
! Option Default Dialect IRIS1

If Err 0 Gosub ERR_TRAP
Rem
Enter INXMLFLE$,RETFLG,Intco
Rem {begin src/inc/dim.getchan.i}
Dim 1%,CHNL
Dim 3%,CHNLSCR,CHNLFREE
Rem {end dim.getchan.i}
Dim e$[500],buttonlist$[5,50],nextlist$[5,100],rstr$[500] ! dx error handling variables
! order file - line item 
dim 1%,un[2],eun[2]
dim 2%,l6[5]
dim 3%,s3[17],unf[6],InvNo,QShp,QDel,Price
dim l$[60]
! product file
                 
dim 1%,pfu1[20],cnvtu[2]            
dim 2%,b[24]
dim 3%,a1[7] ,a[33] ,pfu2[6],cnvta,Amount
Dim WRKLINE$[50000],TMPLINE$[50000],VAR$[10],WORK$[50000],TEMP$[50000]
Dim FLE$[30],RETVAL$[512],EVTYPE$[50],COMMAND$[256],DIRTO$[64],PRN$[40]
Dim Sys$[512],EMAILFROM$[90],EMAILTO$[90],PAYTYPE$[50],HldWork$[50000]
Dim ACLOID$[20],S1$[118],S2$[20],A1$[142],A2$[30],A3$[22],L1$[20]
Dim S3$[33],K1$[64],K2$[64],K3$[64],K4$[64],XMLFLE$[80],TMPFLE$[30]
Dim X$[20],VARNM$[60],ACLPC$[10],LOGFNM$[40],SPACES$[200],IMAG$[300]
Dim FAULTSTRING$[768],OUTXMLFLE$[80],EVSTAT$[80],USRNM$[80],TRIGR$[40]
Dim TODAY$[40],TODRNM$[40],CUSTOM_CUSTOMER$[30],DAYDIR$[4],HOME$[128]
Dim CNam$[30],TProd$[12],TDesc$[30],OPURP$[20],RDesc$[50],PO$[20]
Dim Alpha$[256],QUM$[14]
Dim 1%,X1[9],COID,CH_CNTRL,CH_CUST,CH_ROS,CH_ROSH,CH_ROHHK,CH_INFLE
Dim 1%,L3[3],S2[1],H4[2],TCB,CH_ROH,CH_ROHH,CH_DTL,CH_ROL,CH_ROLH
Dim 1%,CH_ACLTRNS,TTLLNS,LDLN,LNNO,SCR,CREDIT,RTAX,FLEFND,CCHAN[10]
Dim 1%,FOUND,BADDATA,RCOMMIT,RCANCEL,RESPFAULT,BADORD,RLINE
Dim 2%,X2[9],H0[12],MCODE[9],L4[3],H6[8],H5[16]
Dim 2%,CurrDate
Dim 3%,X3[9],SRN[5],T2[25],MCHARGE[9,1],L5[3],L7[12]
Dim 3%,OREF[5],OLM[6]
Dim 3%,ORDREC,R[99],TAXAMT,E,H,POS0,POS1,POS2,POS3,X
SPACES$ = " ",SPACES$;rstr$="events"
If INXMLFLE$ = "" Goto OUTEND ! no response file sent
For X = 2 To 99
  If Err 0 Rem
  Close #X
  If Err 0 Gosub ERR_TRAP
Next X
COID = Intco ! Int((Spc(5) - Int(Spc(5) / 16384) * 16384) / 64)
CH_CNTRL = 1
If Err 0 Let X2 = Spc(8)
X2 = 0
X3 = Chf(CH_CNTRL)
If Err 0 Gosub ERR_TRAP
If X2 ! cntrl not open
  Open #1,"cntrl/cntrl" + Str$(COID)
End If 
Mat Read #1,115,60;CUSTOM_CUSTOMER$;
mat read #1,0,108;currdate;
Custom_customer$=UCase$(Trim$(custom_customer$))
HOME$ = "HOME" \ System 28,HOME$
WORK$ = RTrim$(HOME$)
! Gosub RTRIM_
HOME$ = WORK$ ! trimmed home directory if needed
If CCHAN[1] <= 0 ! No cust
  CHNL = findchannel() ! 97 \ Gosub GETCHAN
  If CHNL > 1 Let CCHAN[1] = CHNL
  Read #CH_CNTRL,88,1808;FLE$[1,16];
  ROpen #CCHAN[1],FLE$
  CCHAN[1] = 0 - CCHAN[1] ! "show we opened
End If 
CH_CUST = Abs(CCHAN[1])
If CCHAN[2] <= 0 ! no roh
  CHNL = findchannel() ! 97 \ Gosub GETCHAN
  If CHNL > 1 Let CCHAN[2] = CHNL
  Read #CH_CNTRL,88,1840;FLE$[1,16];
  ROpen #CCHAN[2],FLE$
  CCHAN[2] = 0 - CCHAN[2] ! "show we opened
End If 
CH_ROH = Abs(CCHAN[2])
If CCHAN[3] <= 0 ! no ros
  CHNL = findchannel() ! 97 \ Gosub GETCHAN
  If CHNL > 1 Let CCHAN[3] = CHNL
  Read #CH_CNTRL,88,1856;FLE$[1,16];
  Open #CCHAN[3],FLE$
  CCHAN[3] = 0 - CCHAN[3] ! "show we opened
End If 
CH_ROS = Abs(CCHAN[3])
If CCHAN[4] <= 0 ! no rosh
  CHNL = findchannel() ! 97 \ Gosub GETCHAN
  If CHNL > 1 Let CCHAN[4] = CHNL
  Read #CH_CNTRL,88,1152;FLE$[1,16];
  ROpen #CCHAN[4],FLE$
  CCHAN[4] = 0 - CCHAN[4] ! "show we opened
End If 
CH_ROSH = Abs(CCHAN[4])
If CCHAN[5] <= 0 ! no invhhKEY
  CHNL = findchannel() ! 97 \ Gosub GETCHAN
  If CHNL > 1 Let CCHAN[5] = CHNL
  lET FLE$="4/SORDFLEHHKEY"+STR$(COID)
  ROpen #CCHAN[5],FLE$
  CCHAN[5] = 0 - CCHAN[5] ! "show we opened
End If 
CH_ROHHK = Abs(CCHAN[5])
If CCHAN[6] <= 0 ! no INVHH
  CHNL = findchannel() ! 97 \ Gosub GETCHAN
  If CHNL > 1 Let CCHAN[6] = CHNL
  Read #CH_CNTRL,88,1136;FLE$[1,16];
  ROpen #CCHAN[6],FLE$
  CCHAN[6] = 0 - CCHAN[6] ! "show we opened
End If 
CH_ROHH = Abs(CCHAN[6])
if CCHAN[7] <= 0 ! no roL
  CHNL = findchannel() ! 97 \ Gosub GETCHAN
  If CHNL > 1 Let CCHAN[7] = CHNL
  Read #CH_CNTRL,88,1888;FLE$[1,16];
  ROpen #CCHAN[7],FLE$
  CCHAN[7] = 0 - CCHAN[7] ! "show we opened
End If 
CH_ROL = Abs(CCHAN[7])
if CCHAN[8] <= 0 ! no roLH
  CHNL = findchannel() ! 97 \ Gosub GETCHAN
  If CHNL > 1 Let CCHAN[8] = CHNL
  Read #CH_CNTRL,88,1184;FLE$[1,16];
  ROpen #CCHAN[8],FLE$
  CCHAN[8] = 0 - CCHAN[8] ! "show we opened
End If 
CH_ROLH = Abs(CCHAN[8])
if CCHAN[9] <= 0 ! no prod
  CHNL = findchannel() ! 97 \ Gosub GETCHAN
  If CHNL > 1 Let CCHAN[9] = CHNL
  Read #CH_CNTRL,88,1792;FLE$[1,16];
  ROpen #CCHAN[9],FLE$
  CCHAN[9] = 0 - CCHAN[9] ! "show we opened
End If 
CH_PROD = Abs(CCHAN[9])
if CCHAN[10] <= 0 ! no ccode
  CHNL = findchannel() ! 97 \ Gosub GETCHAN
  If CHNL > 1 Let CCHAN[10] = CHNL
  Read #CH_CNTRL,88,1728;FLE$[1,16];
  ROpen #CCHAN[10],FLE$
  CCHAN[10] = 0 - CCHAN[10] ! "show we opened
End If 
CH_ccd = Abs(CCHAN[10])
alpha$="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
TODRNM$ = "aclevents/" ! where to put copies
LOGFNM$ = "1/aclevents.log" ! log name
DIRTO$ = HOME$ + "tmp/" ! Have IT SOMEWHERE!
! dirto$="/v/airclic/";todrnm$="events/" ! dl4 test *********
DAYDIR$ = "";daydir$=Str$(tim(10))+"/" ! dl4 test *********
If CUSTOM_CUSTOMER$ = "ACME" ! diff directorys
  DIRTO$ = "/lx/airclic/" ! main dir
  TODRNM$ = "events/" ! events dir
  DOM = Tim(10) ! day of month
  DAYDIR$ = Str$(DOM) + "/"
End If 
If DAYDIR$ <> "" ! try clear the next day directory? (kept/keep 1 month)
  DOMN = DAYDIR$
  DOMN = DOMN + 1 \ If DOMN > 31 Let DOMN = 1 ! definite no 32
  MOY = Tim(9) ! month
  If MOY = 2 And (Fra(Tim(8) / 4)) And DOMN > 28 Let DOMN = 1
  If MOY = 2 And Not(Fra(Tim(8) / 4)) And DOMN > 29 Let DOMN = 1
  If MOY = 4 Or MOY = 6 Or MOY = 9 Or MOY = 11 And DOMN > 30 Let DOMN = 1
  WORK$ = Str$(DOMN) + "/"
  TEMP$ = DIRTO$ + TODRNM$ + WORK$ ! ie: /lx/airclic/events/22/
  COMMAND$ = "rm -f " + TEMP$ + "* 2>&1"
  System COMMAND$
  ! clear 2 month old pdf's
  x2=Tim(9) - 2 \ if x2<=0 let x2=x2+12 ! is in Jan/Feb
  X$ = Tim(8) Using "&&" + X2 Using "&&" + Tim(10) Using "&&" ! yymmdd
  Temp$=DIRTO$ + TODRNM$ + "pdfs/" + "*_"+x$[1,5] + "*" ! ie: *_13050* & today=130708
  COMMAND$ = "rm -f " + TEMP$ + " 2>&1"
  System Command$
End If 
RCFAIL = 0
CHNL = findchannel() ! 97 \ Gosub GETCHAN
If Err 0 Gosub ERR_TRAP ! getchan changes to err_escape:?

XMLFLE$ = INXMLFLE$ ! "passed the full name of file
CH_INFLE = CHNL ! "reuse progdflt channel
WORK$ = XMLFLE$ ! full file name
FLEFND = 0;SENT2X = 0;FAILCODE = 0 ! if resend - clear previous codes
FAULTSTRING$ = " ",FAULTSTRING$;FAULTSTRING$ = "" ! clear any previous!
CHK4FLE: Rem "wait and try again loop
Call FindF(WORK$,FOUND)
If FOUND ! it's there - open it
  Open #CH_INFLE,WORK$
Else 
  If FLEFND <= 4 ! not there yet? try 4 times(0,1,2,3)(=12 seconds), then give up
    FLEFND = FLEFND + 1
    ! Print @40,22;'CL';"NO FILE YET..";Str$(FLEFND);
    Signal 3,30 ! wait 3 seconds
    Goto CHK4FLE
  End If 
  ! Print @0,23;'RB CE';"RESPONSE FILE MISSING!";
  Signal 3,30
  Goto OUTDONE
End If 
PRN$ = " ",PRN$
PRN$ = "" ! clear and null it
WRKLINE = 0;excepl=0
BADDATA = 0;RESPGOOD = 0;RESPFAIL = 1
INFLE_LOOP: Rem until done or EOF
WRKLINE$ = ""
Gosub READ_TEMPLATE
If WRKLINE$ = "" Goto FLEDONE
WRKLINE = WRKLINE + 1
Rem the only way I see it is do hardcode literal search
VARNM$ = "<?XML" ! This is the line before all the data!
Gosub CHK_LINE
If POS1 Let RESPFAIL = 0 ! good response
If WRKLINE = 1 ! first line is where ACL reports error
  VARNM$ = "ERROR"
  Gosub CHK_LINE
  If POS1
    RESPGOOD = 0;RESPFAIL = 0;RESPFAULT = 1 ! valid response - but not good
    TEMP$ = " ",TEMP$;TEMP$ = ""
    TEMP$ = WORK$[POS0 + POS1] ! get rest of line's data
    If TEMP$ = "" Goto FLEDONE ! no message?
    WORK$ = "EXCEPTION OCCURED WHILE VALIDATING FIELD"
    Search TEMP$[1],WORK$,POS2
    If POS2 ! get for fail message
      WORK$ = TEMP$[POS2 + 42] ! as it includes 'bad' data (ie: ; &gt) get after that point
      FAULTSTRING$ = " ",FAULTSTRING$
      FAULTSTRING$ = WORK$ ! [pos1+1] ! all to end
      Gosub STRPCHARS ! strip out any chars Unix cat doesn't like
    End If 
    Goto FLEDONE ! all rest is not needed
  End If 
End If 
If RESPFAIL Goto NXT_RLINE ! no paydirt yet!
If WRKLINE$[1,1] = "<" ! get the event type
  Let EVTYPE$ = WRKLINE$[2] To " " : POS0 ! up to 1st space
  Call String(1,EVTYPE$)
  If EVTYPE$ = "REPLY" ! no data response
    RETFLG = -1;UPDTTYPE = -1
    Goto FLEDONE
  End If 
  If EVTYPE$ = "ORDERSTATUSSUMMARYEVENT" ! main one we need
    UPDTTYPE = 1 ! instead of evtype chk
    VARNM$ = "<ORDERNUMBER" ! check order #
    Gosub CHK_LINE
    If POS1
      Gosub PARS_DATA
      ORDERID = TEMP$
    End If 
    VARNM$ = "<TRIGGER"
    Gosub CHK_LINE
    If POS1
      Let TEMP$ = WRKLINE$[POS1 + 15] To "''>" : POS2 ! after 1st " to next "?
      Call String(1,TEMP$) ! UC it
      TRIGR$ = TEMP$
    End If 
    VARNM$ = "<STATUS"
    Gosub CHK_LINE
    If POS1
      Gosub PARS_DATA ! this one is between ><
      EVSTAT$ = TEMP$
      Call String(1,EVSTAT$)
    End If 
	VARNM$="<REFERENCENUMBER" ! try for Invoice
	gosub CHK_Line
	if pos1
		gosub PARS_Data ! between >< to get Inv:xxxx
		InvNo=temp$[5]
	Endif
    VARNM$ = "<PRINTEDRECEIPTNUMBER"
    Gosub CHK_LINE ! will only be on finalize - fulfilled events
    If POS1
      Gosub PARS_DATA ! between the ><
      PRN$ = TEMP$
    End If 
	excepl=0;POS1=0
	VARNM$="EXCEPTION" ! look for the word anywhere
	Gosub CHK_LINE ! in eventstatus or linestatus
	! WE ONLY WANT FINALS NOT OTA'S (WHICH THEN ALSO GET FINALS!)
	If TRIGR$[1,3] = "FIN" AND POS1>0 ! not delivered as required
	! 2 types seen - single line or whole order
		excepl=1 ! in case (we found word)
		if EVSTAT$[1,4] = "EXCE" let excepl=9 ! whole order exception
		if EVSTAT$[1,4] = "PART" let excepl=5 ! line(s) exception
		hldwork$=WRKLINE$ ! for later parsing
	endif
  End If 
  If EVTYPE$ = "USERSTATUSEVENT" ! for Roadnet
    UPDTTYPE = 2 ! instead of evtype check later
    VARNM$ = "<USERNAME"
    Gosub CHK_LINE
    If POS1
      Gosub PARS_DATA
      USRNM$ = TEMP$
    End If 
    VARNM$ = "<STATUS"
    Gosub CHK_LINE
    If POS1
      Gosub PARS_DATA
      EVSTAT$ = TEMP$
      Call String(1,EVSTAT$)
    End If 
  End If ! use
  If EVTYPE$ = "PAYMENTRECEIVEDEVENT"
    ! has order, customer, amount, type, driver
	let UPDTTYPE=3;PAYTYPE$=""
	VARNM$ = "<ORDERNUMBER" ! check order #
    Gosub CHK_LINE
    If POS1
      Gosub PARS_DATA
      ORDERID = TEMP$
    End If 
	VARNM$ = "<PAYMENT TYPENAME" ! payment type
    Gosub CHK_LINE !ie:20 0123456789312345678941234      
    If POS1 ! comes in as <payment typename="check" paymentTypeId="2">
      Let TEMP$ = WRKLINE$[POS1 + 19] To "'' " : POS2 ! after 1st " to next " ?
      PAYTYPE$ = TEMP$
    End If 
	if rtrim$(paytype$)="" let PAYTYPE$="CASH" ! default to something
  Endif ! of payment
End If 
NXT_RLINE: Rem next
Goto INFLE_LOOP ! next line
READ_TEMPLATE: Rem read (needs any processing?)
Read #CH_INFLE;WRKLINE$;
STRPCCHAR: Rem "remove cr/lf etc
If Len(WRKLINE$) > 1 ! not >= as a couple lines of \15 only!
 if WRKLINE$[Len(WRKLINE$)] < " "
  WRKLINE$[Len(WRKLINE$)] = "" ! Strip control chars
  Goto STRPCCHAR
 endif
End If 
Return 
CHK_LINE: Rem See if line holds what we're looking for
WORK$ = WRKLINE$
Call String(1,WORK$) ! "ALL UPPERCASE
POS0 = 1;POS1 = 0;POS2 = 0
Search WORK$[POS0],VARNM$,POS1
Return 
PARS_DATA: Rem get the data from the line (chk'd to BEFORE ">"!!)
WORK$ = "";TEMP$ = "" ! clear working vars
Search WRKLINE$[POS0 + POS1],">",POS2
If POS2 ! got it
  WORK$ = "";TEMP$ = ""
  X = POS2 + POS0 + POS1
  Let WORK$ = WRKLINE$[X] To "<" : POS2 ! get all data from > to next <
  For X1 = 1 To Len(WORK$) ! "now strip any possible < or >
    If WORK$[X1,X1] <> ">" And WORK$[X1,X1] <> "<" And WORK$[X1,X1] <> ""
      TEMP$ = TEMP$ + WORK$[X1,X1]
    End If 
  Next X1
End If 
Return 
RTRIM_: Rem trim spaces from right side
Work$=RTrim$(Work$)
Return 
FLEDONE: Rem file reading is done - write order files
if orderid<=0 ! certain types no order
	if updttype<>2 let badord=1
	goto Orderfin ! no order - bypass
Endif
if updttype=3 and orderid>999999 goto orderfin ! not an order!
K1$ = " ",K1$;K1$[3] = ORDERID Using "######"
For X = 1 To 99
  If X < 20 Or X > 22 ! no deleted search
    K1$[1,2] = X Using "##"
    Search #CH_ROH,2,1;K1$,R[2],E \ If E > 1 Gosub ERR_SEARCH
    If Not(E) Goto GOTORDER
  End If 
Next X
! try invh
LET IAGE=90 ! DAYS (for bad/diff shipdate)
LET K1$=" ",K1$;K1$[1,6]=ORDERID USING "######"
HHKLOOP: ! TILL NO MATCH
SEARCH #CH_ROHHK,3,3;K1$,R[5],E
LET X3=K1$[1,6] \ IF X3<>ORDERID LET E=2
IF NOT(E) ! SAME
	Mat Read #CH_ROHH,R[5],0;H0;
	X$=" ",X$;X$=H0[9] USING "&&&&&&"
	Call DateToJulian(1,x$,X$,E)
    If E Let X$ = Str$(Tim(6)) ! GOSUB ERR_SEARCH:
    JDATE = X$;TODAY = Tim(6)
    If Abs(TODAY - JDATE) <= IAGE
      BADORD=0 ! OK RECENT
	  Mat Read #CH_ROHH,R[5],104;H5;
	  Mat read #ch_ROHH,R[5],446;PO$;
	  Mat Read #ch_ROHH,R[5],512;OREF;
	  R[4] = OREF[4] ! ros record
	  Mat Read #CH_ROSH,R[4],154;SRN; ! Shiplist #
	  If InvNo and InvNo=ORef[1] GOTO ORDERFIN ! same invoice - grab it!
	ENDIF
	GOTO HHKLOOP ! TRY ANOTHER FOR SAME ORDER
ENDIF 
BADORD = 1
Goto ORDERFIN
GOTORDER: Rem found our target
ORDREC = R[2]
BADORD = 0 ! flag
Mat Read #CH_ROH,R[2],0;H0;
Mat Read #CH_ROH,R[2],104;H5;
Mat read #ch_ROH,R[2],446;PO$;
Mat Read #ch_roh,r[2],512;OREF;
R[3] = H0[2] ! ros record
Mat Read #CH_ROS,R[3],154;SRN; ! Shiplist #
ORDERFIN: Rem "finish up
Close #CH_INFLE
If UPDTTYPE = 0 and respfail=0  ! no rename - new event - just leave file for research
	! as we get occasional cannot read event(Airclic issue) - ignore those
	! we only want new unprogrammed actual events!
	EMAILFROM$="noreply@acmepaper.com"
    EMailto$="jcs@ubsys.com"
    SYS$ = "$/usr/ub/sys/email.report -f ''",EMAILFROM$,"''"," -t ''",EMAILTO$,"''"," -s ''","Bad Event from Airclic","''"
	SYS$ = SYS$," -c ''","Encountered an unknown xml event.","''"
	CHAN = Findchannel() ! 99 \ Call "utchan5",CHAN
	!Signal 2,X1,CHAN,E \ If E Gosub ERR_SEARCH
	EMCH = CHAN
	Open #EMCH,SYS$
	Print #EMCH;""
	Print #EMCH;"File is named: ";xmlfle$
	Print #EMCH;""
	Print #EMCH;"Please see if this file can be identified and corrected"
	Print #EMCH;""
	Close #EMCH 
	! I guess that's all that is required? send xml file somehow?
	Goto OUTDONE
End If 
If UPDTTYPE = -1 ! reply that no events to send - delete file
  WORK$ = "rm -f " + XMLFLE$ + "* 2>&1" ! was "* >/dev/null 2>&1"? maybe for cp
  System WORK$
End If 
If UPDTTYPE = 1 ! order stat
  TMPLINE$ = DIRTO$ + TODRNM$
  If RTrim$(daydir$)<>""
    TMPLINE$ = TMPLINE$ + DAYDIR$
  End If 
  TMPLINE$ = TMPLINE$ + "osse_" + Str$(ORDERID) + "_"
  X$ = "oss" ! default -
  If TRIGR$[1,3] = "OTA" Let X$ = "ota"
  If TRIGR$[1,3] = "FIN" Let X$ = "fin"
  If EVSTAT$[1,4] = "PART" Let X$ = X$ + "pff"
  If EVSTAT$[1,3] = "FUL" Let X$ = X$ + "ful"
  If EVSTAT$[1,4] = "EXCE" Let X$ = X$ + "exc"
  TMPLINE$ = TMPLINE$ + X$
  X$ = Tim(8) Using "&&" + Tim(9) Using "&&" + Tim(10) Using "&&"
  X$ = X$ + Tim(11) Using "&&" + Tim(12) Using "&&" + Tim(13) Using "&&"
  TMPLINE$ = TMPLINE$ + X$
  WORK$ = "mv " + XMLFLE$ + " " + TMPLINE$ ! move from rec'd to final dir/name
  System WORK$
  command$="chmod go+rw "+tmpline$+ " 2>&1" ! as erp always -rw-r--r-- we want -rw-rw-rw-
  system command$
  if excepl and not(BadOrd) ! has exceptions - may as well do them NOW
	gosub excptrpt ! do parsing before pdf/image.in!!
  Endif ! falls on thru
  If PRN$[1,1] <> "" ! need the receipt - call for it
    Gosub GETPDFEVENT
  End If 
  ! send a copy to Roadnet?
  Sys$="cp "+tmpline$+" /v/roadnet/airclic_events/" ! whereever roadnet wants it
  ! system Sys$  ! unrem when ready
End If 
If UPDTTYPE = 2 ! user stat
  TMPLINE$ = DIRTO$ + TODRNM$
  If RTrim$(Daydir$)<>""
    TMPLINE$ = TMPLINE$ + DAYDIR$
  End If 
  TMPLINE$ = TMPLINE$ + "use_" + USRNM$ + "_"
  X$ = "use"
  If EVSTAT$[1,3] = "ARR" Let X$ = "arr"
  If EVSTAT$[1,3] = "FIN" Let X$ = "fin"
  If EVSTAT$[1,3] = "DEP" Let X$ = "dpt"
  If EVSTAT$[1,4] = "INIT" Let X$ = "int"
  If EVSTAT$[1,4] = "BREA" Let X$ = "brd"
  TMPLINE$ = TMPLINE$ + X$
  X$ = Tim(8) Using "&&" + Tim(9) Using "&&" + Tim(10) Using "&&"
  X$ = X$ + Tim(11) Using "&&" + Tim(12) Using "&&" + Tim(13) Using "&&"
  TMPLINE$ = TMPLINE$ + X$
  WORK$ = "mv " + XMLFLE$ + " " + TMPLINE$ ! move from rec'd to final dir/name
  System WORK$
  command$="chmod go+rw "+tmpline$+ " 2>&1" ! as erp always -rw-r--r-- we want -rw-rw-rw-
  system command$
  ! send a copy to Roadnet?
  Sys$="cp "+tmpline$+" /v/roadnet/airclic_events/" ! whereever roadnet wants it
  ! system Sys$  ! unrem when ready
End If 
if updttype=3 ! payment
	TMPLINE$ = DIRTO$ + TODRNM$
  If RTrim$(Daydir$)<>""
    TMPLINE$ = TMPLINE$ + DAYDIR$
  End If 
  TMPLINE$ = TMPLINE$ + "pay_" + + Str$(ORDERID) + "_"
  X$ = Lcase$(paytype$)
  TMPLINE$ = TMPLINE$ + X$
  X$ = Tim(8) Using "&&" + Tim(9) Using "&&" + Tim(10) Using "&&"
  X$ = X$ + Tim(11) Using "&&" + Tim(12) Using "&&" + Tim(13) Using "&&"
  TMPLINE$ = TMPLINE$ + X$
  WORK$ = "mv " + XMLFLE$ + " " + TMPLINE$ ! move from rec'd to final dir/name
  System WORK$
  command$="chmod go+rw "+tmpline$+ " 2>&1" ! as erp always -rw-r--r-- we want -rw-rw-rw-
  system command$
Endif
Goto ORDFINISH
STRPCHARS: Rem as we use cat - we need to strip 'invalid' chars
WORK$ = FAULTSTRING$
If Len(WORK$) = 0 Return 
For X = 1 To Len(WORK$)
  If WORK$[X,X] = ")" Let WORK$[X,X] = " "
  If WORK$[X,X] = "(" Let WORK$[X,X] = " "
Next X
FAULTSTRING$ = " ",FAULTSTRING$
FAULTSTRING$ = WORK$
Return 
GETPDFEVENT: Rem need - DO AS THE LAST ROUTINE!!!
If ORDERID = 0 And (PRN$[1,1] = "" Or PRN$[1,5] = "     ") Return 
WORK$ = "files/txt/acl.getpdf.pl" ! "txt/acl.getpdf.xmlo"
Call FindF(WORK$,FOUND)
If Not(FOUND) Return ! not there - cannot do
TMPFLE$ = WORK$ ! save name of perl script!
! TODAY$ = WORK$[1,4] + "-" + WORK$[5,6] + "-" + WORK$[7,8] ! need for transid
TEMP$ = "" \ Call Time(TEMP$) ! get todays info
WORK$ = TEMP$[1,13] ! just the MMM dd, yyyy
X1 = 5 ! need yyyymmdd
Call VerifyDate(WORK$,X$,E,X1)
WORK$ = X$[1,8] ! yyyymmdd
WORK$[9] = Tim(11) Using "&&" ! hour
WORK$[11] = Tim(12) Using "&&" ! minute
WORK$[13] = Tim(13) Using "&&" ! second
Today$=Work$[1,4]+"-"+Work$[5,6]+"-"+Work$[7,8] ! YYYY-MM-DD
WORK$[15] = ORDERID Using "&&&&&&" ! order
INXMLFLE$ = WORK$[15,20] + "_" + WORK$[3,8] + "_pr" ! OOOOOO_YYMMDD_pr (adds the .pdf)
WORK$ = " ",WORK$
WORK$ = TMPFLE$ + " " + PRN$ + " " ! script + prtrecnum
TEMP$ = Str$(ORDERID)
TEMP$ = TEMP$ + TODAY$[6,7] + TODAY$[9,10] + " " ! OOOOOOMMDD ! transid
TEMP$ = TEMP$ + DIRTO$ + TODRNM$
!If CUSTOM_CUSTOMER$ = "ACME"
  TEMP$ = TEMP$ + "pdfs/"
!End If 
TEMP$ = TEMP$ + INXMLFLE$ ! so goes to dirto$,Todrnm$,name
WORK$ = WORK$ + TEMP$ ! full command line
System WORK$,X2
If Not(X2)  AND NOT(BADORD) ! no error in command? now do imaging (UNLESS NO ORDER FOUND!)
  ! remmed above (! and not(badord) for dl4 test ********************
  
  IMAG$ = DIRTO$ + TODRNM$ 
  !If CUSTOM_CUSTOMER$ = "ACME"
    IMAG$ = IMAG$ + "pdfs/"
  !End If 
  IMAG$ = IMAG$ + INXMLFLE$ ! path from above temp$
  command$="chmod go+rw "+IMAG$ + "* 2>&1" ! as erp always -rw-r--r-- we want -rw-rw-rw-
  system command$
  Call "acl.image.in.dl4",IMAG$,ORDERID,H0[4],H0[10],Intco
  ! no imaging = dl4 test ******************************************
  ! ALL FILES CLOSED & OTHER FILES OPENED IN image.in!!!
Else ! bad command or no order
  WORK$=DIRTO$ + TODRNM$ + "pdfs/" + INXMLFLE$ + "*"
  temp$=DIRTO$ + TODRNM$ + "except/"
  work$=work$+" "+temp$ ! move pdf & tiff to except/
  COMMAND$ = "mv " + Work$ + " 2>&1"
  system command$
  ! also mentioned an email with details (as done in 226a)
  EMAILFROM$="noreply@acmepaper.com"
  EMailto$="anavarro@acmepaper.com; jcs@ubsys.com"
  SYS$ = "$/usr/ub/sys/email.report -f ''",EMAILFROM$,"''"," -t ''",EMAILTO$,"''"," -s ''","Bad Order from Airclic","''"
	SYS$ = SYS$," -c ''","Encountered an order not found.","''"
	CHAN = Findchannel() ! 99 \ Call "utchan5",CHAN
	!Signal 2,X1,CHAN,E \ If E Gosub ERR_SEARCH
	EMCH = CHAN
	Open #EMCH,SYS$
	Print #EMCH;"Order ID as sent= ";Str$(OrderID)
	Print #EMCH;"File is named: ";temp$;Inxmlfle$;"*"
	Print #EMCH;"Event data file name: ";tmpline$
	Print #EMCH;""
	Print #EMCH;"Please see if this file can be identified and corrected"
	Print #EMCH;""
	Close #EMCH 
	! I guess that's all that is required? send pdf somehow?
End If 
Return 
CCHK_LINE: Rem continue checking Line (start at SPOS)
WORK$ = WRKLINE$
Call String(1,WORK$) ! "ALL UPPERCASE
POS0 = SPOS+1;POS1 = 0;POS2 = 0
Search WORK$[POS0],VARNM$,POS1
Return 
ExcptRpt: ! add on task 35264 - exception report
if RTrim$(HldWork$)="" return ! no string??
fle$="3/ACEXCEPT"+STR$(Intco)
call Findf(fle$,x3)
if not(x3) return ! No file - no dice
CH_EXRPT=findchannel()
Open #ch_exrpt,fle$
! ok - first recheck 
WrkLine$=HldWork$ ! reset working variable
VARNM$="EXCEPTION" ! look for the word anywhere
Gosub CHK_LINE ! in eventstatus or linestatus (always from 1)
if not(POS1) goto ERPDone
X3[6]=POS1 ! where found
! if whole order - no <orderItemStatusSummary before it
VARNM$="<ORDERITEMSTATUSSUMMARY"
Gosub CHK_LINE ! (always from 1)
iF POS1>X3[6] ! it's an order exception
	Mode=9 !! all lines also exceptions
Else ! it's a line exception
	Mode=5 !! 1 or more line exceptions
endif
! always get the customer & name from file
VARNM$="<CUSTOMERNUMBER"
gosub chk_line
if pos1
	Gosub PARS_DATA ! between the ><
	CustNo=TEMP$
endif
VARNM$="<CUSTOMERNAME"
GOSUB CHK_LINE
IF POS1
	GOSUB PARS_DATA ! between the ><
	CNam$=TEMP$
endif

If mode=9 ! need next
	SPOS=X3[6]+10 ! to after header word
	VARNM$="EXCEPTION" ! look for the word anywhere
	Gosub CCHK_LINE ! should be at line level now
	if pos1=0 goto ERPDone ! no more?? - get out now
	X3[6]=pos1+pos0 ! for exception placeholder
Endif
! now get line details
LNDETLLOOP: ! loop here
if x3[6]<200 goto ERPDOne ! ?? bad data
SPOS=X3[6]-200 ! to get back to line beginning
VARNM$="<ORDERITEMSTATUSSUMMARY"
Gosub CCHK_LINE
if POS1=0 goto ERPDone ! no more line data
LPOS=POS1+POS0 ! line start
VARNM$="<LINENUMBER" ! is actually the Product Code
SPOS=LPOS \ gosub CCHK_Line
if pos1=0 goto NxtLDTL
gosub PARS_Data ! get between >< for prod code
TPROD$=Temp$+Spaces$ ! may have letter after id (dupe on order)
VARNM$="<DESCRIPTION"
SPOS=LPOS \ gosub CCHK_Line
if POS1
	gosub pars_data
	TDESC$=Temp$
Else
	clear TDesc$
Endif
VARNM$="<PURPOSENUMBER"
SPOS=LPOS \ gosub CCHK_Line
if pos1
	gosub pars_data
	opurp$=Temp$
Else
	OPURP$="Unknown"
Endif
VARNM$="<EXPECTEDQUANTITY"
SPOS=LPOS \ gosub CCHK_Line
if pos1
	gosub pars_data
	QSHP=Temp$
Endif
VARNM$="<ACCEPTEDQUANTITY"
SPOS=LPOS \ gosub CCHK_Line
if pos1
	gosub pars_data
	QDEL=Temp$
Endif
VARNM$="<REASONDESCRIPTION"
SPOS=LPOS \ gosub CCHK_Line
if pos1
	gosub pars_data
	RDesc$=Temp$
Else
	RDesc$="Reason Not Sent"
Endif
! ok - now we have to find the line (for price & UM)
Chan=CH_ROL
if H0[0]=30 or H0[0]=31 let chan=CH_ROLH
dupno=0
work$=RTrim$(TPROD$) ! trim end spaces
X$=Work$[len(work$)] ! get last char
If (X$>="A" and X$<="Z") or (X$>="a" and X$<="z") ! only alpha last char
	POS0=1;pos1=0
	Search alpha$[pos0],X$,POS1
	if pos1 let dupno=pos1 ! should be 1,2,3 etc
Endif
K4$=" ",K4$;nodup=0;NoOrd=1
K4$=ORDERID Using "######"
if chan=ch_rolh let K4$=InvNo using "##########"
ROL_Loop: ! til found or diff
Search #chan,3,1;K4$,r[7],E \ if e goto wrtexcpfle ! Nxtldtl ! wrtexcpfle
If chan=ch_rolh
	X3=k4$[1,10] \ if x3<>InvNo goto wrtexcpfle ! Nxtldtl ! wrtexcpfle
Endif
if chan=Ch_rol
	x3=K4$[1,6] \ if x3<>ORDERID goto wrtexcpfle ! Nxtldtl ! wrtexcpfle
Endif
! read line
	mat read #chan,r[7],8;L3;
	mat read #chan,r[7],16;l4;
	mat read #chan,r[7],32;l5;
	mat read #chan,r[7],56;l6;
	mat read #chan,r[7],80;L$;
	mat read #chan,r[7],140;L1$;
	mat read #chan,r[7],168;L7;
	MAT READ #chan,R[7],250;UN;
	mat read #chan,r[7],256;s2;
	mat read #chan,r[7],370;s3$;
	mat read #chan,R[7],404;OLM;
	mat read #chan,r[7],446;eun;
	mat read #chan,r[7],452;unf;
	x$=spaces$
	clear x$ ! clear and null it
	X$=L1$[1,12]
	If RTrim$(X$)=RTrim$(TProd$) goto Cntline ! matches exact - continue
	! if not match - Why? see if duplicate (w/letter appended)
	PLen=Len(x$) ! check if base prod matches
	if dupno and L1$[1,PLen]=TProd$[1,Plen] ! line has a dupe and main match
		nodup=nodup+1
		if nodup=dupno goto CntLine ! same dupe - continue
	Endif
	Goto ROL_Loop ! continue - not right one
	CntLine: ! continue - correct product
	NoOrd=0 ! found it
	if rtrim$(TDesc$)="" let TDesc$=L$[1,30]
	QUM$="EACH      EA  "
	If un[0]>0 Mat read #ch_CCD,UN,0;QUM$;
	if un[0]=-1 let QUM$="CWT       CWT "
	if un[0]=-2 LET QUM$="LOT       LOT "
	IF UN[0]=-3 LET QUM$="POUND     LB  "
	nonstock=0 \ if l3[0]=1 let nonstock=0
	if not(nonstock)
		MAT READ #CH_PROD,L4[0],156;B;
		MAT READ #CH_PROD,L4[0],256;A;
		MAT READ #CH_PROD,L4[0],460;A1;
		mat read #ch_prod,l4[0],512;pfu1;
		MAT READ #CH_PROD,L4[0],554;PFU2;
	ENDIF
	GOSUB L_30000: ! SET UP W/ORD FACTORS
	LET cnvtu[0]=0;cnvtu[1]=un[0];cnvtu[2]=2
	let cnvta=OLM[3]
	gosub CONVERT
	Price=Amount ! price in Qty UM?
	! okay let's build record
	wrtexcpfle: ! in case still want even if no order?
	if noOrd ! Order bad / not found 
		let price=0;QUM$[11,14]="UNK "
		h0[7]=orderid;h0[4]=custno
		h0[9]=currdate;srn[1]=0
		PO$="none"+Spaces$;l1$=tprod$
		l3[2]=l3[2]+1 ! give a line no?
	Endif
	K3$=" ",k3$
	K3$[1,6]=ORDERID using "######" ! ORDER !!
	K3$[7,10]=L3[2] using "####" ! Line
	K3$[11]=H0[9] using "######" ! ship date
	Search #CH_EXRPT,2,1;k3$,R[20],E
	if not(e) ! already one on file
		goto NXTLDTL ! re-run? (let's call it that)
	Endif
	Let E=2;R=0
	Search #CH_EXRPT,1,0;k3$,R,E
	if e gosub err_search ! error 11000
	Search #CH_EXRPT,4,1;K3$,R,E
	if e gosub err_search ! error 11000
	Write #CH_EXRPT,r,0;H0[7];
	write #ch_exrpt,r,4;H0[4];
	WRITE #CH_EXRPT,R,8;H0[9];
	x2=SRN[1] ! ONLY NEED 2% - NOT 3%
	WRITE #CH_EXRPT,R,12;X2;
	WRITE #CH_EXRPT,R,16;INVNO;
	WRITE #CH_EXRPT,R,22;QSHP;
	WRITE #CH_EXRPT,R,28;QDEL;
	WRITE #CH_EXRPT,R,34;PRICE;
	WRITE #CH_EXRPT,R,40;PO$;
	WRITE #CH_EXRPT,R,60;L1$[1,12]; ! prod on order
	WRITE #CH_EXRPT,R,72;OPURP$;
	WRITE #CH_EXRPT,R,92;TDESC$;
	WRITE #CH_EXRPT,R,122;QUM$[11,14];
	X$="N" \ IF L6[5] LET X$="Y"
	WRITE #CH_EXRPT,R,126;X$[1,1];
	WRITE #CH_EXRPT,R,130;RDESC$;
	WRITE #CH_EXRPT,R,180;L3[2]; ! LINE NO!
	WRITE #CH_EXRPT,R,182;CNAM$; ! cust name
	!! all done with exception

NXTLDTL: ! look for next exception
VARNM$="EXCEPTION" ! look for the word anywhere after where we last got it
SPOS=X3[6]+15 ! to after the last found exception
Gosub CCHK_LINE ! should be at line level now
if pos1=0 goto ERPDone ! no more?? - get out now
X3[6]=POS1+POS0 ! set to where found & continue
goto LNDETLLOOP
L_30000: ! ===== set units for conversions (stock/nonstock version)
! IF ZLINE GOTO L_30099: ! "message line
LET A[6]=L6[4];A[5]=UNF[5] \ IF NOT(A[5]) LET A[5]=1;UNF[5]=1
LET B[23]=L6[2];A1[3]=UNF[4] \ IF NOT(A1[3]) LET A1[3]=1;UNF[4]=1
LET PFU1[0]=EUN[0];PFU1[1]=UN[0] ! "base and selling units
LET PFU1[2]=UN[1];PFU1[3]=UN[2] ! "pricing and costing
LET PFU1[4]=EUN[1] ! "purchasing
LET PFU1[5]=0;PFU1[6]=0;PFU1[7]=0
LET PFU1[8]=UN[0];PFU1[9]=UN[0];PFU1[10]=EUN[1] ! "stock,sell,purch dflt
LET PFU1[11]=UN[2];PFU1[12]=UN[1] ! "cost,price dflt
IF NOT(NONSTOCK) GOTO L_30060: ! "leave as is
LET PFU1[13]=UN[0];PFU1[16]=EUN[0];PFU1[17]=EUN[0] ! "prod,up,bkn dflt
If PFu1[11]=-3 Or PFU1[12]=-3 ! "Catch Wgt Itm N/S
	Let PFU1[15]=-3;CTWT=PFU1[15]
Else
   Let PFU1[15]=0;CTWT=0
Endif
LET PFU1[18]=UN[0];PFU1[19]=UN[0] ! "pack,size dflt
L_30060: LET PFU2[0]=UNF[0];PFU2[1]=UNF[1] ! "selling and pricing factor
LET PFU2[2]=UNF[2];PFU2[3]=UNF[3] ! "costing and purchasing
LET PFU2[4]=0;PFU2[5]=0;PFU2[6]=0
FOR X1=1 TO 4
	FOR X2=0 TO X1-1
		IF PFU1[X1]=PFU1[X2] LET PFU1[X1]=0;PFU2[X1-1]=0
	NEXT X2
NEXT X1
L_30099: RETURN 
CONVERT: Rem "UNIT CONVERSION RETURNS AMOUNT  (rev 01/07/1992)   ! 20040 REM
If CNVTU[2] = 3 Or CNVTU[2] = 4 Goto CVTSTARTA
If CNVTU[2] = 1 And CNVTU[1] = CNVTU[0] Let AMOUNT = CNVTA \ Goto CVTDONE
If CNVTU[0] = -2 Or CNVTU[1] = -2 Let AMOUNT = CNVTA \ Goto CVTDONE
If CNVTU[2] = 0 Goto CVTSTARTA
If Not(CNVTA) Let AMOUNT = 0 \ Goto CVTDONE
CVTSTARTA: Goto CVTSTARTB	!!-!! was If Spc(4) > 1280 Goto CVTSTARTB

CVTSTARTB: Rem "====== unibasic 5+ logic
Call "MXPRCONV5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
If CNVTU[2] = 0 Goto CVTDONE
If FLAG Let E = FLAG !!-!! \ Gosub ERR_SEARCH
AMOUNT = CNVTA
CVTDONE: Return 
ERPDone: ! exceptions finished
if ch_exrpt Try Close #ch_exrpt Else Rem
Return ! done with exception report
ORDFINISH: Rem finish
!if excepl and not(BadOrd) ! has exceptions - HAS TO HAPPEN BEFORE IMAGE.IN CALL
!	gosub excptrpt ! do parsing
!Endif ! falls on thru
OUTDONE: Rem finished
If Err 0 Rem
For X = 1 To 10
  If CCHAN[X] <= 0 ! we opened
    X1 = Abs(CCHAN[X]) ! stored as 0-chan
    If X1 > 0 
		try Close #X1 else rem
	endif
  End If 
Next X
If Err 0 Gosub ERR_TRAP
OUTEND: Rem outta here
End 
Rem {begin src/inc/rtn.getchan.i}
GETCHAN: Rem search for open channel (counts down from supplied chnl #)
chnl=findchannel() ! use dl4 way
Return 

ERR_SEARCH: Rem                                            
ENUM = E;ELINE = Spc(16);CTERR = 0                         
If E = 5 Let CTERR = Err(8)                                
e$ = "RETURN STATUS",(E + (CTERR * .001))                  
e$ = e$,"/ STATEMENT",ELINE," IN PROGRAM " + Msc$(4)       
Error 11000                                 
End
Rem {begin rtn.error.s}
ERR_TRAP: Rem *Error routine (escape trap)   V3.1 8/94 G.DOSCHER/REK
include "src/callmainerrnet_call.inc"
End