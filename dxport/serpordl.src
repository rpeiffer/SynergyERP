!"serpordl" === description  synergy erp  order entry/edit system
!  for line entry/edit
! 
! loadsave -w -n 100,10 -o prog/dxport/serpordl.dl4 src/serpordl.src
!
! **** IF YOU SEND A NEW FIELD TO THE WEB - YOU MUST ALSO ADD TO SERPQTEL!!! *******
!  ******* DON'T FORGET TO CHANGE SERPQTEL - IF APPLICABLE! ****************
!  ******* NATIVE HAS 1 PROGRAM - ERP HAS 2! *******************************
!  03/26/2008 started
!  05/07/2008 revised prod & prodwhse structs
!  08/17/2011 cutting
!
! NOTE: IF WEB SIDE SEES RETURNSTATUS=2 - IT WILL CALL THE KIT PAGE!!
!   SO DO NOT USE RETURNSTATUS=2 EXCEPT FOR KITS! 
!
! custom_customer
! OMAHA -default ord type 38 to update stock=N cct176559/task10467
! OMAHA -%Cut/Punch Markup on Cut cct#208465/task#10448 
! GenPaper - 233990 - DO NOT ALLOW THE PRICE TO BE CHANGED IF THE PRICE ON THE LINE
!	IS FROM A CONTRACT.      
! 03/11/2013 - EVAP - order type 36 & 37 are STANDARD
! --------------  notes for rev10 upgrade for White River Paper -----------------
! ccts 20106, 234718, 173286
! 12/22/03 jliu cct173286 show open order qty on o/t 4 and 15.
! ------------------------------------------------------------------------------
! task 27229 - 08/02/13 - new order line sell whole units only flag (SWUO)
! 09/2013 - NEW LASTPRICE FILES AFTER rev1.8.4.0
! task 57205 - add new edit program with source=2082 (can add lines & chg qty only)
include "src/copyright.inc"
!
include "src/inc/filecust.inc"
include "src/inc/fileprod.inc"
include "src/inc/sql_prod.inc"
include "src/inc/fileordhead.inc" ! combined ros,rot,roh
include "src/inc/filerolz.inc" ! lines
include "src/inc/filesproddesc.inc" ! nstk lines
include "src/inc/fileprodwhse.inc" ! prodwhse
include "src/inc/fileccodesz.inc" ! u/m file (custom for System UM's)
include "src/inc/filesordlotz.inc" ! sordlot (fixed dir's)
include "src/inc/filesprodlot.inc" ! sprodlot
include "src/inc/filelastprice.inc" ! last price
include "src/inc/filesllstprice.inc" ! shiplist last price
include "src/inc/filecommodity.inc" ! commodity detail
include "src/inc/filecommhead.inc" ! commodity header
include "src/inc/fileprodgroup.inc" ! prod groups
include "src/inc/filesprodcatgy.inc" ! prod sls ctgy
include "src/inc/filedeptfle.inc" ! dept file
include "src/inc/filematcode.inc" ! mat'l code
include "src/inc/fileentdby.inc" ! entered by
include "src/inc/filewhinfo.inc" ! whse info - for whselist
include "src/inc/filetaxcode.inc" ! tax code file
include "src/inc/filea80vm.inc" ! vendor 
include "src/inc/filespecprice.inc" ! special price file
include "src/inc/filerebatedtlz.inc" ! rebate details
include "src/inc/filebuyer.inc" ! buyer
include "src/inc/filehazname.inc" ! hazname
include "src/inc/fileroltag.inc" ! rol tag (zlines)
! addon files for line types
include "src/inc/filesordlkitl.inc" ! kit lines
! serial numbers
! catch weight weights
! PO'S for non-stocks
include "src/inc/fileedittrack.inc" ! edit tracking
include "src/inc/fileparcntrol.inc" ! par cnt functionality
include "src/inc/filerfpickq.inc" ! par cnt functionality

include "src/inc/filepohead.inc"
include "src/inc/filepoline.inc"
! for multicurrency
include "src/inc/filecurrency.inc" ! currency exchange file

! external libs for subs/functions
External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus

External Lib "ubsfunc.dl4"
Declare External Sub getportdefault,taxflag,GetCostLevels,LogAccess
Declare External Function OpenFile,PDate$,taxable,JDate$,FormatDate2$
Declare External Function ChkAltItem$,CHKBADCHARS,clrtxtc$
Declare External Function OpenMySQLMirror

External Lib "libprodconv.lib"
Declare External Function ConvProdAmount

External Lib "librasl.lib"
Declare External Sub allocordlot,chkwhrasl

External Lib "libprodwh.lib"
Declare External Sub mxwhcreate,chkrprod
Declare External Function getwhavail,getmillflg

External Lib "libprod.lib"
Declare External Sub ProdList,ProdGroup,UMDList,CompIList
Declare External Sub SubstIList,SPRCIList
Declare External Function ComplFlag,SubItmFlag,SPRCIFlag
Declare External Function getpravail,getumrec,getMSDS,ChkPrdUM

External Lib "ubsprconv.dl4"
Declare External Function XUnit$

External Lib "libedittrack.lib"
Declare External Sub MakeEdittrack

External Lib "librebates.lib"
Declare External Sub rebates

External Lib "libprice.lib"
Declare External Sub SysPriceCalc

!External Lib "turboadd.dl4"  ! let's use just 1 program
!Declare External Sub TurboAdd  ! instead of 2
External Lib "libprodwords.lib"
Declare External Sub apturbo

External Lib "serpkitl.dl4"
Declare External Sub DELOKIT

External Lib "ordcpinv.dl4"
Declare External Sub ordcpinv

External Lib "libcpi.lib"
Declare External Sub cpiordchk,CPIOrdAlerts
Declare External Function CPIQtyAvail

include "src/inc/filecontracth.inc" ! contract header
include "src/inc/filecpidet.inc" ! CPI detail trailer

Declare Intrinsic sub programdump,env,Logic,FindF
Declare Intrinsic Sub DateToJulian, JulianToDate, FormatDate
Declare Intrinsic function findchannel

! internal subs/function
Declare Sub OpenFiles, GetNewProdDtl,GetPrice,Factorum,WhseList
Declare Sub RePrice,StkUpList,OrdAddlDtl,SetUPSpecs,SetNewRol
Declare Sub SetPRtoRol,LineMainDtl,getordlines,getcomplist,getcust
Declare Sub setpricelist,SetNewProdline,PriceWrkData,CostWrkData,CalcDirLoad
Declare Sub UpdtLines,DELOLINE,EdtTrkDo,updatelog,SUCMSELLN,CMCPILINE
Declare Sub NSDefault,NSSaveItem,NSGetItem,NSBuildProd,ChkTOWhse
Declare Sub getot15list,getsubstlist,getsupsdlist,ROLTAG,BOREMCHK
Declare Sub WHSEAVAIL,NSFRMLP,gpsumm,DelParCnt,DelRFPick,verifystat
Declare Sub GetCutDetails,SubmitCutDetails,dolineextens,Check_If_SO_Linked_To_PO
Declare Sub GetNetPrcCost,SProdDtl,chk4sns,ProduceCPIAlerts
Declare Sub GETIOLINES,MainDtlHdr,prcamalg,GetPOLines,LinkPOLine
Declare Sub OLineCopy,CPNSTKLINE
Declare Function GetOrdRec,getrbtcost,UMtoFactor,getnxtline,ChkHldcode
Declare Function Chkkit$,chktagfle$, GetAskLP,getbopolink$
OPTION GOSUB NESTING 16  ! Default is 8
Try
	Option String Redim is legal ! in case subs dim/use same names
	! NOTE ALWAYS PRR for Product Rec, PWR for Prodwhse Record!
	! and OHR as header Record
	dim e$[500],buttonlist$[5,50],nextlist$[5,100] !error handling variables
	dim action$[30],options$[30],userid$[8],b$[200],action1$[30],Action2$[30]
	Dim bsdel$[10],esdel$[10],rdel$[10],fdel$[10],rstr$[2000]
	dim tmp$[1200],tmp1$[500],Msgdesc$[150],Field$[1,30]
	dim Message$[500],WebStr$[2500],SessionID$[200],rolkey$[60]
	Dim Prod$[12],ProdKey$[60],P9$[50],P60$[50],P61$[256],p8$[7]
	Dim QMask$[20],PMask$[20],Key1$[60],UA2$[50],TPWKey$[60]
	Dim OrgProd$[12],LPType$[5],tmp2$[100],custom_customer$[30],FLG$[6]
	dim 1%,cnvcu[10],3%,cnvca[10],keycurr$[10],3%,rec_curr,currfact
	dim 3%,dsp_extucost,dsp_extncost,dsp_extuprice,dsp_extnprice
	dim Blank$[100] \ Blank$=" ",Blank$
	dim ucf$[10]
	Dim 1%,PRC,PWC,CCC,OHC,OTC,OSC,OLC,CMC,SWUO
	dim 1%,cnvtu[2],3%,amount,cnvta,cpiChan[99]
	dim 1%,cost_lev[4],Whse,debug,ordpad,Invoice,2%,Q0[1],cust
	Dim 2%,X2[9],NumProd,OrderNo,LD,UA2[2],RASL[2],source
	Dim 2%,maxcnt \ maxcnt=50 ! init max records in arrays for list
	Dim 3%,PRR,OHR,PWR,OLR,FChan[30],FRec[99]
	Dim 3%,SUM,SQty,SHQty,BOQty,R[99],O1,UB0[16]
	dim 3%,FlePtr[20,1],Specs[50] ! for price
	DIM 3%,INVNUM,X3[9],tmprec,WhsAvail[9]
	dim List$[maxcnt,1500] ! for .net (larger size - ZLines)
	dim slist$[maxcnt,1500] ! second list
	dim tlist$[maxcnt,1500] ! third list
	Dim Dlist$[999,500] ! for line copy from Ord/Inv
	dim dmsg$[256],dblog$[60] \ dblog$="files/6/ol.log" ! fields for DEBUG

	Dim PR. as prod
	Dim sql_prod. as sql_prod
	Dim pw. as prodwhse
	dim roh. as roh ! order header
	dim ros. as ros ! order ship to file
	dim rot. as rot ! order total file
	dim rol. as rolnew ! order lines
	dim cmc. as commhead ! commodity code
	Dim cust. as cust ! customer master
	dim clp. as lastprice ! customer last price
	dim umc. as ccodes ! um codes file
	dim whi. as whinfo ! whse info file
	Dim Nstk. as sproddesc ! non-stock file
	Dim ETR. as edittrack ! EDITTRACKING
	dim psc. as sprodcatgy ! product category
	dim matc. as matcode ! material code
	dim buy. as buyer ! buyer 
	dim haz. as hazname ! haz material
	dim tax. as taxcode ! taxcode
	dim contracth. as contracth
	dim cpid. as cpidet
	Dim sd. as specprice
	   ! for currency exchange
	dim curr. as currency

	Def FNR(H) = Int(Abs(H) * 100 + .5) * .01 * Sgn(H)
	Def FNC(H)=Int(abs(H)*10000+.5)*.0001*Sgn(H)
	Def FNS(H) = Int(Abs(H) * 100) * .01 * Sgn(H) ! rounding to nearest penny
	Def FNQ(H) = Int(Abs(H) * 10 ^ Q0[1] + .1) * 10 ^ - Q0[1] * Sgn(H) 

	call dxopen()
	call GetSession(e$,CTLC,options$,action$,UserID$,intCo,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$,action1$,action2$)
	Call dxget("ORDERID",tmp$)                           
	call LogAccess(e$,"ORDER #: "+tmp$)
	e$=""
	debugDetail=0;debug=0 ! can do debug text by changing both to 1
	If debugDetail
		debug=1
		tmp$="serpordl"
		dmsg$[1,50]="-",dmsg$ \ Call updatelog(debug)               
		dmsg$="start...program "+tmp$ \ Call updatelog(debug)
	Endif
	Action$=UCase$(Action$)
	ACtion$=RTrim$(Action$) ! make sure UPPERCASE and No blanks at end
	Action1$=UCase$(action1$)
	Action1$=RTrim$(action1$) ! UC and trimmed
	Action2$=UCase$(action2$)
	Action2$=RTrim$(action2$) ! UC and trimmed
	if debugdetail
		dmsg$="SERPORDL ACTION "+action$
		If Action1$<>"" let dmsg$=dmsg$+" ACTION1 "+action1$ 
		if Action2$<>"" let dmsg$=dmsg$+" ACTION2 "+action2$
		Call updatelog(debug)
	Endif
	Mat Read #ctlc,61,0;P61$;
	!let p61$[136,136]="N"
	call OpenFiles() ! open all needed files
	call GetCostLevels(e$,Cost_Lev[],IntCO,UserID$) ! get cost security
	e$=""
	mat read #ctlc,52,60;P8$;
	Mat Read #ctlc,19,50;P9$;
	Mat Read #ctlc,60,50;P60$;
	Mat Read #CTLC,115,40;Q0;
	MAT  READ #CTLC,115,60;CUSTOM_CUSTOMER$;
	QMask$="----------#.##"
	tmp$="#",tmp$
	If q0[1]<=0 Let Q0[1]=2
	If Q0[1] Let Pmask$="-----------#.",tmp$[1,Q0[1]]     !price mask
	Custom_customer$=UCase$(Trim$(custom_customer$))
	SWUO=0 ! sell whole units only on new line 0=no, 1=yes
	If custom_customer$="SOUTHJERSEY" let SWUO=1
	if custom_customer$="SAFEWAY" let SWUO=1 ! task 38677
	!! SWUO=1 ! TEST TEST TEST
	!if custom_customer$="WENELSON"
	!	tmp$ = "cntrl/holdforpo"+Str$(Intco)
	!	Call FindF(tmp$,holdforpo)
	!Endif
	if p61$[74,74]="Y" let holdforpo=1
	IF P9$[29,29]="N" LET COST_LEV[1]=0 ! = SHOW COST IN OE
	! get the Usercntrl Rec #
	If Userid$="" or UserID$[1,2]="  "
		Call DXGet("S_USER.ID",tmp$) ! get from system variable
	Else
		tmp$=UserID$
	Endif
	Let UserID$=UCase$(tmp$) ! make sure it's UPPERCASE as that's what PM uses
	Let Key1$=UserID$+"          " ! space fill it
	UCC = OpenFile(-9988, intCo) \ if UCC=-1 Error 42
	Key1$[11]="" ! cut to length
	Search #UCC,2,1;Key1$,Rec,E
	If Not(E)
	  Let SCR=Rec
	  Mat Read #ucc,scr,200;UA2;
	  Mat read #ucc,scr,336;Ua2$;
	  MAT READ #UCC,SCR,652;UCF$;
	Else
	  Let SCR=0 ! 
	  UA2[0]=0;UA2$=" ",UA2$
	  UCF$=" ",UCF$
	Endif
	Close #UCC
	! GET additional user data flags
	REM UNPACK A2[0] TO B0[]                         
	FOR X1=0 TO 15                                          
		LET O1=2^X1 \ LET M1=1
		! CALL $LOGIC,M1,O1,A2[0],B0[X1] ! ub
		Call Logic(m1,O1,UA2[0],UB0[X1])
		LET UB0[X1]=SGN(UB0[X1])
	NEXT X1           
	CALL LOGIC(1,64,UA2[0],ADELLN)
	UB0[6]=ADELLN
	! this is for testing
	!call dxget("ORDERID",tmp$)
	!x3=tmp$
	!if userid$[1,4]="JIMS" ! x3=-101 ! 6057 or userid$[1,4]="JIMS" ! track EVERY WEB CALL!
	!	x=0
	!	getnxtsv: ! loop til not found
	!	tmp$="tmp/olsvpw"+Str$(x)+".txt"
	!	Call FindF(tmp$,FOUND)
	!	if found let x=x+1 \ goto getnxtsv ! til new one to save all web submits
	!	call dxsave(0,tmp$)
	!Endif
	call dxget("SOURCE",tmp$) \ source=tmp$ ! added 251 uses pos/pwo um
	Invoice=0
	if source=221 or source=223 or source=231 or source=251 let Invoice=1
	select case action$

	case "DROPLIST" !   send droplists 
		
		If Action1$="UMDROPLIST" ! doc = produmdroplist.doc
			Call DXGet("PRODID",prod$) \ prod$=UCase$(prod$)
			Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
			ProdKey$=Prod$
			Call dxget("LTYPE",tmp$)
			tmp$ = UCase$(tmp$)
			if tmp$[1,4]<>"NSTK" ! LET PRODKEY$[1,6]="ZNSTK " ! set to non-stock
				! need to get customer from header
				cust = 0  !! intialize it
				Call DXGet("ORDERID",tmp$)
				if tmp$<>"" 
					OrderNo=tmp$
					If OrderNo>0 and OrderNo<999999 and Not(Fra(OrderNo))
						OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
						If OHR>0 ! order found
							cust=roh.custnum
							tmp$ = ChkAltItem$(e$,IntCo,Prod$,cust)
							If tmp$ <> ""
								If tmp$[1,2] <> "  " 
									Let Prod$ = tmp$ ! has alt item
									ProdKey$=Prod$
								endif
							endif
						endif
					endif
				endif
				PrR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.) ! product mode=2 dir=1
				clear e$
				NonStk=0
			Else
				PRR=0;nonstk=1
				Call dxget("ORDERID",tmp$)                           
				orderno = tmp$  
				If not(orderno) goto EndUMDroplist: ! end um droplist
				If orderno <= 0 Or orderno > 999999 Or Fra(orderno)  
					ReturnStatus = 0                                   
					Message$ = "INVALID ORDER!"  
					 goto EndUMDroplist: ! end um droplist
				End If   
				Call dxget("LN",tmp$) ! +Str$(X1),tmp$)         
				LineNo = tmp$ ! line # (zero on new lines)
				If LineNo <= 0 Or LineNo > 999 Or Fra(lineno)  
					ReturnStatus = 0                                   
					Message$ = "INVALID ORDER LINE!"  
					goto EndUMDroplist: ! end um droplist
				End If   
				rolkey$ = " ",rolkey$                         
				rolkey$[1,6] = orderno Using "######"         
				rolkey$[7,9] = LineNo Using "###"       
				rolkey$[11] = "" ! cut to length (space @ 10) 
				OLR = filegetrolz(e$,OLC,"=",1,rolkey$,rol.)
				clear e$
				if olr<=0
					returnstatus=0
					Message$="Order Line Not Found"
					goto EndUMDroplist: ! end um droplist
				endif
				let prodkey$=rol.prodcode$
				Call SetPRtoRol()
			Endif
			if debugdetail
				dmsg$="UMDROPLIST PROD= "+prodkey$ \ Call updatelog(debug)
			Endif
			!
			! initialize status
		  If PrR<0 ! Product record not found
			 clear PR.
			 ReturnStatus=0
			 Message$="Error, Product not found"
		  else ! continue with list
			E$="" ! clear message
			tmp$=" " ! is passed
			If Not(NonStk)
				Call UMDList(e$,tmp$,PRC,PRR,List$[],IntCo,Pr.)
			Else ! nonstk - send whole list
				if olr>0
					Call UMDList(e$,tmp$,PRC,PRR,List$[],IntCo,Pr.)
				else
					clear tmp$ ! send other flag
					Clear Field$[]
					!if p9$[20,20]="F" let tmp$="F"
					let tmp$="F"
					!call filedroplistccodes(e$,list$[],maxcnt,CCC)
					call filedroplistccodesz(e$,list$[],maxcnt,CCC,"",Field$[],1,"",tmp$)
				endif
			Endif
			Let ReturnStatus=1
			Message$="OK"
			If E$<>""
			  Let ReturnStatus=0
			  Message$=E$
			Endif
		  Endif ! valid prod
			EndUMDroplist: ! end um droplist

		  if debugdetail
				dmsg$="UMDROPLIST sent "+message$ \ Call updatelog(debug)
		  Endif
		Endif ! action1=umdroplist

		If Action1$="WHSELIST" ! doc = Ordl-WhseDroplist.doc
			Call DXGet("PRODID",prod$) \ prod$=UCase$(prod$)
			Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
			ProdKey$=Prod$
			Call dxget("LTYPE",tmp$)
			tmp$ = UCase$(tmp$)
			if tmp$[1,4]="NSTK" let Prodkey$[1,6]="ZNSTK "
			If Prodkey$[1,6]<>"ZNSTK "
				PrR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.) ! product mode=2 dir=1
				clear e$
				NonStk=0
			Else
				PRR=0;nonstk=1
			Endif
			if debugdetail
				dmsg$="WHSELIST PROD= "+prodkey$ \ Call updatelog(debug)
			Endif
			!
			! initialize status
		  If PrR<0 ! Product record not found
			 clear PR.
			 ReturnStatus=0
			 Message$="Error, Product not found"
		  else ! continue with list
			If NonStk Let P61$[59,59]="N" ! no prev only on nonstks!
			Call WhseList(e$,List$[],maxcnt,ReturnStatus,Message$)
		  Endif ! valid prod
		  if debugdetail
				dmsg$="WHSELIST sent "+message$ \ Call updatelog(debug)
		  Endif
		Endif ! action1=Whselist

		If Action1$="TAXLIST" ! tax y/n or taxcode list doc = ordl-taxdroplist.doc
			Let ReturnStatus=1
			Message$="OK"
			Clear List$[]
			Clear e$
			tmp$=Action1$ ! send as section name
			If P60$[42,42]<>"Y" ! NOT tax by line - so it's y/n only
				List$[0]=bsdel$,tmp$,fdel$
				List$[1]="ID",fdel$,"Desc$",fdel$ ! use same names as droplist!
				List$[2]="N",fdel$,"Not Taxable",fdel$
				List$[3]="Y",fdel$,"Taxable",fdel$
				List$[4]=esdel$
			Else ! is tax by line - send whole list
				List$[0]=bsdel$,tmp$,fdel$
				Field$[0]="Desc$"
				List$[1]="ID",fdel$,Field$[0],fdel$
				List$[2]="0",fdel$,"Non taxable",fdel$
				row=3
				Tcc=Openfile(-2176,IntCo) \ if Tcc = -1 Error 42
				!call filedroplisttaxcode(e$,list$[],maxcnt,tcc,tmp$,field$[])
				X4=Chf(tcc)-1
				for x2=1 to x4
					tmp1$=" ",tmp1$
					Read record #tcc,x2,0;tax.;
					tmp$=RTrim$(tax.Desc$)
					if tmp$<>""
						WebStr$=Str$(X2),fdel$,tmp$,fdel$
						List$[row]=webstr$
						row=row+1
						If row>tmpcnt let tmpcnt=expandarray(e$,List$[])
					Endif
				Next X2
				List$[row]=esdel$
				Close #tcc
				if e$<>""
					ReturnStatus=0
					Message$=E$
				Endif
			Endif
			if debugdetail
				dmsg$="TAXLIST p60-42,42= "+p60$[42,42] \ Call updatelog(debug)
			Endif
			!
		Endif ! action1=taxlist

		If Action1$="DEPTLIST" ! tax y/n or taxcode list doc = ordl-deptdroplist.doc
			Let ReturnStatus=1
			Message$="OK"
			Clear List$[]
			Clear e$
			clear Field$[]
			tmp$=Action1$ ! send as section name
			dpc=OpenFile(-1632,IntCo) \ if dpc = -1 Error 42
			call filedroplistdeptfle(e$,List$[],maxcnt,dpc,tmp$,Field$[],"0")
			close #dpc
			if e$<>""
				ReturnStatus=0
				Message$=E$
			Endif
			if debugdetail
				dmsg$="DEPTLIST SENT "+Message$ \ Call updatelog(debug)
			Endif
			!
		Endif ! action1=deptlist

		If Action1$="ORDFLAGS" ! rules for this cust/Order  doc=ORDL-OrdFlags.doc & CML-OrdFlags.doc
			ReturnStatus=1
			Message$="OK"
			Call DXGet("ORDERID",tmp$)
			OrderNo=tmp$
			If OrderNo<=0 Or OrderNo>999999 Or Fra(OrderNO)
				ReturnStatus=0
				Message$="INVALID ORDER!"
			Endif
			OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
			e$=""
			If OHR<=0
				ReturnStatus=0
				Message$="ORDER NOT FOUND!"
			Endif
			If OHR>0 ! can only do if found
				Call GetCust() ! need for flags
			Else
				Clear Cust.
			Endif
			Credit=0
			if ros.Status=32 let Credit=1
			if credit and roh.ShipType=3 let cost_Lev[1]=0 ! no cost edit on Price error credit!
			Clear List$[]
			List$[0]=BSDEL$,"ORDERFLAGS",fdel$
			WebStr$="Decimals",fdel$,"Rounding",fdel$ ! add more as needed
			WebStr$=WebStr$,"AllowCut",fdel$,"AllowKit",fdel$
			WebStr$=WebStr$,"Amalg",fdel$,"BOChk",fdel$
			WebStr$=WebStr$,"SPUMEqual",fdel$,"PermPrc",fdel$
			WebStr$=WebStr$,"AllowBrkn",fdel$,"EditQtyUM",fdel$
			WebStr$=WebStr$,"AllowBO",fdel$,"OvrBO",fdel$
			WebStr$=WebStr$,"EditTax",fdel$,"EditPrntFlag",fdel$
			WebStr$=WebStr$,"EditStkUpt",fdel$,"EditQty",fdel$
			WebStr$=WebStr$,"AllowDel",fdel$,"LPPrompt",fdel$
			WebStr$=WebStr$,"AuthBuy",fdel$,"CPUMEqual",fdel$
			WebStr$=WebStr$,"Package",fdel$,"ForceSNinInv",fdel$
			WebStr$=WebStr$,"ExistPW",fdel$,"ProdNotes",fdel$
			WebStr$=WebStr$,"OT16RA",fdel$,"OT16AutoBO",fdel$
			WebStr$=WebStr$,"CostSec",fdel$  ! CAUTION CM FIELD BELOW (AFTER COSTSEC)
			If Credit ! Add only if credit?
				WebStr$=WebStr$,"CPINVONLY",fdel$
			! Else ! if adding flags - send blank before new
			Endif
			if not(Credit) ! and roh.ordtype=15 ! needs header field never sent previously
				webstr$=webstr$,"BOCTR",fdel$ ! needs for lines
			Endif
			webstr$=webstr$,"POSPPFLAG",fdel$,"OIPPFLAG",fdel$ ! 6739 
			webstr$=webstr$,"CPIUSED",fdel$,"USEHLD4PO",fdel$
			webstr$=webstr$,"CalcLoadGL",fdel$
			List$[1]=WebStr$
			WebStr$=Str$(Q0[1]),fdel$,P9$[42,42],fdel$ ! add more as needed
			tmp$="N" \ if p9$[20,20]="F" let tmp$="Y" ! version>1.7.5.0
			IF roh.ordtype=16 let tmp$="N" ! not on xfers
			WebStr$=WebStr$,tmp$,fdel$ ! cutting
			tmp$=P9$[22,22] \ if credit let tmp$="N"
			webStr$=webstr$,tmp$,fdel$ ! kits
			! check if backorder - if Y - NO AMALG
			BORD=0
			If Not(credit) ! only orders/inv have backorders!
				if roh.OrgOrd and roh.OrgOrd<>roh.OrdNum let BORD=1
				if roh.OrgOrd1 and roh.OrgOrd1<>roh.OrdNum let BORD=1
				if roh.BOCTR>0 let BORD=1
			endif
			tmp$=P60$[12,12] \ if BORD let tmp$="N" ! force N if backorder
			WebStr$=WebStr$,tmp$,fdel$,P60$[27,27],fdel$ ! amalg, BOchk
			WebStr$=WebStr$,p60$[30,30],fdel$,p60$[33,33],fdel$ ! Q=P UM, Perm
			WebStr$=WebStr$,p60$[34,34],fdel$,p60$[35,35],fdel$ ! Broken, edit sell um
			tmp$="N" \ if cust.BoSAllowedFlag=1 tmp$="Y"
			if roh.OrdType = 24
				tmp$="N"  ! task 66550, no bo on ot 24
				WebStr$=WebStr$,tmp$,fdel$,tmp$,fdel$ ! allowBO, override BO
			else
				WebStr$=WebStr$,tmp$,fdel$,Ua2$[27,27],fdel$ ! allowBO, override BO
			endif
			WebStr$=WebStr$,UA2$[32,32],fdel$,UA2$[15,15],fdel$ ! edit tax, edit line prntd
			tmp$="N" \ if UB0[13] let tmp$="Y"
			tmp1$="N" \ if UB0[5] let tmp1$="Y"
			WebStr$=WebStr$,tmp$,fdel$,tmp1$,fdel$ ! edit stkupt, edit ord qty
			tmp$="N" \ if UB0[6] let tmp$="Y"
			tmp1$="N" \ if p61$[25,25]="P" let tmp1$="Y"
			WebStr$=WebStr$,tmp$,fdel$,tmp1$,fdel$ ! del line, prompt new LP
			WebStr$=WebStr$,cust.AuthBuyList$,fdel$,P61$[61,61],fdel$ ! authbuy,c=p um
			WebStr$=WebStr$,P9$[2,2],fdel$,P9$[46,46],fdel$ ! pkg, sn in inv
			WebStr$=WebStr$,P61$[59,59],fdel$,P61$[43,43],fdel$ ! exist pw, notes
			WebStr$=WebStr$,p61$[54,54],fdel$,p61$[49,49],fdel$ ! ot16 req/auth, auto BO
			WebStr$=WebStr$,Str$(Cost_Lev[1]),fdel$ ! loadcost sec
			If Credit let webstr$=webStr$,P61$[80,80],fdel$ ! ONLY CM FROM INV
			if Not(Credit) let webstr$=webstr$,Str$(roh.boctr),fdel$ ! ord accepted prev
			tmp$=P61$[102,102] \ if tmp$<>"N" let tmp$="Y" ! blank/null=Y
			if p60$[33,33]="N" or Credit let tmp$="N" ! NO PERM PRICING
			webstr$=webstr$,tmp$[1,1],fdel$ ! POS PP FLag  YN only
			tmp$=p61$[103,103] ! Ord/Inv PP flag
			if tmp$<>"O" and tmp$<>"I" and tmp$<>"B" and tmp$<>"N" let tmp$="B" ! blank/null=Y
			if p60$[33,33]="N" or Credit let tmp$="N" ! NO PERM PRICING
			webstr$=webstr$,tmp$[1,1],fdel$ ! ord/inv/both/none
			tmp$="N" \ if not(credit) and p61$[111,111]="Y" let tmp$="Y"
			webstr$=webstr$,tmp$[1,1],fdel$ ! CPI FLAG
			tmp$="N" \ if holdforpo and (source<219 or source=2082) let tmp$="Y" ! Use Hold for po prompt
			webstr$=webstr$,tmp$[1,1],fdel$ ! hold for po
			let tmp$="N"
			if p61$[116,116]="Y" let tmp$="Y" ! regarless of ordertype
			webstr$=webstr$,tmp$,fdel$
			List$[2]=WebStr$
			List$[3]=esdel$
			if debugdetail
				dmsg$="Order Flags sent "+Message$ \ Call updatelog(debug)
			Endif
			
		Endif ! of OrdFlags
		If Action1$="LINEFLAGS" ! rules for this Line  doc=ORDL-LineFlags.doc
			ReturnStatus=1  ! now sent as part of line detail!
			Message$="OK"
			Call DXGet("PRODID",tmp$)
			tmp$=UCASE$(tmp$)+Blank$
			Prod$=tmp$[1,12]
			Call DXGET("WHSE",tmp$)
			Whse=tmp$
			Call DXGET("ORDTYPE",tmp$)
			OType=tmp$
			ProdKey$=Prod$
			PRR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.)
			clear e$
			If PRR<=0
				ReturnStatus=0
				Message$="PRODUCT NOT FOUND"
				Clear PR.
			Endif
			tmp$=Prod$+Whse Using "##"
			tmp$[15]=""
			PWR=filegetprodwhse(e$,PWC,"=",1,tmp$,PW.)
			clear e$
			If PWR<=0 Clear pw.
			! any order type specific changes?
			If OType=2 ! direct cannot do s/n, lot, etc
				pr.MBFlg$="B" ! force buy
				! pr.SerNoTrack$="N" ! can't do as none
				pr.LotCtrl$="N" ! can't do this either?
				pw.DNReordFlg=0 ! not frozen if direct
			Endif
			Clear List$[]
			List$[0]=BSDEL$,"LINEFLAGS",fdel$
			WebStr$="CHKBrkn",fdel$,"MBFlag",fdel$
			WebStr$=WebStr$,"SerialNo",fdel$,"CatchWeight",fdel$
			WebStr$=WebStr$,"LotControl",fdel$,"RollLB",fdel$
			WebStr$=WebStr$,"DNReord",fdel$,"BrknUM",fdel$
			WebStr$=WebStr$,"BrknUMID",fdel$,"BrknUMFact",fdel$
			webstr$=webstr$,"HILIGHTPID",fdel$

			List$[1]=WebStr$ ! add more to webstr as needed
			if pw.ChkBrknQty$<>"N" let pw.ChkBrknQty$="Y" ! Y is default
			IF PRR<=0 let pw.ChkBrknQty$="N" ! non-stock?
			WebStr$=pw.ChkBrknQty$,fdel$,pr.MBFlg$,fdel$ ! chk brkn, make/buy
			WebStr$=WebStr$,pr.SerNoTrack$,fdel$,pr.CatchwgtItem$,fdel$ ! s/n, catchwgt
			WebStr$=WebStr$,pr.LotCtrl$,fdel$,pr.RollLbItem$,fdel$ ! lotcontrol, roll/lb
			tmp$=XUNIT$(pr.UMBrknQty,ccc)
			WebStr$=WebStr$,Str$(pw.DNReordFlg),fdel$,RTrim$(tmp$),fdel$ ! DNReord, brkn um
			X3=UMtoFactor(pr.UMBrknQty)
			WebStr$=WebStr$,Str$(pr.UMBrknQty),fdel$,Str$(X3),fdel$ ! um id, um factor
			tmp$="N" \ if custom_customer$="MORRISETTE" and Int(pr.UdNumeric)<>0 let tmp$="Y"
			webstr$=webstr$,tmp$,fdel$ ! highlight product
			List$[2]=WebStr$ ! add more to webstr as needed
			List$[3]=esdel$
			if debugdetail
				dmsg$="Line Flags sent "+Message$ \ Call updatelog(debug)
			Endif
			
		Endif ! of LineFlags
		! add in droplist for nonstock here 
			
		if action1$="VENDOR" ! can use option=VENDM action=SEARCH 
			Let ReturnStatus=1
			Message$="OK"
			clear e$
			tmp$=Action1$ ! send as section name
			Clear List$[]
			if not(ch_vend)
				ch_vend = OpenFile(-2400,IntCo) \ If CH_vend = -1 Error 42 ! vendor droplist
			endif
			call FileDropListA80vm(e$,List$[],maxcnt,ch_vend) 
			if e$<>""
				ReturnStatus=0
				Message$=E$
			Endif
			if debugdetail
				dmsg$="VENDOR LIST SENT "+Message$ \ Call updatelog(debug)
			Endif
		endif ! droplist vendor
		IF action1$="MATCODE"! material code ---			doc=OrdL-Droplistmatcode.doc
			Let ReturnStatus=1
			Message$="OK"
			clear e$
			tmp$=Action1$ ! send as section name
			clear list$[]
			if not (ch_matc)
				ch_matc = OpenFile(-2272,IntCo) \ If CH_matc = -1 Error 42 ! material code
			endif
			call FileDropListMatCode(e$,List$[],maxcnt,ch_matc) 
			if debugdetail
				dmsg$="MATERIAL CODE LIST SENT "+Message$ \ Call updatelog(debug)
			Endif
		endif ! droplist for material codes
		if action1$="PRODCAT" ! product categoery ---		doc=OrdL-Droplistprodcat.doc
			Let ReturnStatus=1
			Message$="OK"
			clear e$
			tmp$=Action1$ ! send as section name
			clear list$[]
			if not(ch_psc)
				ch_psc = OpenFile(-1984,IntCo) \ If ch_psc = -1 Error 42 ! prod sales category
			endif
			call FileDropListSProdCatgy(e$,List$[],maxcnt,ch_psc) 
			if debugdetail
				dmsg$="Product Category LIST SENT "+Message$ \ Call updatelog(debug)
			Endif
		endif ! droplist for product category
		if action1$="COMMCODE"  ! commodity code			doc=OrdL-droplistcommcode.doc
		   DIM FIELD$[1,30]
			Let ReturnStatus=1
			Message$="OK"
			clear e$
			tmp$=Action1$ ! send as section name
			clear list$[]
			if not(cmc)
				cmc = OpenFile(-2288,IntCo) \ If cmc = -1 Error 42 ! commod code(HEAD)
			endif
			if p61$[134,134]<>"N"
				Call FileDropListcommhead(e$,List$[],maxcnt,cmc)
			else
			    clear tmp$
				clear field$[]
				Call FileDropListcommhead(e$,List$[],maxcnt,cmc,"",Field$[],1,"","B")
			endif
			if debugdetail
				dmsg$="Commodity Code  LIST SENT "+Message$ \ Call updatelog(debug)
			Endif
		endif ! droplist for commcode
		if action1$="BUYER" ! buyer code					doc=ORDL-droplistbuyer.doc
			Let ReturnStatus=1
			Message$="OK"
			clear e$
			tmp$=Action1$ ! send as section name
			clear list$[]
			if not(ch_buy)
				Ch_buy = OpenFile(-9991,intCo) \ If Ch_buy = -1 Error 42 ! buyer
			endif
			Call FileDropListbuyer(e$,List$[],maxcnt,Ch_buy,"",Field$[],"0") ! 0=none!
			if debugdetail
				dmsg$="BUYER LIST SENT "+Message$ \ Call updatelog(debug)
			Endif
		endif ! droplist for buyer

		if action1$="CCODE" ! unit of measure droplist		doc=OrdL-droplistccodes.doc
			DIM FIELD$[1,30]
			ReturnStatus = 1                                                        
			Message$ = "OK"                                                         
			Clear e$                                                                
			 tmp$ = Action1$ ! send as section name                                  
			Clear List$[]                                                           
			If Not(ccc)                                                             
				ccc = OpenFile(-1728,IntCo) \ If ccc = -1 Error 42 !u/m codes file    
			End If
			CLEAR FIELD$[]
			clear tmp$ ! send other flag
			!if p9$[20,20]="F" let tmp$="F"
			let tmp$="F"
			Call filedroplistccodesz(e$,List$[],maxcnt,ccc,"",Field$[],1,"",tmp$) !u/m list 
			if debugdetail
				dmsg$="Unit Of Measure LIST SENT "+Message$ \ Call updatelog(debug)
			Endif
		endif  ! droplist for ccode
		if action1$="HAZNAME" ! ! Hazardous name			doc=ORDL-Droplisthazname.doc
			Let ReturnStatus=1
			Message$="OK"
			clear e$
			tmp$=Action1$ ! send as section name
			clear list$[]
			if not(ch_haz)
				Ch_haz= OpenFile(-2784,intCo) \ If Ch_haz = -1 Error 42 ! hazardous
			endif
			Call FileDropListHazName(e$,List$[],maxcnt,Ch_Haz,"",Field$[],1,"","")
			if debugdetail
				dmsg$="HAZARDOUS NAME LIST SENT "+Message$ \ Call updatelog(debug)
			Endif
		endif ! droplist for haz mat
		
		! end droplist for nonstock 
		If action1$="ALLWHSEAVAIL" ! whse available			doc=OrdL-GetAllWhseAvail.doc
			returnstatus=1
			message$="OK"
			call WHSEAVAIL()
		Endif
	  ! end of droplists
	  e$=""
	  call AddToStr(e$,rstr$,List$[]) ! add droplist to string
	  !
	  ! status section
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
	  !
	case "PRODSEARCH" ! product scan    doc = prodscanlist.doc
		!call dxsave(0,"tmp/oepsrh.txt!")
		Let ReturnStatus=1
		Message$="OK"
		clear list$[]
		if p61$[136,136]="Y" and roh.currid>0 and roh.currfact>0
			let list$[0]=str$(roh.currfact)
		endif
		X2=1 ! order scan
		Call ProdList(e$,IntCo,List$[],maxcnt,ctlc,prc,pwc,x2,debugdetail,dblog$,UserId$)
		If E$<>""
		  Let ReturnStatus=0
		  Message$=E$
		  e$=""
		Endif
		call AddToStr(e$,rstr$,List$[])
		
	  !
	  ! status section
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
	  if debugdetail
			dmsg$="Product Search sent "+Message$ \ Call updatelog(debug)
	  Endif
	  !
	case "PRODDETAIL" !   doc = ordl-newproddetails.doc
		! get details from list(single/quick also)  
		Call SetNewProdline()
		!
	case "PRICEWORK" !    doc = ordl-priceworkdtl.doc
		! user clicked [+] next to Net Price
		Call PriceWrkData()
		!
	case "COSTWORK" !     doc = ordl-costworkdtl.doc
		! user clicked [+] next to Cost
		Call CostWrkData()
		!
	case "PRICELIST"   ! doc = ordl-pricelist.doc
		! wants a list of prices (List, Bracket/Break)
		Call setpricelist() ! all handled in routine
		! end of PRICELIST
	case "REPRICE","REPRICESUM" !  doc = ordl-reprice.doc
		! reprice/cost the line
		Call Reprice() ! all handled in the routine
		! end of REPRICE
	case "STKUPDATE" ! stock update flag   doc = ordl-stkupdflag.doc
		! send back list of choices (even if N Only)
		Call StkUpList() ! all handled in routine
		! end of stkupdate
	case "LINEADDLDTLS" ! additional details    doc = ordl-addllinedtl.doc
		! Additional details wanted
		Call OrdAddlDtl()
		! end of prodadddtls
	case "GETLINES" !					doc = OrdL-getordlines.doc
		!  get existing ordlines
		let dooneline=0;DoPart=0 ! so gets all
		Call getordlines()
		! end of getlines
	case "GETREQLINES" !				doc = OrdL-getreqlines.doc
		!  get requested ordlines
		let dooneline=0;DoPart=0 ! so gets all
		Call getiolines()
		! end of getreqlines
	case "GETPARTLINES" !					doc = OrdL-getpartlines.doc
		!  get existing ordlines
		let dooneline=0;DoPart=1 ! so gets only 50 at a time
		Call getordlines()
		! end of getlines
	case "GETCOMPLIST" ! get list of complementary items  doc=OrdL-ComplItemList.doc
		! from product sent
		call getcomplist()
		! end of complist
	case "GETSUBSTLIST" ! get list of subst items			doc=OrdL-SubstItemList.doc
		! from product sent
		call getsubstlist()
		! end of getsubstlist
	case "GETSPRSDLIST" ! get list of supersedes			doc=OrdL-SprcdItemList.doc
		! from product sent
		call getsupsdlist()
		! end of getsupsdlist
	case "UPDTLINES" ! lines are being submitted    doc=OrdL-UpdtLines.doc
		! from web
		call UpdtLines()
		! end of update lines
	case "CALCDIRLOAD" !   ! CALCULATE DIRECT LOAD COST   doc = ordl-calcdirload.doc
		! user clicked [+] next to Cost
		Call CalcDirLoad() 
	case "NSDEFAULT" ! get default info for new nonstock item  doc=OrdL-NSDefault.doc
		call NSDefault()
		! end nsdefault
	case "NSSAVEITEM" ! get default info for new nonstock item  doc=OrdL-NSsaveitem.doc
		call NSSAVEITEM()
		! end nssaveitem
	case "NSGETITEM" ! get existing non-stock item info		doc=OrdL-NSGETITEM.doc
		call NSGETITEM()
		
		! end nsgetitem
	case "NSBUILDPROD" ! create a product from non-stock	doc=OrdL-NSBuilldProd.doc
		call NSBUILDPROD()
		if returnstatus=0
			let olr=-1
		else
			call UpdtLines()
		endif
		clear list$[]                                                         
		list$[0]=bsdel$,"NSBUILDPROD",fdel$                                   
		webstr$=webstr$,"PRODID",fdel$                                        
		webstr$=webstr$,"LN",fdel$                                            
		webstr$=webstr$,"DEPT",fdel$                                          
		webstr$=webstr$,"STKUPDT",fdel$                                       
		webstr$=webstr$,"TAX",fdel$                                           
		webstr$=webstr$,"WHSE",fdel$                                          
		List$[1]=webstr$                                                      
		if OLR>0
			Read Record #OLC,OLR,0;rol.;
			webstr$=""                                                    
			webstr$=rtrim$(rol.prodcode$),fdel$                          
			webstr$=webstr$,str$(rol.LineNum),fdel$                       
			webstr$=webstr$,str$(rol.dept),fdel$                          
			let tmp$="N"                                                  
			if rol.UpdtStk let tmp$="Y"                                  
			WebStr$=WebStr$,tmp$,fdel$ ! update stock flag$               
			If P60$[42,42]<>"Y" ! NOT tax by line - so it's y/n only      
				tmp$="N" \ if rol.TaxFlg let tmp$="Y"                
				WebStr$=WebStr$,tmp$,fdel$ ! tax flag                 
			Else ! it's a tax code                                        
				WebStr$=WebStr$,Str$(rol.TaxFlg),fdel$ ! tax code     
			Endif 
			webstr$=webstr$,str$(rol.whse),fdel$     
			list$[2]=webstr$                          
		endif     
		E$=""
		Call AddToStr(e$,rstr$,List$[])            
		Call AddToStr(e$,rstr$,esdel$) ! end of section   
		! status section                                                       
		Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)                 
		Call AddToStr(e$,rstr$,WebStr$)                                        
		Call SetOutPut(e$,rstr$)                                    
	    ! end of nsbuildprod	
	Case "CMSELINVLN" ! select Inv Line to copy				doc=CML-InvHistLines.doc
		! based on Product Code
		ReturnStatus=1
		Message$="OK"
		Call SUCMSELLN()
		! end cmselinvln
	Case "CPINVLINE" ! copy a inv line						doc=CML-InvHCPLine.doc
		! send invno,invline,Qty to copy into a new cm line
		ReturnStatus=1
		Message$="OK"
		call CMCPILINE()
		! end cpinvline
	Case "LINENOTES" ! see routine for docs
		! using the roltag for zlines(does orders & history)
		returnstatus=1
		message$="OK"
		call ROLTAG()
		! end of linenotes
	Case "OPADQTY" ! some of the additional details			doc=OrdL-OrdPadQtyDtl.doc
		! send whse qty list and quantity info
		returnstatus=1
		message$="OK"
		ordpad=1 ! flag to signify it's for orderpad
		Call OrdAddlDtl()
		! end of orderpad qty
	Case "SUBMITSUBST" ! sub/alt							doc=OrdL-SubmitSubstituteProduct.doc
		let afrm=1;SHQty=0;BOQty=0
		call dxget("ORGPROD",tmp$)
		OrgProd$=UCase$(tmp$)+Blank$
		Call SetNewProdline()
	Case "SUBMITSUPER" ! supersede							doc=OrdL-SubmitSupersedeProduct.doc
		let afrm=2;SHQty=0;BOQty=0
		call dxget("ORGPROD",tmp$)
		OrgProd$=UCase$(tmp$)+Blank$
		Call SetNewProdline()
	Case "SUBMITCOMPL","SUBMITBOPAD" !	compl/opad			doc=OrdL-SubmitComplementaryProduct.doc
		let afrm=0;SHQty=0;BOQty=0   !						doc=OrdL-SubmitOrderPadProduct.doc
		OrgProd$=Blank$
		Call SetNewProdline()
	Case "GPSUMMARY" ! g/p summary							doc=OrdL-GetGPSummary.doc
		returnstatus=1
		message$="OK"
		call gpsumm()
		! end of gpsummary
	Case "GETCUTDTLS" ! get curr cut details				doc=OrdL-GetCutData.doc
		returnstatus=1
		message$="OK"
		recalccut=0
		call GetCutDetails()
		! end of getcutdtls
	Case "SUBMITCUTDTLS" ! submit cuts						doc=OrdL-SubmitCutData.doc
		returnstatus=1
		message$="OK"
		call SubmitCutDetails()
		! end of submitcutdtls
	Case "RECALCCUTDTLS" ! recalc qtys/charges				doc=OrdL-ReCalcCutData.doc
		returnstatus=1
		message$="OK"
		recalccut=1
		call GetCutDetails()
		! end of RECALCCUTDTLS
	Case "GETNETPRICE" ! get data - calc netprice			doc=OrdL-GetNetPrice.doc
		returnstatus=1
		message$="OK"
		NTPRICE=1;NTCOST=0
		call GetNetPrcCost()
		! end of GETNETPRICE
	Case "GETNETCOST" ! get data & calc netcost				doc=OrdL-GetNetCost.doc
		returnstatus=1
		message$="OK"
		NTPRICE=0;NTCOST=1
		call GetNetPrcCost()
		! end of GETNETCOST
	Case "GETSPRODDTLS" ! get data for 1 prod(list entry)	doc=OrdL-GetSprodDtls.doc
		! to be more PM like - data (supersede,broken,avail,um,etc)
		returnstatus=1
		message$="OK"
		call SprodDtl()
		! end of getsproddtls
	Case "PRODUCECPIALERTS" !				doc=OrdL-ProduceCPIAlerts.doc
		! this is called after CPI exceptions have been
		! sent to the web and the operator has approved
		! or not approved the exception lines
		returnstatus=1
		message$="OK"
		call ProduceCPIAlerts()
	Case "AMALGPRICES" !					doc=OrdL-amalgprices.doc
		returnstatus=1
		message$="OK"
		call prcamalg()
		! end of amalgprices
	Case "GETPOLINES" !					doc=OrdL-getpolines.doc
		returnstatus=1
		message$="OK"
		call GetPOLines()
		! end of getpolines
	Case "LINKPOLINE" !					doc=OrdL-linkpolines.doc
		returnstatus=1
		message$="OK"
		call LinkPOLine()
		! end of LINKPOLINE
	Case "LINECOPYO","LINECOPYI" !		doc=OrdL-OrderLineCopy.doc, OrdL-InvoiceLineCopy.doc
		returnstatus=1
		message$="OK"
		call OLineCopy()
		! end of Linecopy
	case else
		e$="SERPORDL - Unknown action: "+action$
		error 10000
	! next case
  End Select
  if debugdetail
		dmsg$="End of Program SERPORDL" \ Call updatelog(debug)
  Endif
else
 include "src/callmainerrnet.inc"
end try
end  ! end of Main
!
!--------------------------------------------------------------------

! subs start now
!------------------------------------------------------------------------------------------
Sub OpenFiles()

 Try
    !
	CTLC = OpenFile(-9999,intCo) \ If CTLC = -1 Error 42 !control
	PRC = OpenFile(1792,intCo) \ If PRC = -1 Error 42 ! prod
	PWC = OpenFile(1744,intCo) \ If PWC = -1 Error 42 ! prodwhse
	CCC = OpenFile(-1728,intCo) \ If CCC = -1 Error 42 ! u/m codes file
	OHC = OpenFile(1840,IntCo) \ if ohc = -1 Error 42 ! order header
	OSC = OpenFile(1856,IntCo) \ if osc = -1 Error 42 ! order shipto
	OTC = OpenFile(1872,IntCo) \ if otc = -1 Error 42 ! order totals
	OLC = OpenFile(1888,IntCo) \ if olc = -1 Error 42 ! order lines
	NSC = OpenFile(2128,IntCo) \ if nsc = -1 Error 42 ! non-stock lines
	CMC = OpenFile(-2288,IntCo) \ if cmc = -1 Error 42 ! commod code(HEAD)
	LPC = OpenFile(-1376,IntCo) \ if lpc = -1 error 42 ! lastprice
	splc = OpenFile(-1936,IntCo) \ if splc=-1 Error 42 ! special price
	cphc = OpenFile(-2880,IntCo) \ if cphc = -1 Error 42 ! contr head
	btc = OpenFile(-1952,IntCo) \ if btc = -1 Error 42 ! break tbl chann
	CUC = OpenFile(1808,IntCo) \ if cuc = -1 Error 42 ! customer
	WHI = OpenFile(-2768,IntCo) \ if whi = -1 Error 42 ! whinfo
	PLTC=OpenFile(2528,IntCo) \ if PLTC = -1 Error 42 ! PRODLOT
	SLTC=OpenFile(2320,IntCo) \ if SLTC = -1 Error 42 ! SORDLOT
	if p61$[111,111]="Y"
		CPIDC=OpenFile(9928,IntCo) \ if CPIDC = -1 Error 42 ! CPIDETAIL
		! set up for cpi allocated call
		cpiChan[0] = CTLC
		cpiChan[1] = CPIDC
		cpiChan[2] = splc
		cpiChan[3] = PRC
		cpiChan[4] = olc
	end if
	sqlChan = OpenMySQLMirror(e$)
	If p61$[136,136]="Y"
		ch_curr=OpenFile(-9712,IntCo) \ if ch_curr = -1 Error 42 
	endif
	! set up fleptr for price
	fleptr[1,0]=prc;fleptr[2,0]=pwc;fleptr[3,0]=cmc
	fleptr[4,0]=lpc;fleptr[5,0]=splc;fleptr[6,0]=cphc
	fleptr[7,0]=ccc;fleptr[8,0]=btc;fleptr[15,0]=CPIDC
	if debugdetail
		dmsg$="Files Opened" \ Call updatelog(debug)
    Endif
 else
    include "src/callsuberr.inc"
  end try
end sub ! openfiles


Sub NSDefault()
!-------------------------------------------------------------------
! defaults for nonstock items
 try
	dIM 2%,nsfmcode
	Dim keymat$[2],kcm$[40],field$[1,30]
	Dim udan$[14],WUDAN$[70]
	dim 1%,ch_matc
	dim 3%,rec_mat
	ReturnStatus=1
	Message$="OK"
	let nsfmcode=0
	if p61$[132,132]="Y"
		mat read #ctlc,52,104;nsfmcode;
	endif
	MAT READ #ctlc,68,182;WUDAN$; ! uda field names
  ! unit of measure droplist  *** keep this section ****
  clear list$[]
  if not (CCC)
	ccc = OpenFile(-1728,intCo) \ If ccc= -1 Error 42  !u/m codes file
  endif
  CLEAR FIELD$[]
  clear tmp$ ! send other flag
  !if p9$[20,20]="F" let tmp$="F" 
  let tmp$="F"
  Call filedroplistccodesz(e$,List$[],maxcnt,ccc,"",Field$[],1,"",tmp$)! u/m list
  e$=""
  call AddToStr(e$,rstr$,List$[])

  ! section 2
  
  clear list$[]
  List$[0] = bsdel$,"NSDEFAULT",fdel$
  Webstr$="ComId",fdel$,"CommDesc",fdel$
  Webstr$=webstr$,"ProdCatId",fdel$,"ProdCatName",fdel$
  Webstr$=webstr$,"MatID",fdel$,"MatName",fdel$
  webstr$=webstr$,"VendFlag",fdel$
  webstr$=webstr$,"BuildFlag",fdel$
  webstr$=webstr$,"EditProdCat",fdel$
  webstr$=webstr$,"MiscCostSec",fdel$
  webstr$=webstr$,"UDA 1",fdel$ !
  webstr$=webstr$,"UDA 2",fdel$ !
  webstr$=webstr$,"UDA 3",fdel$ !
  webstr$=webstr$,"UDA 4",fdel$ !
  webstr$=webstr$,"UDA 5",fdel$ !
  list$[1]=webstr$
  if not(prc)
	PRC = OpenFile(-1792,intCo) \ If PRC = -1 Error 42  !product file 
  endif
  let prodkey$="Z ZZZZZZZZZZ"
  PRR = filegetprod(e$,PRC,"=",1,Prodkey$,PR.)
  clear e$
  if prr>0
	if not(cmc)
		cmc = OpenFile(-2288,IntCo) \ If cmc = -1 Error 42 ! commod code(HEAD)
	endif
	let kcm$=PR.ComdtyCode$+Blank$[1,4];kcm$[5]="" ! pr.A$[152,155]
	CMR = filegetcommhead(e$,cmc,"=",1,KCM$,cmc.)
	clear e$
	if cmr<=0
		clear cmc.
		returnstatus=0;message$="Default Commodity not found"
	endif
	if not(ch_psc)
		 ch_psc = OpenFile(-1984,IntCo) \ If ch_psc = -1 Error 42 ! prod sales category
	endif
	if pr.ProdCat>0 and pr.ProdCat<=(chf(ch_psc)-1)
		read record #ch_psc,pr.ProdCat;psc.;
	else
		clear psc.
		returnstatus=0;message$="Default Sales Category not found"
	endif
	if not(ch_matc)
		ch_matc = OpenFile(-2272,IntCo) \ If CH_matc = -1 Error 42 ! material code
	endif
	keymat$=pr.MatCode$ ! only 1 character key
	rec_mat= filegetmatcode(e$,ch_matc,"=",1,keymat$,matc.)
	clear e$
	if rec_mat<=0
		clear matc.
		returnstatus=0;message$="Default Mat Code not found"
	endif
  else
	clear pr.
	clear cmc.
	clear psc.
	clear matc.
	returnstatus=0;message$="Non-Stock Default Product not set up!"
  endif
  IF P61$[134,134]<>"N" ! default comm code
	 Webstr$=rtrim$(PR.ComdtyCode$),fdel$ ! "ComId"
	Webstr$=webstr$,rtrim$(cmc.CodeDescription$),fdel$ 
  else
	Webstr$="",fdel$ ! "ComId"
	Webstr$=webstr$,"",fdel$ 
  endif
  
  Webstr$=webstr$,str$(pr.ProdCat),fdel$ ! "ProdCatId"
  webstr$=webstr$,rtrim$(psc.CategoryDesc$),fdel$
  Webstr$=webstr$,rtrim$(pr.MatCode$),fdel$
  webstr$=webstr$,rtrim$(matc.Description$),fdel$
  webstr$=webstr$,p61$[31,31],fdel$
  tmp$="Y" \ if prr<=0 let tmp$="N" ! nocando if no z record
  if p61$[85,85]="N" let tmp$="N"
  if custom_customer$="HTBERRY" Or custom_customer$="WENELSON"
	let P61$[85,85]="N" ! custom - no nstk to prod
  Endif
  webstr$=webstr$,tmp$,fdel$
  let tmp$="Y" \if p61$[128,128]="N" let tmp$="N" ! edit prod cat
  webstr$=webstr$,tmp$,fdel$
  let tmp3=0
  if p61$[132,132]="Y" and nsfmcode<>0
		let tmp3=cost_lev[1]
  endif
  webstr$=webstr$,str$(tmp3),fdel$
  ! add 5 uda fields
   udan$=WUDAN$[1,14] \ if rtrim$(udan$)="" let udan$="NS UDA 1"
  webstr$=webstr$,RTrim$(udan$),fdel$ !
	udan$=WUDAN$[15,28] \ if rtrim$(udan$)="" let udan$="NS UDA 2"
  webstr$=webstr$,RTrim$(udan$),fdel$ !
	UDAN$=WUDAN$[29,42] \ if rtrim$(udan$)="" let udan$="NS UDA 3"
  webstr$=webstr$,RTrim$(udan$),fdel$ !
	udan$=WUDAN$[43,56] \ if rtrim$(udan$)="" let udan$="NS UDA 4"
  webstr$=webstr$,RTrim$(udan$),fdel$ !
	udan$=WUDAN$[57,70] \ if rtrim$(udan$)="" let udan$="NS UDA 5"
  webstr$=webstr$,RTrim$(udan$),fdel$ !
  List$[2] = WebStr$
  e$=""
  Call AddToStr(e$,rstr$,List$[])             
  Call AddToStr(e$,rstr$,esdel$) ! end of section   
	if returnstatus=1 let message$="OK" ! set if no other problems
	if debugdetail
		dmsg$="Non-Stock Default "+Message$ \ Call updatelog(debug)
	Endif
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
 else
	include "src/callsuberr.inc"
 end try
End sub !NSDEFAULT
!---------------------------------------------------------------------
Sub NSsaveitem()
!--------------------------------------------------------------------
! save a nonstock item -- adding line **** SHOULD HAVE THE CUSTOMER ALREADY /user id
 try
	dim 1%,tmptax,2%,nsfmcode
	dim 3%,blank$[50],k1$[60]
	dim nrol. as rolnew
	Dim cnstk. As sproddesc 
	dim tax. as taxcode
	clear rol.
	clear nstk.
	clear nrol.
	clear cnstk.
	Dim x$[20],NSFKey$[60] 
	dim holdpswd$[12,16]
	Dim 1%,CNVTU[2],FLAG[9],X1[9]            
	Dim 1%,NewLn,HFlg[16],HFlag[16],CREDIT             
	Dim 2%,X2[9],NumLines,ShipDate,JDATE[5]  
	Dim 3%,CNVTA,Amount,X3[9],V3[99]         
	Dim 3%,Whbld[3],S9[20] 
	for ctr=1 to 12
		read #ctlc,66,((ctr*16)-16);holdpswd$[ctr];
	next ctr
	let nsfmcode=0
	if p61$[132,132]="Y"
		mat read #ctlc,52,104;nsfmcode;
	endif
	If debugdetail                                         
		dmsg$ = "Start NonStock Line Update" \ Call updatelog(debug)  
	End If     
	! Call dxsave(0,"tmp/nssave.txt!")
	ReturnStatus = 1   
	Message$ = "OK"    
	if source=207 or source=239 goto NSUDLDone ! NO UPDATE ON INQUIRY!!
	Call dxget("ORDERID",tmp$)                             
	If tmp$ = "" Goto NSUDLDone                              
	orderno = tmp$                                         
		If orderno < 1 Or orderno > 999999 Or Fra(orderno)     
		 ReturnStatus = 0                                     
		Message$ = "ORDER NUMBER INVALID"                    
		Goto NSUDLDone                                         
	End If                                                 
	OHR = GetOrdRec(e$,OHC,OSC,otc,orderno,roh.,ros.,rot.)
	e$=""
	If OHR <= 0 ! not found                                
		ReturnStatus = 99                                     
		Message$ = "ORDER WAS NOT FOUND"                     
		Goto NSUDLDone 
	endif
	if returnstatus<>0
			credit = 0 \ if ros.status=32 let credit=1
			call verifystat()
			if returnstatus=99  Goto NSUDLDone 
	endif
	IF ROH.OrdType=20 ! freight invoice no lines
		ReturnStatus = 0                                     
		Message$ = "ORDER TYPE=Freight Invoice, NO LINES ALLOWED"                     
		Goto NSUDLDone 
	endif
	ZLine = 0;NonStk = 0;stk = 0;delline = 0;cutline=0
	credit = 0 \ if ros.status=32 let credit=1
	LET X3=rot.HoldCode ! unpack hold flags
		FOR CTR=0 TO 11                          
			LET HFlg[CTR]=SGN(FRA(X3/2));X3=INT(X3/2)
		NEXT CTR 
	Call dxget("LTYPE",tmp$)
	tmp$ = UCase$(tmp$)
	if tmp$<>"NSTK"
		returnstatus=0
		Message$="Order Line has Invalid Line Type. Not a non-stock item."
		goto nsudldone:
	endif
	If tmp$[1,4] = "NSTK" Let NonStk = 1
	let prodkey$="Z ZZZZZZZZZZ" ! let's see if z item is on file!
	PRR = filegetprod(e$,PRC,"=",1,Prodkey$,PR.)
	if prr<=0
		returnstatus=0;message$="Can not update. Non-Stock Default Product not set up!"
		goto nsudldone
	Endif ! of no Z prod / abort
	Call DXGet("LN",tmp$) ! +Str$(X1),tmp$)
	let rol.linenum=tmp$
	If rol.LineNum ! get prev data                 
		rolkey$ = " ",rolkey$                         
		rolkey$[1,6] = orderno Using "######"         
		rolkey$[7,9] = rol.LineNum Using "###"       
		rolkey$[11] = "" ! cut to length (space @ 10) 
		OLR = filegetrolz(e$,OLC,"=",1,rolkey$,rol.)
		clear e$
		If OLR <= 0 ! what do we do if not found?     
			Clear rol.
			Clear nstk.
			Clear nrol.
			clear cnstk.
			!nrol.SpareNU$ = Blank$;X0=LEN(nrol.SpareNU$)
			!IF X0>1
			!	nrol.SpareNU$[X0-1] = ""  ! for the key
			!ENDIF
			NEWLN=1
		 End If                                        
		If OLR > 0  
			read record #olc,olr,0;nrol.
			If rol.NStkItem = 1 And rol.LineType <> 3   
				nsr = rol.PDRecNum                        
				Read Record #nsc,nsr,0;nstk.
				read record #nsc,nsr,0;cnstk.
				PRR = 0;PWR = 0 
			End If
			IF rol.NStkItem <> 1
				returnstatus=0
				Message$="Existing Order Line Is Not A Non-Stock Item."
				goto nsudldone:
			ENDIF  
		Endif
	ELSE
		let olr=-1
		Clear rol.
		Clear nstk.
		Clear nrol.
		clear cnstk.
		!nrol.SpareNU$ = Blank$;X0=LEN(nrol.SpareNU$)
		!	IF X0>1
		!		nrol.SpareNU$[X0-1] = ""  ! for the key
		!	ENDIF
		NEWLN=1
	Endif
	if NEWLN=1 and roh.ordtype=15 and roh.boctr<>0 ! no add
		returnstatus=0
		message$="Invoice has been accepted. No new lines allowed"
		goto nsudldone
	Endif
	if newln=1 and roh.ordtype=19 and roh.boctr<>0 and roh.Ot19Comp=0
		returnstatus=0
		Message$="Final Bill of Order. No new lines allowed"
		goto nsudldone
	Endif
	 nrol.Status = 11;CREDIT = 0                                               
	If ros.Status = 32 Let nrol.Status = 12;CREDIT = 1 ! determine order/credi
 	nrol.OrdNum = orderno 
	cnstk.OrdNum = orderno
	Call dxget("DESC1",tmp$) ! +Str$(X1),tmp$) 
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Description 1"
		goto nsudldone
	Endif
	nrol.Desc1$ = tmp$ + Blank$
	cnstk.desc1$ = nrol.desc1$
	Call dxget("DESC2",tmp$) ! +Str$(X1),tmp$) 
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Description 2"
		goto nsudldone
	Endif
	nrol.Desc2$ = tmp$ + Blank$  
	cnstk.desc2$=nrol.desc2$
	Call dxget("WHSE",tmp$) ! +Str$(X1),tmp$)                                 
	nrol.Whse = tmp$ \ If nrol.Whse < 1 Or nrol.Whse > 99 Let nrol.Whse = roh.wh
	if roh.OrdType=16 Let nrol.Whse = roh.wh ! NO WHSE CHANGE!
    Let nrol.UpdtStk = 0 ! stock update is 0 for non-stocks
	
	Call dxget("UPRICE",tmp$) ! +Str$(X1),tmp$)   
	V3[1] = tmp$   
	If V3[1]<0 or V3[1]>9999999
		e$="Price is out of range"
		returnstatus=0
		goto nsudldone
	Endif
	nrol.PriceOrigin=-7;rol.PriceOrigin=-7 ! manual entry always on non-stks
	Call dxget("UCOST",tmp$) ! +Str$(X1),tmp$)    
	V3[2] = tmp$ 
	If V3[2]<0 or V3[2]>9999999
		e$="Cost is out of range"
		returnstatus=0
		goto nsudldone
	Endif
	nrol.CostOrigin=-1;rol.CostOrigin=-1 ! manual cost
	Call dxget("LDISC",tmp$) ! +Str$(X1),tmp$)    
	nrol.LineDiscPct = tmp$  
	Call dxget("UNCUBE",tmp$) ! +Str$(X1),tmp$)   
	nrol.CubeUnit = tmp$ \if not(nrol.CubeUnit) let nrol.CubeUnit=1
	if nrol.cubeunit<0 or nrol.cubeunit>99999
		e$="Cube is out of range"
		returnstatus=0
		goto nsudldone
	Endif
	Call dxget("UNLBS",tmp$) ! +Str$(X1),tmp$)   ! weight 
	nrol.LbsUnit = tmp$ \if not (nrol.LbsUnit) let nrol.Lbsunit=1 
	if nrol.lbsunit<0 or nrol.lbsunit>99999
		e$="Pounds is out of range"
		returnstatus=0
		goto nsudldone
	Endif
	Call dxget("TAXFLG",tmp$) ! +Str$(X1),tmp$) ! if new? where comes from?
	if rtrim$(tmp$)<>""
		if ucase$(tmp$)="N" let tmp$="0"
		if ucase$(tmp$)="Y" let tmp$="1"
		nrol.TaxFlg = tmp$ ! y/n or code
		if nrol.TaxFlg<0 ! cannot be
			e$="Tax Code is out of range"
			returnstatus=0
			goto nsudldone
		Endif
	endif
	Call dxget("DEPT",tmp$) ! +Str$(X1),tmp$)      
	nrol.Dept = tmp$                               
	Call dxget("QTYORD",tmp$) ! +Str$(X1),tmp$)    
	V3[3] = tmp$  
	X1=roh.ordtype
	if V3[3]<0 and (credit Or (x1=4 or x1=7 or x1=8 or x1=15 or x1=16 or x1=24))
		E$="No Negative Order Quantity allowed"
		returnstatus=0
		goto nsudldone
	Endif
	If ABS(V3[3])>9999999999
		e$="Order Quantity out of range"
		returnstatus=0
		goto nsudldone
	Endif
	Call dxget("QTYBO",tmp$) ! +Str$(X1),tmp$)     
	V3[4] = tmp$ 
	If ABS(V3[4])>9999999999
		e$="Back Order Quantity out of range"
		returnstatus=0
		goto nsudldone
	Endif                                  
	Call dxget("QTYSHIP",tmp$) ! +Str$(X1),tmp$)   
	V3[5] = tmp$  ! for ot15 this is relqty! 
	! if v3[5]<0 and V3[5]<>v3[3] let v3[3]=v3[5] ! no ship more than order
	if v3[3]<0 let v3[4]=0;v3[5]=v3[3] ! always! MAKE SHIP=ORDER/NO BO
	If ABS(V3[5])>9999999999
		e$="Ship Quantity out of range"
		returnstatus=0
		goto nsudldone
	Endif
	if roh.ordtype=4 ! order type 4 - needs BILLQTY
		call dxget("CURRBILL",tmp$)
		if rtrim$(tmp$)<>"" ! sent it - otherwise ignore
			V3[10]=tmp$
			if v3[3]<0 and v3[10]>0 ! neg line - pos bill? NO
				returnstatus=0
				message$="Can not have positive Bill quantities!"
				goto NSUDLDone
			Endif
			if v3[10]<0 ! neg bill allowed
				if nrol.PrevQtyBill<=0 or ABS(v3[10])>nrol.PrevQtyBill
					returnstatus=0
					message$="Negative Bill quantity is invalid!"
					goto nsudldone
				Endif
			Endif
		Endif ! sent data
		! ON PM Native - it allows overbill with just a prompt
		! check it below (when base)
	Endif ! bill qty - OT4
	Call dxget("PUPCHG",tmp$) ! +Str$(X1),tmp$)    
	V3[6] = tmp$                                   
	Call dxget("PUPTYPE",tmp$) ! +sTR$(X1),tmp$)   
	x$ = tmp$                                      
	If x$ = "$" ! $ is <0  percent is >=0          
		nrol.UpChrg = 0 - V3[6] ! may need convert   
	Else                                           
		nrol.UpChrg = V3[6]                          
	End If 
	Call dxget("UMSELL",tmp$) ! +Str$(X1),tmp$)     
    ! If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R <> 0 Let tmp$ = Str$(R)                  
	! End If                                          
	X2 = tmp$
	if x2<0 ! system um - not on Qty
		e$="Sell UM is not valid"
		returnstatus=0
		goto nsudldone
	Endif
	pr.UmSellDefault=x2
	nrol.UMSell = X2 ! tmp$
	Call dxget("UMPRICE",tmp$) ! +Str$(x1),tmp$)                              
	!If tmp$[1,1] > "9" ! sent text?                                           
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)                                     
		If R <> 0 Let tmp$ = Str$(R)                                            
	!End If                                                                    
	X2 = tmp$                                                                 
  	nrol.UMPrice = X2 ! tmp$
	Call dxget("UMCOST",tmp$) ! +Str$(X1),tmp$)      
    ! If tmp$[1,1] > "9" ! sent text?                  
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)            
		If R <> 0 Let tmp$ = Str$(R)                   
	! End If                                           
	X2 = tmp$                                        
        nrol.UMCost = X2 ! tmp$
	Call dxget("VENDITM",tmp$) ! +Str$(X1),tmp$)
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Vendor Item"
		goto nsudldone
	Endif
	nrol.VendItemCode$ = ucase$(tmp$) + Blank$
	Call dxget("NETPRC",tmp$) ! +Str$(x1),tmp$)     
	V3[7] = tmp$ ! nrol.NetPrice
	if v3[7]<0 or ABS(V3[7])>9999999999
		e$="Price is out of range"
		returnstatus=0
		goto nsudldone
	Endif
	Call dxget("PPFLAG",tmp$) ! +Str$(X1),tmp$) 
	if ucase$(tmp$)="FALSE" let tmp$="0"
	if ucase$(tmp$)="TRUE" Or tmp$="-1" let tmp$="1"
	let tmp$="0" ! NO PERM PRICE ON NSTKS!!
	nrol.NewPPFlg = tmp$ ! (s/b 0 or 1)             
	Call dxget("LNPRNT",tmp$) ! +Str$(X1),tmp$)
	If ucase$(tmp$)="Y" let tmp$="1"
	if ucase$(tmp$)="N" let tmp$="0"
	If RTrim$(tmp$)<>"" ! only if sent!!
		X2 = tmp$                                       
		If X2 = 0 Or X2 = 1 Let nrol.LinePrint = X2     
		If nrol.LinePrint = 0 ! not printed             
		 nrol.PrintDate = 0                            
		 nrol.PrintTime = 0                            
		End If 
	Endif
	Call dxget("CUPCHG",tmp$) ! +Str$(X1),tmp$)     
	V3[8] = tmp$                                    
	Call dxget("CUPTYPE",tmp$) ! +Str$(X1),tmp$)    
	x$ = tmp$                                       
	If x$ = "$" ! $ is <0  % is >=0                 
	 nrol.LoadUpchrg = 0 - V3[8]                   
	Else                                            
	nrol.LoadUpchrg = V3[8]                       
	End If

	Call dxget("COMMD",tmp$) ! +Str$(X1),tmp$) 
	if rtrim$(tmp$)="" 
		let message$="Commodity Code needs to be entered "
		returnstatus=0
		goto nsudldone
	endif
	nrol.ComdtyCode$ = tmp$ + Blank$ 
	cnstk.ComdtyCode$ = tmp$ + Blank$ 
	Call dxget("BUYER",tmp$) !+Str$(X1),tmp$)   
	Cnstk.Buyer = tmp$                           
	Call dxget("MATCD",tmp$) !+Str$(X1),tmp$)   
	nrol.MatCode$ = tmp$ + Blank$               
	Call dxget("SLSCAT",tmp$) !+Str$(X1),tmp$)  
	nrol.PSlsCat = tmp$                         
	Call dxget("VENDOR",tmp$) ! +Str$(X1),tmp$) 
	nrol.Vendor = tmp$                          
	Call dxget("PONUM",tmp$)                    
	nrol.PONum = tmp$                           
	Call dxget("MSDS",tmp$) ! +Str$(X1),tmp$)   
	nrol.MSDSNo = tmp$                          
	Call dxget("GLCOST",tmp$) !+Str$(X1),tmp$)  
	 V3[9] = tmp$                                
	If V3[9]<0 or ABS(V3[9])>9999999999
		e$="GL Cost is out of range"
		returnstatus=0
		goto nsudldone
	Endif 
	Call dxget("UMBASE",tmp$) !+Str$(X1),tmp$)   
	!If tmp$[1,1] > "9" ! sent text?              
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)        
		If R <> 0 Let tmp$ = Str$(R)               
	!End If                                       
	nrol.UMBase = tmp$                           
	Call dxget("UMPURCH",tmp$) !+Str$(X1),tmp$)  
	!If tmp$[1,1] > "9" ! sent text?              
		 R = getumrec(e$,ccc,tmp$,IntCo,PR.)        
		If R <> 0 Let tmp$ = Str$(R)               
	!End If                                       
	nrol.UMPurch = tmp$  
	if v3[9]>0 ! sent glcost
			CNVTU[0]=nrol.UMCost;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
			cnvta=v3[9] \ if nrol.UMCost>0 and nrol.NumOut>0 let cnvta=v3[9]*nrol.numout
			nrol.UnitGLCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	else
		call dxget("GLCOST",tmp$)
		if rtrim$(tmp$)<>""
			if rtrim$(tmp$)="0" or rtrim$(tmp$)="0.0" or rtrim$(tmp$)="0.00"
				let nrol.unitglcost=0
			endif
		endif
	Endif
	! end new fields
	 Call dxget("SELLFCTR",tmp$) !+Str$(X1),tmp$)   
	 nrol.SellFactor = tmp$  \if nrol.SellFactor<=0 let nrol.SellFactor=1                       
	Call dxget("PRCFCTR",tmp$) !+Str$(X1),tmp$)    
	 nrol.PriceFactor = tmp$   \if nrol.PriceFactor<=0 let nrol.PriceFactor=1                     
	 Call dxget("COSTFCTR",tmp$) !+Str$(X1),tmp$)   
	 nrol.CostFactor = tmp$    \ if nrol.CostFactor<=0 let nrol.CostFactor=1                     
	 Call dxget("PURCHFCTR",tmp$) !+Str$(X1),tmp$)  
	nrol.PurchFactor = tmp$     \ if nrol.PurchFactor<=0 let nrol.PurchFactor=1 
	
	Call dxget("UMCUBE",tmp$) !+Str$(X1),tmp$)   
	!If tmp$[1,1] > "9" ! sent text?              
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)        
		If R <> 0 Let tmp$ = Str$(R)               
	!End If
	!nrol.CubeFactor=tmp$
	!if nrol.CubeFactor<=0 let nrol.CubeFactor=1
	nrol.cubefactor=1
	if R=nrol.umbase
		let nrol.cubefactor=1
	else
		if r=nrol.UMSELL
			let nrol.cubefactor=nrol.sellfactor
		else
			if r=nrol.umprice
				let nrol.cubefactor=nrol.pricefactor
			else
				if r=nrol.umcost
					let nrol.cubefactor=nrol.costfactor
				else
					if r=nrol.umpurch
						let nrol.cubefactor=nrol.purchfactor
					endif
				endif
			endif
		endif
	endif
        
	Call dxget("UMLBS",tmp$) !+Str$(X1),tmp$)    
	!If tmp$[1,1] > "9" ! sent text?              
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)        
		If R <> 0 Let tmp$ = Str$(R)               
	!End If 
	!nrol.wgtfactor=tmp$
	!if nrol.wgtfactor<=0 let nrol.wgtfactor=1
	nrol.wgtfactor=1
	if R=nrol.umbase
		let nrol.wgtfactor=1
	else
		if r=nrol.UMSELL
			let nrol.wgtfactor=nrol.sellfactor
		else
			if r=nrol.umprice
				let nrol.wgtfactor=nrol.pricefactor
			else
				if r=nrol.umcost
					let nrol.wgtfactor=nrol.costfactor
				else
					if r=nrol.umpurch
						let nrol.wgtfactor=nrol.purchfactor
					endif
				endif
			endif
		endif
	endif
    ! added - 5 UDA Fields!
	Call dxget("UDA1",tmp$)
	let cnstk.NS_UDA1=tmp$ ! whatever sent
	Call dxget("UDA2",tmp$) ! +Str$(X1),tmp$)  
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in UDA 2"
		goto nsudldone
	Endif
	cnstk.NS_UDA2$ = tmp$+Blank$
	Call dxget("UDA3",tmp$) ! +Str$(X1),tmp$)  
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in UDA 3"
		goto nsudldone
	Endif
	cnstk.NS_UDA3$ = tmp$+Blank$
	Call dxget("UDA4",tmp$) ! +Str$(X1),tmp$)  
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in UDA 4"
		goto nsudldone
	Endif
	cnstk.NS_UDA4$ = tmp$+Blank$
	Call dxget("UDA5",tmp$) ! +Str$(X1),tmp$)  
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in UDA 5"
		goto nsudldone
	Endif
	cnstk.NS_UDA5$ = tmp$+Blank$    
    cnstk.SpareNU$ = Blank$  ! used for erp auto keygen                             
	clear cnstk.spare$ ! dl4 fix !cnstk.Spare$ = Blank$  
	! get hazardous info
	CALL DXGET ("HAZFLG",tmp$) ! hazardous flag
	let cnstk.hazflg=0
	if tmp$="Y" let cnstk.hazflg=1 ! yes
	if tmp$="S" let cnstk.hazflg=2 ! shipping
	if not (cnstk.hazflg)
		cnstk.HazFileRecno=0                               
		cnstk.HazClass$=blank$                                   
		cnstk.PackGrp$=blank$                                    
		cnstk.DotID$=blank$                                      
		cnstk.ERGdbk$=blank$                                     
	else
		Call Dxget ("HAZID",tmp$) ! hazardous id
		if not (ch_haz)
			Ch_Haz = openfile(-2784,intCo) \ If Ch_Haz = -1 Error 42 ! hazar
		endif
		let rec_haz=filegethazname(e$,ch_haz,"=",1,tmp$,haz.)
		clear e$
		if rec_haz>0
			cnstk.HazFileRecno=rec_haz
		else
			cnstk.HazFileRecno=0
		endif
		Call Dxget ("HAZCLASS",TMP$) ! HAZ CLASS
		LET cnstk.hazclass$=tmp$+BLANK$
		call dxget ("PACKGROUP",tmp$) ! 
		let cnstk.packgrp$=tmp$+blank$
		call dxget ("DOTID",tmp$)
		let cnstk.dotid$=tmp$+blank$
		call dxget ("ERBOOK",tmp$)
		let cnstk.ERGdbk$=tmp$+blank$
	endif
	If nrol.LineNum = 0 
		let cnstk.CurrFrtCost=0
		let cnstk.PrevFrtCost=0
	endif
	if p61$[132,132]="Y" and cost_lev[1]<>0 and nsfmcode<>0
		call dxget("CURRFRTCOST",tmp$)
		let cnstk.CurrFrtCost=tmp$
	endif
	 If nrol.LineNum = 0 ! new line         
		 nrol.LineNum = getnxtline(orderno)
		 rol.linenum=nrol.linenum
		 rol.Dept=roh.Dept
		 ! nrol.dept=roh.dept - set above
		 rol.NStkItem=1
		 nrol.NStkItem=1
		 nrol.UpdtStk=0 
		 rol.UpdtStk=0
		 rol.slsm=roh.slsm
		 nrol.slsm=roh.slsm
		 etr.EtAction = 11 ! new              
		 rol.UMBase = nrol.UMBase         
		 rol.UMSell = nrol.UMSell         
		 rol.UMCost = nrol.UMCost         
		rol.UMPrice = nrol.UMPrice       
		rol.UMPurch = nrol.UMPurch       
		rol.SellFactor = nrol.SellFactor 
		rol.PriceFactor = nrol.PriceFactor
		rol.CostFactor = nrol.CostFactor 
		rol.PurchFactor = nrol.PurchFactor
		rol.CubeFactor = nrol.CubeFactor 
		rol.WgtFactor = nrol.WgtFactor
		nrol.SpareNU3$=blank$
		nrol.KitDesignation$=blank$
		nrol.LineType=0
		nrol.RepairLine$=blank$
		nrol.OrgProdCode$=blank$
		nrol.HldForPo$=blank$
		nrol.AwmDeal$=blank$
		if p61$[136,136]="Y"
			let rol.currid=roh.currid
			let rol.currfact=roh.currfact
			let nrol.currid=roh.currid
			let nrol.currfact=roh.currfact
		endif
		v3[7]=v3[1] ! set the net price to unit price
		v3[5]=v3[3] ! set qty ship = to qty ord
		v3[4]=0 ! set qty bo to zero
		if p61$[76,76]="Y" and NOT(CREDIT) ! auto bo nonstk
		  if custom_customer$="HTBERRY" or roh.ordtype<>2 ! per group - not on DIRECT
			if roh.ordtype<>15  ! task42215
			   let v3[4]=v3[3];v3[5]=0 ! bo=ord,ship=0
			endif
		  Endif
		Endif
		PRR = 0;PWR = 0                  
		! set up / add nonstk                                           
		cnstk.OrdNum = nrol.OrdNum                                       
		cnstk.LineNum = nrol.LineNum                                     
		!nstk.OrdLineRec not known yet                                  
		cnstk.Desc1$ = nrol.Desc1$                                       
		cnstk.Desc2$ = nrol.Desc2$                                       
		cnstk.PSlsCat = nrol.PSlsCat                                     
		! nstk.QtyShip  nstk.UnitCost  nstk.UnitPrice                   
		nrol.ProdCode$ = roh.OrdNum Using "######"                      
		nrol.ProdCode$ = nrol.ProdCode$ + "-" + nrol.LineNum Using "&&&"
		nrol.ProdCode$ = nrol.ProdCode$ + Blank$                        
		cnstk.ProdCode$ = nrol.ProdCode$                                 
		cnstk.ComdtyCode$ = nrol.ComdtyCode$                             
		cnstk.Unused$ = Blank$                                           
		cnstk.SpareNU$ = Blank$                                          
		clear cnstk.spare$ ! dl4 fix!cnstk.Spare$ = Blank$                                            
		nsr = fileupdatesproddesc(e$,nsc,"a",0,cnstk.) 
		If nsr > 0                                                    
			 nrol.PDRecNum = nsr 
		Else                                                          
			 e$ = "NONSTOCK " + nrol.ProdCode$ + " FILE NOT ADDED"       
		End If
		if not(prc)
			PRC = OpenFile(-1792,intCo) \ If PRC = -1 Error 42  !product file 
		endif
		  let prodkey$="Z ZZZZZZZZZZ" ! let's set up tax now-as it's new!
		  PRR = filegetprod(e$,PRC,"=",1,Prodkey$,PR.)
		  clear e$
		  if prr>0
			K1$=roh.CustNum Using "######"
			ProdKey$=nrol.ProdCode$
			ProdKey$=nrol.VendItemCode$ ! as it's stored that way in lastprice
			Call TaxFlag(k1$,ProdKey$,ros.ShipCust,ros.ShipCode,rol.Dept,pr.TaxType,intco,roh.TaxCode,ros.ShipTaxType,Taxback)
			Nrol.TaxFlg=Taxback ! contains what's needed
			If P60$[42,42]<>"Y" ! has y/n only - get rate from header tax
				TaxNo=roh.TaxCode
			Else ! is a code
				TaxNo=nrol.TaxFlg
			Endif
			If TaxNo>0
				Tcc=Openfile(-2176,IntCo) \ if Tcc = -1 Error 42
				Read record #tcc,taxno,0;tax.;
				Close #tcc
			Else ! no taxcode
				clear tax.
			Endif
			nrol.TaxPct=tax.TaxRate
		  Else
			returnstatus=0;message$="Can not add. Non-Stock Default Product not set up!"
			goto nsudldone
		  Endif ! of got a Z prod / do tax
	End If ! of newline                                          
	If rol.WgtFactor <= 0 Let rol.WgtFactor = 1                     
	If nrol.WgtFactor <= 0 Let nrol.WgtFactor = 1                   
	rol.LbsUnit = nrol.LbsUnit ! update to current (lb based items) 
	 ! so nrol. has new, rol. has orig                                  
	Call setprtorol() ! set to rol. factors                            
	! convert sent to base as sent in display um  
	! PRICES
		if p61$[136,136]="Y"  and rol.currfact<>0 ! nssave
			if v3[1]<>0 ! unit price
				let cnvcu[0]=2
				let cnvcu[1]=1 ! no rounding 
				let cnvca[0]=v3[1]
				let cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[1]=cnvca[0]
			endif
			! convert cost to base
			if v3[2]<>0 ! unit cost
				let cnvcu[0]=2
				let cnvcu[1]=1 ! no rounding 
				let cnvca[0]=v3[2]
				let cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[2]=cnvca[0]
			endif
			if v3[6]<0 ! price upcharge $
				let cnvcu[0]=2
				let cnvcu[1]=1 ! no rounding 
				let cnvca[0]=v3[6]
				let cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[6]=cnvca[0]
			endif
			if v3[7]<>0 ! net price
				let cnvcu[0]=2
				let cnvcu[1]=1 ! no rounding 
				let cnvca[0]=v3[7]
				let cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[7]=cnvca[0]
			endif
			if v3[8]<0 ! cost upcharge $
				let cnvcu[0]=2
				let cnvcu[1]=1 ! no rounding 
				let cnvca[0]=v3[8]
				let cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[8]=cnvca[0]
			endif
			if v3[9]<>0 ! gl cost
				let cnvcu[0]=2
				let cnvcu[1]=1 ! no rounding 
				let cnvca[0]=v3[9]
				let cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[9]=cnvca[0]
			endif
		endif
	CNVTU[0] = nrol.UMPrice;CNVTU[1] = 0;CNVTU[2] = 6 ! to base no round was =2
	If v3[1]
		CNVTA = V3[1] \ if nrol.UMPrice>0 and nrol.NumOut>0 let cnvta=v3[1]*nrol.numout                                                     
		nrol.UnitPrice = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)  
	else
		nrol.UnitPrice=0
	endif
	if v3[7]
		CNVTU[0] = nrol.UMPrice;CNVTU[1] = 0;CNVTU[2] = 6 ! to base no round was =2
		CNVTA = V3[7] \ if nrol.UMPrice>0 and nrol.NumOut>0 let cnvta=v3[7]*nrol.numout                                                      
		nrol.NetPrice = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	else
		nrol.netprice=0
	endif
	if nrol.upchrg ! 
		If nrol.UpChrg < 0 ! $ amount
			CNVTU[0] = nrol.UMPrice;CNVTU[1] = 0;CNVTU[2] = 6 ! to base no round was =2
			 CNVTA = V3[6] ! still +                                          
			X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)              
			nrol.UpChrg = 0 - X3                                             
		End If
	endif
	! costs
	CNVTU[0] = nrol.UMCost;CNVTU[1] = 0;CNVTU[2] = 6 ! to base no round was =2
	if v3[2]
		CNVTA = V3[2] \ if nrol.UMCost>0 and nrol.NumOut>0 let cnvta=v3[2]*nrol.numout                                                       
		nrol.UnitCost = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	else
		nrol.unitcost =0
	endif
	if nrol.LoadUpchrg  
		If nrol.LoadUpchrg < 0 ! it's a $ up
			CNVTU[0] = nrol.UMCost;CNVTU[1] = 0;CNVTU[2] = 6 ! to base no round was =2
			CNVTA = V3[8]                                                   
			X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)             
			nrol.LoadUpchrg = 0 - X3                                        
		End If  
	endif
	If V3[9] > 0 ! sent glcost
		CNVTU[0] = nrol.UMCost;CNVTU[1] = 0;CNVTU[2] = 6 ! to base no round was =2
		CNVTA = V3[9] \ if nrol.UMCost>0 and nrol.NumOut>0 let cnvta=v3[9]*nrol.numout                                                  
		nrol.UnitGLCost = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	else
		call dxget("GLCOST",tmp$)
		if rtrim$(tmp$)<>""
			if rtrim$(tmp$)="0" or rtrim$(tmp$)="0.0" or rtrim$(tmp$)="0.00"
				let nrol.unitglcost=0
			endif
		endif
		!nrol.UnitGlCost=0
	End If
	! QUANTITIES
	CNVTU[0] = nrol.UMSell;CNVTU[1] = 0;CNVTU[2] = 1  
	IF V3[3]
		CNVTA = V3[3]  \ IF nrol.NumOut>0 let CNVTA=v3[3]/nrol.NumOut                                                    
		nrol.QtyOrd = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	else
		nrol.qtyord =0
	ENDIF
	if v3[4]
	CNVTA = V3[4]  \ IF nrol.NumOut>0 let CNVTA=v3[4]/nrol.NumOut                                                    
		nrol.QtyBO = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	else
		nrol.qtybo=0
	endif
	if v3[5]
		CNVTA = V3[5] \ IF nrol.NumOut>0 let CNVTA=v3[5]/nrol.NumOut
		nrol.QtyShip = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	else
		let nrol.qtyship=0
	endif
	if v3[3]>0  ! new - ot 4 & 15 can neg relqty - but never neg boqty
	  If v3[4]<0 or (roh.ordtype<>4 and roh.ordtype<>14 and v3[5]<0) ! no mixing
		returnstatus=0
		message$="Can not have negative BO/Ship quantities!"
		goto nsudldone
	  Endif
	  IF V3[5]<0 and (roh.ordtype=4 or roh.ordtype=15)
	    If nrol.PrevQtyShip<=0 or ABS(V3[5])>nrol.PrevQtyShip
			returnstatus=0
			message$="Negative Ship quantity is invalid!"
			goto nsudldone
		Endif
	  Endif
	Endif
	If V3[3]<0 and (v3[4]>0 or V3[5]>0) ! no mixed
		returnstatus=0
		message$="Can not have positive BO/Ship quantities!"
		goto nsudldone
	Endif
	If roh.ordtype=4 ! Curr Billqty
		cnvta=V3[10] \ if nrol.NumOut>0 let cnvta=v3[10]/nrol.numout
		nrol.CurrBillQty=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	Endif
	if roh.ordtype=15 and roh.boctr=0 and olr>0 ! existing line
		!nrol.qtyord=rol.qtyord ! how is new id'd?
		nrol.qtybo=rol.qtybo
		nrol.CurrRelQty=nrol.qtyship ! =rol.qtyship
	Endif
	If roh.ordtype=15 and roh.boctr<>0 ! cannot change qtys,prc/cost,um
		nrol.qtyord=rol.qtyord
		nrol.qtybo=rol.qtybo
		nrol.CurrRelQty=nrol.qtyship ! =rol.qtyship
		nrol.UnitPrice=rol.unitprice
		nrol.netprice=rol.netprice
		nrol.upchrg=rol.upchrg
		nrol.unitcost=rol.unitcost
		nrol.UMPrice=rol.umprice
		nrol.UMCost=rol.umcost
		nrol.UMSell=rol.umsell
		nrol.LoadUpchrg=rol.loadupchrg
	Endif
	If roh.ordtype=4 ! checks are here
		nrol.CurrRelQty=nrol.qtyship ! release is entered as QtyShip
		! PM Native - allows billing>order-prevbill - just an ok Y/N prompt
		! if nrol.currbillqty>nrol.qtyord-nrol.PrevQtyBill ! popup and ok Y/N
		! I guess the front end handles this as we can't here
		if custom_customer$="MORRISETTE"! ques on this
			nrol.CurrBillQty=nrol.CurrRelQty
		Endif
	Endif
	if roh.ordtype=19
		if rol.PrevQtyShip<>0 ! partially shipped already
				! only qty related fields can change
				! native only opts 1-4, 14-16, 23, >29 allowed!
				OT19OK=1 ! ok so far
				if rol.NetPrice<>nrol.NetPrice let ot19ok=0 ! 5
				if rol.LineDiscPct<>nrol.LineDiscPct let ot19ok=0 ! 6
				if rol.LineDisc<>nrol.LineDisc let ot19ok=0 ! 6
				if rol.unitcost<>nrol.unitcost let ot19ok=0 ! 8
				if rol.LoadUpchrg<>nrol.LoadUpchrg let ot19ok=0 ! 32
				if rol.UpChrg<>nrol.UpChrg let ot19ok=0 ! 7
				if rol.UnitGLCost<>nrol.UnitGLCost let ot19ok=0 ! 9
				if rol.UMPrice<>nrol.UMPrice let ot19ok=0 ! 12
				if rol.UMCost<>nrol.UMCost let ot19ok=0 ! 13
				if rol.UMSell<>nrol.UMSell let ot19ok=0 ! 11
				if rol.Desc1$<>nrol.Desc1$ let ot19ok=0 ! 17
				if rol.Desc2$<>nrol.Desc2$ let ot19ok=0 ! 17
				if rol.VendItemCode$<>nrol.VendItemCode$ let ot19ok=0 ! 18
				if rol.LineType<>nrol.LineType let ot19ok=0 ! 20
				if rol.UpdtStk<>nrol.UpdtStk let ot19ok=0 ! 21
				if rol.TaxFlg<>nrol.TaxFlg let ot19ok=0 ! 22
				if rol.KitDesignation$<>nrol.KitDesignation$ let ot19ok=0 ! 25
				if rol.Whse<>nrol.Whse let ot19ok=0 ! 29
				!Endif ! rest is allowed?
				if not(ot19ok) ! 
					returnstatus=0
					message$="Partial Shipment made - You can only change Qty/Weight"
					goto nsudldone
				Endif
		Endif ! of partial
	Endif ! ot 19 
	! all sent cost/price/qty now base
	call dolineextens()                        
                                          
	If nrol.UnitPrice <> rol.UnitPrice AND nrol.OrgPriceUnit = 0 Let nrol.OrgPriceUnit = rol.UnitPrice  
	If nrol.UnitCost <> rol.UnitCost AND nrol.OrgLoadCost =0 Let nrol.OrgLoadCost = rol.UnitCost      
	If nrol.Whse <> rol.Whse Let nrol.OrgWhse = rol.Whse 
	! SPECIAL TYPE PROCESSING
	if roh.OrdType=8 or roh.OrdType=16 ! cons/trans - no price/cost
		nrol.UnitCost=0;nrol.CostOrigin=0;nrol.RebtContract=0
		nrol.UnitPrice=0;nrol.CutChrg=0;nrol.CutCost=0
		nrol.LineDisc=0;nrol.ExtOrdAmt=0;nrol.ExtShipAmt=0
		nrol.LineDiscPct=0;nrol.ExtCutChg=0;nrol.ExtCutCost=0
		nrol.ExtLoadShip=0;nrol.ExtLoadOrd=0;nrol.NetPrice=0
		nrol.TaxAmt=0;nrol.LoadUpchrg=0;nrol.UpChrg=0
	Endif
	If p61$[46,46]="Y" and Credit and roh.shiptype=3 ! price fix - no cost
		nrol.UnitCost=0;nrol.CostOrigin=0;nrol.RebtContract=0
		nrol.CutCost=0;nrol.ExtCutCost=0;nrol.ExtLoadShip=0;nrol.ExtLoadOrd=0
		nrol.LoadUpchrg=0
	Endif
	if roh.ordtype=15
		!extend in subroutine (was qtybo-borel) - native = bo+borel
		!if nrol.qtyord<>nrol.CurrRelQty+(nrol.QtyBo+nrol.BORelQty)+nrol.PrevQtyShip
		if nrol.qtyord<nrol.CurrRelQty+(nrol.QtyBo-nrol.BORelQty)+nrol.PrevQtyShip
			returnstatus=0
			message$="Quantity is Out of Balance"
			goto nsudldone ! abort update? let's
		Endif
	Endif
	if roh.ordtype=4
		!extend in subroutine (was qtybo-borel) - native = bo+borel
		if nrol.qtyord<nrol.CurrRelQty+(nrol.QtyBo-nrol.BORelQty)+nrol.PrevQtyShip
			returnstatus=0
			message$="Quantity is Over Shipped"
			goto nsudldone ! abort update? let's
		Endif
	Endif
	if custom_customer$="MORRISETTE"
		IF roh.ordtype=4 AND (nrol.CurrRelQty<>0 AND nrol.CurrBillQty=0) ! "CCT 111810 
			LET message$="THERE IS A RELEASE BUT NO BILL AMOUNT"
			returnstatus=0
			goto nsudldone ! abort update? let's
		ENDIF 
	Endif
	if roh.ordtype=19
		x3[5]=nrol.PrevQtyShip+nrol.QtyShip+nrol.QtyBO
		if roh.ordtype=19 and roh.BOCTR>0 and roh.Ot19Comp=0 let x3[5]=nrol.qtyship ! final ship=ordered
		if nrol.qtyord<>X3[5] ! rol.PrevQtyShip+rol.QtyShip+rol.QtyBO
			returnstatus=0
			message$="Quantity is unequal. Please adjust (ord=ship+bo+prev)"
			goto NSUDLDone ! 
		Endif
	Endif
	If etr.EtAction = 0 ! no check yet                                        
		If nrol.UnitPrice <> rol.UnitPrice ! diff - but is it rounding?
		  If FNC(nrol.UnitPrice) <> FNC(rol.UnitPrice)
			Let etr.EtAction = 23
			If rtrim$(holdpswd$[5])<>"" HFlag[4] = 1
		  End if
		endif
		If nrol.UnitCost <> rol.UnitCost ! diff - rounding?
		  If FNC(nrol.UnitCost) <> FNC(rol.UnitCost) ! compare to 4 dec
			Let etr.EtAction = 24
			If rtrim$(holdpswd$[6])<>"" HFlag[5] = 1 !
		  Endif
		endif
		If nrol.netprice<>rol.netprice ! diff - chk rounding
		  If FNC(nrol.netprice)<>FNC(rol.netprice) ! 4 dec 
			let etr.etaction=23
			If rtrim$(holdpswd$[5])<>"" hflag[4]=1 
		  Endif
		endif
		If nrol.QtyOrd <> rol.QtyOrd Let etr.EtAction = 1                  
		If nrol.QtyBO <> rol.QtyBO Let etr.EtAction = 1                    
		If nrol.QtyShip <> rol.QtyShip Let etr.EtAction = 1                
			
	 End If                                                               
	If P60$[44,44] = "Y" And etr.EtAction <> 0                           
		Call EdtTrkDo(rol.,nrol.) ! org, new                               
	 End If ! of edit tracking                                            
                               
	nrol.PDRecNum = nsr ! non-stk rec # 
	tmp$ = ShipDate Using "&&&&&&"                                 
	Call DateToJulian(1,tmp$,tmp1$,f)                              
	If f Let tmp1$ = ""                                            
	JDATE[1] = tmp1$;f = 0 ! julian sys shipdate                   
	tmp$ = roh.ShipDate Using "&&&&&&"                             
	If roh.ShipDate <> 999999 Call DateToJulian(1,tmp$,tmp1$,f)    
	If f Let tmp1$ = ""                                            
	JDATE[2] = tmp1$ ! julian ord shipdate                         
     nrol.SpareNU3$=blank$ 
	 clear nrol.SpareNu$ ! dl4 fix
	If NewLn ! new line                                            
		OLR = fileupdaterolz(e$,OLC,"a",0,nrol.)               
          clear e$              
		 If OLR > 0 ! has to have a record!                           
			cnstk.OrdLineRec = OLR                                           
			If CREDIT Let x = -1 Else Let x = 1                             
			CNVTU[0] = 0;CNVTU[1] = nrol.UMSell;CNVTU[2] = 1                
			CNVTA = nrol.QtyShip
			Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)         
			cnstk.QtyShip = (Amount * x) ! store credits as neg (IN SELL UM!)
			CNVTU[0] = 0;CNVTU[1] = nrol.UMSell;CNVTU[2] = 2                
			CNVTA = nrol.UnitCost                                           
			Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)         
			cnstk.UnitCost = Amount ! nrol.UnitCost (SAYS IN sELL UM)        
			CNVTU[0] = 0;CNVTU[1] = nrol.UMSell;CNVTU[2] = 2                
			CNVTA = nrol.UnitPrice                                          
			Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)         
			cnstk.UnitPrice = Amount ! nrol.UnitPrice (IN SELL UM!)          
			cnstk.ExtShipAmt = (nrol.ExtShipAmt * x) ! store credits as neg 
			clear cnstk.Spare$ ! dl4 fix
			Write Record #nsc,nsr,0;cnstk.;                                  
		End If                         
	                       
	 Else ! existing line
		clear nrol.SpareNu$ ! dl4 fix
		Write Record #OLC,OLR,0;nrol.; 
		 x = 1 \ If CREDIT Let x = -1                                     
		CNVTU[0] = 0;CNVTU[1] = nrol.UMSell;CNVTU[2] = 1                 
		CNVTA = nrol.QtyShip                                             
		Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)          
		cnstk.QtyShip = (Amount * x) ! store credits as neg (IN SELL UM!) 
		CNVTU[0] = 0;CNVTU[1] = nrol.UMSell;CNVTU[2] = 2                 
		CNVTA = nrol.UnitCost                                            
		Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)          
		cnstk.UnitCost = Amount ! nrol.UnitCost (SAYS IN sELL UM)         
		CNVTU[0] = 0;CNVTU[1] = nrol.UMSell;CNVTU[2] = 2                 
		CNVTA = nrol.UnitPrice                                           
		Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)          
		cnstk.UnitPrice = Amount ! nrol.UnitPrice (IN SELL UM!)           
		cnstk.ExtShipAmt = (nrol.ExtShipAmt * x) ! credits stored as neg  
		clear cnstk.Spare$ ! dl4 fix
		Write Record #nsc,nsr,0;cnstk.;  ! was ;nstk.; ?
	endif
	iF not(roh.HoldOver) ! repack holds
		! HFlag[x]=set in this routine, HFlg[x]=set previously
		If HFlag[2] Let HFlg[2]=chkhldcode(3) ! hold passwd=1+ the flag
		If HFlag[4] let HFlg[4]=chkhldcode(5)
		If HFlag[5] let HFlg[5]=chkhldcode(6)
		
		LET X3=0 ! repack holds                               
		FOR CTR=0 TO 11                         
			IF HFlg[CTR] LET X3=X3+2^CTR            
		NEXT CTR                                
		LET rot.HoldCode=X3
		IF (Credit) LET rot.HoldCode=0
		if roh.ordtype=16 let rot.HoldCode=0
		WRITE Record #otc,roh.TotRec,0;rot.;
	Endif
	If returnstatus<>0 and NewLN and OLR>0 and not(credit) ! new nonstk line - send alert
		clear x2[]
		clear x3[]
		tmp$=""
		x2[1]=ctlc;x2[2]=OLC;x2[4]=OHC;X2[5]=OSC;X2[6]=OTC;x2[7]=CCC
		x2[8]=CUC ! x2[]=file channels
		X3[0]=21;x3[1]=Cnstk.Buyer;x3[2]=OLR;x3[3]=OHR
		x3[4]=V3[3];x3[5]=v3[4];x3[6]=v3[5] ! qty: ord,bo,ship (as entered)
		! x3=vars 0=alert,1=buyer,2=ordline,3=ordhead
		call "libalertproc.lib",x3[],x2[],tmp$
	Endif
	nsUDLDone: ! send status back                                            
	If ReturnStatus = 1 Let Message$ = "OK" ! set if no other problems  
	If debugdetail                                                         
		dmsg$ = "Update NStk Line " + Str$(nrol.OrdNum) + "-" + Str$(nrol.LineNum) +nrol.ProdCode$ + Message$ 
		Call updatelog(debug)                         
	End If 
	NSUDLDEND: ! END OF THE LINE
	clear list$[]                                                         
	list$[0]=bsdel$,"NSSAVEITEM",fdel$ 
	webstr$=""
	webstr$=webstr$,"PRODID",fdel$                                        
	webstr$=webstr$,"LN",fdel$                                            
	webstr$=webstr$,"DEPT",fdel$                                          
	webstr$=webstr$,"STKUPDT",fdel$                                       
	webstr$=webstr$,"TAX",fdel$                                           
	webstr$=webstr$,"WHSE",fdel$                                          
	List$[1]=webstr$                                                      
	if OLR>0                                                              
		webstr$=""                                                    
		webstr$=rtrim$(nrol.prodcode$),fdel$                          
		webstr$=webstr$,str$(nrol.LineNum),fdel$                       
		webstr$=webstr$,str$(nrol.dept),fdel$                          
		let tmp$="N"                                                  
		! if nrol.UpdtStk let tmp$="Y"   ! nonstk NEVER UPDATES STOCK!!                               
		WebStr$=WebStr$,tmp$,fdel$ ! update stock flag$               
		If P60$[42,42]<>"Y" ! NOT tax by line - so it's y/n only      
			tmp$="N" \ if nrol.TaxFlg let tmp$="Y"                
			WebStr$=WebStr$,tmp$,fdel$ ! tax flag                 
		Else ! it's a tax code                                        
		   WebStr$=WebStr$,Str$(nrol.TaxFlg),fdel$ ! tax code     
		Endif 
	        webstr$=webstr$,str$(nrol.whse),fdel$     
		list$[2]=webstr$                          
	 endif       
	e$=""
	Call AddToStr(e$,rstr$,List$[])            
	Call AddToStr(e$,rstr$,esdel$) ! end of section   
	! status section                                                       
	Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)                 
	Call AddToStr(e$,rstr$,WebStr$)                                        
	Call SetOutPut(e$,rstr$)                                               
 else
	 include "src/callsuberr.inc"
 end try
End sub !NSSAveItem
!--------------------------------------------------------------------

Sub nsgetitem()
!--------------------------------------------------------------------
! also used in invoice history for nonstock detail screen
 try
	dim 1%,tmptax,2%,nsfmcode
	dim KCM$[40],KEYMAT$[2],knsh$[60]
	Dim 3%,InvcNo ! for history inquiry
	Dim vend. As a80vm
	clear rol.
	clear nstk.
	let nsfmcode=0
	if p61$[132,132]="Y"
		mat read #ctlc,52,104;nsfmcode;
	endif
	olr=-1
	If debugdetail                                                    
		dmsg$ = "Start Get NonStock Line Detail" \ Call updatelog(debug)    
	End If                                                            
	ReturnStatus = 1                                                  
	Message$ = "OK"                                                   
	Call dxget("ORDERID",tmp$)                                        
	If tmp$ = "" Goto EndNSGetItem 
	If Source<>239
		orderno = tmp$                                                    
		If orderno < 1 Or orderno > 999999 Or Fra(orderno)                
			 ReturnStatus = 0                                                
			 Message$ = "ORDER NUMBER INVALID"                               
			Goto EndNSGetItem                                                 
		End If                                                            
		OHR = GetOrdRec(e$,OHC,OSC,otc,orderno,roh.,ros.,rot.)
		e$=""
		If OHR <= 0 ! not found                                               
			ReturnStatus = 0                                                    
			Message$ = "ORDER WAS NOT FOUND"                                    
			Goto  EndNSGetItem                                                       
		End If 
	Else ! is hist inquiry - don't bother with header!
		InvcNo=tmp$
		Close #OLC
		OLC=OpenFile(-1184,Intco) \ if olc=-1 error 42  !invhist line
		Close #NSC
		NSC=OpenFile(-9935,Intco) \ if nsc=-1 error 42 ! nonstk hist
	Endif
	Credit=0
	if ros.Status=32 let Credit=1
	ZLine = 0;NonStk = 0;stk = 0;delline = 0;CutLine = 0                  
	Call dxget("LTYPE",tmp$)                                              
	tmp$ = UCase$(tmp$)                                                   
	If tmp$[1,4] <> "NSTK"                                                     
		 ReturnStatus = 0                                                    
		Message$ = "Order Line has Invalid Line Type. Not a non-stock item."
		Goto EndNSGetItem                                                     
	End If                                                                
	Let NonStk = 1                                  
	Call dxget("LN",tmp$)                              
	rol.LineNum = tmp$ 
	
	If rol.LineNUm < 1 Or rol.lineNum > 999 Or Fra(rol.lineNum)                
		 ReturnStatus = 0                                                
		 Message$ = "ORDER LINE NUMBER INVALID"                               
		Goto EndNSGetItem 
	endif
	rolkey$ = " ",rolkey$ 
	if source<>239
		rolkey$[1,6] = orderno Using "######"                              
		rolkey$[7,9] = rol.LineNum Using "###"                            
		rolkey$[11] = "" ! cut to length (space @ 10) 
	Else ! history
		rolkey$[1,10]=InvcNo Using "##########"
		rolkey$[11,13]=rol.linenum Using "###"
		Rolkey$[15]=""
	Endif
	OLR = filegetrolz(e$,OLC,"=",1,rolkey$,rol.) 
	clear e$
	If OLR <= 0 ! what do we do if not found?                          
		 ReturnStatus = 0                                                
		 Message$ = "ORDER LINE NOT ON FILE"                               
		Goto EndNSGetItem 
	endif
    Read Record #OLC,OLR,0;rol.;                                     
	If rol.NStkItem <>1
          	 ReturnStatus = 0                                                
		 Message$ = "ORDER LINE IS NOT A NON-STOCK LINE" 
		 clear rol.
		 olr=-1
		 Goto EndNSGetItem 
	endif
	if rol.LineType = 3  ! it's a zline line  
		ReturnStatus = 0                                                
		 Message$ = "ORDER LINE IS NOT A NON-STOCK LINE" 
		 clear rol.
		 olr=-1
		 Goto EndNSGetItem 
	endif
	if source<>239 ! curr order
		nsr = rol.PDRecNum                                             
		Read Record #nsc,nsr,0;nstk.;
	Else ! history - need to use key not record #
		clear nstk.
		knsh$=rolkey$ ! same key as line
		search #nsc,2,1;knsh$,NSR,E ! we didn't include sprddesch so no "fileget"
		if not(e)
			read record #NSC,NSR,0;nstk.;
		endif
	Endif
	Call setprtorol() ! set to rol. factors 
	
	EndNSGetItem: ! load this up for heading
	clear list$[]
	list$[0]=bsdel$,"GETNONSTOCK",fdel$
	webstr$="QTYORD",fdel$
	webstr$=webstr$,"IDBASE",fdel$
	webstr$=webstr$,"UMBASE",fdel$
	webstr$=webstr$,"IDSELL",fdel$
	webstr$=webstr$,"UMSELL",fdel$
	webstr$=webstr$,"SELLFCTR",fdel$
	webstr$=webstr$,"IDPRICE",fdel$
	webstr$=webstr$,"UMPRICE",fdel$
	webstr$=webstr$,"PRCFCTR",fdel$
	webstr$=webstr$,"IDPURCH",fdel$
	webstr$=webstr$,"UMPURCH",fdel$
	webstr$=webstr$,"PURCHFCTR",fdel$
	webstr$=webstr$,"IDCOST",fdel$
	webstr$=webstr$,"UMCOST",fdel$
	webstr$=webstr$,"COSTFCTR",fdel$
	webstr$=webstr$,"UNLBS",fdel$
	webstr$=webstr$,"LBSFCTR",fdel$
	webstr$=webstr$,"UMLBS",fdel$
	webstr$=webstr$,"UNCUBE",fdel$
	webstr$=webstr$,"CUBEFCTR",fdel$
	webstr$=webstr$,"UMCUBE",fdel$
	webstr$=webstr$,"HAZFLAG",fdel$
	webstr$=webstr$,"HAZID",fdel$
	webstr$=webstr$,"HAZNAME",fdel$
	webstr$=webstr$,"HAZCLASS",fdel$ ! HAZ CLASS
	webstr$=webstr$,"PACKGROUP",fdel$
	webstr$=webstr$,"DOTID",fdel$
	webstr$=webstr$,"ERBOOK",fdel$
	webstr$=webstr$,"DESC1",fdel$
	webstr$=webstr$,"DESC2",fdel$
	webstr$=webstr$,"SLSCAT",fdel$
	webstr$=webstr$,"SLSCATDESC",fdel$
	webstr$=webstr$,"COMMD",fdel$
	webstr$=webstr$,"COMMDDESC",fdel$
	webstr$=webstr$,"BUYER",fdel$	
	webstr$=webstr$,"BUYERNAME",fdel$
	webstr$=webstr$,"MATCD",fdel$
	webstr$=webstr$,"MATCDESC",fdel$
	webstr$=webstr$,"VENDITM",fdel$
	webstr$=webstr$,"VENDOR",fdel$
	webstr$=webstr$,"VENDNAME",fdel$
	webstr$=webstr$,"PONUM",fdel$	
	webstr$=webstr$,"GLCOST",fdel$                                      
	webstr$=webstr$,"UCOST",fdel$  
	webstr$=webstr$,"DEPT",fdel$
	webstr$=webstr$,"UPRICE",fdel$
	webstr$=webstr$,"LN",fdel$
	webstr$=webstr$,"BUILDPRODFLAG",fdel$
	webstr$=webstr$,"EditProdCat",fdel$
	webstr$=webstr$,"MiscCostSec",fdel$
	webstr$=webstr$,"CurrFrtCost",fdel$
	webstr$=webstr$,"PrevFrtCost",fdel$
	! Add 5 UDA Fields!
	webstr$=webstr$,"UDA1",FDEL$
	webstr$=webstr$,"UDA2",FDEL$
	webstr$=webstr$,"UDA3",FDEL$
	webstr$=webstr$,"UDA4",FDEL$
	webstr$=webstr$,"UDA5",FDEL$
	List$[1]=webstr$
	if OLR>0
		webstr$=""
		CNVTU[0] = 0;CNVTU[1] = rol.UMSell;CNVTU[2] = 1          
		CNVTA = rol.QtyOrd \ if rol.numout>0 let CNVTA=rol.qtyord*rol.numout
		X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)      
		WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! Qty Ord
		webstr$ = webstr$,str$(rol.UMBase),fdel$ ! Base rec#/id
		tmp$=XUnit$(rol.UMBase,ccc) ! u/m
		webstr$=webstr$,rtrim$(tmp$),fdel$
		webstr$ = webstr$,str$(rol.UMSell),fdel$ ! Sell rec#/id
		tmp$=XUnit$(rol.UMSell,ccc) ! u/m
		webstr$=webstr$,rtrim$(tmp$),fdel$
		webstr$=webstr$,str$(rol.SellFactor),fdel$
		webstr$ = webstr$,str$(rol.UMPRICE),fdel$ ! Price rec#/id
		tmp$=XUnit$(rol.UMPRICE,ccc) ! u/m
		webstr$=webstr$,rtrim$(tmp$),fdel$
		webstr$=webstr$,str$(rol.PRICEFactor),fdel$
		webstr$ = webstr$,str$(rol.UMPURCH),fdel$ ! PURCH rec#/id
		tmp$=XUnit$(rol.UMPURCH,ccc) ! u/m
		webstr$=webstr$,rtrim$(tmp$),fdel$
		webstr$=webstr$,str$(rol.PURCHFactor),fdel$
		webstr$ = webstr$,str$(rol.UMCost),fdel$ ! Cost rec#/id
		tmp$=XUnit$(rol.UMCost,ccc) ! u/m
		webstr$=webstr$,rtrim$(tmp$),fdel$
		webstr$=webstr$,str$(rol.CostFactor),fdel$
		WebStr$ = WebStr$,LTrim$(rol.LbsUnit Using PMask$),fdel$ ! wgt unit       
		tmp$ = Str$(rol.WgtFactor)                                                
		Call factorum(tmp$) ! get um for factor                                   
		WebStr$ = WebStr$,Str$(rol.WgtFactor),fdel$,RTrim$(tmp$),fdel$ ! wgt facto
	        WebStr$ = WebStr$,LTrim$(rol.CubeUnit Using PMask$),fdel$ ! cube unit     
		 tmp$ = Str$(rol.CubeFactor)                                               
		Call factorum(tmp$) ! get um for factor                                   
		 WebStr$ = WebStr$,Str$(rol.CubeFactor),fdel$
		 webstr$ = webstr$,RTrim$(tmp$),fdel$ ! cube fac
		let tmp$="N" ! \ if source=239 let tmp$="N/A" (it's a droplist!!)
		if nstk.hazflg=1 let tmp$="Y"
		if nstk.hazflg=2 let tmp$="S"
		webstr$=webstr$,tmp$,fdel$
		let tmp$=""
		clear haz.
		if  nstk.HazFlg<>0 and nstk.HazFileRecno<>0
			if not (ch_haz)
				 Ch_Haz = openfile(-2784,intCo) \ If Ch_Haz = -1 Error 42 ! hazar
			endif
			read record #ch_haz,nstk.HazFileRecno;haz.;
			let tmp$=""
			let tmp$[1,24]=haz.hazshippingname1$[1,24]
			let tmp$[25,30]=nstk.HazFileRecno using "######"
		endif
		webstr$=webstr$,tmp$,fdel$
		webstr$=webstr$,rtrim$(haz.HazShippingName1$),fdel$
		webstr$=webstr$,rtrim$(nstk.hazclass$),fdel$
		webstr$=webstr$,rtrim$(nstk.packgrp$),fdel$
		webstr$=webstr$,rtrim$(nstk.dotid$),fdel$
		webstr$=webstr$,rtrim$(nstk.ERGdbk$),fdel$ 
		tmp$=clrtxtc$(e$,rol.desc1$) ! chk/clr control chars
		webstr$=webstr$,rtrim$(tmp$),fdel$ 
		tmp$=clrtxtc$(e$,rol.desc2$) ! chk/clr control chars
		webstr$=webstr$,rtrim$(tmp$),fdel$ 
		webstr$=webstr$,str$(rol.PSlsCat),fdel$
		clear psc.
		if rol.PSlsCat
			if not(ch_psc)
				ch_psc = openfile(-1984,intCo) \ If ch_psc = -1 Error 42 ! prod 	
			endif
			If rol.PSlsCat > 0 And rol.PSlsCat<= (Chf(ch_psc) - 1)
				Read Record #ch_psc,rol.PSlsCat;psc.; 
			endif
		endif
		webstr$=webstr$,rtrim$(psc.CategoryDesc$),fdel$ 
		webstr$=webstr$,rtrim$(rol.ComdtyCode$),fdel$
		if not(cmc)
			cmc = openfile(-2288,intCo) \ If cmc = -1 Error 42 ! commo
		endif
		KCM$ = " ",KCM$        
		KCM$ = rol.ComdtyCode$+Blank$;kcm$[5]=""
		cmr = filegetcommhead(e$,cmc,"=",1,kcm$,cMC.)
		clear e$
		if cmr<=0
			clear cmc.
		endif
		webstr$=webstr$,rtrim$(cmc.CodeDescription$),fdel$ 
		webstr$=webstr$,str$(nstk.Buyer),fdel$
		clear buy.
		if nstk.buyer
			if not(ch_buy)
				 Ch_buy = openfile(-9991,intCo) \ If Ch_buy = -1 Error 42 ! buyer
			endif
			If nstk.buyer > 0 And nstk.buyer < (Chf(ch_buy) - 1)
				read record #ch_buy,nstk.buyer;buy.;
			endif
		endif
		webstr$=webstr$,rtrim$(buy.BuyerName$),fdel$ 
		webstr$=webstr$,rtrim$(rol.MatCode$),fdel$
		if not (ch_matc)
			ch_matc = openfile(-2272,intCo) \ If ch_matc = -1 Error 42 ! mat
		endif
		let keymat$=rol.MatCode$
		rec_mat=filegetmatcode(e$,ch_matc,"=",1,keymat$,matc.)
		clear e$
		if rec_mat<=0
			clear matc.
		endif
		webstr$=webstr$,rtrim$(matc.Description$),fdel$ 
		tmp$=clrtxtc$(e$,rol.VendItemCode$) ! chk/clr control chars
		tmp$=UCase$(tmp$) ! uppercase
		webstr$=webstr$,rtrim$(tmp$),fdel$
		webstr$=webstr$,str$(rol.vendor),fdel$
		clear vend.
		if rol.vendor<>0
			if not(vnc)
				vnc = OpenFile(-2400,IntCo) \ If vnc = -1 Error 42 ! vendor droplist
			endif
			let tmp$=rol.vendor using "######"
			vnr = filegeta80vm(e$,vnc,"=",1,tmp$,vend.) 
			clear e$
			if vnr<0
				clear vend.
			endif
		endif
		
		webstr$=webstr$,rtrim$(vend.name$),fdel$ ! vendor name
		webstr$=webstr$,str$(rol.PONum),fdel$	
		CNVTU[0] = 0;CNVTU[1] = rol.UMCost;CNVTU[2] = 2             
		CNVTA = rol.UnitGLCost !  / if rol.UMCost>0 and rol.numout>0 let CNVTA=rol.UnitGLCost/rol.numout
		X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)    
		if p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 ! unit gl cost
			let cnvcu[0]=1
			let cnvca[0]=x3
			let cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif       
		WebStr$ = WebStr$,LTrim$(X3 Using PMask$),fdel$ ! unit gl cost  
		CNVTU[0] = 0;CNVTU[1] = rol.UMCost;CNVTU[2] = 2             
		CNVTA = rol.UnitCost !  / if rol.UMCost>0 and rol.numout>0 let CNVTA=rol.UnitCost/rol.numout   
		if p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 ! unit cost
			let cnvcu[0]=1
			let cnvca[0]=x3
			let cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
		X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.) 
		if p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 ! unit cost
			let cnvcu[0]=1
			let cnvca[0]=x3
			let cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
		WebStr$ = WebStr$,LTrim$(X3 Using PMask$),fdel$ ! unit cost   
		webstr$=webstr$,str$(rol.dept),fdel$
		CNVTU[0] = 0;CNVTU[1] = rol.UMPrice;CNVTU[2] = 2     
		CNVTA = rol.UnitPrice !  / if rol.UMPrice>0 and rol.numout>0 let CNVTA=rol.UnitPrice/rol.numout                                
		X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.) 
		if p61$[136,136]="Y"  and rol.currfact<>0 and x3<>0 ! unit cost
			let cnvcu[0]=1
			let cnvca[0]=x3
			let cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
		WebStr$ = webstr$, LTrim$(X3 Using PMask$),fdel$ 
		webstr$=webstr$,str$(rol.LineNum),fdel$
		let tmp$="N" \ if p61$[85,85]="Y" let tmp$="Y"
		if credit or source=239 or source=207 let tmp$="N" ! not on credits or inquiry!
		webstr$=webstr$,tmp$,fdel$ 
		let tmp$="Y" \if p61$[128,128]="N" let tmp$="N" ! edit prod cat
		IF source=239 or source=207 let tmp$="N" ! no edit on inquiry
		webstr$=webstr$,tmp$,fdel$
		let tmp3=0
		if p61$[132,132]="Y" and nsfmcode<>0
			let tmp3=cost_lev[1]
		endif
		webstr$=webstr$,str$(tmp3),fdel$
		if tmp3<>0
			webstr$=webstr$,(nstk.CurrFrtCost using "######.##"),fdel$
			webstr$=webstr$,(nstk.PrevFrtCost using "######.##"),fdel$
		else
			webstr$=webstr$,"",fdel$
			webstr$=webstr$,"",fdel$
		endif
		! and the 5 uda fields
		webstr$=webstr$,LTrim$(nstk.NS_UDA1 using "##########.####"),fdel$
		webstr$=webstr$,Rtrim$(nstk.NS_UDA2$),fdel$
		webstr$=webstr$,Rtrim$(nstk.NS_UDA3$),fdel$
		webstr$=webstr$,Rtrim$(nstk.NS_UDA4$),fdel$
		webstr$=webstr$,Rtrim$(nstk.NS_UDA5$),fdel$
		list$[2]=webstr$
	endif
	e$=""
	Call AddToStr(e$,rstr$,List$[])                 
	Call AddToStr(e$,rstr$,esdel$) ! end of section         
	! status section                                                       
	Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)                 
	Call AddToStr(e$,rstr$,WebStr$)                                        
	Call SetOutPut(e$,rstr$)                  
	
 else
   include "src/callsuberr.inc"
   
 end try
End sub ! nsgetitem


Sub NSBUILDPROD()
!-------------------------------------------------------------------
! BUILD PRODUCT FROM NON-STOCK
 try
	dim nspw. as prodwhse
	Dim keyprod$[12],kcm$[40],field$[1,30]
	dim 1%,ch_matc,errstatus,e$[50]
	dim 2%,currdate,L4
	dim 3%,rec_mat,Rec_prod
	DIM A$[156],HZ$[90],PR_A2$[30],C1$[32],PSN$[20],U3$[60]        
	DIM PRFLG$[10],PRMKUPTYP$[4],PIC$[50],PRIML$[12]               
	DIM 1%,LLC,PFTB[3],PFU1[20],LM[1],UPCT,PR_PO[1]                
	DIM 1%,PRBASE,PRPARC2[3],PRD1[4],AGEDAY                        
	DIM 2%,A2,A3[2],B[24],PR_C4[10],PFCO[3],PLC[3],PSN[1],U2[1],U4[1] 
	DIM 2%,STK[2],FDT[1],PRMKUP[3],PRD0[2]                         
	DIM 3%,A1[7],A[33],PF_LOAD2,PFU2[6],PLV[1],PRPARC[3],U3,PFN[1] 
	DIM 3%,LBSORD,FUT[1],PRREDI[1],PRD2[3]                         
	REM {end dim.prod.i}                                           
	DIM K1$[25],K2$[20],K3$[40],K4$[40],K5$[45],COPYPROD$[12]      
	DIM PROD$[12],WHKEY$[14]
	DIM 3%,UNWORK[6],UNFWORK[6] 
	DIM 3%,P2[12,2],rec_tmp,FLE[5]
	dim 3%,rec_ror,keyroll$[50],keyroll2$[50],F$[16]
	dim nspwkey$[30],3%,rec_nspw
	dim rolkey2$[30]
	mat read #1,60,6;flg$;
	ReturnStatus=1
	Message$="OK"
	if source=207 or source=239 goto NSBPrdDone ! NO UPDATE ON INQUIRY!!
	if custom_customer$="HTBERRY" or custom_customer$="WENELSON"
		let P61$[85,85]="N" ! custom - no nstk to prod
	Endif
	! verify if build option is avail
	if p61$[85,85]="N"
		let returnstatus=0
		let message$="Build Product for Non-Stock Option Not Available"
		Goto NSBPrdDone
	endif
    Call dxget("ORDERID",tmp$)                             
	If tmp$ = ""  goto NSBPrdDone                            
	orderno = tmp$                                         
	If orderno < 1 Or orderno > 999999 Or Fra(orderno)     
		ReturnStatus = 0                                     
		Message$ = "ORDER NUMBER INVALID"                    
		Goto NSBPrdDone                                       
	End If                                                 
	OHR = GetOrdRec(e$,OHC,OSC,otc,orderno,roh.,ros.,rot.)
	e$=""
	If OHR <= 0 ! not found                                
		ReturnStatus = 99                                     
		Message$ = "ORDER WAS NOT FOUND"                     
		Goto NSBPrdDone
	endif
	if returnstatus<>0
		credit = 0 \ if ros.status=32 let credit=1
		call verifystat()
		if returnstatus=99  Goto NSBPrdDone
	endif
	IF ROH.OrdType=20 ! freight invoice no lines
		ReturnStatus = 0                                     
		Message$ = "ORDER TYPE=Freight Invoice, NO LINES ALLOWED"                     
		Goto NSBPrdDone
	endif
	let keyprod$="Z ZZZZZZZZZZ"
	PRR = filegetprod(e$,PRC,"=",1,keyprod$,PR.)
	clear e$
	if prr<=0
		let returnstatus=0
		let message$="Default Non-Stock Product 'Z ZZZZZZZZZZ' Not On File"
		Goto NSBPrdDone
	endif
	Call dxget("PRODID",tmp$)      
	tmp$ = Rtrim$(UCase$(tmp$)) + Blank$   
	prod$ = tmp$[1,12]
	if rtrim$(prod$)=""
		let returnstatus=0
		let message$="Invalid Product Code "+Prod$
		Goto NSBPrdDone
	endif
	let keyprod$=rtrim$(prod$)+blank$
	rec_prod = filegetprod(e$,PRC,"=",1,keyprod$,PR.)
	clear e$
	if rec_prod>0
		let returnstatus=0
		let message$="Product Id "+Rtrim$(PROD$)+" Already On File "
		Goto NSBPrdDone
	endif                            
	Call dxget("LN",tmp$) ! +Str$(X1),tmp$)              
	LineNo = tmp$ ! line # (zero on new lines)           
	If LineNo < 0 Or LineNo > 999 Or Fra(LineNo)        
		ReturnStatus = 0                                   
		Message$ = "INVALID ORDER LINE!"                   
		Goto NSBPrdDone           
	End If 
	if lineno<>0
		rolkey$ = " ",rolkey$                                
		rolkey$[1,6] = orderno Using "######"                
		rolkey$[7,9] = LineNo Using "###"                    
		rolkey$[11] = "" ! cut to length (space @ 10)        
		OLR = filegetrolz(e$,OLC,"=",1,rolkey$,rol.) 
		clear e$
		If OLR <= 0                                          
			ReturnStatus = 0 
			Message$ = "Order Line Not Found"  
			Goto NSBPrdDone
		End If
	
		if not(rol.NStkItem) 
			ReturnStatus = 0
			Message$="Order Line is not a Non-Stock Item"
			Goto NSBPrdDone
		endif
	else
		let olr=-1
		clear rol.
	endif
	! open product sales file
	If not(ch_prsls)
		ch_prsls = OpenFile(2080,IntCo) \ If ch_prsls = -1 Error 42 ! prod sales file
	endif
	IF not(CH_PDESCKEY)
		ch_pdesckey = OpenFile(1104,IntCo) \ If ch_pdesckey = -1 Error 42 ! prod sales file
	endif
	! read old product use prr  -- using with old format since I need arrays
	! from the Z product
	MAT  READ #PRC,PRR,0;A$;          
	MAT  READ #PRC,PRR,156;B;        
	MAT  READ #PRC,PRR,256;A;        
	MAT  READ #PRC,PRR,460;A1;        
	MAT  READ #PRC,PRR,508;A2;       
	MAT  READ #PRC,PRR,512;PFU1;      
	MAT  READ #PRC,PRR,554;PFU2;      
	MAT  READ #PRC,PRR,596;PRPARC;    
	MAT  READ #PRC,PRR,620;LM;   
	MAT  READ #PRC,PRR,624;PR_PO;     
	MAT  READ #PRC,PRR,628;AGEDAY;   
	READ #PRC,PRR,630;LLC;            
	MAT  READ #PRC,PRR,632;PSN$;      
	MAT  READ #PRC,PRR,652;PSN;       
	MAT  READ #PRC,PRR,660;U2;        
	MAT  READ #PRC,PRR,664;LBSORD;
	MAT  READ #PRC,PRR,670;U4;            
	READ #PRC,PRR,678;U3;                 
	MAT  READ #PRC,PRR,684;U3$;           
	MAT  READ #PRC,PRR,744;HZ$;           
	MAT  READ #PRC,PRR,834;A3;            
	MAT  READ #PRC,PRR,846;PFTB;          
	READ #PRC,PRR,854;UPCT;               
	MAT  READ #PRC,PRR,856;C1$;           
	MAT  READ #PRC,PRR,894;PR_C4;         
	MAT  READ #PRC,PRR,938;PF_LOAD2;      
	MAT  READ #PRC,PRR,944;PR_A2$;        
	MAT  READ #PRC,PRR,974;PFCO;          
	MAT  READ #PRC,PRR,990;PLV;           
	MAT  READ #PRC,PRR,1002;PLC;          
	MAT  READ #PRC,PRR,1018;PFN;          
	MAT  READ #PRC,PRR,1030;STK;          
	MAT  READ #PRC,PRR,1048;FDT;          
	MAT  READ #PRC,PRR,1056;PRFLG$;       
	MAT  READ #PRC,PRR,1066;PRBASE;       
	MAT  READ #PRC,PRR,1068;PRMKUP;                     
	MAT  READ #PRC,PRR,1084;PRMKUPTYP$;                       
	MAT  READ #PRC,PRR,1088;FUT;                              
	MAT  READ #PRC,PRR,1100;PRPARC2;                          
	MAT  READ #PRC,PRR,1108;PRREDI;                           
	MAT  READ #PRC,PRR,1120;PIC$; 
	MAT  READ #PRC,PRR,1270;PRD0;                             
	MAT  READ #PRC,PRR,1282;PRIML$;                           
	MAT  READ #PRC,PRR,1294;PRD1;                            
	MAT  READ #PRC,PRR,1304;PRD2;           
	! clear variables needed ! 
	FOR I=0 TO 33                         
		FOR A2=0 TO 2                       
			IF I<=12 LET P2[I,A2]=0           
		NEXT A2                             
		IF I<=3 LET A[I]=0                  
		IF I>=7 and I<=19 LET A[I]=0         
		IF I>=26 LET A[I]=0                 
		IF I>=1 and I<=7 LET B[I]=0          
		IF I>=12 and I<=15 LET B[I]=0        
		IF I<4 LET PFCO[I]=0                
	NEXT I                                
	LET PR_A2$[1,12]=" ",PR_A2$[1,12]     
	LET A1[0]=0 \ LET A1[2]=0 \ LET A2=0
	A3[0]=0;A3[1]=0;A3[2]=0 ! HAZ,MSDS,
	! lm[0]=0;lm[1]=0 keep load markup tables from Z_ZZZZZZ
	hz$=" ",hz$
	Read #ctlc,3,172;currdate;
	LET pr_C4[7]=currdate ! DATE ESTABLISHED
	! U4[0]=0;U4[1]=0 keep Except Sale and Lead Time % from Z_ZZZZZZZ
	! PR_C4[3]=0; keep Price Markup Table
	U2[0]=0;U2[1]=0
	A$[116,126]="           " ! COST GROUP
    Call dxget("DESC1",tmp$)
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Description 1"
		Goto NSBPrdDone
	Endif
	A$[9,38]=rtrim$(tmp$) + Blank$ 
	Call dxget("DESC2",tmp$)
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Description 2"
		Goto NSBPrdDone
	Endif
	A$[63,92] = rtrim$(tmp$) + Blank$                            
	Call dxget("VENDITM",tmp$) 
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Vendor Item"
		Goto NSBPrdDone
	Endif
	A$[93,112] = rtrim$(tmp$) + Blank$                               
	A$[140,151]=prod$
	Call dxget("COMMD",tmp$)   
	if rtrim$(tmp$)=""
		let returnstatus=0
		message$="Commodity Code needs to be Entered"
		goto NSBPrdDone
	endif
	A$[152,155]=tmp$+blank$
	Call dxget("MATCD",tmp$)
	a$[156,156]=tmp$+blank$
	let flg$[3,3]="Y"
	if flg$[3,3]="Y"
		Call dxget("HAZFLG",tmp$)
		if rtrim$(tmp$)="Y" let A3[0]=1
		if rtrim$(tmp$)="S" let A3[0]=2
		IF A3[0]<>0
			Call Dxget ("HAZID",tmp$) ! hazardous id
			if not (ch_haz)
				Ch_Haz = openfile(-2784,intCo) \ If Ch_Haz = -1 Error 42 ! hazar
			endif
			let rec_haz=filegethazname(e$,ch_haz,"=",1,tmp$,haz.)
			clear e$
			if rec_haz>0
				a3[2]=rec_haz
			endif
		endif
		Call Dxget ("HAZCLASS",TMP$) ! HAZ CLASS
		LET HZ$[41,64]=rtrim$(tmp$)+BLANK$
		call dxget ("PACKGROUP",tmp$) ! 
		let HZ$[65,70]=rtrim$(tmp$)+blank$
		call dxget ("DOTID",tmp$)
		let hz$[71,80]=rtrim$(tmp$)+blank$
		call dxget ("ERBOOK",tmp$)
		let hz$[81,90]=rtrim$(tmp$)+blank$
	endif
	call dxget("GLCOST",tmp$) !+Str$(X1),tmp$) ! NSBUILD
	V3[9]=tmp$
	if v3[9]<0 or v3[9]>9999999
		returnstatus=0
		message$="GL Cost is out of range"
		Goto NSBPrdDone
	Endif

	! set unit of measures into unwork
	! base unit of measure  ! UNWORK[0]
	Call dxget("UMBASE",tmp$) 
	!If tmp$[1,1] > "9" ! sent text?             
		 R = getumrec(e$,ccc,tmp$,IntCo,PR.)       
		If R <> 0 Let tmp$ = Str$(R)              
	!End If                                      
	UNWORK[0] = tmp$
	if unwork[0]<0
		returnstatus=0
		Message$="Invalid Base UM"
		Goto NSBPrdDone
	Endif
	! selling unit of measure ! unwork[1]
	Call dxget("UMSELL",tmp$) 
	!If tmp$[1,1] > "9" ! sent text?             
		 R = getumrec(e$,ccc,tmp$,IntCo,PR.)       
		If R <> 0 Let tmp$ = Str$(R)              
	!End If                                      
	UNWORK[1] = tmp$
	if unwork[1]<0 ! can't use system um for QTY
		returnstatus=0
		Message$="Invalid Sell UM"
		Goto NSBPrdDone
	Endif
	! Pricing unit of measure ! unwork[2]
	Call dxget("UMPRICE",tmp$) 
	!If tmp$[1,1] > "9" ! sent text?             
		 R = getumrec(e$,ccc,tmp$,IntCo,PR.)       
		If R <> 0 Let tmp$ = Str$(R)              
	!End If                                      
	UNWORK[2] = tmp$
	! Costing unit of measure ! unwork[3]
	Call dxget("UMCOST",tmp$) 
	!If tmp$[1,1] > "9" ! sent text?             
		 R = getumrec(e$,ccc,tmp$,IntCo,PR.)       
		If R <> 0 Let tmp$ = Str$(R) 
	!End If                                      
	UNWORK[3] = tmp$
	NROL.UMCOST=UNWORK[3]
	
	! Purchasing unit of measure ! unwork[4]
	Call dxget("UMPURCH",tmp$) 
	!If tmp$[1,1] > "9" ! sent text?             
		 R = getumrec(e$,ccc,tmp$,IntCo,PR.)       
		If R <> 0 Let tmp$ = Str$(R)              
	!End If                                      
	UNWORK[4] = tmp$ ! 
	! lbs unit of measure ! unwork[4]
	Call dxget("UMLBS",tmp$)  ! this might be lbs factor
	!If tmp$[1,1] > "9" ! sent text?             
		 R = getumrec(e$,ccc,tmp$,IntCo,PR.)       
		If R <> 0 Let tmp$ = Str$(R)              
	!End If                                      
	UNWORK[5] = tmp$
	
	! let do the factors
	UNFWORK[0]=1
	Call dxget("SELLFCTR",tmp$)                          
	UNFWORK[1]=tmp$ \ If unfwork[1] <= 0 Let unfwork[1] = 1  
	Call dxget("PRCFCTR",tmp$)                               
	UNFWORK[2]=tmp$ \ If unfwork[2] <= 0 Let unfwork[2] = 1
	Call dxget("COSTFCTR",tmp$) 
	UNFWORK[3]=tmp$ \ If unfwork[3] <= 0 Let unfwork[3] = 1
	Call dxget("PURCHFCTR",tmp$)                           
	UNFWORK[4]=tmp$ \ If unfwork[4] <= 0 Let unfwork[4] = 1
	Call dxget("LBSFCTR",tmp$)
	UNFWORK[5]=tmp$ \ If unfwork[5] <= 0 Let unfwork[5] = 1
    Call dxget("CUBEFCTR",tmp$) 
	UNFWORK[6]=tmp$ \ If unfwork[6] <= 0 Let unfwork[6] = 1!+Str$(X1),tmp$)
	! cube unit of measure
	Call dxget("UMCUBE",tmp$) !+Str$(X1),tmp$)   
	!If tmp$[1,1] > "9" ! sent text?              
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)        
		If R <> 0 Let tmp$ = Str$(R)               
	!End If 
	UNWORK[6] =tmp$ ! UNFWORK[6]=tmp$ \ If unfwork[6] <= 0 Let unfwork[6] = 1!+Str$(X1),tmp$)
        unfwork[6]=1
	if R=unwork[0]
		let unfwork[6]=1
	else
		if r=unwork[1]
			let unfwork[6]=unfwork[1]
		else
			if r=unwork[2]
				let unfwork[6]=unfwork[2]
			else
				if r=unwork[3]
					let unfwork[6]=unfwork[3]
				else
					if r=unwork[4]
						let unfwork[6]=unfwork[4]
					endif
				endif
			endif
		endif
	endif
	Call dxget("UMLBS",tmp$) !+Str$(X1),tmp$)    
	!If tmp$[1,1] > "9" ! sent text?              
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)        
		If R <> 0 Let tmp$ = Str$(R)               
	!End If
	unwork[5]=r
	if R=unwork[0]
		let unfwork[6]=1
	else
			if r=unwork[1]
			let unfwork[6]=unfwork[1]
		else
			if r=unwork[2]
				let unfwork[6]=unfwork[2]
			else
				if r=unwork[3]
					let unfwork[6]=unfwork[3]
				else
					if r=unwork[4]
						let unfwork[6]=unfwork[4]
					endif
				endif
			endif
		endif
	endif
    Call dxget("VENDOR",tmp$)
	LET B[24]=Tmp$! vendor code 
	Call dxget("SLSCAT",tmp$) 
	LET B[11]=tmp$
	Call dxget("UNCUBE",tmp$) 
	LET B[23]=tmp$ ! cube feet
	Call dxget("UNLBS",tmp$) 
	LET A[6]=tmp$ ! cube feet
                  
	LET PFU1[0]=UNWORK[0]               
                               
	LET PFU1[0]=UNWORK[0]                  
	LET K=0                                
	FOR Y=1 TO 4                           
		FOR X=0 TO 7                           
			 IF UNWORK[Y]=PFU1[X] GOTO NEXTY:     
		NEXTX: NEXT X                          
		LET K=K+1                              
		IF UNWORK[Y]>0 LET PFU1[K]=UNWORK[Y]   
		IF UNWORK[Y]>0 LET PFU2[K-1]=UNFWORK[Y]
	NEXTY: NEXT Y                          
	LET PFU1[9]=UNWORK[1]                  
	LET PFU1[10]=UNWORK[4]                 
	LET PFU1[11]=UNWORK[3]                 
	LET PFU1[12]=UNWORK[2] 
	! SET TO PURCHASING UNIT OF MEASURE
	LET PFU1[8]=PFU1[10] ! STOCKING
	LET PFU1[20]=PFU1[10] ! VENDOR ORDER
	LET PFU1[18]=PFU1[10] ! PACKING
	LET PFU1[19]=PFU1[10]  ! PROD SIZE
	! SET TO SELLING UNIT OF MEASURE
	LET PFU1[16]=PFU1[9] ! UPCHARGE
	LET PFU1[17]=PFU1[9] ! BROKEN
	LET PFU1[13]=PFU1[9] ! PROD/POS
	LET A1[3]=UNFWORK[6]                   
	!LET B[23]=UNWORK[6]  ! cube feet                   
	!LET A[6]=UNWORK[5]  ! lbs                   
	LET A[5]=UNFWORK[5]                    
	LET PGWL=A[6];PGWF=A[5] 
	pr.BaseUM=PFU1[0]
	pr.UM2=pfu1[1];pr.UM2Fact=PFU2[0]
	pr.UM3=Pfu1[2];pr.UM3Fact=pfu2[1]
	pr.UM4=pfu1[3];pr.UM4Fact=pfu2[2]
	pr.UM5=pfu1[4];pr.UM5Fact=pfu2[3]
	pr.UMStkDefault = PFU1[8] 
	pr.UMSellDefault = PFU1[9] 
	pr.UMPurchDefault= PFU1[10]
	pr.UMCostDefault  = PFU1[11]
	pr.UMPriceDefault  = PFU1[12]
	pr.UMPrdtnDefault  = PFU1[13]
	pr.LbsFact=A[5]
	pr.LbsUnit=A[6]
	! SET COST
	if v3[9]>0 ! sent glcost
		if p61$[136,136]="Y" and rol.currfact<>0 and V3[9]<>0
			let cnvcu[0]=2
			let cnvcu[1]=1
			let cnvca[0]=V3[9]
			let cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let v3[9]=cnvca[0]
		endif
		CNVTU[0]=nrol.UMCost;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
		cnvta=v3[9] \ if nrol.UMCost>0 and nrol.NumOut>0 let cnvta=v3[9]*nrol.numout
		nrol.UnitGLCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		LET PR_C4[4]=NROL.UNITGLCOST ! base cost
		let b[10]=nrol.unitglcost ! po cost
		let b[21]=nrol.unitglcost ! average cost
	Endif

	let e=2
	search #prc,1,0;keyprod$,rec_prod,e
	if e
		let returnstatus=0
		let message$="Error in Allocating Product Id "+Rtrim$(PROD$)+" Cannot Add"
		goto NSBPrdDone
	endif
	LET A[26]=REC_PROD;PRR=REC_PROD
	MAT  WRITE #prc,REC_PROD,0;A$          
	MAT  WRITE #prc,REC_PROD,156;B         
	MAT  WRITE #prc,REC_PROD,256;A         
	MAT  WRITE #prc,REC_PROD,460;A1        
	MAT  WRITE #prc,REC_PROD,508;A2        
	MAT  WRITE #prc,REC_PROD,512;PFU1      
	MAT  WRITE #prc,REC_PROD,554;PFU2      
	MAT  WRITE #prc,REC_PROD,596;PRPARC    
	MAT  WRITE #prc,REC_PROD,620;LM        
	MAT  WRITE #prc,REC_PROD,624;PR_PO     
	MAT  WRITE #prc,REC_PROD,628;AGEDAY    
	WRITE #prc,REC_PROD,630;LLC            
	MAT  WRITE #prc,REC_PROD,632;PSN$      
	MAT  WRITE #prc,REC_PROD,652;PSN       
	MAT  WRITE #prc,REC_PROD,660;U2        
	MAT  WRITE #prc,REC_PROD,664;LBSORD
	MAT  WRITE #prc,REC_PROD,670;U4            
	WRITE #prc,REC_PROD,678;U3                 
	MAT  WRITE #prc,REC_PROD,684;U3$           
	MAT  WRITE #prc,REC_PROD,744;HZ$           
	MAT  WRITE #prc,REC_PROD,834;A3            
	MAT  WRITE #prc,REC_PROD,846;PFTB   
	WRITE #prc,REC_PROD,854;UPCT               
	MAT  WRITE #prc,REC_PROD,856;C1$           
	MAT  WRITE #prc,REC_PROD,894;PR_C4         
	MAT  WRITE #prc,REC_PROD,938;PF_LOAD2      
	MAT  WRITE #prc,REC_PROD,944;PR_A2$        
	MAT  WRITE #prc,REC_PROD,974;PFCO          
	MAT  WRITE #prc,REC_PROD,990;PLV           
	MAT  WRITE #prc,REC_PROD,1002;PLC          
	MAT  WRITE #prc,REC_PROD,1018;PFN          
	MAT  WRITE #prc,REC_PROD,1030;STK          
	MAT  WRITE #prc,REC_PROD,1048;FDT          
	MAT  WRITE #prc,REC_PROD,1056;PRFLG$       
	MAT  WRITE #prc,REC_PROD,1066;PRBASE       
	MAT  WRITE #prc,REC_PROD,1068;PRMKUP	                        
	MAT  WRITE #prc,REC_PROD,1084;PRMKUPTYP$                       
	MAT  WRITE #prc,REC_PROD,1088;FUT                              
	MAT  WRITE #prc,REC_PROD,1100;PRPARC2                          
	MAT  WRITE #prc,REC_PROD,1108;PRREDI                           
	MAT  WRITE #prc,REC_PROD,1120;PIC$                             
	MAT  WRITE #prc,REC_PROD,1270;PRD0                             
	MAT  WRITE #prc,REC_PROD,1282;PRIML$                           
	MAT  WRITE #prc,REC_PROD,1294;PRD1                             
	MAT  WRITE #prc,REC_PROD,1304;PRD2;
	K1$=KEYPROD$
	SEARCH #prc,4,1;K1$,REC_PROD,E
	IF E>1
		let returnstatus=0
		message$="Error in Adding Directory 1 for Product "+Rtrim$(prod$)
		Goto NSBPrdDone
	endif        
	LET K2$=" ",K2$ \ LET K2$[2,2]=A$[139,139] \ LET K2$[3]=K1$        
	SEARCH #prc,4,2;K2$,REC_PROD,E 
	IF E>1
		let returnstatus=0
		message$="Error in Adding Directory 2 for Product "+Rtrim$(prod$)
		Goto NSBPrdDone
	endif     
	LET K3$=" ",K3$ \ LET K3$[1,4]=A$[152,155] \ LET K3$[5]=K1$[1,12]  
	SEARCH #prc,4,3;K3$,REC_PROD,E
	IF E>1
		let returnstatus=0
		message$="Error in Adding Directory 3 for Product "+Rtrim$(prod$)
		Goto NSBPrdDone
	endif       
	LET K4$=" ",K4$ \ LET K4$[1,20]=A$[93,112] \ LET K4$[21]=K1$       
	SEARCH #prc,4,4;K4$,REC_PROD,E
	IF E>1
		let returnstatus=0
		message$="Error in Adding Directory 4 for Product"+Rtrim$(prod$)
		Goto NSBPrdDone
	endif       
	sqlChan = OpenMySQLMirror(e$) !
	if sqlChan >= 0 ! SQL option enabled and open succeeded
		e = prod_UpdateSQLFromDL4(e$, intCo, K1$, sqlChan, prc)
		if E<>1 ! 1 record inserted / updated
			message$="Error adding MySQL product record!"
			Goto NSBPrdDone
		end if
	end if
	LET K5$[1,30]=UCase$(A$[9,38])+blank$
	Let k5$[31]=A$[140,151]  
	! need to open a product description file
	SEARCH #CH_PDESCKEY,4,1;K5$,REC_PROD,E
	IF E>1
		let returnstatus=0
		message$="Error in Adding Product Description Key "+Rtrim$(prod$)
		Goto NSBPrdDone
		endif     
	! UPDATE PROD SALES
	WRITE #CH_PRSLS,REC_PROD,0;A$[140,151]
	MAT  WRITE #CH_PRSLS,REC_PROD,16;P2   
	MAT  WRITE #CH_PRSLS,REC_PROD,256;P2; 
	! UPDATE WAREHOUSE -- GET WAREHOUSE FROM HEADER
	if olr<=0
		let rol.whse = roh.wh
		if not (rol.whse) let rol.Whse = roh.wh
	endif
	if not (rol.whse) let rol.Whse = roh.wh
	if not (rol.whse) let rol.whse=1
	if roh.ordtype=8 or roh.ordtype=16 ! check/bld to whse
	  If Roh.ConsWh>0 and roh.conswh<100
		let TPWKey$=" ",tpwKey$
		TPWkey$[1,12]=prod$[1,12]+Blank$
		TPWKey$[13]=ROH.ConsWh Using "##"
		call chktowhse(TPWKey$,B[24])
	  Endif
	Endif
	let k5$=" ",k5$
	k5$[1,12]=prod$[1,12]
	k5$[13]=rol.Whse Using "##"
	PWR=filegetprodwhse(e$,PWC,"=",1,k5$,pw.)
	clear e$
	if PWR<0 ! not found
		Clear pw.
		Whbld[0] = PWC
		if rol.whse<=0 let rol.whse=roh.wh
		if rol.whse<=0 let rol.whse=1
		! whbld[0] = channel number for prodwhse file
		Whbld[1] = rol.Whse
		Whbld[2] = B[24] ! vednor
		WHBLD[3]=1 ! flag as non-stock
		IF rol.whse<>1 let whbld[1]=rol.whse+.01 ! fra=copy whse 1
		Call mxwhcreate(e$,IntCo,Prod$,Whbld[])        
		PWR = Whbld[2];e$ = "" 
		read record #pwc,pwr,0;pw.;
		nspwkey$=" ",nspwkey$
		let nspwkey$[1,12]="Z ZZZZZZZZZZ"
		let nspwkey$[13,14]=rol.whse using "##"
		rec_nspw=0
		search #pwc,2,1;nspwkey$,rec_nspw,e
		if not (e)
			read record #pwc,rec_nspw,0;nspw.;
		else
			let rec_nspw=0
			if rol.whse<>1
				let nspwkey$[13,14]=" 1"
				search #pwc,2,1;nspwkey$,rec_nspw,e
				if not(e)
					read record #pwc,rec_nspw,0;nspw.;
				else
					let rec_nspw=0
				endif
			endif
		endif
		if rec_nspw<>0 ! ok
			pw.DNReordFlg=nspw.DNReordFlg! 
			pw.ProdGrp=nspw.ProdGrp 
			pw.FrcstWgtTbl=nspw.FrcstWgtTbl ! Forecase
			pw.CalcSrc=nspw.Calcsrc ! Reorder Table
			if P9$[32,32]="Y" ! warehouse pricing
				Pw.CostAvg=b[21]   
				pw.CostLastPo=b[10]
				pw.CostBase=pr_c4[4]
			endif
			write record #pwc,pwr,0;pw.;
		endif			
		PRR = filegetprod(e$,PRC,"=",1,keyprod$,PR.)

	endif
	Read Record #PWC,PWR,0;pw.;
	! set the buyer from the non-stock screen
	Call dxget("BUYER",tmp$) !+Str$(X1),tmp$)  
	let tmp3=tmp$
	if tmp3<>pw.buyer
		let k3$=" ",k3$
		let k3$[1,2]=pw.whse using "##"
		let k3$[3,5]=pw.buyer using "###"
		let k3$[6,17]=pw.prodcode$
		search #pwc,2,2;k3$,tmprec,e
		if not(e)
			search #pwc,5,2;k3$,tmprec,e
		endif
		let k4$=k3$
		let k4$[3,5]=tmp3 using "###"
		search #pwc,4,2;k4$,pwr,e
	endif
	pw.Buyer = tmp$ 
	write Record #PWC,PWR,0;pw.;
	if P61$[35,35] = "Y"
		Read record #PRC,Rec_Prod,0;pr.; ! reread new rec
		!fle[0]=ctlc
		!fle[1]=prc
		!fle[2]=pwc
		!errstatus=1
		e$=""
		!Call turboadd(intco,prod$,e$,fle[],errstatus)
		call apturbo(e$,CTLC,IntCo,REC_PROD,pr.) ! add new turbo
		e$=""
	endif
	
	! need to delete the non-stock item
	if lineno<>0 and olr>0
		nsr = rol.PDRecNum ! record                                        
		Read Record #nsc,nsr,0;nstk.;
		if nstk.SpareNu$=""
			let nstk.SpareNu$="  "
			write record #NSC,NSR,0;nstk.;
		Endif
		X3 = fileupdatesproddesc(e$,nsc,"d",nsr,nstk.) ! delete sproddesc  
		! if x3<0 ! problem deleting 
		! do I need to change ! delete the old non-stock 
		! nonstock items do not have a directory 2 key
		!let rolkey2$=" ",rolkey2$
		!let rolkey2$[1,6]=rol.PDRecNum using "######"
		!let rolkey2$[7,12]=rol.OrdNum using "######"
		!let rolkey2$[13]=rol.LineNum using "###"
		!search #olc,5,2;rolkey2$,rec_tmp,e
	
		rol.PDRecNum=PRR ! rec_prod 
		rol.NStkItem=0 
		rol.ProdCode$=prod$+blank$
		clear rol.SpareNu$ ! dl4 fix
		Write Record #OLC,OLR,0;rol.;
		let rolkey2$=" ",rolkey2$
		let rolkey2$[1,6]=rol.PDRecNum using "######"
		let rolkey2$[7,12]=rol.OrdNum using "######"
		let rolkey2$[13,15]=rol.LineNum using "###"
		search #olc,4,2;rolkey2$,olr,e
	endif
	! let update stock
	! mtdg
	NSBPrdDone: ! done
	if returnstatus=1 let message$="OK" ! set if no other problems
		if debugdetail
		dmsg$="Product "+rtrim$(Prod$)+" Built "+Str$(rol.OrdNum)+"-"+Str$(rol.LineNum)+" "+Message$ \ Call updatelog(debug)
	Endif
 else
	include "src/callsuberr.inc"
 end try
End sub !NSBUILDPROD

!---------------------------------------------------------------------
!--------------------------------------------------------------------
Sub GetCust()
! get customer data (after header read!)
 Try
	Dim KCust$[60]
	Dim 3%,CUR
	KCust$=" ",KCust$
	KCust$=roh.CustNum Using "######"
	CUR=filegetcust(e$,CUC,"=",1,KCust$,Cust.) ! need customer fields
	clear e$
	If CUR<0 clear cust.
	if debugdetail
		dmsg$="Get Customer "+kcust$+" REC="+Str$(CUR) \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
  end try
end sub ! GetCust
! 
!--------------------------------------------------------------------
Function GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh. as roh, ros. as ros, rot. as rot)
! search thru all status for Order
! ohc,osc,otc = channels for roh, ros, rot
! orderNo = Order # to find
! roh.,ros.,rot. = structs for roh,ros,rot
! returns 
! X3 = order header rec #
	Try
		Dim KOHC$[20]
		Dim 1%,X[9],SCHN[2]
		Dim 2%,X2[9]
		Dim 3%,X3[9],OHR
		SCHN[0]=OHC;SCHN[1]=OSC;SCHN[2]=OTC
		Let X2=OrderNo
		let OHR=-1 ! not found as default
		if debugdetail
			dmsg$="Look for Order "+Str$(X2) \ Call updatelog(debug)
		Endif
		For X=1 to 99
			e$=""
			If X<20 or x>24 ! skip deleted
				Let KOHC$=" ",KOHC$
				KOHC$[1,2]=X Using "##"
				KOHC$[3]=OrderNo Using "######"
				X3=filegetrohz(e$,SCHN[],"=",1,kohc$,roh.,ros., rot.)
				clear e$ ! we expect a msgrohNOF - It's NOT CAUSE TO BOMB!
				If X3>0 ! found it
				  Exit function X3
				Endif
			Endif
		Next X
		if debugdetail
			dmsg$="Order NOT FOUND "+Str$(X2) \ Call updatelog(debug)
		Endif
	else
    include "src/callsuberr.inc"
  end try
end Function OHR ! getordrec
! 
!--------------------------------------------------------------------
Sub GetNewProdDtl(e$,List$[],maxcnt,Prod$,Sqty,SUM,OHR,SHQty,BOQty)
! send prod, qty, um, order Rec
! sends back list$ with details (use rol. varnames)
! ALSO CREATE ORDER LINE NOW! allocates & edittrack
! added: 04/19/10 - Nonstock (from lastprice)
! added: 08/17/11 - Option to just load data - NO UPDATE (maxcnt<0)
Try
	Dim KPR$[60],KPW$[60],kcm$[40],k1$[50]
	
	Dim 1%,Cnvtu[2],Flag,E,X[9],Pram[5]
	Dim 1%,FCDays,Zline,NonStk,onCPI
	Dim 2%,X2[9],TaxBack,JDate[5],FDate,ShipDate
	Dim 2%,nsltbl
	Dim 3%,CNVTA,Amount,x3[9],FutCost,LPR
	Dim 3%,MSHQty,MBOQty,s9[20],leftOnCPI,recCPI
	
	Dim NRol. as rolnew ! store new sent data

	if debugdetail
		dmsg$="Start New Line" \ Call updatelog(debug)
	Endif
	e$="";ZLine=0;NonStk=0
	Read #ctlc,2,198;FCDays; ! days to check future cost
	Read #ctlc,3,188;ShipDate; ! for inv levels
	If FCDays<1 or FCDays>999 or Fra(FCDays) Let FCDays=30 ! check range
	tmpcnt=maxcnt ! row is passed
	tmpcnt2=maxcnt ! second list
	! add for nonstock lastprice
	
	if UCase$(RTrim$(LPType$))="NSTK" let nonstk=1
	if nonstk ! additional data from SetNewProdline
		! let lpnstk=1 ! customer(master)
		! let lpnstk=2 ! shiplist(site)
		if lpnstk=2 ! need sllst file
			SLC=OpenFile(-9982,IntCo) \ if slc=-1 Error 42
		Endif
		if lpnstk=0
			Let E$=" No Last Price File Sent" ! +Prod$
			Let ReturnStatus=0
			if debugdetail
				dmsg$=prod$+e$ \ Call updatelog(debug)
			Endif
			Exit Sub
		Endif
		if lpnstk=1 let x3=chf(LPC)-1
		if lpnstk=2 let x3=chf(SLC)-1
		if lprec<=0 or lprec>x3 or fra(lprec)
			Let E$=" Invalid Last Price Record Sent" ! +Prod$
			Let ReturnStatus=0
			if debugdetail
				dmsg$=prod$+e$ \ Call updatelog(debug)
			Endif
			if lpnstk=2 try close #slc Else rem
			Exit Sub
		Endif
		Prod$="Z ZZZZZZZZZZ" ! set for default/missing
		chan=lpc
		if lpnstk=2 let chan=slc
		read record #chan,lprec,0;clp.;
		call NSFRMLP()
		if lpnstk=2
			if slc try close #slc Else rem
		Endif
		goto GotLPNS
	Else ! stock item
		tmp$=ChkAltItem$(e$,IntCo,Prod$,roh.CustNum)
		If tmp$<>"" If tmp$[1,2]<>"  " let prod$=tmp$ ! has alt item
	Endif
	Let kpr$=Prod$
	Let kpr$[13]="";e=0 ! no lock
	If prod$[1,3]="Z  " let Nonstk=1;ZLine=1
	If Prod$[1,3]="Z Z" let nonstk=1
	If Abs(SQty)>9999999 or ABS(SHQTY)>9999999 or ABS(BOQTY)>9999999
		E$="Quantity is out of range"
		returnstatus=0
		Exit Sub
	Endif
	If not(ZLine) ! still get prod for nonstk
	 PRR = filegetprod(e$,PRC,"=",1,KPr$,PR.,e)
	 clear e$
	 If PRR<=0 ! not found
		Let E$=" PRODUCT NOT FOUND" ! +Prod$
		Let ReturnStatus=0
		if debugdetail
			dmsg$=prod$+e$ \ Call updatelog(debug)
		Endif
		Exit Sub
	 Endif
	Endif
	
	Clear rol. ! clear rol. to start
	GotLPNS: ! start for nonstk from lp (rol filled)
	Clear nrol. ! clear new data (as is none yet)
	Clear specs[] ! clear specs vars
	FlePtr[4,1]=0;LPR=0 ! clear last price info! 239790
	! check if valid um# sent
	if SUM=0 ! was not(nonstk) and 
		let sum=pr.UMSellDefault
		if source=251 and pr.UMPrdtnDefault<>0 let sum=pr.UMPrdtnDefault
	Endif
	If not(nonstk) and SUM<>0 ! can't check what's not there!
	 Flag=ChkPrdUM(e$,SUM,IntCo,Pr.)
	 If Not(Flag)
		Let E$=" INVALID QUANTITY U/M" ! +Prod$
		Let ReturnStatus=0
		if debugdetail
			dmsg$=e$+" Rec "+Str$(SUM) \ Call updatelog(debug)
		Endif
		Exit Sub
	 Endif
	Endif
	Read Record #OHC,OHR,0;roh.; ! still there from getordrec?
	if p61$[136,136]="Y"
		let nrol.currid=roh.currid
		let nrol.currfact=roh.currfact
		let rol.currid=roh.currid
		let rol.currfact=roh.currfact
	endif
	Credit=0 \ if roh.Status>=8 and roh.Status<=12 Let Credit=1
	If ROH.OrgStatus>=8 AND ROH.OrgStatus<=12 let Credit=1
	if returnstatus<>0
			call verifystat()
			if returnstatus=99
				exit sub
			endif
		endif
	if credit and roh.ShipType=3 let cost_lev[1]=0 ! no cost on cm price error
	OrderNo=roh.OrdNum
	If ZLine ! set needed, rest zero/null
		rol.NStkItem=1
		rol.OrdNum=roh.OrdNum
		rol.Desc1$=Blank$
		rol.Desc2$=Blank$
		rol.whse=roh.wh
		let rol.linetype=3
		rol.ProdCode$="Z"+Blank$
		rol.PSlsCat=20
		rol.ComdtyCode$="MISC"
		goto GNPDDone ! clear & submit nothing for zlines
	Endif ! of zline
	X1=roh.ordtype
	if SQty<0 and (credit Or (x1=4 or x1=7 or x1=8 or x1=15 or x1=16 or x1=19 or x1=24))
		E$="No Negative Order Quantity allowed"
		returnstatus=0
		Exit sub
	Endif
	! okay, convert qty to BASE
	let cnvtu[0]=SUM;cnvtu[1]=0;cnvtu[2]=1
	let cnvta=SQty  ! BIG Q: is cutting known at this point??? *****
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	Let rol.QtyOrd=Int(Amount) ! always integer base - just cut it
	IF SQTY<0 AND (SHQTY<>0 or BOQTY<>0) ! NO BO AND SHIP SAME!
		SHQTY=SQTY;BOQTY=0
	Endif	
	if SHQty ! order pad detl allows entry
		cnvta=SHQty ! CUTTING??
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		MSHQty=Amount;rol.QtyShip=Amount
	Endif
	
	If BOQty ! order pad detl allows entry
		cnvta=BOQty
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		MBOQty=Amount;rol.QtyBO=Amount
	Endif
	If SQTY>0 and (SHQTY<0 or BOQTY<0)
		Let E$=" INVALID QUANTITY ENTERED +/- " ! +Prod$
		Let ReturnStatus=0
		Exit Sub
	Endif
	If SQTY<0 and (SHQTY>0 or BOQTY>0)
		Let E$="INVALID QUANTITY ENTERED -/+ " ! +Prod$
		Let ReturnStatus=0
		Exit Sub
	Endif
	! set up rol. vars for ease of use
	
	! now get whse
	Let kpw$=" ",kpw$;e=0
	kpw$=prod$+roh.Wh Using "##"
	if roh.ordtype=7 let kpw$=prod$+roh.ConsWh Using "##"
	If Not(NonStk)
	 rol.ComdtyCode$=pr.ComdtyCode$+Blank$
	 if roh.ordtype=8 or roh.ordtype=16 ! see if to whse exists
	   If Roh.ConsWh>0 and roh.conswh<100
		Let TPWKey$=" ",tpwKey$
		TPWkey$[1,12]=prod$[1,12]+Blank$
		TPWKey$[13]=ROH.ConsWh Using "##"
		call chktowhse(TPWKey$,pr.PrimVend)
	   Endif
	 Endif
	 PWR=filegetprodwhse(e$,PWC,"=",1,KPw$,PW.,e)
	 clear e$
	 if pwr<0 ! NOT FOUND
		clear pw.
		If P61$[59,59]="Y" or (Credit and (roh.ordtype=7 or roh.ordtype=8)) ! not allowed new prodwhse
			Let E$="Product "+Prod$+"Not Available In this Warehouse"
			Let ReturnStatus=0
			if debugdetail
				dmsg$=e$+" Sysflag 61-59,59 Y "+Str$(roh.wh) \ Call updatelog(debug)
			Endif
			Exit Sub
		Endif
		If PWR=-1 ! not found - add now?
			x3=kpw$[13,14] ! header/cons whse
			Whbld[0]=PWC;Whbld[1]=x3;WhBld[2]=pr.PrimVend
			if x3<>1 let Whbld[1]=x3+.01 ! fra=copy whse 1
			Call mxwhcreate(e$,IntCo,PROD$,WHBLD[])
			PWR=Whbld[2];E$=""
			Read record #PWC,PWR,0;PW.;
			if debugdetail
				dmsg$="Build new whse  "+kpw$ \ Call updatelog(debug)
			Endif
		Endif
	 Endif ! of whse not found
	Else ! is nonstk
	 Clear pw.
	 rol.UpdtStk=0 ! can't happen!
	Endif
	! Needs a Prodgroup check (in case single entry!)
	If PW.ProdGrp>0 ! has a group
		Pram[0]=ROH.OrdType !  \ if TScan=2 Let Pram[0]=0-OType
		Pram[1]=PW.ProdGrp
		Pram[5]=0 ! file not opened
		![0]=Order or (-)PO Type
		! [1]=Product Group
		! [2]=Allow on Ord/PO (1=y, 0=N)
		! [3]=Update Stock (1=y, 0=N)
		! [4]=On Price List (0/1)
		! [5]=Channel of 2/ProdGrp#
		Call ProdGroup(e$,intco,Pram[])
		! !!!! ---- add override prod group functionality --- not longer need to check if allow for order type#34276
		!!! NEED TO REM LINES OUT FOR 34276 --- CHECK IN FOR RELEASE MODS
		If Pram[2]=0  ! not allowed on OType
			E$="Product "+Prod$+"Not Allowed on this Order Type!"
			returnstatus=0
			if debugdetail
				dmsg$=E$+" OT "+Str$(ROH.OrdType)+" PG "+Str$(PW.ProdGrp) \ Call updatelog(debug)
			Endif
			Exit Sub
		Endif
		rol.UpdtStk=Pram[3] ! update Stock
	Endif
	If not(nonStk) and not(credit) ! now a restricted item check
		! set up 
		clear x[]
		clear s9[]
		clear pram[]
		x[1]=PRC;X[2]=CUC ! prod,cust chan
		S9[1]=prr;s9[2]=CUR ! prod,cust records
		pram[2]=roh.wh ! whse to check
		if roh.ordtype=7 let pram[2]=roh.ConsWh ! use consignment?
		Clear tmp2$
		call chkrprod(e$,intco,X[],S9[],PRAM[],Tmp2$)
		if pram[0]=0  ! 0=restrict, <>0=ok
			e$=tmp2$;returnstatus=0
			if debugdetail
				dmsg$=E$ \ Call updatelog(debug)
			Endif
			exit sub
		Endif
	Endif
	Call SetNewRol() ! use std routine to define rol vars
	! remainder = get prices,costs,tax, rbt/sp, wh/ttl avail, last price info, future cost
	if rol.ComdtyCode$="" or rol.ComdtyCode$=Blank$[1,4]
		If Not(NonStk) Let rol.ComdtyCode$=pr.ComdtyCode$
	Endif
	if not(nonStk) and not(credit) and rol.UpdtStk=0 ! is it mill? do check NOW
		milf=getmillflg(e$,intco,PWC,prod$,rol.Whse,roh.ordtype)
		if milf>0 ! it is - back order all per dd
			let rol.qtybo=rol.qtyship
			let rol.qtyship=0
		endif
	endif
	if MSHQty or MBOQty ! entered something manually (and setnewrol defaults to Ordqty)
		let rol.QtyShip=MSHQty ! as entered (override calc)
		let rol.QtyBO=MBOQty ! as entered
	Endif
	rol.UMSell=SUM ! just in case
	rol.AltSupsd=afrm ! where added-0=normal,1=alt,2=supersede
	rol.OrgProdCode$=blank$
	if afrm let rol.OrgProdCode$=OrgProd$+blank$
	
	! as call prodgroup changes updtstk flag - redo it
	IF CREDIT<>0
		if roh.ShipType=3 LET rol.UpdtStk=0
		if roh.ShipType=7 LET rol.UpdtStk=0
		if roh.shiptype=2 ! defective return
			if p61$[131,131]="N" let rol.UpdtStk=0
			if p61$[131,131]="Y" and not(nonstk) let rol.UpdtStk=1
			! check comm code below 
		endif
	endif
	IF roh.OrdType=16 and ROH.XferAuth=0 let rol.UpdtStk=0 ! whxfer not auth
	if roh.ordtype=15 or roh.ordtype=4 let Cust.BoSAllowedFlag=1 ! will always allow bo's
	IF roh.ordtype=2 or roh.ordtype=5 let rol.UpdtStk=0
	if roh.ordtype=3 and p60$[22,22]<>"Y" LET rol.UpdtStk=0 ! indir no stk
	if custom_customer$="OMAHA"
        ! default ord type 38 to update stock=N cct176559/task10467
		if roh.ordtype=38 let rol.updtstk=0 
	endif
	If roh.ordtype=36 
		If Not(Credit) Or (Credit And roh.ShipType=16)
			Let rol.UpdtStk=0 ! "default to "N"
		Endif
	Endif
	tmp$=rol.ComdtyCode$
	if tmp$="LABR" OR tmp$="TIME" OR tmp$="MACH" LET rol.UpdtStk=0 ! comm's no stk
	If NonStk ! can't call price
		rol.NStkItem=1;rol.UpdtStk=0
		! rol.umsell=0
		FutCost=0
		LPR=0;fleptr[4,1]=0
		tmp$=" ",tmp$;tmp$=Pr.ComdtyCode$+Blank$;tmp$[5]=""
		CMR=filegetcommhead(e$,CMC,"=",1,tmp$,cmc.)
		clear e$
		Goto NSBypass
	Endif
	let HasLPflag=GetAskLP() ! also gets lpr & clp.
	asklpflag=0 ! only used later
	if HaSLPflag=1 let LPR=-1 ! double sure (1=NO LP)
	! task 36848 - make price call with correct(or changed) UM's!
	! sys flag p61$[12,12] (set OE UM = LP UM)
	If P61$[12,12]="Y" and LPR>0 AND PR.CatchwgtItem$<>"Y"
		IF clp.UMSell LET rol.UMSell=clp.UMSell  ! ;SUM=clp.UMSell
		IF clp.UMPrice LET rol.UMPrice=clp.UMPrice
		IF clp.UMCost LET rol.UMCost=clp.UMCost
	Endif
	! sys flag p60$[30,30] = price um = sell um (UN[1]=UN[0])
	If P60$[30,30]="Y" and PR.CatchwgtItem$<>"Y"
		let rol.UMPrice=rol.UMSell
	Endif
	! sys flag p61$[61,61] = cost um = price um
	If P61$[61,61]="Y" Let rol.UMCost=rol.UMPrice
	! and now set specs
	Call SetupSpecs()
	! the above matches a mx299 call (no price/cost/etc
	Call getprice()
	! parse out returned data
	if Specs[0]=0 ! no error - process away
		rol.UpChrg=Specs[16]
		rol.UnitCost=Specs[17]
		rol.LineCost2=Specs[18]
		rol.UnitPrice=Specs[20]
		rol.LineDisc=Specs[21]
		rol.LineDiscPct=Specs[22]
		rol.NetPrice=Specs[23]
		rol.RebtContract=Specs[24]
		rol.PriceOrigin=Specs[25]
		rol.CostOrigin=Specs[26]
		rol.Contract=Specs[27]
		rol.SpCommPct=Specs[28]
		rol.BrkLvl=Specs[29]
		rol.LoadUpchrg=Specs[40]
        ! check to see if the price call changed the price or cost unit 
		IF SPECS[14]<>rol.UMPrice ! "price unit changed     
		  let rol.UMPrice=specs[14]
		REM    PUM$=xunit$(ROL.UMPrice,ccc) ! u/m
		ENDIF                                                              
		IF SPECS[15]<>rol.UMCost ! "cost unit changed   
			let rol.UMCost=SPECS[15]
		rem 	CUM$=xunit$(ROL.UMCost,ccc) ! u/m
		ENDIF                        
		! if CPI and this price was the result of a CPI
		! price - make sure we are not overselling the contract
		if p61$[116,116]="Y" and roh.ordtype=2 and rol.unitcost=0 and rol.unitglcost<>0
		    !! mtg
			let ltbl=0
			if p9$[32,32]="Y" and pw.load1muptbl>0
				let ltbl=pw.Load1MupTbl
			endif
			if not(ltbl)
				if pr.load1muptbl>=0 
					let ltbl=pr.Load1MupTbl
				endif
			endif
			if not(ltbl)
				Read #1,182,4;nsltbl;
				if nsltbl>0 let ltbl=nsltbl
			endif		
			if ltbl>0
				LET PREC[0]=prr ! product record #    
				if pr.lbsfact<=0 let pr.lbsfact=1
				leT PREC[2]=FNR(ABS((ROL.LbsUnit*ROL.QtyOrd)/pr.LbsFact)) ! ext weight of line (ordered)  
				IF ROL.LbsUnit<>0 AND ROL.LbsUnit<>pr.lbsunit! line lbs different from prod file lbs         
					LET PREC[3]=ROL.LbsUnit                                                      
				ELSE                                                                     
					LET PREC[3]=0                                                          
				ENDIF                                                                    
				LET CNVTA=rol.unitglcost ! use g/l cost                             
				LET SCR=-roh.ordtype ! negative otyp means force the base cost  
				let wh=roL.whse
				CALL "MXLOAD5.DL4",SCR,WH,LTBL,PREC[],CNVTA,IntCo,e$,rstr$                               
				let rol.unitcost=cnvta 
			endif		
		endif
		onCPI = 0
		if p61$[111,111] = "Y" and not(credit) and rol.Contract and FLEPTR[15,1]
			if roh.OrdType = 2 or roh.OrdType = 8 and roh.OrdType = 16 goto skipCPI1
			if not(rol.UpdtStk) goto skipCPI1
			onCPI = 1
			recCPI = FLEPTR[15,1]
			read record #splc,fleptr[5,1],0;SD.;
			read record #CPIDC,recCPI,0;CPID.;
			leftOnCPI = CPIQtyAvail(e$,cpid.ContractNumber,cpid.ProductID$,dummy,cpiChan[])
			if e$ = "" ! no errors
				if leftOnCPI < rol.QtyShip + rol.QtyBO
					! okay, convert qty back to SELL U/M
					let cnvtu[0]=0;cnvtu[1]=SUM;cnvtu[2]=1
					let cnvta=leftOnCPI
					Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
					e$ = " Only "+str$(Amount)+" left on CPI contract: "+str$(rol.Contract)+".  Ship + BO quantity cannot exceed!"
					returnstatus=0
					Exit sub
				end if
			end if
			skipCPI1: ! skip allocation
		end if
	Endif
	! needs UM check after price call
	Let LPR=fleptr[4,1] ! sent last price record
	If LPR>0
		Read record #LPC,LPR,0;clp.;
		if custom_customer$="SWP"
			if MSGDESC$[1,9]="Permanent"
				if Clp.Umprice<>rol.umprice
					rol.umprice=Clp.UMPrice
					rol.PriceFactor = UMtoFactor(rol.umprice) 
				endif
			endif
		endif
	Else
		! Cust flag a$[138,138] = auth buy list (only if on lastprice file!)
		If cust.AuthBuyList$="Y"
			E$="Product "+Prod$+"Not on the Buy List!"
			if debugdetail
				dmsg$=E$+" "+rol.prodcode$ \ Call updatelog(debug)
			Endif
			Exit Sub
		Endif
		
	Endif
	If LPR<=0 and not(rol.NStkItem) ! no lastprice on stkitem
		if P61$[25,25]="P" and not(credit) ! and rol.AltSupsd=0
			if substitm let rol.AltSupsd=Int(rol.AltSupsd)+.1
		Endif
	Endif ! prompt if not in lastprice and prod
	! sys flag p61$[12,12] (set OE UM = LP UM)
	If P61$[12,12]="Y" and LPR>0 AND PR.CatchwgtItem$<>"Y"
		IF clp.UMSell LET rol.UMSell=clp.UMSell  ! ;SUM=clp.UMSell
		IF clp.UMPrice LET rol.UMPrice=clp.UMPrice
		IF clp.UMCost LET rol.UMCost=clp.UMCost
	Endif
	! sys flag p60$[30,30] = price um = sell um (UN[1]=UN[0])
	If P60$[30,30]="Y" and PR.CatchwgtItem$<>"Y"
		let rol.UMPrice=rol.UMSell
	Endif
	! sys flag p61$[61,61] = cost um = price um
	If P61$[61,61]="Y" Let rol.UMCost=rol.UMPrice
	If Rol.umsell<>SUM ! UM change - reget base
		! okay, reconvert qty to BASE
		let cnvtu[0]=Rol.umsell;cnvtu[1]=0;cnvtu[2]=1
		let cnvta=SQty  ! BIG Q: is cutting known at this point??? *****
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		Let rol.QtyOrd=Int(Amount) ! always integer base - just cut it
		let rol.QtyShip=rol.qtyord
		SUM=Rol.UMSell
	Endif
	rol.SellFactor=UMtoFactor(rol.UMSell) ! reget in case changed!
	rol.PriceFactor=UMtoFactor(rol.UMPrice)
	rol.CostFactor=UMtoFactor(rol.UMCost)
	! future cost = cost as of xx days from today (specs[5] chg)
	JDate=TIM(6)+FCDays ! ## days from today
	tmp$=JDate$(jdate) ! from ddddd to MM/DD/YYYY
	tmp1$=Formatdate2$(tmp$) ! now MM/DD/YYYY to YYYYMMDD
	Let FDate=tmp1$[3,8] ! just need yymmdd
	Let Specs[5]=0-FDate
	Call getprice() ! call price w/all entries above
	If Specs[0]=0 ! okay
		Let X3=Specs[17]
		cnvtu[0]=0;cnvtu[1]=rol.UMCost;cnvtu[2]=2
		Cnvta=X3 \ if rol.numout>0 let cnvta=x3/rol.numout
		FutCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	Endif
	! quick avail check! If we're here - it's not cutting
	x2[9]=rol.whse \ if roh.ordtype=7 let x2[9]=roh.ConsWh
	If RTrim$(rol.ProdCode$)<>""
		X3[1]=getwhavail(e$,intco,PWC,rol.ProdCode$,X2[9])
	Else
		x3[1]=0 
	Endif
	! note was dnr AND - causes issue - change to IF
	if not(credit) ! credits not DNR check
	 if pw.DNReordFlg=1 If ((ROL.UpdtStk and x3[1]<=0) or (Not(ROL.UpdtStk))) ! dnr and no avail
		E$="Product "+Prod$+"is a Do Not Reorder!"
		if debugdetail
			dmsg$=E$+" DNR "+Str$(pw.DNReordFlg)+" AVL "+Str$(x3[1]) \ Call updatelog(debug)
		Endif
		Exit Sub
	 Endif
	Endif ! credit no dnr chk
	kit=0
	If not(nonstk) ! wait for complete to write zline/nonstk
	 IF P9$[2,2]="D" AND P9$[20,20]<>"F" AND pr.MBFlg$="M" 
		IF P9$[22,22]="Y" AND NOT(CREDIT)
			if rol.LineType=0 and rol.qtyship>0 ! only stock items
				LET KIT=1
			Endif
		Endif
	 ENDIF
	Endif
	x=0 \ if p60$[27,27]="S" let x=1
	if p60$[27,27]="B" let x=2
	if p60$[27,27]="E" let x=3
	if kit let x=0 ! will build it
	IF P9$[2,2]="M" AND pr.MBFlg$="M" let X=0 ! will build/make it
	if maxcnt<0 let x=0 ! no check - use what's sent
	if Not(credit) and X>0 ! has bochk set
	 If rol.QtyOrd>0 and ROL.UpdtStk and rol.QtyOrd>X3[1] ! order > whavail
	  if x3[1]>0 ! has some avail
		Let rol.QtyShip=X3[1] ! take it all
		Let rol.QtyBO=rol.QtyOrd-rol.QtyShip
	  Else ! zero or <0 avail
		Let rol.QtyShip=0
		Let rol.QtyBO=rol.QtyOrd ! all backordered
	  Endif
	 Endif ! of updt and ord>avail
	Endif
	! added 2/28 - convert shipped/bo to sell 2 dec - 2316
	if rol.qtyship<>0
		cnvtu[0]=0;cnvtu[1]=rol.UMSell;cnvtu[2]=1
		cnvta=rol.qtyship
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		tmp$=LTrim$(amount using "----------#.##")
		amount=tmp$ ! now 2 decimals only
		If SWUO ! whole sell units only flag
			let amount=Int(amount) ! just cut decimals off
		Endif
		cnvtu[0]=rol.UMSell;cnvtu[1]=0;cnvtu[2]=1
		cnvta=amount ! convert back to base
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if amount<>rol.qtyship ! it changed
			rol.qtyship=amount
			if rol.qtyship>x3[1] let rol.qtyship=x3[1] ! no overship!
			Let rol.QtyBO=rol.QtyOrd-rol.QtyShip
		Endif
	Endif ! of recalc qty ship based on 2 dec
	NSBypass: ! can't get price avail etc for non-stk
	if MSHQty or MBOQty ! manually entered this - keep it?
		let rol.QtyShip=MSHQty ! as entered (override calc)
		let rol.QtyBO=MBOQty ! as entered
	Endif
	if roh.ordtype=15 let rol.qtyship=0;rol.qtybo=0 ! starts as zero
	if Cust.BoSAllowedFlag=0 Let rol.QtyBO=0 ! no bo's allowed
	if pw.DNReordFlg=1 and rol.qtybo let rol.qtybo=0 ! no bo
	if roh.ordtype=4 let rol.qtybo=0 ! no bo on ot4 - 32160?
	GNPDDone: ! go here for zline / nonstk (DO NOT CREATE LINE!)
	! we need to make sure base is correct for display
	cnvtu[0]=0;cnvtu[1]=rol.umprice;cnvtu[2]=2 ! base to display
	cnvta=rol.UnitPrice
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	cnvtu[0]=rol.umprice;cnvtu[1]=0;cnvtu[2]=6 ! display back to base
	cnvta=amount
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	rol.unitprice=amount ! done unit price
	cnvtu[0]=0;cnvtu[1]=rol.umprice;cnvtu[2]=2 ! base to display
	cnvta=rol.NetPrice
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	cnvtu[0]=rol.umprice;cnvtu[1]=0;cnvtu[2]=6 ! display back to base
	cnvta=amount
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	rol.NetPrice=amount ! done net price
	cnvtu[0]=0;cnvtu[1]=rol.UMCost;cnvtu[2]=2 ! base to display
	cnvta=rol.UnitCost
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	cnvtu[0]=rol.UMCost;cnvtu[1]=0;cnvtu[2]=6 ! display back to base
	cnvta=amount
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	rol.UnitCost=amount ! done unit cost
	Let elflag=0 ! NOT an existing line
	! won't be cut or LOT Price here?
	! ADDED - Create line NOW! (unless maxcnt<0)
	! clear / set up misc fields
	IF rol.UMCutCost=-3 AND rol.QtyOrd LET CHBASE=(rol.CutCost/rol.QtyOrd) ELSE  LET CHBASE=rol.CutCost
	X3[4]=rol.UnitCost+CHBase
	X3[3]=X3[4]
	IF rol.LoadUpchrg ! has cost up
		IF rol.LoadUpchrg<0 ! $ amount
			X3[3]=X3[4]+Abs(rol.LoadUpchrg)
		Else ! percent
			X3[3]=X3[4]+(X3[4]*(rol.LoadUpchrg/100))
		Endif
	Endif
	NetCost=X3[3]
	cnvtu[0]=0;cnvtu[1]=rol.UMCost;cnvtu[2]=2 ! base to display
	cnvta=NetCost
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	cnvtu[0]=rol.UMCost;cnvtu[1]=0;cnvtu[2]=6 ! display back to base
	cnvta=amount
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	NetCost=amount ! done net cost
	If roh.OrdType=37  ! "EVAP Ship - NO Price - any order in here
		If Not(Credit) Or (Credit And roh.ShipType=16)
			Let rol.UnitPrice=0;rol.NetPrice=0;rol.CutChrg=0
			Let rol.LineDisc=0;rol.LineDiscPct=0;rol.UpChrg=0
		Endif
	Endif
	If roh.OrdType=36 ! "EVAP Billing - NO Cost - Any type order
		If Not(Credit) Or (Credit And roh.ShipType=16)
			Let rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
			Let rol.CutCost=0;rol.ExtCutCost=0;rol.ExtLoadShip=0;rol.ExtLoadOrd=0
			rol.LoadUpchrg=0;NetCost=0
		ENDIF
	Endif
	!let rot.mdseordamt=rot.mdseordamt-rol.extordamt
	!let rot.totordcost=rot.totordcost-rol.extloadord
	LET rol.ExtOrdAmt=FNR(rol.QtyOrd*Rol.NetPrice)
	LET rol.ExtLoadOrd=FNR(rol.QtyOrd*NETCOST)
	!let rot.mdseordamt=rot.mdseordamt+rol.extordamt
	!let rot.totordcost=rot.totordcost+rol.extloadord
	IF roh.ordtype=4 OR roh.ordtype=15 ! "bill and hold
	  IF roh.ordtype=15 
		if roh.BOCTR=0 let rol.CurrBillQty=rol.QtyOrd Else let rol.CurrBillQty=0
	  Endif
	  IF roh.ordtype=4 let rol.CurrRelQty=rol.QtyShip
	  If roh.ordtype=4 and custom_Customer$="MORRISETTE" let rol.CurrBillQty=rol.Qtyship
	  LET rol.ExtShipAmt=FNR(rol.CurrBillQty*Rol.NetPrice)
	  LET rol.ExtLoadShip=FNR(rol.CurrBillQty*NETCOST)
	ELSE
	  LET rol.ExtShipAmt=FNR(rol.QtyShip*Rol.NetPrice)
	  LET rol.ExtLoadShip=FNR(rol.QtyShip*NETCOST)
	ENDIF
	IF rol.UMPrice=-2 ! lot
	  LET rol.ExtOrdAmt=FNR(Rol.NetPrice)*SGN(rol.QtyOrd)
	  IF roh.ordtype=4 OR roh.ordtype=15
		LET rol.ExtShipAmt=FNR(SGN(rol.CurrBillQty)*Rol.NetPrice)
	  ELSE
		LET rol.ExtShipAmt=FNR(Rol.NetPrice)*SGN(rol.QtyShip)
	  ENDIF
	ENDIF
	IF rol.UMCost=-2 ! LOT
	  LET rol.ExtLoadOrd=FNR(NETCOST*SGN(rol.QtyOrd))
	  IF roh.ordtype=4 OR roh.ordtype=15
        LET rol.ExtLoadShip=FNR(NETCOST*SGN(rol.CurrBillQty))
	  ELSE
		LET rol.ExtLoadShip=FNR(NETCOST*SGN(rol.QtyShip))
	  ENDIF
	ENDIF
	if rol.WgtFactor<=0 let rol.WgtFactor=1
	rol.ExtNetWgt=FNR(Abs((rol.QtyShip*rol.LbsUnit)/rol.WgtFactor))
	rol.Status=11 \ if credit let rol.Status=12
	rol.KitDesignation$=blank$
	ROL.MWgt=rol.LbsUnit
	rol.RepairLine$=blank$
	rol.HldForPo$=blank$
	rol.SpareNU1$=blank$
	rol.AwmDeal$=blank$
	!rol.SpareNU$ = Blank$;X0=LEN(rol.SpareNU$)
	!		IF X0>1
	!			rol.SpareNU$[X0-1] = ""  ! for the key
	!		ENDIF
	clear rol.SpareNU$ ! for dl4
	if debugdetail
		dmsg$="New Line Setup "+Str$(Orderno)+" - "+rol.prodcode$ \ Call updatelog(debug)
	Endif
	! special processing here!!!
	if roh.OrdType=8 or roh.OrdType=16 ! cons/trans - no price/cost
		rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
		rol.UnitPrice=0;rol.CutChrg=0;rol.CutCost=0
		rol.LineDisc=0;rol.ExtOrdAmt=0;rol.ExtShipAmt=0
		rol.LineDiscPct=0;rol.ExtCutChg=0;rol.ExtCutCost=0
		rol.ExtLoadShip=0;rol.ExtLoadOrd=0;rol.NetPrice=0
		rol.TaxAmt=0;rol.LoadUpchrg=0;rol.UpChrg=0
	Endif
	If p61$[46,46]="Y" and Credit and roh.shiptype=3 ! price fix - no cost
		rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
		rol.CutCost=0;rol.ExtCutCost=0;rol.ExtLoadShip=0;rol.ExtLoadOrd=0
		rol.LoadUpchrg=0
	Endif
	!if roh.ordtype=15
	!	if roh.BOCTR=0 let rol.CurrBillQty=rol.QtyOrd Else let rol.CurrBillQty=0
	!	rol.ExtShipAmt=FNR(rol.CurrBillQty*rol.NetPrice) ! ext price
	!	rol.ExtLoadShip=FNR(rol.CurrBillQty*X3[3]) ! ext net cost
	!Endif
	If not(nonstk) ! wait for complete to write zline/nonstk
	 IF P9$[2,2]="D" AND P9$[20,20]<>"F" AND pr.MBFlg$="M" 
		IF P9$[22,22]="Y" AND NOT(CREDIT)
			if rol.LineType=0 and rol.qtyship>=0 ! only stock items
				LET rol.KitDesignation$="KIT"
			Endif
		Endif
	 ENDIF
	 if rol.OrgPriceUnit<=0 let rol.OrgPriceUnit=ROL.UnitPrice ! save on entry?
	 if rol.OrgLoadCost<=0 let rol.OrgLoadCost=rol.UnitCost ! as PM does it
	 rol.PDRecNum=PRR
	 rol.SpareNU3$=blank$
	 if maxcnt<0 exit sub ! DON'T CREATE A LINE FLAG!!
	 clear rol.SpareNu$ ! dl4 fix
	 X2=GetNxtLine(orderno) ! GET NEXT LINE# 
	 rol.linenum=x2;E=0;olr=0
	 OLR=fileupdaterolz(e$,OLC,"a",e,rol.)
	 clear e$
	 If Not(nonstk) and rol.UpdtStk and OLR>0
		if debugdetail
			dmsg$="New Line Added "+Str$(Orderno)+"-"+Str$(rol.Linenum) \ Call updatelog(debug)
		Endif
		if Not(Credit) and rol.UpdtStk ! add NEW qty ord to prod & whse
			tmp$=ShipDate Using "&&&&&&"
			Call DateToJulian(1,tmp$,tmp1$,F)
			IF F let tmp1$=""
			JDate[1]=tmp1$;F=0 ! julian sys shipdate
			tmp$=roh.ShipDate Using "&&&&&&"
			if roh.ShipDate<>999999 Call DateToJulian(1,tmp$,tmp1$,F)
			If f let tmp1$=""
			JDate[2]=tmp1$ ! julian ord shipdate
			Read record #PRC,PRR,0;PR.
			If PWR>0 Read Record #PWC,PWR,0;pw.
			X3=ROL.QtyShip ! as mxline does it
			if roh.OrdType=15 or roh.OrdType=19 let x3=rol.QtyOrd-rol.PrevQtyShip-rol.QtyBO
			if custom_customer$="MORRISETTE"
				If roh.OrdType=4 Let x3=ROL.QtyShip ! "cct 129415 - only commit shipping qty
			Endif
			IF roh.OrdType=15 AND roh.BOCTR<>0 LET x3=0        
			IF roh.OrdType=15 AND roh.BOCTR=0 LET x3=rol.QtyOrd
			if x3>0 
				pr.QtyOnOrd=pr.QtyOnOrd+X3
				pw.QtyOnOrd=pw.QtyOnOrd+x3
				if onCPI
					cpid.QuantityAllocated=cpid.QuantityAllocated+x3
					write record #CPIDC,recCPI,0;CPID.;
				end if
				IF JDATE[1]>=JDATE[2]
					LET pr.Lvl1Qty=pr.Lvl1Qty+x3
					Let pw.Lvl1Qty=pw.Lvl1Qty+x3
				ELSE
					LET pr.Lvl2Qty=pr.Lvl2Qty+x3
					Let pw.Lvl2Qty=pw.Lvl2Qty+x3
				Endif
				if pr.CatchwgtItem$="Y"
					X=1 \ if rol.QtyOrd<0 let x=-1 ! neg ord/ship (wgt always +)
					IF roh.OrdType=15 AND roh.BOCTR<>0 LET x=0 ! NO QTY
					pr.LbsOnOrder=pr.LbsOnOrder+(rol.ExtNetWgt*x)
					pw.LbsOnOrder=pw.LbsOnOrder+(rol.ExtNetWgt*x)
				Endif
			endif
			Write Record #PRC,PRR,0;PR.;
			if sqlChan >= 0 ! MySQL enabled and channel opened
				call prod_DL4SQLConvert(e$,"FROMDL4",PR.,sql_prod.,PRR)
				e = prod_SQLAddUpdate(e$,sqlChan,sql_prod.) ! mode="a" or "c"
				if e <> 1 ! returns the number of records add/updated/deleted
					error 11000
				end if
			end if
			If PWR>0 Write Record #PWC,PWR,0;pw.;
		Endif ! write on order to prod/whse
		! do allocate to none/stock location now! unless rasl & invoice or status>1
		Call ChkWhRasl(e$,intco,Ctlc,WHI,rol.Whse,RASL[])
		if rasl=0 ! or credit ! or not(invoice)
			Atype=0 \ if credit let Atype=1
			FChan[0]=OHC;FChan[1]=OLC;FChan[2]=SLTC;FChan[3]=PLTC
			FRec[0]=OHR;FRec[1]=OLR
			call Allocordlot(e$,intCo,AType,FChan[],FRec[],Rasl,Status)
			if roh.ordtype=8 or roh.ordtype=16 ! needs the "to" whse set (just in case)
				Clear FChan[]
				fchan[0]=PRC;fchan[1]=OHC;fchan[2]=OLC
				fchan[3]=SLTC;fchan[4]=PLTC
				clear FREC[]
				FRec[2]=OHR \ if credit let FRec[3]=4
				call "mx201lcon5.dl4",intco,Ctlc,FRec[],FCHAN[] ! do to whse
			Endif
		Else ! is rasl let rasl decide (even for credits!?)
			S9[2]=OHR;S9[3]=0;S9[4]=source ! determine program #?
			If credit let S9[3]=4;S9[4]=243 ! credit
			if source=2082 let s9[4]=208 ! ord edit
			if s9[4]<=0 let s9[4]=208 ! send something!
			S9[12]=OLR ! PASS THE LINE JUST UPDATED (new single line mxrasl5)?
			FChan[0]=1;FChan[1]=PRC;FCHan[2]=OHC;FChan[3]=OLC
			FChan[4]=0;FChan[5]=ccc;FChan[6]=PLTC;FChan[7]=0
			FChan[8]=SLTC;FChan[9]=0
			! Call dxsave(0,"/tmp/jcs.txt!")
			Call "MXRASL5.DL4",intco,Ctlc,S9[],FChan[]
		Endif
		if debugdetail
			dmsg$="New Line Allocated " \ Call updatelog(debug)
		Endif
		
	 Endif ! of stk update
	 Elflag=1 ! not new anymore
	Else ! do nonstk update (no zline on erp!)
      If not(ZLine)
		 X2=GetNxtLine(orderno) ! GET NEXT LINE# 
		 rol.linenum=x2;E=0;olr=0
		 nstk.LineNum=x2
		 rol.ProdCode$ = roh.OrdNum Using "######"                      
		 rol.ProdCode$ = rol.ProdCode$ + "-" + rol.LineNum Using "&&&"
		 rol.ProdCode$ = rol.ProdCode$ + Blank$                        
		 nstk.ProdCode$ = rol.ProdCode$ 
		 rol.SpareNU3$=blank$
		 clear rol.SpareNu$ ! dl4 fix
		 OLR=fileupdaterolz(e$,OLC,"a",e,rol.) 
		 clear e$
		 If OLR > 0 ! has to have a record!                           
				nstk.OrdLineRec = OLR  
				If CREDIT Let x = -1 Else Let x = 1 
				nstk.QtyShip=rol.QtyShip*x
				nstk.ExtShipAmt = (rol.ExtShipAmt * x) ! store credits as neg
				clear nstk.Spare$ ! dl4 fix
				nstk.SpareNu$=blank$ ! make sure has space for key! 
				nsr = fileupdatesproddesc(e$,nsc,"a",0,nstk.) 
				clear e$
				If nsr > 0                                                    
					 rol.PDRecNum = nsr
				Else                                                          
					 e$ = "NONSTOCK " + rol.ProdCode$ + " FILE NOT ADDED"
					 NSR=0 ! neg is no good in file
				End If
				rol.PDRecNum=NSR
				Write Record #olc,olr,0;rol.; 
				If NSR>0 and OLR>0 and not(credit) ! new nonstk line - send alert
					clear x2[]
					clear x3[]
					tmp$=""
					x2[1]=ctlc;x2[2]=OLC;x2[4]=OHC;X2[5]=OSC;X2[6]=OTC;x2[7]=CCC
					x2[8]=CUC ! x2[]=file channels
					X3[0]=21;x3[1]=nstk.Buyer;x3[2]=OLR;x3[3]=OHR
					x3[4]=SQty;x3[5]=BOQty;x3[6]=SHQty ! qty: ord,bo,ship (as entered)
					! x3=vars 0=alert,1=buyer,2=ordline,3=ordhead
					call "libalertproc.lib",x3[],x2[],tmp$
				Endif
		 Else
			e$="Nonstock Line not added for "+rol.prodcode$
		 End If  
		 elflag=1 ! NOT NEW
	  Endif ! no zline  
	 
	Endif ! of add stock/nstk line NOW
	If P60$[44,44]="Y" AND olr>0
		clear etr.
		etr.EtAction=11 ! send action
		call EdttrkDO(nrol.,rol.) ! org,new
		if debugdetail
			dmsg$="Line Edittrack " \ Call updatelog(debug)
		Endif
	Endif ! of edit tracking
	Call LineMainDtl() ! generate/write list$ 
	! call programdump("/tmp/ollog1!","")
 else
    include "src/callsuberr.inc"
  end try
end sub ! GetNewProdDtl
! 
!--------------------------------------------------------------------
Sub GetPrice()
! finish price setup & call it
 Try
	dim 1%,dbg,dlog$[50],3%
	!let Debug=0 ! no, 1=yes
	!let Dlog$="/usr/dxport/files/6/dx.log" ! whence the debug log
	!If debugdetail let debug=1;dlog$=dblog$ ! set to this program
	!CALL "price.dl4",FLEPTR[],SPECS[],MSGDESC$,intco,debug,dlog$
	Let dbg=debug;dlog$=dblog$ ! pass what this program uses
	Call SysPriceCalc(e$,FLEPTR[],SPECS[],MSGDESC$,dbg,dlog$)
	e$=""
	if debugdetail
		!debug=1 ! reset
		dmsg$="PRICE CALLED "+Str$(SPECS[0]) \ Call updatelog(debug)
	Endif

	!
 else
    include "src/callsuberr.inc"
  end try
end sub ! GetPrice
! 
!--------------------------------------------------------------------
Sub Factorum(tmp$)
! from sent factor (in tmp$) - get um text for it
! if no match - send factor back as um
 Try
	dim um$[4]
	dim 1%,umrec
	dim 3%,factor
	let factor=tmp$
	if factor<=0 let factor=1
	umrec=0
	if factor=pr.UM2Fact let umrec=PR.UM2
	if factor=pr.UM3Fact let umrec=PR.UM3
	if factor=pr.UM4Fact let umrec=PR.UM4
	if factor=pr.UM5Fact let umrec=PR.UM5
	if factor=pr.UM6Fact let umrec=PR.UM6
	if factor=pr.UM7Fact let umrec=PR.UM7
	if factor=pr.UM8Fact let umrec=PR.UM8
	If factor=1 let umrec=pr.BaseUM
	if umrec>0 and umrec<chf(ccc) ! -1
		Read record #ccc,umrec,0;UMC.;
		let tmp$=umc.Code$ ! send back um attached
	Else
		if factor=1000 ! hardcode an "M"?
			tmp$="M" ! why not
		Else
			Let tmp$=Str$(Factor) ! send back w/no um (factor instead of um)
		Endif
	Endif
	if debugdetail
		dmsg$="Factor to UM" \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
  end try
end sub ! Factorum
! 
!--------------------------------------------------------------------
Sub WhseList(e$,List$[],maxcnt,ReturnStatus,Message$)
! this is determined by system flag P61$[59,59]
! if =Y - ONLY WHSE THAT CURRENTLY EXIST
! if =N - any valid whse
! DON'T KNOW CURRENT HEADER OR LINE WHSE!!?
 Try
	Dim PWK$[60],Secname$[40]
	Dim 1%,Whse
	dim 2%,tmpcnt
	Dim 3%,PWR,WHIR
	Let ReturnStatus=1
	Message$="OK"
	Clear List$[]
	tmpcnt=maxcnt
	Secname$="WHSELIST" ! specify section name
	If P61$[59,59]="Y" ! only currently used whses for product
		List$[0]=bsdel$,Secname$,fdel$
		List$[1]="ID",fdel$,"WhName",fdel$ ! use same names as droplist
		row=2
		Pwk$=" ",Pwk$
		Pwk$=Prod$
		Do
			PWR=filegetprodwhse(e$,PWC,">",1,PWK$,PW.)
			clear e$
			If PWK$[1,12]<>Prod$ Let PWR=-2
			If PWR<0 Exit do
			Whse=PWK$[13,14]
			If Whse<1 or Whse>99 Exit do
			WHIR=Whse-1
			Read record #WHI,WHIR,0;WHI.;
			tmp$=RTrim$(WHI.WhName$)
			If tmp$<>"" ! whse defined
				List$[row]=Str$(Whse),fdel$,tmp$,fdel$
				row=row+1
				If row>tmpcnt let tmpcnt=expandarray(e$,List$[])
			Endif
		Loop
		List$[row]=esdel$ ! all done
	Else ! list all
		!Call filedroplistwhinfoz(e$,list$[],tmpcnt,WHI,Secname$) ! not correct - do manually
		List$[0]=bsdel$,Secname$,fdel$
		List$[1]="ID",fdel$,"WhName",fdel$
		row=2
		maxwhse=CHF(WHI)-1 \ if maxwhse>98 let maxwhse=98
		For I=0 to maxwhse ! CHF(WHC)-1 (99 is the ALLWHSE record)
			read record #WHI,I,0;whi.;
			if rtrim$(whi.WhName$)<>"" !indicates active record in non-indexed file
				WebStr$=Str$(I+1),fdel$,rtrim$(whi.WhName$),fdel$
				List$[row]=webstr$
				row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
			Endif
		Next I
		List$[row]=esdel$
		! returns with bsdel$,esdel$
	Endif
	if debugdetail
		dmsg$="Whse List sent p61-59,59 "+p61$[59,59]+" "+prod$ \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
  end try
end sub ! WhseList
! 
!--------------------------------------------------------------------
Sub RePrice()
! user wants complete price/cost get
! NEEDS LINE DATA - CUTTING
 Try
	Dim KPR$[60],KPW$[60],kcm$[40],k1$[50]
	Dim SUM$[4],PUM$[4],CUM$[4]
	Dim 1%,Cnvtu[2],Flag,E,X[9],PT[37]
	Dim 2%,X2[9]
	Dim 3%,CNVTA,Amount,x3[9]
	if debugdetail
		dmsg$="Start RePrice" \ Call updatelog(debug)
	Endif
	Call DXGet("PRODID",prod$) \ prod$=UCase$(prod$)
	Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
	ProdKey$=Prod$
	PrR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.) ! product mode=2 dir=1
	clear e$
	If PRR<0
		E$="PRODUCT NOT FOUND"
		ReturnStatus=0
		
	Endif
			!
			! initialize status
	ReturnStatus=1
	Message$="OK"
	If PRR<0 Let ReturnStatus=0
	Call DXGet("ORDERID",tmp$)
	if tmp$="" 
			let e$="ORDER # MISSING"
			Let ReturnStatus=0
			
	Endif
	OrderNo=tmp$
	If OrderNo>0 and OrderNo<999999 and Not(Fra(OrderNo))
		OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
		e$=""
		If OHR<=0 ! no order found
			Let e$="ORDER # NOT FOUND"
			Let ReturnStatus=0
			
		Else
			Call GetCust()
		Endif
	Endif
	Call DXGet("WHSE",tmp$) ! if line whse <> header
	Whse=tmp$ \ if whse<1 or Whse>99 Let Whse=roh.wh
	Call DXGet("UMQTY",tmp$) ! Qty um id
	!If tmp$[1,1]>"9" ! sent text?
		R=getumrec(e$,CCC,tmp$,IntCo,PR.)
		If R<>0 let tmp$=Str$(R)
	!Endif
	SUM=tmp$
	Call DXGet("ORDQTY",tmp$)
	Let OrdQty=tmp$
	If ABS(OrdQty)>9999999999
		e$="Order Quantity out of range"
		returnstatus=0
	Endif
	! check if valid um# sent
	Flag=ChkPrdUM(e$,SUM,IntCo,PR.)
	If Not(Flag)
		Let E$="INVALID QUANTITY U/M"
		Let ReturnStatus=0
		
	Endif
	clear tmp$
	call dxget("QTYOUT",tmp$)
	pnumout=tmp$
	if pnumout<0 or pnumout>999 or fra(pnumout)
		let e$="INVALID QTY OUT"
		let returnstatus=0
	Endif
	clear tmp$ ! added #41670 - send price/cost UM to keep same
	Call DXGet("UMPRICE",tmp$)\ PUM=0 ! Price um id
	If tmp$<>"" ! sent text?
		R=getumrec(e$,CCC,tmp$,IntCo,PR.)
		If R<>0 let tmp$=Str$(R)
		PUM=tmp$
		! check if valid um# sent
		Flag=ChkPrdUM(e$,PUM,IntCo,PR.)
		If Not(Flag)
			Let E$="INVALID PRICE U/M"
			Let ReturnStatus=0
			
		Endif
	endif
	clear tmp$ ! added #41670 - send price/cost UM to keep same
	Call DXGet("UMCOST",tmp$) \ CSUM=0 ! Cost um id
	If tmp$<>"" ! sent text?
		R=getumrec(e$,CCC,tmp$,IntCo,PR.)
		If R<>0 let tmp$=Str$(R)
		CSUM=tmp$
		! check if valid um# sent
		Flag=ChkPrdUM(e$,CSUM,IntCo,PR.)
		If Not(Flag)
			Let E$="INVALID COST U/M"
			Let ReturnStatus=0
			
		Endif
	endif
	If ReturnStatus=0 ! something failed
		Message$=E$
		Goto RPrcDone:
	Endif
	Clear rol. ! we'll use those names
	Clear specs[] ! clear specs vars
	rol.numout=pnumout
	! okay, convert qty to BASE
	let cnvtu[0]=SUM;cnvtu[1]=0;cnvtu[2]=1
	let cnvta=OrdQty \ if pnumout>0 let cnvta=ordqty/pnumout ! CUTTING??
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	Let rol.QtyOrd=Amount
	Let roh.Wh=Whse
	rol.whse=roh.wh
	rol.prodCode$=ProdKey$
	! now get whse
	Let kpw$=" ",kpw$;e=0
	kpw$=rol.ProdCode$+rol.Whse Using "##"
	if roh.ordtype=7 let kpw$=rol.ProdCode$+roh.ConsWh Using "##"
	PWR=filegetprodwhse(e$,PWC,"=",1,KPw$,PW.,e)
	clear e$
	if pwr<0 clear pw.
	if pum ! sent it - make it default
		pr.UMPriceDefault=pum
	endif
	if csum ! sent it - make it default
		pr.UMCostDefault=csum
	endif
	Call SetNewRol() ! set up default line vars
	if pum ! sent price um
		let rol.umprice=pum
	endif
	if csum ! sent cost um
		let rol.umcost=csum
	endif
	! set up SPECS
	Call SetUpSpecs()
	! the above matches a mx299 call (no price/cost/etc
	Call getprice()
	let rol.currid=roh.currid
	if rol.currid>0 and rol.currid<=9999
		let rol.currfact=roh.currfact
	else
		let rol.currid=0
		let rol.currfact=0
	endif
	If Specs[0]=0 ! okay to go
		rol.UpChrg=Specs[16]
		rol.UnitCost=Specs[17]
		rol.LineCost2=Specs[18]
		rol.UnitPrice=Specs[20]
		rol.LineDisc=Specs[21]
		rol.LineDiscPct=Specs[22]
		rol.NetPrice=Specs[23]
		rol.RebtContract=Specs[24]
		rol.PriceOrigin=Specs[25]
		rol.CostOrigin=Specs[26]
		rol.Contract=Specs[27]
		rol.SpCommPct=Specs[28]
		rol.BrkLvl=Specs[29]
		rol.LoadUpchrg=Specs[40]
		IF SPECS[14]<>rol.UMPrice ! "price unit changed     
		  let rol.UMPrice=specs[14]
		  REM  PUM$=xunit$(ROL.UMPrice,ccc) ! u/m
		ENDIF                                                              
		IF SPECS[15]<>rol.UMCost ! "cost unit changed   
			let rol.UMCost=SPECS[15]
		REM	CUM$=xunit$(ROL.UMCost,ccc) ! u/m ok
		ENDIF                
	Endif
	If roh.OrdType=37  ! "EVAP Ship - NO Price - any order in here
		If Not(Credit) Or (Credit And roh.ShipType=16)
			Let rol.UnitPrice=0;rol.NetPrice=0;rol.CutChrg=0
			Let rol.LineDisc=0;rol.LineDiscPct=0;rol.UpChrg=0
			rol.ExtOrdAmt=0;rol.ExtShipAmt=0;rol.ExtCutChg=0
		Endif
	Endif
	If roh.OrdType=36 ! "EVAP Billing - NO Cost - Any type order
		If Not(Credit) Or (Credit And roh.ShipType=16)
			Let rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
			Let rol.CutCost=0;rol.ExtCutCost=0;rol.ExtLoadShip=0;rol.ExtLoadOrd=0
			rol.LoadUpchrg=0;NetCost=0
		ENDIF
	Endif
	List$[0]=bsdel$,"SYSPRICE",fdel$
	WebStr$="Unitprice",fdel$,"PriceUM",fdel$
	WebStr$=WebStr$,"LineDisc%",fdel$,"GP%",fdel$
	WebStr$=WebStr$,"PriceUpchrg",fdel$,"PriceUpType",fdel$
	WebStr$=WebStr$,"NetPrice",fdel$,"UnitCost",fdel$
	WebStr$=WebStr$,"CostUM",fdel$,"CostUpchrg",fdel$
	WebStr$=WebStr$,"CostUpType",fdel$
	webstr$=webstr$,"PRCORGN",fdel$,"CSTORGN",fdel$
	List$[1]=WebStr$
	Row=2
	SUM$=xunit$(ROL.UMSell,ccc) ! u/m
	PUM$=xunit$(ROL.UMPrice,ccc) ! u/m  (Q: what if changed?)
	CUM$=xunit$(ROL.UMCost,ccc) ! u/m   (Q: what if changed/diff?)
	cnvtu[0]=0;cnvtu[1]=rol.UMPrice;cnvtu[2]=2
	Cnvta=rol.UnitPrice \ if rol.umprice>0 and pnumout>0 let cnvta=rol.unitprice/pnumout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	if p61$[136,136]="Y"  and rol.currfact<>0 and x3<>0 ! unit/net price
			let cnvcu[0]=1
			let cnvca[0]=x3
			let cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
	endif
	WebStr$=LTrim$(X3 Using PMask$),fdel$ ! Unit price
	WebStr$=WebStr$,RTrim$(PUM$),fdel$ ! price um
	WebStr$=WebStr$,LTrim$(rol.LineDiscPct Using "###.##"),fdel$ ! line disc % (what of $?)
	X3[3]=rol.UnitCost ! NEED NET COST!!! for gp%
	IF rol.LoadUpchrg ! has cost up
		IF rol.LoadUpchrg<0 ! $ amount
			X3[3]=rol.UnitCost+Abs(rol.LoadUpchrg)
		Else ! percent
			X3[3]=rol.UnitCost+(rol.UnitCost*(rol.LoadUpchrg/100))
		Endif
	Endif
!if ucase$(userid$[1,3])="TXC" stop
	x3=0
	if rol.NetPrice ! NEEDS A PRICE for GP
		X3=FNR(((rol.NetPrice-x3[3])/rol.NetPrice)*100)
	else 
		if x3[3] then let x3=-999999.99

	Endif
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! GP
	! send upcharge as amount & type
	tmp$="%" \ if rol.UpChrg<0 let tmp$="$"
	Let X3=rol.UpChrg
	If tmp$="$" ! need convert to price um
		cnvtu[0]=0;cnvtu[1]=rol.UMPrice;cnvtu[2]=2
		Cnvta=ABS(X3)
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if p61$[136,136]="Y"  and rol.currfact<>0 and x3<>0 ! unit/net price
			let cnvcu[0]=1
			let cnvca[0]=x3
			let cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
	Endif
	WebStr$=WebStr$,Ltrim$(X3 Using PMask$),fdel$,tmp$,fdel$ ! upchrg & type
	cnvtu[0]=0;cnvtu[1]=rol.UMPrice;cnvtu[2]=2
	Cnvta=rol.NetPrice \ if rol.umprice>0 and rol.numout>0 let cnvta=rol.NetPrice/rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	if p61$[136,136]="Y"  and rol.currfact<>0 and x3<>0 ! unit/net price
			let cnvcu[0]=1
			let cnvca[0]=x3
			let cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
	endif
	WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! net price
	cnvtu[0]=0;cnvtu[1]=rol.UMCost;cnvtu[2]=2
	Cnvta=rol.UnitCost \ if rol.UMCost>0 and rol.numout>0 let cnvta=rol.UnitCost/rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	if p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 ! unit/net price
			let cnvcu[0]=1
			let cnvca[0]=x3
			let cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
	endif
	WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! unit cost
	
	WebStr$=WebStr$,RTrim$(CUM$),fdel$ ! Cost um
	! send upcharge as amount & type
	tmp$="%" \ if rol.LoadUpchrg<0 let tmp$="$"
	Let X3=rol.LoadUpchrg
	If tmp$="$" ! need convert to cost um
		cnvtu[0]=0;cnvtu[1]=rol.UMCost;cnvtu[2]=2
		Cnvta=ABS(X3)
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 ! unit/net price
			let cnvcu[0]=1
			let cnvca[0]=x3
			let cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
	Endif
	WebStr$=WebStr$,Ltrim$(X3 Using PMask$),fdel$,tmp$,fdel$ ! upchrg & type
	webstr$=webstr$,Str$(rol.PriceOrigin),fdel$,Str$(rol.CostOrigin),fdel$
	List$[row]=WebStr$
	Row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	List$[row]=esdel$ ! finished
	e$=""
	call AddToStr(e$,rstr$,List$[])
	
	RPrcDone: ! finished
	if debugdetail
		dmsg$="Reprice "+prod$+" "+Str$(Orderno)+" "+message$ \ Call updatelog(debug)
	Endif
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
  else
    include "src/callsuberr.inc"
  end try
end sub ! REprice
! 
!--------------------------------------------------------------------
Sub StkUpList()
! return options for stock update flag
  Try
	Dim KPW$[60]
	Dim 1%,UpdtStk,Pram[5],Whse
	Dim 2%,OType
	Dim 3%

	Call DXGet("PRODID",prod$) \ prod$=UCase$(prod$)
	Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
	ProdKey$=Prod$
	PrR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.) ! product mode=2 dir=1
	clear e$
			!
			! initialize status
	ReturnStatus=1
	Message$="OK"
	If PRR<0 
		Let ReturnStatus=0
		Message$="PRODUCT NOT FOUND"
		Goto SUpDone:
	Endif
	Call DXGet("ORDTYPE",tmp$)
	OType=tmp$
	If OType<1 or OType>38 or Fra(OType)
		ReturnStatus=0
		Message$="INVALID ORDER TYPE!"
		goto SUpDone:
	Endif
	Call DXGet("WHSE",tmp$)
	Whse=tmp$
	If whse<1 or Whse>99 or fra(Whse)
		ReturnStatus=0
		Message$="INVALID WAREHOUSE"
		Goto SUpDone:
	Endif
	Let kpw$=" ",kpw$
	Kpw$=Prod$+Whse Using "##"
	PWR=filegetprodwhse(e$,PWC,"=",1,KPW$,PW.)
	clear e$
	If PWR<0 Clear PW.
	Clear List$[]
	tmpcnt=maxcnt

	List$[0]=bsdel$,"STKUPFLAG",fdel$
	List$[1]="Option",fdel$
	row=2
	! check if normally allowed
	UpdtStk=1 ! yes
	! Needs a Prodgroup check 
	If PW.ProdGrp>0 ! has a group
		Pram[0]=OType !  \ if TScan=2 Let Pram[0]=0-OType
		Pram[1]=PW.ProdGrp
		Pram[5]=0 ! file not opened
		![0]=Order or (-)PO Type
		! [1]=Product Group
		! [2]=Allow on Ord/PO (1=y, 0=N)
		! [3]=Update Stock (1=y, 0=N)
		! [4]=On Price List (0/1)
		! [5]=Channel of 2/ProdGrp#
		Call ProdGroup(e$,intco,Pram[])
		UpdtStk=Pram[3] ! update Stock
	Endif
	X2=OType
	if x2=2 OR X2=5 LET UpdtStk=0 ! not on directs
	if x2=3 and p60$[22,22]<>"Y" LET UpdtStk=0 ! indir no stk 
	tmp$=pr.ComdtyCode$
	if tmp$="LABR" OR tmp$="TIME" OR tmp$="MACH" LET UpdtStk=0 ! comm's no stk
	If UpdtStk=0 ! only answer is N
		WebStr$="N",fdel$
		! IF (don't know line setting) if we did - check if already Y!
	Else ! can have Y and N
		WebStr$="Y",fdel$
		List$[row]=WebStr$
		Row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
		WebStr$="N",fdel$
	Endif
	List$[row]=WebStr$
	Row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	List$[row]=esdel$ ! finished
	e$=""
	call AddToStr(e$,rstr$,List$[])
	SUpDone: ! finito ! finished
	if debugdetail
		dmsg$="Stock Update flag "+prod$+Message$ \ Call updatelog(debug)
	Endif
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)

  else
    include "src/callsuberr.inc"
  end try
end sub ! StkUpList
! 
!--------------------------------------------------------------------
Sub Ordaddldtl()
! send additional data for complete detail of line
! this can handle new / existing lines for stk/nonstk
  Try
	dim PWKey$[60],VendKey$[60],OLKey$[60],k1$[60]
	Dim kcm$[50],sum$[4],Pum$[4],Cum$[4],lpkey$[60]
	dim lppum$[4],lpcum$[4],lpsum$[4]
	dim 1%,cnvtu[2],NonStk,ZLine
	Dim 2%,OrderNo,LineNo,Whse,TaxNo,Dept
	Dim 3%,OLR,CNVTA,Amount,lpr,spr
	Dim vend. as a80vm
	Dim tax. as taxcode
	Dim spcl. as specprice
	dim rbdt. as rebatedtl
	if debugdetail
		dmsg$="Start Additional Details" \ Call updatelog(debug)
	Endif
	ReturnStatus=1
	Message$="OK"
	Call DXGet("DEPT",tmp$)
	Dept=tmp$ ! as it may be diff from header?
	Call DXGet("ORDERID",tmp$)
	OrderNo=tmp$
	LineNo=0;fleptr[4,1]=0;nonstk=0
	If OrderNo>0 ! sent order
		OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
		e$=""
		Call DXGet("LINENO",tmp$)
		LineNo=tmp$
		If OHR<0 ! can't do much with no order!
			Let lineno=0
			clear roh.
			clear ros.
			clear rot.
			ReturnStatus=0
			Message$="ORDER NOT FOUND"
			goto OPADDone
		Endif
		If LineNo>0 ! sent line - get info from it
			OLKey$=" ",OLKey$
			OLKey$[1,6]=roh.OrdNum Using "######"
			OLKey$[7,9]=LineNo Using "###"
			OLKey$[11]="" ! cut at 11 - 10 blank
			OLR=filegetrolz(e$,OLC,"=",1,OLKey$,rol.)
			clear e$
			If OLR<0 
				Clear rol.
				LineNo=0
			Endif ! did not find line
		Endif
	Else ! NEED AN ORDER!
		ReturnStatus=0
		Message$="ORDER NOT PASSED"
		goto OPADDone
	Endif
	If ReturnStatus=1 and OHR>0
		Call GetCust()
	Endif
	If LineNo<=0 ! no order found / yet
		clear rol. ! have nothing
		nonstk=0
		IF ordpad ! need last price check
			call dxget("LTYPE",tmp$)
			LPType$=UCase$(rtrim$(tmp$))
			if LPtype$="NSTK" ! additional
				call dxget("LPFLE",tmp$) ! last price file used
				lpnstk=0
				if UCase$(RTrim$(tmp$))="C" let lpnstk=1
				if UCase$(RTrim$(tmp$))="S" let lpnstk=2 ! shiplist
				call dxget("LPREC",tmp$) ! last price rec
				LPREC=tmp$
				nonstk=1
				if lpnstk=2 ! need sllst file
					SLC=OpenFile(-9982,IntCo) \ if slc=-1 Error 42
				Endif
				if lpnstk=0
					Let E$=" No Last Price File Sent" ! +Prod$
					Let ReturnStatus=0
					if debugdetail
						dmsg$=prod$+e$ \ Call updatelog(debug)
					Endif
					goto OPADDone
				Endif
				if lpnstk=1 let x3=chf(LPC)-1
				if lpnstk=2 let x3=chf(SLC)-1
				if lprec<=0 or lprec>x3 or fra(lprec)
					Let E$=" Invalid Last Price Record Sent" ! +Prod$
					Let ReturnStatus=0
					if debugdetail
						dmsg$=prod$+e$ \ Call updatelog(debug)
					Endif
					if lpnstk=2 try close #slc Else rem
					Goto OPADDone
				Endif
				chan=lpc
				if lpnstk=2 let chan=slc
				read record #chan,lprec,0;clp.;
				call NSFRMLP()
				if lpnstk=2
					if slc try close #slc Else rem
				Endif
				PRR=0 ! not there, is nonstklp
				Prod$=clp.VendItemCode$ ! set for default/missing
				LPR=LPRec
				goto GotOPLPNS
			Endif ! of lptype=NSTK
		Endif ! of orderpad
		Call DXGet("PRODID",tmp$)
		tmp$=UCase$(tmp$)+Blank$
		Prod$=tmp$[1,12]
		ProdKey$=prod$
		PRR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.)
		clear e$
		If PRR<=0 ! no product found
			Clear Pr.
			ReturnStatus=0
			Message$="PRODUCT NOT FOUND"
			goto OPADDone
		Endif
		GotOPLPNS: ! do not reread/clear pr. as it's from lastprice
		If PRR>=0 ! if =0 it's nonstk lastprice orderpad
			Call DXGet("WHSE",tmp$)
			Whse=tmp$
			if whse>0
				PWKey$=Prod$+Whse using "##"
				if roh.ordtype=7 let PWKey$=Prod$+roh.ConsWh using "##"
				PWR=filegetprodwhse(e$,PWC,"=",1,PWKey$,PW.)
				clear e$
				If PWR<0 Clear PW.
			Else
				Clear PW.
			Endif
			! as no line - set up rol. values to use
			rol.QtyOrd=0 ! don't know or need? (need spcl/rbt #)
			SUM=pr.UMSellDefault ! need to pass to setnewrol
			if source=251 and pr.UMPrdtnDefault<>0 let sum=pr.UMPrdtnDefault
			if ordpad ! from order pad - any qty?
				Call DXGet("UM",tmp$)
				if tmp$<>""
					R=getumrec(e$,CCC,tmp$,IntCo,PR.)
					If R<>0 let tmp$=Str$(R)
					Let SUM=tmp$
				Else
					SUM=0
				Endif
				Flag=ChkPrdUM(e$,SUM,IntCo,Pr.)
				If Not(Flag)
					sum=pr.UMSellDefault
					if source=251 and pr.UMPrdtnDefault<>0 let sum=pr.UMPrdtnDefault
				Endif
				call dxget("ORDQTY",tmp$)
				x3=tmp$
				If ABS(X3)>9999999999
					message$="Order Quantity out of range"
					returnstatus=0
					goto OPADDone
				Endif
				if x3<>0 let SQty=x3
				let cnvtu[0]=SUM;cnvtu[1]=0;cnvtu[2]=1
				let cnvta=SQty ! CUTTING? (not known yet)
				Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				Let rol.QtyOrd=Int(Amount) ! always integer base - just cut it
			Endif
			Call SETNEWRol() ! set up rol. vars
			rol.dept=Dept ! as passed
			rol.PDRecNum=PRR;rol.whse=whse
			if ordpad goto bpprice ! no price on ordpad qty
			! need a price call for special/rebate #
			CALL SETUPSPECS() ! set up specs[] for call
			Call getprice()
			let rol.currid=roh.currid
			if rol.currid>0 and rol.currid<=9999
				let rol.currfact=roh.currfact
			else
				let rol.currid=0
				let rol.currfact=0
			endif
			If Specs[0]=0 ! okay to go
				rol.UpChrg=Specs[16]
				rol.UnitCost=Specs[17]
				rol.LineCost2=Specs[18]
				rol.UnitPrice=Specs[20]
				rol.LineDisc=Specs[21]
				rol.LineDiscPct=Specs[22]
				rol.NetPrice=Specs[23]
				rol.RebtContract=Specs[24]
				rol.PriceOrigin=Specs[25]
				rol.CostOrigin=Specs[26]
				rol.Contract=Specs[27]
				rol.SpCommPct=Specs[28]
				rol.BrkLvl=Specs[29]
				rol.LoadUpchrg=Specs[40]
				IF SPECS[14]<>rol.UMPrice ! "price unit changed     
				  let rol.UMPrice=specs[14]
			REM 	   PUM$=xunit$(ROL.UMPrice,ccc) ! u/m
				ENDIF                                                              
				IF SPECS[15]<>rol.UMCost ! "cost unit changed   
					let rol.UMCost=SPECS[15]
				REM	CUM$=xunit$(ROL.UMCost,ccc) ! u/m ok
				ENDIF                
			Endif
			
		Endif ! found prod
	Endif ! no line
	! okay got line setup - let's go with the list
	NonStk=rol.NStkItem
	ZLine=0 \ if NonStk and rol.LineType=3 let ZLine=1
	! CHECK FOR LastPrice
	LPR=FlePtr[4,1] ! in case called above
	bpprice: ! no need for price call
	If LPR<=0 ! did not find or get yet - look for it
		LPKey$=" ",LPKey$
		LPKey$[1,6]=Roh.CustNum using "######"
		X2=rol.dept \ if P9$[44,44]<>"Y" let x2=0
		LPkey$[7,10]=X2 Using "####"
		If Not(NonStk) let LPKey$[11]=rol.prodcode$
		If NonStk let LPKey$[11]=rol.VendItemCode$
		tmp$=LPKey$
		LPR=filegetlastprice(e$,LPC,">",1,LPKey$,CLP.)
		clear e$
		If lpkey$[1,22]<>tmp$[1,22] let lpr=-1
		If LPR<=0 clear clp.

	Endif ! need for poss sugg price
	prr=rol.PDRecNum
	
	If Not(NonStk) Read record #PRC,prr,0;PR.; ! always read prod!
	If NonStk ! nonstock 
		if ordpad goto OPLPBypass ! set up - done clear!!
		Clear pr.
	Endif
	call SetPRtoROL() ! set up prod conv vars
	if rol.comdtycode$="" or rol.comdtycode$=Blank$[1,4]
		If Not(NonStk) Let Rol.Comdtycode$=Pr.ComdtyCode$+blank$
	Endif
	
	Prod$=rol.prodcode$
	whse=rol.whse
	k1$=rol.ComdtyCode$+Blank$;k1$[5]=""
	cmr=filegetcommhead(e$,cmc,"=",1,K1$,cmc.)
	clear e$
	If cmr<0 clear cmc. ! need for price rounding
	! may need set certain prod vars to rol. for  (catchwgt,cwt)
	! first get avl in all whses
	OPLPBYPASS: ! 
	SUM$=XUnit$(rol.umsell,ccc)
	Pum$=XUnit$(rol.umprice,ccc)
	CUm$=XUnit$(rol.umcost,ccc)
	Clear list$[]
	List$[0]=bsdel$,"WHSEAVAIL",fdel$
	webstr$="WHSE",fdel$,"Available",fdel$
	if ordpad let webstr$="WHSE",fdel$,"Available",fdel$,"UM",fdel$,"WHNAME",fdel$
	List$[1]=Webstr$
	Row=2;tmpcnt=maxcnt
	WHAvl=0;x2[9]=rol.whse
	if roh.ConsWh and roh.ordtype=7 let x2[9]=roh.ConsWh
	If RTrim$(Prod$)<>""
		If Not(NonStk) Let WHAvl=getwhavail(e$,intco,PWC,rol.ProdCode$,X2[9])
	Else
		WHAVL=0
	Endif
	if lineno>0 and not(NonStk) and rol.UpdtStk
	  if not(credit) and roh.ordtype<>15 AND rol.qtyship>=0
!	    if roh.ordtype=4 ! backs out ordered
!		  if custom_customer$="MORRISETTE"
!			let whavl=whavl+rol.qtyship ! add back this order
!		  Else
!			let whavl=whavl+(rol.qtyord-rol.PrevQtyShip)
!		  Endif
!		Else
			! let whavl=whavl+rol.qtyship ! add back this order
!		Endif
	  Endif
	Endif
	cnvtu[0]=0;cnvtu[1]=rol.umsell;cnvtu[2]=1
	cnvta=WHAvl \ if rol.numout>0 let cnvta=whavl*rol.numout
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	WebStr$=Str$(rol.Whse),fdel$
	if ordpad
	  WHIR=x2[9]-1
	  Read record #WHI,WHIR,0;WHI.;
	  tmp$=RTrim$(WHI.WhName$)
	  WebStr$=WebStr$,LTrim$(Amount Using QMask$),fdel$,RTrim$(SUM$),fdel$ ! as deflt sell?
	  webstr$=webstr$,tmp$,fdel$ ! wants wh name
	Else
	  WebStr$=WebStr$,STR$(WHAVL),fdel$ ! as base (don't know if UMSell changed!
	Endif
	List$[row]=WebStr$
	row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	PWKey$=" ",PWKey$
	PWKey$=rol.ProdCode$+Blank$
	PWKey$[15]="" ! cut to length
	Do
		if NonStk exit do
		if roh.ordtype=7 exit do ! only the one
		PWR=filegetprodwhse(e$,PWC,">",1,PWKey$,PW.)
		clear e$
		If PWR<0 or Pwkey$[1,12]<>rol.prodcode$ exit do
		X2=pwkey$[13,14]
		If X2<>rol.whse ! already sent line whse #
			If Rtrim$(rol.ProdCode$)<>""
			WHAvl=getwhavail(e$,intco,PWC,rol.ProdCode$,X2)
			Else
				WHAVL=0
			Endif
			if WHAvl>0 ! don't send zero (less than?) Per DD only avail>0
			 cnvtu[0]=0;cnvtu[1]=rol.umsell;cnvtu[2]=1
			 cnvta=WHAvl \ if rol.numout>0 let cnvta=whavl*rol.numout
			 Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			 WebStr$=Str$(X2),fdel$ ! whse #
			 if ordpad
			   WHIR=X2-1
			   Read record #WHI,WHIR,0;WHI.;
	           tmp$=RTrim$(WHI.WhName$)
			   WebStr$=WebStr$,LTrim$(Amount Using QMask$),fdel$,RTrim$(SUM$),fdel$ ! as sell UM
			   webstr$=webstr$,tmp$,fdel$ ! wants wh name
			 Else
				WebStr$=WebStr$,Str$(WHAVL),fdel$ ! as base qty
			 Endif
			 List$[row]=WebStr$
			 row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
			Endif ! no zero avl (shorten list)
		Endif
	Loop
	List$[row]=esdel$ ! finished
	e$=""
	call AddToStr(e$,rstr$,List$[])
	! now any details needed for line
	PWKey$=Prod$+rol.Whse using "##"
	if roh.ordtype=7 let PWKey$=Prod$+roh.ConsWh using "##"
	If Not(NonStk) Let PWR=filegetprodwhse(e$,PWC,"=",1,PWKey$,PW.)
	clear e$
	If PWR<0 Or NonStk Clear PW. ! reread line whse
	Clear list$[]
	List$[0]=bsdel$,"LINEDETAIL",fdel$
	WebStr$="COMPLM",fdel$
	WebStr$=WebStr$,"VENDOR",fdel$,"VENDNAME",fdel$
	WebStr$=WebStr$,"DEPT",fdel$,"PACK",fdel$
	WebStr$=WebStr$,"ALTSUB",fdel$,"ORIGPROD",fdel$
	WebStr$=WebStr$,"FUTEFFDATE",fdel$,"LastDate",fdel$
	WebStr$=WebStr$,"LastPrice",fdel$,"LastCost",fdel$
	WebStr$=WebStr$,"LastGP%",fdel$,"LastQty",fdel$
	WebStr$=WebStr$,"Freq",fdel$,"MSDS",fdel$
	WebStr$=WebStr$,"STKUpt",fdel$,"Whse",fdel$
	WebStr$=WebStr$,"Printed",fdel$,"PrintDate",fdel$
	WebStr$=WebStr$,"SPContract",fdel$,"SPExpDate",fdel$
	WebStr$=WebStr$,"RbtContract",fdel$,"RbtCost",fdel$
	WebStr$=WebStr$,"RbtExpDate",fdel$,"SuggPrice",fdel$
	WebStr$=WebStr$,"TaxRate",fdel$
	if roh.ordtype=15 or roh.ordtype=4 ! add'l fields (qtyship = release)
		webstr$=webstr$,"BILLQTY",fdel$,"PRVBILLQTY",fdel$
		webstr$=webstr$,"PRVBILLDOL",fdel$,"ONBOREL",fdel$
	Endif
	webstr$=webstr$,"GLCOST",fdel$,"PONUM",fdel$
	if ordpad ! order pad much less detail!
		clear list$[]
		List$[0]=bsdel$,"ORDPADQTY",fdel$
		Webstr$="PRODID",fdel$,"DESC1",fdel$,"DESC2",fdel$
		webstr$=webstr$,"ORDQTY",fdel$,"SHIPQTY",fdel$,"BOQTY",fdel$
		webstr$=webstr$,"UM",fdel$,"UMID",fdel$,"PACK",fdel$,"LASTQTY",fdel$
		webstr$=webstr$,"STKUPDT",fdel$,"WHSE",fdel$,"CHKBrkn",fdel$
		WebStr$=WebStr$,"BrknUM",fdel$,"BrknUMID",fdel$,"BrknUMFact",fdel$
	Endif
	List$[1]=WebStr$
	row=2
	X=0
	If ZLine goto OLADone ! zline has none of the below
	X=0 ! for nonstks
	If Not(NonStk) let X=ComplFlag(e$,PRC,IntCo,Prod$)
	e$=""
	Tmp$="N" \ if x let tmp$="Y"
	WebStr$=tmp$,fdel$ ! yes/no 1/0 complementary
	X2=rol.Vendor \ if x2=0 let x2=pr.PrimVend
	tmp$=x2 using "######"
	vnc=OpenFile(-2400,IntCo)
	if vnc>0
		vnr=filegeta80vm(e$,vnc,"=",1,tmp$,Vend.)
		clear e$
		if vnr<=0 clear vend.
		Close #vnc
	Else
		Clear vend.
	Endif
	WebStr$=WebStr$,Str$(x2),fdel$,RTrim$(vend.Name$),fdel$ ! vend & name
	WebStr$=WebStr$,Str$(rol.dept),fdel$,RTrim$(pr.PackSize$),fdel$ ! dept & packsize
	WebStr$=WebStr$,Str$(Int(rol.AltSupsd)),fdel$,RTrim$(rol.OrgProdCode$),fdel$ ! alt/sup & code
	X2=0 ! " clp.PendPermPrdate ! eff date perm price chg?
	if x2=0 let x2=pr.PendBaseDate ! pend future base cost date?
	tmp$=PDate$(x2) ! convert to date
	if x2=0 let tmp$=""
	WebStr$=WebStr$,tmp$,fdel$ ! eff date
	If LPR>0 ! has last price
		read record #LPC,lpr,0;clp.;
		tmp$=PDate$(clp.OrdDate)
		if clp.orddate=0 let tmp$=""
		WebStr$=WebStr$,tmp$,fdel$ ! last date
		cnvtu[0]=0;cnvtu[1]=clp.UMPrice;cnvtu[2]=2
		Cnvta=clp.UnitPrice ! \ if clp.umprice>0 and rol.numout>0 let cnvta=clp.UnitPrice/rol.numout		
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=amount
			If clp.currid=rol.currid and clp.currfact>0
				let cnvca[1]=clp.currfact
			else
				let cnvca[1]=rol.currfact
			endif
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=fnq(cnvca[0])
		endif
		WebStr$=WebStr$,LTrim$(X3 Using PMask$) ! last price
		LPPUM$=xunit$(clp.UMPrice,ccc) ! u/m price
		WebStr$=WebStr$," /",RTrim$(LPPUM$),fdel$ ! lp sell um
		if cost_lev[1]
			cnvtu[0]=0;cnvtu[1]=clp.UMCost;cnvtu[2]=2
			Cnvta=clp.UnitCost ! \ if clp.UMCost>0 and rol.numout>0 let cnvta=clp.UnitCost/rol.numout
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			if p61$[136,136]="Y"  and rol.currfact<>0 and x3<>0 !  
				let cnvcu[0]=1
				let cnvcu[1]=0
				let cnvca[0]=amount
				If clp.currid=rol.currid and clp.currfact>0
					let cnvca[1]=clp.currfact
				else
					let cnvca[1]=rol.currfact
				endif
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=fnq(cnvca[0])
			endif
			WebStr$=WebStr$,"  ",LTrim$(X3 Using PMask$) ! last cost
			LPCUM$=xunit$(clp.UMCost,ccc) ! u/m cost
			WebStr$=WebStr$," /",RTrim$(LPCUM$),fdel$ ! lp cost um 
		Else
			webstr$=webstr$,fdel$
		Endif
		x3=0
		if clp.UnitPrice! NEEDS A PRICE
			X3=FNR(((clp.UnitPrice-clp.UnitCost)/clp.UnitPrice)*100)
		else 
			if clp.UnitCost then let x3=-999999.99
		Endif
		if cost_lev[1]
			WebStr$=WebStr$,"  ",LTrim$(X3 Using QMask$),"%",fdel$ ! GP %
		Else
			webstr$=webstr$,fdel$
		Endif
		cnvtu[0]=0;cnvtu[1]=clp.UMSell;cnvtu[2]=1
		Cnvta=clp.Quantity ! \ if rol.numout>0 let cnvta=clp.Quantity*rol.numout
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		WebStr$=WebStr$,"  ",LTrim$(X3 Using QMask$) ! last Qty
		LPSUM$=xunit$(clp.UMSell,ccc) ! u/m Sell
		WebStr$=WebStr$," /",RTrim$(LPSUM$),fdel$ ! Qty um 
		WebStr$=WebStr$,Str$(clp.FreqSold),FDEL$ ! frequency
	Else
		clear clp.
		WebStr$=WebStr$," ",fdel$," ",fdel$ ! last price/date
		WebStr$=WebStr$," ",fdel$," ",fdel$ ! last cost/gp
		WebStr$=WebStr$," ",fdel$," ",fdel$ ! last Qty/freq
	Endif
	WebStr$=WebStr$,Str$(rol.MSDSNo),fdel$ ! msds
	tmp$="N" \ if rol.UpdtStk let tmp$="Y"
	WebStr$=WebStr$,tmp$,fdel$ ! update stock flag
	WebStr$=WebStr$,Str$(rol.Whse),fdel$ ! warehouse
	tmp$="N" \ if rol.LinePrint let tmp$="Y"
	WebStr$=WebStr$,tmp$,fdel$ ! line printed
	tmp$="" \ if rol.LinePrint let tmp$=JDate$(rol.PrintDate) ! print date = julian
	WebStr$=WebStr$,tmp$ ! printed date
	tmp$=rol.PrintTime Using "&&&&&&"
	if rol.LinePrint=0
		WebStr$=WebStr$,"",FDEL$
	Else
		WebStr$=WebStr$," ",tmp$[1,2],":",tmp$[3,4],":",tmp$[5,6],fdel$ ! print time HH:MM:SS
	Endif
	If rol.Contract ! has a spcl price
		k1$=rol.ProdCode$+"C"+rol.Contract Using "#####"
		spr=filegetspecprice(e$,splc,"=",2,K1$,spcl.)
		clear e$
		if spr<0 clear spcl. else goto Got_SPR
		! now try cost group contract
		k1$="C"+rol.Contract Using "#####" + "-"+PR.CostUpdGrp$
		spr=filegetspecprice(e$,splc,"=",1,K1$,spcl.)
		clear e$
		if spr<0 clear spcl. else goto Got_SPR
		! now try commodity contract
		k1$="C"+rol.Contract Using "#####" + "*"+PR.ComdtyCode$
		spr=filegetspecprice(e$,splc,"=",1,K1$,spcl.)
		clear e$
		if spr<0 clear spcl. else goto Got_SPR
		! and the rest...when needed
		Got_SPR: ! found the rec
		WebStr$=WebStr$,Str$(rol.Contract),fdel$ ! contr #
		tmp$="" \ if spcl.CancelDate let tmp$=PDate$(spcl.CancelDate)
		if spcl.canceldate=999999 or tmp$="" let tmp$="none"
		WebStr$=WebStr$,RTrim$(tmp$),fdel$ ! exp date
	Else
		WebStr$=WebStr$," ",fdel$," ",fdel$ ! sp contr & exp date
	Endif
	If Not(NonStk) ! rol.RebtContract ! has a rbt contract or always? try always
		RbtCost=getrbtcost() ! gets rbt cost
		rbdc=OpenFile(-320,IntCo)
		If rbdc>0 ! get detail
		  If rbt_args[5,1]>0 ! passed record
		    rbdr=rbt_args[5,1] 
		    Read Record #rbdc,rbdr,0;rbdt.;
		  Else
			K1$=" ",k1$
			K1$=rol.RebtContract Using "######",rol.prodcode$
			! also possible *+Commdty or #  all so hope rec is sent
			rbdr=filegetrebatedtlz(e$,rbdc,"=",1,K1$,rbdt.)
			clear e$
			If Rbdr<=0 clear rbdt.
		  Endif
		  Close #rbdc ! close details
		Else
			clear rbdt.
		Endif
		WebStr$=WebStr$,Str$(rol.RebtContract),fdel$
		CNVTU[0]=0;CNVTU[1]=rol.UMCost;cnvtu[2]=2
		Cnvta=rbtcost \ if rol.umcost>0 and rol.numout>0 let cnvta=rbtcost/rol.numout
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		! WebStr$=WebStr$,LTrim$(amount using PMask$),fdel$ ! needs CUM$ (cost um)?
		WebStr$=WebStr$,Str$(rbtcost),fdel$ ! as base
		tmp$="" \ if rbdt.CancelDate let tmp$=PDate$(rbdt.CancelDate)
		if rbdt.CancelDate=999999 or tmp$="" let tmp$="none"
		WebStr$=WebStr$,RTrim$(tmp$),fdel$ ! exp date
	Else ! no rebates
		WebStr$=WebStr$," ",fdel$," ",fdel$," ",fdel$ ! #, cost, date
	Endif
	IF LPR>0 and (P9$[13,13]="M" or P9$[13,13]="G") ! can only give sugg price if last price!
		x3=0
		IF clp.UnitCost ! must have for sugg price
			! mxline = UWORK[4]*(1+((LPC2[1]-LPC2[2])/LPC2[2]) (Uwork[4]=Unitcost in costum)
			x3=rol.UnitCost*(1+((clp.UnitPrice-clp.UnitCost)/clp.UnitCost)) ! we use base!
		Endif ! of get sugg price
		If rol.UpChrg ! has up - add it in
			If rol.UpChrg<0 ! it's a $
				x3=x3+Abs(rol.UpChrg)
			Else ! it's %
				x3=x3+(x3*(rol.UpChrg/100))
			Endif
		Endif ! of upchrg it
		cnvtu[0]=0;cnvtu[1]=rol.UMPrice;cnvtu[2]=2
		cnvta=x3 ! \ if rol.umprice>0 and rol.numout>0 let cnvta=x3/rol.numout
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=amount
			let cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=FNQ(cnvca[0])
		endif
		IF P61$[50,50]="Y" ! price rounding
			x2=cmc.PriceRoundFactor
			if x2>0 and x2<9
				Call "pricernd",x2,Amount
			Endif
		Endif 
		! WebStr$=WebStr$,LTrim$(Amount using PMask$),fdel$ ! as price um
		WebStr$=WebStr$,Str$(X3),fdel$ ! as base (line um chg'd?)
	Else
		WebStr$=WebStr$,"0",fdel$ ! no sugg
	Endif
	If P60$[42,42]<>"Y" ! has y/n only - get rate from header tax
		TaxNo=roh.TaxCode
		rol.TaxPct=rot.TaxPct ! use totals %
	Else ! is a code
		TaxNo=rol.TaxFlg
		If TaxNo>0
			Tcc=Openfile(-2176,IntCo) \ if Tcc = -1 Error 42
			Read record #tcc,taxno,0;tax.;
			Close #tcc
		Else ! no taxcode
			clear tax.
		Endif
		rol.TaxPct=tax.TaxRate
	Endif
	
	WebStr$=WebStr$,LTrim$(rol.TaxPct Using "###.####"),fdel$ ! tax rate
	if roh.ordtype=15 or roh.ordtype=4 ! send add'l fields
		cnvtu[0]=0;cnvtu[1]=rol.umsell;cnvtu[2]=1
		cnvta=rol.CurrBillQty \ if rol.umsell>0 and rol.numout>0 let cnvta=rol.CurrBillQty*rol.numout
		amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		webstr$=webstr$,LTrim$(amount using Qmask$),fdel$ ! currbillqty
		cnvta=rol.PrevQtyBill \ if rol.umsell>0 and rol.numout>0 let cnvta=rol.PrevQtyBill*rol.numout
		amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		webstr$=webstr$,LTrim$(amount using Qmask$),fdel$ ! prevbillqty
		webstr$=webstr$,LTrim$(rol.PrevBill using Qmask$),fdel$ ! prev bill$
		cnvta=rol.BORelQty \ if rol.umsell>0 and rol.numout>0 let cnvta=rol.BORelQty*rol.numout
		amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		webstr$=webstr$,LTrim$(amount using Qmask$),fdel$ ! qty on bo rel
	Endif
	CNVTU[0] = 0;CNVTU[1] = rol.UMCost;CNVTU[2] = 2 
	otok=0 \ if roh.OrdType=2 let otok=1
	if custom_customer$="HTBERRY" and roh.ordtype=25 let otok=1
	if roh.Ordtype=1 and rol.Updtstk=0 and p8$[4,4]="Y" and pw.prodgrp>0 and not(nonstk) and not(credit)
			milf=getmillflg(e$,intco,PWC,prod$,rol.Whse,roh.ordtype)
			if milf>0 let otok=1
	endif
	if Nonstk or otok or (roh.OrdType=3 and P60$[22,22]="N")
		if source<>207 and Not(nonstock)! task#45231 - need to write it to file, since user may not save screen
			if rol.UnitGLCost<=0 
				let rol.UnitGLCost=pr.CostPO
				write record #olc,olr;rol.;
			endif
		endif
		CNVTA = rol.UnitGLCost 
		if rol.UMCost>0 and rol.numout>0 let cnvta=rol.UnitGLCost/rol.numout
		X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)  
		if p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=x3
			let cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
		 WebStr$ = WebStr$,LTrim$(X3 Using PMask$),fdel$ ! unit gl cost 
	Else
		CNVTA=0 ! not sending
		webstr$=webstr$," ",fdel$
	Endif
	webstr$=webstr$,Str$(rol.PONum),fdel$ ! 1986 - send po
	If OrdPad ! order pad - much less detail
		! quick avail check
		x2[9]=rol.whse \ if roh.ordtype=7 let x2[9]=roh.ConsWh
		If RTrim$(rol.prodcode$)<>""
			X3[1]=getwhavail(e$,intco,PWC,rol.ProdCode$,X2[9])
		Else
			X3[1]=0
		Endif
		x=0 \ if p60$[27,27]="S" let x=1
		if p60$[27,27]="B" let x=2
		if p60$[27,27]="E" let x=3
		if nonstk let x3[1]=0 ! can't
		if Not(credit) and X>0 ! has bochk set
		 If rol.QtyOrd>0 and ROL.UpdtStk and rol.QtyOrd>X3[1] ! order > whavail
		  if x3[1]>0 ! has some avail
			Let rol.QtyShip=X3[1] ! take it all
			Let rol.QtyBO=rol.QtyOrd-rol.QtyShip
		  Else ! zero or <0 avail
			Let rol.QtyShip=0
			Let rol.QtyBO=rol.QtyOrd ! all backordered
		  Endif
		 Endif ! of updt and ord>avail
		Endif
		! added 2/28 - convert shipped/bo to sell 2 dec - 2316
		if rol.qtyship<>0
			cnvtu[0]=0;cnvtu[1]=rol.UMSell;cnvtu[2]=1
			cnvta=rol.qtyship \ if rol.numout>0 let cnvta=rol.qtyship*rol.numout
			Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			tmp$=LTrim$(amount using "----------#.##")
			amount=tmp$ ! now 2 decimals only
			cnvtu[0]=rol.UMSell;cnvtu[1]=0;cnvtu[2]=1
			cnvta=amount \ if rol.numout>0 let cnvta=amount/rol.numout
			Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			if amount<>rol.qtyship ! it changed
				rol.qtyship=amount
				if rol.qtyship>x3[1] let rol.qtyship=x3[1] ! no overship
				Let rol.QtyBO=rol.QtyOrd-rol.QtyShip
			Endif
		Endif ! of recalc qty ship based on 2 dec
		if roh.ordtype=15 let rol.qtyship=0;rol.qtybo=0 ! starts as zero
		if Cust.BoSAllowedFlag=0 Let rol.QtyBO=0 ! no bo's allowed
		if roh.ordtype=4 let rol.QtyBO=0 ! no bo's allowed on ot4?
		if nonstk let rol.UpdtStk=0;pw.ChkBrknQty$="N"
		! ok - send data
		tmp$=clrtxtc$(e$,pr.Desc1$) ! chk/clr control chars
		Webstr$=Prod$,fdel$,RTrim$(tmp$),fdel$
		tmp$=clrtxtc$(e$,pr.Desc2$) ! chk/clr control chars
		webstr$=webstr$,RTrim$(tmp$),fdel$
		cnvtu[0]=0;cnvtu[1]=rol.UMSell;cnvtu[2]=1
		Cnvta=rol.QtyOrd \ if rol.numout>0 let cnvta=rol.qtyord*rol.numout
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! Ord Qty
		Cnvta=rol.QtyShip \ if cnvta=0 and rol.qtybo=0 let cnvta=rol.qtyord
		if rol.numout>0 let cnvta=cnvta*rol.numout
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! Ship Qty
		Cnvta=rol.QtyBO \ if rol.numout>0 let cnvta=rol.qtyBo*rol.numout
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! BO Qty
		tmp$=xunit$(rol.UMSell,ccc) ! u/m sell
		webstr$=webstr$,tmp$,fdel$,Str$(rol.UMSell),fdel$ ! um & rec
		webstr$=webstr$,RTrim$(pr.PackSize$),fdel$ ! pack
		cnvtu[0]=0;cnvtu[1]=clp.UMSell;cnvtu[2]=1
		Cnvta=clp.Quantity ! \ if rol.numout>0 let cnvta=clp.Quantity*rol.numout
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		WebStr$=WebStr$,LTrim$(X3 Using QMask$) ! last Qty
		LPSum$=""
		if clp.UMSell let LPSUM$=xunit$(clp.UMSell,ccc) ! u/m Sell
		WebStr$=WebStr$," /",RTrim$(LPSUM$),fdel$ ! last Qty um
		tmp$="N" \ if rol.UpdtStk let tmp$="Y"
		WebStr$=WebStr$,tmp$,fdel$ ! update stock flag
		WebStr$=WebStr$,Str$(x2[9]),fdel$ ! warehouse
		tmp$=XUNIT$(pr.UMBrknQty,ccc)
		if pw.ChkBrknQty$<>"N" let pw.ChkBrknQty$="Y" ! Y is default
		WebStr$=WebStr$,pw.ChkBrknQty$,fdel$,RTrim$(tmp$),fdel$ ! chkbrkn, brkn um
		X3=UMtoFactor(pr.UMBrknQty)
		WebStr$=WebStr$,Str$(pr.UMBrknQty),fdel$,Str$(X3),fdel$ ! um id, um factor
	Endif ! of orderpad
	! finished with line details
	List$[row]=WebStr$
	row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	OLADONE: ! finished
	List$[row]=esdel$ ! finished
	e$=""
	call AddToStr(e$,rstr$,List$[])
	! add any flags needed
	Clear list$[]
	List$[0]=bsdel$,"LINEFLAGS",fdel$
	List$[1]="BOPOLINK",fdel$
	webstr$=getbopolink$(),fdel$ ! CHECK sordtype
	List$[2]=webstr$
	list$[3]=esdel$
	call AddToStr(e$,rstr$,List$[])

	if debugdetail
		dmsg$="Addl Detail sent "+Str$(Orderno)+"-"+Str$(LineNo)+" "+rol.prodcode$+Message$ \ Call updatelog(debug)
	Endif
	! status section
	! ReturnStatus=1 (Set above)
	! Message$="OK"
	OPADDone: ! 
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
	! 
	! call programdump("/tmp/ollog5!","")
  else
    include "src/callsuberr.inc"
  end try
end sub ! Ordaddldtl
! 
!--------------------------------------------------------------------
Sub SetNewROL()
! a routine for setting rol. variables
! this assumes the prod & prodwhse are already read!
! also roh. ros. rot. have been read!
! AND the qtyord is already known and SellUM is in SUM
 Try
	Dim K1$[50]
	dim 1%,PRAM[5]
	Dim 2%,X2[9]
	Dim 3%,X3[9]

	Dim tax. as taxcode
	
	rol.OrdNum=roh.OrdNum
	rol.UpdtStk=1 ! yes
	
	rol.PSlsCat=PR.ProdCat
	rol.Slsm=roh.SlsmNum
	rol.Whse=roh.Wh
	!!!!!!!!!!! start task#57048 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	IF NONSTK<>0 AND LPNSTK<>0 AND LPREC<>0 and rtrim$(clp.ComdtyCode$)<>""
		rol.ComdtyCode$ = rtrim$(clp.ComdtyCode$)  + Blank$ 
    ELSE
		rol.ComdtyCode$ = PR.ComdtyCode$ + Blank$ 
	ENDIF 
	!rol.ComdtyCode$=pr.ComdtyCode$+Blank$
	!!!!!!!!! end task#57048 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	rol.Dept=roh.Dept
	rol.QtyBO=0
	rol.QtyShip=rol.QtyOrd
	rol.MatCode$=pr.MatCode$
	rol.EntBy=ROH.EntBy ! how's this gotten? (MXLINE=PORTDEFAULT) OR H5[0]
	If nonstk 
		if p61$[76,76]="Y" and NOT(CREDIT) ! auto bo nonstk
		  if custom_customer$="HTBERRY" or roh.ordtype<>2! per group not on DIRECTS
		    if roh.ordtype<>15  ! task42215
				let Rol.QtyBO=rol.QtyOrd;rol.QtyShip=0 ! bo=ord,ship=0
			endif
		  Endif
		Endif
		goto NStkSUBypass ! don't load the remainder
	Endif
	rol.CubeUnit=PR.CubicFeet
	rol.LbsUnit=pr.LbsUnit
	rol.TaxFlg=0 ! --------- needs setup (below)
	rol.Desc1$=pr.Desc1$
	rol.Desc2$=pr.Desc2$
	rol.ProdCode$=pr.ProdCode$
	if SUM=0 and source=251 and pr.UMPrdtnDefault<>0 let sum=pr.UMPrdtnDefault
	rol.UMSell=SUM ! as passed!
	if SUM=0 Let rol.UMSell=pr.UMSellDefault
	rol.UMPrice=pr.UMPriceDefault
	rol.UMCost=pr.UMCostDefault
	rol.Vendor=pr.PrimVend ! may chg to whse
	rol.MSDSNo=getMSDS(e$,IntCo,roh.CustNum,rol.ProdCode$,ros.ShipCust,ros.ShipCode,pr.Msds,pr.DotHazardous)
	rol.VendItemCode$=pr.VendItem$ ! cb whse
	rol.UMBase=pr.BaseUM
	rol.UMPurch=pr.UMPurchDefault
	rol.CubeFactor=PR.CubicFtFactor \ if rol.CubeFactor<=0 Let rol.CubeFactor=1
	rol.WgtFactor=pr.LbsFact \ if rol.WgtFactor<=0 Let rol.WgtFactor=1
	rol.CatchWgtItem=pr.CatchWgtItm
	rol.SellFactor=UMtoFactor(rol.UMSell)
	rol.PriceFactor=UMtoFactor(rol.UMPrice)
	rol.CostFactor=UMtoFactor(rol.UMCost)
	rol.PurchFactor=UMtoFactor(rol.UMPurch)
	let rol.currid=roh.currid
	if rol.currid>0 and rol.currid<=9999
		let rol.currfact=roh.currfact
	else
		let rol.currid=0
		let rol.currfact=0
	endif
	
	IF P9$[32,32]="Y" ! whse pricing
		if pw.CostLastPo let rol.UnitGLCost=pw.CostLastPo
	Endif
	If PW.Vend>0 Let rol.Vendor=pw.vend
	IF PW.VendPN$[1,5]>"     " let rol.VendItemCode$=pw.VendPN$
	otok=0 \ if roh.OrdType=2 let otok=1
	if custom_customer$="HTBERRY" and roh.ordtype=25 let otok=1
	
	! Needs a Prodgroup check (in case single entry!)
	If PW.ProdGrp>0 ! has a group
		Pram[0]=ROH.OrdType !  \ if TScan=2 Let Pram[0]=0-OType
		Pram[1]=PW.ProdGrp
		Pram[5]=0 ! file not opened
		![0]=Order or (-)PO Type
		! [1]=Product Group
		! [2]=Allow on Ord/PO (1=y, 0=N)
		! [3]=Update Stock (1=y, 0=N)
		! [4]=On Price List (0/1)
		! [5]=Channel of 2/ProdGrp#
		Call ProdGroup(e$,intco,Pram[])
		! If Pram[2]=0  ! not allowed on OType
		!	E$="Product Not Allowed on this Order!"
		!	Exit Sub
		! Endif  ! DO THIS ON ENTRY ONLY!
		rol.UpdtStk=Pram[3] ! update Stock
	Endif ! prodgroup
	X2=roh.OrdType
	if x2=2 OR X2=5 LET rol.UpdtStk=0 ! not on directs
	if x2=3 and p60$[22,22]<>"Y" LET rol.UpdtStk=0 ! indir no stk
	! if x2=16 and roh.XferAuth=0 LET rol.UpdtStk=0 ! whxfer not auth
	if otok or (roh.OrdType=3 and P60$[22,22]="N") ! gl cost
		if source<>207 ! task#45231 - need to write it to file, since user may not save screen
			if rol.UnitGLCost<=0 
				let rol.UnitGLCost=pr.CostPO
				! write record #olc,olr;rol.; ! CAN'T WRITE - MAY BE NO LINE YET!!
			endif
		endif
	Else
		if roh.Ordtype=1 and rol.Updtstk=0 and p8$[4,4]="Y" and pw.prodgrp>0 and not(nonstk) and not(credit)
			milf=getmillflg(e$,intco,PWC,prod$,rol.Whse,roh.ordtype)
			if milf>0 ! it is - back order all per dd! need to check if mill item
				if source<>207 ! task#45231 need to write it to file, since user may not save screen
					if rol.UnitGLCost<=0 
						let rol.UnitGLCost=pr.CostPO
						! write record #olc,olr;rol.; ! CAN'T WRITE - MAY BE NO LINE YET!!
					endif
				endif
			else
				let rol.unitglcost=0
			endif
		else
			rol.UnitGLCost=0
		endif
	Endif
	IF CREDIT<>0 ! stock update flags
		if roh.ShipType=3 LET rol.UpdtStk=0
		if roh.ShipType=7 LET rol.UpdtStk=0
		if roh.ShipType=2
			if p61$[131,131]="N" let rol.UpdtStk=0
			if p61$[131,131]="Y" let rol.UpdtStk=1 ! checks non-stock and comm code below
		endif
	endif
	tmp$=pr.ComdtyCode$
	if tmp$="LABR" OR tmp$="TIME" OR tmp$="MACH" LET rol.UpdtStk=0 ! comm's no stk
	If nonstk LET rol.UpdtStk=0
	
	NStkSUBypass: ! bypass a lot on new nonstk
	! tax flag / rate
	K1$=roh.CustNum Using "######"
	ProdKey$=rol.ProdCode$
	if nonstk let ProdKey$=rol.VendItemCode$ ! nonstk use venditem as key
	Call TaxFlag(k1$,ProdKey$,ros.ShipCust,ros.ShipCode,rol.Dept,pr.TaxType,intco,roh.TaxCode,ros.ShipTaxType,Taxback)
	rol.TaxFlg=Taxback ! contains what's needed
	If P60$[42,42]<>"Y" ! has y/n only - get rate from header tax
		TaxNo=roh.TaxCode
	Else ! is a code
		TaxNo=rol.TaxFlg
	Endif
	If TaxNo>0
		Tcc=Openfile(-2176,IntCo) \ if Tcc = -1 Error 42
		Read record #tcc,taxno,0;tax.;
		Close #tcc
	Else ! no taxcode
		clear tax.
	Endif
	rol.TaxPct=tax.TaxRate
	! extensions, etc to be calculated when sent back!
	! call programdump("/tmp/ollog4!","")
	if debugdetail
		dmsg$="Rol. Setup "+rol.prodcode$+Message$ \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
 end try
end sub ! Setnewrol
! 
!--------------------------------------------------------------------
Sub SetUpSpecs()
! this sets up the specs[]
! the rol has already be set up!
Try 
	Dim KCM$[50],K1$[50]
	Dim 1%,PT[37]
	Dim 3%,ORDWGT

	KCM$=" ",kcm$;kcm$=rol.ComdtyCode$+Blank$;kcm$[5]=""
	CMR=filegetcommhead(e$,CMC,"=",1,kcm$,CMC.) ! need comm rec#
	clear e$
	If CMR<0 Let CMR=0
	Call getcust()
	! send rec #'s
	let x2=Cust.LpPpGrpCust
	! If P60$[33,33]<>"Y" Let X2=0
	If CUST.AuthBuyList$="Y" Let X2=0
	If X2=CUST.CustomerCode let x2=0
	if x2<1 or x2>999999 or Fra(X2) Let X2=0
	IF P61$[100,100]<>"Y" let x2=0
	let fleptr[0,1]=X2 ! perm price group
	fleptr[1,1]=PRR;fleptr[2,1]=PWR;fleptr[3,1]=CMR ! prod,prodwh,comm
	if rol.WgtFactor<=1 Let rol.WgtFactor=1
	ordWgt=(ABS((rol.LbsUnit*rol.QtyOrd)/rol.WgtFactor)) ! PRICE USES ORDERED!
	Specs[0]=0;Specs[1]=rol.QtyOrd;Specs[2]=ORDWGT ! rol.ExtNetWgt
	IF ROL.Numout>0 
		let Specs[1]=rol.qtyord*rol.numout
		let Specs[2]=ORDWgt*rol.numout
	Endif
	Specs[3]=roh.CustNum;Specs[4]=rol.Whse;Specs[5]=roh.OrdDate
	Specs[6]=rol.Dept;Specs[8]=roh.OrdType
	Let Specs[7]=roh.PriceType \ if specs[7]<=0 let Specs[7]=cust.PriceType
	! default cost from prtype file
	cpt=openfile(-752,Intco) \ if cpt=-1 Error 42
	mat read #cpt,specs[7],28;PT;
	Close #cpt ! that's all we needed from file
	X=Specs[8]-1 ! pt[] is 0 to 37
	If X<0 let x=0
	X2=PT[x] \ if x2=0 let x2=P60$[29,29]
	Specs[9]=X2 ! default cost
	Specs[13]=rol.UMSell;Specs[14]=rol.UMPrice;Specs[15]=rol.UMCost
	Specs[16]=rol.UpChrg
	Specs[17]=rol.UnitCost
	Specs[18]=rol.LineCost2
	Specs[20]=rol.UnitPrice
	Specs[21]=rol.LineDisc
	Specs[22]=rol.LineDiscPct
	Specs[23]=rol.NetPrice
	Specs[24]=rol.RebtContract
	Specs[25]=rol.PriceOrigin
	Specs[26]=rol.CostOrigin
	Specs[27]=rol.Contract
	Specs[28]=rol.SpCommPct
	Specs[29]=rol.BrkLvl
	Specs[40]=rol.LoadUpchrg
	if debugdetail
		dmsg$="Price Specs setup "+rol.prodcode$ \ Call updatelog(debug)
	Endif
else
    include "src/callsuberr.inc"
 end try
end sub ! SetupSpecs
! 
!--------------------------------------------------------------------
Function getrbtCost()
! set up vars for call "rebates" & return rbtcost
  Try
	dim 1%,vtgc,rbhc,rbdc
	Dim 3%,Rbt_Args[10,4],rbtcost

	rbtCost=0
	rbt_args[1,0]=PRC ! prod chan
	rbt_args[2,0]=PWC ! prodwhse
	vtgc=OpenFile(1120,Intco) \ if vgtc=-1 goto finrcall
	rbt_args[3,0]=vtgc ! vendtag
	rbhc=OpenFile(304,IntCo) \ if rbhc=-1 goto finrcall
	rbt_args[4,0]=rbhc ! rebate header
	rbdc=OpenFile(320,IntCo) \ if rbdc=-1 goto finrcall
	rbt_args[5,0]=rbdc ! rebate detail
	rbt_args[1,1]=prr ! prod record
	rbt_args[1,2]=rol.whse ! whse
	rbt_args[2,1]=pwr ! prodwhse record
	rbt_args[2,2]=roh.custnum ! customer
	rbt_args[3,2]=0 ! ignore customer?
	rbt_args[4,2]=roh.OrdDate ! order date
	rbt_args[5,2]=roh.PriceType  !Cust price type
	IF P61$[100,100]="Y"
		X2 = Cust.LpPpGrpCust                                         
		If Cust.AuthBuyList$ = "Y" Let X2 = 0          
		If X2 = roh.custnum  Let X2 = 0           
		If X2 < 1 Or X2 > 999999 Or Fra(X2) Let X2 = 0 
		if x2<>0
			rbt_args[2,2]=x2! customer
			call rebates(e$,Rbt_args[],Prod$,Flag,debug,dblog$) ! new external sub
			If Flag=0
				rbtcost=Rbt_args[1,3]
				goto FinRCall:
			Else
				rbtcost=0
			Endif
			rbt_args[2,2]=roh.custnum ! customer
		endif
	endif      
	!Call "rebates",Rbt_args[],Prod$,Flag
	call rebates(e$,Rbt_args[],Prod$,Flag,debug,dblog$) ! new external sub
	If Flag=0
		rbtcost=Rbt_args[1,3]
	Else
		rbtcost=0
	Endif
	FinRCall: ! finished - closefiles
	If vtgc>0 close #vtgc
	if rbhc>0 close #rbhc
	if rbdc>0 close #rbdc
	if debugdetail
		dmsg$="Rebate get "+prod$ \ Call updatelog(debug)
	Endif
  else
    include "src/callsuberr.inc"
  end try
end Function RbtCost ! openfiles
! 
!--------------------------------------------------------------------
Sub SetPRtoRol()
! set up prod (PR.) with line values (stock & NonStock)
 Try
	Dim 1%,PFU1[20]
	Dim 3%,PFU2[6]
	IF ZLINE GOTO L30099:                                          
	LET pr.LbsUnit=rol.LbsUnit;pr.LbsFact=rol.WgtFactor
	IF NOT(pr.LbsUnit) LET pr.LbsUnit=1;rol.WgtFactor=1    
	LET pr.CubicFeet=rol.CubeUnit;pr.CubicFtFactor=rol.CubeFactor
	IF NOT(pr.CubicFtFactor) LET pr.CubicFtFactor=1;rol.CubeFactor=1
	LET pr.BaseUM=rol.UMBase;pr.UM2=rol.UMSell                     
	LET pr.UM3=rol.UMPrice;pr.UM4=rol.UMCost                               
	LET pr.UM5=rol.UMPurch                                          
	LET pr.UM6=0;pr.UM7=0;pr.UM8=0                               
	LET pr.UMStkDefault=rol.UMSell;Pr.UMSellDefault=rol.UMSell;pr.UMPurchDefault=rol.UMPurch             
	LET pr.UMCostDefault=rol.UMCost;pr.UMPriceDefault=rol.UMPrice                              
	IF NOT(NonSTK) GOTO L30060:                                   
	LET pr.UMPrdtnDefault=rol.UMSell;pr.UMUpChrg=rol.UMBase;pr.UMBrknQty=rol.UMBase              
	IF pr.UMCostDefault=-3 OR pr.UMPriceDefault=-3 ! "Catch Wgt Itm N/S              
		LET pr.CatchWgtItm=-3;rol.CatchWgtItem=pr.CatchWgtItm                                 
	ELSE                                                            
		LET pr.CatchWgtItm=0;rol.CatchWgtItem=0                                         
	ENDIF                                                           
	LET pr.UMPack=rol.UMSell;pr.UMSize=rol.UMSell                               
	L30060: LET pr.UM2Fact=rol.SellFactor;pr.UM3Fact=rol.PriceFactor                     
	LET pr.UM4Fact=rol.CostFactor;pr.UM5Fact=rol.PurchFactor                              
	LET pr.UM6Fact=0;pr.UM7Fact=0;pr.UM8Fact=0 
	! below gets rid of dupes - not easy with names - so load into pfu1,pfu2
	PFU1[0]=pr.BaseUM
	pfu1[1]=pr.UM2;PFU2[0]=pr.UM2Fact
	Pfu1[2]=pr.UM3;pfu2[1]=pr.UM3Fact
	pfu1[3]=pr.UM4;pfu2[2]=pr.UM4Fact
	pfu1[4]=pr.UM5;pfu2[3]=pr.UM5Fact
	FOR X1=1 TO 4                                                   
		FOR X2=0 TO X1-1                                              
			IF PFU1[X1]=PFU1[X2] LET PFU1[X1]=0;PFU2[X1-1]=0            
		NEXT X2                                                       
	NEXT X1 
	! now reload checked um's to names
	pr.BaseUM=PFU1[0]
	pr.UM2=pfu1[1];pr.UM2Fact=PFU2[0]
	pr.UM3=Pfu1[2];pr.UM3Fact=pfu2[1]
	pr.UM4=pfu1[3];pr.UM4Fact=pfu2[2]
	pr.UM5=pfu1[4];pr.UM5Fact=pfu2[3]
L30099: ! finito
	if debugdetail
		dmsg$="Put rol. into pr. "+Str$(Orderno)+"-"+Str$(LineNo)+" "+rol.prodcode$ \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
 end try
end sub ! SetPRtoRol
! 
!--------------------------------------------------------------------
Function UMtoFactor(UMRec)
! from sent um # - get um factor for it
! if no match - send factor back as one (base?)
 Try
	
	dim 3%,factor
	let factor=0
	if umrec=-1 let factor=-1 ! web wants umrec in factor
	if umrec=-3 let factor=-3 ! for these
	if umrec<=0 exit function Factor ! 0 ! no um - no factor!
	If umrec=Pr.BaseUM let factor=1
	if umrec=PR.UM2 let factor=pr.UM2Fact
	if umrec=PR.UM3 let factor=pr.UM3Fact
	if umrec=PR.UM4 let factor=pr.UM4Fact
	if umrec=PR.UM5 let factor=pr.UM5Fact
	if umrec=PR.UM6 let factor=pr.UM6Fact
	if umrec=PR.UM7 let factor=pr.UM7Fact
	if umrec=PR.UM8 let factor=pr.UM8Fact
	!if umrec=-1 let factor=-1 ! web wants umrec in factor
	!if umrec=-3 let factor=-3 ! for these
	if debugdetail
		dmsg$="UM to Factor" \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
  end try
end Function Factor ! umtofactor
! 
!--------------------------------------------------------------------
Sub MainDtlHdr()
! send the header for line main details
! so all routines use the same and save searching
Try
	WebStr$="ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$
	WebStr$=WebStr$,"WHAvail",fdel$,"WHAvlUM",fdel$,"WHAvlUMID",fdel$
	WebStr$=WebStr$,"TotAvail",fdel$,"TotAvlUM",fdel$,"TotAvlUMID",fdel$
	WebStr$=WebStr$,"UnitPrice",fdel$,"PriceUpchrg",fdel$
	WebStr$=WebStr$,"PriceUpType",fdel$,"Whse",fdel$
	WebStr$=WebStr$,"NetPrice",fdel$,"PriceUM",fdel$,"PriceUMID",fdel$
	WebStr$=WebStr$,"QtyOrder",fdel$,"QtyUM",fdel$,"QtyUMID",fdel$
	WebStr$=WebStr$,"UnitCost",fdel$,"CostSecurity",fdel$
	WebStr$=WebStr$,"CostUM",fdel$,"CostUMID",fdel$,"CostUpchrg",fdel$
	WebStr$=WebStr$,"CostUpType",fdel$,"ExtCost",fdel$
	WebStr$=WebStr$,"ExtPrice",fdel$,"GP%",fdel$
	WebStr$=WebStr$,"Comm/Desc",fdel$,"QtyBO",fdel$
	WebStr$=WebStr$,"PrevShip",fdel$,"QtyShip",fdel$
	WebStr$=WebStr$,"LastPrc/Cost",fdel$,"LastDate/GP/Qty",fdel$
	WebStr$=WebStr$,"NOTES",fdel$,"Tax",fdel$
	WebStr$=WebStr$,"FutureCost",fdel$,"SPPRContract",fdel$
	WebStr$=WebStr$,"RebateContract",fdel$,"Dept",fdel$
	WebStr$=WebStr$,"Weight",fdel$,"WgtFactor",fdel$,"WgtUM",fdel$
	WebStr$=WebStr$,"ExtWgt",fdel$,"VendorItem",fdel$
	WebStr$=WebStr$,"Cube",fdel$,"CubeFactor",fdel$,"CubeUM",fdel$
	WebStr$=WebStr$,"ExtCube",fdel$,"LineDisc%",fdel$
	WebStr$=WebStr$,"LineNum",fdel$ 
	If elflag=9 let webstr$=webstr$,"NewPermPrc",fdel$ 
	WebStr$=WebStr$,"LTYPE",fdel$ ! include type? ----- ADD WHEN READY  -- ready now
	! added 05/28 - per web send all flags & factors NOW
	webstr$=webstr$,"QTYUMFACT",fdel$,"COSTUMFACT",fdel$,"PRCUMFACT",fdel$
	webstr$=webstr$,"CHKBrkn",fdel$,"MBFlag",fdel$
	WebStr$=WebStr$,"SerialNo",fdel$,"CatchWeight",fdel$
	WebStr$=WebStr$,"LotControl",fdel$,"RollLB",fdel$
	WebStr$=WebStr$,"DNReord",fdel$,"BrknUM",fdel$
	WebStr$=WebStr$,"BrknUMID",fdel$,"BrknUMFact",fdel$
	webstr$=webstr$,"STKUPDT",fdel$,"KIT",fdel$,"KITACTION",fdel$
	webstr$=webstr$,"PRCORGN",fdel$,"CSTORGN",fdel$
	webstr$=webstr$,"BORelQty",fdel$,"QTYOUT",fdel$
	webstr$=webstr$,"NETCOST",fdel$
	webstr$=webstr$,"CURRBILL",fdel$,"PREVBILL",fdel$ ! OT 4 fields!!
	webstr$=webstr$,"HILIGHTPID",fdel$,"HLD4PO",fdel$
	Webstr$=webstr$,"RASL",fdel$,"SuggPrice",fdel$
	Webstr$=webstr$,"PRCEDIT",fdel$
	! add any new fields here and in LineMainDtl
else
    include "src/callsuberr.inc"
  end try
end sub ! MainDtlHdr
! 
!--------------------------------------------------------------------
Sub LineMainDtl()
! the routine to load string for the web
! all rol. set up already - the HEADER IS SENT ABOVE
! commodity code read
! prod code & prodwhse read or set up
! futcost already gotten
! Fleptr[4,1] is Last Price record (like from price call)
 Try
	Dim SUM$[4],PUM$[4],CUM$[4]
	Dim LPPUM$[4],LPCUM$[4],LPSUM$[4]
	Dim 1%,X1[9]
	Dim 2%,X2[9]
	Dim 3%,LPR,X3[9]

	! generate list
	If rol.NStkItem and elflag=0 ! new nonstk line
		rol.umsell=0;rol.umprice=0;rol.umcost=0
		SUM$=blank$;PUM$=blank$;CUM$=blank$
		rol.prodcode$="NONSTOCK"+Blank$
		if rol.linetype=3 let rol.prodcode$="Z"+blank$
	Else
		SUM$=xunit$(ROL.UMSell,ccc) ! u/m
		PUM$=xunit$(ROL.UMPrice,ccc) ! u/m
		CUM$=xunit$(ROL.UMCost,ccc) ! u/m
	Endif
	If rol.LineType=3 ! ZLINE
		rol.umsell=0;rol.umprice=0;rol.umcost=0
		SUM$=blank$;PUM$=blank$;CUM$=blank$
	Endif
	tmp$=clrtxtc$(e$,rol.Desc1$) ! chk/clr control chars
	WebStr$=rol.ProdCode$,fdel$,RTrim$(tmp$),fdel$ ! prod code & desc 1
	tmp$=clrtxtc$(e$,rol.Desc2$) ! chk/clr control chars
	WebStr$=WebStr$,RTrim$(tmp$),fdel$
	! whse available
	If rol.NStkItem or rol.LineType=3
		let X3[1]=0
	Else
	  If RTrim$(rol.prodcode$)<>""
		x2[9]=rol.whse \ if roh.ordtype=7 let x2[9]=roh.ConsWh
		X3[1]=getwhavail(e$,intco,PWC,rol.ProdCode$,X2[9])
	  Else
	    X3[1]=0
	  Endif
	Endif
	if rol.LineNum>0 and not(NonStk) and rol.UpdtStk
	  if not(credit) and roh.ordtype<>15 AND rol.qtyship>=0
!	    if roh.ordtype=4 ! backs out ordered
!		  if custom_customer$="MORRISETTE"
!			let X3[1]=X3[1]+rol.qtyship ! add back this order
!		  Else
!			let X3[1]=X3[1]+(rol.qtyord-rol.PrevQtyShip)
!		  Endif
!		Else
			! let X3[1]=X3[1]+rol.qtyship ! add back this order - per group - NO
			! they want available to be with curr ship taken out?
!		Endif
	  Endif
	Endif
	Cnvtu[0]=0;Cnvtu[1]=rol.UMSell;Cnvtu[2]=1
	CNVTA=X3[1] \ IF ROL.NUMout>0 let cnvta=x3[1]*rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$,RTrim$(SUM$),fdel$ ! whse avail / um
	WebStr$=WebStr$,Str$(ROL.UMSell),fdel$ ! avl um id
	! total(product) available
	If rol.NStkItem or rol.LineType=3
		let X3[2]=0
	Else
		X3[2]=getpravail(e$,intco,PRC,rol.ProdCode$)
	Endif
	if rol.LineNum>0 and not(NonStk) and rol.UpdtStk
	  if not(credit) and roh.ordtype<>15 AND rol.qtyship>=0
!	    if roh.ordtype=4 ! backs out ordered
!		  if custom_customer$="MORRISETTE"
!			let X3[2]=X3[2]+rol.qtyship ! add back this order
!		  Else
!			let X3[2]=X3[2]+(rol.qtyord-rol.PrevQtyShip)
!		  Endif
!		Else
			! let X3[2]=X3[2]+rol.qtyship ! add back this order - per group - NO
			! they want available to be with curr ship taken out?
!		Endif
	  Endif
	Endif
	Cnvtu[0]=0;Cnvtu[1]=rol.UMSell;Cnvtu[2]=1
	CNVTA=X3[2] \ if rol.numout>0 let cnvta=x3[2]*rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$,RTrim$(SUM$),fdel$ ! Prod avail & um
	WebStr$=WebStr$,Str$(ROL.UMSell),fdel$ ! avl um id
	
	cnvtu[0]=0;cnvtu[1]=rol.UMPrice;cnvtu[2]=2
	Cnvta=rol.UnitPrice \ if rol.umprice>0 and rol.numout>0 let cnvta=rol.unitprice/rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	if p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=x3
			let cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
	WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! Unit price
	! send upcharge as amount & type
	tmp$="%" \ if rol.UpChrg<0 let tmp$="$"
	Let X3=rol.UpChrg
	If tmp$="$" ! need convert to price um
		cnvtu[0]=0;cnvtu[1]=rol.UMPrice;cnvtu[2]=2
		Cnvta=ABS(X3)
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=x3
			let cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
	Endif
	WebStr$=WebStr$,Ltrim$(X3 Using PMask$),fdel$,tmp$,fdel$ ! upchrg & type
	WebStr$=WebStr$,Str$(rol.Whse),fdel$ ! warehouse
	cnvtu[0]=0;cnvtu[1]=rol.UMPrice;cnvtu[2]=2
	Cnvta=rol.NetPrice \ if rol.umprice>0 and rol.numout>0 let cnvta=rol.NetPrice/rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	if p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=x3
			let cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
	WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! net price
	WebStr$=WebStr$,RTrim$(PUM$),fdel$,Str$(rol.UMPrice),fdel$ ! price um & id
	cnvtu[0]=0;cnvtu[1]=rol.UMSell;cnvtu[2]=1
	Cnvta=rol.QtyOrd \ if rol.numout>0 let cnvta=rol.qtyord*rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! Qty Ord
	WebStr$=WebStr$,RTrim$(SUM$),fdel$,Str$(rol.UMSell),fdel$ ! sell um & id
	cnvtu[0]=0;cnvtu[1]=rol.UMCost;cnvtu[2]=2
	Cnvta=rol.UnitCost \ if rol.UMCost>0 and rol.numout>0 let cnvta=rol.UnitCost/rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	if p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=x3
			let cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
	WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! unit cost
	WebStr$=WebStr$,Str$(Cost_Lev[1]),fdel$ ! load cost security
	WebStr$=WebStr$,RTrim$(CUM$),fdel$,Str$(rol.UMCost),fdel$ ! Cost um & id
	! send upcharge as amount & type
	tmp$="%" \ if rol.LoadUpchrg<0 let tmp$="$"
	Let X3=rol.LoadUpchrg
	If tmp$="$" ! need convert to cost um
		cnvtu[0]=0;cnvtu[1]=rol.UMCost;cnvtu[2]=2
		Cnvta=ABS(X3)
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=x3
			let cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
	Endif
	WebStr$=WebStr$,Ltrim$(X3 Using PMask$),fdel$,tmp$,fdel$ ! upchrg & type
	IF rol.UMCutCost=-3 AND rol.QtyOrd LET CHBASE=(rol.CutCost/rol.QtyOrd) ELSE  LET CHBASE=rol.CutCost
	X3[4]=rol.UnitCost+CHBase
	X3[3]=X3[4]
	IF rol.LoadUpchrg ! has cost up
		IF rol.LoadUpchrg<0 ! $ amount
			X3[3]=x3[4]+Abs(rol.LoadUpchrg)
		Else ! percent
			X3[3]=X3[4]+(X3[4]*(rol.LoadUpchrg/100))
		Endif
	Endif ! X3[3]=NETCOST
	NETCOST=X3[3]
	X3=rol.ExtLoadShip ! FNR(rol.QtyShip*X3[3]) ! ext net cost
    if p61$[136,136]="Y"  and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=x3
			let cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fns(cnvca[0])
		endif
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! net cost exten
	! rol.ExtLoadShip=X3
	! rol.ExtShipAmt=FNR(rol.QtyShip*rol.NetPrice) ! ext price
	Let X3=rol.ExtShipAmt
	if p61$[136,136]="Y"  and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=x3
			let cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fns(cnvca[0])
		endif
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! net price exten
!if ucase$(userid$[1,3])="TXC" stop
	x3=0
	if rol.NetPrice ! NEEDS A PRICE
		X3=FNR(((rol.NetPrice-x3[3])/rol.NetPrice)*100)
	else
		if x3[3] let x3=-999999.99
	Endif
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! GP
	WebStr$=WebStr$,rol.ComdtyCode$," ",RTRIM$(CMC.CodeDescription$),fdel$ ! commod & desc
	cnvtu[0]=0;cnvtu[1]=rol.UMSell;cnvtu[2]=1
	Cnvta=rol.QtyBO \ if rol.numout>0 let cnvta=rol.QtyBo*rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! Qty BO
	cnvtu[0]=0;cnvtu[1]=rol.UMSell;cnvtu[2]=1
	Cnvta=rol.PrevQtyShip \ if rol.numout>0 let cnvta=rol.PrevQtyShip*rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! Qty Prev shipped
	cnvtu[0]=0;cnvtu[1]=rol.UMSell;cnvtu[2]=1
	Cnvta=rol.QtyShip 
	if roh.ordtype=15 let cnvta=rol.CurrRelQty ! chg to relqty?
	if rol.numout>0 let cnvta=cnvta*rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! Qty Ship (relqty)
	Let LPR=fleptr[4,1] ! sent last price record
	If LPR>0
		Read record #LPC,LPR,0;clp.;
		cnvtu[0]=0;cnvtu[1]=clp.UMPrice;cnvtu[2]=2
		Cnvta=clp.UnitPrice ! \ if clp.UMPrice>0 and rol.numout>0 let cnvta=clp.UnitPrice/rol.numout
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if p61$[136,136]="Y" and rol.currfact<>0 and x3<>0  !! need last price factors!  
				let cnvcu[0]=1
				let cnvcu[1]=0
				let cnvca[0]=x3
				If clp.currid=rol.currid and clp.currfact>0
					let cnvca[1]=clp.currfact
				else
					let cnvca[1]=rol.currfact
				endif
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let x3=fnq(cnvca[0])
			endif
		WebStr$=WebStr$,LTrim$(X3 Using PMask$) ! last price
		LPPUM$=xunit$(clp.UMPrice,ccc) ! u/m price
		WebStr$=WebStr$," /",RTrim$(LPPUM$) ! lp sell um
		if cost_lev[1]
		cnvtu[0]=0;cnvtu[1]=clp.UMCost;cnvtu[2]=2
		Cnvta=clp.UnitCost ! \ if clp.umcost>0 and rol.numout>0 let cnvta=clp.unitcost/rol.numout
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if p61$[136,136]="Y"  and rol.currfact<>0 and x3<>0  !! need last price factors!  
				let cnvcu[0]=1
				let cnvcu[1]=0
				let cnvca[0]=x3
				If clp.currid=rol.currid and clp.currfact>0
					let cnvca[1]=clp.currfact
				else
					let cnvca[1]=rol.currfact
				endif
				let cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let x3=fnq(cnvca[0])
			endif
		WebStr$=WebStr$,"  ",LTrim$(X3 Using PMask$) ! last cost
		LPCUM$=xunit$(clp.UMCost,ccc) ! u/m cost
		WebStr$=WebStr$," /",RTrim$(LPCUM$),fdel$ ! lp cost um (price/cost as one field)
		else
			webstr$=webstr$,fdel$
		Endif
		tmp$=PDate$(clp.OrdDate)
		WebStr$=WebStr$,tmp$ ! last date
!if ucase$(userid$[1,3])="TXC" stop
		x3=0
		if clp.UnitPrice! NEEDS A PRICE
			X3=FNR(((clp.UnitPrice-clp.UnitCost)/clp.UnitPrice)*100)
		else 
			if clp.UnitCost then let x3=-999999.99
		Endif
		if cost_lev[1]
		WebStr$=WebStr$,"  ",LTrim$(X3 Using QMask$),"%" ! GP %
		endif
		cnvtu[0]=0;cnvtu[1]=clp.UMSell;cnvtu[2]=1
		Cnvta=clp.Quantity ! \ if rol.numout>0 let cnvta=clp.Quantity*rol.numout
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		WebStr$=WebStr$,"  ",LTrim$(X3 Using QMask$) ! last Qty
		LPSUM$=xunit$(clp.UMSell,ccc) ! u/m Sell
		WebStr$=WebStr$," /",RTrim$(LPSUM$),fdel$ ! lp cost um (date/gp/qty as one field)
	Else
		Clear clp.
		tmp$=" ";tmp1$=" "
		if Int(rol.AltSupsd)=1 let tmp$="Substitute";tmp1$=rol.OrgProdCode$
		if Int(rol.AltSupsd)=2 let tmp$="Supersede";tmp1$=rol.OrgProdCode$
		if Int(rol.AltSupsd)=0 and fra(rol.AltSupsd)
			tmp$="Substitute";tmp1$="No LP Update"
		Endif
		WebStr$=WebStr$,tmp$,fdel$,tmp1$,fdel$ ! last price/date
	Endif
	tmp$=blank$;tmp$="" ! clear
	tmp$=chktagfle$()
	WebStr$=WebStr$,tmp$[1,1],fdel$ ! do notes exist!
	If P60$[42,42]<>"Y" ! NOT tax by line - so it's y/n only
		tmp$="N" \ if rol.TaxFlg let tmp$="Y"
		WebStr$=WebStr$,tmp$,fdel$ ! tax flag
	Else ! it's a tax code
		WebStr$=WebStr$,Str$(rol.TaxFlg),fdel$ ! tax code
	Endif
	!WebStr$=WebStr$,LTrim$(FutCost Using PMask$),fdel$ ! future cost
	X3=FUTCOST
	if p61$[136,136]="Y" and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=FutCost
			let cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
	endif
	WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! future cost
	x=rol.PriceOrigin;tmp$="0" ! zero is default
	IF X>1 AND X<14 AND X<>5 AND X<>9 AND X<>10 
		 LET tmp$="Special Price"                                               
	ENDIF 
	If rol.PriceOrigin>82 and rol.PriceOrigin<115 ! perm price
		let x=rol.priceorigin-100
		IF X>1 AND X<14 AND X<>5 AND X<>9 AND X<>10 
			LET tmp$="Special Price"                                               
		ENDIF 
	endif
	if rol.Contract>0 let tmp$=Str$(rol.Contract)
	WebStr$=WebStr$,tmp$,fdel$ ! sp contract
	WebStr$=WebStr$,Str$(rol.RebtContract),fdel$ ! rbt contract
	WebStr$=WebStr$,Str$(rol.Dept),fdel$ ! dept
	WebStr$=WebStr$,LTrim$(rol.LbsUnit Using PMask$),fdel$ ! wgt unit
	tmp$=Str$(rol.WgtFactor)
	call factorum(tmp$) ! get um for factor
	WebStr$=WebStr$,Str$(rol.WgtFactor),fdel$,Rtrim$(tmp$),fdel$ ! wgt factor & um
	WebStr$=WebStr$,LTrim$(rol.ExtNetWgt Using QMask$),fdel$ ! wgt ext
	tmp$=clrtxtc$(e$,rol.VendItemCode$) ! chk/clr control chars
	tmp$=UCase$(tmp$) ! uppercase
	WebStr$=WebStr$,RTrim$(tmp$),fdel$ ! vend item
	WebStr$=WebStr$,LTrim$(rol.CubeUnit Using PMask$),fdel$ ! cube unit
	tmp$=Str$(rol.CubeFactor)
	call factorum(tmp$) ! get um for factor
	WebStr$=WebStr$,Str$(rol.CubeFactor),fdel$,Rtrim$(tmp$),fdel$ ! cube factor & um
	X3=0
	If rol.CubeFactor let X3=FNR(ABS(rol.QtyShip*rol.CubeUnit/rol.CubeFactor))
	WebStr$=WebStr$,LTRim$(X3 Using QMask$),fdel$ ! cube ext (no rol. var)
	WebStr$=WebStr$,LTrim$(rol.LineDiscPct Using "###.##"),fdel$ ! line disc % (what of $?)
	WebStr$=WebStr$,Str$(rol.LineNum),fdel$ ! line Number (would be zero at first?)
	If elflag=9 ! existing line send flag
		WebStr$=WebStr$,Str$(rol.NewPPFlg),fdel$ ! perm/1 time price
    Endif ! if include type on new also - endif here
	tmp$="STK";X2=rol.LineType
	if rol.NStkItem LET TMP$="NSTK"
	if rol.NStkItem AND X2=3 LET TMP$="MSG"
	IF X2=1 let tmp$="INV"
	If X2=2 LET TMP$="FIN"
	! ot 19 - if header flag=0 or prevship=ordered - it is closed
	if roh.ordtype=19 and Rol.QtyOrd<>0 and rol.PrevQtyShip=rol.QtyOrd let tmp$="CLSD" ! ALL SHIPPED-PARTIAL
	if roh.ordtype=19 and roh.BOCTR<>0 and roh.ot19comp=0 let tmp$="CLSD" ! FINAL
	WebStr$=WebStr$,RTRIM$(TMP$),FDEL$ ! line type
	!Endif ! is no type on new line - endif here
	! per web - send all flags & current factors NOW
	
	X3=UMtoFactor(ROL.UMSell)
	Webstr$=Webstr$,Str$(X3),fdel$
	X3=UMtoFactor(ROL.UMCost)
	Webstr$=Webstr$,Str$(X3),fdel$
	X3=UMtoFactor(ROL.UMprice)
	Webstr$=Webstr$,Str$(X3),fdel$
	if rol.NStkItem ! make sure flags correct
		pw.ChkBrknQty$="N";pr.MBFlg$="B"
		pr.SerNoTrack$="N";pr.CatchwgtItem$="N"
		pr.LotCtrl$="N";pr.RollLbItem$="N"
		! pw.DNReordFlg=1
	Endif
	if pw.ChkBrknQty$<>"N" let pw.ChkBrknQty$="Y" ! Y is default
	if roh.ordtype=19 and roh.BOCTR<>0 and roh.ot19comp=0 let pw.ChkBrknQty$="N" ! closed
	WebStr$=Webstr$,pw.ChkBrknQty$,fdel$,pr.MBFlg$,fdel$ ! chk brkn, make/buy
	if rol.UpdtStk=0 let pr.LotCtrl$="N" ! pr.SerNoTrack$="N"; ! can't do if no stk
	if roh.ordtype=19 and roh.BOCTR<>0 and roh.ot19comp=0 let pr.SerNoTrack$="N" ! closed
	WebStr$=WebStr$,pr.SerNoTrack$,fdel$,pr.CatchwgtItem$,fdel$ ! s/n, catchwgt
	WebStr$=WebStr$,pr.LotCtrl$,fdel$,pr.RollLbItem$,fdel$ ! lotcontrol, roll/lb
	tmp$=XUNIT$(pr.UMBrknQty,ccc)
	WebStr$=WebStr$,Str$(pw.DNReordFlg),fdel$,RTrim$(tmp$),fdel$ ! DNReord, brkn um
	if not(rol.NStkItem) and prr>0 ! need re-read for brknumfactor
		read record #PRC,PRR,0;pr.; ! as may not be used as a line um
	Endif
	X3=UMtoFactor(pr.UMBrknQty)
	WebStr$=WebStr$,Str$(pr.UMBrknQty),fdel$,Str$(X3),fdel$ ! um id, um factor
	if not(rol.NStkItem) and prr>0 ! need reset for rest of routine back to line ums
		Call SetPRtoRol() ! reset to line details
	Endif
	tmp$="N" \ if rol.UpdtStk=1 let tmp$="Y"
	webstr$=webstr$,tmp$,fdel$	! stock update
	! if roh.ordtype=15 ! send relqty as sep field?
	tmp$="N" \ if rol.KitDesignation$="KIT" let tmp$="Y"
	if credit let tmp$="N"
	if roh.ordtype=19 and roh.BOCTR<>0 and roh.ot19comp=0 let tmp$="N" ! turn off kits - closed
	webstr$=webstr$,tmp$,fdel$ ! kit y/n
	tmp$="" ! KIT ACTION
	if rol.KitDesignation$="KIT" ! see if action needed
	   if not(credit)
			tmp$=chkkit$() ! function returns string
	   Endif
	Endif
	if roh.ordtype=19 and roh.BOCTR<>0 and roh.ot19comp=0 let tmp$="" ! closed - no action
	webstr$=webstr$,tmp$,fdel$ ! kit action - (WEB FLAG)
	webstr$=webstr$,Str$(rol.PriceOrigin),fdel$,Str$(rol.CostOrigin),fdel$
	cnvtu[0]=0;cnvtu[1]=rol.UMSell;cnvtu[2]=1
	Cnvta=rol.BORelQty \ if rol.numout>0 let cnvta=rol.BORelQty*rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! Qty BackOrd Rel'd
	webstr$=webstr$,Str$(rol.numout),fdel$ ! cutting out
	cnvtu[0]=0;cnvtu[1]=rol.umcost;cnvtu[2]=2
	Cnvta=NETCOST \ if rol.UMCost>0 and rol.numout>0 let cnvta=NETCOST/rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	if p61$[136,136]="Y"  and rol.currfact<>0 and x3<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=x3
			let cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=fnq(cnvca[0])
		endif
	WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! net cost
	if roh.ordtype=4 ! send bill fields
		cnvtu[0]=0;cnvtu[1]=rol.umsell;cnvtu[2]=1
		cnvta=rol.CurrBillQty \ if rol.umsell>0 and rol.numout>0 let cnvta=rol.CurrBillQty*rol.numout
		amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		webstr$=webstr$,LTrim$(amount using Qmask$),fdel$ ! currbillqty
		cnvta=rol.PrevQtyBill \ if rol.umsell>0 and rol.numout>0 let cnvta=rol.PrevQtyBill*rol.numout
		amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		webstr$=webstr$,LTrim$(amount using Qmask$),fdel$ ! prevbillqty
	Else
		webstr$=webstr$,"",fdel$,"",fdel$ ! curr/prev bill qty
	Endif
	tmp$="N" \ if custom_customer$="MORRISETTE" and Int(pr.UdNumeric)<>0 let tmp$="Y"
	! If Int(pr.UdNumeric)<>0 tmp$="Y" ! TEMP - FOR .NET TEST ONLY *****************
	webstr$=webstr$,tmp$,fdel$ ! highlight product 
	tmp$="N" \ if holdforpo and (source<219 or source=2082) and rol.HldForPo$="Y" let tmp$="Y"
	webstr$=webstr$,tmp$,fdel$ ! hold for po
	tmp$="N" ! RASL flag - done for task 45530
	Whse=rol.Whse
	If Whse<1 or Whse>99 let whse=roh.Wh
	WHIR=Whse-1
	if whse>0 and whse<=99
		Read record #WHI,WHIR,0;WHI.;
	else
		clear whi.
	endif
	if p9$[41,41]="W" let rasl=whi.useRasl
	if p9$[41,41]="Y" let rasl=1
	if Rasl ! using rasl - is update stock set
		if rol.UpdtStk let tmp$="Y" ! can only be yes if update stock!
	endif
	If Source=207 or source=239 let tmp$="N" ! INQUIRY ONLY!
	IF credit and tmp$="Y" ! credits and using RASL
		IF Not(WHI.PoRtsDflt) Let tmp$="N" ! not allowing RTS location change
	Else
		LET TMP$="N" ! ONLY CM'S (per the group(EER & DD) DO NOT SHOW RASL ICON ANYWHERE ELSE!)
	Endif
	webstr$=webstr$,tmp$,fdel$ ! rasl
	! new - task 56199 - Add Sugg price to Main Detail (for Custom View)
	IF LPR>0 and (P9$[13,13]="M" or P9$[13,13]="G") ! can only give sugg price if last price!
		x3=0
		IF clp.UnitCost ! must have for sugg price
			! mxline = UWORK[4]*(1+((LPC2[1]-LPC2[2])/LPC2[2]) (Uwork[4]=Unitcost in costum)
			x3=rol.UnitCost*(1+((clp.UnitPrice-clp.UnitCost)/clp.UnitCost)) ! we use base!
		Endif ! of get sugg price
		If rol.UpChrg ! has up - add it in
			If rol.UpChrg<0 ! it's a $
				x3=x3+Abs(rol.UpChrg)
			Else ! it's %
				x3=x3+(x3*(rol.UpChrg/100))
			Endif
		Endif ! of upchrg it
		cnvtu[0]=0;cnvtu[1]=rol.UMPrice;cnvtu[2]=2
		cnvta=x3 ! \ if rol.umprice>0 and rol.numout>0 let cnvta=x3/rol.numout
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if p61$[136,136]="Y"  and rol.currfact<>0 and amount<>0 !  
			let cnvcu[0]=1
			let cnvcu[1]=0
			let cnvca[0]=amount
			let cnvca[1]=rol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=cnvca[0]
		endif
		IF P61$[50,50]="Y" ! price rounding
			x2=cmc.PriceRoundFactor
			if x2>0 and x2<9
				Call "pricernd",x2,Amount
			Endif
		Endif 
		WebStr$=WebStr$,LTrim$(Amount using PMask$),fdel$ ! as price um
		!WebStr$=WebStr$,Str$(X3),fdel$ ! as base (line um chg'd?)
	Else
		WebStr$=WebStr$,"0",fdel$ ! no sugg
	Endif
	! edit price 
	let tmp$="Y"
	if ucf$[6,6]="N" and roh.ordtype=1 and not(credit)
		if rol.priceorigin>82 and rol.priceorigin<115
			let tmp$="N"
		endif
		if rol.priceorigin=3 let tmp$="N" !- promotion (product)                    
        if rol.priceorigin=6 let tmp$="N" !- contract/special all products                                     
        if rol.priceorigin=7 let tmp$="N" !- promotion (commodity)               
        if rol.priceorigin=8 let tmp$="N" !- promotion (all products)            
		if rol.priceorigin=11 let tmp$="N" ! - size promotion                                                    
		if rol.priceorigin=12 let tmp$="N" !- size special/contract                                             
		if rol.priceorigin=13 let tmp$="N" !- fixed price customer contract                                     
		if rol.priceorigin=15 let tmp$="N" !- cost grp special price   
		if rol.priceorigin=16 let tmp$="N" !- cost grp promotion
	endif
	webstr$=webstr$,tmp$,fdel$
	List$[row]=WebStr$
	Let row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	if debugdetail
		dmsg$="Main Detail "+Str$(Orderno)+"-"+Str$(LineNo)+" "+rol.prodcode$+Message$ \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
 end try
end sub ! LineMainDtl
! 
!--------------------------------------------------------------------
Sub getordlines()
! go thru passed order and send existing lines back
 Try
	Dim KOL$[60],KPW$[60],KCM$[50],KLP$[60]
	Dim ZOL$[60]
	Dim 1%,FCDays,cnvtu[2],elflag
	Dim 2%,OrderNo,row,tmpcnt,JDate[5],FDate
	Dim 3%,OLR,FutCost,CNVTA,Amount

	Dim ZROL. as rolnew ! for zlines (get data for it before sending line)
	if debugdetail
		dmsg$="Start get Existing Lines" \ Call updatelog(debug)
	Endif
	MaxLines=50 ! per front end - send these # of lines at a time
	Read #ctlc,2,198;FCDays; ! days to check future cost
	If FCDays<1 or FCDays>999 or Fra(FCDays) Let FCDays=30 ! check range
	ReturnStatus=1
	Message$="OK"
	Call DXGet("ORDERID",tmp$)
	X2=tmp$
	If X2<1 or X2>999999 or Fra(X2) ! not valid
		ReturnStatus=0
		Message$="ORDER NOT PASSED"
		goto golDone:
	Endif
	OrderNo=x2
	OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
	e$=""
	If OHR<=0 ! not found
		ReturnStatus=0
		Message$="ORDER NOT FOUND"
		goto golDone:
	Endif
	Call GetCust()
	CREDIT=0 \ if ros.status=32 let credit=1
	if credit and roh.ShipType=3 let cost_lev[1]=0 ! no cost on cm price error
	! add a break after x lines - so need a beginning line #
	Call dxget("BEGLINE",tmp$)
	Let StrtLine=tmp$
	if StrtLine<0 or StrtLine>999 or fra(StrtLine)
		ReturnStatus=0
		Message$="Starting Line Invalid"
		goto golDone:
	Endif
	! set list header (SIMILAR TO PRODDETAIL ACTION!)
	elflag=9 ! existing Line Flag (for detail to string) as add'l fields needed
		Clear List$[]
		List$[0]=bsdel$,"LINEDETAIL",fdel$
		call MainDtlHdr() ! set webstr$ for main header
		List$[1]=WebStr$
		Row=2;tmpcnt=maxcnt
	! okay - see if lines
	KOL$=" ",KOL$;NumLines=0
	KOL$=OrderNo Using "######"
	if dooneline or (DoPart and StrtLine>0)
		x2=dooneline \ if DoPart and StrtLine>0 let x2=StrtLine
		let KOL$[7]=x2-1 using "###" ! so next line is it
		let kOL$[10]=" "
	Endif
	! what if start with or only zlines on order??
	Do
		OLR=filegetrolz(e$,OLC,">",1,kol$,rol.)
		clear e$
		If OLR<0 exit do
		X2=kol$[1,6] \ if x2<>orderno exit do
		if (roh.OrdType=21 or roh.OrdType=22) and kol$[7,9]="   " goto bpldtl ! ot 21/22
		x2=kol$[7,9] \ if dooneline and x2<>dooneline exit do ! only want 1 line
		if doPart and NumLines>=MaxLines ! web side wants xx lines at a time
			let returnstatus=5 ! signal that more to come - send this lines data
			message$="ORDERID="+Str$(OrderNo)+"&BEGLINE="+Str$(X2)+"&" ! BEGKEY="+Kol$
			Exit do
		Endif
		NonStk=rol.NStkItem
		ZLine=0 \ if rol.LineType=3 and NonStk let ZLine=1 ! need for later
		! get/read appropriate records (prod,prodwhse,comm,lastprice
		If Not(NonStk) ! it's a prod
			PRR=rol.PDRecNum
			Read record #PRC,PRR,0;PR.;
			if roh.ordtype=8 or roh.ordtype=16
			  If Roh.ConsWh>0 and roh.conswh<100
				Let TPWKey$=" ",tpwKey$
				TPWkey$[1,12]=rol.prodcode$+Blank$
				TPWKey$[13]=ROH.ConsWh Using "##"
				call chktowhse(TPWKey$,pr.PrimVend)
			  Endif
			Endif
			KPW$=" ",KPW$
			Kpw$=rol.prodcode$+rol.whse Using "##"
			IF roh.ordtype=7 let Kpw$=rol.prodcode$+ROH.ConsWh Using "##"
			PWR=filegetprodwhse(e$,PWC,"=",1,KPW$,pw.)
			clear e$
			if PWR<0 ! not found
				Clear pw.
				If PWR=-1 ! not found - add?
					E$="";x3=kpw$[13,14]
					if roh.ordtype=7
						x3[1]=rol.whse/100
						x3=x3+x3[1]
					Endif
					Whbld[0]=PWC;Whbld[1]=X3;WhBld[2]=pr.PrimVend
					if x3<>1 let Whbld[1]=X3+.01 ! fra=copy whse 1
					Call mxwhcreate(e$,IntCo,rol.PRODCode$,WHBLD[])
					PWR=Whbld[2]
					Read record #PWC,PWR,0;PW.;
				Endif
			Endif
			If rol.ComdtyCode$="" or rol.ComdtyCode$=Blank$[1,4]
				rol.ComdtyCode$=pr.ComdtyCode$
			Endif
		Else
			Clear pr.
			Clear pw.
		Endif
		! always set up pr. w/line factors
		LineNo=rol.LineNum
		Call SetPRtoRol()
		KCM$=" ",KCM$
		KCM$=rol.ComdtyCode$+Blank$[1,4];kcm$[5]=""
		CMR=filegetcommhead(e$,cmc,"=",1,KCM$,cmc.)
		clear e$
		If CMR<1 Clear cmc.
		KLP$=" ",KLP$ ! look for lastprice record
		klp$[1,6]=ROH.custnum using "######"
		X2=rol.dept \ if P9$[44,44]<>"Y" let x2=0
		KLP$[7,10]=X2 Using "####"
		If Not(NonStk)Let KLP$[11]=rol.prodcode$
		If NonStk Let KLP$[11]=rol.VendItemCode$ ! is diff on nonstks!
		tmp$=KLP$ ! only know/can send up to prod
		LPR=filegetlastprice(e$,LPC,">",1,KLP$,CLP.)
		clear e$
		If klp$[1,22]<>tmp$[1,22] let lpr=-1
		If LPR<=0 clear clp.
		FlePtr[4,1]=LPR ! is used this way elsewhere
		FutCost=0
		If Not(NonStk) ! can only call price for futcost on stock items
			Call SetUpSpecs() ! get specs info for fut cost
			! future cost = cost as of xx days from today (specs[5] chg)
			JDate=TIM(6)+FCDays ! ## days from today
			tmp$=JDate$(jdate) ! from ddddd to MM/DD/YYYY
			tmp1$=Formatdate2$(tmp$) ! now MM/DD/YYYY to YYYYMMDD
			Let FDate=tmp1$[3,8] ! just need yymmdd
			Let Specs[5]=0-FDate
			Call getprice() ! call price w/all entries above
			If Specs[0]=0 ! okay
				Let X3=Specs[17]
				cnvtu[0]=0;cnvtu[1]=rol.UMCost;cnvtu[2]=2
				Cnvta=X3 \ if rol.umcost>0 and rol.numout>0 let cnvta=x3/rol.numout
				FutCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			Endif
		Endif ! of stk item - get future cost
		if roh.OrdType=8 or roh.OrdType=16 ! cons/trans - no price/cost
			rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
			rol.UnitPrice=0;rol.CutChrg=0;rol.CutCost=0
			rol.LineDisc=0;rol.ExtOrdAmt=0;rol.ExtShipAmt=0
			rol.LineDiscPct=0;rol.ExtCutChg=0;rol.ExtCutCost=0
			rol.ExtLoadShip=0;rol.ExtLoadOrd=0;rol.NetPrice=0
			rol.TaxAmt=0;rol.LoadUpchrg=0;rol.UpChrg=0
		Endif
		If p61$[46,46]="Y" and Credit and roh.shiptype=3 ! price fix - no cost
			rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
			rol.CutCost=0;rol.ExtCutCost=0;rol.ExtLoadShip=0;rol.ExtLoadOrd=0
			rol.LoadUpchrg=0
		Endif
		If roh.OrdType=37  ! "EVAP Ship - NO Price - any order in here
			If Not(Credit) Or (Credit And roh.ShipType=16)
				Let rol.UnitPrice=0;rol.NetPrice=0;rol.CutChrg=0
				Let rol.LineDisc=0;rol.LineDiscPct=0;rol.UpChrg=0
				rol.ExtOrdAmt=0;rol.ExtShipAmt=0;rol.ExtCutChg=0
			Endif
		Endif
		If roh.OrdType=36 ! "EVAP Billing - NO Cost - Any type order
			If Not(Credit) Or (Credit And roh.ShipType=16)
				Let rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
				Let rol.CutCost=0;rol.ExtCutCost=0;rol.ExtLoadShip=0;rol.ExtLoadOrd=0
				rol.LoadUpchrg=0;NetCost=0
			ENDIF
		Endif
		Call LineMainDtl() ! set up web string
		NumLines=NumLines+1
	 BPLDTL: ! bypass line (ot21/22)
	Loop ! done with order
	List$[row]=esdel$ ! finished
	e$=""
	call AddToStr(e$,rstr$,List$[])
	GolDone: ! finish ord line get
	! status section
	if debugdetail
		dmsg$="Existing Lines "+Str$(Orderno)+" TTL "+Str$(NumLines)+" "+Message$ \ Call updatelog(debug)
	Endif
	if not(dooneline)
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
	Endif ! don't send on one line get
	! 
	! call programdump("/tmp/ollog6!","")
 else
    include "src/callsuberr.inc"
 end try
end sub ! getordlines
! 
!--------------------------------------------------------------------
sub getcomplist()
! get a list of complementary items for a product
! output like scan list

 Try
	Dim 1%,OType
	Dim 2%,Whse
	Dim 3%,tmpcnt
	
	Call DXGet("PRODID",tmp$)
	Prod$=UCase$(tmp$)
	Prod$=Prod$+Blank$
	If Len(Prod$)>12 let prod$[13]=""
	Call DXGet("WHSE",tmp$)
	Whse=tmp$
	
	ReturnStatus=1
	Message$="OK"
	If Whse<1 or whse>99 or Fra(whse)
	  ReturnStatus=0
	  Message$="WAREHOUSE NOT PASSED"
	  Goto ComplDone ! needs to be?
	Endif
	ProdKey$=Prod$
	ProdKey$[13]="" ! cut to length
	PRR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.)
	clear e$
	If PRR<=0 ! has to exist!
		ReturnStatus=0
		Message$="PRODUCT NOT FOUND"
		Goto ComplDone ! has to be
	Endif
	Call DXGet("ORDTYPE",tmp$)
	Let OType=tmp$ \ if otype<0 Or OType>38 Let OType=0

	Call CompIList(e$,IntCo,List$[],maxcnt,ctlc,prc,whc,ccc,Prod$,Whse,OType)
	E$=""
	call AddToStr(e$,rstr$,List$[])
	ComplDone: ! finish Complist get
	! status section
	if debugdetail
		dmsg$="Complementary List "+prod$+Message$ \ Call updatelog(debug)
	Endif
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
	! 
	! call programdump("/tmp/ollog7!","")
 else
    include "src/callsuberr.inc"
 end try
end sub ! getcomplist
! 
!--------------------------------------------------------------------
Sub setpricelist()
! wants a list of prices (List, Bracket/Break)
 Try
	Dim 3%,Bprice[10],UPrice[10]
		Dim 3%,Bupchrg
		Call DXGet("PRODID",prod$) \ prod$=UCase$(prod$)
		Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
		ProdKey$=Prod$
		PrR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.) ! product mode=2 dir=1
		clear e$
			!
			! initialize status
		If PrR<0 ! Product record not found
			 clear PR.
			 ReturnStatus=0
			 Message$="Error, Product not found"
		else ! continue with lists
			Returnstatus=1
			Message$="OK"
			Call DXGet("ORDERID",tmp$)
			if tmp$="" 
				let Message$="ORDER # MISSING"
				Let ReturnStatus=0
				Goto PLstSendDone:
			Endif
			OrderNo=tmp$
			If OrderNo>0 and OrderNo<999999 and Not(Fra(OrderNo))
			OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
			e$=""
				If OHR<=0 ! no order found
					Let Message$="ORDER # NOT FOUND"
					Let ReturnStatus=0
					Goto PLstSendDone:
				Endif
			Endif
			if roh.ordtype=15 and roh.boctr<>0 ! no price change
				returnstatus=0
				message$="Cannot change price!"
				Goto PLstSendDone
			Endif
			Call GetCust()
			Call DXGet("WHSE",tmp$) ! if line whse <> header
			Whse=tmp$ \ if whse<1 or Whse>99 Let Whse=roh.wh
			if roh.ordtype=7 let whse=ROH.ConsWh ! prices from "to" whse
			Call DXGet("UMPRC",tmp$) ! price um id
			!If tmp$[1,1]>"9" ! sent text?
				R=getumrec(e$,CCC,tmp$,IntCo,PR.)
				If R<>0 let tmp$=Str$(R)
			!Endif
			let PRUM=tmp$ \ if prum=0 Let prum=pr.UMPriceDefault
			Call DXGet("PTYPE",tmp$)
			tmp$=UCASE$(tmp$)
			tmp$=RTrim$(tmp$) ! uppercase and trimmed
			If tmp$<>"LIST" and tmp$<>"BRACKET" ! other options?
				MessagE$="PRICE OPTION MISSING"
				ReturnStatus=0
				Goto PLstSendDone:
			Endif
			Field$[0]=tmp$
			clear tmp$
			call dxget("QTYOUT",tmp$)
			pnumout=tmp$
			if pnumout<0 or pnumout>999 or fra(pnumout)
				returnstatus=0
				message$="INVALID QTY OUT"
				GOTO PLstSendDone
			endif
			! call programdump("/tmp/ollog3!","")
			! okay now get the prices from call price
			Clear specs[] ! clear specs vars
			Clear List$[]
			List$[0]=bsdel$,"PRICES",fdel$
			List$[1]="Name",fdel$,"Price",fdel$,"PricewithUp",fdel$
			Row=2
			tmpcnt=maxcnt
			! need certain records
			tmp$=" ",tmp$;tmp$=prod$
			tmp$[13]=Whse Using "##"
			PWR=filegetprodwhse(e$,pwc,"=",1,tmp$,pw.)
			clear e$
			tmp$=" ",tmp$;tmp$=Pr.ComdtyCode$+Blank$[1,4];tmp$[5]=""
			CMR=filegetcommhead(e$,CMC,"=",1,tmp$,cmc.)
			clear e$
			fleptr[1,1]=PRR;fleptr[2,1]=PWR;fleptr[3,1]=CMR ! prod,prodwh,comm
			if pr.PriceUpchrg ! has data setup bupchrg
				If pr.PriceUpchrgType=0 ! it's %
					Bupchrg=pr.PriceUpchrg
				Endif
				If pr.PriceUpchrgType=1 ! it's $ (in upum)
					cnvtu[0]=pr.UMUpChrg;cnvtu[1]=0;cnvtu[2]=6 ! to base no round was =2
					cnvta=pr.PriceUpchrg
					Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
					Bupchrg=0-amount ! baseum uc
				Endif
			Endif ! has u/c data
			If Field$[0]="LIST"
				! see if specs[0]=6 does as it says (costs & ALL LP's) DOES NOT WORK!
				Specs[0]=1;specs[1]=1;specs[2]=1;Specs[3]=roh.CustNum
				Specs[4]=whse;specs[5]=roh.OrdDate;specs[6]=roh.Dept;specs[7]=roh.PriceType
				Specs[8]=roh.OrdType;Specs[9]=1;Specs[13]=pr.UMSellDefault
				if source=251 and pr.UMPrdtnDefault<>0 let Specs[13]=pr.UMPrdtnDefault
				Specs[14]=prum;specs[15]=pr.UMCostDefault
				For X=1 to 6 ! needs mode 1
					Specs[0]=1;Specs[11]=x;Specs[20]=0
					Call GetPrice() ! standard price call
					If Specs[0]=0 let Bprice[x]=Specs[20];UPrice[x]=specs[20]
				Next X
					
			Endif ! want list prices
			If Field$[0]="BRACKET" ! breaks or brackets
				prctype=pr.PriceType
				! specs[0]=2 or 3 and Specs[11]=level (1-10)
				If Prctype=1 ! matrix
					Specs[0]=0;specs[1]=1;specs[2]=1;Specs[3]=roh.CustNum
					Specs[4]=whse;specs[5]=roh.OrdDate;specs[6]=roh.Dept;specs[7]=roh.PriceType
					Specs[8]=roh.OrdType;Specs[9]=1;Specs[13]=pr.UMSellDefault
					if source=251 and pr.UMPrdtnDefault<>0 let Specs[13]=pr.UMPrdtnDefault
					Specs[14]=prum;specs[15]=pr.UMCostDefault
					Call GetPrice() ! NEED SYSTEM PRICE/COST?
					BPrice[0]=Specs[20];UPrice[0]=Specs[17]
					For Blvl=1 to 10
						Specs[0]=2;Specs[11]=BLvl;Specs[20]=BPrice[0];specs[23]=0
						Call GetPrice() ! standard price call
						If Specs[0]=0 Let BPrice[blvl]=Specs[23];UPrice[blvl]=Specs[23] ! Net?
						! if blvl=2 call programdump("/tmp/ollog2!","")
					Next Blvl
				Endif
				If Prctype=2 ! 10 bracket
					Specs[0]=3;specs[1]=1;specs[2]=1;Specs[3]=roh.CustNum
					Specs[4]=whse;specs[5]=roh.OrdDate;specs[6]=roh.Dept;specs[7]=roh.PriceType
					Specs[8]=roh.OrdType;Specs[9]=1;Specs[13]=pr.UMSellDefault
					if source=251 and pr.UMPrdtnDefault<>0 let Specs[13]=pr.UMPrdtnDefault
					Specs[14]=prum;specs[15]=pr.UMCostDefault
					Call GetPrice() ! NEED SYSTEM PRICE/COST?
					BPrice[0]=Specs[20];UPrice[0]=Specs[17]
					For Blvl=1 to 10
						Specs[0]=3;Specs[11]=BLvl;Specs[20]=BPrice[0]
						Call GetPrice() ! standard price call
						If Specs[0]=0 Let BPrice[blvl]=Specs[23];UPrice[blvl]=Specs[23] ! net?	
					Next Blvl
				Endif
				
			Endif ! break/bracket
			! got prices - now up 'em (UP Was IN BREAKUM, Now BASE)
			If BUpchrg>0 ! apply %
				for x=1 to 10
					If UPrice[x] LET UPrice[x]=UPrice[x]+(UPrice[x]*(Bupchrg/100))
				next x
			Endif
			If BUpchrg<0 ! apply $
				For x=1 to 10
					If UPrice[x] LET UPrice[x]=UPrice[x]+ABS(BUpchrg)
				Next x
			Endif
			SysRnd=0
			if p61$[50,50]="Y" and cmc.PriceRoundFactor Let SysRnd=cmc.PriceRoundFactor
			! finally send it out
			tmp$="LIST PRICE "
			If Field$[0]="BRACKET" let tmp$="LEVEL "
			For X=1 to 10
				WebStr$=tmp$,Str$(x),fdel$ ! name
				cnvtu[0]=0;cnvtu[1]=prUM;cnvtu[2]=2
				cnvta=BPrice[x];Amount=0
				if prum>0 and pnumout>0 let cnvta=bprice[x]/pnumout
				if cnvta let Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				if p61$[136,136]="Y"  and rol.currfact<>0 and amount<>0 !
					let cnvcu[0]=1
					let cnvcu[1]=0
					let cnvca[0]=amount
					let cnvca[1]=rol.currfact
					call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
					let x3=fnq(cnvca[0])
				endif
				If SysRnd Call "Pricernd",SysRnd,amount ! needs rounding?
				X3=Amount
				WebStr$=WebStr$,LTrim$(X3 using PMask$),fdel$ ! price
				cnvtu[0]=0;cnvtu[1]=prUM;cnvtu[2]=2
				cnvta=UPrice[x];Amount=0
				if prum>0 and pnumout>0 let cnvta=UPrice[x]/pnumout
				if cnvta let Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				if p61$[136,136]="Y"  and rol.currfact<>0 and amount<>0 !
					let cnvcu[0]=1
					let cnvcu[1]=0
					let cnvca[0]=amount
					let cnvca[1]=rol.currfact
					call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
					let x3=fnq(cnvca[0])
				endif
				If SysRnd Call "Pricernd",SysRnd,amount ! needs rounding?
				X3=Amount
				WebStr$=WebStr$,LTrim$(X3 using PMask$),fdel$ ! price w/uc
				List$[row]=WebStr$
				row=row+1
				if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
				If Field$[0]="LIST" and x=6 let x=11 ! only 6 list prices
			Next X
		
			List$[row]=esdel$ ! finished
			e$=""
			call AddToStr(e$,rstr$,List$[])
		PLstSendDone: ! finished
		Endif ! of valid prod
		! status section
	  if debugdetail
		dmsg$="Prices "+Str$(Orderno)+" "+prod$+Field$[0]+" "+Message$ \ Call updatelog(debug)
	  Endif
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
 else
    include "src/callsuberr.inc"
 end try
end sub ! setpricelist
! 
!--------------------------------------------------------------------
Sub SetNewProdline()
! take pad list - send line details
 Try
	Call DXGet("ORDERID",tmp$)
		if tmp$="" 
			let e$="ORDER # MISSING"
			Let ReturnStatus=0
			Goto PDSendDone:
		Endif
		OrderNo=tmp$
		If OrderNo>0 and OrderNo<999999 and Not(Fra(OrderNo))
			OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
			e$=""
			If OHR<=0 ! no order found
				Let e$="ORDER # NOT FOUND"
				Let ReturnStatus=99
				Goto PDSendDone:
			Endif
		Endif
		if roh.ordtype=15 and roh.boctr<>0 ! no add once accepted!
			Returnstatus=0
			Message$="Invoice has been accepted. No new lines allowed"
			Goto PDSendDone:
		Endif
		if roh.ordtype=19 and roh.BOCtr<>0 and roh.Ot19Comp=0 ! FINAL - NO ADD!
			Returnstatus=0
			Message$="Final Bill of Order. No new lines allowed"
			Goto PDSendDone:
		Endif
		if roh.ordtype=20 ! freight invoice
			Returnstatus=0
			Message$="Order Type=Freight Invoice. No lines are allowed"
			Goto PDSendDone:
		Endif
		Call GetCust()
		Call DXGet("TTLPRODS",tmp$)
		Let NumProds=tmp$
		if NumProds<1 ! HAS TO BE AT LEAST 1!
			let e$="NO NUMBER OF ITEMS SENT"
			Let ReturnStatus=0
			Goto PDSendDone:
		Endif
		ReturnStatus=1
		Message$="OK" 
		Credit=0 \ if ros.status=32 let credit=1
		! set list header
		Clear List$[]
		clear slist$[]
		clear tlist$[]
		!DOCPI=0 \ if userid$[1,4]="JIMS" or userid$[1,2]="S8" let docpi=1 ! temp for test
		if p61$[111,111]="Y" and not(credit) ! and DOCPI=1
			cpiflag=0;tmpcnt=maxcnt;Custno=roh.CustNum
			clear list$[]
			! ok - make a call & check results if exceptions - status=11 and results in list$
			Call cpiordchk(e$,intco,cpiflag,tmpcnt,custno,CUC,CUR,NumProds,OHC,OHR,List$[])
			call dxget("CPIFINAL",tmp$)
			if ucase$(rtrim$(tmp$))="Y"
				! OK - here's the dealeo...  If this parameter is set, there
				! was a CPI exception with this line that has been
				! approved.  We have just done the check to see which exception we
				! ran into.  If it's customer not on contract we need to auto-add
				! them and continue on (which is done in the cpiordchk).
				clear list$[] ! clear whatever is sent
				GOTO CPIADONE ! final list coming
			end if
			if cpiflag=0 ! all ok
				clear list$[] ! clear whatever is sent
				goto CPIADone ! ALL OK
			Endif
			ReturnStatus=11
			message$="CPI Exceptions"
			call AddToStr(e$,rstr$,List$[])
			goto PDSendDone ! bypass rest
		CPIADONE: ! finished with cpi
		Endif
		ELFlag=0 ! NOT EXISTING LINES
		List$[0]=bsdel$,"PRODUCTDETAIL",fdel$
		call MainDtlHdr() ! set webstr$ for main header
		List$[1]=WebStr$
		Row=2;tmpcnt=maxcnt
		! second list 
		slist$[0]=bsdel$,"OT15LIST",fdel$  ! key is PRODID
		SList$[1]="PRODID",fdel$,"ORDERID",fdel$,"LINE",fdel$,"OPENQTY",fdel$,"UM",fdel$
		row2=2;tmpcnt2=maxcnt
		ReturnStatus=1;Message$=""
		For LD=1 to NumProds
			let e$=""
			Call DXGet("PRODID"+Str$(LD),tmp$)
			tmp$=RTrim$(tmp$)
			If tmp$="" Goto LDPDone: ! NEED A PRODUCT!
			Let PROD$=UCase$(tmp$)+Blank$
			If prod$[1,3]="+  " OR PROD$[1,6]="ZNSTK "! it's nonstock
				prod$="Z ZZZZZZZZZZ"
			Endif ! will not have um or qty for messg or nonstk?
			Call DXGet("QTY"+Str$(LD),tmp$)
			Let SQty=tmp$ ! in sum units
			Call DXGet("UM"+Str$(LD),tmp$)
			Let SUM=tmp$
			! added for order pad detail entry
			call dxget("SHIPQTY"+Str$(LD),tmp$)
			SHQty=tmp$ ! in sum units (ordpad dtl)
			call dxget("BOQTY"+Str$(LD),tmp$)
			let BOQty=tmp$ ! in sum um (ordpad dtl)
			call dxget("SUBSTFLG"+Str$(LD),tmp$)
			tmp$=UCase$(RTrim$(tmp$))
			Substitm=0 \ if tmp$="Y" let substitm=1
			call dxget("LTYPE"+Str$(LD),tmp$)
			LPType$=UCase$(rtrim$(tmp$))
			if LPtype$="NSTK" ! additional
				call dxget("LPFLE"+Str$(LD),tmp$) ! last price file used
				lpnstk=0
				if UCase$(RTrim$(tmp$))="C" let lpnstk=1
				if UCase$(RTrim$(tmp$))="S" let lpnstk=2 ! shiplist
				call dxget("LPREC"+Str$(LD),tmp$) ! last price rec
				LPREC=tmp$
			Endif
			Call GetNewProdDtl(e$,List$[],tmpcnt,Prod$,Sqty,SUM,OHR,SHQty,BOQty)
			If e$<>""  ! a problem!
				Message$=Message$+Prod$+E$+"  " ! send prod & reason
				ReturnStatus=0
			Endif
			cust=roh.CustNum
			If not(credit) call getot15list(e$,SList$[],row2,tmpcnt2,Cust,Prod$,SUM)
		LDPDone: ! bypass
		Next LD ! next sent prod,qty,um
		List$[row]=esdel$
		e$=""
		call AddToStr(e$,rstr$,List$[])
		Slist$[row2]=esdel$
		If Not(Credit) call addtostr(e$,rstr$,SList$[]) ! SEND NEW OT15 SECTION!!****
	    ! If Not(Credit) call addtostr(e$,rstr$,tList$[]) ! SEND NEW NO LASTPRC SECTION!!****
		!
	  PDSendDone: ! finished
	  ! status section
	  If ReturnStatus=1 let message$="OK"
	  if returnstatus<>1 and message$="" let message$=E$ ! there are 99's now?
	  if debugdetail
		dmsg$="List Setup "+Str$(Orderno)+" TTL IN "+Str$(NumProds)+" "+Message$ \ Call updatelog(debug)
	  Endif
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
 else
    include "src/callsuberr.inc"
 end try
end sub ! SetNewProdline
! 
!--------------------------------------------------------------------
Sub PriceWrkData()
  Try

	Call DXGet("PRODID",prod$) \ prod$=UCase$(prod$)
			Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
			ProdKey$=Prod$
			Call dxget("LTYPE",tmp$)
			tmp$ = UCase$(tmp$)
			if tmp$[1,4]<>"NSTK" ! LET PRODKEY$[1,6]="ZNSTK " ! set to non-stock
				PrR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.) ! product mode=2 dir=1
				clear e$
				NonStk=0
			Else
				PRR=0;nonstk=1
				Call dxget("ORDERID",tmp$)                           
				orderno = tmp$  
				If not(orderno)
					let prr=-1
					goto endnspricewrk:
				endif
				If orderno <= 0 Or orderno > 999999 Or Fra(orderno)  
					ReturnStatus = 0                                   
					Message$ = "INVALID ORDER!"  
					let prr=-1
					goto endnspricewrk:
				End If   
				Call dxget("LN",tmp$) ! +Str$(X1),tmp$)         
				LineNo = tmp$ ! line # (zero on new lines)
				If LineNo <= 0 Or LineNo > 999 Or Fra(lineno)  
					ReturnStatus = 0                                   
					Message$ = "INVALID ORDER LINE!"
					prr=-1
					goto endnspricewrk:
					
				End If   
				rolkey$ = " ",rolkey$                         
				rolkey$[1,6] = orderno Using "######"         
				rolkey$[7,9] = LineNo Using "###"       
				rolkey$[11] = "" ! cut to length (space @ 10) 
				OLR = filegetrolz(e$,OLC,"=",1,rolkey$,rol.)
				clear e$
				if olr<=0
					returnstatus=0
					Message$="Order Line Not Found"
					prr=-1
					goto endnspricewrk:
				endif
				IF rol.NStkItem <> 1
					returnstatus=0
					message$="Not a NonStock Item"
					prr=-1
					goto endnspricewrk:
				endif
				let prodkey$=rol.prodcode$
				Call SetPRtoRol()
				endnspricewrk: ! end of getting factors for non-stock item
			Endif
			!
			! initialize status
		  If PrR<0 ! Product record not found
			 clear PR.
			 ReturnStatus=0
			 Message$="Error, Product not found"
		  else ! continue with lists
			List$[0]=bsdel$,"UPCHARGE",fdel$
			List$[1]="TEXT",fdel$
			If PR.PriceUpchrgType=0 AND PR.PriceUpchrg>0 ! it's a %
				WebStr$="UP ",LTrim$(PR.PriceUpchrg Using "###.##"),"%"
				WebStr$=WebStr$," if less than "
				tmp$=XUnit$(PR.UMUpChrg,ccc)
				WebStr$=WebStr$,RTrim$(tmp$),fdel$
			Endif
			If PR.PriceUpchrgType=1 AND PR.PriceUpchrg>0 ! IT'S $$
				X3=Abs(PR.PriceUpchrg)
				WebStr$="UP ",LTrim$(X3 Using PMask$)
				tmp$=XUnit$(PR.UMUpChrg,ccc) ! IS in upUM!
				WebStr$=WebStr$,"/",RTrim$(tmp$)," if less than "
				tmp$=XUnit$(PR.UMUpChrg,ccc)
				WebStr$=WebStr$,RTrim$(tmp$),fdel$
			Endif
			If PR.PriceUpchrg=0
				WebStr$="no u/c",fdel$
			Endif
			List$[2]=WebStr$
			List$[3]=esdel$ ! end this section
			e$=""
			call AddToStr(e$,rstr$,List$[]) ! add section 1
			! now 2 UM lists (Qty & Price)
			!Call env(2,"UTYPE","QTY") ! try setting a var?
			tmp$="QTY" ! try a pass
			Clear List$[]
			E$="" ! clear message
			Call UMDList(e$,tmp$,PRC,PRR,List$[],IntCo,Pr.)
			e$=""
			call AddToStr(e$,rstr$,List$[]) ! add section 2
			tmp$="PRICE" ! try a pass
			Clear List$[]
			E$="" ! clear message
			Call UMDList(e$,tmp$,PRC,PRR,List$[],IntCo,Pr.)
			e$=""
			call AddToStr(e$,rstr$,List$[]) ! add section 3
			tmp$="COST" ! try a pass
			Clear List$[]
			E$="" ! clear message
			Call UMDList(e$,tmp$,PRC,PRR,List$[],IntCo,Pr.)
			e$=""
			call AddToStr(e$,rstr$,List$[]) ! add section 4
			! A SECTION ON DECIMALS/ROUNDING
			Clear List$[]
			List$[0]=BSDEL$,"DECIMALROUND",fdel$
			List$[1]="Decimals",fdel$,"Rounding",fdel$
			List$[2]=Str$(Q0[1]),fdel$,P9$[42,42],fdel$
			List$[3]=esdel$
			e$=""
			call AddToStr(e$,rstr$,List$[]) ! add section 5
			Let ReturnStatus=1
			Message$="OK"
			If E$<>""
			  Let ReturnStatus=0
			  Message$=E$
			Endif
		  Endif ! valid prod
	if debugdetail
		dmsg$="Price Detail "+prod$+Message$ \ Call updatelog(debug)
	Endif
	  ! status section
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
 else
    include "src/callsuberr.inc"
 end try
end sub ! PriceWrkData
! 
!--------------------------------------------------------------------
Sub CostWrkData()
 Try

	Call DXGet("PRODID",prod$) \ prod$=UCase$(prod$)
			Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
			ProdKey$=Prod$
			Call dxget("LTYPE",tmp$)
			tmp$ = UCase$(tmp$)
			if tmp$[1,4]<>"NSTK" ! LET PRODKEY$[1,6]="ZNSTK " ! set to non-stock
				PrR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.) ! product mode=2 dir=1
				clear e$
				NonStk=0
			Else
				PRR=0;nonstk=1
				Call dxget("ORDERID",tmp$)                           
				orderno = tmp$  
				If not(orderno)
					let prr=-1
					goto endnscostwrk:
				endif
				If orderno <= 0 Or orderno > 999999 Or Fra(orderno)  
					ReturnStatus = 0                                   
					Message$ = "INVALID ORDER!"  
					let prr=-1
					goto endnscostwrk:
				End If   
				Call dxget("LN",tmp$) ! +Str$(X1),tmp$)         
				LineNo = tmp$ ! line # (zero on new lines)
				If LineNo <= 0 Or LineNo > 999 Or Fra(lineno)  
					ReturnStatus = 0                                   
					Message$ = "INVALID ORDER LINE!"
					prr=-1
					goto endnscostwrk:
					
				End If   
				rolkey$ = " ",rolkey$                         
				rolkey$[1,6] = orderno Using "######"         
				rolkey$[7,9] = LineNo Using "###"       
				rolkey$[11] = "" ! cut to length (space @ 10) 
				OLR = filegetrolz(e$,OLC,"=",1,rolkey$,rol.)
				clear e$
				if olr<=0
					returnstatus=0
					Message$="Order Line Not Found"
					prr=-1
					goto endnscostwrk:
				endif
				if rol.NStkItem <> 1
					returnstatus=0
					Message$="Order Line Not NonStock"
					prr=-1
					goto endnscostwrk:
				endif
				let prodkey$=rol.prodcode$
				Call SetPRtoRol()
				Endnscostwrk: ! end of getting factors for non-stock item
			Endif
			
			!
			! initialize status
		  If PrR<0 ! Product record not found
			 clear PR.
			 ReturnStatus=0
			 Message$="Error, Product not found"
		  else ! continue with lists
			List$[0]=bsdel$,"UPCHARGE",fdel$
			List$[1]="TEXT",fdel$
			If PR.LoadUpchgType=0 and PR.LoadCostUpchrg>0 ! it's a %
				WebStr$="UP ",LTrim$(PR.LoadCostUpchrg Using "###.##"),"%"
				WebStr$=WebStr$," if less than "
				tmp$=XUnit$(PR.UMUpChrg,ccc)
				WebStr$=WebStr$,RTrim$(tmp$),fdel$
			Endif
			If PR.LoadUpchgType=1 and PR.LoadCostUpchrg>0 ! it's $$
				X3=Abs(PR.LoadCostUpchrg)
				WebStr$="UP ",LTrim$(X3 Using PMask$)
				tmp$=XUnit$(PR.UMUpChrg,ccc) ! up$ is in UpUM!
				WebStr$=WebStr$,"/",RTrim$(tmp$)," if less than "
				tmp$=XUnit$(PR.UMUpChrg,ccc)
				WebStr$=WebStr$,RTrim$(tmp$),fdel$
			Endif
			If PR.LoadCostUpchrg=0
				WebStr$="no u/c",fdel$
			Endif
			if rtrim$(webstr$)="" let WebStr$="no u/c",fdel$ ! send something!!
			List$[2]=WebStr$
			List$[3]=esdel$ ! end this section
			e$=""
			call AddToStr(e$,rstr$,List$[]) ! add section 1
			! now Cost UM list
			!Call env(2,"UTYPE","COST") ! try setting a var?
			tmp$="COST" ! try a pass
			Clear List$[]
			E$="" ! clear message
			Call UMDList(e$,tmp$,PRC,PRR,List$[],IntCo,Pr.)
			e$=""
			call AddToStr(e$,rstr$,List$[]) ! add section 2
			
			Let ReturnStatus=1
			Message$="OK"
			If E$<>""
			  Let ReturnStatus=0
			  Message$=E$
			Endif
		  Endif ! valid prod
	  if debugdetail
		dmsg$="Cost Detail "+prod$+Message$ \ Call updatelog(debug)
	  Endif	
	  ! status section
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
 else
    include "src/callsuberr.inc"
 end try
end sub ! CostWrkData
! 
!--------------------------------------------------------------------
Sub UpdtLines()
! lines are being sent back to PM
! rol. = orig values, nrol. = just entered
! changed to 1 at a time (as user leaves line - save it!)
 Try
	Dim X$[20],NSFKey$[60]
	dim holdpswd$[12,16]
	Dim 1%,CNVTU[2],FLAG[9],X1[9],onCPI,nOnCPI
	Dim 1%,NewLn,HFlg[16],HFlag[16],Credit
	Dim 2%,X2[9],NumLines,ShipDate,JDate[5]
	Dim 3%,CNVTA,AMOUNT,X3[9],V3[99]
	Dim 3%,leftOnCPI,recCPI
	Dim 3%,WHBLD[2],S9[20]

	Dim NRol. as rolnew ! store new sent data
	! call dxsave(0,"tmp/olsv.txt!")
	Read #ctlc,3,188;ShipDate; ! for inv levels
	if debugdetail
		dmsg$="Start Line Update" \ Call updatelog(debug)
	Endif
	ReturnStatus=1
	Message$="OK"
	Call DXGet("ORDERID",tmp$)
	If tmp$="" goto UDLDone:
	OrderNo=tmp$
	If OrderNo<1 or OrderNo>999999 or Fra(OrderNo)
		ReturnStatus=0
		Message$="ORDER NUMBER INVALID"
		Goto UDLDone
	Endif
	OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
	e$=""
	If OHR<=0 ! not found
		ReturnStatus=99
		Message$="ORDER WAS NOT FOUND"
		goto udldone
	Else
		Credit=0 \ if rot.Status=22 let Credit=1 ! instead of roh.status check
		if returnstatus<>0
			call verifystat()
			if returnstatus=99 goto udldone:
		endif
		LET X3=rot.HoldCode ! unpack hold flags
		FOR CTR=0 TO 11                          
			LET HFlg[CTR]=SGN(FRA(X3/2));X3=INT(X3/2)
		NEXT CTR 
		for ctr=1 to 12
			read #ctlc,66,((ctr*16)-16);holdpswd$[ctr];
		next ctr
	Endif
	if source=0 and (roh.orgstatus=5 or roh.orgstatus=6 or ROH.STATUS=96) let invoice=1
	! Call DXGet("TTLLNS",tmp$) ! number of lines sent
	NumLines=1 ! was tmp$ for multiple
	If numlines<1 or NumLines>999 goto udldone ! cant update
	! now read in stuff
	Message$="" ! in case issues in loop
	!if ORDERNO=9024 ! 410405
	!	call dxsave(0,"tmp/olsv.txt!")
	!endif
	! For X1=1 to NumLines (was for multiple
		E$="" ! clear for this loop
		OLR=0;NewLn=0;KITCHG=0;kit=0
		Clear nrol.
		Clear pr.
		Clear pw.
		Clear etr.
		Clear nstk.
		!nrol.SpareNU$ = Blank$;X0=LEN(nrol.SpareNU$)
		!	IF X0>1
		!		nrol.SpareNU$[X0-1] = ""  ! for the key
		!	ENDIF
		Call DXGet("LN",tmp$) ! +Str$(X1),tmp$)
		nrol.LineNum=tmp$ ! line # (zero on new lines)
		LineNo=nrol.LineNum
		if nrol.linenum ! get prev data
			rolkey$=" ",rolkey$
			rolkey$[1,6]=OrderNo Using "######"
			rolkey$[7,9]=nrol.linenum using "###"
			rolkey$[11]="" ! cut to length (space @ 10)
			OLR=filegetrolz(e$,OLC,"=",1,rolkey$,rol.)
			clear e$
			if olr<=0 ! what do we do if not found?
				clear rol.
				nrol.LineNum=0 ! treat as new?
				e$="" ! clear emsg
			Endif
			If OLR>0 ! existing
				if rol.NStkItem=1 and rol.LineType<>3
					NSR=rol.PDRecNum
					Read record #NSC,NSR,0;nstk.
					PRR=0;PWR=0
				Endif
				If Not(rol.NStkItem) ! get prod & whse
					PRR=rol.PDRecNum
					Read record #PRC,PRR,0;pr.;
					if roh.ordtype=8 or roh.ordtype=16 ! chk to whse
					  If Roh.ConsWh>0 and roh.conswh<100
						Let TPWKey$=" ",tpwKey$
						TPWkey$[1,12]=pr.prodcode$+Blank$
						TPWKey$[13]=ROH.ConsWh Using "##"
						call chktowhse(TPWKey$,pr.PrimVend)
					  Endif
					Endif
					Tmp$=" ",tmp$
					tmp$=Pr.ProdCode$+rol.Whse Using "##"
					if roh.ordtype=7 let tmp$=Pr.ProdCode$+ROH.ConsWh Using "##"
					PWR=filegetprodwhse(e$,PWC,"=",1,tmp$,pw.)
					clear e$
					if PWR<0 ! not found - add new
						Clear pw.
						If PWR=-1 ! not found
							E$="";x3=tmp$[13,14]
							if roh.ordtype=7
								x3[1]=rol.whse/100
								x3=x3+x3[1]
							Endif
							Whbld[0]=PWC;Whbld[1]=X3;WhBld[2]=pr.PrimVend
							if x3<>1 let Whbld[1]=X3+.01 ! fra=copy whse 1
							Call mxwhcreate(e$,IntCo,PR.PRODCode$,WHBLD[])
							PWR=Whbld[2]
							Read record #PWC,PWR,0;PW.;
						Endif ! no whse
					Endif ! wh not found
					! FIND OUT IF THIS IS ON A CPI CONTRACT
					onCPI = 0 ! previous on cpi
					nOnCPI = 0 ! new on cpi
					if P61$[111,111] = "Y" AND not(credit) and rol.Contract
						if roh.OrdType = 2 or roh.OrdType = 8 and roh.OrdType = 16 goto notCPI
						Call DXGet("STKUPDT",tmp$) ! +Str$(X1),tmp$)
						if ucase$(tmp$)="Y" let tmp$="1"
						if ucase$(tmp$)="N" let tmp$="0"
						X2=tmp$ 
						if not(rol.UpdtStk) and not(x2) goto notCPI
						! see if contract involved is a cpi contact
						tmp$=rol.Contract Using "C#####"
						cphr = filegetcontracth(e$,cphc,"=",1,tmp$,contracth.)
						If cphr<=0 goto notCPI:
						if not(contracth.CPI) goto notCPI:
						! now we gotta find the product on both the
						! specprice and cpidet
						tmp$=rol.Contract Using "C#####"+rol.ProdCode$
						recCPI = filegetcpidet(e$,cpidc,"=",1,tmp$,cpid.)
						If recCPI<=0 goto notCPI:
						if not(CPID.ResStock) goto notCPI ! no qty limit
						sdr = filegetspecprice(e$,splc,"=",1,tmp$,sd.)
						If sdr<=0 goto notCPI:
						if rol.UpdtStk onCPI = 1
						if X2 nOnCPI = 1
						leftOnCPI = CPIQtyAvail(e$,rol.Contract,rol.ProdCode$,dummy,cpiChan[])
						if e$ = "" ! no errors
							! add back in the quantity previously allocated
							if onCPI = 1 ! if original line allocated to contract
								leftOnCPI = leftOnCPI + rol.QtyShip + rol.QtyBO
							end if
						end if
					end if
					notCPI: ! not a cpi contract we need to worry about
				Endif ! stk item
			Endif ! existing line
		Else ! no line
			Clear rol. ! clear
			Clear nstk.
		Endif
		If OLR>0 Read Record #OLC,OLR,0;nrol. ! read / lock with prev values
		If OLR<=0 Let NewLn=1
		if NEWLN=1 and roh.ordtype=15 and roh.boctr<>0 ! no add
			returnstatus=0
			message$="Invoice has been accepted. No new lines allowed"
			goto UDLDone
		Endif
		if roh.ordtype=19 ! bill complete check
			if roh.ordtype=19 and roh.BOCTR<>0 and roh.OT19Comp=0 and newln=1
				returnstatus=0
				message$="Final Bill for Bill Complete. No new lines allowed"
				goto UDLDone
			Endif
			if roh.ordtype=19 and roh.BOCTR<>0 and roh.ot19comp=0 ! final - no changes allowed
				returnstatus=0
				message$="Final Bill for Bill Complete. No changes allowed"
				goto UDLDone
			Endif
			if rol.QtyOrd<>0 and rol.Qtyord=rol.PrevQtyShip ! closed
				returnstatus=0
				message$="Line is closed. No changes allowed"
				goto UDLDone
			Endif
			
		Endif
		if credit let nrol.KitDesignation$=blank$
		if nrol.KitDesignation$="KIT" let KIT=1
		!nrol.SpareNU$ = Blank$;X0=LEN(nrol.SpareNU$)
		!	IF X0>1
		!		nrol.SpareNU$[X0-1] = ""  ! for the key
		!	ENDIF
		clear nrol.SpareNU$ ! dl4 fix
		! we assume qty/price/cost are passed in display u/m
		Call DXGet("LTYPE",tmp$) ! +Str$(X1),tmp$) ! line type (stk,nstk,msg,del)
		tmp$=UCase$(tmp$)
		ZLine=0;NonStk=0;Stk=0;Delline=0
		if tmp$="MSG" let ZLine=1;NonStk=1
		If tmp$[1,4]="NSTK" let NonStk=1
		if tmp$[1,3]="STK" let Stk=1
		if tmp$[1,4]="CLSD" goto UDLDone ! no
		if ACTION$="NSBUILDPROD" and olr>0 and not(rol.NStkItem)
			let stk=1;Nonstk=0 ! web could send as NSTK! NO,NO
		endif
		CutLine=0
		If tmp$="INV" and not(nonstk) let cutline=1;Stk=1 ! only cut stock lines
		if tmp$="FIN" and not(nonstk) let cutline=2;Stk=1 ! only cut stock lines
		if tmp$="DEL" ! deleting line
			!let rot.mdseordamt=rot.mdseordamt-nrol.extordamt
			!let rot.totordcost=rot.totordcost-nrol.extloadord
		  if source<>2082 ! Order Shipping Edit - NO LINE DELETE!
			let delline=1
			If OLR>0 call DELOLINE(OrderNo,nrol.linenum,OLR)
			goto UDLDone
		  Else
			returnstatus=0
			message$="YOU CAN NOT DELETE A LINE"
			goto UDLDone
		  Endif
		Endif
		If not(stk) and not(nonStk) ! has to be one or the other!
			returnstatus=0
			message$="NO LINE TYPE PASSED"
			goto UDLDone
		Endif
		! if olr>0 goto bptest else goto udldone  ! REMOVE WHEN READY!
		nrol.Status=11;Credit=0
		if ros.Status=32 let nrol.Status=12;Credit=1 ! determine order/credit?
		nrol.OrdNum=OrderNo
		IF SOURCE=2082 GOTO BYPLEDIT ! only get data for Qty Ship, BO, Order
		Call DXGet("DESC1",tmp$) ! +Str$(X1),tmp$)
		strgok=chkbadchars(e$,tmp$)
		if not(strgok)
			returnstatus=0
			Message$="Invalid Characters in Description 1"
			goto UDLDone
		Endif
		nrol.Desc1$=tmp$+Blank$
		Call DXGet("DESC2",tmp$) ! +Str$(X1),tmp$)
		strgok=chkbadchars(e$,tmp$)
		if not(strgok)
			returnstatus=0
			Message$="Invalid Characters in Description 2"
			goto UDLDone
		Endif
		nrol.Desc2$=tmp$+Blank$
		Call DXGet("WHSE",tmp$) ! +Str$(X1),tmp$)
		nrol.whse=tmp$ \ if nrol.whse<1 or nrol.whse>99 let nrol.whse=roh.wh
		!if roh.OrdType=16 let nrol.whse=roh.wh ! CANNOT CHANGE WHSE!!
		! see if whse can be changed (from mxledit)
		whok=1;x1=roh.ordtype
		If x1=7 or x1=8 or x1=11 Or x1=13 Or x1=15 let whok=0
		if custom_customer$="RUTHERFORD"
			If x1=16 Or x1=20 or x1=23 or x1=24 let whok=0
		else
			If x1=16 Or x1=20 Or x1=21 or x1=22 Or x1=23 Or x1=24 let whok=0
		endif
		If x1=19 and rol.PrevQtyShip let whok=0 ! "did a partial ship
		if rol.whse=0 let rol.whse=nrol.whse ! new line?
		if not(whok) and rol.whse<>nrol.whse
			returnstatus=0
			message$="Warehouse can not be changed on this order type"
			goto UDLDone
		Endif
		if kit and nrol.whse<>rol.whse let kitchg=1
		nrol.LineType=0
		If ZLine ! that's all folks
			let nrol.linetype=3
			nrol.ProdCode$="Z"+Blank$
			nrol.PSlsCat=20
			nrol.ComdtyCode$="MISC"
			Goto SLUChk
		Endif
		Call DXGet("STKUPDT",tmp$) ! +Str$(X1),tmp$)
		if ucase$(tmp$)="Y" let tmp$="1"
		if ucase$(tmp$)="N" let tmp$="0"
		X2=tmp$ 
		If X2=0 OR X2=1 let nrol.UpdtStk=X2 ! s/b 0 or 1
		if kit and nrol.UpdtStk<>rol.UpdtStk let kitchg=1
		if ACTION$="NSBUILDPROD" and olr>0 and not(rol.updtStk )
			if roh.ordtype<>2
				let nrol.Updtstk=1 ! set to update stock
				!let stk=1;Nonstk=0 ! web could send as NSTK! NO,NO
				if roh.ordtype=3 and P60$[22,22]="N" let nrol.Updtstk=0
			endif
		endif
		Call DXGet("UPRICE",tmp$) ! +Str$(X1),tmp$)
		V3[1]=tmp$ ! ALSO ON CUTS - PARENT or CUT
		if v3[1]<0
			returnstatus=0
			message$="NO NEGATIVE PRICE"
			goto UDLDone
		endif
		If V3[1]>9999999
			returnstatus=0
			message$="Price is out of range"
			goto UDLDone
		endif
		If V3[1] and rol.UMPrice>0 and (rol.LineType=1 or rol.LineType=2)
			call DXGet("PARCUTP",tmp$) ! if Cut - use as is (SCREEN SHOWS CUT!)
			if UCase$(Trim$(tmp$))="P"
				if rol.numout>0 let v3[1]=FNC(v3[1]/rol.numout)
			Endif
		Endif
		Call DXGet("UCOST",tmp$) ! +Str$(X1),tmp$)
		V3[2]=tmp$ ! ALSO ON CUTS - PARENT OR CUT
		if v3[2]<0
			returnstatus=0
			message$="NO NEGATIVE COST"
			goto UDLDone
		endif
		If V3[2]>9999999
			returnstatus=0
			message$="Cost is out of range"
			goto UDLDone
		endif
		if v3[2] and rol.umcost>0 and (rol.LineType=1 or rol.LineType=2)
			call DXget("PARCUTC",tmp$) ! if Cut - use as is (SCREEN SHOWS CUT!)
			if UCase$(Trim$(tmp$))="P"
				if rol.numout>0 let v3[2]=FNC(v3[2]/rol.numout)
			Endif
		Endif
		Call DXGet("LDISC",tmp$) ! +Str$(X1),tmp$)
		nrol.LineDiscPct=tmp$
		Call DXGet("UNCUBE",tmp$) ! +Str$(X1),tmp$)
		nrol.CubeUnit=tmp$ \ if not(nrol.CubeUnit) let nrol.CubeUnit=1
		if nrol.CubeUnit<0 or nrol.cubeunit>99999
			returnstatus=0
			message$="Cube unit is out of range"
			goto UDLDone
		Endif
		Call DXGet("UNLBS",tmp$) ! +Str$(X1),tmp$)
		nrol.LbsUnit=tmp$ \if not(nrol.LbsUnit) let nrol.LbsUnit=1
		if nrol.LbsUnit<0 or nrol.lbsunit>99999
			returnstatus=0
			message$="Pound unit is out of range"
			goto UDLDone
		Endif
		Call DXGet("TAXFLG",tmp$) ! +Str$(X1),tmp$)
		if ucase$(tmp$)="N" let tmp$="0"
		if ucase$(tmp$)="Y" let tmp$="1"
		nrol.TaxFlg=tmp$ ! y/n or code
		if nrol.taxflg<0 
			returnstatus=0
			message$="Tax code is out of range"
			goto UDLDone
		Endif
		Call DXGet("PRODID",tmp$) ! +Str$(X1),tmp$)
		nrol.ProdCode$=UCase$(tmp$)+Blank$
		If Not(nonStk) ! get product now (for um's)
			Prodkey$=" ",prodkey$
			prodkey$=nrol.ProdCode$
			PRR=filegetprod(e$,PRC,"=",1,ProdKey$,pr.)
			clear e$
			If PRR<0 ! not found
				ReturnStatus=0
				Message$="PRODUCT NOT FOUND!"
				clear pr. ! switch to non-stk? bomb?
				Goto UDLDone
			Endif
		Else ! Nonstk
			if not(zline) ! just + items
			  If rol.ProdCode$<>nrol.ProdCode$ ! code changed!? dropped spaces?
				tmp$=orderno using "######"
				tmp$=tmp$+"-"+lineno using "&&&"
				nrol.prodcode$=tmp$+blank$
				IF ROH.OrgOrd ! is a backorder release
					tmp1$=" ",tmp1$
					tmp1$=ROH.OrgOrd using "######"
					tmp1$=tmp1$+"-"+lineno using "&&&"
					tmp1$=tmp1$+blank$
					tmp1$[13]=""
					if RTrim$(rol.prodcode$)<>"" let tmp1$=rol.prodcode$ ! keep original
				Endif
				if roh.OrgOrd1 ! another orig ord
					tmp2$=" ",tmp2$
					tmp2$=ROH.OrgOrd1 using "######"
					tmp2$=tmp2$+"-"+lineno using "&&&"
					tmp2$=tmp2$+Blank$
					tmp2$[13]=""
					if RTrim$(rol.prodcode$)<>"" let tmp2$=rol.prodcode$ ! keep original
				Endif
			  Endif ! nonstocks - web drops leading spaces - re-add them!
			Endif
		Endif
		If nrol.LineNum>0 and Trim$(rol.ProdCode$)<>"" ! need a product check?
			If rol.ProdCode$<>nrol.ProdCode$ ! what should we do? code changed!?
				IF not(nonstk) let pcchg=1
				if nonstk ! could be a copy from orig order
					if zline ! should be same
						let pcchg=1
					Else ! check if copied from orig order
						pcchg=1 ! changed is default as we know it did change
						if rol.ProdCode$=tmp1$[1,12] let pcchg=0;nrol.ProdCode$=tmp1$
						if rol.ProdCode$=tmp2$[1,12] let pcchg=0;nrol.prodcode$=tmp2$
					Endif
				Endif
				If PCCHg ! did change
					ReturnStatus=0
					Message$="PRODUCT CODE CHANGE ON LINE!"
					goto UDLDone
				Endif
			Endif
		Endif
		call DXGet("DEPT",tmp$) ! +Str$(X1),tmp$)
		nrol.Dept=tmp$
		BYPLEDIT: ! ONLY EDIT QTYORD & SHIP
		call DXGet("QTYORD",tmp$) ! +Str$(X1),tmp$)
		let V3[3]=tmp$
		! at start no negative
		x1=roh.ordtype
		if v3[3]<0 and (credit or (x1=4 or x1=7 or x1=8 or x1=15 or x1=16 or x1=19 or x1=24))
			returnstatus=0
			message$="Can not order negative quantity"
			goto UDLDone
		Endif
		If Abs(V3[3])>9999999
			returnstatus=0
			message$="Order Quantity is out of range"
			goto UDLDone
		Endif
		Call DXGet("QTYBO",tmp$) ! +Str$(X1),tmp$)
		Let V3[4]=tmp$
		If Abs(V3[4])>9999999
			returnstatus=0
			message$="Back Order Quantity is out of range"
			goto UDLDone
		Endif
		Call DXGet("QTYSHIP",tmp$) ! +Str$(X1),tmp$)
		Let V3[5]=tmp$
		If V3[3]>0 ! new - no neg bo ever and ot4/15 can do neg release
		  If V3[4]<0 or (roh.ordtype<>4 and roh.ordtype<>15 and V3[5]<0)
			returnstatus=0
			message$="Can not have negative BO/Ship quantities!"
			goto UDLDone
		  Endif
		  IF V3[5]<0 and (roh.ordtype=4 or roh.ordtype=15)
			If nrol.PrevQtyShip<=0 or ABS(V3[5])>nrol.PrevQtyShip
				returnstatus=0
				message$="Negative Ship quantity is invalid!"
				goto udldone
			Endif
		  Endif
		Endif
		if v3[3]<0 and (V3[4]>0 or V3[5]>0)
			returnstatus=0
			message$="Can not have positive Bo/Ship quantities!"
			goto UDLDone
		Endif
		!if v3[5]<0 and V3[5]<>v3[3] let v3[3]=v3[5] ! no ship more than order
		if v3[3]<0 ! always ship ordered on negative
			v3[5]=v3[3];v3[4]=0
		Endif
		If Abs(V3[5])>9999999
			returnstatus=0
			message$="Ship Quantity is out of range"
			goto UDLDone
		Endif
		if roh.ordtype=4 ! order type 4 - needs BILLQTY
			call dxget("CURRBILL",tmp$)
			if rtrim$(tmp$)<>"" ! sent it - otherwise ignore
				V3[10]=tmp$
				if v3[3]<0 and v3[10]>0 ! neg line - pos bill? NO
					returnstatus=0
					message$="Can not have positive Bill quantities!"
					goto UDLDone
				Endif
				if v3[10]<0 ! neg bill allowed
					if nrol.PrevQtyBill<=0 or ABS(v3[10])>nrol.PrevQtyBill
						returnstatus=0
						message$="Negative Bill quantity is invalid!"
						goto udldone
					Endif
				Endif
			Endif ! sent data
			! ON PM Native - it allows overbill with just a prompt
			! check it below (when base)
		Endif ! bill qty - OT4
		IF SOURCE=2082 GOTO SLUChk ! FINISHED
		! do not allow UM change on "order shipping edit" - does
		Call DXGet("UMSELL",tmp$) ! +Str$(X1),tmp$)
		! call programdump("/tmp/ollog10!","")
		!If tmp$[1,1]>"9" ! sent text?
			R=getumrec(e$,CCC,tmp$,IntCo,PR.)
			If R<>0 let tmp$=Str$(R)
		!Endif
		x2=tmp$
		if x2<0 ! NO System UM for QTY
			ReturnStatus=0
			Message$="INVALID U/M - SELL"
			goto UDLDone
		Endif
		if not(nonstk) ! chk u/m
			Flag=ChkPrdUM(e$,X2,IntCo,Pr.)
			if flag=0 ! let x2=pr.UMSellDefault ! unrem / rem below to just change
				ReturnStatus=0
				Message$="INVALID U/M - SELL"
				goto UDLDone
			Endif
		Endif
		let nrol.UMSell=x2 ! tmp$
		if not(nonStk)
			X3=UMtoFactor(nrol.UMSell)
			rol.SellFactor=X3;nrol.SellFactor=x3
		Endif
		! if roh.ordtype=15 let nrol.CurrRelQty=v3[5] ! is relqty
		Call DXGet("PUPCHG",tmp$) ! +Str$(X1),tmp$)
		V3[6]=tmp$
		Call DXGet("PUPTYPE",tmp$) ! +sTR$(X1),tmp$)
		let x$=tmp$
		if x$="$" ! $ is <0  percent is >=0
			let nrol.UpChrg=0-V3[6] ! may need convert
		Else
			let nrol.UpChrg=V3[6]
		Endif
		! Allow UM Change on Order Shipping Edit?
		Call DXGet("UMPRICE",tmp$) ! +Str$(x1),tmp$)
		! call programdump("/tmp/ollog11!","")
		!If tmp$[1,1]>"9" ! sent text?
			R=getumrec(e$,CCC,tmp$,IntCo,PR.)
			If R<>0 let tmp$=Str$(R)
		!Endif
		x2=tmp$
		if not(nonstk) ! chk u/m
			Flag=ChkPrdUM(e$,X2,IntCo,Pr.)
			if flag=0 ! let x2=pr.UMPriceDefault ! unrem / rem below to just change
				ReturnStatus=0
				Message$="INVALID U/M - PRICE"
				goto UDLDone
			Endif
		Endif
		nrol.umprice=x2 ! tmp$
			if not(nonStk)
				X3=UMtoFactor(nrol.umprice)
				rol.PriceFactor=X3;nrol.PriceFactor=x3
			Endif
		Call DXGet("UMCOST",tmp$) ! +Str$(X1),tmp$)
		! call programdump("/tmp/ollog12!","")
		!If tmp$[1,1]>"9" ! sent text?
			R=getumrec(e$,CCC,tmp$,IntCo,PR.)
			If R<>0 let tmp$=Str$(R)
		!Endif
		x2=tmp$
		if not(nonstk) ! chk u/m
			Flag=ChkPrdUM(e$,X2,IntCo,Pr.)
			if flag=0 ! let x2=pr.UMCostDefault ! unrem / rem below to just change
				ReturnStatus=0
				Message$="INVALID U/M - COST"
				goto UDLDone
			Endif
		Endif
		nrol.UMCost=x2 ! tmp$
			if not(nonStk)
				X3=UMtoFactor(nrol.UMCost)
				rol.CostFactor=X3;nrol.CostFactor=x3
			Endif
		call dxget("VENDITM",tmp$) ! +Str$(X1),tmp$)
		strgok=chkbadchars(e$,tmp$)
		if not(strgok)
			returnstatus=0
			Message$="Invalid Characters in Vendor Item"
			goto UDLDone
		Endif
		nrol.VendItemCode$=ucase$(tmp$)+Blank$
		call dxget("NETPRC",tmp$) ! +Str$(x1),tmp$)
		V3[7]=tmp$ ! nrol.NetPrice
		If V3[7]<0 or Abs(V3[7])>9999999
			returnstatus=0
			message$="Net Price is out of range"
			goto UDLDone
		Endif
		call dxget("PPFLAG",tmp$) ! +Str$(X1),tmp$)
		if ucase$(tmp$)="FALSE"  let tmp$="0"
		if ucase$(tmp$)="TRUE" or tmp$="-1" let tmp$="1"
		nrol.NewPPFlg=tmp$ ! (s/b 0 or 1)
		call dxget("LNPRNT",tmp$) ! +Str$(X1),tmp$)
		if ucase$(tmp$)="N" let tmp$="0"
		if ucase$(tmp$)="Y" let tmp$="1"
		iF RTrim$(tmp$)<>"" ! only if sent!!
			X2=Tmp$
			If X2=0 Or X2=1 let nrol.LinePrint=X2
			if nrol.LinePrint=0 ! not printed
				nrol.PrintDate=0
				nrol.PrintTime=0
			Endif
		Endif
		Call dxget("CUPCHG",tmp$) ! +Str$(X1),tmp$)
		V3[8]=tmp$
		call dxget("CUPTYPE",tmp$) ! +Str$(X1),tmp$)
		X$=tmp$
		if x$="$" ! $ is <0  % is >=0
			nrol.LoadUpchrg=0-V3[8]
		Else
			nrol.LoadUpchrg=V3[8]
		Endif
		! call programdump("/tmp/ollog13!","")
		Call dxget("KIT",tmp$)
		if pr.MBFlg$<>"M" let tmp$="N" ! cannot happen
		if credit or nonstk let tmp$="N" ! no kits on these
		if p9$[22,22]="N" let tmp$="N" ! flag says no kits
		if UCase$(RTRIM$(tmp$))<>"" ! forced or user entered
		 ! if nothing passed - ignore it - leave field as is
			If kit ! started off as kit (set at beginning)
				if tmp$="N" ! now is not kit - delete old
					! call to delete
					FChan[1]=ohc;fchan[2]=osc;fchan[3]=otc
					FChan[4]=prc;fchan[5]=pwc;fchan[6]=sltc;fchan[7]=pltc
					fchan[9]=sqlChan;fchan[11]=0;fchan[12]=0
					KTC=openfile(1312,Intco)
					if ktc>0
						FChan[8]=ktc
						S9[7]=roh.ordnum;S9[9]=rol.linenum
						call DELOKIT(e$,IntCo,S9[],FChan[])
						clear e$
						Try close #KTC Else Rem
					Endif
					kit=0;kitchg=0 ! clear kit flags
					nrol.KitDesignation$=blank$
				endif
				! if already a kit - it still is
			else ! not a kit
				if tmp$="Y" ! now it is a kit
					kit=1;kitchg=1
					nrol.KitDesignation$="KIT"
					! near end it does kit code
				endif
				! if not a kit - it still is not
			endif
		Endif ! user did not enter or fld not passed
		tmp$="";v3[9]=0
		otok=0 \ if roh.OrdType=2 let otok=1
		if custom_customer$="HTBERRY" and roh.ordtype=25 let otok=1
		if nonstk or otok OR (roh.OrdType=3 and p60$[22,22]="N")
			call dxget("GLCOST",tmp$) !+Str$(X1),tmp$)
			IF roh.OrdType=15 AND roh.boctr let tmp$="" ! billed - no change
			if nonstk or cost_Lev[0]=2
				V3[9]=tmp$
				if v3[9]<0 or v3[9]>9999999
					returnstatus=0
					message$="GL Cost is out of range"
					goto UDLDone
				Endif
			Endif
		Endif
		Call dxget("PRCORGN",tmp$) ! price origin
		if Trim$(tmp$)="" let tmp$=Str$(rol.PriceOrigin) ! not sent - retain orig
		x=tmp$
		if x>-18 and x<15 ! with in range
			nrol.PriceOrigin=iNT(x)
		Endif
		if x>82 and x<118 ! with in range from perm price
			nrol.PriceOrigin=iNT(x)
		endif
		call dxget("CSTORGN",tmp$) ! cost origin (if reprice)
		if Trim$(tmp$)="" let tmp$=Str$(rol.CostOrigin) ! not sent - retain orig
		x=tmp$
		if x>-2 and x<12 ! with in range
			nrol.CostOrigin=Int(x)
		Endif
		! also cut data
		If CutLine ! get cutting info? 1=Inv, 2=Fin
			nrol.linetype=cutline ! set to orig (chg'd elsewhere)
		Endif
		if Holdforpo and (Source<219 or source=2082) and not(zline) ! not(credit)
			! cct141900  if bo_qty and ord_qty <= avail(base) then ask to for po
			! x2[9]=nrol.whse \ if roh.ordtype=7 let x2[9]=roh.ConsWh
			!WhsAvail=0;whsavail[3]=0
			!if not(nonstk) ! nonstk=NO AVAIL!
			!	WHSAvail=getwhavail(e$,intco,PWC,nrol.ProdCode$,X2[9])
			!	WhsAvail=WhsAvail+rol.qtyship ! add in prev ship
			!	cnvtu[0]=0;cnvtu[1]=nrol.umsell;cnvtu[2]=1
			!	cnvta=whsavail
			!	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			!	WhsAvail[3]=amount ! qty avl in sell
			!Endif
			if holdforpo ! and V3[4] and V3[3] <= Whsavail[3]
				call dxget("HLD4PO",tmp$)
				nrol.HldForPo$=Blank$ ! ="N" ! or is it ""?(it's ="" in mxline)
				if Ucase$(RTrim$(tmp$))="Y" let nrol.HldForPo$="Y"
				if v3[4]<=0 let nrol.HldForPo$=Blank$ ! no bo - no hold!
			Endif
		Endif
		! nonstks data entered in sept rtn
		! now the update work starts
		SLUChk: ! start update
		If ZLine ! just move in descs and done!
			If nrol.LineNum=0
				X2=GetNxtLine(orderno)
				nrol.linenum=x2
				nrol.SpareNU3$=blank$
				clear nrol.SpareNu$ ! dl4 fix
				OLR=fileupdaterolz(e$,OLC,"a",rcdno,nrol.)
				clear e$
			Else ! existing line
				Read record #OLC,OLR,0;rol.
				rol.Desc1$=nrol.Desc1$
				rol.Desc2$=nrol.Desc2$
				Write record #OLC,OLR,0;rol.;
			Endif
			goto eldline ! finished
		Endif ! ALL for zlines
		! if new or changed - need edittrack  NEW=11, CHG=1
		If nrol.linenum=0 ! new line
			nrol.linenum=getnxtline(orderno)
			etr.EtAction=11 ! new
			if p61$[136,136]="Y"
				let nrol.currid=roh.currid
				let nrol.currfact=roh.currfact
				let rol.currid=roh.currid
				let rol.currfact=roh.currfact
			endif
			If not(nonstk) ! need prod for add'l data
				ProdKey$=nrol.ProdCode$+Blank$
				ProdKey$[13]=""
				PRR=filegetprod(e$,PRC,"=",1,prodkey$,pr.)
				clear e$
				If PRR>0
					nrol.PDRecNum=PRR
				Else
					E$="PRODUCT "+nrol.ProdCode$+"NOT FOUND!"
				Endif
				nrol.ComdtyCode$=pr.ComdtyCode$+Blank$
				if roh.ordtype=8 or roh.ordtype=16
				  If Roh.ConsWh>0 and roh.conswh<100
					Let TPWKey$=" ",tpwKey$
					TPWkey$[1,12]=prodKey$+Blank$
					TPWKey$[13]=ROH.ConsWh Using "##"
					call chktowhse(TPWKey$,pr.PrimVend)
				  Endif
				Endif
				Prodkey$=ProdKey$+nrol.Whse Using "##"
				if roh.ordtype=7 let prodkey$[13]=ROH.ConsWh Using "##"
				PWR=filegetprodwhse(e$,PWC,"=",1,Prodkey$,pw.)
				clear e$
				if PWR<0 ! not found
					Clear pw.
					If PWR=-1 ! add on NOF
						E$="";x3=prodkey$[13,14]
						if roh.ordtype=7
							let x3[1]=nrol.whse/100
							x3=x3+x3[1]
						Endif
						Whbld[0]=PWC;Whbld[1]=x3;WhBld[2]=pr.PrimVend
						if x3<>1 let Whbld[1]=X3+.01 ! fra=copy whse 1
						Call mxwhcreate(e$,IntCo,nrol.PRODCode$,WHBLD[])
						PWR=Whbld[2]
						Read record #PWC,PWR,0;PW.;
					Endif
				Endif
				SUM=nrol.UMSell
				rol.qtyord=V3[3]
				call setnewrol() ! set default values
				rol.dept=nrol.dept
			Else ! nonstks - set rol. to nrol. for converts
				rol.UMBase=nrol.UMBase
				rol.UMSell=nrol.UMSell
				rol.UMCost=nrol.UMCost
				rol.UMPrice=nrol.UMPrice
				rol.UMPurch=nrol.UMPurch
				rol.SellFactor=nrol.SellFactor
				rol.PriceFactor=nrol.PriceFactor
				rol.CostFactor=nrol.CostFactor
				rol.PurchFactor=nrol.PurchFactor
				rol.CubeFactor=nrol.CubeFactor
				rol.WgtFactor=nrol.WgtFactor
				PRR=0;PWR=0
				! set up / add nonstk
				Nstk.OrdNum=nrol.OrdNum
				nstk.LineNum=nrol.linenum
				!nstk.OrdLineRec not known yet
				nstk.Desc1$=nrol.Desc1$
				nstk.Desc2$=nrol.Desc2$
				nstk.PSlsCat=nrol.PSlsCat
				! nstk.QtyShip  nstk.UnitCost  nstk.UnitPrice
				nrol.ProdCode$=roh.OrdNum Using "&&&&&&"
				nrol.ProdCode$=nrol.ProdCode$+"-"+nrol.LineNum Using "&&&"
				nrol.ProdCode$=nrol.ProdCode$+blank$
				nstk.ProdCode$=nrol.ProdCode$
				nstk.ComdtyCode$=nrol.ComdtyCode$
				nstk.Unused$=blank$
				nstk.SpareNu$=blank$
				clear nstk.spare$ ! dl4 fix ! nstk.Spare$=blank$
				NSR=fileupdatesproddesc(e$,NSC,"a",0,Nstk.)
				clear e$
				If NSR>0 
					let nrol.PDRecNum=NSR
				Else
					E$="NONSTOCK "+nrol.ProdCode$+" FILE NOT ADDED"
				Endif
				
			Endif ! of stk/nonstk
			If rol.WgtFactor<=0 Let rol.WgtFactor=1
			if nrol.WgtFactor<=0 let nrol.WgtFactor=1
			rol.LbsUnit=nrol.LbsUnit ! update to current (lb based items)
		Else ! existing line 
			! as setprtorol uses rol. needs a setup to new values
			rol.UMBase=nrol.UMBase
			rol.UMSell=nrol.UMSell
			rol.UMCost=nrol.UMCost
			rol.UMPrice=nrol.UMPrice
			rol.UMPurch=nrol.UMPurch
			rol.SellFactor=nrol.SellFactor
			rol.PriceFactor=nrol.PriceFactor
			rol.CostFactor=nrol.CostFactor
			rol.PurchFactor=nrol.PurchFactor
			rol.CubeFactor=nrol.CubeFactor
			rol.WgtFactor=nrol.WgtFactor
		endif ! of new line
		! so nrol. has new, rol. has orig
		Call setprtorol() ! set to rol. factors
		PR.LbsUnit = nrol.LbsUnit ! Task 45186    
		IF SOURCE=2082 GOTO BYPLEDIT2 ! JUST QTY
		! convert sent to base as sent in display um
		if p61$[136,136]="Y" and rol.currfact<>0 ! nssave
			if v3[1]<>0 ! unit price
				let cnvcu[0]=2
				let cnvcu[1]=1 ! no rounding 
				let cnvca[0]=v3[1]
				let cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[1]=cnvca[0]
			endif
			! convert cost to base
			if v3[2]<>0 ! unit cost
				let cnvcu[0]=2
				let cnvcu[1]=1 ! no rounding 
				let cnvca[0]=v3[2]
				let cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[2]=cnvca[0]
			endif
			if v3[6]<0 ! price upcharge $
				let cnvcu[0]=2
				let cnvcu[1]=1 ! no rounding 
				let cnvca[0]=v3[6]
				let cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[6]=cnvca[0]
			endif
			if v3[7]<>0 ! net price
				let cnvcu[0]=2
				let cnvcu[1]=1 ! no rounding 
				let cnvca[0]=v3[7]
				let cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[7]=cnvca[0]
			endif
			if v3[8]<0 ! cost upcharge $
				let cnvcu[0]=2
				let cnvcu[1]=1 ! no rounding 
				let cnvca[0]=v3[8]
				let cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[8]=cnvca[0]
			endif
			if v3[9]<>0 ! gl cost
				let cnvcu[0]=2
				let cnvcu[1]=1 ! no rounding 
				let cnvca[0]=v3[9]
				let cnvca[1]=rol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[9]=cnvca[0]
			endif
		endif
		CNVTU[0]=nrol.UMPrice;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
		cnvta=v3[1] \ if nrol.UMPrice>0 and nrol.NumOut>0 let cnvta=v3[1]*nrol.numout
		nrol.UnitPrice=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		CNVTU[0]=nrol.UMPrice;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
		cnvta=v3[7] \ if nrol.UMPrice>0 and nrol.NumOut>0 let cnvta=v3[7]*nrol.numout
		nrol.NetPrice=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if nrol.UpChrg<0 ! $ amount
			CNVTU[0]=nrol.UMPrice;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
			cnvta=V3[6] ! still +
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			let nrol.UpChrg=0-x3
		Endif
		if custom_customer$="GPG" ! custom - no change to contract prices
		! on classic - does not allow prompt - erp keep original prices 
			if rol.contract and olr>0 ! it is a contract on existing line
				let nrol.UnitPrice=rol.UnitPrice
				let nrol.NetPrice=rol.NetPrice
				let nrol.UpChrg=rol.UpChrg
				let nrol.LineDiscPct=rol.LineDiscPct
				let nrol.LineDisc=rol.LineDisc
				let nrol.NewPPFlg=rol.NewPPFlg
			endif
		endif ! general paper - no changing contract price
		CNVTU[0]=nrol.UMCost;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
		cnvta=V3[2]  \ if nrol.UMCost>0 and nrol.NumOut>0 let cnvta=v3[2]*nrol.numout
		nrol.UnitCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if nrol.LoadUpchrg<0 ! it's a $ up
			CNVTU[0]=nrol.UMCost;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
			cnvta=v3[8]
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			nrol.LoadUpchrg=0-X3
		endif
		if v3[9]>0 ! sent glcost
			CNVTU[0]=nrol.UMCost;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
			cnvta=v3[9] \ if nrol.UMCost>0 and nrol.NumOut>0 let cnvta=v3[9]*nrol.numout
			nrol.UnitGLCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		else
			call dxget("GLCOST",tmp$)
			if rtrim$(tmp$)<>""
				if rtrim$(tmp$)="0" or rtrim$(tmp$)="0.0" or rtrim$(tmp$)="0.00"
					let nrol.unitglcost=0
				endif
			endif
		Endif
		BYPLEDIT2: ! SOURCE=2082 -- ONLY CHANGE QTY SHIP/BO/Ord
		CNVTU[0]=nrol.UMSell;Cnvtu[1]=0;Cnvtu[2]=1
		cnvta=V3[3] \ IF nrol.NumOut>0 let CNVTA=v3[3]/nrol.NumOut
		nrol.QtyOrd=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		cnvta=V3[4] \ IF nrol.NumOut>0 let CNVTA=v3[4]/nrol.NumOut
		nrol.QtyBO=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		cnvta=V3[5]  \ IF nrol.NumOut>0 let CNVTA=v3[5]/nrol.NumOut
		nrol.QtyShip=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if nOnCPI
			if leftOnCPI < nrol.QtyShip + nrol.QtyBO
				! okay, convert qty back to SELL U/M
				let cnvtu[0]=0;cnvtu[1]=nrol.UMSell;cnvtu[2]=1
				let cnvta=leftOnCPI
				Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				message$ = " Only "+str$(Amount)+" left on CPI contract: "+str$(nrol.Contract)+".  Ship quantity + BO cannot exceed!"
				returnstatus=0
				goto UDLDone
			end if
		end if
		If roh.ordtype=4 ! Curr Billqty
			cnvta=V3[10] \ if nrol.NumOut>0 let cnvta=v3[10]/nrol.numout
			nrol.CurrBillQty=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		Endif
		if roh.ordtype=15 and roh.boctr=0 and olr>0 ! existing line
			! nrol.qtyord=rol.qtyord ! can't id new line?
			nrol.qtybo=rol.qtybo
			nrol.CurrRelQty=nrol.qtyship ! =rol.qtyship
		Endif
		If roh.ordtype=15 and roh.boctr<>0 ! cannot change qtys,prc/cost,um
			nrol.qtyord=rol.qtyord ! so set them back to previous
			nrol.qtybo=rol.qtybo  ! as no new lines - use rol. vars
			nrol.CurrRelQty=nrol.qtyship ! =rol.qtyship (rel sent as ship)
			nrol.UnitPrice=rol.unitprice
			nrol.netprice=rol.netprice
			nrol.upchrg=rol.upchrg
			nrol.unitcost=rol.unitcost
			nrol.UMPrice=rol.umprice
			nrol.UMCost=rol.umcost
			nrol.UMSell=rol.umsell
			nrol.LoadUpchrg=rol.loadupchrg
			nrol.UnitGLCost=rol.unitglcost
		Endif
		If roh.ordtype=4 ! checks are here
			nrol.CurrRelQty=nrol.qtyship ! release is entered as QtyShip
			! PM Native - allows billing>order-prevbill - just an ok Y/N prompt
			! if nrol.currbillqty>nrol.qtyord-nrol.PrevQtyBill ! popup and ok Y/N
			! I guess the front end handles this as we can't here
			if custom_customer$="MORRISETTE"! ques on this
				nrol.CurrBillQty=nrol.CurrRelQty
			Endif
		Endif
		if rol.BORelFlg ! uh oh - can not change qty if flag
			! can not change on native mode! - rasl ignores it!!
			qchg=0
			if nrol.Qtyord<>rol.QtyOrd let qchg=1 ! qty overrides price/cost
			if nrol.QtyBO<>rol.QtyBo let qchg=1
			if nrol.QtyShip<>rol.QtyShip let qchg=1
			If qchg
				returnstatus=0
				Message$="BO Release (261) is in progress - NO QTY CHANGE ALLOWED"
				goto UDLDone
			Endif
		Endif
		if roh.ordtype=19
			if rol.PrevQtyShip<>0 ! partially shipped already
				! only qty related fields can change
				! native only opts 1-4, 14-16, 23, >29 allowed!
				OT19OK=1 ! ok so far
				if rol.NetPrice<>nrol.NetPrice let ot19ok=0 ! 5
				if rol.LineDiscPct<>nrol.LineDiscPct let ot19ok=0 ! 6
				if rol.LineDisc<>nrol.LineDisc let ot19ok=0 ! 6
				if rol.unitcost<>nrol.unitcost let ot19ok=0 ! 8
				if rol.LoadUpchrg<>nrol.LoadUpchrg let ot19ok=0 ! 32
				if rol.UpChrg<>nrol.UpChrg let ot19ok=0 ! 7
				if rol.UnitGLCost<>nrol.UnitGLCost let ot19ok=0 ! 9
				if rol.UMPrice<>nrol.UMPrice let ot19ok=0 ! 12
				if rol.UMCost<>nrol.UMCost let ot19ok=0 ! 13
				if rol.UMSell<>nrol.UMSell let ot19ok=0 ! 11
				if rol.Desc1$<>nrol.Desc1$ let ot19ok=0 ! 17
				if rol.Desc2$<>nrol.Desc2$ let ot19ok=0 ! 17
				if rol.VendItemCode$<>nrol.VendItemCode$ let ot19ok=0 ! 18
				if rol.LineType<>nrol.LineType let ot19ok=0 ! 20
				if rol.UpdtStk<>nrol.UpdtStk let ot19ok=0 ! 21
				if rol.TaxFlg<>nrol.TaxFlg let ot19ok=0 ! 22
				if rol.KitDesignation$<>nrol.KitDesignation$ let ot19ok=0 ! 25
				if rol.Whse<>nrol.Whse let ot19ok=0 ! 29
				!Endif ! rest is allowed?
				if not(ot19ok) ! 
					returnstatus=0
					message$="Partial Shipment made - Change not allowed"
					goto UDLDone
				Endif
			Endif ! of partial
		Endif ! ot 19 
		!let rot.mdseordamt=rot.mdseordamt-rol.extordamt
		!let rot.totordcost=rot.totordcost-rol.extloadord
		call dolineextens()
		if roh.OrdType=8 or roh.OrdType=16 ! cons/trans - no price/cost
			nrol.UnitCost=0;nrol.CostOrigin=0;nrol.RebtContract=0
			nrol.UnitPrice=0;nrol.CutChrg=0;nrol.CutCost=0
			nrol.LineDisc=0;nrol.ExtOrdAmt=0;nrol.ExtShipAmt=0
			nrol.LineDiscPct=0;nrol.ExtCutChg=0;nrol.ExtCutCost=0
			nrol.ExtLoadShip=0;nrol.ExtLoadOrd=0;nrol.NetPrice=0
			nrol.TaxAmt=0;nrol.LoadUpchrg=0;nrol.UpChrg=0
		Endif
		If p61$[46,46]="Y" and Credit and roh.shiptype=3 ! price fix - no cost
			nrol.UnitCost=0;nrol.CostOrigin=0;nrol.RebtContract=0
			nrol.CutCost=0;nrol.ExtCutCost=0;nrol.ExtLoadShip=0;nrol.ExtLoadOrd=0
			nrol.LoadUpchrg=0
		Endif
		!let rot.mdseordamt=rot.mdseordamt+nrol.extordamt
		!let rot.totordcost=rot.totordcost+nrol.extloadord
		if custom_customer$="MORRISETTE"
			IF roh.ordtype=4 AND (nrol.CurrRelQty<>0 AND nrol.CurrBillQty=0) ! "CCT 111810 
				LET message$="THERE IS A RELEASE BUT NO BILL AMOUNT"
				returnstatus=0
				goto udldone ! abort update? let's
			ENDIF 
		Endif
		if roh.ordtype=4
			!extensions in subroutine (was qtybo-borel) - native = bo+borel
			if nrol.qtyord<nrol.CurrRelQty+(nrol.QtyBo-nrol.BORelQty)+nrol.PrevQtyShip
				returnstatus=0
				message$="Quantity is over shipped"
				goto UDLDone ! abort update? let's
			Endif
		Endif
		if roh.ordtype=15
			!extensions in subroutine (was qtybo-borel) - native = bo+borel
			!if nrol.qtyord<>nrol.CurrRelQty+(nrol.QtyBo+nrol.BORelQty)+nrol.PrevQtyShip
			if nrol.qtyord<nrol.CurrRelQty+(nrol.QtyBo-nrol.BORelQty)+nrol.PrevQtyShip
				returnstatus=0
				message$="Quantity is Out of Balance"
				goto UDLDone ! abort update? let's
			Endif
		Endif
		if roh.ordtype=19
			x3[5]=rol.PrevQtyShip+nrol.QtyShip+nrol.QtyBO ! new qty/prev
			if roh.ordtype=19 and roh.BOCTR<>0 and roh.Ot19Comp=0 let x3[5]=ROL.qtyship ! final ordered=shipped
			if nrol.qtyord<>X3[5] ! rol.PrevQtyShip+rol.QtyShip+rol.QtyBO
				returnstatus=0
				message$="Quantity is unequal. Please adjust (ord=ship+bo+prev)"
				goto UDLDone ! 
			Endif
		Endif
		BPTEST: ! a bypass for testing
		if nrol.Unitprice<>rol.unitprice 
			let nrol.OrgPriceUnit=rol.unitprice
		Endif
		if nrol.unitcost<>rol.unitcost 
			let nrol.OrgLoadCost=rol.unitcost
			if rol.costorigin=0 let nrol.CostOrigin=-1 ! manual? ! quick fix - manual cost *******
		Endif ! after quick fix - set it if not already?
		if nrol.netprice<>rol.netprice
			if rol.priceorigin=0 let nrol.PriceOrigin=-7 ! quick fix - manual price ******
		Endif ! after quick fix - set it if not already?
		if nrol.whse<>rol.whse let nrol.OrgWhse=rol.whse
		If ETr.EtAction=0 ! no check yet
			
			if nrol.UnitPrice<>rol.UnitPrice ! diff - is it rounded?
			  if FNC(nrol.UnitPrice)<>FNC(rol.UnitPrice) ! compare at 4 dec
				let ETr.EtAction=23
				If rtrim$(holdpswd$[5])<>"" let HFlag[4]=1 ! prc chg/hold
			  Endif
			endif
			if nrol.unitcost<>rol.unitCost ! diff - is it rounded?
			  if FNC(nrol.unitcost)<>FNC(rol.unitCost) ! compare 4 dec
				let ETr.EtAction=24
				If rtrim$(holdpswd$[6])<>"" Hflag[5]=1 ! cost chg/hold
			  Endif
			endif
			If nrol.netprice<>rol.netprice ! diff - is it rounded?
			  If FNC(nrol.netprice)<>FNC(rol.netprice) ! compare to 4 dec
				let etr.etaction=23
				If rtrim$(holdpswd$[5])<>"" let HFlag[4]=1 ! prc chg/hold
			  Endif
			endif
			if nrol.Qtyord<>rol.QtyOrd let ETr.EtAction=1 ! qty overrides price/cost
			if nrol.QtyBO<>rol.QtyBo let ETr.EtAction=1
			if nrol.QtyShip<>rol.QtyShip let ETr.EtAction=1
			
		Endif
		if KIT and nrol.QtyShip<>rol.QtyShip let KITCHG=1
		If P60$[44,44]="Y" and etr.EtAction<>0
			call edttrkdo(rol.,nrol.) ! org, new
		Endif ! of edit tracking
		if not(nonstk) and not(credit)
		  IF P9$[2,2]="D" AND P9$[20,20]<>"F" AND pr.MBFlg$="M" 
			IF P9$[22,22]="Y" AND NOT(CREDIT)
				if nrol.LineType=0 and nrol.qtyship>=0 ! only stock items
					if LineNo=0 LET nrol.KitDesignation$="KIT" ! only new line!
				Endif
			Endif
		  Endif
		  if nrol.KitDesignation$="KIT" and not(credit)
		    let kit=1
			if kit and nrol.whse<>rol.whse let kitchg=1
			if kit and nrol.UpdtStk<>rol.UpdtStk let kitchg=1
			if KIT and nrol.QtyShip<>rol.QtyShip let KITCHG=1
			if nrol.KitDesignation$<>rol.KitDesignation$ let kitchg=1
		  Endif
		Endif
		Call ChkWhRasl(e$,intco,Ctlc,WHI,nrol.Whse,RASL[])
		If NonStk
			nrol.PDRecNum=NSR ! non-stk rec #
		Endif
		tmp$=ShipDate Using "&&&&&&"
		Call DateToJulian(1,tmp$,tmp1$,F)
		IF F let tmp1$=""
		JDate[1]=tmp1$;F=0 ! julian sys shipdate
		tmp$=roh.ShipDate Using "&&&&&&"
		if roh.ShipDate<>999999 Call DateToJulian(1,tmp$,tmp1$,F)
		If f let tmp1$=""
		JDate[2]=tmp1$ ! julian ord shipdate
		! call programdump("/tmp/ollog14!","")
		! write back
		nrol.SpareNU3$=blank$
		clear nrol.SpareNu$ ! dl4 fix
		CALL BOREMCHK() ! final avail check before update
		if borfail goto UDLDone ! NO WRITE OR UPDATE TIL OK!!
		If NewLn ! new line
			OLR=fileupdaterolz(e$,OLC,"a",rcdno,nrol.)
			! If OLR<0 ! will pass e$ to bottom
			! set up for new immediate allocation
			If OLR>0 ! has to have a record!
			  If Not(NonStk)
			   If nrol.UpdtStk
				Atype=0 \ if credit let Atype=1
				FChan[0]=OHC;FChan[1]=OLC;FChan[2]=SLTC;FChan[3]=PLTC
				FRec[0]=OHR;FRec[1]=OLR
				call Allocordlot(e$,intCo,AType,FChan[],FRec[],Rasl,Status)
			   Endif 
			  Else 
				nstk.OrdLineRec=OLR
				if credit let x=-1 else let x=1
				cnvtu[0]=0;cnvtu[1]=nrol.UMSell;cnvtu[2]=1
				cnvta=nrol.QtyShip
				Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				nstk.QtyShip=(Amount*x) ! store credits as neg (IN SELL UM!)
				cnvtu[0]=0;cnvtu[1]=nrol.UMSell;cnvtu[2]=2
				Cnvta=nrol.UnitCost
				Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				nstk.UnitCost=Amount ! nrol.UnitCost (SAYS IN sELL UM)
				cnvtu[0]=0;cnvtu[1]=nrol.UMSell;cnvtu[2]=2
				Cnvta=nrol.UnitPrice
				Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				nstk.UnitPrice=Amount ! nrol.UnitPrice (IN SELL UM!)
				nstk.ExtShipAmt=(nrol.ExtShipAmt*x) ! store credits as neg
				Write record #NSC,NSR,0;nstk.;
				If NSR>0 and OLR>0 and not(credit) ! new nonstk line - send alert
					clear x2[]
					clear x3[]
					tmp$=""
					x2[1]=ctlc;x2[2]=OLC;x2[4]=OHC;X2[5]=OSC;X2[6]=OTC;x2[7]=CCC
					x2[8]=CUC ! x2[]=file channels
					X3[0]=21;x3[1]=Cnstk.Buyer;x3[2]=OLR;x3[3]=OHR
					x3[4]=V3[3];x3[5]=v3[4];x3[6]=v3[5] ! qty: ord,bo,ship (as entered)
					! x3=vars 0=alert,1=buyer,2=ordline,3=ordhead
					call "libalertproc.lib",x3[],x2[],tmp$
				Endif
			  Endif ! nonstk
			  clear e$
			Endif ! has rec
		Else ! existing line
			Write record #OLC,OLR,0;nrol.;
			if Not(nonStk)
			  If Not(Credit) and rol.UpdtStk ! back out prev qty ord from prod & whse
				Read record #PRC,PRR,0;PR.
				If PWR>0 Read Record #PWC,PWR,0;pw.
				X3=ROL.QtyShip ! as mxline does it
				if roh.OrdType=15 or roh.ordtype=19 let x3=rol.QtyOrd-rol.PrevQtyShip-rol.QtyBO
				if custom_customer$="MORRISETTE"
					If roh.OrdType=4 Let X3=ROL.QtyShip ! "cct 129415 - only commit shipping qty
				Endif
				IF roh.OrdType=15 AND roh.BOCTR<>0 LET x3=0        
				IF roh.OrdType=15 AND roh.BOCTR=0 LET x3=rol.QtyOrd
				if roh.ordtype=19 and roh.boctr<>0 and roh.ot19comp=0 let x3=0 ! closed!
				If X3<0 let X3=0 ! neg ship - no Onord update
				pr.QtyOnOrd=pr.QtyOnOrd-X3
				pw.QtyOnOrd=pw.QtyOnOrd-x3
				if onCPI ! of old line allocated to contract
					cpid.QuantityAllocated=cpid.QuantityAllocated-x3
					write record #CPIDC,recCPI,0;CPID.;
				end if
				IF JDATE[1]>=JDATE[2]
					LET pr.Lvl1Qty=pr.Lvl1Qty-x3
					Let pw.Lvl1Qty=pw.Lvl1Qty-x3
					if pr.Lvl1Qty<0 let pr.Lvl1Qty=0
					if pw.Lvl1Qty<0 let pw.Lvl1Qty=0
				ELSE
					LET pr.Lvl2Qty=pr.Lvl2Qty-x3
					Let pw.Lvl2Qty=pw.Lvl2Qty-x3
					if pr.Lvl2Qty<0 let pr.Lvl2Qty=0
					if pw.Lvl2Qty<0 let pw.Lvl2Qty=0
				Endif
				if pr.CatchwgtItem$="Y"
					X=1 \ if rol.QtyOrd<0 let x=0 ! -1 ! neg ord/ship (wgt always +)
					IF roh.OrdType=15 AND roh.BOCTR<>0 LET x=0 ! NO QTY
					pr.LbsOnOrder=pr.LbsOnOrder-(rol.ExtNetWgt*x)
					pw.LbsOnOrder=pw.LbsOnOrder-(rol.ExtNetWgt*x)
				Endif
				If pr.QtyOnOrd<0 Let pr.QtyOnOrd=0
				If pw.QtyOnOrd<0 let pw.QtyOnOrd=0
				If pr.LbsOnOrder<0 Let pr.LbsOnOrder=0
				If pw.LbsOnOrder<0 Let pw.LbsOnOrder=0
				Write Record #PRC,PRR,0;PR.;
				if sqlChan >= 0 ! MySQL enabled and channel opened
					call prod_DL4SQLConvert(e$,"FROMDL4",PR.,sql_prod.,PRR)
					e = prod_SQLAddUpdate(e$,sqlChan,sql_prod.) ! mode="a" or "c"
					if e <> 1 ! returns the number of records add/updated/deleted
						error 11000
					end if
				end if
				If PWR>0 Write Record #PWC,PWR,0;pw.;
			  Endif ! of updatestk
			Else ! is non-stk & existing line
				X=1 \ if credit let x=-1
				cnvtu[0]=0;cnvtu[1]=nrol.UMSell;cnvtu[2]=1
				cnvta=nrol.QtyShip
				Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				nstk.QtyShip=(Amount*x) ! store credits as neg (IN SELL UM!)
				cnvtu[0]=0;cnvtu[1]=nrol.UMSell;cnvtu[2]=2
				Cnvta=nrol.UnitCost
				Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				nstk.UnitCost=Amount ! nrol.UnitCost (SAYS IN sELL UM)
				cnvtu[0]=0;cnvtu[1]=nrol.UMSell;cnvtu[2]=2
				Cnvta=nrol.UnitPrice
				Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				nstk.UnitPrice=Amount ! nrol.UnitPrice (IN SELL UM!)
				nstk.ExtShipAmt=(nrol.ExtShipAmt*x) ! credits stored as neg
				Write record #NSC,NSR,0;nstk.;
			Endif ! existing
		Endif ! new / existing
		! add qtyord to prod & Whse
		if Not(nonStk) and Not(Credit) and nrol.UpdtStk ! add NEW qty ord to prod & whse
			Read record #PRC,PRR,0;PR.
			! in case whse change - get whse again
			tmp$=" ",tmp$
			tmp$=pr.prodcode$+nrol.whse using "##"
			if roh.ordtype=7 let tmp$=pr.prodcode$+roh.ConsWh using "##"
			PWR=filegetprodwhse(e$,pwc,"=",1,tmp$,pw.,1)! get and LOCK
			clear e$
			If PWR<0 ! search error
			  Clear pw.
			  if PWR=-1 ! new whse not found - add it now
				E$="";x3=tmp$[13,14] ! CLEAR NOF msg
				if roh.ordtype=7
					x3[1]=nrol.whse/100
					x3=x3+x3[1]
				Endif
				Whbld[0]=PWC;Whbld[1]=x3;WhBld[2]=pr.PrimVend
				if x3<>1 let Whbld[1]=X3+.01 ! fra=copy whse 1
				Call mxwhcreate(e$,IntCo,pr.PRODCode$,WHBLD[])
				PWR=Whbld[2]
				Read Record #PWC,PWR,0;pw.
			  Endif
			Endif
			X3=NROL.QtyShip ! as mxline does it
			if roh.OrdType=15 or roh.ordtype=19 let x3=nrol.QtyOrd-nrol.PrevQtyShip-nrol.QtyBO
			if custom_customer$="MORRISETTE"
				If roh.OrdType=4 Let X3=NROL.QtyShip ! "cct 129415 - only commit shipping qty
			Endif
			IF roh.OrdType=15 AND roh.BOCTR<>0 LET x3=0        
			IF roh.OrdType=15 AND roh.BOCTR=0 LET x3=nrol.QtyOrd
			if roh.ordtype=19 and roh.boctr<>0 and roh.ot19comp=0 let x3=0 ! closed
			if x3<0 let X3=0 ! no neg onord update
			pr.QtyOnOrd=pr.QtyOnOrd+X3
			pw.QtyOnOrd=pw.QtyOnOrd+x3
			if nOnCPI ! if new line alloacted to contract
				cpid.QuantityAllocated=cpid.QuantityAllocated+x3
				write record #CPIDC,recCPI,0;CPID.;
			end if
			IF JDATE[1]>=JDATE[2]
				LET pr.Lvl1Qty=pr.Lvl1Qty+x3
				Let pw.Lvl1Qty=pw.Lvl1Qty+x3
			ELSE
				LET pr.Lvl2Qty=pr.Lvl2Qty+x3
				Let pw.Lvl2Qty=pw.Lvl2Qty+x3
			Endif
			if pr.CatchwgtItem$="Y"
				X=1 \ if nrol.QtyOrd<0 let x=0 ! -1 ! neg ord/ship (wgt always +)
				IF roh.OrdType=15 AND roh.BOCTR<>0 LET x=0 ! NO QTY
				pr.LbsOnOrder=pr.LbsOnOrder+(nrol.ExtNetWgt*x)
				pw.LbsOnOrder=pw.LbsOnOrder+(nrol.ExtNetWgt*x)
			Endif
			Write Record #PRC,PRR,0;PR.;
			if sqlChan >= 0 ! MySQL enabled and channel opened
				call prod_DL4SQLConvert(e$,"FROMDL4",PR.,sql_prod.,PRR)
				e = prod_SQLAddUpdate(e$,sqlChan,sql_prod.) ! mode="a" or "c"
				if e <> 1 ! returns the number of records add/updated/deleted
					error 11000
				end if
			end if
			If PWR>0 Write Record #PWC,PWR,0;pw.;
			IF PW.QtyOnHand-pw.QtyOnOrd<0 
				If rtrim$(holdpswd$[3])<>"" LET HFlag[2]=1 ! OOS hold
			endif
			If pr.QtyOnHand-pr.QtyOnOrd<0 
				If rtrim$(holdpswd$[3])<>"" LET HFlag[2]=1
			endif
		Endif
		ELDLine: ! end of line load
		If E$<>"" ! had an issue
			message$=message$+e$
			ReturnStatus=0
			! goto UDLDone ! bypass rest?
		Endif
		if delline goto UDLDone
	! Next X1 ! process next line sent (was for multiple
	
	! now any post update work starts
	iF not(roh.HoldOver) ! repack holds
		! HFlag[x]=set in this routine, HFlg[x]=set previously
		If HFlag[2] Let HFlg[2]=chkhldcode(3) ! hold passwd=1+ the flag
		If HFlag[4] let HFlg[4]=chkhldcode(5)
		If HFlag[5] let HFlg[5]=chkhldcode(6)
		
		LET X3=0 ! repack holds                               
		FOR CTR=0 TO 11                         
			IF HFlg[CTR] LET X3=X3+2^CTR            
		NEXT CTR                                
		LET rot.HoldCode=X3
		IF (Credit) LET rot.HoldCode=0
		if roh.ordtype=16 let rot.HoldCode=0
		WRITE Record #otc,roh.TotRec,0;rot.;
	Endif
	! set for mxrasl
	! was after all lines processed - now is single line? do whole order rasl on every line?
	if Not(nonStk) and olr>0 ! don't bother on zline or nonstk line
		S9[2]=OHR;S9[3]=0;S9[4]=source ! determine program #?
		If credit let S9[3]=4;S9[4]=243 ! credit
		if source=2082 let s9[4]=208
		if s9[4]<=0 let s9[4]=208 ! send something!
		S9[12]=OLR ! PASS THE LINE JUST UPDATED (new single line mxrasl5)?
		FChan[0]=1;FChan[1]=PRC;FCHan[2]=OHC;FChan[3]=OLC
		FChan[4]=0;FChan[5]=ccc;FChan[6]=PLTC;FChan[7]=0
		FChan[8]=SLTC;FChan[9]=0
		! Call dxsave(0,"/tmp/jcs.txt!")
		Call "MXRASL5.DL4",intco,Ctlc,S9[],FChan[]
	Endif
	IF returnstatus=1 and PR.SerNoTrack$="Y" and nrol.qtyship<>0 ! add serial number check/message
		call chk4sns()
	Endif
	UDLDone: ! send status back
	if returnstatus=1 let message$="OK" ! set if no other problems
	if debugdetail
		dmsg$="Update Line "+Str$(rol.OrdNum)+"-"+Str$(rol.LineNum)+" "+rol.ProdCode$+Message$ \ Call updatelog(debug)
	Endif
	IF ACTION$="NSBUILDPROD"
		exit sub ! do not create status section
	endif
	if kit and returnstatus=1 ! ok
		if kitchg ! something changed
			returnstatus=2 ! ok - but kit screen needed
			message$="KITSCREEN"
		Endif
	Endif
	clear list$[]
	List$[0]=bsdel$,"OrderSubmit",fdel$
	WebStr$="OrderId",fdel$
	Webstr$=webstr$,"InvoiceId",fdel$
	webstr$=webstr$,"ORDERAMT",fdel$
	webstr$=webstr$,"ORDERCOST",fdel$
	List$[1]=WebStr$
	WebStr$=str$(orderid),fdel$
	Webstr$=webstr$,str$(roh.invnum),fdel$
	webstr$=webstr$,str$(rot.mdseordamt),fdel$
	webstr$=webstr$,str$(rot.totordcost),fdel$
	LIST$[2]=Webstr$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	
 else
    include "src/callsuberr.inc"
 end try
end sub ! UpdtLines
! 
!--------------------------------------------------------------------
Function getnxtline(OrderNum)
! get first available order line number
 Try
	Dim OLK$[60]
	Dim 3%,LRec,NRec

	Dim CRol. as rolnew ! do not use rol. or nrol.!(would overwrite)
	dim cnstk. as sproddesc ! pm also checks nonstk file
	
	
	X2=1
	CHKNXTLN: ! loop til not found (get first available line)
	OLK$=" ",OLK$
	OLK$[1,6]=OrderNum Using "######"
	OLK$[7,9]=X2 Using "###"
	OLK$[11]="" ! cut to length
	LRec=filegetrolz(e$,OLC,"=",1,OLK$,crol.)
	clear e$
	If LRec>0 ! found a line with same number
		x2=x2+1
		if x2>999 Error 10000 ! bomb it!
		goto chknxtln
	Endif ! not found - check sproddesc
	NRec=filegetsproddesc(e$,NSC,"=",1,OLK$,cnstk.)
	clear e$
	If NRec>0 ! found a line with same number
		x2=x2+1
		if x2>999 Error 10000 ! bomb it!
		goto chknxtln
	Endif ! not found - drop thru and send back
	e$="" ! clear any not found messg
	if debugdetail
		dmsg$="Get new Line No "+Str$(rol.OrdNum)+"-"+Str$(X2) \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
  end try
end Function X2 ! getnxtline
! 
!--------------------------------------------------------------------
Sub DELOLINE(ordnum,linenum,OLR)
! delete an order line
 Try
	! all passed from UpdtLines(only place to delete!)
	! ALSO NEEDS EDITTRACK ACTION=2 (DELETE)
	! OLR MAY BE ZERO - SO see if actually there first (and nonstocks)
	! Dim ETR. as edittrack
	! Dim NRol. as rolnew ! store new sent data

	RTC=OpenFile(9950,IntCo) \ if RTC = -1 Let RTC=0 ! Error 42
	! SLTC=OpenFile(2320,IntCo) \ if SLTC = -1 Error 42
	Dim PLot. as sprodlot
	Dim SLot. as sordlot
	Dim crol. as rolnew
	Dim rtg. as roltag

	Dim SLKey$[60],PLKey$[60],PWKey$[60],RTKey$[60]
	Dim SLKey2$[60],SLKey1$[60],sn1$[54],F$[16]
	Dim 3%,leftOnCPI,recCPI
	dim 1%,sn1,snn1[2],onCPI,2%,sn0[1],3%,rec_ron
	
	Read #ctlc,3,188;ShipDate; ! for inv levels
	if debugdetail
		dmsg$="Delete Line "+Str$(OrdNum)+"-"+Str$(LineNum) \ Call updatelog(debug)
	Endif
	if roh.ordtype=15 and roh.boctr<>0 ! cannot delete
		returnstatus=0
		message$="Cannot delete the line off order if invoiced"
		Exit sub
	Endif
	tmp$=ShipDate Using "&&&&&&"
	Call DateToJulian(1,tmp$,tmp1$,F)
	IF F let tmp1$=""
	JDate[1]=tmp1$;F=0 ! julian sys shipdate
	tmp$=roh.ShipDate Using "&&&&&&"
	if roh.ShipDate<>999999 Call DateToJulian(1,tmp$,tmp1$,F)
	If f let tmp1$=""
	JDate[2]=tmp1$ ! julian ord shipdate
	If OLR<=0 ! no record, see if there!
		PWKey$=" ",PWKey$
		PWKey$[1,6]=OrdNum Using "######"
		PWKey$[7,9]=LineNum Using "###"
		PWKey$[11]=""
		OLR=filegetrolz(e$,OLC,"=",1,PWKey$,nrol.)
		clear e$
		If OLR<0 exit sub ! NO LINE (New?)
		RTKey$=PWKey$ ! keep line key!
	Endif
	Clear crol. ! would have no org nos!
	Read record #OLC,OLR,0;rol.;
	If roh.ordtype=19 
		if rol.PrevQtyShip<>0
			returnstatus=0
			message$="Can not delete line - shipments made"
			exit sub
		Endif
		if rol.QtyOrd<>0 And rol.PrevQtyShip=rol.QtyOrd
			returnstatus=0
			message$="Line is closed. Cannot delete it"
			exit sub
		Endif
	Endif
	if (roh.ordtype=4 or roh.ordtype=15) and (rol.PrevQtyShip<>0 or rol.PrevBill<>0 or rol.PrevRelQty<>0)
		returnstatus=0
		message$="Line has shipments/releases - Cannot delete"
		exit sub
	Endif
	CALL Check_If_SO_Linked_To_PO(ROH.,ROL.,rot.)
	if returnstatus=0 exit sub
	if custom_customer$="ACME" or custom_customer$="WENELSON"
		if returnstatus=2 exit sub
	endif
	If P60$[44,44]="Y" 
		etr.EtAction=2 ! delete
		Clear crol.
		Call EdtTrkDo(crol.,rol.) ! org, new
	Endif ! of edit tracking
	! back out of sord/sprodlot
	Nonstk=rol.NStkItem
	if Not(nonStk) and rol.UpdtStk ! back out prev qty ord from prod & whse
		If not(credit)  ! credits = no on ord
			PRR=rol.PDRecNum
			Read record #PRC,PRR,0;PR.
			PWKey$=" ",PWKey$
			PWKey$=rol.ProdCode$+rol.Whse Using "##"
			if roh.ordtype=7 let PWKey$=rol.ProdCode$+roh.ConsWh Using "##"
			PWR=filegetprodwhse(e$,PWC,"=",1,Pwkey$,PW.)
			! FIND OUT IF THIS IS ON A CPI CONTRACT
			onCPI = 0
			if P61$[111,111] = "Y" AND not(credit) and rol.Contract
				if roh.OrdType = 2 or roh.OrdType = 8 and roh.OrdType = 16 goto notCPIDel
				if not(rol.UpdtStk) goto notCPIDel
				! see if contract involved is a cpi contact
				tmp$=rol.Contract Using "C#####"
				cphr = filegetcontracth(e$,cphc,"=",1,tmp$,contracth.)
				If cphr<=0 goto notCPIDel:
				if not(contracth.CPI) goto notCPIDel:
				! now we gotta find the product on both the
				! specprice and cpidet
				tmp$=rol.Contract Using "C#####"+rol.ProdCode$
				recCPI = filegetcpidet(e$,cpidc,"=",1,tmp$,cpid.)
				If recCPI<=0 goto notCPIDel
				if not(CPID.ResStock) goto notCPIDel ! no qty limit
				onCPI = 1
			end if
			notCPIDel: !
			clear e$
			If PWR<0 Clear pw.
			! no add of whse on delete
			X3=ROL.QtyShip ! as mxline does it
			if roh.OrdType=15 or roh.ordtype=19 let x3=rol.QtyOrd-rol.PrevQtyShip-rol.QtyBO
			if custom_customer$="MORRISETTE"
				If roh.OrdType=4 Let X3=ROL.QtyShip ! "cct 129415 - only commit shipping qty
			Endif
			IF roh.OrdType=15 AND roh.BOCTR<>0 LET x3=0        
			IF roh.OrdType=15 AND roh.BOCTR=0 LET x3=rol.QtyOrd
			if x3>0
				pr.QtyOnOrd=pr.QtyOnOrd-X3
				pw.QtyOnOrd=pw.QtyOnOrd-x3
				if onCPI
					cpid.QuantityAllocated=cpid.QuantityAllocated-x3
					write record #CPIDC,recCPI,0;CPID.;
				end if
				IF JDATE[1]>=JDATE[2]
					LET pr.Lvl1Qty=pr.Lvl1Qty-x3
					Let pw.Lvl1Qty=pw.Lvl1Qty-x3
					if pr.Lvl1Qty<0 let pr.Lvl1Qty=0
					if pw.Lvl1Qty<0 let pw.Lvl1Qty=0
				ELSE
					LET pr.Lvl2Qty=pr.Lvl2Qty-x3
					Let pw.Lvl2Qty=pw.Lvl2Qty-x3
					if pr.Lvl2Qty<0 let pr.Lvl2Qty=0
					if pw.Lvl2Qty<0 let pw.Lvl2Qty=0
				Endif
				if pr.CatchwgtItem$="Y"
					X=1 \ if rol.QtyOrd<0 let x=-1 ! neg ord/ship (wgt always +)
					IF roh.OrdType=15 AND roh.BOCTR<>0 LET x=0 ! NO QTY
					pr.LbsOnOrder=pr.LbsOnOrder-(rol.ExtNetWgt*x)
					pw.LbsOnOrder=pw.LbsOnOrder-(rol.ExtNetWgt*x)
				Endif
			endif
			If pr.QtyOnOrd<0 Let pr.QtyOnOrd=0
			If pw.QtyOnOrd<0 let pw.QtyOnOrd=0
			If pr.LbsOnOrder<0 Let pr.LbsOnOrder=0
			If pw.LbsOnOrder<0 Let pw.LbsOnOrder=0
			Write Record #PRC,PRR,0;PR.;
			if sqlChan >= 0 ! MySQL enabled and channel opened
				call prod_DL4SQLConvert(e$,"FROMDL4",PR.,sql_prod.,PRR)
				e = prod_SQLAddUpdate(e$,sqlChan,sql_prod.) ! mode="a" or "c"
				if e <> 1 ! returns the number of records add/updated/deleted
					error 11000
				end if
			end if
			IF PWR>0 Write Record #PWC,PWR,0;pw.; ! in case not found
		Endif ! of update on order
	Endif ! of stk & updatestk
	! now sord/sprodlot - in all cases at least try
	SLKey$=" ",SLKey$
	SLKey$[1,6]=OrdNum Using "######"
	SLKey$[7,9]=rol.LineNum Using "###"
	slkey$[11]=""
	tmp$=SLKey$
	Do
		SLTR=filegetsordlotz(e$,SLTC,">",3,SLKey$,slot.)
		clear e$
		If SLTR<0 Exit do
		If SLKey$[1,9]<>tmp$[1,9] exit do
		Whse=slot.Whse ! 2 diff on cons/xfer
		PLKey$=" ",PLKey$
		PLKey$[1,2]=Whse Using "##"
		PLkey$[3,8]=SLKey$[12,17] ! location
		PLKey$[9,32]=Slot.ProdCode$,Slot.LotNum$
		! PLKey$[33]="" ! Cutting @ stock? (not for struct type!)
		PLKey$[43]="" ! length=42
		PLTR=filegetsprodlot(e$,PLTC,"=",3,PLKey$,plot.)
		clear e$
		If PLTR>0
			IF slot.QtyAlloc>0 LET plot.QtyAlloc=plot.QtyAlloc-slot.QtyAlloc ! WAS S3                                     
			IF slot.QtyOnBO>0 LET plot.QtyBO=plot.QtyBO-slot.QtyOnBO                                                      
			IF plot.QtyBO<0 LET plot.QtyBO=0                                                       
			IF plot.QtyAlloc<0 LET plot.QtyAlloc=0
			WRITE RECORD #pltc,pltr,0;plot.; 
		Endif
		! now delete sordlot
		slot.NU$=Blank$ ! make sure blank for key
		!Write record #SLTC,SLTR,0;slot.;
		!X3=fileupdatesordlotz(e$,sltc,"d",SLTR,slot.) ! delete sordlot NOTWORKING 100%
		! If X3<0 ! error on delete
		! do PM way - not SQL
		SLKey2$ = " ",SLKey2$;SLKey2$[1,12] = slot.LotNum$;SLKey2$[13,22] = SLKey$[30,39]
		SLKey2$[23,39] = SLKey$[1,17];SLKey2$[40,51] = slot.ProdCode$
		SLKey1$ = " ",SLKey1$;SLKey1$[1,12] = SLKey2$[40,51];SLKey1$[13,29] = SLKey2$[23,39]
		SLKey1$[30,51] = SLKey2$[1,22]
		X3=0 ! search error flag
		Search #sltc,2,1;SLkey1$,r,E
		if not(e)
			search #SLTC,5,1;SLKey1$,R,E
			if e
				let returnstatus=0
				message$="Search Error ",Str$(E)," @ line ",SPC(10),"in serpordl"
				x3=11
			Endif
		Else
			message$="Search Error ",Str$(E)," @ line ",SPC(10),"in serpordl"
			x3=1
		Endif
		Search #sltc,2,2;SLKey2$,R,E
		if not(e)
			search #SLTC,5,2;SLKey2$,R,E
			if e
				let returnstatus=0
				message$="Search Error ",Str$(E)," @ line ",SPC(10),"in serpordl"
				x3=21
			Endif
		Else
			message$="Search Error ",Str$(E)," @ line ",SPC(10),"in serpordl"
			x3=2
		Endif
		Search #sltc,5,3;SLKey$,R,E
		if e
				let returnstatus=0
				message$="Search Error ",Str$(E)," @ line ",SPC(10),"in serpordl"
				x3=3
		Endif
		Let E=3;R=SLTR
		Search #sltc,1,0;SLKey$,R,E
		if e
				let returnstatus=0
				message$="Search Error ",Str$(E)," @ line ",SPC(10),"in serpordl"
				x3=4
		Endif
		if x3>0 ! search error - record it!
			system "echo ''" + msc$(0)+" "+ message$ + "'' >> files/1/erp.errlog"
			Dim msc4$[100] \ msc4$ = Msc$(4)
			If Pos(msc4$, = "/",-1) Let msc4$ = msc4$[Pos(msc4$, = "/",-1) + 1]
			Call env(2,"PROGNAME",msc4$)
			Call programdump()
		Endif
		! add for Berry/std - rasl unallocate location
		Call ChkWhRasl(e$,intco,Ctlc,WHI,Whse,RASL[])
		if rasl and Not(nonStk) and rol.UpdtStk ! yes it is
			if slot.loc$<>"NONE  " and slot.loc$<>"STOCK " ! only rasl locs
			 If roh.OrdType<>4 AND roh.OrdType<>15 ! not bill/holds!
			  IF roh.OrgStatus<9 OR roh.OrgStatus>11 !  not credit memos ! "custom-cct159966- htberry
				CALL "MoveToUnallocLoc.dl4",slot.ProdCode$,Whse,slot.LOC$,slot.LotNum$,slot.QtyAlloc,IntCo
			  ENDIF ! not for cm's
			 Endif ! not bill / holds
			Endif ! loc is raslbins only
		Endif ! rasl and updates stk
	Loop
		
	If NonStk and rol.LineType<>3 ! delete sproddesc (zline none)
		NSR=rol.PDRecNum ! record
		Read Record #NSC,NSR,0;nstk.;
		if nstk.SpareNu$=""
			let nstk.SpareNu$="  "
			write record #NSC,NSR,0;nstk.;
		Endif
		X3=fileupdatesproddesc(e$,nsc,"d",nsr,nstk.) ! delete sproddesc
		! if x3<0 ! problem deleting
	Endif
	if rol.KitDesignation$="KIT"
		FChan[1]=ohc;fchan[2]=osc;fchan[3]=otc
		FChan[4]=prc;fchan[5]=pwc;fchan[6]=sltc;fchan[7]=pltc
		fchan[9]=sqlChan;fchan[11]=0;fchan[12]=0
		KTC=openfile(1312,Intco)
		if ktc>0
			FChan[8]=ktc
			S9[7]=roh.ordnum;S9[9]=rol.linenum
			call DELOKIT(e$,IntCo,S9[],FChan[])
			e$=""
			Try close #KTC Else Rem
		Endif
	Endif
	! also delete kits, serial nos, catchwgts, etc
	If RTC>0 ! roltag file opened
		RTKey$=" ",RTKey$
		RTkey$[1,6]=rol.OrdNum using "######"
		RTKey$[7,9]=rol.LineNum using "###"
		RTKey$[11]="" ! space
		RTR=filegetroltag(e$,RTC,"=",1,RTKey$,rtg.)
		clear e$
		If RTR>0
			if rtg.Blankforkey$="" ! CANNOT BE NULL (from UB- causes SE)
				rtg.Blankforkey$=" "
				write record #RTC,RTR,0;rtg.;
			Endif
			X3=fileupdateroltag(e$,RTC,"d",RTR,rtg.)
		Else
			e$=""
		Endif
	Endif
	! SERIAL NUMBERS!
	Ch_PSN = OpenFile(416,intCo) \ If Ch_PSN = -1 Error 42  !product serial #'s
	ch_ordflen=OpenFile(2944,Intco) \ if ch_ordflen = -1 Error 42 !sordflen
	RTKey$=" ",RTKey$
	RTkey$[1,6]=rol.OrdNum using "######"
	RTKey$[7,9]=rol.LineNum using "###"
	SLKEY$=RTKEY$
	DO
		SEARCH #CH_ORDFLEN,3,1;RTKEY$,R[9],E
		IF E EXIT DO
		IF RTKEY$[1,9]<>SLKEY$[1,9] EXIT DO
		rec_ron=R[9]
		MAT  READ #CH_ORDFLEN,rec_ron,0;SN1$;                        
		!if sn1$[1,12]=proda$[140,151] ! even if diff prod?  yes                          
		MAT  READ #CH_ORDFLEN,rec_ron,54;SN0;                
		MAT  READ #CH_ORDFLEN,rec_ron,62;SN1;                
		SEARCH #CH_ORDFLEN,5,1;RTKEY$,rec_ron,E 
		If E let E$="Search Error "+Str$(E)+" @ line ",SPC(10),"in serpordl" \ Error 10000 ! Gosub ERR_SEARCH
		LET SLKEY2$=" ",SLKEY2$                        
		let SLKEY2$=SN1$[25,54]                         
		let SLKEY2$[31]=rol.PDRecNum USING "######" 
		Search #ch_ordflen,2,2;slkey2$,Rec_ron,E
		if not(e)
			SEARCH #CH_ORDFLEN,5,2;SLKEY2$,rec_ron,E
			If E let E$="Search Error "+Str$(E)+" @ line ",SPC(10),"in serpordl" \ Error 10000 ! Gosub ERR_SEARCH
		Endif
		LET E=3 \ SEARCH #CH_ORDFLEN,1,0;RTKEY$,r[9],E
		If E let E$="Search Error "+Str$(E)+" @ line ",SPC(10),"in serpordl" \ Error 10000 ! Gosub ERR_SEARCH
		if Ch_PSN>0
			if sn1>0 and sn0[1]>0                              
			READ #Ch_PSN,sn0[1],294;SNN1[2]      
			IF SNN1[2]=3 LET SNN1[2]=0             
			IF credit !! deleting c/m               
				IF SNN1[2]=5 LET SNN1[2]=1     
			ENDIF                                  
			WRITE #Ch_PSN,sn0[1],294;SNN1[2];    
			endif                                          
		endif                                                  
		!endif ! Right prod                
	LOOP
	TRY CLOSE #CH_PSN ELSE REM
	TRY CLOSE #CH_ORDFLEN ELSE REM
	! check the roll inventory
	if p61$[104,104]="Y" and pr.rollinv$="Y"
	
		ch_ror=findchannel()
		let f$="3/sordROLL"+STR$(Intco)
		try
			open #ch_ror,f$
			! delete roll items
			let keyroll$=" ",keyroll$
			let keyroll$[1,6]=rol.ordnum using "######"
			let keyroll$[7,9]=rol.linenum using "###"
			do
				search #ch_ror,3,1;keyroll$,rec_ror,e
				if e>0 exit do
				let tmp3=keyroll$[1,6]
				if tmp3<>rol.ordnum exit do
				let tmp3=keyroll$[7,9]
				if tmp3<>rol.linenum exit do
				let keyroll2$=" ",keyroll2$
				let keyroll2$[1,26]=keyroll$[11,36]
				let keyroll2$[27,36]=keyroll$[1,10]
				search #ch_ror,5,2;keyroll2$,rec_tmp,e
				If E let E$="Search Error "+Str$(E)+" @ line ",SPC(10),"in serpordl" \ Error 10000 ! Gosub ERR_SEARCH
				search #ch_ror,5,1;keyroll$,rec_tmp,e
				If E let E$="Search Error "+Str$(E)+" @ line ",SPC(10),"in serpordl" \ Error 10000 ! Gosub ERR_SEARCH
				let e=3\search #ch_ror,1,0;keyroll$,rec_ror,e
				If E let E$="Search Error "+Str$(E)+" @ line ",SPC(10),"in serpordl" \ Error 10000 ! Gosub ERR_SEARCH
			loop
		else
			! no roll file
		end try
	endif
	! end check for roll inventory
	! finally delete the line
	X3=fileupdaterolz(e$,OLC,"d",OLR,rol.)
	! if x3<0 ! problem with delete
	call DelParCnt(ordnum, linenum)
	call DelRFPick(ordnum, linenum)
	if debugdetail
		dmsg$="Line "+Str$(rol.OrdNum)+"-"+Str$(rol.LineNum)+" Deleted "+e$ \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
 end try
end sub ! DELOLINE
! 
!--------------------------------------------------------------------
Function Chkhldcode(hldnum)
! pass in hold code
! pass back 0=not used, 1=used
 Try
	Dim f1$[16],Htmp$[16]
	let x1=hldnum ! sent as 1+ (because flag[] is less one)
	x=0
	LET F1$=" ",F1$
	READ #ctlc,66,((X1*16)-16);F1$[1,16];
	HTmp$=Trim$(F1$)
	IF HTmp$[1,1]>"" let x=1 ! yes 
	IF QUOTE OR CREDIT X=0
	if debugdetail
		dmsg$="Hold chk "+Str$(hldnum)+" "+Str$(x) \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
 end try
end Function x ! Chkhldcode
! 
!--------------------------------------------------------------------
Sub EdtTrkDo(oorl. as rolnew, corl. as rolnew)
! roh. and rot. read PREVIOUSLY
! Have etr.etaction SET UP ALREADY
! oorl. = Original rol data
! corl. = Current/new rol data (CANNOT BE CLEAR!)
 Try
	If etr.EtAction=0 EXIT SUB ! no action
	fChan[0]=-1;fchan[1]=-1 ! no files open - etrack/usercntrl
	etr.OrdNum=corl.OrdNum
	etr.LineNum=corl.LineNum
	etr.Status=roh.OrgStatus \ IF etr.Status<=0 let etr.Status=roh.Status
	etr.ProdCode$=corl.ProdCode$
	etr.OrgQtyOrd=oorl.Qtyord;etr.NewQtyOrd=corl.QtyOrd
	etr.OrgQtyShip=oorl.QtyShip;etr.NewQtyShip=corl.QtyShip
	etr.OrgQtyBO=oorl.QtyBo;etr.NewQtyBO=corl.QtyBO
	e$=""
	! date,time,port,access gotten in call
	etr.AccessCode$=Userid$+Blank$
	etr.UMSell=corl.UMSell
	etr.NstkFlag=corl.NStkItem
	etr.OrgOrdTot=rot.OrdTot
	etr.CustNum=roh.CustNum
	etr.InvNum=roh.InvNum
	etr.Slsm=roh.SlsmNum
	etr.OrgUnitPrice=oorl.NETPRICE ! UnitPrice (actually net price)
	etr.NewUnitPrice=corl.netprice ! UnitPrice
	etr.UMPrice=corl.UMPrice
	etr.UMCost=corl.UMCost
	etr.OrgLoadCost=oorl.UnitCost
	etr.NewLoadCost=corl.UnitCost
	etr.UnitNetWgt=corl.LbsUnit
	etr.NetWgtFact=corl.WgtFactor
	etr.SpareNU$=Blank$
	if etr.etaction=11 or etr.etaction=2 ! add SET ORIG=NEW/cURR on ADD or DELETE
		etr.OrgQtyOrd=etr.NewQtyOrd
		etr.OrgQtyShip=etr.NewQtyShip
		etr.OrgQtyBO=etr.NewQtyBO
		etr.OrgUnitPrice=etr.NewUnitPrice
		etr.OrgLoadCost=etr.NewLoadCost
	Endif	
	Call MakeEdittrack(e$,IntCo,fchan[],etr.)
	if debugdetail
		dmsg$="Edittrack "+Str$(etr.OrdNum)+"-"+Str$(etr.LineNum)+" "+Str$(etr.EtAction)+e$ \ Call updatelog(debug)
	Endif
	e$=""
 else
    include "src/callsuberr.inc"
 end try
end sub ! EdtTrkDo
! 
!--------------------------------------------------------------------
Sub updatelog(debug)                                        
    If not(debug) Exit Sub                                    
	System "echo ''" + msc$(0) + " UID "+RTrim$(Userid$)+" " + dmsg$ + "'' >> " + dblog$
End Sub 
! 
!--------------------------------------------------------------------
Sub SUCMSELLN()
	! read in cmno,invno (from existing CM)
	! read product line is for
	! call off to mxselinvln to generate list of inv's & cm's
	!  to select from (based on pm program)
 Try
	Errflag=0;Message$="OK"
		if debugdetail
			Dmsg$="Start Inv Line List for C/M" \ call updatelog(debug)
		Endif
		Call dxget("CMNUM",tmp$)
		X2=tmp$
		if x2<=0 or x2>999999 or fra(x2)
			returnstatus=0
			Message$="INVALID CREDIT MEMO NUMBER"
			goto SELILNDone
		Endif
		let cmnum=x2
		OrderNo=CMNum
		OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
		e$=""
		If OHR<=0 ! no order found
			Let message$="ORDER # NOT FOUND"
			Let ReturnStatus=0
			goto SELILNDone
		Endif
		!Call dxget("INVNUM",tmp$)
		!x2=tmp$
		!If X2<0 or fra(X2) ! can be zero
			!returnstatus=0
			!Message$="INVALID INVOICE NUMBER"
			!goto SELILNDone
		!Endif
		let invnum=roh.InvNum ! x2  (get from header)
		Let CustNum=ROH.CustNum ! instead of asking
		Call DXGet("PRODID",prod$) \ prod$=UCase$(prod$)
		Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
		ProdKey$=Prod$
		PrR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.) ! product mode=2 dir=1
		clear e$
		If PRR<=0 
			Let message$="PRODUCT NOT FOUND"
			Let ReturnStatus=0
			goto SELILNDone
		Endif
		Clear FlePtr[]
		fleptr[1,0]=prc;fleptr[2,0]=pwc;fleptr[3,0]=cmc
		fleptr[7,0]=ccc;fleptr[9,0]=CUC
		fleptr[11,0]=OLC;fleptr[12,0]=NSC;fleptr[15,0]=OHC
		FlePtr[1,1]=PRR ! prod rec
		call "mxselinvln.dl4",CMNUM,CUSTNUM,PROD$,FLEPTR[],ERRFLAG,INVNUM,maxcnt,List$[],Message$
		e$=""
		Call AddToStr(e$,rstr$,List$[]) ! add list
		ReturnStatus=1 \ if errflag let returnstatus=0;Message$="Error in Line List"
		SELILNDone: ! status section                                                       
		Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)                 
		Call AddToStr(e$,rstr$,WebStr$)                                        
		Call SetOutPut(e$,rstr$)  
		if debugdetail
			Dmsg$="End of Inv Line List for C/M Prod "+Prod$+Message$ \ call updatelog(debug)
		Endif
 else
    include "src/callsuberr.inc"
 end try
end sub ! SUCMSELLN
! 
!--------------------------------------------------------------------
Sub CMCPILINE()
 ! read in cmno,invno,Qty(Left),invline to copy
 ! call to mxcpline to do copy (based on pm program)
 Try
	ErrFlag=0;Message$="OK"
		if debugdetail
			dmsg$="Start Inv Line Copy to CM" \ call updatelog(debug)
		Endif
		Call dxget("CMNUM",tmp$)
		X2=tmp$
		if x2<=0 or x2>999999 or fra(x2)
			returnstatus=0
			Message$="INVALID CREDIT MEMO NUMBER"
			goto CPILNDone
		Endif
		let cmnum=x2
		OrderNo=CMNum
		OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
		e$=""
		If OHR<=0 ! no order found
			Let message$="ORDER # NOT FOUND"
			Let ReturnStatus=0
			goto CPILNDone
		Endif
		Call dxget("INVNUM",tmp$)
		x3=tmp$
		If X3<0 or fra(X3) ! can be zero
			returnstatus=0
			Message$="INVALID INVOICE NUMBER"
			goto CPILNDone
		Endif
		let invnum=x3
		call dxget("QLBASE",tmp$) ! BASE LEFT TO CREDIT (FROM LIST)
		X3=tmp$
		if X3<=0 ! no good
			returnstatus=0
			Message$="INVALID CREDIT QUANTITY"
			goto CPILNDone
		Endif
		CQty=x3
		call dxget("INVLN",tmp$)
		let x2=tmp$
		if x2<=0 or x2>999 or fra(X2)
			returnstatus=0
			Message$="INVALID INVOICE LINE NUMBER"
			goto CPILNDone
		Endif
		invln=x2
		cmln=getnxtline(cmnum) ! get next new line # to use
		CMType=roh.ShipType
		cmwhse=roh.Wh
		cmordtype=roh.OrdType
		custnum=roh.CustNum
		Clear FlePtr[]
		fleptr[1,0]=prc;fleptr[2,0]=pwc;fleptr[3,0]=cmc
		fleptr[7,0]=ccc;fleptr[9,0]=CUC
		fleptr[11,0]=OLC;fleptr[12,0]=NSC;fleptr[15,0]=OHC
		fleptr[0,1]=intco;fleptr[4,0]=SLTC;fleptr[5,0]=PLTC
		call "mxcpline.dl4",INVNUM,INVLN,CMNUM,CMLN,CMTYPE,CMWHSE,CMORDTYPE,FLEPTR[],ERRFLAG,CUSTNUM,CQty,Message$
		ReturnStatus=1 \ if errflag let returnstatus=0;message$="Error in Line Copy"
		CPILNDone: ! status section                                                       
		Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)                 
		Call AddToStr(e$,rstr$,WebStr$)                                        
		Call SetOutPut(e$,rstr$)  
		if debugdetail
			dmsg$="End Inv "+Str$(INVNum)+"-"+Str$(invln)+" Copy to CM "+Str$(CMNUM)+"-"+Str$(CMLN)+" "+Message$ \ call updatelog(debug)
		Endif
  else
    include "src/callsuberr.inc"
 end try
end sub ! CMCPILINE
! 
!--------------------------------------------------------------------
Sub ChkTOWhse(Tpwkey$,Vendor)
 ! need a check / create of whse going to (OT 8 & 16)
 ! pass in the key to check & Vendor Number
 Try
	dim cpw. as prodwhse ! don't use normal
	dim 1%,TWH
	Dim 3%,TWHBld[5],TPWR
	If tpwkey$[1,1]="" or tpwkey$[1,12]=Blank$[1,12] Exit sub ! NO PROD - NO CHECK
	TWH=tpwkey$[13,14]
	TPWKey$[15]=""
	if TWH>0 and TWH<100 and Not(Fra(TWH)) ! only valid whses
		TPWR=filegetprodwhse(e$,PWC,"=",1,TPWKey$,cpw.)
		clear e$
		If TPWR=-1 ! not found - build it
			TWhbld[0]=PWC;TWhbld[1]=TWH;TWhBld[2]=Vendor
			if twh<>1 let TWHBLD[1]=TWH+.01 ! fra=COPY WHSE 1
			Call mxwhcreate(e$,IntCo,TPWKey$[1,12],TWHBLD[])
			IF TWHBLD[2]>0
				if debugdetail
					dmsg$="Build new ConsXfer whse "+tpwkey$ \ Call updatelog(debug)
				Endif
			Else ! error
				if debugdetail
					dmsg$="ERROR "+Str$(TWHBLD[2])+" Build new ConsXfer whse "+tpwkey$ \ Call updatelog(debug)
				Endif
			Endif ! of good build
		Endif ! of no pwhse found
	Endif ! of valid whse
 else
    include "src/callsuberr.inc"
 end try
end sub ! ChkTOWhse
! 
!--------------------------------------------------------------------
Sub getot15list(e$,SList$[],row2,tmpcnt2,Cust,Prod$,SUM)
! send list of ot15's for cust/prod
 Try
	dim croh. as roh
	dim crol. as rolnew
	dim TKey$[60],Tkey2$[60]
	tkey$=" ",tkey$
	tkey$[1,6]=Cust Using "######"
	do
		search #OHC,3,2;tkey$,r[2],E
		if e exit do
		X2=TKEY$[1,6] \ IF X2<>Cust Exit do
		read record #OHC,R[2],0;croh.;
		if croh.status>7 goto BPHODone
		if croh.ordtype=15 or (custom_customer$="WHITERIVER" and croh.ordtype=4) ! and croh.OrdNum<>roh.Ordnum
			let tkey2$=" ",tkey2$
			let tkey2$[1,6]=croh.OrdNum using "######"
			do
				search #OLC,3,1;tkey2$,r[3],E
				if e exit do
				x2=tkey2$[1,6] \ if x2<>croh.ordnum exit do
				read record #OLC,R[3],0;crol.;
				if crol.ProdCode$=prod$ ! same - load list
					Webstr$=Prod$,fdel$
					Webstr$=webstr$,str$(CRoh.ordnum)
					if custom_customer$="WHITERIVER" ! add order type
						let webstr$=webstr$," OT ",Str$(croh.ordtype)
					endif
					webstr$=webstr$,fdel$,Str$(crol.LineNum),fdel$
					X3=crol.QtyOrd-crol.QtyShip-crol.PrevQtyShip
					cnvtu[0]=0;cnvtu[1]=SUM;cnvtu[2]=1
					CNVTA=X3 \ if sum>0 and crol.numout>0 let cnvta=x3/crol.numout
					Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
					Webstr$=WebStr$,LTrim$(Amount using QMask$),fdel$
					tmp$=XUNIT$(SUM,ccc)
					webstr$=webstr$,tmp$,fdel$
					SList$[row2]=webstr$
					row2=row2+1
					If row2>tmpcnt2 let tmpcnt2=expandarray(e$,SList$[])
				Endif
			Loop
		Endif ! of ot15 
	BPHODone: !bypass
	Loop
 else
    include "src/callsuberr.inc"
 end try
end sub ! getot15list
! 
!--------------------------------------------------------------------
sub getsubstlist()
! get a list of substitute items for a product
! output like scan list

 Try
	Dim 1%,OType
	Dim 2%,Whse
	Dim 3%,tmpcnt
	
	Call DXGet("PRODID",tmp$)
	Prod$=UCase$(tmp$)
	Prod$=Prod$+Blank$
	If Len(Prod$)>12 let prod$[13]=""
	Call DXGet("WHSE",tmp$)
	Whse=tmp$
	
	ReturnStatus=1
	Message$="OK"
	If Whse<1 or whse>99 or Fra(whse)
	  ReturnStatus=0
	  Message$="WAREHOUSE NOT PASSED"
	  Goto SubstDone ! needs to be?
	Endif
	ProdKey$=Prod$
	ProdKey$[13]="" ! cut to length
	PRR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.)
	clear e$
	If PRR<=0 ! has to exist!
		ReturnStatus=0
		Message$="PRODUCT NOT FOUND"
		Goto SubstDone ! has to be
	Endif
	Call DXGet("ORDTYPE",tmp$)
	Let OType=tmp$ \ if otype<0 Or OType>38 Let OType=0

	Call SubstIList(e$,IntCo,List$[],maxcnt,ctlc,prc,whc,ccc,Prod$,Whse,OType)
	e$=""
	call AddToStr(e$,rstr$,List$[])
	SubstDone: ! finish Substlist get
	! status section
	if debugdetail
		dmsg$="Substitute List "+prod$+Message$ \ Call updatelog(debug)
	Endif
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
	! 
	! call programdump("/tmp/ollogst!","")
 else
    include "src/callsuberr.inc"
 end try
end sub ! getsubstlist
! 
!--------------------------------------------------------------------
sub getsupsdlist()
! get a list of supersede items for a product
! output like scan list

 Try
	Dim 1%,OType
	Dim 2%,Whse
	Dim 3%,tmpcnt
	
	Call DXGet("PRODID",tmp$)
	Prod$=UCase$(tmp$)
	Prod$=Prod$+Blank$
	If Len(Prod$)>12 let prod$[13]=""
	Call DXGet("WHSE",tmp$)
	Whse=tmp$
	
	ReturnStatus=1
	Message$="OK"
	If Whse<1 or whse>99 or Fra(whse)
	  ReturnStatus=0
	  Message$="WAREHOUSE NOT PASSED"
	  Goto SPRSDDone ! needs to be?
	Endif
	ProdKey$=Prod$
	ProdKey$[13]="" ! cut to length
	PRR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.)
	clear e$
	If PRR<=0 ! has to exist!
		ReturnStatus=0
		Message$="PRODUCT NOT FOUND"
		Goto SPRSDDone ! has to be
	Endif
	Call DXGet("ORDTYPE",tmp$)
	Let OType=tmp$ \ if otype<0 Or OType>38 Let OType=0

	Call SPRCIList(e$,IntCo,List$[],maxcnt,ctlc,prc,whc,ccc,Prod$,Whse,OType)
	e$=""
	call AddToStr(e$,rstr$,List$[])
	SPRSDDone: ! finish supersdlist get
	! status section
	if debugdetail
		dmsg$="Supersede List "+prod$+Message$ \ Call updatelog(debug)
	Endif
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
	! 
	! call programdump("/tmp/ollogsd!","")
 else
    include "src/callsuberr.inc"
 end try
end sub ! getsupsdlist
! 
!--------------------------------------------------------------------
Sub ROLTAG()
! using roltag for zlines - use action1$ for function (GET,DELETE,SAVE)
! AND ACTION2 = HISTORY FOR INV HIST
  Try
	Dim RTKey$[60],UDA$[70],mode$[2]
	Dim 3%,RTR,refno
	Read #ctlc,68,112;uda$;
	Dim RTG. as roltag  ! SAME LAYOUT FOR ALL
	If Action2$="HISTORY" ! wants inv hist not orders
		Close #OHC ! close order files
		Close #OSC
		Close #OTC
		Close #OLC
		Ohc = openfile(-1136,intCo) \ If Ohc = -1 Error 42     !"Invoice header file
		olc = openfile(-1184,intCo) \ If oLc = -1 Error 42     !"Invoice lines file
		oSc = openfile(-1152,intCo) \ If oSc = -1 Error 42     !"Invoice shipto file
		otc = openfile(-1168,intCo) \ If otc = -1 Error 42     !"Invoice total file
		RTc = openfile(-9939,intco)! if rtc=-1 error 42 ! allow missing!
	Else ! regular orders
		RTC=OpenFile(9950,IntCo)
	Endif
	if RTC=-1
		returnstatus=0
		message$="File ROLTAG not found"
		goto RLTDone
	Endif
	if action2$="HISTORY" ! ONLY 1 ACTION1=GET				doc=InvL-GetLineTag.doc
		call dxget("REFID",tmp$)
		if tmp$=""
		  let message$="Reference # MISSING"
		  Let ReturnStatus=0
		  Goto RLTDone:
	    Endif	
		Refno=tmp$
		if refno>0 and refno<=99999999 and not(fra(refno))
			TPWKey$=" ",TPWKEY$
			TPWKey$[1,2]="30" ! try invoice
			TPWKey$[3]=refno using "##########"
			Search #OHC,2,1;TPWKey$,OHR,E \ if e let ohr=0-e
			if OHR<0 ! not found as invoice
				tpwkey$[1,2]="31" ! try credit
				Search #OHC,2,1;TPWKey$,OHR,E \ if e let ohr=0-e
			Endif ! if fails it's not there
		Else
			OHR=-1
		Endif
		If OHR<=0 ! no order found
			Let message$="Reference # NOT FOUND"
			Let ReturnStatus=0
			Goto RLTDone:
		Else
			! read record #OHC,OHR,0;roh.; ! not used on hist
		Endif
	Else
		Call DXGet("ORDERID",tmp$)
	  if tmp$="" 
		let message$="ORDER # MISSING"
		Let ReturnStatus=0
		Goto RLTDone:
	  Endif
	  OrderNo=tmp$
	  If OrderNo>0 and OrderNo<=999999 and Not(Fra(OrderNo))
		OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
		e$=""
	  Else
		OHR=-1
	  Endif
	  If OHR<=0 ! no order found
		Let message$="ORDER # NOT FOUND"
		Let ReturnStatus=0
		Goto RLTDone:
	  Endif
	Endif ! of hist or order
	Call dxget("LN",tmp$) !        
	LineNo = tmp$ ! line # 
	If LineNo <= 0 Or LineNo > 999 Or Fra(lineno)  
		ReturnStatus = 0                                   
		Message$ = "INVALID ORDER LINE!"  
		goto RLTDone: ! out 
	End If   
	rolkey$ = " ",rolkey$  
	If action2$="HISTORY"
		rolkey$[1,10]=RefNo Using "##########"
		rolkey$[11,13]=LineNo using "###"
		Rolkey$[15]="" ! cut at 15
		Search #OLC,2,1;RolKey$,OLR,E \ if e let OLR=0-e
		! no need for read
	Else
		rolkey$[1,6] = orderno Using "######"         
		rolkey$[7,9] = LineNo Using "###"       
		rolkey$[11] = "" ! cut to length (space @ 10) 
		OLR = filegetrolz(e$,OLC,"=",1,rolkey$,rol.)
		clear e$
	Endif
	if olr<=0
		returnstatus=0
		Message$="Order Line Not Found"
		goto RLTDone: ! out 
	endif
	! okay order & line exist - now action1
	Select Case Action1$
		case "GET" ! get data for web						doc=OrdL-GetLineTag.doc
			RTKey$=ROLKey$ ! same key as line				doc=InvL-GetLineTag.doc
			RTR=filegetroltag(e$,RTC,"=",1,RTKey$,rtg.) ! hist & ord same layout
			clear e$
			If RTR<=0 ! not found
				clear rtg.
				! if action2$<>"HISTORY" let rtg.PONum$=roh.CustPO$ ! default to order po
			Endif
			! send uda names
			Clear List$[]
			List$[0]=bsdel$,"FLDNAMES",fdel$
			List$[1]="FLD1",fdel$,"FLD2",fdel$,"FLD3",fdel$,"FLD4",fdel$,"FLD5",fdel$
			webstr$=RTrim$(UDA$[1,14]),fdel$,RTrim$(UDA$[15,28]),fdel$
			webstr$=webstr$,RTrim$(UDA$[29,42]),fdel$,RTrim$(UDA$[43,56]),fdel$
			webstr$=webstr$,RTrim$(UDA$[57,70]),fdel$
			List$[2]=webstr$
			List$[3]=esdel$
			e$=""
			call addtostr(e$,rstr$,List$[])
			Clear List$[]
			List$[0]=bsdel$,"LINENOTES",fdel$
			tmp$="ORDERID" \ if action2$="HISTORY" let tmp$="REFID"
			Webstr$=tmp$,fdel$,"LINE",fdel$,"FLD1",FDEL$
			webstr$=webstr$,"FLD2",fdel$,"FLD3",fdel$
			webstr$=webstr$,"FLD4",fdel$,"FLD5",fdel$
			for x=6 to 30 ! now 30 lines!
				tmp$="FLD"+Str$(X)
				webstr$=webstr$,tmp$,fdel$
			Next X
			List$[1]=webstr$
			x3=orderno \ if action2$="HISTORY" let x3=REFNo
			webstr$=Str$(X3),fdel$,Str$(LineNo),fdel$
			webstr$=webstr$,RTrim$(rtg.JobNum$),fdel$,RTrim$(rtg.PONum$),fdel$
			webstr$=webstr$,RTrim$(rtg.PressNum$),fdel$,Rtrim$(rtg.MSGLine1$),fdel$
			webstr$=webstr$,RTrim$(rtg.MSGLine2$),fdel$
			for x=1 to 25 ! send the 25 add'l lines
				x1=(x-1)*30+1
				tmp$=RTrim$(rtg.msgs$[x1,x1+29])
				webstr$=webstr$,tmp$,fdel$
			Next X
			List$[2]=webstr$
			List$[3]=esdel$
			e$=""
			call addtostr(e$,rstr$,List$[])
		case "SUBMIT" ! write to file						doc=OrdL-SubmitLineTag.doc
			if action2$="HISTORY"
				returnstatus=0
				message$="Can not submit history"
				goto RLTDone
			Endif
			RTKey$=ROLKey$ ! same key as line
			RTR=filegetroltag(e$,RTC,"=",1,RTKey$,rtg.)
			clear e$
			If RTR<=0 
				clear rtg.
				RTR=0
			Else ! existing - check blank for key (NOT NULL!!!)
				if rtg.Blankforkey$="" ! it is - from UB - fill it NOW
					rtg.Blankforkey$=" "
					write record #RTC,RTR,0;rtg.;
				Endif ! not null - ok
			Endif
			rtg.Status=rol.Status
			rtg.OrdNum=Orderno
			rtg.LineNum=LineNo
			call dxget("FLD1",tmp$)
			rtg.JobNum$=tmp$+Blank$
			call dxget("FLD2",tmp$)
			rtg.PONum$=tmp$+Blank$
			call dxget("FLD3",tmp$)
			rtg.PressNum$=tmp$+Blank$
			call dxget("FLD4",tmp$)
			rtg.MSGLine1$=tmp$+Blank$
			call dxget("FLD5",tmp$)
			rtg.MSGLine2$=tmp$+Blank$
			rtg.MSGS$=" ",rtg.MSGS$
			For X=6 to 30 ! 30 total flds
				call dxget("FLD"+str$(x),tmp$)
				tmp$=Rtrim$(tmp$)
				if tmp$<>"" ! sent something
					x1=x-5 ! so is 1 to 25
					x2=(x1-1)*30+1
					rtg.msgs$[x2,x2+29]=tmp$+Blank$
				Endif
			Next X
			rtg.Blankforkey$=" "
			mode$="c" \ if rtr<=0 let mode$="a"
			x3[7]=fileupdateroltag(e$,RTC,mode$,RTR,rtg.)
			clear e$
			if x3[7]<0 ! problem
				returnstatus=0
				message$="Search Error "+Str$(X3[7])+" updating roltag file"
			Endif
		case "DELETE" ! delete								doc=OrdL-DeleteLineTag.doc
			if action2$="HISTORY"
				returnstatus=0
				message$="Can not delete history"
				goto RLTDone
			Endif
			RTKey$=ROLKey$ ! same key as line
			RTR=filegetroltag(e$,RTC,"=",1,RTKey$,rtg.)
			clear e$
			If RTR<=0 goto RLTDone ! no key - no delete
			if rtg.Blankforkey$="" ! it is null - from UB - fill it NOW
				rtg.Blankforkey$=" " ! otherwise "not found"(SE)
				write record #RTC,RTR,0;rtg.;
			Endif ! not null - ok
			mode$="d"
			x3[7]=fileupdateroltag(e$,RTC,mode$,RTR,rtg.)
			if x3[7]<0 ! problem
				returnstatus=0
				message$="Search Error "+Str$(X3[7])+" deleting roltag file"
			Endif
	End select
	RLTDone: ! finshed
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
  else
    include "src/callsuberr.inc"
 end try
end sub ! ROLTAG
! 
!--------------------------------------------------------------------
Sub BOREMCHK()
! check line & borem flag to see if ok ROL.=orig, NROL.=New
 Try
	BOREM=0
	IF P60$[27,27]="S" ! "b/o reminder 
		LET BOREM=1                        
	ELSE                               
		IF P60$[27,27]="B"                 
		  LET BOREM=2                      
		ELSE                               
		  IF P60$[27,27]="E"               
			LET BOREM=3                    
		  ENDIF                            
		ENDIF                              
	ENDIF                
	if nrol.ComdtyCode$="LABR" OR nrol.ComdtyCode$="TIME" OR nrol.ComdtyCode$="MACH" then borem=0
	borfail=0 ! no fail yet
	if credit or borem=0 goto BORCDone ! no check wanted
	IF roh.OrdType<>16 AND roh.OrdType<>5                            
	  IF NONSTK OR nrol.QtyShip<=0 OR NOT(nrol.UpdtStk) GOTO BORCDone
	ELSE                                                
	  IF NONSTK OR nrol.QtyShip<=0 GOTO BORCDone            
	ENDIF                                               
	IF P9$[2,2]="M" AND pr.MBFlg$="M" GOTO BORCDone  
	IF rol.KitDesignation$="KIT" OR CREDIT OR QUOTE GOTO BORCDone
	if RTrim$(rol.ProdCode$)="" or rol.whse=0 goto BORCDone ! no product??
	if roh.ordtype=19
		if rol.QtyOrd<>0 and rol.PrevQtyShip =rol.QtyOrd goto BORCDone
	Endif
	IF (BOREM=3 OR ((BOREM=1 OR BOREM=2) AND PW.DNReordFlg=1)) 
		! get CURRENT prod whse avail without the line qty
		x2[9]=nrol.whse \ if roh.ordtype=7 let x2[9]=roh.ConsWh
		whAVL=getwhavail(e$,intco,PWC,rol.ProdCode$,X2[9])
		If Not(NewLn) and nrol.whse=rol.whse ! existing - back out old
			X3=ROL.QtyShip ! back out of avail like added
			if roh.OrdType=15 or roh.ordtype=19 let x3=rol.QtyOrd-rol.PrevQtyShip-rol.QtyBO
			if custom_customer$="MORRISETTE"
				If roh.OrdType=4 Let X3=ROL.QtyShip ! "cct 129415 - only commit shipping qty
			Endif
			IF roh.OrdType=15 AND roh.BOCTR<>0 LET x3=0        
			IF roh.OrdType=15 AND roh.BOCTR=0 LET x3=rol.QtyOrd
			if roh.ordtype=19 and roh.boctr<>0 and roh.ot19comp=0 let x3=0 ! closed
			WHAvl=WHAvl+X3 ! add in prev
		Endif
		X3=NROL.QtyShip ! Lets only check SHIP here - ALL OT'S
		!if roh.OrdType=4 or roh.OrdType=15 or roh.ordtype=19 let x3=nrol.QtyOrd-nrol.PrevQtyShip-nrol.QtyBO
		!if custom_customer$="MORRISETTE"
		!	If roh.OrdType=4 Let X3=NROL.QtyShip ! "cct 129415 - only commit shipping qty
		!Endif
		IF roh.OrdType=15 AND roh.BOCTR<>0 LET x3=0        
		IF roh.OrdType=15 AND roh.BOCTR=0 LET x3=nrol.QtyOrd
		if roh.ordtype=19 and roh.boctr<>0 and roh.ot19comp=0 let x3=0 ! closed
		WHAVL=WHAVL-X3 ! take out new shipping
		if WHAVL<0 ! not enough - line fails test
			Returnstatus=0
			Message$="Line not written. Not enough available, please backorder"
			BORFail=1
		Endif
	Endif
	BORCDone: ! finished
 else
    include "src/callsuberr.inc"
 end try
end sub ! BOREMCHK
! 
!--------------------------------------------------------------------
Sub WHSEAVAIL()
! Separate call to send list of whses with avail
 Try
	dim PWKey$[60],VendKey$[60],OLKey$[60],k1$[60]
	Dim kcm$[50],sum$[4],Pum$[4],Cum$[4],lpkey$[60]
	dim lppum$[4],lpcum$[4],lpsum$[4]
	dim 1%,cnvtu[2],NonStk,ZLine
	Dim 2%,OrderNo,LineNo,Whse,TaxNo,Dept,cwh
	Dim 3%,OLR,CNVTA,Amount,lpr,spr
	READ #CTLC,60,16;CWH; ! start of conswhs
	Call DXGet("ORDERID",tmp$)
	OrderNo=tmp$
	LineNo=0;fleptr[4,1]=0
	If OrderNo>0 ! sent order
		OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
		e$=""
		Call DXGet("LINENO",tmp$)
		LineNo=tmp$
		If OHR<0 ! can't do much with no order!
			Let lineno=0
			clear roh.
			clear ros.
			clear rot.
			ReturnStatus=0
			Message$="ORDER NOT FOUND"
		Endif
		If LineNo>0 ! sent line - get info from it
			OLKey$=" ",OLKey$
			OLKey$[1,6]=roh.OrdNum Using "######"
			OLKey$[7,9]=LineNo Using "###"
			OLKey$[11]="" ! cut at 11 - 10 blank
			OLR=filegetrolz(e$,OLC,"=",1,OLKey$,rol.)
			clear e$
			If OLR<0 
				Clear rol.
				LineNo=0
			Endif ! did not find line
			NonStk = rol.NStkItem 
		Endif
	Else ! NEED AN ORDER!
		ReturnStatus=0
		Message$="ORDER NOT PASSED"
	Endif
	If ReturnStatus=1 and OHR>0
		Call GetCust()
	Endif
	if returnstatus=0 goto GWADone ! we'll force a valid order/line
	If LineNo<=0 ! no order found / yet
		clear rol. ! have nothing
		Call DXGet("PRODID",tmp$)
		tmp$=UCase$(tmp$)+Blank$
		Prod$=tmp$[1,12]
		ProdKey$=prod$
		PRR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.)
		clear e$
		If PRR<0 ! no product found
			Clear Pr.
			ReturnStatus=0
			Message$="PRODUCT NOT FOUND"
		Endif
		If PRR>0
			Call DXGet("WHSE",tmp$)
			Whse=tmp$
			if whse>0
				PWKey$=Prod$+Whse using "##"
				! if roh.ordtype=7 let PWKey$=Prod$+roh.ConsWh using "##"
				PWR=filegetprodwhse(e$,PWC,"=",1,PWKey$,PW.)
				clear e$
				If PWR<0 Clear PW.
			Else
				Clear PW.
			Endif
			! as no line - set up rol. values to use
			rol.QtyOrd=0 ! don't know or need? (need spcl/rbt #)
			SUM=pr.UMSellDefault ! need to pass to setnewrol
			if source=251 and pr.UMPrdtnDefault<>0 let SUM=pr.UMPrdtnDefault
			if ordpad ! from order pad - any qty?
				Call DXGet("UM",tmp$)
				if tmp$<>""
					R=getumrec(e$,CCC,tmp$,IntCo,PR.)
					If R<>0 let tmp$=Str$(R)
					Let SUM=tmp$
				Else
					SUM=0
				Endif
				Flag=ChkPrdUM(e$,SUM,IntCo,Pr.)
				If Not(Flag)
					sum=pr.UMSellDefault
					if source=251 and pr.UMPrdtnDefault<>0 let SUM=pr.UMPrdtnDefault
				Endif
				call dxget("ORDQTY",tmp$)
				x3=tmp$
				if x3<>0 let SQty=x3
				let cnvtu[0]=SUM;cnvtu[1]=0;cnvtu[2]=1
				let cnvta=SQty
				Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				Let rol.QtyOrd=Int(Amount) ! always integer base - just cut it
			Endif
			Call SETNEWRol() ! set up rol. vars
			rol.dept=Dept ! as passed
			rol.PDRecNum=PRR;rol.whse=whse
		Endif ! Product found
	Endif ! sent line or not
	prr=rol.PDRecNum
	If returnstatus=0 goto GWADone
	If Not(NonStk) Read record #PRC,prr,0;PR.; ! always read prod!
	If NonStk ! nonstock 
		Clear pr.
	Endif
	call SetPRtoROL() ! set up prod conv vars
	
	Prod$=rol.prodcode$
	whse=rol.whse
	if whse<1 or whse>99 let whse=roh.wh
	! may need set certain prod vars to rol. for  (catchwgt,cwt)
	! first get avl in all whses
	SUM$=XUnit$(rol.umsell,ccc)
	Pum$=XUnit$(rol.umprice,ccc)
	CUm$=XUnit$(rol.umcost,ccc)
	Clear list$[]
	List$[0]=bsdel$,"WHSEAVAIL",fdel$
	webstr$="WHSE",fdel$,"Available",fdel$
	if ordpad let webstr$="WHSE",fdel$,"Available",fdel$,"UM",fdel$,"WHNAME",fdel$
	List$[1]=Webstr$
	Row=2;tmpcnt=maxcnt
	WHAvl=0
	x2[9]=rol.whse \ if roh.ordtype=7 let x2[9]=roh.ConsWh
	If RTrim$(Prod$)<>""
		x2[9]=rol.whse \ if roh.ordtype=7 let x2[9]=roh.ConsWh
		If Not(NonStk) Let WHAvl=getwhavail(e$,intco,PWC,rol.ProdCode$,X2[9])
	Else
		WHAVL=0
	Endif
	if lineno>0 and not(NonStk) and rol.UpdtStk
	  if not(credit) and roh.ordtype<>15 AND rol.qtyship>=0
!	    if roh.ordtype=4 ! backs out ordered
!		  if custom_customer$="MORRISETTE"
!			let whavl=whavl+rol.qtyship ! add back this order
!		  Else
!			let whavl=whavl+(rol.qtyord-rol.PrevQtyShip)
!		  Endif
!		Else
			! let whavl=whavl+rol.qtyship ! add back this order - per grp NO
			! leave current line qty unavailable?
!		Endif
	  Endif
	Endif
	cnvtu[0]=0;cnvtu[1]=rol.umsell;cnvtu[2]=1
	cnvta=WHAvl \ if rol.numout>0 let cnvta=whavl*rol.numout
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	WebStr$=Str$(rol.Whse),fdel$
	if ordpad
	  WHIR=x2[9]-1
	  Read record #WHI,WHIR,0;WHI.;
	  tmp$=RTrim$(WHI.WhName$)
	  WebStr$=WebStr$,LTrim$(Amount Using QMask$),fdel$,RTrim$(SUM$),fdel$ ! as deflt sell?
	  webstr$=webstr$,tmp$,fdel$ ! wants wh name
	Else
	  WebStr$=WebStr$,STR$(WHAVL),fdel$ ! as base (don't know if UMSell changed!
	Endif
	List$[row]=WebStr$
	row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	PWKey$=" ",PWKey$
	PWKey$=rol.ProdCode$+Blank$
	PWKey$[15]="" ! cut to length
	Do
		!If NonStk Exit do ! no whse/avl on nonstocks!
		if roh.ordtype=7 exit do ! only one whse!
		If NonStk<>0
				maxwhse=CHF(WHI)-1 \ if maxwhse>98 let maxwhse=98
				For I=0 to maxwhse ! CHF(WHC)-1 (99 is the ALLWHSE record)
					if i<>(x2[9]-1)
						read record #WHI,I,0;whi.;
						if rtrim$(whi.WhName$)<>"" !indicates active record in non-indexed file
							WebStr$=Str$(I+1),fdel$ ! whse
							let amount=0 ! nonstock
							WebStr$=WebStr$,Str$(Amount),fdel$ ! available
							if ordpad<>0
								webstr$=webstr$,RTrim$(SUM$),fdel$ ! as sell UM
								webstr$=webstr$,rtrim$(whi.WhName$),fdel$ ! whse, avail
							endif
							List$[row]=webstr$
							row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
						endif
					endif
				next i
			Exit do ! no whse/avl on nonstocks!
		endif	
		PWR=filegetprodwhse(e$,PWC,">",1,PWKey$,PW.)
		clear e$
		If PWR<0 or Pwkey$[1,12]<>rol.prodcode$ exit do
		X2=pwkey$[13,14]
		if roh.ordtype<>8 and x2>=cwh exit do ! no consignments
		If X2<>rol.whse ! already sent line whse #
			If Rtrim$(rol.ProdCode$)<>""
				WHAvl=getwhavail(e$,intco,PWC,rol.ProdCode$,X2)
			Else
				WHAVL=0
			Endif
			!if WHAvl>0 ! don't send zero (less than?) Per DD only avail>0
			 cnvtu[0]=0;cnvtu[1]=rol.umsell;cnvtu[2]=1
			 cnvta=WHAvl \ if rol.numout>0 let cnvta=whavl*rol.numout
			 Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			 WebStr$=Str$(X2),fdel$ ! whse #
			 if ordpad
			   WHIR=X2-1
			   Read record #WHI,WHIR,0;WHI.;
	           tmp$=RTrim$(WHI.WhName$)
			   WebStr$=WebStr$,LTrim$(Amount Using QMask$),fdel$,RTrim$(SUM$),fdel$ ! as sell UM
			   webstr$=webstr$,tmp$,fdel$ ! wants wh name
			 Else
				WebStr$=WebStr$,Str$(WHAVL),fdel$ ! as base qty
			 Endif
			 List$[row]=WebStr$
			 row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
			!Endif ! no zero avl (shorten list)
		Endif
	Loop
	List$[row]=esdel$ ! finished
	GWADone: ! finished
 else
    include "src/callsuberr.inc"
 end try
end sub ! WHSEAVAIL
! 
!--------------------------------------------------------------------
Sub NSFRMLP()
! set up for nonstock from lastprice
 Try
	dim keyinvk$[50],keyinvl$[50],3%,rec_invl,rec_invh,LPglcost,invnum
	clear pr.
	clear pw.
	pr.UMSellDefault=clp.UMSell
	pr.UMPriceDefault=clp.UMPrice
	pr.UMCostDefault=clp.UMCost
	pr.VendItem$=UCase$(clp.VendItemCode$)
	pr.Desc1$=clp.LineDesc1$
	pr.Desc2$=clp.LineDesc2$
	pr.ComdtyCode$=clp.ComdtyCode$
	pr.PrimVend=clp.VendNum
	pr.ProdCat=clp.PSCat
	pr.MatCode$=clp.MatCode$
	pr.LbsUnit=clp.UnitWgt
	pr.CubicFeet=clp.UnitCube
	pw.Buyer=clp.Buyer
	pr.BaseUM=clp.UMBase
	pr.UMPurchDefault=clp.UMPurch
	x=2
	clear x2[]
	clear x3[]
	if pr.UMSellDefault and pr.UMSellDefault<>pr.BaseUM
		x2[x]=pr.UMSellDefault;x3[x]=clp.SellUnitFactor
		x=x+1
	Endif
	if pr.UMPriceDefault and pr.UMPriceDefault<>pr.BaseUM 
		x2[x]=pr.UMPriceDefault;x3[x]=clp.PriceUnitFactor
		x=x+1
	Endif
	if pr.UMCostDefault and pr.UMCostDefault<>Pr.BaseUM 
		x2[x]=pr.UMCostDefault;x3[x]=clp.CostUnitFactor
		x=x+1
	Endif
	if pr.UMPurchDefault and pr.UMPurchDefault<>pr.BaseUM
		x2[x]=pr.UMPurchDefault;x3[x]=clp.PurchUnitFactor
		! x=x+1
	Endif
	for x1=2 to x ! start 2 up to 5 max diff um's
		if x2[x1]<>0 ! diff than base
			X2=X2[X1]
			IF pr.UM2=0 ! no um2
				pr.um2=x2;pr.UM2Fact=x3[x1]
			Else ! has 2
				if x2<>pr.um2 ! diff than 2
					if pr.um3=0 ! no um3
						pr.um3=x2;pr.um3fact=x3[x1]
					Else ! has 3
						if x2<>pr.um3
							if pr.um4=0 ! no 4
								pr.um4=x2;pr.um4fact=x3[x1]
							Else ! has 4
								pr.um5=x2;pr.um5fact=x3[x1] ! max 5
							Endif ! of 4
						Endif ! diff 3
					Endif ! of 3
				Endif ! diff 2
			Endif ! of 2
		Endif ! not zero
	Next X1 ! loop
	pr.CubicFtFactor=clp.CubeFactor
	pr.LbsFact=clp.WgtFactor
	! anything else - load rol? nstk?
	clear rol.
	clear nstk.
	! let's load what we can
	! these not loaded by setnewrol
	rol.NStkItem=1
	rol.UpdtStk=0
	rol.CubeUnit=PR.CubicFeet
	rol.LbsUnit=pr.LbsUnit
	rol.TaxFlg=0 ! --------- needs setup (below)
	rol.Desc1$=pr.Desc1$
	rol.Desc2$=pr.Desc2$
	rol.ProdCode$=Blank$ ! pr.ProdCode$ (don't know line yet!)
	rol.UMSell=SUM ! as passed!
	if SUM=0 Let rol.UMSell=pr.UMSellDefault
	rol.UMPrice=pr.UMPriceDefault
	rol.UMCost=pr.UMCostDefault
	rol.Vendor=pr.PrimVend ! may chg to whse
	rol.MSDSNo=0
	rol.VendItemCode$=pr.VendItem$ ! cb whse
	rol.UMBase=pr.BaseUM
	rol.UMPurch=pr.UMPurchDefault
	rol.CubeFactor=PR.CubicFtFactor \ if rol.CubeFactor<=0 Let rol.CubeFactor=1
	rol.WgtFactor=pr.LbsFact \ if rol.WgtFactor<=0 Let rol.WgtFactor=1
	rol.CatchWgtItem=pr.CatchWgtItm
	rol.SellFactor=clp.SellUnitFactor ! UMtoFactor(rol.UMSell)
	rol.PriceFactor=clp.PriceUnitFactor ! UMtoFactor(rol.UMPrice)
	rol.CostFactor=clp.CostUnitFactor ! UMtoFactor(rol.UMCost)
	rol.PurchFactor=clp.PurchUnitFactor ! UMtoFactor(rol.UMPurch)
	rol.TaxFlg=clp.TaxCode
	rol.UnitCost=clp.UnitCost
	rol.UnitPrice=clp.UnitPrice
	rol.PriceOrigin=clp.LastPriceType
	rol.UnitGLCost=0 ! not in lp
	rol.NetPrice=rol.UnitPrice ! no upchg in lp - MAKE SAME!
	rol.CostOrigin=clp.LastCostOrg
	rol.LineCost2=clp.LpUnitCost ! loadit
	nstk.OrdNum=roh.OrdNum
	nstk.Desc1$=rol.desc1$
	nstk.Desc2$=rol.Desc2$
	nstk.UnitCost=rol.UnitCost
	nstk.UnitPrice=rol.UnitPrice
	nstk.PSlsCat=pr.ProdCat
	nstk.ComdtyCode$=pr.ComdtyCode$
	nstk.Unused$=blank$
	nstk.Buyer=clp.Buyer
	nstk.HazClass$=blank$ ! no place to get haz info
	nstk.PackGrp$=blank$
	nstk.DotID$=blank$
	nstk.ERGdbk$=blank$
	nstk.SpareNu$=blank$
	nstk.NS_UDA1=0;nstk.NS_UDA2$=blank$
	nstk.NS_UDA3$=blank$;nstk.NS_UDA4$=blank$;nstk.NS_UDA5$=blank$
	clear nstk.Spare$ ! dl4 fix ! nstk.Spare$=blank$
	If p60$[42,42]<>"Y" and p60$[42,42]<>"T" let rol.taxflg=-2 ! tax by line is not set -- need to get tax code
	if rol.taxflg<0
		let prodkey$="Z ZZZZZZZZZZ" ! let's set up tax now-as it's new!
		PRR = filegetprod(e$,PRC,"=",1,Prodkey$,PR.)
		clear e$
		if prr>0
			K1$=roh.CustNum Using "######"
			ProdKey$=nrol.ProdCode$
			ProdKey$=nrol.VendItemCode$ ! as it's stored that way in lastprice
			Call TaxFlag(k1$,ProdKey$,ros.ShipCust,ros.ShipCode,rol.Dept,pr.TaxType,intco,roh.TaxCode,ros.ShipTaxType,Taxback)
			rol.TaxFlg=Taxback ! contains what's needed
			If P60$[42,42]<>"Y" ! has y/n only - get rate from header tax
				TaxNo=roh.TaxCode
			Else ! is a code
				TaxNo=rol.TaxFlg
			Endif
			If TaxNo>0
				Tcc=Openfile(-2176,IntCo) \ if Tcc = -1 Error 42
				Read record #tcc,taxno,0;tax.;
				Close #tcc
			Else ! no taxcode
				clear tax.
			Endif
			rol.TaxPct=tax.TaxRate
		endif
	endif
	If custom_customer$="PIEDMONT" and clp.ordnum<>0 and clp.ordlinenum<>0
		let ch_invk=0
		let ch_invl=0
		let lpglcost=0
		try
			ch_invk=Openfile(-9994,IntCo) 
			if ch_invk<=0 
				let ch_invk=0
				goto endgetglcost:
			endif
		else
			let ch_invk=0
			goto endgetglcost:
		end try
		let keyinvk$=" ",keyinvk$
		let keyinvk$[1,6]=clp.ordnum using "######"
		search #ch_invk,3,3;keyinvk$,rec_invh,e
		if e<>0 goto endgetglcost
		let tmp3=keyinvk$[1,6]
		if tmp3<>clp.ordnum goto endgetglcost:
		let invnum=keyinvk$[7,16]
		try
			ch_invl=Openfile(-1184,IntCo) 
			if ch_invl<=0 
				let ch_invl=0
				goto endgetglcost:
			endif
		else
			let ch_invl=0
			goto endgetglcost:
		end TRY
		let keyinvl$=" ",keyinvl$
		let keyinvl$[1,10]=invnum using "##########"
		let keyinvl$[11,13]=clp.ordlinenum using "###"
		search #ch_invl,2,1;keyinvl$,rec_invl,e
		if not(e)
			read #ch_invl,rec_invl,210;lpglcost;
			let rol.unitglcost=lpglcost
		endif
		endgetglcost:  ! 
		if ch_invk<>0
			try close #ch_invk else rem
		endif
		if ch_invl<>0
			try close #ch_invl else rem
		endif

	endif
	


	! load rest of cnstk at write
 else
    include "src/callsuberr.inc"
 end try
end sub ! NSFRMLP
! 
!--------------------------------------------------------------------
Function Chkkit$()
! see if action needed be web - start with is it there
  try
	dim kflg$[10]
	dim kkey$[60],hkkey$[60]
	kflg$=""
	KTC=OpenFile(-1312,IntCo) \ if ktc=-1 Goto CKDONE ! kit lines
	kkey$=" ",kkey$
	kkey$[1,6]=rol.OrdNum using "######"
	kkey$[7,9]=rol.LineNum using "###"
	hkkey$=kkey$ ! easier check
	search #Ktc,3,1;kkey$,r,e
	if e
		If rol.QtyShip>0 let kflg$="NO KIT"
	Else ! there - right order/line?
		if kkey$[1,9]<>Hkkey$[1,9] ! not for this order/line
			If rol.QtyShip>0 let kflg$="NO KIT"
			goto CKDone
		Endif
		! if other conditions - add below
		if rol.Qtyship<=0
			kflg$="KIT QTY" ! kit exists w/no ship qty
		Endif
	Endif
	CKDone: ! finished
	IF ktc>0
		try close #KTC Else Rem
	Endif
  else
    include "src/callsuberr.inc"
  end try
end Function kflg$ ! Chkkit$
! 
!--------------------------------------------------------------------
Function chktagfle$()
! see if any data for all msglines in tagfile
! as messages are condensed (ie: enter msg 20, will move to lower number
!   so all messages start at 1, 2, etc.)
  Try
	Dim RTKey$[60],tflg$[1]
	Dim 3%,RTR,refno
	Dim RTG. as roltag
	tflg$="N"
	RTC=OpenFile(-9950,IntCo)
	if rtc=-1 goto ctfdone
	RTKey$=" ",rtkey$ ! same key as line
	rtkey$[1,6]=roh.OrdNum using "######"
	rtkey$[7,9]=rol.LineNum using "###"
	RTR=filegetroltag(e$,RTC,"=",1,RTKey$,rtg.) ! hist & ord same layout
	clear e$
	If RTR<=0 ! not found
		tflg$="N"
	Else
	    !!! rem check line
		if rtrim$(rtg.MSGLine1$)<>"" let tflg$="Y"
		if rtrim$(rtg.MSGLine2$)<>"" let tflg$="Y"
		if rtrim$(rtg.PONum$)<>"" let tflg$="Y"
		if rtrim$(rtg.JobNum$)<>"" let tflg$="Y"
		if rtrim$(rtg.PressNum$)<>"" let tflg$="Y"
		for x=1 to 25
			x1=(x-1)*30
			let tmp$=rtg.MSGS$[x1+1,x1+30]
			if rtrim$(tmp$)<>"" let tflg$="Y"
		Next X
	Endif
	e$=""
	try close #RTC Else Rem
	Ctfdone: ! finished
  else
    include "src/callsuberr.inc"
  end try
end Function tflg$ ! chktagfle$
! 
!--------------------------------------------------------------------
Sub gpsumm()
! send summary of g/p for lines
  Try
    IF SOURCE=2082 GOTO GGPDone ! NOT FOR ORD EDT V2
	Dim KOL$[60],KPW$[60],KCM$[50],KLP$[60]
	Dim ZOL$[60]
	Dim 1%,FCDays,cnvtu[2]
	Dim 2%,OrderNo,row,tmpcnt,JDate[5],FDate
	Dim 3%,OLR,FutCost,CNVTA,Amount

	tmpcnt=maxcnt
	if debugdetail
		dmsg$="Start get G/P Summary" \ Call updatelog(debug)
	Endif
	! close rw files - open as ro
	Try close #OHC Else Rem
	Try Close #OSC Else Rem
	Try Close #OTC Else Rem
	Try Close #OLC Else Rem
	OHC = OpenFile(-1840,IntCo) \ if ohc = -1 Error 42 ! order header
	OSC = OpenFile(-1856,IntCo) \ if osc = -1 Error 42 ! order shipto
	OTC = OpenFile(-1872,IntCo) \ if otc = -1 Error 42 ! order totals
	OLC = OpenFile(-1888,IntCo) \ if olc = -1 Error 42 ! order lines
	ReturnStatus=1
	Message$="OK"
	Call DXGet("ORDERID",tmp$)
	X2=tmp$
	If X2<1 or X2>999999 or Fra(X2) ! not valid
		ReturnStatus=0
		Message$="ORDER NOT PASSED"
		goto GGPDone:
	Endif
	OrderNo=x2
	OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
	e$=""
	If OHR<=0 ! not found
		ReturnStatus=0
		Message$="ORDER NOT FOUND"
		goto GGPDone:
	Endif
	! Call GetCust()
	CREDIT=0 \ if ros.status=32 let credit=1
	if credit and roh.ShipType=3 let cost_lev[1]=0 ! no cost on cm price error
	Clear List$[]
		List$[0]=bsdel$,"GPREVIEW",fdel$
		WebStr$="LineNum",fdel$,"ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$
		webstr$=webstr$,"OrdCost",fdel$,"OrdPrice",fdel$,"OrdGPDol",fdel$,"OrdGPPct",fdel$
		webstr$=webstr$,"ShpCost",fdel$,"ShpPrice",fdel$
		webstr$=webstr$,"ShpGPDol",fdel$,"ShpGPPct",fdel$
		List$[1]=webstr$
		Row=2
	! okay - see if lines
	KOL$=" ",KOL$;NumLines=0
	KOL$=OrderNo Using "######"
	! what if start with or only zlines on order??
	Do
		OLR=filegetrolz(e$,OLC,">",1,kol$,rol.)
		clear e$
		If OLR<0 exit do
		X2=kol$[1,6] \ if x2<>orderno exit do
		if (roh.OrdType=21 or roh.OrdType=22) and kol$[7,9]="   " goto bpgpdtl ! ot 21/22
		!x2=kol$[7,9] \ if x2>900 exit do ! as in pm
		NonStk=rol.NStkItem
		ZLine=0 \ if rol.LineType=3 and NonStk let ZLine=1 ! need for later
		! get/read appropriate records (prod,prodwhse,comm,lastprice
		if zline goto bpgpdtl ! no data to send
		!If Not(NonStk) ! it's a prod
		!	PRR=rol.PDRecNum
		!	Read record #PRC,PRR,0;PR.;
		!Else
		!	Clear pr.
		!Endif
		! always set up pr. w/line factors
		LineNo=rol.LineNum
		!Call SetPRtoRol()
		if roh.OrdType=8 or roh.OrdType=16 ! cons/trans - no price/cost
			rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
			rol.UnitPrice=0;rol.CutChrg=0;rol.CutCost=0
			rol.LineDisc=0;rol.ExtOrdAmt=0;rol.ExtShipAmt=0
			rol.LineDiscPct=0;rol.ExtCutChg=0;rol.ExtCutCost=0
			rol.ExtLoadShip=0;rol.ExtLoadOrd=0;rol.NetPrice=0
			rol.TaxAmt=0;rol.LoadUpchrg=0;rol.UpChrg=0
		Endif
		If p61$[46,46]="Y" and Credit and roh.shiptype=3 ! price fix - no cost
			rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
			rol.CutCost=0;rol.ExtCutCost=0;rol.ExtLoadShip=0;rol.ExtLoadOrd=0
			rol.LoadUpchrg=0
		Endif
		If roh.OrdType=37  ! "EVAP Ship - NO Price - any order in here
			If Not(Credit) Or (Credit And roh.ShipType=16)
				Let rol.UnitPrice=0;rol.NetPrice=0;rol.CutChrg=0
				Let rol.LineDisc=0;rol.LineDiscPct=0;rol.UpChrg=0
				rol.ExtOrdAmt=0;rol.ExtShipAmt=0;rol.ExtCutChg=0
			Endif
		Endif
		If roh.OrdType=36 ! "EVAP Billing - NO Cost - Any type order
			If Not(Credit) Or (Credit And roh.ShipType=16)
				Let rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
				Let rol.CutCost=0;rol.ExtCutCost=0;rol.ExtLoadShip=0;rol.ExtLoadOrd=0
				rol.LoadUpchrg=0;NetCost=0
			ENDIF
		Endif
		! load data - NO Conversions needed!
		webstr$=Str$(rol.LineNum),fdel$
		tmp$=clrtxtc$(e$,rol.Desc1$) ! chk/clr control chars
		webstr$=webstr$,RTrim$(rol.ProdCode$),fdel$,RTrim$(tmp$),fdel$
		tmp$=clrtxtc$(e$,rol.Desc2$) ! chk/clr control chars
		webstr$=webstr$,RTrim$(tmp$),fdel$
		! first ordered
		if cost_lev[1]
			webstr$=webstr$,LTrim$(rol.ExtLoadOrd using QMask$),fdel$
		Else
			webstr$=webstr$,"0",fdel$
		Endif
			webstr$=webstr$,LTrim$(rol.ExtOrdAmt using QMask$),fdel$
			X3=rol.ExtOrdAmt-rol.ExtLoadOrd ! ext'd gp
			X3[1]=0
			if rol.ExtOrdAmt
				let x3[1]=FNR((x3/rol.ExtOrdAmt)*100)
			else
				if rol.ExtLoadOrd then let x3[1]=-999999.99
			Endif
		if cost_lev[1]=0 let x3=0;X3[1]=0 ! alt - no cost/gp$/%
			webstr$=webstr$,LTrim$(X3 using QMask$),fdel$
			webstr$=webstr$,LTrim$(X3[1] using QMask$),fdel$
		!Else ! no cost sec
		!	webstr$=fdel$,Ltrim$(rol.ExtOrdAmt using QMask$),fdel$
		!	webstr$=webstr$,fdel$,fdel$ ! no cost or gp
		!Endif
		! now shipping
		If cost_Lev[1]
			webstr$=webstr$,LTRim$(rol.ExtLoadShip using QMask$),fdel$
		Else
			webstr$=webstr$,"0",fdel$
		Endif
			webstr$=webstr$,LTrim$(rol.ExtShipAmt using QMask$),fdel$
			X3=rol.ExtShipAmt-rol.ExtLoadShip ! ext'd gp
			X3[1]=0
			if rol.ExtShipAmt
				let x3[1]=FNR((x3/rol.ExtShipAmt)*100)
			else
				if rol.ExtLoadShip then let x3[1]=-999999.99
			Endif
		if cost_lev[1]=0 let x3=0;X3[1]=0 ! alt - no cost/gp$/%
			webstr$=webstr$,LTrim$(X3 using QMask$),fdel$
			webstr$=webstr$,LTrim$(X3[1] using QMask$),fdel$
		!Else ! no cost sec
		!	webstr$=fdel$,Ltrim$(rol.ExtShipAmt using QMask$),fdel$
		!	webstr$=webstr$,fdel$,fdel$ ! no cost or gp
		!Endif
		List$[row]=WebStr$
		Let row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	BPGPDtl: ! zlines no gp
	Loop
	LIST$[ROW]=esdel$
	e$=""
	call addtostr(e$,rstr$,List$[])
	GGPDone: ! finished
	! status section
	e$=""
	if debugdetail
		dmsg$="GP Summary Lines "+Str$(Orderno)+" TTL "+Str$(NumLines)+" "+Message$ \ Call updatelog(debug)
	Endif
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
  else
    include "src/callsuberr.inc"
 end try
end sub ! gpsumm

Sub DelParCnt(ordnum, linenum)
! delete par count line if it exists
  Try
	dim parKEY$[10]
	dim 1%,parCH
	dim 3%,parREC
	dim par. as parcntrol

	parCH = openfile(9924,intco) \ if parCH = -1 exit sub ! not built
	parKEY$[1,6]=ordnum using "######"
	parKEY$[7,10]=linenum using "####"
	parREC=filegetparcntrol(e$,parCH,"=",1,parKEY$,par.) ! product mode=2 dir=1
	clear e$
	if parREC > 0 ! got it
		parREC = fileupdateparcntrol(e$,parCH,"d",parREC,par.) ! delete
	end if
	close #parCH
  else
    include "src/callsuberr.inc"
 end try
end sub ! DelParCnt


Sub DelRFPick(ordnum, linenum)
! delete par count line if it exists
  Try
	dim k_rfpq$[100]
	dim 1%,ch_rfpq
	dim 3%,r_rfpq
	dim rfpq. as rfpickq

	if p61$[135,135] <> "Y" exit sub ! not enabled

	ch_rfpq = OpenFile(9603,intCo) \ if ch_rfpq = -1 Error 42 !rf pick file
	k_rfpq$ = " ",k_rfpq$
	k_rfpq$[1,6]=ordnum using "######"
	k_rfpq$[7,10]=linenum using "####"
	do
		r_rfpq=filegetrfpickq(e$,ch_rfpq,">",4,k_rfpq$,rfpq.,1)
		if r_rfpq<1 exit do
		if val(k_rfpq$[1,6]) <> ordnum or val(k_rfpq$[7,10]) <> linenum exit do
		clear e$
		r_rfpq = fileupdaterfpickq(e$,ch_rfpq,"d",r_rfpq,rfpq.) ! delete
	loop
	close #ch_rfpq
  else
    include "src/callsuberr.inc"
 end try
end sub ! DelParCnt


!--------------------------------------------------------------------------------
Sub verifystat()
! verify status on save data 
! header record needs to read first
  Try
	
	if returnstatus<>1
		goto endverifystat: ! already has error
	endif
	!Call dxget("SOURCE",tmp$)
	let tmp3=source ! tmp$ from beginning
	if tmp3=207 goto endverifystat: ! inquiry
	
	if credit<>0
		if roh.status<>97
			let returnstatus=99
			let message$="Credit is no longer in an edit status. Data is not saved. "	
		endif
		goto endverifystat:
	endif
	if tmp3=251 or tmp3=231
		if roh.status<>94
			let returnstatus=99
			let message$="Invoice is not longer in an edit status. Data is not saved. "
		endif
		goto endverifystat:
	endif
	if tmp3=223 
		if roh.status<>96 and roh.status<>95
			let returnstatus=99
			let message$="Invoice is no longer in an edit status. Data is not saved. "
		endif
		goto endverifystat:
	endif
	If not(tmp3) 
		if roh.status<94  or roh.status>96
			let returnstatus=99
			let message$="Order is no longer in an edit status. Data is not saved. "
		endif
		goto endverifystat:
	endif
	if roh.status<>95
		let returnstatus=99
		let message$="Order is no longer in an edit status. Data is not saved. "
	endif
	endverifystat: ! end the status check
		

	! status section
	e$=""
	!
	!  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	!  call AddToStr(e$,rstr$,WebStr$)
	!  call SetOutPut(e$,rstr$)
  else
    include "src/callsuberr.inc"
 end try
end sub ! verifystat
! 
!--------------------------------------------------------------------
Sub GetCutDetails()
! Send cutting details + get new charge if qtyout chgs
! Also since calcs so different - allow recalc option
  Try
	Dim X$[20],NSFKey$[60]
	dim holdpswd$[12,16]
	Dim 1%,CNVTU[2],FLAG[9],X1[9]
	Dim 1%,NewLn,HFlg[16],HFlag[16],Credit
	DIM 1%,COSTUM,BKNUNIT,CNG
	Dim 2%,X2[9],NumLines,ShipDate,JDate[5]
	DIM 2%,MAXWGT[11],DFLTCHG[11],MINCOST[11],MAXCOST[11],DFLTCOST[11]
	Dim 3%,CNVTA,AMOUNT,X3[9],V3[99]
	Dim 3%,WHBLD[2],S9[20]

	Dim NRol. as rolnew ! store new sent data
	Dim CPR. as prod
	if debugdetail
		dmsg$="Start get cut details" \ Call updatelog(debug)
	Endif
	if p9$[20,20]<>"F" ! not fine version
		returnstatus=0
		message$="Not Fine Paper Version"
		goto GCDDONE
	Endif
	! call dxsave(0,"tmp/olgc.txt!")
	ReturnStatus=1
	Message$="OK"
	Call DXGet("ORDERID",tmp$)
	If tmp$="" goto GCDDone
	if source<>239 ! not history
		OrderNo=tmp$
		If OrderNo<1 or OrderNo>999999 or Fra(OrderNo)
			ReturnStatus=0
			Message$="ORDER NUMBER INVALID"
			Goto GCDDone
		Endif
		OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
	Else ! from history inquiry
		RefId=tmp$ ! no header required
		OHR=1 ! SO considers found
		Close #OLC ! close order line
		OLC=OpenFile(-1184,Intco) \ if olc=-1 error 42  !invhist line
	Endif ! ord/hist file
	e$=""
	If OHR<=0 ! not found
		ReturnStatus=99
		Message$="ORDER WAS NOT FOUND"
		goto GCDDone
	Else
	 If source<>239
		Credit=0 \ if rot.Status=22 let Credit=1 ! instead of roh.status check
		if returnstatus<>0
			call verifystat()
			if returnstatus=99 goto GCDDone
		endif
		LET X3=rot.HoldCode ! unpack hold flags
		FOR CTR=0 TO 11                          
			LET HFlg[CTR]=SGN(FRA(X3/2));X3=INT(X3/2)
		NEXT CTR 
		for ctr=1 to 12
			read #ctlc,66,((ctr*16)-16);holdpswd$[ctr];
		next ctr
	  Endif ! of not history
	Endif
	if custom_customer$="OMAHA"!cct#208465/task#10448 %Cut/Punch Markup on Cut 
		IF source<>239 and ohr>0
			Call GetCust() ! need for flags
		endif
	endif
	Call DXGet("LN",tmp$) ! +Str$(X1),tmp$)
	nrol.LineNum=tmp$ ! line # (zero on new lines)
	LineNo=nrol.LineNum;NOLINEYET=0
	! per group - allow for entry on search screens - means no line yet
	if nrol.linenum ! get prev data
	  if source<>239
		rolkey$=" ",rolkey$
		rolkey$[1,6]=OrderNo Using "######"
		rolkey$[7,9]=nrol.linenum using "###"
		rolkey$[11]="" ! cut to length (space @ 10)
	  Else ! history
		rolkey$[1,10]=RefId Using "##########"
		rolkey$[11,13]=nrol.linenum Using "###"
		Rolkey$[15]=""
	  Endif
		OLR=filegetrolz(e$,OLC,"=",1,rolkey$,rol.)
		clear e$
		if olr<=0 ! what do we do if not found? if they sent it check it!
			Returnstatus=0
			message$="Line not found"
			e$="" ! clear emsg
			goto GCDDone
		Endif
		If OLR>0
				if rol.NStkItem=1 ! and rol.LineType<>3
					returnstatus=0
					message$="Cut is not allowed on Non-Stocks"
					goto GCDDone
				Endif
				If Not(rol.NStkItem) ! get prod & whse
					PRR=rol.PDRecNum
					Read record #PRC,PRR,0;pr.;
					read record #PRC,PRR,0;cpr.; ! copy of
					Tmp$=" ",tmp$
					tmp$=Pr.ProdCode$+rol.Whse Using "##"
					if roh.ordtype=7 let tmp$=Pr.ProdCode$+ROH.ConsWh Using "##"
					PWR=filegetprodwhse(e$,PWC,"=",1,tmp$,pw.)
					clear e$
					if PWR<0 ! not found - add new
						Clear pw.
						If PWR=-1 and source<>239 ! not found
							E$="";x3=tmp$[13,14]
							if roh.ordtype=7
								x3[1]=rol.whse/100
								x3=x3+x3[1]
							Endif
							Whbld[0]=PWC;Whbld[1]=X3;WhBld[2]=pr.PrimVend
							if x3<>1 let Whbld[1]=X3+.01 ! fra=copy whse 1
							Call mxwhcreate(e$,IntCo,PR.PRODCode$,WHBLD[])
							PWR=Whbld[2]
							Read record #PWC,PWR,0;PW.;
						Endif ! no whse
					Endif ! wh not found
				Endif ! stk item
		Endif ! existing line
	Else ! no line
		if source=239 ! history - no build
			returnstatus=0
			message$="No Line number sent!"
			goto GCDDone
		Endif
		Clear rol. ! clear
		Clear nstk.
		! will need to get product, price, and other rol. variables!
		Call DXGet("PRODID",tmp$)
		tmp$=RTrim$(tmp$)
		If tmp$="" Goto GCDDone: ! NEED A PRODUCT!
		Let PROD$=UCase$(tmp$)+Blank$
		Call DXGet("QTY",tmp$)
		Let SQty=tmp$ ! in sum units
		Call DXGet("UM",tmp$)
		Let SUM=tmp$
		! added for order pad detail entry
		call dxget("SHIPQTY",tmp$)
		SHQty=tmp$ ! in sum units (ordpad dtl)
		call dxget("BOQTY",tmp$)
		let BOQty=tmp$ ! in sum um (ordpad dtl)
		E$="";returnstatus=1
		Clear List$[]
		maxcnt=-9 ! only set up variables flag
		call GetNewProdDtl(e$,List$[],maxcnt,Prod$,Sqty,SUM,OHR,SHQty,BOQty)
		if e$<>"" or returnstatus<>1 ! means bad data
			let message$=E$
			goto GCDDone
		Endif
		! ok - data loaded in to rol.
		NOLINEYET=1
	Endif
	If OLR>0 Read Record #OLC,OLR,0;nrol.; ! read with prev values
	if prr>0 read record #PRC,prr,0;cpr.;
	Call GetCust()
	CREDIT=0 \ if ros.status=32 let credit=1
	if credit and roh.ShipType=3 let cost_lev[1]=0 ! no cost on cm price error
	LineNo=rol.LineNum
	IF NOT(NOLINEYET) Call SetPRtoRol()
	call dxget("TYPE",tmp$) ! S I F
	tmp$=UCase$(RTrim$(tmp$))
	IF SOURCE=239 OR source=207 clear tmp$
	if tmp$="" and not(nolineyet) ! use existing
		tmp$="STK"
		if rol.LineType=1 let tmp$="INV"
		if rol.LineType=2 let tmp$="FIN"
	Endif
	if tmp$="" and nolineyet let tmp$="STK"
	if tmp$<>"STK" and tmp$<>"INV" and tmp$<>"FIN"
		returnstatus=0
		message$="Invalid Line Type"
		goto GCDDone
	Endif
	let rol.LineType=0 \ if tmp$="INV" let rol.LineType=1
	if tmp$="FIN" let rol.LineType=2
	if rol.LineType=0 ! stock - clear cut data
		rol.NumOut=0;rol.CutChrg=0;rol.CutCost=0
		rol.CutUnit=0;rol.UMCutChrg=0;rol.ExtCutChg=0
		rol.ExtCutCost=0;rol.UMCutCost=0
		goto Sndcddata ! bypass cut data
	Endif
	clear tmp$ ! jic
	call dxget("QTYOUT",tmp$)
	if source=207 or source=239 clear tmp$ ! DO NOT SET/CHG - USE WHAT'S THERE!!
	if tmp$<>"" ! chg'd it or set it?
		x2=tmp$;x2[1]=rol.numout
		if x2<0 or x2>999 or fra(x2)
			returnstatus=0
			message$="INVALID NUMBER OUT"
			goto GCDDone
		Endif
		if x2<>rol.numout let x1=1 else let x1=0
		rol.numout=x2
		if nolineyet ! entered is to customer!
			x3[0]=rol.numout ! entered
			x3[2]=rol.QtyOrd/X3[0];x3[3]=rol.QtyBO/X3[0];x3[4]=rol.QtyShip/X3[0]
		ELSE  ! LINE EXISTS
			if x1 ! changed numout
				if x2[1] ! have orig (ord,etc base = display/ numout
					rol.QtyOrd=rol.QtyOrd*x2[1]
					rol.QtyShip=rol.QtyShip*X2[1]
					rol.QtyBO=rol.QtyBO*X2[1]
				Endif
				if rol.numout ! get new base
					rol.QtyOrd=Rol.QtyOrd/rol.numout
					rol.QtyShip=rol.QtyShip/rol.numout
					rol.QtyBO=rol.QtyBO/rol.numout
				Endif
			Endif
		Endif ! on PM it's parent qtys? 
		if x1 let nolineyet=1 ! so recalc's charg/ccost
		IF nolineyet ! reset lbs
			LET rol.LbsUnit=pr.LbsUnit;rol.WgtFactor=pr.LbsFact
			IF NOT(rol.LbsUnit) LET rol.LbsUnit=1;rol.WgtFactor=1
		Endif
	Endif
	if source=207 or source=239 let recalccut=0 ! NOT ON INQUIRY
	if recalccut ! wants recalc due to changes
		call dxget("CUTCHRG",tmp$)
		if tmp$<>""
			let charg=tmp$
			if charg<0 or charg>99999
				returnstatus=0
				message$="Invalid Cutting Charge"
				goto GCDDone
			Endif
		Endif
		call dxget("CUTCHGUM",tmp$)
		IF UCase$(Trim$(tmp$))="FLAT" 
			let R=-3
		else
			R = getumrec(e$,ccc,tmp$,IntCo,CPR.) 
		Endif          
		If R <> 0 Let tmp$ = Str$(R)                  
		X2 = tmp$
		IF X2>0 ! NOT CWT/FLAT
			Flag=ChkPrdUM(e$,SUM,IntCo,CPr.)
		 If Not(Flag)
			Let E$=" INVALID CUTTING U/M" ! +Prod$
			Let ReturnStatus=0
			GOTO GCDDone
		 Endif
		Endif
		let rol.UMCutChrg=x2
		call dxget("CUTCOST",tmp$)
		if tmp$<>""
			let ccost=tmp$
			if ccost<0 or ccost>99999
				returnstatus=0
				message$="Invalid Cutting Cost"
				goto GCDDone
			Endif
		Endif
		call dxget("CUTCSTUM",tmp$)
		IF UCase$(Trim$(tmp$))="FLAT" 
			let R=-3
		else
			R = getumrec(e$,ccc,tmp$,IntCo,CPR.) 
		Endif
		If R <> 0 Let tmp$ = Str$(R)
		X2 = tmp$
		IF X2>0 ! NOT CWT/FLAT
			Flag=ChkPrdUM(e$,SUM,IntCo,CPr.)
		 If Not(Flag)
			Let E$=" INVALID CUTTING COST U/M" ! +Prod$
			Let ReturnStatus=0
			GOTO GCDDone
		 Endif
		Endif
		let rol.UMCutCost=x2
	Endif ! of recalccut
	! load list
	Sndcddata: ! if new - use prod vars!
	Clear List$[]
	List$[0]=bsdel$,"CUTDETAILS",fdel$
	webstr$="ORDERID",fdel$,"LINEID",fdel$,"PRODID",fdel$
	webstr$=webstr$,"TYPE",fdel$,"QTYOUT",fdel$
	webstr$=webstr$,"INVENTORY",fdel$,"ACTUALINV",fdel$
	webstr$=webstr$,"QTYTOCUST",fdel$,"WEIGHT",fdel$
	webstr$=webstr$,"CUTCHRG",fdel$,"CUTCHGUM",fdel$
	webstr$=webstr$,"CUTCHGUMID",fdel$,"CUTCHGUMFACT",fdel$
	Webstr$=webstr$,"CUTCOST",fdel$,"CUTCSTUM",fdel$
	webstr$=webstr$,"CUTCSTUMID",fdel$,"CUTCSTUMFACT",fdel$
	webstr$=webstr$,"LINEDESC1",fdel$,"LINEDESC2",fdel$
	webstr$=webstr$,"PPRICE",fdel$,"CUTPRICE",fdel$
	webstr$=webstr$,"CUTANDCHRG",FDEL$,"QTYUM",fdel$
	webstr$=webstr$,"PRICEUM",fdel$ ! ,"COSTUM",fdel$
	webstr$=webstr$,"LEVEL",fdel$ ! 
	List$[1]=webstr$
	if rol.numout
		x3[0]=rol.numout
		x3[2]=rol.QtyOrd*X3[0];x3[3]=rol.QtyBO*X3[0];x3[4]=rol.QtyShip*X3[0]
	Else
		x3[2]=rol.QtyOrd;x3[3]=rol.QtyBO;x3[4]=rol.QtyShip
	Endif
	if not(recalccut) ! not just sent!
	  if rol.UMCutChrg=-3 ! FLAT
		Charg=rol.CutChrg
	  Else
		cnvtu[0]=0;cnvtu[1]=rol.UMCutChrg;cnvtu[2]=2
		cnvta=rol.CutChrg
		Charg=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	  Endif
	  if rol.UMCutCost=-3 ! FLAT
		CCost=rol.CutCost
	  Else
		cnvtu[0]=0;cnvtu[1]=rol.UMCutCost;cnvtu[2]=2
		cnvta=rol.CutCost
		CCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	  Endif
	Endif
	IF rol.LineType=2 LET X5=137 ELSE  LET X5=138
	MAT  READ #CTLC,X5,0;MAXWGT;             
	MAT  READ #CTLC,X5,48;DFLTCOST;          
	MAT  READ #CTLC,X5,96;MINCOST;           
	MAT  READ #CTLC,X5,144;MAXCOST;          
	MAT  READ #CTLC,X5,192;DFLTCHG;          
	MAT  READ #CTLC,X5,240;COSTUM;  
	! IF rol.numout=1 IF ROL.CutChrg=0 IF rol.CutCost=0 LET rol.numout=0
	IF rol.numout<=0 LET rol.numout=1                        
	IF PR.LbsFact=0 LET pr.LbsFact=1 
	cnvtu[0]=0;cnvtu[1]=rol.UMSell;cnvtu[2]=1
	cnvta=x3[2]
	Qtyord=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.) ! to sell um
	LET WGT=FNR(ABS((rol.LbsUnit*X3[2])/(rol.numout*pr.LbsFact))) 
	FOR LEVEL=0 TO 6                              
		IF WGT<=MAXWGT[LEVEL] GOTO END_LEVEL_SEARCH:
	NEXT LEVEL                                    
	IF LEVEL>6 LET LEVEL=6                        
	END_LEVEL_SEARCH: REM ! normal get level
	if rol.linetype=0 let rol.numout=0;level=0
	iF nolineyet ! need add'l data
	  if rol.numout
		ChkFraB: ! see if fra base
		IF FRA(X3[2]/rol.numout)                                               
		  LET X3[2]=INT(X3[2])+1                                         
		  GOTO ChkFraB                                                       
		ENDIF                                                              
		LET CNVTU[0]=0;CNVTU[1]=rol.UMSell;CNVTU[2]=1;CNVTA=X3[2] ! QTYORD
		LET Qtyord=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.) ! to sell um
		! need new level?? Yes if Base Qty Changed!
		LET WGT=FNR(ABS((rol.LbsUnit*X3[2])/(rol.numout*pr.LbsFact))) 
		FOR LEVEL=0 TO 6                              
			IF WGT<=MAXWGT[LEVEL] GOTO END_LEVEL_SEARCH2
		NEXT LEVEL                                    
		IF LEVEL>6 LET LEVEL=6                        
		END_LEVEL_SEARCH2: REM 
	  Endif
	
	  if recalccut=0 and rol.numout>0 ! did not send chrg/cost
		  LET CHARG=DFLTCHG[LEVEL]
		  LET CCOST=DFLTCOST[LEVEL]                                                 
		  LET ROL.UMCutChrg=-1 \ LET ROL.UMCutCost=COSTUM
		  IF ROL.CutCost LET ROL.UMCutCost=-1
		  if custom_customer$="OMAHA"!cct#208465/task#10448 %Cut/Punch Markup on Cut 
			 If cust.OmahaCpMup<>0 And CostUM=-1 ! "has markup % and cwt cost
  				Let X3=CCost ! "use in calc
  				LET X4=X3+((X3*(ABS(cust.OmahaCpMup)/100)))*SGN(cust.OmahaCpMup)
  				Let CHARG=X4 ! "cost plus markup %
  				If Q0[1]=2 Let CHARG=FNR(X4) ! "round @ 2
			endif
		  endif
		  LET ROL.ExtCutChg=CHARG*(WGT/100)
		  LET ROL.ExtCutCost=CCOST*(WGT/100)
		  IF MINCOST[LEVEL] IF ROL.ExtCutCost<MINCOST[LEVEL] LET CCOST=MINCOST[LEVEL] \ LET ROL.UMCutCost=-3                                                                        
		  IF MAXCOST[LEVEL] IF ROL.ExtCutCost>MAXCOST[LEVEL] LET CCOST=MAXCOST[LEVEL] \ LET ROL.UMCutCost=-3                                                                        
		  if custom_customer$="OMAHA"!cct#208465/task#10448 %Cut/Punch Markup on Cut 
			If cust.OmahaCpMup<>0 and ROL.UMCUTCOST=-3 ! "flat cost = flat charge?
 				Let X3=CCost ! "use in calc
  				LET X4=X3+((X3*(ABS(cust.OmahaCpMup)/100)))*SGN(cust.OmahaCpMup)
  				Let CHARG=FNR(X4) ! "cost plus markup %
  				Let ROL.umCUTCHRG=-3 ! "change charge to flat also?
			Endif
		 endif
	  Endif ! only new
	
	Endif ! of set cut, etc on new line
	! calc final cost/price
	cnvtu[0]=rol.umcutcost;cnvtu[1]=0;cnvtu[2]=2
	if cnvtu[0] and cnvtu[0]<>-3
		cnvta=ccost
		rol.cutcost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	Endif
	if rol.umcutcost=-3 let rol.cutcost=CCost
	cnvtu[0]=rol.UMCutChrg;cnvtu[1]=0;cnvtu[2]=2
	if cnvtu[0] and cnvtu[0]<>-3
		cnvta=CHARG
		rol.CutChrg=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	Endif
	if rol.UMCutChrg=-3 let rol.CutChrg=CHARG

	cnvtu[0]=rol.UMSell;cnvtu[1]=0;cnvtu[2]=1
	if rol.numout let cnvta=qtyord/rol.numout Else let cnvta=qtyord
	BaseQ=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	if rol.UMCutChrg=-3 and BaseQ ! FLAT
		CHBase=rol.CutChrg/BASEQ
	Else
		CHBase=rol.CutChrg
	Endif
	cnvtu[0]=0;cnvtu[1]=rol.UMPrice;cnvtu[2]=2
	cnvta=rol.UnitPrice
	Price=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	cnvtu[0]=0;cnvtu[1]=rol.UMPrice;cnvtu[2]=2
	IF rol.UMPrice>0 AND rol.numout LET CNVTA=(rol.UnitPrice/rol.numout) ELSE  LET CNVTA=rol.UnitPrice
	CPrice=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	cnvtu[0]=0;cnvtu[1]=rol.UMPrice;cnvtu[2]=2
	IF rol.UMPrice>0 AND rol.numout LET CNVTA=(rol.UnitPrice/rol.numout) ELSE  LET CNVTA=rol.UnitPrice
	IF rol.UMPrice>0 AND rol.numout LET CNVTA=CNVTA+(CHBASE/rol.numout) ELSE let CNVTA=CNVTA+CHBASE
	CHPrice=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	! send data
	if source<>239 let webstr$=Str$(OrderNo) Else Let Webstr$=Str$(RefID)
	webstr$=webstr$,fdel$,Str$(LineNo),fdel$,RTrim$(rol.ProdCode$),fdel$
	tmp$="STK" \ if rol.LineType=1 let tmp$="INV"
	if rol.LineType=2 let tmp$="FIN"
	webstr$=webstr$,tmp$,fdel$,Str$(rol.NumOut),fdel$
	!cnvtu[0]=rol.UMSell;cnvtu[1]=pr.UMStkDefault;cnvtu[2]=1
	!if rol.numout let cnvta=qtyord/rol.numout Else Let cnvta=Qtyord
	cnvtu[0]=0;cnvtu[1]=cpr.UMStkDefault;cnvtu[2]=1;cnvta=BaseQ
	! if not(nolineyet) let cnvtu[1]=pr.UMPurchDefault ! moved in prtorol
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,CPR.)
	tmp$=XUnit$(cpr.UMStkDefault,ccc)
	webstr$=webstr$,LTRim$(x3 using QMask$)," ",tmp$,fdel$ ! stk order
	if rol.numout let cnvta=qtyord/rol.numout Else let cnvta=Qtyord
	webstr$=webstr$,lTRIM$(cnvta using QMask$),fdel$ !  ordered
	webstr$=webstr$,LTRim$(Qtyord using QMask$),fdel$ ! Qty to cust
	webstr$=webstr$,LTrim$(WGT using QMask$),fdel$ ! weight
	webstr$=webstr$,LTrim$(Charg using PMask$),fdel$ ! cut charge
	tmp$="" \ if rol.UMCutChrg let tmp$=XUnit$(rol.UMCutChrg,ccc)
	if rol.UMCutChrg=-3 let tmp$="FLAT"
	webstr$=webstr$,tmp$,fdel$,Str$(rol.UMCutChrg),fdel$ ! cut um, ID
	x3=0 \ if rol.UMCutChrg>0 let x3=UMtoFactor(rol.UMCutChrg)
	if rol.UMCutChrg<0 let x3=rol.UMCutChrg
	webstr$=webstr$,LTrim$(X3 using "-------#"),fdel$ ! um factor?
	webstr$=webstr$,LTrim$(CCost using PMask$),fdel$ ! cut cost
	tmp$="" \ if rol.UMCutCost let tmp$=XUnit$(rol.UMCutCost,ccc)
	if rol.UMCutCost=-3 let tmp$="FLAT"
	webstr$=webstr$,tmp$,fdel$,Str$(rol.UMCutCost),fdel$
	x3=0 \ if rol.UMCutCost let x3=UMtoFactor(rol.UMCutCost)
	if rol.UMCutCost<0 let x3=rol.UMCutCost
	webstr$=webstr$,LTrim$(X3 using "-------#"),fdel$ ! um factor?
	tmp$=clrtxtc$(e$,rol.Desc1$) ! chk/clr control chars
	webstr$=webstr$,RTrim$(tmp$),fdel$
	tmp$=clrtxtc$(e$,rol.Desc2$) ! chk/clr control chars
	webstr$=webstr$,RTrim$(tmp$),fdel$
	webstr$=webstr$,LTrim$(Price using PMask$),fdel$
	webstr$=webstr$,LTrim$(CPrice using PMask$),fdel$
	webstr$=webstr$,LTrim$(CHPrice using PMask$),fdel$
	tmp$=XUnit$(rol.UMSell,ccc)
	webstr$=webstr$,tmp$,fdel$ ! UM Sell
	tmp$=XUnit$(rol.UMPrice,ccc)
	webstr$=webstr$,tmp$,fdel$ ! UM PRICE
	webstr$=webstr$,Str$(Level+1),fdel$ ! level
	List$[2]=webstr$
	List$[3]=esdel$ ! finished
	e$=""
	call AddToStr(e$,rstr$,List$[])
	! need to send UM usable (add FLAT!)
	clear list$[]
	List$[0]=bsdel$,"CUTUM",fdel$
	list$[1]="UM",fdel$,"DESC",fdel$
	row=2
	! add cwt/flat
	let list$[row]="CWT ",fdel$,"HUNDRED WT",fdel$ \ row=row+1
	list$[row]="FLAT",fdel$,"FLAT CHRG",fdel$ \ row=row+1
	for x=0 to 7
		if x=0 let x1=pr.BaseUM
		if x=1 let x1=pr.UM2
		if x=2 let x1=pr.UM3
		if x=3 let x1=pr.UM4
		if x=4 let x1=pr.UM5
		if x=5 let x1=pr.UM6
		if x=6 let x1=pr.UM7
		if x=7 let x1=pr.UM8
		if x1>0
			read #ccc,x1,0;x$[1,14];
			list$[row]=x$[11,14],fdel$,X$[1,10],fdel$
			row=row+1
		Endif
	Next X
	! done
	list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])
	GCDDone: ! finished
	if returnstatus=1 let message$="OK" ! set if no other problems
	if debugdetail
		dmsg$="Get Cut "+Str$(rol.OrdNum)+"-"+Str$(rol.LineNum)+" "+rol.ProdCode$+Message$ \ Call updatelog(debug)
	Endif
	
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	
  else
    include "src/callsuberr.inc"
 end try
end sub ! GetCutDetails
! 
!--------------------------------------------------------------------
Sub SubmitCutDetails()
! Submit cutting details
  Try
	Dim X$[20],NSFKey$[60]
	dim holdpswd$[12,16]
	Dim 1%,CNVTU[2],FLAG[9],X1[9]
	Dim 1%,NewLn,HFlg[16],HFlag[16],Credit
	Dim 2%,X2[9],NumLines,ShipDate,JDate[5]
	Dim 3%,CNVTA,AMOUNT,X3[9],V3[99]
	Dim 3%,WHBLD[2],S9[20]

	Dim NRol. as rolnew ! store new sent data
	Dim CPR. as prod
	if debugdetail
		dmsg$="Start submit cut details" \ Call updatelog(debug)
	Endif
	if p9$[20,20]<>"F" ! not fine version
		returnstatus=0
		message$="Not Fine Paper Version"
		goto SCDDONE
	Endif
	ReturnStatus=1
	Message$="OK"
	hmaxcnt=maxcnt ! keep it
	Read #ctlc,3,188;ShipDate; ! for inv levels
	! source gotten in beginning
	if source=207 or source=239
		returnstatus=0
		message$="Can not submit on Inquiry"
		goto SCDDone ! NO WRITE ON INQUIRY
	Endif
	Call DXGet("ORDERID",tmp$)
	If tmp$="" goto SCDDone
	OrderNo=tmp$
	If OrderNo<1 or OrderNo>999999 or Fra(OrderNo)
		ReturnStatus=0
		Message$="ORDER NUMBER INVALID"
		Goto SCDDone
	Endif
	OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
	e$=""
	If OHR<=0 ! not found
		ReturnStatus=99
		Message$="ORDER WAS NOT FOUND"
		goto SCDDone
	Else
		Credit=0 \ if rot.Status=22 let Credit=1 ! instead of roh.status check
		if returnstatus<>0
			call verifystat()
			if returnstatus=99 goto SCDDone
		endif
		LET X3=rot.HoldCode ! unpack hold flags
		FOR CTR=0 TO 11                          
			LET HFlg[CTR]=SGN(FRA(X3/2));X3=INT(X3/2)
		NEXT CTR 
		for ctr=1 to 12
			read #ctlc,66,((ctr*16)-16);holdpswd$[ctr];
		next ctr
	Endif
	tmp$ = ShipDate Using "&&&&&&"                                 
	Call DateToJulian(1,tmp$,tmp1$,f)                              
	If f Let tmp1$ = ""                                            
	JDATE[1] = tmp1$;f = 0 ! julian sys shipdate                   
	tmp$ = roh.ShipDate Using "&&&&&&"                             
	If roh.ShipDate <> 999999 Call DateToJulian(1,tmp$,tmp1$,f)    
	If f Let tmp1$ = ""                                            
	JDATE[2] = tmp1$ ! julian ord shipdate  
	Call DXGet("LN",tmp$) ! +Str$(X1),tmp$)
	nrol.LineNum=tmp$ ! line # (zero on new lines)
	LineNo=nrol.LineNum;NOLINEYET=0
	if nrol.linenum ! get prev data
		rolkey$=" ",rolkey$
		rolkey$[1,6]=OrderNo Using "######"
		rolkey$[7,9]=nrol.linenum using "###"
		rolkey$[11]="" ! cut to length (space @ 10)
		OLR=filegetrolz(e$,OLC,"=",1,rolkey$,rol.)
		clear e$
		if olr<=0 ! what do we do if not found - if passed has to be there
				clear rol.
				returnstatus=0 ! treat as new?
				e$="" ! clear emsg
				Message$="ORDER LINE WAS NOT FOUND"
				goto SCDDone
		Endif
		If OLR>0
			if rol.NStkItem=1 ! and rol.LineType<>3
				returnstatus=0
				message$="Cut is not allowed on Non-Stocks"
				goto SCDDone
					NSR=rol.PDRecNum
					Read record #NSC,NSR,0;nstk.
					PRR=0;PWR=0
			Endif
			if rol.KitDesignation$="KIT"
				returnstatus=0
				message$="Cut is not allowed on Kit Lines"
				goto SCDDone
			Endif
			If Not(rol.NStkItem) ! get prod & whse
					PRR=rol.PDRecNum
					Read record #PRC,PRR,0;pr.;
					if roh.ordtype=8 or roh.ordtype=16 ! chk to whse
					  If Roh.ConsWh>0 and roh.conswh<100
						Let TPWKey$=" ",tpwKey$
						TPWkey$[1,12]=pr.prodcode$+Blank$
						TPWKey$[13]=ROH.ConsWh Using "##"
						call chktowhse(TPWKey$,pr.PrimVend)
					  Endif
					Endif
					Tmp$=" ",tmp$
					tmp$=Pr.ProdCode$+rol.Whse Using "##"
					if roh.ordtype=7 let tmp$=Pr.ProdCode$+ROH.ConsWh Using "##"
					PWR=filegetprodwhse(e$,PWC,"=",1,tmp$,pw.)
					clear e$
					if PWR<0 ! not found - add new
						Clear pw.
						If PWR=-1 ! not found
							E$="";x3=tmp$[13,14]
							if roh.ordtype=7
								x3[1]=rol.whse/100
								x3=x3+x3[1]
							Endif
							Whbld[0]=PWC;Whbld[1]=X3;WhBld[2]=pr.PrimVend
							if x3<>1 let Whbld[1]=X3+.01 ! fra=copy whse 1
							Call mxwhcreate(e$,IntCo,PR.PRODCode$,WHBLD[])
							PWR=Whbld[2]
							Read record #PWC,PWR,0;PW.;
						Endif ! no whse
					Endif ! wh not found
			Endif ! stk item
		Endif ! existing line
	Else ! no line
		Clear rol. ! clear
		Clear nstk.
		! will need to create line now!
		Call DXGet("PRODID",tmp$)
		tmp$=RTrim$(tmp$)
		If tmp$="" Goto SCDDone: ! NEED A PRODUCT!
		Let PROD$=UCase$(tmp$)+Blank$
		Call DXGet("QTY",tmp$)
		Let SQty=tmp$ ! in sum units
		Call DXGet("UM",tmp$)
		Let SUM=tmp$
		! added for order pad detail entry
		call dxget("SHIPQTY",tmp$)
		SHQty=tmp$ ! in sum units (ordpad dtl)
		call dxget("BOQTY",tmp$)
		let BOQty=tmp$ ! in sum um (ordpad dtl)
		E$="";returnstatus=1
		Clear List$[]
		maxcnt=-9 ! only set up variables flag
		call GetNewProdDtl(e$,List$[],maxcnt,Prod$,Sqty,SUM,OHR,SHQty,BOQty)
		if e$<>"" or returnstatus<>1 ! means bad data
			let message$=E$
			goto SCDDone
		Endif
		PRR=rol.PDRecNum ! needed below?
		! ok - data loaded in to rol.
		NOLINEYET=1;OLR=0
		! all rol. are set up - NO LINE CREATED YET!
	Endif
	If OLR>0 Read Record #OLC,OLR,0;nrol. ! read / lock with prev values
	IF PRR>0 read record #PRC,PRR,0;cpr.; ! copy of prod
	Call GetCust()
	CREDIT=0 \ if ros.status=32 let credit=1
	if credit and roh.ShipType=3 let cost_lev[1]=0 ! no cost on cm price error
	LineNo=rol.LineNum
	if not(NOLINEYET) ! exists - set up conv
		Call SetPRtoRol()
	Endif ! existing line
	IF rol.numout ! to base display qtys
		x3[0]=rol.numout
		x3[2]=rol.QtyOrd*X3[0];x3[3]=rol.QtyBO*X3[0];x3[4]=rol.QtyShip*X3[0]
	Else
		let x3[2]=rol.qtyord;x3[3]=rol.qtybo;x3[4]=rol.qtyship ! retain original BASE
	Endif
	X3[1]=x3[2] ! origqtyord
	! get data
	call dxget("TYPE",tmp$) ! S I F
	tmp$=UCase$(RTrim$(tmp$))
	if tmp$<>"STK" and tmp$<>"INV" and tmp$<>"FIN"
		returnstatus=0
		message$="Invalid Line Type"
		goto SCDDone
	Endif
	let rol.LineType=0 \ if tmp$="INV" let rol.LineType=1
	if tmp$="FIN" let rol.LineType=2
	if rol.LineType=0 ! stock - clear cut data
		rol.NumOut=0;rol.CutChrg=0;rol.CutCost=0
		rol.CutUnit=0;rol.UMCutChrg=0;rol.ExtCutChg=0
		rol.ExtCutCost=0;rol.UMCutCost=0
		goto CutDOK ! bypass cut data
	Endif
	clear tmp$ ! jic
	call dxget("QTYOUT",tmp$) ! 0=NG, 1-999 (if chgd-base qtys change!!)
	x2=tmp$
	if x2<1 or x2>999 or fra(x2)
		returnstatus=0
		message$="Invalid Number out"
		goto SCDDone
	Endif
	let rol.numout=x2
	cnvtu[0]=0;cnvtu[1]=rol.UMSell;cnvtu[2]=1
	cnvta=x3[2] ! TO customer ordered
	Qtyord=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.) ! in sell um
	if rol.numout
		ChkFraBs: ! see if fra base
		IF FRA(X3[2]/rol.numout)                                               
		  LET X3[2]=INT(X3[2])+1                                         
		  GOTO ChkFraBS                                                       
		ENDIF                                                              
		LET CNVTU[0]=0;CNVTU[1]=UN[0];CNVTU[2]=1;CNVTA=X3[2] ! QTYORD
		LET Qtyord=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.) ! sell um
	Endif
	call dxget("CUTCHRG",tmp$)
	if tmp$<>""
		let charg=tmp$
		if charg<0 or charg>99999
			returnstatus=0
			message$="Invalid Cutting Charge"
			goto SCDDone
		Endif
	Endif
	call dxget("CUTCHGUM",tmp$)
	IF UCase$(Trim$(tmp$))="FLAT" 
		let R=-3
	else
		R = getumrec(e$,ccc,tmp$,IntCo,CPR.) 
	Endif          
	If R <> 0 Let tmp$ = Str$(R)                  
	X2 = tmp$
	IF X2>0 ! NOT CWT/FLAT
		cum=x2
		Flag=ChkPrdUM(e$,cum,IntCo,CPr.)
	 If Not(Flag)
		Let messagE$=" INVALID CUTTING U/M" ! +Prod$
		Let ReturnStatus=0
		GOTO SCDDONE
	 Endif
	Endif
	let rol.UMCutChrg=x2
	call dxget("CUTCOST",tmp$)
	if tmp$<>""
		let ccost=tmp$
		if ccost<0 or ccost>99999
			returnstatus=0
			message$="Invalid Cutting Cost"
			goto SCDDone
		Endif
	Endif
	call dxget("CUTCSTUM",tmp$)
	IF UCase$(Trim$(tmp$))="FLAT" 
		let R=-3
	else
		R = getumrec(e$,ccc,tmp$,IntCo,CPR.) 
	Endif
	If R <> 0 Let tmp$ = Str$(R)
	X2 = tmp$
	IF X2>0 ! NOT CWT/FLAT
		cum=x2
		Flag=ChkPrdUM(e$,CUM,IntCo,CPr.)
	 If Not(Flag)
		Let messagE$=" INVALID CUTTING COST U/M" ! +Prod$
		Let ReturnStatus=0
		GOTO SCDDONE
	 Endif
	Endif
	let rol.UMCutCost=x2
	call dxget("LINEDESC1",tmp$)
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Description 1"
		goto SCDDONE
	Endif
	let rol.Desc1$=Trim$(Tmp$)+Blank$
	call dxget("LINEDESC2",tmp$)
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Description 2"
		goto SCDDONE
	Endif
	let rol.Desc2$=Trim$(tmp$)+Blank$
	if not(nolineyet) ! existing and data is ok
		If Not(Credit) and rol.UpdtStk ! back out prev qty ord from prod & whse
			Read record #PRC,PRR,0;PR.
			If PWR>0 Read Record #PWC,PWR,0;pw.
			X3=ROL.QtyShip ! as mxline updates prods
			if roh.OrdType=15 or roh.ordtype=19 let x3=rol.QtyOrd-rol.PrevQtyShip-rol.QtyBO
			if custom_customer$="MORRISETTE"
				If roh.OrdType=4 Let X3=ROL.QtyShip ! "cct 129415 - only commit shipping qty
			Endif
			IF roh.OrdType=15 AND roh.BOCTR<>0 LET x3=0        
			IF roh.OrdType=15 AND roh.BOCTR=0 LET x3=rol.QtyOrd
			if roh.ordtype=19 and roh.boctr<>0 and roh.ot19comp=0 let x3=0 ! closed!
			If X3<0 let X3=0 ! neg ship - no Onord update
			pr.QtyOnOrd=pr.QtyOnOrd-X3
			pw.QtyOnOrd=pw.QtyOnOrd-x3
			IF JDATE[1]>=JDATE[2]
				LET pr.Lvl1Qty=pr.Lvl1Qty-x3
				Let pw.Lvl1Qty=pw.Lvl1Qty-x3
				if pr.Lvl1Qty<0 let pr.Lvl1Qty=0
				if pw.Lvl1Qty<0 let pw.Lvl1Qty=0
			ELSE
				LET pr.Lvl2Qty=pr.Lvl2Qty-x3
				Let pw.Lvl2Qty=pw.Lvl2Qty-x3
				if pr.Lvl2Qty<0 let pr.Lvl2Qty=0
				if pw.Lvl2Qty<0 let pw.Lvl2Qty=0
			Endif
			if pr.CatchwgtItem$="Y"
				X=1 \ if rol.QtyOrd<0 let x=0 ! -1 ! neg ord/ship (wgt always +)
				IF roh.OrdType=15 AND roh.BOCTR<>0 LET x=0 ! NO QTY
				pr.LbsOnOrder=pr.LbsOnOrder-(rol.ExtNetWgt*x)
				pw.LbsOnOrder=pw.LbsOnOrder-(rol.ExtNetWgt*x)
			Endif
			If pr.QtyOnOrd<0 Let pr.QtyOnOrd=0
			If pw.QtyOnOrd<0 let pw.QtyOnOrd=0
			If pr.LbsOnOrder<0 Let pr.LbsOnOrder=0
			If pw.LbsOnOrder<0 Let pw.LbsOnOrder=0
			Write Record #PRC,PRR,0;PR.;
			if sqlChan >= 0 ! MySQL enabled and channel opened
				call prod_DL4SQLConvert(e$,"FROMDL4",PR.,sql_prod.,PRR)
				e = prod_SQLAddUpdate(e$,sqlChan,sql_prod.) ! mode="a" or "c"
				if e <> 1 ! returns the number of records add/updated/deleted
					error 11000
				end if
			end if
			If PWR>0 Write Record #PWC,PWR,0;pw.;
		Endif ! of updatestk
	Endif
	! reset weight vars to rol (as re-read pr. above)
	If rol.LbsUnit>0 LET pr.LbsUnit=rol.LbsUnit
	if rol.WgtFactor>0 let pr.LbsFact=rol.WgtFactor
	IF NOT(pr.LbsUnit) LET pr.LbsUnit=1;rol.WgtFactor=1    
	LET pr.CubicFeet=rol.CubeUnit;pr.CubicFtFactor=rol.CubeFactor
	IF NOT(pr.CubicFtFactor) LET pr.CubicFtFactor=1;rol.CubeFactor=1
	! set up conv
	IF PR.LbsFact=0 LET pr.LbsFact=1                          
	if rol.numout 
		LET WGT=FNR(ABS((rol.LbsUnit*X3[2])/(rol.numout*pr.LbsFact)))
	else
		let wgt=rol.ExtNetWgt
	Endif
	REM CONVERT CHARGE TO BASE                                            
	IF rol.UMCutChrg=-3 
		LET rol.CutChrg=CHARG \ LET rol.ExtCutChg=rol.CutChrg
	Else
		LET CNVTU[0]=rol.UMCutChrg;CNVTU[1]=0;CNVTU[2]=2;CNVTA=CHARG
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		LET rol.CutChrg=AMOUNT
		LET ROL.ExtCutChg=CHARG*(WGT/100)
	Endif                                                                
	REM CONVERT COST TO BASE                                              
	IF rol.UMCutCost=-3
		LET rol.CutCost=CCOST \ LET rol.ExtCutCost=Rol.CutCost
	Else
		LET CNVTU[0]=rol.UMCutCost \ LET CNVTU[1]=0 \ LET CNVTU[2]=2 \ LET CNVTA=CCOST
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		LET rol.CutCost=AMOUNT 
		LET ROL.ExtCutCost=CCOST*(WGT/100)
	Endif
	! per group - also redo onord,onbo,ship after
	CutDOK: ! ok - continue
	! use x3[] - base customer qtys-original
	!0=org.numout,1&2=ord,3=bo,4=shp
	IF X3[4]=X3[1] AND X3[2]>X3[4] LET x3[4]=x3[2]   
	IF X3[3] AND X3[2]>X3[1] LET X3[3]=X3[2]-X3[4]       
	IF X3[4]>X3[2] LET X3[4]=X3[2]                          
	IF X3[3]>X3[2] LET X3[3]=X3[2]                             
	IF X3[3]+X3[4]>X3[2] LET X3[3]=X3[2]-X3[4]              
	IF rol.numout ! put back to parent qtys
	  LET rol.QtyOrd=X3[2]/rol.numout;rol.Qtybo=X3[3]/rol.numout;rol.qtyship=X3[4]/rol.numout
	ELSE                                                          
	  LET rol.QtyOrd=X3[2];rol.Qtybo=X3[3];rol.qtyship=X3[4]                  
	ENDIF 
	nrol.QtyOrd=rol.QtyOrd;nrol.Qtybo=rol.Qtybo;nrol.qtyship=rol.qtyship
	! get bo type
	x=0 \ if p60$[27,27]="S" let x=1
	if p60$[27,27]="B" let x=2
	if p60$[27,27]="E" let x=3
	if kit let x=0 ! will build it
	! Per group = redo avail check
	x2[9]=rol.whse \ if roh.ordtype=7 let x2[9]=roh.ConsWh
	If RTrim$(rol.ProdCode$)<>""
		X3[1]=getwhavail(e$,intco,PWC,rol.ProdCode$,X2[9])
	Else
		x3[1]=0
	Endif
	if nrol.linenum>0 and not(NonStk) and rol.UpdtStk
	  if not(credit) and roh.ordtype<>15 AND rol.qtyship>=0
!	    if roh.ordtype=4 ! backs out ordered
!		  if custom_customer$="MORRISETTE"
!			let X3[1]=X3[1]+rol.qtyship ! add back this order
!		  Else
!			let X3[1]=X3[1]+(rol.qtyord-rol.PrevQtyShip)
!		  Endif
!		Else
			let X3[1]=X3[1]+rol.qtyship ! add back this order (internal chk)
			! avail is less the curr ship qty for ship?
!		Endif
	  Endif
	Endif
	if Not(credit) and X>0 ! has bochk set
	 If rol.QtyOrd>0 and ROL.UpdtStk and rol.QtyOrd>X3[1] ! order > whavail
	  if x3[1]>0 ! has some avail
		Let rol.QtyShip=X3[1] ! take it all
		Let rol.QtyBO=rol.QtyOrd-rol.QtyShip
	  Else ! zero or <0 avail
		Let rol.QtyShip=0
		Let rol.QtyBO=rol.QtyOrd ! all backordered
	  Endif
	 Endif ! of updt and ord>avail
	Endif
	! added 2/28 - convert shipped/bo to sell 2 dec - 2316
	if rol.qtyship<>0
		cnvtu[0]=0;cnvtu[1]=rol.UMSell;cnvtu[2]=1
		cnvta=rol.qtyship
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		tmp$=LTrim$(amount using "----------#.##")
		amount=tmp$ ! now 2 decimals only
		cnvtu[0]=rol.UMSell;cnvtu[1]=0;cnvtu[2]=1
		cnvta=amount
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if amount<>rol.qtyship ! it changed
			rol.qtyship=amount
			if rol.qtyship>x3[1] let rol.qtyship=x3[1] ! no overship!
			Let rol.QtyBO=rol.QtyOrd-rol.QtyShip
		Endif
	Endif ! of recalc qty ship based on 2 dec
	! if user entered?
	!if NoLineYet ! not existing
	! if MSHQty or MBOQty ! manually entered this - keep it? NO
	!	let rol.QtyShip=MSHQty ! as entered (override calc)
	!	let rol.QtyBO=MBOQty ! as entered
	! Endif
	!Endif ! new line
	if roh.ordtype=15 let rol.qtyship=0;rol.qtybo=0 ! starts as zero
	if Cust.BoSAllowedFlag=0 Let rol.QtyBO=0 ! no bo's allowed
	if pw.DNReordFlg=1 and rol.qtybo let rol.qtybo=0 ! no bo
	if roh.ordtype=4 let rol.QtyBO=0 ! no bo's allowed on ot4? - 32160
	! and update on order/rasl
	
	clear rol.SpareNu$ ! dl4 fix
	if nolineyet ! not existing
		 X2=GetNxtLine(orderno) ! GET NEXT LINE# 
		 rol.linenum=x2;E=0;olr=0
		 OLR=fileupdaterolz(e$,OLC,"a",e,rol.)
	Else ! is existing
		write record #OLC,OLR,0;rol.;
	Endif ! add new line
	read record #OLC,OLR,0;nrol.; ! below uses nrol
	call dolineextens() ! re-calc extensions 
	write record #OLC,OLR,0;nrol.; ! ext update
	If Not(nonstk) and rol.UpdtStk and OLR>0
	   ! add qtyord to prod & Whse
	   if Not(nonStk) and Not(Credit) and nrol.UpdtStk ! add NEW qty ord to prod & whse
			Read record #PRC,PRR,0;PR.
			! in case whse change - get whse again
			tmp$=" ",tmp$
			tmp$=pr.prodcode$+nrol.whse using "##"
			if roh.ordtype=7 let tmp$=pr.prodcode$+roh.ConsWh using "##"
			PWR=filegetprodwhse(e$,pwc,"=",1,tmp$,pw.,1)! get and LOCK
			clear e$
			If PWR<0 ! search error
			  Clear pw.
			  if PWR=-1 ! new whse not found - add it now
				E$="";x3=tmp$[13,14] ! CLEAR NOF msg
				if roh.ordtype=7
					x3[1]=nrol.whse/100
					x3=x3+x3[1]
				Endif
				Whbld[0]=PWC;Whbld[1]=x3;WhBld[2]=pr.PrimVend
				if x3<>1 let Whbld[1]=X3+.01 ! fra=copy whse 1
				Call mxwhcreate(e$,IntCo,pr.PRODCode$,WHBLD[])
				PWR=Whbld[2]
				Read Record #PWC,PWR,0;pw.
			  Endif
			Endif
			X3=NROL.QtyShip ! as mxline updates prods
			if roh.OrdType=15 or roh.ordtype=19 let x3=nrol.QtyOrd-nrol.PrevQtyShip-nrol.QtyBO
			if custom_customer$="MORRISETTE"
				If roh.OrdType=4 Let X3=NROL.QtyShip ! "cct 129415 - only commit shipping qty
			Endif
			IF roh.OrdType=15 AND roh.BOCTR<>0 LET x3=0        
			IF roh.OrdType=15 AND roh.BOCTR=0 LET x3=nrol.QtyOrd
			if roh.ordtype=19 and roh.boctr<>0 and roh.ot19comp=0 let x3=0 ! closed
			if x3<0 let X3=0 ! no neg onord update
			pr.QtyOnOrd=pr.QtyOnOrd+X3
			pw.QtyOnOrd=pw.QtyOnOrd+x3
			IF JDATE[1]>=JDATE[2]
				LET pr.Lvl1Qty=pr.Lvl1Qty+x3
				Let pw.Lvl1Qty=pw.Lvl1Qty+x3
			ELSE
				LET pr.Lvl2Qty=pr.Lvl2Qty+x3
				Let pw.Lvl2Qty=pw.Lvl2Qty+x3
			Endif
			if pr.CatchwgtItem$="Y"
				X=1 \ if nrol.QtyOrd<0 let x=0 ! -1 ! neg ord/ship (wgt always +)
				IF roh.OrdType=15 AND roh.BOCTR<>0 LET x=0 ! NO QTY
				pr.LbsOnOrder=pr.LbsOnOrder+(nrol.ExtNetWgt*x)
				pw.LbsOnOrder=pw.LbsOnOrder+(nrol.ExtNetWgt*x)
			Endif
			Write Record #PRC,PRR,0;PR.;
			if sqlChan >= 0 ! MySQL enabled and channel opened
				call prod_DL4SQLConvert(e$,"FROMDL4",PR.,sql_prod.,PRR)
				e = prod_SQLAddUpdate(e$,sqlChan,sql_prod.) ! mode="a" or "c"
				if e <> 1 ! returns the number of records add/updated/deleted
					error 11000
				end if
			end if
			If PWR>0 Write Record #PWC,PWR,0;pw.;
			IF PW.QtyOnHand-pw.QtyOnOrd<0 
				If rtrim$(holdpswd$[3])<>"" LET HFlag[2]=1 ! OOS hold
			endif
			If pr.QtyOnHand-pr.QtyOnOrd<0 
				If rtrim$(holdpswd$[3])<>"" LET HFlag[2]=1
			endif
		Endif
	Endif ! of onord, etc update
	if roh.ordtype=4
			! moved extensions up (was qtybo-borel) - native = bo+borel		
			if nrol.qtyord<nrol.CurrRelQty+(nrol.QtyBo-nrol.BORelQty)+nrol.PrevQtyShip
				returnstatus=0
				message$="Quantity is over shipped"
				!goto SCDDone ! abort update? let's not
			Endif
	Endif
	if roh.ordtype=15
			! moved extensions up (was qtybo-borel) - native = bo+borel
			!if nrol.qtyord<>nrol.CurrRelQty+(nrol.QtyBo+nrol.BORelQty)+nrol.PrevQtyShip
			if nrol.qtyord<nrol.CurrRelQty+(nrol.QtyBo-nrol.BORelQty)+nrol.PrevQtyShip
				returnstatus=0
				message$="Quantity is Out of Balance"
				!goto SCDDone ! abort update? let's not
			Endif
	Endif
	if roh.ordtype=19
			x3[5]=rol.PrevQtyShip+nrol.QtyShip+nrol.QtyBO ! new qty/prev
			if roh.ordtype=19 and roh.BOCTR<>0 and roh.Ot19Comp=0 let x3[5]=ROL.qtyship ! final ordered=shipped
			if nrol.qtyord<>X3[5] ! rol.PrevQtyShip+rol.QtyShip+rol.QtyBO
				returnstatus=0
				message$="Quantity is unequal. Please adjust (ord=ship+bo+prev)"
				!goto SCDDone ! no abort - just message
			Endif
	Endif
	If ETr.EtAction=0 ! no check yet
			! per MM - no holds set for price/cost on cuts
			if nrol.UnitPrice<>rol.UnitPrice ! diff - is it rounded?
			  if FNC(nrol.UnitPrice)<>FNC(rol.UnitPrice) ! compare at 4 dec
				let ETr.EtAction=23
				!If rtrim$(holdpswd$[5])<>"" let HFlag[4]=1 ! prc chg/hold
			  Endif
			endif
			if nrol.unitcost<>rol.unitCost ! diff - is it rounded?
			  if FNC(nrol.unitcost)<>FNC(rol.unitCost) ! compare 4 dec
				let ETr.EtAction=24
				!If rtrim$(holdpswd$[6])<>"" Hflag[5]=1 ! cost chg/hold
			  Endif
			endif
			If nrol.netprice<>rol.netprice ! diff - is it rounded?
			  If FNC(nrol.netprice)<>FNC(rol.netprice) ! compare to 4 dec
				let etr.etaction=23
				!If rtrim$(holdpswd$[5])<>"" let HFlag[4]=1 ! prc chg/hold
			  Endif
			endif
			if nrol.Qtyord<>rol.QtyOrd let ETr.EtAction=1 ! qty overrides price/cost
			if nrol.QtyBO<>rol.QtyBo let ETr.EtAction=1
			if nrol.QtyShip<>rol.QtyShip let ETr.EtAction=1
			
	Endif
		!if KIT and nrol.QtyShip<>rol.QtyShip let KITCHG=1
	If P60$[44,44]="Y" and etr.EtAction<>0
		call edttrkdo(rol.,nrol.) ! org, new
	Endif ! of edit tracking
		! now any post update work starts
	iF not(roh.HoldOver) ! repack holds
			! HFlag[x]=set in this routine, HFlg[x]=set previously
			If HFlag[2] Let HFlg[2]=chkhldcode(3) ! hold passwd=1+ the flag
			If HFlag[4] let HFlg[4]=chkhldcode(5)
			If HFlag[5] let HFlg[5]=chkhldcode(6)
			
			LET X3=0 ! repack holds                               
			FOR CTR=0 TO 11                         
				IF HFlg[CTR] LET X3=X3+2^CTR            
			NEXT CTR                                
			LET rot.HoldCode=X3
			IF (Credit) LET rot.HoldCode=0
			if roh.ordtype=16 let rot.HoldCode=0
			WRITE Record #otc,roh.TotRec,0;rot.;
	Endif
	if rol.UpdtStk ! also update rasl!
			S9[2]=OHR;S9[3]=0;S9[4]=source ! determine program #?
			If credit let S9[3]=4;S9[4]=243 ! credit
			if source=2082 let s9[4]=208 ! order edit v2
			if s9[4]<=0 let s9[4]=208 ! send something!
			S9[12]=OLR ! PASS THE LINE JUST UPDATED (new single line mxrasl5)?
			FChan[0]=1;FChan[1]=PRC;FCHan[2]=OHC;FChan[3]=OLC
			FChan[4]=0;FChan[5]=ccc;FChan[6]=PLTC;FChan[7]=0
			FChan[8]=SLTC;FChan[9]=0
			! Call dxsave(0,"tmp/olrcut.txt!")
			Call "MXRASL5.DL4",intco,Ctlc,S9[],FChan[]
	Endif
	! resend line to web
	maxcnt=hmaxcnt;dopart=0
	dooneline=rol.linenum ! 1 line send flag
	call getordlines() ! try existing routine
	SCDDone: ! finished
	if returnstatus=1 let message$="OK" ! set if no other problems
	if debugdetail
		dmsg$="Update Cut "+Str$(rol.OrdNum)+"-"+Str$(rol.LineNum)+" "+rol.ProdCode$+Message$ \ Call updatelog(debug)
	Endif
	
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	
  else
    include "src/callsuberr.inc"
 end try
end sub ! SubmitCutDetails
! 
!--------------------------------------------------------------------
Sub dolineextens()
! subroutine for extensions (ALWAYS NROL.!)
! Also recalcs Net Price
  Try
	Dim 3%,CHBase,NetCost
	! REDO EXTENSIONS - From MXLINE
	IF NROL.UMCutChrg=-3 AND Nrol.QtyOrd LET CHBASE=(nrol.CutChrg/nrol.QtyOrd) ELSE  LET CHBASE=nrol.CutChrg 
	LET NRol.NetPrice=nrol.UnitPrice-nrol.LineDisc+CHBASE
	LET NRol.NetPrice=nRol.NetPrice-(nRol.NetPrice*(nrol.LineDiscPct/100))
	IF nrol.UpChrg>0 LET nRol.NetPrice=nRol.NetPrice+(nRol.NetPrice*(nrol.UpChrg/100))
	IF nrol.UpChrg<0 LET nRol.NetPrice=nRol.NetPrice+(0-nrol.UpChrg)
	! LET X2=5 \ GOSUB L_15500: \ LET X2=5 \ GOSUB L_15000: ! TO PRICE UM THEN BACK NET Price
	cnvtu[0]=0;cnvtu[1]=nrol.UMPrice;cnvtu[2]=2
	cnvta=nrol.NetPrice
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	cnvtu[0]=nrol.UMPrice;cnvtu[1]=0;cnvtu[2]=6;cnvta=x3
	nrol.NetPrice=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	IF nrol.UMCutCost=-3 AND nrol.QtyOrd LET CHBASE=(nrol.CutCost/nrol.QtyOrd) ELSE  LET CHBASE=nrol.CutCost
	LET NETCOST=nrol.UnitCost+CHBASE
	IF nrol.LoadUpchrg
	  IF nrol.LoadUpchrg <0
		LET NETCOST=NETCOST+ABS(nrol.LoadUpchrg )
	  ELSE
		LET NETCOST=NETCOST+(NETCOST*(nrol.LoadUpchrg /100))
	  ENDIF
	ENDIF
	! LET X2=16 \ GOSUB L_15500: \ LET X2=11 \ GOSUB L_15000: ! TO COST THEN BACK - NETCOST/W CUT             
	cnvtu[0]=0;cnvtu[1]=nrol.UMCost;cnvtu[2]=2
	IF nrol.UMCost>0 AND nrol.numout LET CNVTA=(NETCOST/nrol.numout) ELSE  LET CNVTA=NETCOST
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	cnvtu[0]=nrol.UMCost;cnvtu[1]=0;cnvtu[2]=6
	IF nrol.UMCost>0 AND nROL.NUMOUT LET CNVTA=x3*nRol.NumOut ELSE  LET CNVTA=x3
	Netcost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	If roh.OrdType=37  ! "EVAP Ship - NO Price - any order in here
		If Not(Credit) Or (Credit And roh.ShipType=16)
			Let nrol.UnitPrice=0;nrol.NetPrice=0;nrol.CutChrg=0
			Let nrol.LineDisc=0;nrol.LineDiscPct=0;nrol.UpChrg=0
		Endif
	Endif
	If roh.OrdType=36 ! "EVAP Billing - NO Cost - Any type order
		If Not(Credit) Or (Credit And roh.ShipType=16)
			Let nrol.UnitCost=0;nrol.CostOrigin=0;nrol.RebtContract=0
			Let nrol.CutCost=0;nrol.ExtCutCost=0;nrol.ExtLoadShip=0;nrol.ExtLoadOrd=0
			nrol.LoadUpchrg=0;NetCost=0
		ENDIF
	Endif
	IF nROL.UMCutChrg=-3 LET nrol.ExtCutChg=nrol.CutChrg ELSE  LET nrol.ExtCutChg=FNR(nrol.CutChrg*nrol.QtyShip)
	IF nrol.UMCutCost=-3 LET nrol.ExtCutCost=nrol.CutCost ELSE  LET nrol.ExtCutCost=FNR(nrol.CutCost*nrol.QtyShip)
	LET nrol.ExtOrdAmt=FNR(nrol.QtyOrd*nRol.NetPrice)
	LET nrol.ExtLoadOrd=FNR(nrol.QtyOrd*NETCOST)
	IF roh.ordtype=4 OR roh.ordtype=15 ! "bill and hold
	  IF roh.ordtype=15 
		if roh.BOCTR=0 let nrol.CurrBillQty=nrol.QtyOrd Else let nrol.CurrBillQty=0
	  Endif
	  LET nrol.ExtShipAmt=FNR(nrol.CurrBillQty*nRol.NetPrice)
	  LET nrol.ExtLoadShip=FNR(nrol.CurrBillQty*NETCOST)
	ELSE
	  LET nrol.ExtShipAmt=FNR(nrol.QtyShip*nRol.NetPrice)
	  LET nrol.ExtLoadShip=FNR(nrol.QtyShip*NETCOST)
	ENDIF
	IF nrol.UMPrice=-2 ! lot
	  LET nrol.ExtOrdAmt=FNR(nRol.NetPrice)*SGN(nrol.QtyOrd)
	  IF roh.ordtype=4 OR roh.ordtype=15
		LET nrol.ExtShipAmt=FNR(SGN(nrol.CurrBillQty)*nRol.NetPrice)
	  ELSE
		LET nrol.ExtShipAmt=FNR(nRol.NetPrice)*SGN(nrol.QtyShip)
	  ENDIF
	ENDIF
	IF nrol.UMCost=-2 ! LOT
	  LET nrol.ExtLoadOrd=FNR(NETCOST*SGN(nrol.QtyOrd))
	  IF roh.ordtype=4 OR roh.ordtype=15
        LET nrol.ExtLoadShip=FNR(NETCOST*SGN(nrol.CurrBillQty))
	  ELSE
		LET nrol.ExtLoadShip=FNR(NETCOST*SGN(nrol.QtyShip))
	  ENDIF
	ENDIF
	nrol.ExtGLCost=FNR(nrol.QtyShip*nrol.UnitGLCost)
	nrol.ExtNetWgt=FNR(Abs((nrol.QtyShip*nrol.LbsUnit)/nrol.WgtFactor))
		if roh.OrdType=8 or roh.OrdType=16 ! cons/trans - no price/cost
			nrol.UnitCost=0;nrol.CostOrigin=0;nrol.RebtContract=0
			nrol.UnitPrice=0;nrol.CutChrg=0;nrol.CutCost=0
			nrol.LineDisc=0;nrol.ExtOrdAmt=0;nrol.ExtShipAmt=0
			nrol.LineDiscPct=0;nrol.ExtCutChg=0;nrol.ExtCutCost=0
			nrol.ExtLoadShip=0;nrol.ExtLoadOrd=0;nrol.NetPrice=0
			nrol.TaxAmt=0;nrol.LoadUpchrg=0;nrol.UpChrg=0
		Endif
		If p61$[46,46]="Y" and Credit and roh.shiptype=3 ! price fix - no cost
			nrol.UnitCost=0;nrol.CostOrigin=0;nrol.RebtContract=0
			nrol.CutCost=0;nrol.ExtCutCost=0;nrol.ExtLoadShip=0;nrol.ExtLoadOrd=0
			nrol.LoadUpchrg=0
		Endif
		
  else
    include "src/callsuberr.inc"
 end try
end sub ! DoLineExtens
! 
!--------------------------------------------------------------------
Sub GetNetPrcCost()
! get data for netprice or netcost/send it back
  Try
	Dim X$[20],NSFKey$[60]
	dim holdpswd$[12,16]
	Dim SUM$[4],PUM$[4],CUM$[4]
	Dim 1%,CNVTU[2],FLAG[9],X1[9]
	Dim 1%,NewLn,HFlg[16],HFlag[16],Credit
	Dim 2%,X2[9],NumLines,ShipDate,JDate[5]
	Dim 3%,CNVTA,AMOUNT,X3[9],V3[99]
	Dim 3%,WHBLD[2],S9[20]

	Dim NRol. as rolnew ! store new sent data
	! call dxsave(0,"tmp/olsv.txt!")
	Read #ctlc,3,188;ShipDate; ! for inv levels
	if debugdetail
		dmsg$="Start Calculate Price/Cost" \ Call updatelog(debug)
	Endif
	ReturnStatus=1
	Message$="OK"
	Call DXGet("ORDERID",tmp$)
	If tmp$="" goto CNPCDone:
	OrderNo=tmp$
	If OrderNo<1 or OrderNo>999999 or Fra(OrderNo)
		ReturnStatus=0
		Message$="ORDER NUMBER INVALID"
		Goto CNPCDone
	Endif
	OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
	e$=""
	If OHR<=0 ! not found
		ReturnStatus=99
		Message$="ORDER WAS NOT FOUND"
		goto CNPCDone
	Else
		Credit=0 \ if rot.Status=22 let Credit=1 ! instead of roh.status check

	Endif
		E$="" ! clear for this loop
		OLR=0;NewLn=0;KITCHG=0;kit=0
		Clear nrol.
		Clear pr.
		Clear pw.
		Clear etr.
		Clear nstk.
		Call DXGet("LN",tmp$) ! +Str$(X1),tmp$)
		nrol.LineNum=tmp$ ! line # (zero on new lines)
		LineNo=nrol.LineNum
		if nrol.linenum ! get prev data
			rolkey$=" ",rolkey$
			rolkey$[1,6]=OrderNo Using "######"
			rolkey$[7,9]=nrol.linenum using "###"
			rolkey$[11]="" ! cut to length (space @ 10)
			OLR=filegetrolz(e$,OLC,"=",1,rolkey$,rol.)
			clear e$
			if olr<=0 ! what do we do if not found?
				Returnstatus=0
				message$="ORDER LINE NOT FOUND"
				GOTO CNPCDone
			Endif
			If OLR>0
				if rol.NStkItem=1 and rol.LineType<>3
					NSR=rol.PDRecNum
					Read record #NSC,NSR,0;nstk.
					PRR=0;PWR=0
				Endif
				If Not(rol.NStkItem) ! get prod & whse
					PRR=rol.PDRecNum
					Read record #PRC,PRR,0;pr.;
				Endif ! stk item
			Endif ! existing line
		Else ! no line
			Returnstatus=0
			message$="ORDER LINE NOT SENT"
			GOTO CNPCDone
		Endif
		If OLR>0 Read Record #OLC,OLR,0;nrol.; ! read with prev values
	Call DXGet("LTYPE",tmp$) ! +Str$(X1),tmp$) ! line type (stk,nstk,msg,del)
		tmp$=UCase$(tmp$)
		ZLine=0;NonStk=0;Stk=0;Delline=0
		if tmp$="MSG" let ZLine=1;NonStk=1
		If tmp$[1,4]="NSTK" let NonStk=1
		if tmp$[1,3]="STK" let Stk=1
		if tmp$[1,4]="CLSD" Let Stk=1 ! goto CNPCDone ! yes - allow it(no Updates)
		if ACTION$="NSBUILDPROD" and olr>0 and not(rol.NStkItem) let stk=1;Nonstk=0 ! web could send as NSTK! NO,NO
		CutLine=0
		if p9$[20,20]="F"
			If tmp$="INV" and not(nonstk) let cutline=1;Stk=1 ! only cut stock lines
			if tmp$="FIN" and not(nonstk) let cutline=2;Stk=1 ! only cut stock lines
		Endif
		nrol.Status=11;Credit=0
		if ros.Status=32 let nrol.Status=12;Credit=1 ! determine order/credit?
		nrol.OrdNum=OrderNo
		Call DXGet("UPRICE",tmp$) ! +Str$(X1),tmp$)
		V3[1]=tmp$ ! ALSO ON CUTS - PARENT or CUT
		if v3[1]<0
			returnstatus=0
			message$="NO NEGATIVE PRICE"
			goto CNPCDone
		endif
		If V3[1]>9999999
			returnstatus=0
			message$="Price is out of range"
			goto CNPCDone
		endif
		If V3[1] and rol.UMPrice>0 and (rol.LineType=1 or rol.LineType=2)
			call DXGet("PARCUTP",tmp$) ! if Cut - use as is (SCREEN SHOWS CUT!)
			if UCase$(Trim$(tmp$))="P"
				if rol.numout>0 let v3[1]=FNC(v3[1]/rol.numout)
			Endif
		Endif
		Call DXGet("UCOST",tmp$) ! +Str$(X1),tmp$)
		V3[2]=tmp$ ! ALSO ON CUTS - PARENT OR CUT
		if v3[2]<0
			returnstatus=0
			message$="NO NEGATIVE COST"
			goto CNPCDone
		endif
		If V3[2]>9999999
			returnstatus=0
			message$="Cost is out of range"
			goto CNPCDone
		endif
		if v3[2] and rol.umcost>0 and (rol.LineType=1 or rol.LineType=2)
			call DXget("PARCUTC",tmp$) ! if Cut - use as is (SCREEN SHOWS CUT!)
			if UCase$(Trim$(tmp$))="P"
				if rol.numout>0 let v3[2]=FNC(v3[2]/rol.numout)
			Endif
		Endif
		Call DXGet("LDISC",tmp$) ! +Str$(X1),tmp$)
		nrol.LineDiscPct=tmp$
		call DXGet("QTYORD",tmp$) ! +Str$(X1),tmp$)
		if RTrim$(tmp$)<>""
			let V3[3]=tmp$
		Else ! calc it from line
			cnvtu[0]=0;cnvtu[1]=rol.umsell;cnvtu[2]=1
			Cnvta=rol.QtyOrd \ if rol.numout>0 let cnvta=rol.qtyord*rol.numout
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			let v3[3]=X3
		Endif
		! at start no negative
		x1=roh.ordtype
		if v3[3]<0 and (credit or (x1=4 or x1=7 or x1=8 or x1=15 or x1=16 or x1=19 or x1=24))
			returnstatus=0
			message$="Can not order negative quantity"
			goto CNPCDone
		Endif
		If Abs(V3[3])>9999999
			returnstatus=0
			message$="Order Quantity is out of range"
			goto CNPCDone
		Endif
		Call DXGet("QTYBO",tmp$) ! +Str$(X1),tmp$)
		If RTrim$(tmp$)<>""
			Let V3[4]=tmp$
		Else ! calc it from line
			cnvtu[0]=0;cnvtu[1]=rol.umsell;cnvtu[2]=1
			Cnvta=rol.QtyBO \ if rol.numout>0 let cnvta=rol.qtybo*rol.numout
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			let v3[4]=X3
		Endif
		If Abs(V3[4])>9999999
			returnstatus=0
			message$="Back Order Quantity is out of range"
			goto CNPCDone
		Endif
		Call DXGet("QTYSHIP",tmp$) ! +Str$(X1),tmp$)
		if RTrim$(tmp$)<>""
			Let V3[5]=tmp$
		Else ! calc it from line
			cnvtu[0]=0;cnvtu[1]=rol.umsell;cnvtu[2]=1
			Cnvta=rol.QtyShip \ if rol.numout>0 let cnvta=rol.qtyship*rol.numout
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			let v3[5]=X3
		Endif
		if v3[3]=0 and v3[5] ! 0 ordered passed - and shipped qty
			let v3[3]=v3[5]+v3[4]
		Endif ! WE NEED ORDERED!!!
		If V3[3]>0 ! new never neg bo and ot4/15 can do neg release
		  if V3[4]<0 or (roh.ordtype<>4 and roh.ordtype<>15 and V3[5]<0)
			returnstatus=0
			message$="Can not have negative BO/Ship quantities!"
			goto CNPCDone
		  Endif
		  IF V3[5]<0 and (roh.ordtype=4 or roh.ordtype=15)
			If nrol.PrevQtyShip<=0 or ABS(V3[5])>nrol.PrevQtyShip
				returnstatus=0
				message$="Negative Ship quantity is invalid!"
				goto CNPCDone
			Endif
		  Endif
		Endif
		if v3[3]<0 and (V3[4]>0 or V3[5]>0)
			returnstatus=0
			message$="Can not have positive Bo/Ship quantities!"
			goto CNPCDone
		Endif
		!if v3[5]<0 and V3[5]<>v3[3] let v3[3]=v3[5] ! no ship more than order
		if v3[3]<0 ! always ship ordered on negative
			v3[5]=v3[3];v3[4]=0
		Endif
		If Abs(V3[5])>9999999
			returnstatus=0
			message$="Ship Quantity is out of range"
			goto CNPCDone
		Endif
		if roh.ordtype=4 ! order type 4 - needs BILLQTY
			call dxget("CURRBILL",tmp$)
			if rtrim$(tmp$)<>"" ! sent it - otherwise ignore
				V3[10]=tmp$
				if v3[3]<0 and v3[10]>0 ! neg line - pos bill? NO
					returnstatus=0
					message$="Can not have positive Bill quantities!"
					goto CNPCDone
				Endif
				if v3[10]<0 ! neg bill allowed
					if nrol.PrevQtyBill<=0 or ABS(v3[10])>nrol.PrevQtyBill
						returnstatus=0
						message$="Negative Bill quantity is invalid!"
						goto CNPCDone
					Endif
				Endif
			Else ! calc from existing line
				cnvtu[0]=0;cnvtu[1]=rol.umsell;cnvtu[2]=1
				Cnvta=rol.CurrBillQty \ if rol.numout>0 let cnvta=rol.CurrBillQty*rol.numout
				X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				let v3[10]=X3
			Endif ! sent data
			! ON PM Native - it allows overbill with just a prompt
			! check it below (when base)
		Endif ! bill qty - OT4
		! if roh.ordtype=15 let nrol.CurrRelQty=v3[5] ! is relqty
		Call DXGet("PUPCHG",tmp$) ! +Str$(X1),tmp$)
		V3[6]=tmp$
		Call DXGet("PUPTYPE",tmp$) ! +sTR$(X1),tmp$)
		let x$=tmp$
		if x$="$" ! $ is <0  percent is >=0
			let nrol.UpChrg=0-V3[6] ! may need convert
		Else
			let nrol.UpChrg=V3[6]
		Endif
		Call DXGet("UMSELL",tmp$) ! +Str$(X1),tmp$)
		! call programdump("/tmp/ollog10!","")
		!If tmp$[1,1]>"9" ! sent text?
			R=getumrec(e$,CCC,tmp$,IntCo,PR.)
			If R<>0 let tmp$=Str$(R)
		!Endif
		x2=tmp$
		if x2<0 ! no system UM for Qty
			returnstatus=0
			message$="INVALID U/M - SELL"
			goto CNPCdone
		Endif
		if not(nonstk) ! chk u/m
			Flag=ChkPrdUM(e$,X2,IntCo,Pr.)
			if flag=0 ! let x2=pr.UMSellDefault ! unrem / rem below to just change
				ReturnStatus=0
				Message$="INVALID U/M - SELL"
				goto CNPCDone
			Endif
		Endif
		let nrol.UMSell=x2 ! tmp$
		if not(nonStk)
			X3=UMtoFactor(nrol.UMSell)
			rol.SellFactor=X3;nrol.SellFactor=x3
		Endif
		Call DXGet("UMPRICE",tmp$) ! +Str$(x1),tmp$)
		! call programdump("/tmp/ollog11!","")
		!If tmp$[1,1]>"9" ! sent text?
			R=getumrec(e$,CCC,tmp$,IntCo,PR.)
			If R<>0 let tmp$=Str$(R)
		!Endif
		x2=tmp$
		if not(nonstk) ! chk u/m
			Flag=ChkPrdUM(e$,X2,IntCo,Pr.)
			if flag=0 ! let x2=pr.UMPriceDefault ! unrem / rem below to just change
				ReturnStatus=0
				Message$="INVALID U/M - PRICE"
				goto CNPCDone
			Endif
		Endif
		nrol.umprice=x2 ! tmp$
			if not(nonStk)
				X3=UMtoFactor(nrol.umprice)
				rol.PriceFactor=X3;nrol.PriceFactor=x3
			Endif
		Call DXGet("UMCOST",tmp$) ! +Str$(X1),tmp$)
		! call programdump("/tmp/ollog12!","")
		!If tmp$[1,1]>"9" ! sent text?
			R=getumrec(e$,CCC,tmp$,IntCo,PR.)
			If R<>0 let tmp$=Str$(R)
		!Endif
		x2=tmp$
		if not(nonstk) ! chk u/m
			Flag=ChkPrdUM(e$,X2,IntCo,Pr.)
			if flag=0 ! let x2=pr.UMCostDefault ! unrem / rem below to just change
				ReturnStatus=0
				Message$="INVALID U/M - COST"
				goto CNPCDone
			Endif
		Endif
		nrol.UMCost=x2 ! tmp$
			if not(nonStk)
				X3=UMtoFactor(nrol.UMCost)
				rol.CostFactor=X3;nrol.CostFactor=x3
			EndiF
		Call dxget("CUPCHG",tmp$) ! +Str$(X1),tmp$)
		V3[8]=tmp$
		call dxget("CUPTYPE",tmp$) ! +Str$(X1),tmp$)
		X$=tmp$
		if x$="$" ! $ is <0  % is >=0
			nrol.LoadUpchrg=0-V3[8]
		Else
			nrol.LoadUpchrg=V3[8]
		Endif
			! as setprtorol uses rol. needs a setup to new values
			rol.UMBase=nrol.UMBase
			rol.UMSell=nrol.UMSell
			rol.UMCost=nrol.UMCost
			rol.UMPrice=nrol.UMPrice
			rol.UMPurch=nrol.UMPurch
			rol.SellFactor=nrol.SellFactor
			rol.PriceFactor=nrol.PriceFactor
			rol.CostFactor=nrol.CostFactor
			rol.PurchFactor=nrol.PurchFactor
			rol.CubeFactor=nrol.CubeFactor
			rol.WgtFactor=nrol.WgtFactor
		! so nrol. has new, rol. has orig
		Call setprtorol() ! set to rol. factors
		! convert sent to base as sent in display um
		CNVTU[0]=nrol.UMPrice;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
		cnvta=v3[1] \ if nrol.UMPrice>0 and nrol.NumOut>0 let cnvta=v3[1]*nrol.numout
		nrol.UnitPrice=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		CNVTU[0]=nrol.UMPrice;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
		!cnvta=v3[7] \ if nrol.UMPrice>0 and nrol.NumOut>0 let cnvta=v3[7]*nrol.numout
		!nrol.NetPrice=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if nrol.UpChrg<0 ! $ amount
			CNVTU[0]=nrol.UMPrice;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
			cnvta=V3[6] ! still +
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			let nrol.UpChrg=0-x3
		Endif
		CNVTU[0]=nrol.UMCost;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
		cnvta=V3[2]  \ if nrol.UMCost>0 and nrol.NumOut>0 let cnvta=v3[2]*nrol.numout
		nrol.UnitCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if nrol.LoadUpchrg<0 ! it's a $ up
			CNVTU[0]=nrol.UMCost;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
			cnvta=v3[8]
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			nrol.LoadUpchrg=0-X3
		endif

		CNVTU[0]=nrol.UMSell;Cnvtu[1]=0;Cnvtu[2]=1
		cnvta=V3[3] \ IF nrol.NumOut>0 let CNVTA=v3[3]/nrol.NumOut
		nrol.QtyOrd=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		cnvta=V3[4] \ IF nrol.NumOut>0 let CNVTA=v3[4]/nrol.NumOut
		nrol.QtyBO=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		cnvta=V3[5]  \ IF nrol.NumOut>0 let CNVTA=v3[5]/nrol.NumOut
		nrol.QtyShip=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		If roh.ordtype=4 ! Curr Billqty
			cnvta=V3[10] \ if nrol.NumOut>0 let cnvta=v3[10]/nrol.numout
			nrol.CurrBillQty=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		Endif
		if roh.ordtype=4 or roh.ordtype=15
			nrol.CurrRelQty=nrol.qtyship ! release is entered as QtyShip
		Endif
		call dolineextens()
		if roh.OrdType=8 or roh.OrdType=16 ! cons/trans - no price/cost
			nrol.UnitCost=0;nrol.CostOrigin=0;nrol.RebtContract=0
			nrol.UnitPrice=0;nrol.CutChrg=0;nrol.CutCost=0
			nrol.LineDisc=0;nrol.ExtOrdAmt=0;nrol.ExtShipAmt=0
			nrol.LineDiscPct=0;nrol.ExtCutChg=0;nrol.ExtCutCost=0
			nrol.ExtLoadShip=0;nrol.ExtLoadOrd=0;nrol.NetPrice=0
			nrol.TaxAmt=0;nrol.LoadUpchrg=0;nrol.UpChrg=0
		Endif
		If p61$[46,46]="Y" and Credit and roh.shiptype=3 ! price fix - no cost
			nrol.UnitCost=0;nrol.CostOrigin=0;nrol.RebtContract=0
			nrol.CutCost=0;nrol.ExtCutCost=0;nrol.ExtLoadShip=0;nrol.ExtLoadOrd=0
			nrol.LoadUpchrg=0
		Endif
		! ok - now send back
		SUM$=xunit$(NROL.UMSell,ccc) ! u/m
		PUM$=xunit$(NROL.UMPrice,ccc) ! u/m
		CUM$=xunit$(NROL.UMCost,ccc) ! u/m
		Clear List$[]
		If NTPRICE ! net price
			List$[0]=bsdel$,"NETPRICE",fdel$
			WebStr$="UnitPrice",fdel$,"PriceUpchrg",fdel$
			WebStr$=WebStr$,"PriceUpType",fdel$
			WebStr$=WebStr$,"NetPrice",fdel$,"PriceUM",fdel$,"PriceUMID",fdel$
			WebStr$=WebStr$,"ExtPrice",fdel$,"GP%",fdel$
			List$[1]=webstr$
					
			cnvtu[0]=0;cnvtu[1]=nrol.UMPrice;cnvtu[2]=2
			Cnvta=nrol.UnitPrice \ if nrol.umprice>0 and nrol.numout>0 let cnvta=nrol.unitprice/nrol.numout
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			WebStr$=LTrim$(X3 Using PMask$),fdel$ ! Unit price
			! send upcharge as amount & type
			tmp$="%" \ if nrol.UpChrg<0 let tmp$="$"
			Let X3=nrol.UpChrg
			If tmp$="$" ! need convert to price um
				cnvtu[0]=0;cnvtu[1]=nrol.UMPrice;cnvtu[2]=2
				Cnvta=ABS(X3)
				X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			Endif
			WebStr$=WebStr$,Ltrim$(X3 Using PMask$),fdel$,tmp$,fdel$ ! upchrg & type
			cnvtu[0]=0;cnvtu[1]=nrol.UMPrice;cnvtu[2]=2
			Cnvta=nrol.NetPrice \ if nrol.umprice>0 and nrol.numout>0 let cnvta=nrol.NetPrice/nrol.numout
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! net price
			WebStr$=WebStr$,RTrim$(PUM$),fdel$,Str$(nrol.UMPrice),fdel$ ! price um & id
			Let X3=nrol.ExtShipAmt
			WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! net price exten
			IF nrol.UMCutCost=-3 AND nrol.QtyOrd LET CHBASE=(nrol.CutCost/nrol.QtyOrd) ELSE  LET CHBASE=nrol.CutCost
			X3[4]=nrol.UnitCost+CHBase
			X3[3]=X3[4]
			IF nrol.LoadUpchrg ! has cost up
				IF nrol.LoadUpchrg<0 ! $ amount
					X3[3]=x3[4]+Abs(nrol.LoadUpchrg)
				Else ! percent
					X3[3]=X3[4]+(X3[4]*(nrol.LoadUpchrg/100))
				Endif
			Endif ! X3[3]=NETCOST
			NETCOST=X3[3]
!if ucase$(userid$[1,3])="TXC" stop
			x3=0
			if nrol.NetPrice ! NEEDS A PRICE
				X3=FNR(((nrol.NetPrice-x3[3])/nrol.NetPrice)*100)
			else 
				if X3[3] then let x3=-999999.99
			Endif
			WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! GP
			List$[2]=webstr$
			Row=3
		Endif
		If NTCOST ! net cost
			List$[0]=bsdel$,"NETCOST",fdel$
			WebStr$="UnitCost",fdel$,"CostSecurity",fdel$
			WebStr$=WebStr$,"CostUM",fdel$,"CostUMID",fdel$,"CostUpchrg",fdel$
			WebStr$=WebStr$,"CostUpType",fdel$,"ExtCost",fdel$
			WebStr$=WebStr$,"GP%",fdel$,"NETCOST",fdel$ !
			List$[1]=webstr$
			cnvtu[0]=0;cnvtu[1]=nrol.UMCost;cnvtu[2]=2
			Cnvta=nrol.UnitCost \ if nrol.UMCost>0 and nrol.numout>0 let cnvta=nrol.UnitCost/nrol.numout
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			WebStr$=LTrim$(X3 Using PMask$),fdel$ ! unit cost
			WebStr$=WebStr$,Str$(Cost_Lev[1]),fdel$ ! load cost security
			WebStr$=WebStr$,RTrim$(CUM$),fdel$,Str$(nrol.UMCost),fdel$ ! Cost um & id
			! send upcharge as amount & type
			tmp$="%" \ if nrol.LoadUpchrg<0 let tmp$="$"
			Let X3=nrol.LoadUpchrg
			If tmp$="$" ! need convert to cost um
				cnvtu[0]=0;cnvtu[1]=nrol.UMCost;cnvtu[2]=2
				Cnvta=ABS(X3)
				X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			Endif
			WebStr$=WebStr$,Ltrim$(X3 Using PMask$),fdel$,tmp$,fdel$ ! upchrg & type
			IF nrol.UMCutCost=-3 AND nrol.QtyOrd LET CHBASE=(nrol.CutCost/nrol.QtyOrd) ELSE  LET CHBASE=nrol.CutCost
			X3[4]=nrol.UnitCost+CHBase
			X3[3]=X3[4]
			IF nrol.LoadUpchrg ! has cost up
				IF nrol.LoadUpchrg<0 ! $ amount
					X3[3]=x3[4]+Abs(nrol.LoadUpchrg)
				Else ! percent
					X3[3]=X3[4]+(X3[4]*(nrol.LoadUpchrg/100))
				Endif
			Endif ! X3[3]=NETCOST
			NETCOST=X3[3]
			X3=nrol.ExtLoadShip ! FNR(nrol.QtyShip*X3[3]) ! ext net cost
			WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! net cost exten
!if ucase$(userid$[1,3])="TXC" stop
			x3=0
			if nrol.NetPrice ! NEEDS A PRICE
				X3=FNR(((nrol.NetPrice-x3[3])/nrol.NetPrice)*100)
			else 
				if x3[3] then let x3=-999999.99
			Endif
			WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! GP
			cnvtu[0]=0;cnvtu[1]=nrol.umcost;cnvtu[2]=2
			Cnvta=NETCOST \ if nrol.UMCost>0 and nrol.numout>0 let cnvta=NETCOST/nrol.numout
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! net cost
			List$[2]=webstr$
			Row=3
		Endif
	list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])
	CNPCDone: ! finished 
	if returnstatus=1 let message$="OK" ! set if no other problems
	if debugdetail
		dmsg$="Get Net Price/Cost "+Str$(rol.OrdNum)+"-"+Str$(rol.LineNum)+" "+rol.ProdCode$+Message$ \ Call updatelog(debug)
	Endif
	
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	
  else
    include "src/callsuberr.inc"
 end try
end sub ! GetNetPrcCost
! 
!--------------------------------------------------------------------
Sub SProdDtl()
! send details for list entry
  Try
	Dim KPR$[60],KPW$[60],kcm$[40],k1$[50]
	Dim SUM$[4],PUM$[4],CUM$[4]
	Dim 1%,Cnvtu[2],Flag,E,X[9],Pram[5]
	Dim 1%,FCDays,Zline,NonStk
	Dim 2%,X2[9],TaxBack,JDate[5],FDate,ShipDate
	Dim 3%,CNVTA,Amount,x3[9],FutCost,LPR
	Dim 3%,MSHQty,MBOQty,s9[20]
	Clear rol. ! as we will use those vars
	! call dxsave(0,"tmp/ollein.txt!")
	Call DXGet("ORDERID",tmp$)
	if tmp$="" 
		let message$="ORDER # MISSING"
		Let ReturnStatus=0
		Goto SPEDone:
	Endif
	OrderNo=tmp$
	If OrderNo>0 and OrderNo<999999 and Not(Fra(OrderNo))
		OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
		e$=""
		If OHR<=0 ! no order found
			Let message$="ORDER # NOT FOUND"
			Let ReturnStatus=99
			Goto SPEDone:
		Endif
	Endif
	if roh.ordtype=15 and roh.boctr<>0 ! no add once accepted!
		Returnstatus=0
		Message$="Invoice has been accepted. No new lines allowed"
		Goto SPEDone:
	Endif
	if roh.ordtype=19 and roh.BOCtr<>0 and roh.Ot19Comp=0 ! FINAL - NO ADD!
		Returnstatus=0
		Message$="Final Bill of Order. No new lines allowed"
		Goto SPEDone:
	Endif
	if roh.ordtype=20 ! freight invoice
		Returnstatus=0
		Message$="Order Type=Freight Invoice. No lines are allowed"
		Goto SPEDone:
	Endif
	Call GetCust()
	Credit=0 \ if ros.status=32 let credit=1
	! set list header
	Clear List$[]
	clear slist$[]
	clear tlist$[]
	List$[0]=bsdel$,"PRODUCTDETAIL",fdel$
	WebStr$="ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$,"Commodity",fdel$
	WebStr$=WebStr$,"WHAvail",fdel$,"WHAvlUM",fdel$,"WHAvlUMID",fdel$
	Webstr$=webstr$,"WHSE",fdel$,"QtyUM",fdel$,"QtyUMID",fdel$
	WebStr$=WebStr$,"LTYPE",fdel$ ! include type? ----- ADD WHEN READY  -- ready now
	! added 05/28 - per web send all flags & factors NOW
	webstr$=webstr$,"QTYUMFACT",fdel$,"AvlUmFactor",fdel$
	webstr$=webstr$,"CHKBroken",fdel$,"MBFlag",fdel$
	WebStr$=WebStr$,"SerialNo",fdel$,"CatchWeight",fdel$
	WebStr$=WebStr$,"LotControl",fdel$,"RollLB",fdel$
	WebStr$=WebStr$,"DNReord",fdel$,"BrokenUM",fdel$
	WebStr$=WebStr$,"BrokenUMID",fdel$,"BrokenUMFact",fdel$
	webstr$=webstr$,"STKUPDT",fdel$,"DNRFail",fdel$
	webstr$=webstr$,"CMP",fdel$,"SUB",fdel$,"SPR",fdel$,"ASKLP",fdel$
	List$[1]=webstr$
	row=2
	
	Call DXGet("PRODID",tmp$)
	tmp$=RTrim$(tmp$)
	If tmp$="" Goto SPEDone: ! NEED A PRODUCT!
	Let PROD$=UCase$(tmp$)+Blank$
	If prod$[1,3]="+  " OR PROD$[1,6]="ZNSTK "! it's nonstock
		prod$="Z ZZZZZZZZZZ"
	Endif ! will not have um or qty for messg or nonstk?
	tmp$=ChkAltItem$(e$,IntCo,Prod$,roh.CustNum)
	If tmp$<>"" If tmp$[1,2]<>"  " let prod$=tmp$ ! has alt item
	Let kpr$=Prod$;NonStk=0
	Let kpr$[13]="";e=0 ! no lock
	If prod$[1,3]="Z  " let Nonstk=1;ZLine=1
	If Prod$[1,3]="Z Z" let nonstk=1
	If not(ZLine) ! still get prod for nonstk
	 PRR = filegetprod(e$,PRC,"=",1,KPr$,PR.,e)
	 clear e$
	 If PRR<=0 ! not found
		Let MessagE$=" PRODUCT NOT FOUND" ! +Prod$
		Let ReturnStatus=0
		if debugdetail
			dmsg$=prod$+e$ \ Call updatelog(debug)
		Endif
		Goto SPEDone
	 Endif
	Endif
	! now get whse
	Let kpw$=" ",kpw$;e=0
	kpw$=prod$+roh.Wh Using "##"
	if roh.ordtype=7 let kpw$=prod$+roh.ConsWh Using "##"
	If Not(NonStk)
		rol.UpdtStk=1 ! default=Y
		rol.ComdtyCode$=pr.ComdtyCode$+Blank$
		if roh.ordtype=8 or roh.ordtype=16 ! see if to whse exists
			If Roh.ConsWh>0 and roh.conswh<100
				Let TPWKey$=" ",tpwKey$
				TPWkey$[1,12]=prod$[1,12]+Blank$
				TPWKey$[13]=ROH.ConsWh Using "##"
				call chktowhse(TPWKey$,pr.PrimVend)
			Endif
		Endif
		PWR=filegetprodwhse(e$,PWC,"=",1,KPw$,PW.,e)
		clear e$
		if pwr<0 ! NOT FOUND
			clear pw.
			If P61$[59,59]="Y" or (Credit and (roh.ordtype=7 or roh.ordtype=8)) ! not allowed new prodwhse
				Let MessagE$="Product "+Prod$+"Not Available In this Warehouse"
				Let ReturnStatus=0
				if debugdetail
					dmsg$=e$+" Sysflag 61-59,59 Y "+Str$(roh.wh) \ Call updatelog(debug)
				Endif
				Goto SPEDone
			Endif
		Endif ! of whse not found
	Else ! is nonstk
		Clear pw.
		rol.UpdtStk=0 ! can't happen!
	Endif
	rol.prodcode$=Prod$
	! check for lastprice record - 0=found, 1=not found and reads clp.
	if p60$[30,30]="Y" let HasLPflag=GetAskLP() ! for pricing
	AskLPFlag=0 ! clear it
	If P61$[25,25]="P"  let AskLPflag=GetAskLP()
	! Needs a Prodgroup check (in case single entry!)
	If PW.ProdGrp>0 ! has a group
		Pram[0]=ROH.OrdType !  \ if TScan=2 Let Pram[0]=0-OType
		Pram[1]=PW.ProdGrp
		Pram[5]=0 ! file not opened
		![0]=Order or (-)PO Type
		! [1]=Product Group
		! [2]=Allow on Ord/PO (1=y, 0=N)
		! [3]=Update Stock (1=y, 0=N)
		! [4]=On Price List (0/1)
		! [5]=Channel of 2/ProdGrp#
		Call ProdGroup(e$,intco,Pram[])
		If Pram[2]=0  ! not allowed on OType
			MessagE$="Product "+Prod$+"Not Allowed on this Order Type!"
			returnstatus=0
			if debugdetail
				dmsg$=E$+" OT "+Str$(ROH.OrdType)+" PG "+Str$(PW.ProdGrp) \ Call updatelog(debug)
			Endif
			Goto SPEDone
		Endif
		rol.UpdtStk=Pram[3] ! update Stock
	Endif
	If not(nonStk) and not(credit) ! now a restricted item check
		! set up 
		clear x[]
		clear s9[]
		clear pram[]
		x[1]=PRC;X[2]=CUC ! prod,cust chan
		S9[1]=prr;s9[2]=CUR ! prod,cust records
		pram[2]=roh.wh ! whse to check
		if roh.ordtype=7 let pram[2]=roh.ConsWh ! use consignment?
		Clear tmp2$
		call chkrprod(e$,intco,X[],S9[],PRAM[],Tmp2$)
		if pram[0]=0  ! 0=restrict, <>0=ok
			message$=tmp2$;returnstatus=0
			if debugdetail
				dmsg$=E$ \ Call updatelog(debug)
			Endif
			Goto SPEDone
		Endif
	Endif
	! checking done - now loadit
	rol.UMSell=PR.UMSellDefault
	if Source=251 and pr.UMPrdtnDefault<>0 let rol.UMSell=pr.UMPrdtnDefault ! POS UM
	if p60$[30,30]="Y" and HasLPFlag=0 ! found last price
		if clp.UMSell<>0 let rol.umsell=clp.umsell ! clp. is read in asklpflag()
		IF P61$[25,25]<>"P" LET AskLPFlag=0 ! do not ask
	Endif
	! as call prodgroup changes updtstk flag - redo it
	IF CREDIT<>0 
		if roh.ShipType=3 LET rol.UpdtStk=0
		if roh.ShipType=7 LET rol.UpdtStk=0
		if roh.ShipType=2
			if p61$[131,131]="N" 
				let rol.Updtstk=0
			else
				if p61$[131,131]="Y" and not(nonstk) let rol.Updtstk=1 
				! check commcode further down
			endif
		endif
	endif
	IF roh.OrdType=16 and ROH.XferAuth=0 let rol.UpdtStk=0 ! whxfer not auth
	if roh.ordtype=15 or roh.ordtype=4 let Cust.BoSAllowedFlag=1 ! will always allow bo's
	IF roh.ordtype=2 or roh.ordtype=5 let rol.UpdtStk=0
	if roh.ordtype=3 and p60$[22,22]<>"Y" LET rol.UpdtStk=0 ! indir no stk
	if custom_customer$="OMAHA"
        ! default ord type 38 to update stock=N cct176559/task10467
		if roh.ordtype=38 let rol.updtstk=0 
	endif
	tmp$=rol.ComdtyCode$
	if tmp$="LABR" OR tmp$="TIME" OR tmp$="MACH" LET rol.UpdtStk=0 ! comm's no stk
	rol.whse=roh.wh
	! quick avail check! If we're here - it's not cutting
	x2[9]=rol.whse \ if roh.ordtype=7 let x2[9]=roh.ConsWh
	If RTrim$(rol.ProdCode$)<>""
		X3[1]=getwhavail(e$,intco,PWC,rol.ProdCode$,X2[9])
	Else
		x3[1]=0 
	Endif
	DNRFail=0
	! note was dnr AND - causes issue - change to IF
	if not(credit) ! credits not DNR check
		if pw.DNReordFlg=1 If ((ROL.UpdtStk and x3[1]<=0) or (Not(ROL.UpdtStk))) ! dnr and no avail
			!MessagE$="Product "+Prod$+"is a Do Not Reorder!"
			!if debugdetail
			!	dmsg$=E$+" DNR "+Str$(pw.DNReordFlg)+" AVL "+Str$(x3[1]) \ Call updatelog(debug)
			!Endif
			!Goto SPEDone
			DNRFail=1
		Endif
	Endif ! credit no dnr chk
	SUM$=xunit$(ROL.UMSell,ccc) ! u/m
	rol.linetype=0 \ if zline let rol.linetype=3
	rol.NStkItem=nonstk
	If rol.LineType=3 ! ZLINE
		rol.umsell=0;rol.umprice=0;rol.umcost=0
		SUM$=blank$;PUM$=blank$;CUM$=blank$
	Endif
	tmp$=clrtxtc$(e$,PR.Desc1$) ! chk/clr control chars
	WebStr$=rol.ProdCode$,fdel$,RTrim$(tmp$),fdel$ ! prod code & desc 1
	tmp$=clrtxtc$(e$,PR.Desc2$) ! chk/clr control chars
	WebStr$=WebStr$,RTrim$(tmp$),fdel$,RTrim$(rol.ComdtyCode$),fdel$
	! whse available
	If rol.NStkItem or rol.LineType=3
		let X3[1]=0
	Endif
	Cnvtu[0]=0;Cnvtu[1]=rol.UMSell;Cnvtu[2]=1
	CNVTA=X3[1] \ IF ROL.NUMout>0 let cnvta=x3[1]*rol.numout
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$,RTrim$(SUM$),fdel$ ! whse avail / um
	WebStr$=WebStr$,Str$(ROL.UMSell),fdel$ ! avl um id
	tmp$=Str$(roh.Wh) \	if roh.ordtype=7 let tmp$=Str$(roh.ConsWh)
	Webstr$=webstr$,tmp$,fdel$,RTrim$(SUM$),fdel$
	WebStr$=WebStr$,Str$(ROL.UMSell),fdel$
	tmp$="STK";X2=rol.LineType
	if rol.NStkItem LET TMP$="NSTK"
	if rol.NStkItem AND X2=3 LET TMP$="MSG"
	IF X2=1 let tmp$="INV"
	If X2=2 LET TMP$="FIN"
	! ot 19 - if header flag=0 or prevship=ordered - it is closed
	if roh.ordtype=19 and Rol.QtyOrd<>0 and rol.PrevQtyShip=rol.QtyOrd let tmp$="CLSD" ! ALL SHIPPED-PARTIAL
	if roh.ordtype=19 and roh.BOCTR<>0 and roh.ot19comp=0 let tmp$="CLSD" ! FINAL
	WebStr$=WebStr$,RTRIM$(TMP$),FDEL$ ! line type
	X3=UMtoFactor(ROL.UMSell)
	Webstr$=Webstr$,Str$(X3),fdel$,Str$(X3),fdel$ ! qty&avail factor
	
	if rol.NStkItem ! make sure flags correct
		pw.ChkBrknQty$="N";pr.MBFlg$="B"
		pr.SerNoTrack$="N";pr.CatchwgtItem$="N"
		pr.LotCtrl$="N";pr.RollLbItem$="N"
		! pw.DNReordFlg=1
	Endif
	if pw.ChkBrknQty$<>"N" let pw.ChkBrknQty$="Y" ! Y is default
	if roh.ordtype=19 and roh.BOCTR<>0 and roh.ot19comp=0 let pw.ChkBrknQty$="N" ! closed
	WebStr$=Webstr$,pw.ChkBrknQty$,fdel$,pr.MBFlg$,fdel$ ! chk brkn, make/buy
	if rol.UpdtStk=0 let pr.LotCtrl$="N" ! pr.SerNoTrack$="N";! can't do if no stk
	if roh.ordtype=19 and roh.BOCTR<>0 and roh.ot19comp=0 let pr.SerNoTrack$="N" ! closed
	WebStr$=WebStr$,pr.SerNoTrack$,fdel$,pr.CatchwgtItem$,fdel$ ! s/n, catchwgt
	WebStr$=WebStr$,pr.LotCtrl$,fdel$,pr.RollLbItem$,fdel$ ! lotcontrol, roll/lb
	tmp$=XUNIT$(pr.UMBrknQty,ccc)
	WebStr$=WebStr$,Str$(pw.DNReordFlg),fdel$,RTrim$(tmp$),fdel$ ! DNReord, brkn um
	X3=UMtoFactor(pr.UMBrknQty)
	WebStr$=WebStr$,Str$(pr.UMBrknQty),fdel$,Str$(X3),fdel$ ! um id, um factor
	tmp$="N" \ if rol.UpdtStk=1 let tmp$="Y"
	webstr$=webstr$,tmp$,fdel$	! stock update
	tmp$="N" \ if DNRFail=1 let tmp$="Y"
	Webstr$=Webstr$,tmp$,fdel$ ! DNR Failed!
	if not(nonstk)
		x1=ComplFlag(e$,PRC,IntCo,Prod$)
		webstr$=webstr$,Str$(X1),fdel$ ! complementary 0/1  N/Y
		X1=SubItmFlag(e$,PRC,IntCo,Prod$)
		webstr$=webstr$,Str$(X1),fdel$ ! substitute 0/1  N/Y
		X1=SPRCIFlag(e$,PRC,IntCo,Prod$)
		webstr$=webstr$,Str$(X1),fdel$ ! supercede 0/1  N/Y
		X1=AskLPFlag \ IF P61$[25,25]<>"P" LET x1=0 ! Or Source=251 ?
		webstr$=webstr$,Str$(X1),fdel$	! 0=no ask 1= yes ask
	Else
		webstr$=webstr$,"0",fdel$,"0",fdel$,"0",fdel$,"0",fdel$
	Endif
	List$[2]=webstr$
	List$[3]=esdel$ ! done
	Call AddToStr(e$,rstr$,List$[])
	Goto SPEDone ! Do we need to send super/subst list?
	! send supersede list
	Whse=roh.Wh \	if roh.ordtype=7 let Whse=roh.ConsWh
	OType=roh.ordtype
	Call SPRCIList(e$,IntCo,TList$[],maxcnt,ctlc,prc,whc,ccc,Prod$,Whse,OType)
	e$=""
	call AddToStr(e$,rstr$,TList$[])
	! send subs list? - lets
	
	Call SubstIList(e$,IntCo,SList$[],maxcnt,ctlc,prc,whc,ccc,Prod$,Whse,OType)
	e$=""
	call AddToStr(e$,rstr$,SList$[])

	SPEDone: ! finished
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	
  else
    include "src/callsuberr.inc"
 end try
end sub ! SProdDtl
! 
!--------------------------------------------------------------------
Sub chk4sns()
! add a message if serial numbers need editting
  try
	dim flenkey$[60]
	dim 3%,nsno,qship
	if source=207 or source=239 goto c4sndone
	if rol.UpdtStk=0 goto c4sndone ! no stock - no update
	if p60$[25,25]<>"Y" goto c4sndone ! no sn flg
	let ch_flen=openfile(-2944,Intco) \ if ch_flen<0 goto c4sndone
	QShip=ABS(nrol.qtyship) ! in case - neg ship
	rolkey$=" ",rolkey$;nsno=0
	rolkey$[1,6]=OrderNo Using "######"
	rolkey$[7,9]=nrol.linenum using "###"
	rolkey$[11]="" ! cut to length (space @ 10)
	let flenkey$=rolkey$
	SNLOOP: ! DIR 1=ORDER/LINE/SN
	SEARCH #CH_FLEN,3,1;FLENKEY$,R[99],E
	IF E GOTO C4SNDONE
	IF FLENKEY$[1,9]<>ROLKEY$[1,9] GOTO C4SNDONE
	LET NSNO=NSNO+1 ! both sn and ship are BASE UM!
	GOTO SNLOOP
	C4SNDone: ! complete
	IF CH_FLEN>0
		TRY CLOSE #CH_FLEN ELSE REM
	ENDIF
	IF QSHIP AND QSHIP<>NSNO ! DIFF
	   if NSNO or Invoice or Credit ! if entered previously or invoice/credit
		returnstatus=0 ! so message shows? yes
		LET Message$=Message$+" line written  NOTE: Serial Numbers need edit"
	   endif
	endif
  else
    include "src/callsuberr.inc"
 end try
end sub ! chk4sns
! 
!--------------------------------------------------------------------
Function GetAskLP()
	try
		Dim LPKey$[60]
		If LPR<=0 ! did not find or get yet - look for it
			LPKey$=" ",LPKey$
			LPKey$[1,6]=Roh.CustNum using "######"
			X2=roh.dept \ if P9$[44,44]<>"Y" let x2=0
			LPkey$[7,10]= X2 Using "####"
			If Not(NonStk) let LPKey$[11]=rol.prodcode$
			If NonStk let LPKey$[11]=rol.VendItemCode$
			tmp$=LPKey$
			LPR=filegetlastprice(e$,LPC,">",1,LPKey$,CLP.)
			clear e$
			If lpkey$[1,22]<>tmp$[1,22] let lpr=-1
			!  nothing for main cust try again with pricemaster
			If LPR<=0 and cust.LpPpGrpCust
				clear clp.
				LPKey$=" ",LPKey$
				LPKey$[1,6]=cust.LpPpGrpCust using "######"
				X2=roh.dept \ if P9$[44,44]<>"Y" let x2=0
				LPkey$[7,10]= X2 Using "####"
				If Not(NonStk) let LPKey$[11]=rol.prodcode$
				If NonStk let LPKey$[11]=rol.VendItemCode$
				tmp$=LPKey$
				LPR=filegetlastprice(e$,LPC,">",1,LPKey$,CLP.)
				clear e$
				If lpkey$[1,22]<>tmp$[1,22] let lpr=-1
				If LPR<=0 clear clp.
			Endif
		Endif ! need for poss sugg price
		if LPR>0 let AskLPFlag=0 else AskLPFlag=1  ! 0=lp exists 1=nolp
	  else
    include "src/callsuberr.inc"
 end try
End Function AskLPFlag  ! GetAskLP()
!--------------------------------------------------------------------
! 
!--------------------------------------------------------------------
Sub ProduceCPIAlerts ()
! take update from CPI exception page and
! produce alerts
 Try
	if p61$[111,111]="N"
		message$ = "CPI NOT ENABLED AND CPI ALERT CALL DONE!"
		returnstatus=0
		goto CPIAlertsDone:
	end if
	Call DXGet("ORDERID",tmp$)
	if tmp$="" 
		let message$="ORDER # MISSING"
		Let ReturnStatus=0
		Goto CPIAlertsDone:
	Endif
	OrderNo=tmp$
	If OrderNo>0 and OrderNo<999999 and Not(Fra(OrderNo))
		OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
		e$=""
		If OHR<=0 ! no order found
			Let message$="ORDER # NOT FOUND"
			Let ReturnStatus=99
			Goto CPIAlertsDone:
		Endif
	Endif
	Call GetCust()
	Call DXGet("TTLCPIS",tmp$)
	Let NumCPIs=tmp$
	if NumCPIs<1 ! HAS TO BE AT LEAST 1!
		let message$="NO NUMBER OF CPI REPONSES SENT"
		Let ReturnStatus=0
		Goto CPIAlertsDone:
	Endif
	ReturnStatus=1
	Message$="OK" 
	Credit=0 \ if ros.status=32 let credit=1
	if credit
		let message$="CREDIT SHOULD NOT GENERATE CPI ALERTS!"
		Let ReturnStatus=0
		Goto CPIAlertsDone:
	end if
	! set list header
	Clear List$[]
	!DOCPI=0 \ if userid$[1,4]="JIMS" or userid$[1,2]="S8" let docpi=1 ! temp for test
	cpiflag=0;tmpcnt=maxcnt;Custno=roh.CustNum
	clear list$[]
	! ok - make a call & check results if exceptions - status=11 and results in list$
	Call CPIOrdAlerts(e$,intco,NumCPIs,ctlc,OrderNo,roh.,ros.,rot.,CUC)
	CPIAlertsDone: ! finished
	! status section
	If ReturnStatus=1 let message$="OK"
	if returnstatus<>1 and message$="" let message$=E$ ! as there are 99's?
	if debugdetail
	dmsg$="CPI Generate Alerts "+Str$(Orderno)+" TTL IN "+Str$(NumCPIs)+" "+Message$ \ Call updatelog(debug)
	Endif
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
 else
    include "src/callsuberr.inc"
 end try
end sub ! ProduceCPIAlerts
!--------------------------------------------------------------------
Sub CalcDirLoad()  
!!! note if flag is set, the system will recalculate load everytime the g/l cost is change, regardless of order type
	Try
		dim 1%,wh,scr
		Dim 1%,nsch[10],nstat,2%,nsltbl,3%,nscost
		DIM 2%,LTBL
		dim K5$[45],3%
		returnstatus=1
		message$="OK"
		if p61$[116,116]<>"Y"
			returnstatus=0
			let message$="Option to Calculate Direct Load Cost Not Available"
			goto endcalcdirload:
		endif
		Call dxget("ORDERID",tmp$)                           
		orderno = tmp$  
		If orderno <= 0 Or orderno > 999999 Or Fra(orderno)
			let returnstatus=0
			let message$="Invalid Order Id "
			goto endcalcdirload:
		endif
		OHR = GetOrdRec(e$,OHC,OSC,otc,orderno,roh.,ros.,rot.)
		e$=""
		If OHR <= 0 ! not found                                
			ReturnStatus = 99                                     
			Message$ = "ORDER WAS NOT FOUND"                     
			Goto endcalcdirload:
		endif
		!if roh.ordtype<>2
		!	returnstatus=0
		!	let message$="Order "+str$(orderno)+" Not a direct order type "
		!	goto endcalcdirload:
		!endif
		Call Dxget("GLCOST",tmp$)
		let v3[9]=tmp$
		if v3[9]<=0
			returnstatus=0
			let message$="No General Ledger Cost "
			goto endcalcdirload:
		endif
		Call dxget("LN",tmp$) ! +Str$(X1),tmp$)         
		LineNo = tmp$ ! line # (zero on new lines)
		If LineNo <= 0 Or LineNo > 999 Or Fra(lineno)  
			ReturnStatus = 0                                   
			Message$ = "INVALID ORDER LINE!"
			GOTO endcalcdirload:				
		End If   
		rolkey$ = " ",rolkey$                         
		rolkey$[1,6] = orderno Using "######"         
		rolkey$[7,9] = LineNo Using "###"       
		rolkey$[11] = "" ! cut to length (space @ 10) 
		OLR = filegetrolz(e$,OLC,"=",1,rolkey$,rol.)
		clear e$
		if olr<=0
			returnstatus=0
			Message$="Order Line Not Found"
			GOTO endcalcdirload:
		endif
		let prodkey$=rol.prodcode$
		if rol.NStkItem = 1 ! nonstock item #1
			Read #1,182,4;nsltbl;
			if nsltbl<=0
				let returnstatus=0
				Message$="No Load Table for Nonstocks"
				goto endcalcdirload:
			endif
			Call SetPRtoRol()
			if v3[9]>0 ! sent glcost
				CNVTU[0]=rol.UMCost;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
				cnvta=v3[9] \ if rol.UMCost>0 and rol.NumOut>0 let cnvta=v3[9]*rol.numout
				rol.UnitGLCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			else
				call dxget("GLCOST",tmp$)
				if rtrim$(tmp$)<>""
					if rtrim$(tmp$)="0" or rtrim$(tmp$)="0.0" or rtrim$(tmp$)="0.00"
						let rol.unitglcost=0
					endif
				endif
			endif
			let nsch[0]=ctlc         
			LET NSCH[1]=0 ! load markup channel
			let nsch[2]=olc! sales order line channel
			Parm[0]=208 ! order entry/edit
			Parm[1]=nsltbl ! 
			Parm[2]=olr ! line record #
			Parm[3]=roh.ordtype ! order type
			nsstat=1
			Let NSCOST=rol.UnitGlCost ! set to load cost
			Call "NSLOAD.dl4",NSCH[],PARM[],NSCOST,NSSTAT
			LET rol.UnitCost=NSCOST
		else ! product 
			let prr=rol.PDRecNum
			Read Record #prc,prr;pr.;
			if v3[9]>0 ! sent glcost
				CNVTU[0]=rol.UMCost;CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
				cnvta=v3[9] \ if rol.UMCost>0 and rol.NumOut>0 let cnvta=v3[9]*rol.numout
				rol.UnitGLCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			else
				call dxget("GLCOST",tmp$)
				if rtrim$(tmp$)<>""
					if rtrim$(tmp$)="0" or rtrim$(tmp$)="0.0" or rtrim$(tmp$)="0.00"
						let rol.unitglcost=0
					endif
				endif
			endif
			if p9$[32,32]="Y"
				k5$[1,12]=pr.prodcode$[1,12]
				k5$[13]=rol.Whse Using "##"
				PWR=filegetprodwhse(e$,PWC,"=",1,k5$,pw.)
				clear e$
				if pwr<0
					let returnstatus=0
					Message$="No Load Table for Product Warehouse "
					goto endcalcdirload:
				endif
				if pw.Load1MupTbl<=0
					let returnstatus=0
					Message$="No Load Table for Product Warehouse "
					goto endcalcdirload:
				Endif
				let ltbl=pw.Load1MupTbl
			else
				let ltbl=pr.Load1MupTbl
			endif		
			if ltbl>0
				LET PREC[0]=prr ! product record #    
				if pr.lbsfact<=0 let pr.lbsfact=1
				leT PREC[2]=FNR(ABS((ROL.LbsUnit*ROL.QtyOrd)/pr.LbsFact)) ! ext weight of line (ordered)  
				IF ROL.LbsUnit<>0 AND ROL.LbsUnit<>pr.lbsunit! line lbs different from prod file lbs         
					LET PREC[3]=ROL.LbsUnit                                                      
				ELSE                                                                     
					LET PREC[3]=0                                                          
				ENDIF                                                                    
				LET CNVTA=rol.unitglcost ! use g/l cost                             
				LET SCR=-roh.ordtype ! negative otyp means force the base cost   
				!Enter OTYPE,WH,LTBL,PREC[],CNVTA,IntCo,e$,rstr$
				CALL "MXLOAD5.DL4",SCR,WH,LTBL,PREC[],CNVTA,IntCo,e$,rstr$                               
				let rol.unitcost=cnvta 
			else
				let returnstatus=0
				Message$="No Load Table for Product"
				goto endcalcdirload:
			endif
		endif ! #1
		if not(rol.unitcost)
			let returnstatus=0
			Message$="No Load Table for Product"
			goto endcalcdirload:
		endif
		IF rol.UMCutCost=-3 AND nrol.QtyOrd LET CHBASE=(nrol.CutCost/nrol.QtyOrd) ELSE  LET CHBASE=nrol.CutCost
		X3[4]=rol.UnitCost+CHBase
		X3[3]=X3[4]
		IF rol.LoadUpchrg ! has cost up
			IF rol.LoadUpchrg<0 ! $ amount
				X3[3]=x3[4]+Abs(nrol.LoadUpchrg)
			Else ! percent
				X3[3]=X3[4]+(X3[4]*(nrol.LoadUpchrg/100))
			Endif
		Endif ! X3[3]=NETCOST
		NETCOST=X3[3]
		endcalcdirload: ! end calc distribution
		Clear List$[]
		list$[0]=bsdel$,"LOADCOST",fdel$
		List$[1]="UNITCOST",fdel$,"NETCOST",fdel$
		let row=2	
		if returnstatus=1 ! #1
			webstr$=""
			CNVTU[0] = 0;CNVTU[1] = rol.UMCost;CNVTU[2] = 2                 
			CNVTA = rol.UnitCost                                            
			Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.) 
			let webstr$=webstr$+str$(amount)+fdel$ ! new line unit cost
			cNVTU[0] = 0;CNVTU[1] = rol.UMCost;CNVTU[2] = 2                 
			CNVTA = netcost                                           
			Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.) 
			let webstr$=webstr$+str$(amount)+fdel$ ! new line unit cost
			let list$[row]=webstr$
			let row=row+1
		endif  ! #1
		list$[row]=esdel$
		e$=""
	    call AddToStr(e$,rstr$,List$[]) ! add droplist to string  
	 
	  ! status section
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
 else
    include "src/callsuberr.inc"
 end try
end sub ! CalcDirLoad
! 
!--------------------------------------------------------------------
Sub Getiolines()
! get the lines front end wants
  try
	Dim KOL$[60],KPW$[60],KCM$[50],KLP$[60]
	Dim ZOL$[60],GPID$[20]
	Dim 1%,FCDays,cnvtu[2],elflag
	Dim 2%,OrderNo,row,tmpcnt,JDate[5],FDate
	Dim 3%,OLR,FutCost,CNVTA,Amount

	Dim ZROL. as rolnew ! for zlines (get data for it before sending line)
	if debugdetail
		dmsg$="Start get Requested Lines" \ Call updatelog(debug)
	Endif
	Read #ctlc,2,198;FCDays; ! days to check future cost
	If FCDays<1 or FCDays>999 or Fra(FCDays) Let FCDays=30 ! check range
	ReturnStatus=1
	Message$="OK"
	Call DXGet("ORDERID",tmp$)
	X2=tmp$
	If X2<1 or X2>999999 or Fra(X2) ! not valid
		ReturnStatus=0
		Message$="ORDER NOT PASSED"
		goto giolDone:
	Endif
	OrderNo=x2
	OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
	e$=""
	If OHR<=0 ! not found
		ReturnStatus=0
		Message$="ORDER NOT FOUND"
		goto giolDone:
	Endif
	Call GetCust()
	CREDIT=0 \ if ros.status=32 let credit=1
	if credit and roh.ShipType=3 let cost_lev[1]=0 ! no cost on cm price error
	! set list header (SIMILAR TO PRODDETAIL ACTION!)
	elflag=9 ! existing Line Flag (for detail to string) as add'l fields needed
		Clear List$[]
		List$[0]=bsdel$,"LINEDETAIL",fdel$
		call MainDtlHdr() ! set webstr$ for main header/LineMainDtl
		List$[1]=WebStr$
		Row=2;tmpcnt=maxcnt
	! okay - see if lines
	call dxget("NUMITEMS",tmp$) ! number of items wanted (lines/prods)
	if rtrim$(tmp$)="" 
		returnstatus=0
		message$="Number of items wanted was not sent"
		goto GIOLFIN ! 
	Endif
	let NumItems=tmp$
	if numitems<=0 or numitems>999 or fra(numitems)
		returnstatus=0
		message$="Number of items wanted is invalid"
		goto GIOLFIN ! 
	Endif
	GN0=0
	! okay loop thru (start at 1!)
	NxtGILoop: ! 
	GN0=GN0+1 \ if GN0>NumItems goto GIOLFin ! reached max
	call dxget("LINENO"+Str$(GN0),tmp$) ! could be blank/zero/null
	GLNO=tmp$
	if GLNO<0 or GLNO>999 or fra(GLNO)
		returnstatus=0
		message$="Line # "+Str$(GN0)+" is invalid"
		goto gioldone ! 
	Endif 
	Call dxget("PRODID"+Str$(GN0),tmp$) ! could be blank/null
	GPID$=UCASE$(RTRIM$(tmp$))+Blank$
	GPID$[13]="" ! cut to length
	if glno=0 and RTrim$(GPID$)="" goto nxtgiloop ! nothing sent - next
	KOL$=" ",KOL$;NumLines=0
	KOL$=OrderNo Using "######"
	if RTrim$(GPID$)<>"" ! sent prod - look for it first
		PrR=filegetprod(e$,PRC,"=",1,GPID$,PR.) ! product mode=2 dir=1
		clear e$
		NonStk=0
		if PRR<=0 let NONSTK=1
		let ldir=2 \ if nonstk let ldir=1
		if ldir=2 
			let kol$[1,6]=PRR USING "######"
			kol$[7,12]=OrderNo using "######"
		endif
		IF NONSTK ! check for spaces BEfor order (web doesn't send 'em)
			search GPID$[1],"-",pos0
			if pos0 ! has a dash so before is order# - after line #
				let x2=GPID$[1,pos0-1]
				let tmp$=x2 using "######" ! make it 6
				let tmp$[7]=gpid$[pos0] ! should be -000
				let gpid$=tmp$
			endif
		endif
		grlolloop:
		search #OLC,3,ldir;kol$,olr,E
		if e goto nxtgiloop
		if ldir=2 ! prod rec
			x2=kol$[1,6] \ if x2<>prr goto nxtgiloop ! done with prod rec
		endif
		let x2=kol$[1,6] \ if ldir=2 let x2=kol$[7,12]
		if x2<>OrderNo goto nxtgiloop ! done with order
		
		Read record #OLC,OLR,0;rol.;
		
		if rol.ProdCode$[1,12]<>GPID$[1,12] goto grlolloop ! diff prod
		if rol.OrdNum<>OrderNo goto nxtgiloop ! another ord# check
		gosub StrtDetailforReq
		goto grlolloop ! next prod?
	Else ! no prodcode - get this line
	  if glno ! want this line!
		kol$[7,9]=GLNO Using "###"
		search #OLC,2,1;kol$,olr,e
		if e
			returnstatus=0
			message$="Order Line "+Str$(GLNO)+" not found"
			goto giolfin
		endif
		gosub StrtDetailforReq ! send line detail
	  Endif
	Endif
	Goto NxtGILoop ! done or neither was sent?
	! same for both options
	StrtDetailforReq: ! 
	read record #OLC,OLR,0;rol.;
	if (roh.OrdType=21 or roh.OrdType=22) and kol$[7,9]="   " goto bprldtl ! ot 21/22
	!x2=kol$[7,9] \ if dooneline and x2<>dooneline exit do ! only want 1 line
		NonStk=rol.NStkItem
		ZLine=0 \ if rol.LineType=3 and NonStk let ZLine=1 ! need for later
		! get/read appropriate records (prod,prodwhse,comm,lastprice
		If Not(NonStk) ! it's a prod
			PRR=rol.PDRecNum
			Read record #PRC,PRR,0;PR.;
			if roh.ordtype=8 or roh.ordtype=16
			  If Roh.ConsWh>0 and roh.conswh<100
				Let TPWKey$=" ",tpwKey$
				TPWkey$[1,12]=rol.prodcode$+Blank$
				TPWKey$[13]=ROH.ConsWh Using "##"
				call chktowhse(TPWKey$,pr.PrimVend)
			  Endif
			Endif
			KPW$=" ",KPW$
			Kpw$=rol.prodcode$+rol.whse Using "##"
			IF roh.ordtype=7 let Kpw$=rol.prodcode$+ROH.ConsWh Using "##"
			PWR=filegetprodwhse(e$,PWC,"=",1,KPW$,pw.)
			clear e$
			if PWR<0 ! not found
				Clear pw.
				If PWR=-1 ! not found - add?
					E$="";x3=kpw$[13,14]
					if roh.ordtype=7
						x3[1]=rol.whse/100
						x3=x3+x3[1]
					Endif
					Whbld[0]=PWC;Whbld[1]=X3;WhBld[2]=pr.PrimVend
					if x3<>1 let Whbld[1]=X3+.01 ! fra=copy whse 1
					Call mxwhcreate(e$,IntCo,rol.PRODCode$,WHBLD[])
					PWR=Whbld[2]
					Read record #PWC,PWR,0;PW.;
				Endif
			Endif
			If rol.ComdtyCode$="" or rol.ComdtyCode$=Blank$[1,4]
				rol.ComdtyCode$=pr.ComdtyCode$
			Endif
		Else
			Clear pr.
			Clear pw.
		Endif
		! always set up pr. w/line factors
		LineNo=rol.LineNum
		Call SetPRtoRol()
		KCM$=" ",KCM$
		KCM$=rol.ComdtyCode$+Blank$[1,4];kcm$[5]=""
		CMR=filegetcommhead(e$,cmc,"=",1,KCM$,cmc.)
		clear e$
		If CMR<1 Clear cmc.
		KLP$=" ",KLP$ ! look for lastprice record
		klp$[1,6]=ROH.custnum using "######"
		X2=rol.dept \ if P9$[44,44]<>"Y" let x2=0
		KLP$[7,10]=X2 Using "####"
		If Not(NonStk)Let KLP$[11]=rol.prodcode$
		If NonStk Let KLP$[11]=rol.VendItemCode$ ! is diff on nonstks!
		tmp$=KLP$ ! only know/can send up to prod
		LPR=filegetlastprice(e$,LPC,">",1,KLP$,CLP.)
		clear e$
		If klp$[1,22]<>tmp$[1,22] let lpr=-1
		If LPR<=0 clear clp.
		FlePtr[4,1]=LPR ! is used this way elsewhere
		FutCost=0
		If Not(NonStk) ! can only call price for futcost on stock items
			Call SetUpSpecs() ! get specs info for fut cost
			! future cost = cost as of xx days from today (specs[5] chg)
			JDate=TIM(6)+FCDays ! ## days from today
			tmp$=JDate$(jdate) ! from ddddd to MM/DD/YYYY
			tmp1$=Formatdate2$(tmp$) ! now MM/DD/YYYY to YYYYMMDD
			Let FDate=tmp1$[3,8] ! just need yymmdd
			Let Specs[5]=0-FDate
			Call getprice() ! call price w/all entries above
			If Specs[0]=0 ! okay
				Let X3=Specs[17]
				cnvtu[0]=0;cnvtu[1]=rol.UMCost;cnvtu[2]=2
				Cnvta=X3 \ if rol.umcost>0 and rol.numout>0 let cnvta=x3/rol.numout
				FutCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			Endif
		Endif ! of stk item - get future cost
		if roh.OrdType=8 or roh.OrdType=16 ! cons/trans - no price/cost
			rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
			rol.UnitPrice=0;rol.CutChrg=0;rol.CutCost=0
			rol.LineDisc=0;rol.ExtOrdAmt=0;rol.ExtShipAmt=0
			rol.LineDiscPct=0;rol.ExtCutChg=0;rol.ExtCutCost=0
			rol.ExtLoadShip=0;rol.ExtLoadOrd=0;rol.NetPrice=0
			rol.TaxAmt=0;rol.LoadUpchrg=0;rol.UpChrg=0
		Endif
		If p61$[46,46]="Y" and Credit and roh.shiptype=3 ! price fix - no cost
			rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
			rol.CutCost=0;rol.ExtCutCost=0;rol.ExtLoadShip=0;rol.ExtLoadOrd=0
			rol.LoadUpchrg=0
		Endif
		If roh.OrdType=37  ! "EVAP Ship - NO Price - any order in here
			If Not(Credit) Or (Credit And roh.ShipType=16)
				Let rol.UnitPrice=0;rol.NetPrice=0;rol.CutChrg=0
				Let rol.LineDisc=0;rol.LineDiscPct=0;rol.UpChrg=0
				rol.ExtOrdAmt=0;rol.ExtShipAmt=0;rol.ExtCutChg=0
			Endif
		Endif
		If roh.OrdType=36 ! "EVAP Billing - NO Cost - Any type order
			If Not(Credit) Or (Credit And roh.ShipType=16)
				Let rol.UnitCost=0;rol.CostOrigin=0;rol.RebtContract=0
				Let rol.CutCost=0;rol.ExtCutCost=0;rol.ExtLoadShip=0;rol.ExtLoadOrd=0
				rol.LoadUpchrg=0;NetCost=0
			ENDIF
		Endif
		Call LineMainDtl() ! set up web string
		NumLines=NumLines+1
	 BPRLDTL: ! bypass line (ot21/22)
	Return ! Goto NxtGILoop
	GIOLFIN:  !
	List$[row]=esdel$ ! finished
	e$=""
	call AddToStr(e$,rstr$,List$[])
	giolDone: ! finished
	! status section
	if debugdetail
		dmsg$="Selected Lines "+Str$(Orderno)+" TTL "+Str$(NumLines)+" "+Message$ \ Call updatelog(debug)
	Endif
	!if not(dooneline)
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
	!Endif ! don't send on one line get
	! 
	! call programdump("/tmp/ollog7!","")
  else
    include "src/callsuberr.inc"
 end try
end sub ! Getiolines
! 
!--------------------------------------------------------------------
SUB prcamalg()
! call off to mx201wt for price amalgamation
! and then resend all the lines (can be optional with changes)
  try
	
	Dim 1%,FCDays,cnvtu[2],elflag,PChan[99]
	Dim 2%,OrderNo,row,tmpcnt,JDate[5],FDate
	Dim 3%,OLR,FutCost,CNVTA,Amount
	Dim 1%,H4[2],SO[20],P3,2%,N0,H5[16],H0[12],H6[8]
	Dim 3%,R[50],S9[9]
	! call dxsave(0,"tmp/pamg.txt!")
	Dim ZROL. as rolnew ! for zlines (get data for it before sending line)
	if debugdetail
		dmsg$="Start Amalgamate Lines" \ Call updatelog(debug)
	Endif
	if p60$[12,12]<>"Y" ! NOT
		returnstatus=0
		message$="NO PRICE AMALGAMATION"
		goto pamdone
	endif
	MaxLines=50 ! per front end - send these # of lines at a time
	Read #ctlc,2,198;FCDays; ! days to check future cost
	If FCDays<1 or FCDays>999 or Fra(FCDays) Let FCDays=30 ! check range
	ReturnStatus=1
	Message$="OK"
	Call DXGet("ORDERID",tmp$)
	X2=tmp$
	If X2<1 or X2>999999 or Fra(X2) ! not valid
		ReturnStatus=0
		Message$="ORDER NOT PASSED"
		goto pamDone:
	Endif
	OrderNo=x2
	!if orderno=22431 call dxsave(0,"tmp/olapcm.txt!")
	OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
	e$=""
	If OHR<=0 ! not found
		ReturnStatus=0
		Message$="ORDER NOT FOUND"
		goto pamDone:
	Endif
	Call GetCust()
	CREDIT=0 \ if ros.status=32 let credit=1
	r[50]=1 \ if credit let r[50]=2
	if credit and source<=0 let source=241
	let s9[2]=ohr;s9[4]=source
	if source=2082 let s9[4]=208
	pchan[1]=prc;pchan[2]=CMC;pchan[3]=OLC
	pchan[4]=btc;pchan[5]=NSC;pchan[6]=PWC
	pchan[7]=CCC;pchan[8]=cphc;pchan[9]=splc
	pchan[10]=CUC;pchan[11]=OHC
	Mat read #ohc,ohr,0;H0;
	mat read #ohc,ohr,78;H4;
	mat read #ohc,ohr,104;h5;
	mat read #ohc,ohr,408;h6;
	let p3=h6[0] ! price type
	if p3<=0 let p3=cust.PriceType
	if p3<=0 let p3=1
	mat read #cuc,cur,502;so;
	let n0=orderno
	
	call "mx201wt.dl4",H4[],SO[],P3,N0,H5[],H0[],R[],S9[],Intco,PChan[]
	! no passing of issues back from call?
	! we can also (and possibly should send back the lines)
	let dooneline=0;DoPart=0 ! so gets all
	Call getordlines()
	goto pamexit ! NO NEED FOR STATUS - (it's in getordlines)
	pamdone: ! finished
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	pamexit: ! bypass status
  else
    include "src/callsuberr.inc"
 end try
end sub ! prcamalg
! 
!--------------------------------------------------------------------

sub GetPOLines()
  try
	dim k_pol$[50]
	dim poh. as pohead
	dim pol. as poline
	
	if debugdetail
		dmsg$="Get PO Lines" \ Call updatelog(debug)
	Endif
	ch_poh = openfile(-2416,IntCo) \ if ch_poh = -1 Error 42
	ch_pol = openfile(-2432,IntCo) \ if ch_pol = -1 Error 42
	ReturnStatus=1
	Message$="OK"
	Call DXGet("ORDERID",tmp$)
	OrderNo=tmp$
	If OrderNo<1 or OrderNo>999999 or Fra(OrderNo)
		ReturnStatus=0
		Message$="ORDER NUMBER INVALID"
		Goto POLSDone
	Endif
	OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
	e$=""
	If OHR<=0 ! not found
		ReturnStatus=99
		Message$="ORDER WAS NOT FOUND"
		goto POLSDone
	Else
		Credit=0 \ if rot.Status=22 let Credit=1 ! instead of roh.status check
		if Credit
			ReturnStatus=0
			Message$="NOT VALID FOR CREDITS"
			Goto POLSDone
		end if
		if source<>201 and source<>208
			ReturnStatus=0
			Message$="VALID FOR SALES ORDER ENTRY ONLY"
			Goto POLSDone
		end if
	Endif
	! check for valid order types here
! 	if not(found)
! 		ReturnStatus=0
! 		Message$="INVALID ORDER TYPE"
! 		Goto POLSDone
! 	end if
	Call DXGet("LN",tmp$) ! +Str$(X1),tmp$)
	LineNo=tmp$
	if LineNo<0 or LineNo>999
		ReturnStatus=0
		Message$="INVALID LINE NUMBER"
		Goto POLSDone
	end if
	rolkey$=" ",rolkey$
	rolkey$[1,6]=OrderNo Using "######"
	rolkey$[7,9]=LineNo using "###"
	rolkey$[11]="" ! cut to length (space @ 10)
	OLR=filegetrolz(e$,OLC,"=",1,rolkey$,rol.)
	clear e$
	if olr<=0 ! what do we do if not found?
		ReturnStatus=0
		Message$="LINE NOT FOUND"
		Goto POLSDone
	Endif
	if rol.PONum
		ReturnStatus=0
		Message$="ALREADY LINKED TO PO"
		Goto POLSDone
	end if
	if rol.NStkItem=1
		ReturnStatus=0
		Message$="NOT VALID FOR NON STOCK LINE"
		Goto POLSDone
	Endif
	if rol.TOrderNum
		ReturnStatus=0
		Message$="ON TRANSFER ORDER - CANNOT LINK TO PO"
		Goto POLSDone
	end if
	if not(rol.UpdtStk)
		ReturnStatus=0
		Message$="LINE DOES NOT UPDATE STOCK - CANNOT LINK TO PO"
		Goto POLSDone
	end if
	if not(rol.QtyBO)
		ReturnStatus=0
		Message$="NOTHING BACK ORDERED - CANNOT LINK TO PO"
		Goto POLSDone
	end if
	! OK - technically eligible to do this so see what we can find
	Read record #prc,rol.PDRecNum,0;pr.;
	found = 0
	k_pol$ = " ",k_pol$
	k_pol$[1,6] = rol.PDRecNum using "######"
	do
		r_pol=filegetpoline(e$,ch_pol,">",2,k_pol$,pol.)
		clear e$
		If r_pol<=0 exit do
		if val(k_pol$[1,6]) <> rol.PDRecNum exit do
		if pol.Status <> 1 goto SkipPoLine ! not open
		if pol.Whse <> rol.Whse goto SkipPoLine !wrong wh
		if not(pol.UpdStock) goto SkipPoLine ! non-stock line
		if (pol.QtyOrd - pol.QtyRcvdToDate) < rol.QtyBO goto SkipPoLine
		if (pol.SalesOrd) ! POSSIBLY already linked, make sure
			tmp$ = " ",tmp$
			tmp$[1,6] = pol.SalesOrd using "######"
			tmp$[7,9] = pol.SalesOrdLine using "###"
			search #OLC,2,1;tmp$,r,e
			if not(E) goto SkipPoLine !already linked
		end if
		! OK - got one
		read record #ch_poh,pol.HeaderRec,0;poh.;
		if not(found)
			! build the header
			found = 1
			tmp$ = bsdel$+"POLINES"+fdel$+rdel$
			tmp$ = tmp$+"PO"+fdel$+"POLINE"+fdel$
			tmp$ = tmp$+"ORDDATE"+fdel$
			tmp$ = tmp$+"DUEDATE"+fdel$+"QUANTITY"+fdel$
			tmp$ = tmp$+"UM"+fdel$+rdel$
			call addtostr(e$,rstr$,tmp$)
		end if
		! add detail
		webstr$=str$(pol.PONum)+fdel$
		webstr$=webstr$+str$(pol.ItemNo)+fdel$
		tmp$ = poh.OrderDate using "&&&&&&"
		try call FormatDate(tmp$) else tmp$=""
		webstr$=webstr$+tmp$+fdel$
		tmp$ = pol.DueDate using "&&&&&&"
		try
			call FormatDate(tmp$)
		else
			tmp$ = poh.DueDate using "&&&&&&"
			try call FormatDate(tmp$) else tmp$ = ""
		end try
		webstr$=webstr$+tmp$+fdel$
		! convert po amount to sell qty
		let cnvtu[0]=0;cnvtu[1]=rol.UMSell;cnvtu[2]=1
		let cnvta=(pol.QtyOrd - pol.QtyRcvdToDate)
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		webstr$=webstr$+str$(Amount)+fdel$
		webstr$=webstr$+rtrim$(XUNIT$(rol.UMSell,ccc))+fdel$+rdel$
		call addtostr(e$,rstr$,webstr$)
		SkipPoLine: !
	loop
	if not(found)
		ReturnStatus=0
		Message$="NO QUALIFYING PO LINES FOUND"
		Goto POLSDone
	end if
	call addtostr(e$,rstr$,esdel$)
	POLSDone: ! finished
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
  else
    include "src/callsuberr.inc"
 end try
end sub ! GetPOLines
! 
!--------------------------------------------------------------------

sub LinkPOLine()
  try
	dim k_pol$[50]
	dim pol. as poline
	
	if debugdetail
		dmsg$="Link PO Line" \ Call updatelog(debug)
	Endif
	ch_pol = openfile(2432,IntCo) \ if ch_pol = -1 Error 42
	ReturnStatus=1
	Message$="OK"
	Call DXGet("ORDERID",tmp$)
	OrderNo=tmp$
	If OrderNo<1 or OrderNo>999999 or Fra(OrderNo)
		ReturnStatus=0
		Message$="ORDER NUMBER INVALID"
		Goto POLinkDone
	Endif
	OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
	e$=""
	If OHR<=0 ! not found
		ReturnStatus=99
		Message$="ORDER WAS NOT FOUND"
		goto POLinkDone
	Else
		Credit=0 \ if rot.Status=22 let Credit=1 ! instead of roh.status check
		if Credit
			ReturnStatus=0
			Message$="NOT VALID FOR CREDITS"
			Goto POLinkDone
		end if
		if source<>201 and source<>208
			ReturnStatus=0
			Message$="VALID FOR SALES ORDER ENTRY ONLY"
			Goto POLinkDone
		end if
	Endif
	! check for valid order types here
! 	if not(found)
! 		ReturnStatus=0
! 		Message$="INVALID ORDER TYPE"
! 		Goto POLinkDone
! 	end if
	Call DXGet("LN",tmp$) ! +Str$(X1),tmp$)
	LineNo=tmp$
	if LineNo<0 or LineNo>999
		ReturnStatus=0
		Message$="INVALID LINE NUMBER"
		Goto POLinkDone
	end if
	rolkey$=" ",rolkey$
	rolkey$[1,6]=OrderNo Using "######"
	rolkey$[7,9]=LineNo using "###"
	rolkey$[11]="" ! cut to length (space @ 10)
	OLR=filegetrolz(e$,OLC,"=",1,rolkey$,rol.,1)
	clear e$
	if olr<=0 ! what do we do if not found?
		ReturnStatus=0
		Message$="LINE NOT FOUND"
		Goto POLinkDone
	Endif
	if rol.PONum
		ReturnStatus=0
		Message$="ALREADY LINKED TO PO"
		Goto POLinkDone
	end if
	if rol.NStkItem=1
		ReturnStatus=0
		Message$="NOT VALID FOR NON STOCK LINE"
		Goto POLinkDone
	Endif
	if rol.TOrderNum
		ReturnStatus=0
		Message$="ON TRANSFER ORDER - CANNOT LINK TO PO"
		Goto POLinkDone
	end if
	if not(rol.UpdtStk)
		ReturnStatus=0
		Message$="LINE DOES NOT UPDATE STOCK - CANNOT LINK TO PO"
		Goto POLinkDone
	end if
	if not(rol.QtyBO)
		ReturnStatus=0
		Message$="NOTHING BACK ORDERED - CANNOT LINK TO PO"
		Goto POLinkDone
	end if
	call dxget("PO", tmp$)
	PO = tmp$
	if not(po)
		ReturnStatus=0
		Message$="PO TO LINK NOT SPECIFICED"
		Goto POLinkDone
	end if
	call dxget("POLINE", tmp$)
	POLine = tmp$
	if not(POLine)
		ReturnStatus=0
		Message$="PO LINE TO LINK NOT SPECIFICED"
		Goto POLinkDone
	end if
	k_pol$ = PO using "######"
	k_pol$[7] = POLine using "###"
	r_pol=filegetpoline(e$,ch_pol,"=",1,k_pol$,pol.,1)
	clear e$
	If r_pol<=0
		ReturnStatus=0
		Message$="CAN'T READ PO LINE RECORD"
		Goto POLinkDone
	end if
	if pol.Status <> 1
		ReturnStatus=0
		Message$="PO LINE STATUS NOT OPEN"
		Goto POLinkDone
	end if
	if (pol.SalesOrd) ! POSSIBLY already linked, make sure
		tmp$ = " ",tmp$
		tmp$[1,6] = pol.SalesOrd using "######"
		tmp$[3,9] = pol.SalesOrdLine using "###"
		search #OLC,2,1;tmp$,r,e
		if not(E)
			ReturnStatus=0
			Message$="PO LINE ALREADY LINKED"
			Goto POLinkDone
		end if
	end if
	pol.SalesOrd = rol.OrdNum
	pol.SalesOrdline = rol.LineNum
	write record #ch_pol,r_pol,0;pol.;
	rol.PONum = pol.PONum
	write record #OLC,OLR,0;rol.;
	POLinkDone: ! finished
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
  else
    include "src/callsuberr.inc"
 end try
end sub ! LinkPOLine
! 
!--------------------------------------------------------------------

function getbopolink$()
! see if back orders can be linked to PO on this OT
  Try
	Dim f$[20],APOBOFlag$[1]
	Dim 1%,APOBO
	APOBOFLag$="N" ! as default
	IF P61$[121,121]<>"Y" exit function APOBOFLag$
	if source<>201 and source<>208 exit function APOBOFLag$! Only orders, not inquiry
	if rol.PONum exit function APOBOFLag$ ! already linked to PO
	if rol.TOrderNum exit function APOBOFLag$ ! already on transfer order
	if ros.Status=32 exit function APOBOFLag$ ! not for credits
	! now in sordtype file
	ch_sot=findchannel()
	F$="3/SORDTYPE"+Str$(IntCo) \ ROpen #ch_sot,F$
	Key1$=" ",Key1$
	Key1$=roh.OrdType using "##"
	search #ch_sot,2,1;Key1$,r_sot,E
	if not(e)
		read #ch_sot,r_sot,52;APOBO;
		IF APOBO=1 APOBOFLag$="Y" ! ALLOWED
	end if
	Try Close #ch_sot Else Rem
  else
    include "src/callsuberr.inc"
  end try
end Function APOBOFLag$
!--------------------------------------------------------------------------------

sub Check_If_SO_Linked_To_PO(TROH. as roh, trol. as rolnew,trot. as rot)
  try
	DIM 1%,POFLAGS[11]
	DIM 3%,X2
	dim k_pol$[50]
	dim pol. as poline
	
	if debugdetail
		dmsg$="Check SO link to PO" \ Call updatelog(debug)
	Endif
	ch_pol = openfile(2432,IntCo) \ if ch_pol = -1 Error 42
	ReturnStatus=1
	Message$="OK"
	Credit=0 \ if Trot.Status=22 let Credit=1 ! instead of roh.status check
	if Credit
		!ReturnStatus=99 ! say checking is ok
		!Message$="NOT VALID FOR CREDITS"
		Goto chkPOLinkDone
	end if
	if not(rol.ponum)
		ReturnStatus=1
		Message$="PO LINK NOT SPECIFIED"
		Goto chkPOLinkDone
	end if
	k_POL$ = " ",K_POL$
	k_pol$[1,6] = Trol.ponum using "######"
	DO
		r_pol=filegetpoline(e$,ch_pol,">",1,k_pol$,pol.,1)
		clear e$
		IF r_POL<=0 EXIT DO
		if VAL(K_POL$[1,6])<>Trol.ponum EXIT DO
		IF 	pol.SalesOrd=TROH.ordnum and pol.SalesOrdline=TROL.LINENUM
			!check flags
			!LET X2=pol.flags ! ! REM UNPACK pol.Flags TO FLAGS[x] 
			!FOR K=0 TO 11                     
			!	LET POFLAGS[K]=SGN(FRA(X2/2)) \ LET X2=INT(X2/2) 
			!NEXT K
			!Closedshort=flags[1]
			!if pol.status=3 let closed=99
			IF POL.STATUS<>3
				ReturnStatus=0
				Message$="SO LINKED TO PO "+Trol.ponum
				if custom_customer$="ACME" or custom_Customer$="WENELSON"
					CALL dxget ("CONFIRMDELETE",tmp$)
					if rtrim$(tmp$)<>""
						let returnstatus=1
					else
						let returnstatus=2
						let message$=message$+"Press OK to Delete "
					endif
				endif
				EXIT DO
			ENDIF
		end if
	LOOP
	CHKPOLinkDone: ! finished
	try close #ch_pol else rem
 else
    include "src/callsuberr.inc"
 end try
end sub ! Check_If_SO_Linked_To_PO
! 
!--------------------------------------------------------------------
Sub OLineCopy()
!! get order or invoice to copy all lines from.
 Try
	ErrFlag=0;Message$="OK";returnstatus=1
	if p61$[111,111] = "Y" ! CPI
		returnstatus=0
		Message$="This feature is not compatible with CPI"
		goto OCPLNDone
	end if
	dim k1$[60],HldMessage$[1000]
	Dim 1%,CPNotes,cpyln,crefln
	Dim 3%,CRefNO,cpordnum,cpinvnum
	Dim 3%,rec_roh,rec_uac,S9[20]
		if debugdetail
			dmsg$="Start Line Copy to Order" \ call updatelog(debug)
		Endif
		Call dxget("ORDERID",tmp$)
		X2=tmp$
		if x2<=0 or x2>999999 or fra(x2)
			returnstatus=0
			Message$="INVALID ORDER NUMBER"
			goto OCPLNDone
		Endif
		OrderNo=X2
		OHR=GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh.,ros.,rot.)
		e$=""
		If OHR<=0 ! no order found
			Let message$="ORDER # NOT FOUND"
			Let ReturnStatus=0
			goto OCPLNDone
		Endif
		! quick check of lines (if any it FAILS)
		k1$=" ",k1$;k1$=orderno using "######"
		k1$[7]=""
		search #olc,2,1;k1$,R,E
		if not(e) ! found lines!!
			Let message$="ORDER HAS LINES ALREADY - NO COPY"
			Let ReturnStatus=0
			goto OCPLNDone
		Endif
		IF E>1
			Let message$="ORDER LINES HAS SE "+STR$(E)!
			Let ReturnStatus=0
			goto OCPLNDone
		Endif
		if action$="LINECOPYI"
			Call dxget("CPINVNUM",tmp$)
			x3=tmp$
			If X3<0 or fra(X3) ! can be zero
				returnstatus=0
				Message$="INVALID INVOICE NUMBER TO COPY"
				goto OCPLNDone
			Endif
			let cpinvnum=x3
		Else
			cpinvnum=0
		endif
		if action$="LINECOPYO"
			Call dxget("CPORDNUM",tmp$)
			x3=tmp$
			If X3<0 or fra(X3) ! can be zero
				returnstatus=0
				Message$="INVALID ORDER NUMBER TO COPY"
				goto OCPLNDone
			Endif
			cpordnum=x3
		Else
			cpordnum=0
		Endif
		cpyln=0
		!call dxget("CPYLN",tmp$) ! future use? copy all lines for now
		!let x2=tmp$
		!if x2<0 or x2>999 or fra(X2)
		!	returnstatus=0
		!	Message$="INVALID LINE NUMBER TO COPY"
		!	goto OCPLNDone
		!Endif
		!cpyln=x2
		call dxget("CPNOTES",tmp$) ! COPY ROLTAG NOTES y/n
		cpnotes=0 \ if UCase$(Trim$(tmp$))="Y" let cpnotes=1
		! That's all requested for now! START CALL
		clear DList$[]
		clear s9[]
		clear fchan[]
		If cpordnum=0 and cpinvnum=0 ! no copy from #??
			returnstatus=0
			Message$="NO REFERENCE NUMBER TO COPY ENTERED"
			GOTO OCPLNDone
		Endif
		! send any open channels
		fchan[0]=ctlc
		fchan[1]=OHC
		fchan[2]=OSC
		fchan[3]=OTC
		fchan[4]=OLC
		fchan[5]=NSC
		fchan[6]=LPC
		fchan[7]=0 ! ch_ar
		fchan[8]=CCC
		fchan[9]=PRC
		fchan[10]=PWC
		if cpordnum<>0 let mode=1 ! order
		if cpinvnum<>0 let mode=2 ! inv
		clear s9[]
		s9[0]=OrderNo;s9[2]=OHR;s9[4]=201
		s9[6]=cpnotes
		if cpyln Let s9[8]=cpyln else let S9[8]=-1 ! >0=copy the one line, -1=all lines
		if mode=1 let s9[1]=cpordnum else let s9[1]=cpinvnum
		rec_roh=OHR;rec_uac=SCR
		call ordcpinv(e$,Intco,fchan[],s9[],rec_uac,rec_roh,returnStatus,Message$,DList$[],row,tmpcnt,mode,roh.,ros.,rot.)
		if returnstatus<>1 goto OCPLNDone ! some issue occurred - no proceed
		HldMessage$=Message$ ! ok - read data and pass to existing new line create calls!
		NumProds=DList$[0] ! line zero = number of lines
		if NumProds<=0 
			returnstatus=0
			message$="No lines on selected reference to copy"
			goto OCPLNDone
		endif
		! now - set up like setnewprodline and call off to create new line
		if cpnotes
			if mode=2 ! history
				cpITc = openfile(-9939,intco) \ if cpITC=-1 let cpnotes=0 ! no file - no copy
			endif
			CPRTC= OpenFile(9950,IntCo)
			if CPRTC=-1 ! no file
				if CPitc>0 Try Close #CPITC Else Rem ! close ordtag before exit
				cpnotes=0 ! no file - no copy
			Endif
			! if mode=1 let itc=rtc ! both orders
		endif
		
		clear list$[]
		ELFlag=0 ! NOT EXISTING LINES
		List$[0]=bsdel$,"PRODUCTDETAIL",fdel$
		call MainDtlHdr() ! set webstr$ for main header
		List$[1]=WebStr$
		Row=2;tmpcnt=maxcnt
		! second list 
		slist$[0]=bsdel$,"OT15LIST",fdel$  ! key is PRODID
		SList$[1]="PRODID",fdel$,"ORDERID",fdel$,"LINE",fdel$,"OPENQTY",fdel$,"UM",fdel$
		row2=2;tmpcnt2=maxcnt
		ReturnStatus=1;Message$=""
		for ld=1 to numprods
			tmp1$=DList$[ld] ! load all 500 chars into tmp1$
			Let PROD$=UCase$(tmp1$[1,12])+Blank$
			If prod$[1,3]="+  " OR PROD$[1,6]="ZNSTK "! it's nonstock
				prod$="Z ZZZZZZZZZZ"
			Endif ! will not have um or qty for messg or nonstk?
			let tmp$=RTrim$(Prod$)
			if tmp$="" goto CPDPDone ! no product - bypass
			tmp$=tmp1$[21,31]
			Let SQty=tmp$ ! in sum units
			if sqty<=0 goto CPDPDone ! gotta have order qty
			V3[3]=SQty;v3[4]=0;v3[5]=SQty ! v3[] used various places  order,bo,ship
			tmp$=tmp1$[32,39]
			Let SUM=tmp$
			CPRec=tmp1$[40,50] ! line rec copied (if needed - check mode for curr/hist)
			tmp$=tmp1$[51,55]
			LPType$=UCase$(rtrim$(tmp$))
			nonstk=0 \ if lptype$="NSTK" or lptype$="CNSTK" let nonstk=1
			if nonstk ! get venditem?
				prod$=UCase$(tmp1$[1,20])+Blank$
			endif
			If CPNotes
				if mode=1 ! need copy line data!
					read #OLC,CPRec,4;x2;
					read #OLC,CPRec,12;CRefLn;
					CRefNo=x2 ! order
				Endif
				if mode=2 ! copy line data=hist
					ILC=Openfile(-1184,Intco)
					Read #ILC,CPRec,12;CRefln;
					read #ILC,CPRec,518;CRefno; ! invoice
					Try close #ILC Else Rem
				Endif
			endif
			if nonstk ! additional data needed!!
					tmp$=tmp1$[56,56] ! last price file used
					lpnstk=0
					if UCase$(RTrim$(tmp$))="C" let lpnstk=1
					if UCase$(RTrim$(tmp$))="S" let lpnstk=2 ! shiplist
					tmp$=tmp1$[60,69] ! last price rec
					LPREC=tmp$
				if lprec<=0 ! no last price record (was never accepted?)
					!goto CPDPDone ! nonstk requirement!!
					! so copy from order/hist in here? WILL also NEED SEND new LINE!!!
					call CPNSTKLINE() ! copy from line (no nonstk)
					Goto BYPSPRD ! continue with roltag
				Endif ! it may be due to only in Open order (never accepted) 
			Endif
			Call GetNewProdDtl(e$,List$[],tmpcnt,Prod$,Sqty,SUM,OHR,SHQty,BOQty)
			If e$<>""  ! a problem!
				Message$=Message$+Prod$+E$+"  " ! send prod & reason
				ReturnStatus=0
			Endif
			cust=roh.CustNum
			If not(credit) call getot15list(e$,SList$[],row2,tmpcnt2,Cust,Prod$,SUM)
			BYPSPRD: ! BYPASS PRODUCT STUFF (Still copy notes!)
			if cpnotes ! wants roltag copy
				if mode=2 let chanfrom=0-CPITC else chanfrom=CPRTC ! <0 = histfile
				chanto=CPRTC;ordfrom=CRefNo;linefrom=CRefLn
				ordto=OrderNo;lineto=rol.linenum;L2=12 ! always order not credit ! was rol.status
				Call "mxordtagcp.dl4",chanfrom,chanto,ordfrom,linefrom,ordto,lineto,L2,IntCo
			Endif
		CPDPDone: ! bypass
		Next LD ! next sent prod,qty,um
		List$[row]=esdel$
		e$=""
		call AddToStr(e$,rstr$,List$[])
		Slist$[row2]=esdel$
		If Not(Credit) call addtostr(e$,rstr$,SList$[]) ! SEND NEW OT15 SECTION!!****
	    ! If Not(Credit) call addtostr(e$,rstr$,tList$[]) ! SEND NEW NO LASTPRC SECTION!!****
		if cpnotes
			Try Close #CPRTC Else Rem
			if mode=2 Try Close #CPITC Else Rem
		endif
		!
		OCPLNDone: ! status section  
		if returnstatus=1 and rtrim$(message$)="" let Message$=HldMessage$
		Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)                 
		Call AddToStr(e$,rstr$,WebStr$)                                        
		Call SetOutPut(e$,rstr$)  
		if debugdetail
			dmsg$="End Copy "+Str$(s9[1])+" to ORD "+Str$(Orderno)+" "+Message$ \ call updatelog(debug)
		Endif
 else
    include "src/callsuberr.inc"
 end try
end sub ! OLineCopy
! 
!--------------------------------------------------------------------
Sub CPNSTKLINE()
! copy a nonstock line from elsewhere
  Try
	Dim k1$[60]
	dim nrol. as rolnew
	Dim cnstk. As sproddesc 
	dim tax. as taxcode
	! as there is no record of this nonstock in lastprice - COPY FROM the line?
	If CPRec<=0 goto CPNSDone ! no line to copy (order/history)
	If mode=2 ! Invoice - there isn't a Nonstock invoice history!!  THERE IS NOW!!
		ILC=Openfile(-1184,Intco) \ if ilc=-1 goto CPNSDONE
		let NOLC=ILC ! so same code is used
		INSC=OpenFile(-9935,Intco) \ if insc=-1 goto cpnsdone
		let ninsc=insc ! 4/sprddesch#
	Endif ! order
	if mode=1 let NOLC=OLC;NINSC=NSC ! set to order chans!
	read record #NOLC,CPRec,0;nrol.; ! original order data
	if mode=2 if ilc>0 try close #ILC else rem ! no more need of inv hist line?
	if nrol.NStkItem=0 ! danger - not nonstock!!
		returnstatus=0;message$="Can not copy. Not a Non-Stock Product!"
		goto CPNSDONE
	Endif ! of not Z prod / abort
	NSR=nrol.PDRecNum
	if mode=1 ! as only current order has data!
		Read Record #NInsc,nsr,0;cnstk.; ! original sproddesc data
	else ! invoice - clear it
		clear cnstk.
		K1$=" ",k1$;k1$=nrol.InvNum USING "##########"
		IF NROL.STATUS=12 LET K1$=NROL.OrdNum USING "##########"
		K1$[11]=NROL.LineNum USING "###"
		SEARCH #NINSC,2,1;K1$,R[88],E
		IF NOT(E) ! OKAY
			READ RECORD #NINSC,R[88],0;CNSTK.;
		ENDIF
		TRY CLOSE #NINSC ELSE REM ! no longer need it
	endif
	! set/reset new line's data
	nnsline=getnxtline(orderno) ! next new line number
	nrol.LineNum=nnsline
	! get new tax for cust/prod
	let prodkey$="Z ZZZZZZZZZZ" ! let's see if z item is on file!
	PRR = filegetprod(e$,PRC,"=",1,Prodkey$,PR.)
	if prr<=0
		returnstatus=0;message$="Can not update. Non-Stock Default Product not set up!"
		goto CPNSDONE
	Endif ! of no Z prod / abort
	! set or reset new line data
	nrol.OrdNum=roh.OrdNum
	nrol.Whse = roh.wh
	nrol.currid = roh.currid
	nrol.currfact = roh.currfact
	nrol.PrevQtyShip=0 ! new line!
	nrol.PrevQtyBill=0
	nrol.QtyShip=nrol.QtyOrd
	nrol.QtyBO=0
	nrol.LinePrint = 0 ! not printed             
	nrol.PrintDate = 0                            
	nrol.PrintTime = 0
	nrol.PONum=0;Credit=0 ! we aren't copying po's or credit's!!
	clear cnstk.spare$
	if p61$[76,76]="Y" and NOT(CREDIT) ! auto bo nonstk
		  if custom_customer$="HTBERRY" or roh.ordtype<>2 ! per group - not on DIRECT
			if roh.ordtype<>15  ! task42215
			   let nrol.QtyBO=nrol.QtyOrd;nrol.QtyShip=0 ! bo=ord,ship=0
			endif
		  Endif
	Endif
	! set up nstk rec
	! set up / add nonstk                                           
		cnstk.OrdNum = nrol.OrdNum                                       
		cnstk.LineNum = nrol.LineNum  
		cnstk.InvNum=0
		!nstk.OrdLineRec not known yet                                  
		cnstk.Desc1$ = nrol.Desc1$                                       
		cnstk.Desc2$ = nrol.Desc2$                                       
		cnstk.PSlsCat = nrol.PSlsCat                                     
		! nstk.QtyShip  nstk.UnitCost  nstk.UnitPrice                   
		nrol.ProdCode$ = roh.OrdNum Using "######"                      
		nrol.ProdCode$ = nrol.ProdCode$ + "-" + nrol.LineNum Using "&&&"
		nrol.ProdCode$ = nrol.ProdCode$ + Blank$                        
		cnstk.ProdCode$ = nrol.ProdCode$                                 
		cnstk.ComdtyCode$ = nrol.ComdtyCode$                             
		cnstk.Unused$ = Blank$                                           
		cnstk.SpareNU$ = Blank$                                          
		clear cnstk.spare$ ! dl4 fix!cnstk.Spare$ = Blank$                                            
		nsr = fileupdatesproddesc(e$,nsc,"a",0,cnstk.) 
		If nsr > 0                                                    
			 nrol.PDRecNum = nsr 
		Else                                                          
			 e$ = "NONSTOCK " + nrol.ProdCode$ + " FILE NOT ADDED"       
		End If
	if prr>0 ! get what tax data is needed
			K1$=roh.CustNum Using "######"
			ProdKey$=nrol.ProdCode$
			ProdKey$=nrol.VendItemCode$ ! as it's stored that way in lastprice
			Call TaxFlag(k1$,ProdKey$,ros.ShipCust,ros.ShipCode,rol.Dept,pr.TaxType,intco,roh.TaxCode,ros.ShipTaxType,Taxback)
			Nrol.TaxFlg=Taxback ! contains what's needed
			If P60$[42,42]<>"Y" ! has y/n only - get rate from header tax
				TaxNo=roh.TaxCode
			Else ! is a code
				TaxNo=nrol.TaxFlg
			Endif
			If TaxNo>0
				Tcc=Openfile(-2176,IntCo) \ if Tcc = -1 Error 42
				Read record #tcc,taxno,0;tax.;
				Close #tcc
			Else ! no taxcode
				clear tax.
			Endif
			nrol.TaxPct=tax.TaxRate
	Else
			returnstatus=0;message$="Can not add. Non-Stock Default Product not set up!"
			goto CPNSDONE
	Endif ! of got a Z prod / do tax
	Call setprtorol() ! set to rol. factors 
	call dolineextens()  
	! SPECIAL TYPE PROCESSING
	if roh.OrdType=8 or roh.OrdType=16 ! cons/trans - no price/cost
		nrol.UnitCost=0;nrol.CostOrigin=0;nrol.RebtContract=0
		nrol.UnitPrice=0;nrol.CutChrg=0;nrol.CutCost=0
		nrol.LineDisc=0;nrol.ExtOrdAmt=0;nrol.ExtShipAmt=0
		nrol.LineDiscPct=0;nrol.ExtCutChg=0;nrol.ExtCutCost=0
		nrol.ExtLoadShip=0;nrol.ExtLoadOrd=0;nrol.NetPrice=0
		nrol.TaxAmt=0;nrol.LoadUpchrg=0;nrol.UpChrg=0
	Endif
	If p61$[46,46]="Y" and Credit and roh.shiptype=3 ! price fix - no cost
		nrol.UnitCost=0;nrol.CostOrigin=0;nrol.RebtContract=0
		nrol.CutCost=0;nrol.ExtCutCost=0;nrol.ExtLoadShip=0;nrol.ExtLoadOrd=0
		nrol.LoadUpchrg=0
	Endif
	OLR = fileupdaterolz(e$,OLC,"a",0,nrol.)               
    clear e$              
	If OLR > 0 ! has to have a record!                           
			cnstk.OrdLineRec = OLR                                           
			If CREDIT Let x = -1 Else Let x = 1                             
			CNVTU[0] = 0;CNVTU[1] = nrol.UMSell;CNVTU[2] = 1                
			CNVTA = nrol.QtyShip
			Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)         
			cnstk.QtyShip = (Amount * x) ! store credits as neg (IN SELL UM!)
			CNVTU[0] = 0;CNVTU[1] = nrol.UMSell;CNVTU[2] = 2                
			CNVTA = nrol.UnitCost                                           
			Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)         
			cnstk.UnitCost = Amount ! nrol.UnitCost (SAYS IN sELL UM)        
			CNVTU[0] = 0;CNVTU[1] = nrol.UMSell;CNVTU[2] = 2                
			CNVTA = nrol.UnitPrice                                          
			Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)         
			cnstk.UnitPrice = Amount ! nrol.UnitPrice (IN SELL UM!)          
			cnstk.ExtShipAmt = (nrol.ExtShipAmt * x) ! store credits as neg 
			clear cnstk.Spare$ ! dl4 fix
			Write Record #nsc,nsr,0;cnstk.;  
	Else
		goto CPNSDONE ! no order line record!
	End If        
	If returnstatus<>0 and OLR>0 and not(credit) ! new nonstk line - send alert
		clear x2[]
		clear x3[]
		tmp$=""
		x2[1]=ctlc;x2[2]=OLC;x2[4]=OHC;X2[5]=OSC;X2[6]=OTC;x2[7]=CCC
		x2[8]=CUC ! x2[]=file channels
		X3[0]=21;x3[1]=Cnstk.Buyer;x3[2]=OLR;x3[3]=OHR
		x3[4]=V3[3];x3[5]=v3[4];x3[6]=v3[5] ! qty: ord,bo,ship (as entered)
		! x3=vars 0=alert,1=buyer,2=ordline,3=ordhead
		call "libalertproc.lib",x3[],x2[],tmp$
	Endif
	elflag=1 ! NOT NEW
	read record #OLC,OLR,0;rol.; ! re-read line rec with rol. names
	If P60$[44,44]="Y" AND olr>0
		clear etr.
		etr.EtAction=11 ! send action
		call EdttrkDO(nrol.,rol.) ! org,new
		if debugdetail
			dmsg$="Line Edittrack " \ Call updatelog(debug)
		Endif
	Endif ! of edit tracking
	Call LineMainDtl() ! generate/write list$ 
	CPNSDONE: ! send line back in List$[]
  else
    include "src/callsuberr.inc"
 end try
end sub ! CPNSTKLINE
! 
!--------------------------------------------------------------------