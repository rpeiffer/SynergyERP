! MX851 - bom entry / edit
!
! loadsave -w -n 100,10 -o prog/dxport/mx851.dl4 src/mx851.src
!
!
include "src/copyright.inc" ! dx
!
Rem MX851A
Rem NEW BOMFLE FILE LAYOUT
Rem 3 DIRECTORY X 8 WORDS \ 16 CHAR
!
! *********************** NOTE *******************
! THE LIMIT FOR PRODUCT RECORD IS 99999 (5 digits!)
! IF THE CUSTOMER HAS OVER 99,999 PRODUCTS - BOM WILL BOMB!!!
! *********************** NOTE *******************
!
Rem BEDIT Version: 2.2 OBJECT CODE     Created: APR  9, 2004  17:13:12
Rem /w/papermaster/r2002//usr/acct/txc/work/r2002/mfg/mx851a.src (univ2) [txc] {15228}
Rem  Copyright (c) 2004 Universal Business Systems, Inc.
Rem    **** ALL CHANGES MUST BE MADE IN SOURCE!!! ****
Rem
include "src/inc/fileprod.inc" ! product
!
External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus
!
External Lib "ubsfunc.dl4"
Declare External Sub GetCostLevels
Declare External Function ChkAltItem$
!
External Lib "libprod.lib"
Declare External Sub UMDLIST
!
Declare Intrinsic Sub InpBuf,String,FindF
!Option Default Dialect IRIS1
If Err 0 Gosub ERR_TRAP

Dim 1%,PFU1[20],CNVTU[2],3%,PFU2[6],CNVTA,A[33]
Dim 1%,COST_LEV[3],NXTPRD
Dim 1%,C3,D0,E,E1,E8,H,I,L9,S2[3],S9,X,Z9[31],SC,SR,2%,S[1000]
Dim 2%,A2[1],B[24],C2,C[24],E2,P9[1],R1,R2[3],R3,R5,S4,V,V1,V2,X1
Dim 2%,X2,X3,H1
Dim 3%,A1[24],A3,A5,L8,R4[10],R[40],S3,BMAMT,AMNT,COST,EXCOST
Dim A$[156],B$[33],F$[16],H$[30],H1$[30],I$[30],J$[20],K1$[30],K2$[16]
Dim K3$[30],K4$[30],K5$[45],N$[50],N1$[42],N2$[26],P$[156],P1$[156]
Dim N0$[30],P9$[50],U9$[1],V$[5],W$[20],W1$[20],X$[10],J4$[50],2%
Dim UM$[4],3%,WGHT,2%,C4[10],PF_B[24],FG_B[24],1%,ECOST,WHSE
Dim 1%,LM[1],WHLM[1],AVGCOST,3%,W3[24],PREC[1],WHMISC[6],PRPARC[3],PF_LOAD2
Dim K30$[40],RESP$[5]
Dim e$[500],buttonlist$[5,50],nextlist$[5,100] ! dx error handling variables
dim tmp$[800],tmp1$[800],tmp2$[800],Message$[200],WebStr$[2000]
dim action$[30],options$[30],userid$[8],3%,fdel$[10],rstr$[2000],bsdel$[10],esdel$[10],rdel$[10]
dim Action1$[30],Action2$[30],Blank$[20]	  \ Blank$=" ",Blank$
Dim List$[50,1500]
Dim 3% ! d
Def FNR(X) = Int((X) * 10000 + .5) * .0001

V = 0;maxcnt=50;tmpcnt=maxcnt
WHSE = 0
! call dxopen() ! use for standalone - normally from whmenu
Call getsession(e$,CTLC,options$,action$,userid$,intCO,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$,action1$,action2$)
! call dxsave(0,"tmp/851in.txt!")
call GetCostLevels(e$,Cost_Lev[],IntCO,UserID$)
FOR E1=2 TO 8                             
  READ X                                  
  IF X=-1 GOTO L_290                        
  READ #1,88,X;F$[1,16];                  
  OPEN #E1,F$                             
L_290: ! 
NEXT E1 
DATA -1,1792,1728,1744,656,-1,1104        
REM 1=CNTRL#                              
REM 3=PARTS,4=CCODES,5=PRODWH,6=BOMFLE,8=PARTSDESC 
Mat Read #1,19,50;P9$;
If P9$[6,6] = "Q" Let X1 = 1
If P9$[6,6] = "P" Let X1 = .01
Def FNP(X) = FNR(X * X1)
Dim pr. as prod
if userid$[1,4]="JIMS" ! x3=-101 ! 6057 or userid$[1,4]="JIMS" ! track EVERY WEB CALL!
	x=0
	getnxtsv: ! loop til not found
	tmp$="tmp/bomin"+Str$(x)+".txt"
	Call FindF(tmp$,FOUND)
	if found let x=x+1 \ goto getnxtsv ! til new one to save all web submits
	call dxsave(0,tmp$)
Endif
! came back from elsewhere (classic only)
!If C2 <= 0 Goto L_1000
!R = C2 \ S2[3] = 0 \ Gosub L_5170
!If K3$ = "COPY" Goto L_1070
!If K3$ = "DELETE" Goto L_1070
L_1000: R1 = 0
! my attempt at a serp style program

L_1010: ! restart (classic) !Print 'CS MH';
!Print @0,0;"BILL OF MATERIALS ENTRY/INQUIRY/EDIT";
!Print @50,0;"MX851 - REV 3.1";
!Print 'MD';

action1$=UCase$(RTrim$(action1$))
action2$=UCase$(RTrim$(action2$))
ReturnStatus=0
Message$="ACTION NOT FOUND"
if action1$<>"GETDLISTS" and action1$<>"PRODUM" ! don't need make item
	V = 0
	Gosub L_5000 ! main prod prompt ALWAYS ON SERP ! gotta have it on every call
	If C2>99999 ! max chars=5
		message$="Maximum Product Record reached!"
		goto outerr
	Endif
	r2=c2 ! L_4000 uses r2?
	gosub Loadsvar ! load up the s[1000]
	let lsvar=0
Endif
select case Action1$
	Case "GETDLISTS" ! all droplists				doc=BOM851 - GetDroplists.doc
		returnstatus=1
		message$="OK"
		clear list$[]
		list$[0]=bsdel$,"OPTIONAL",fdel$
		!OPTIONALS:  Y:yes, N:no, U:use only, No Make";
		list$[1]="ID",fdel$,"DESC",fdel$
		list$[2]="N",fdel$,"NO",fdel$
		list$[3]="Y",fdel$,"YES",fdel$
		list$[4]="U",fdel$,"USE ONLY, No Make",fdel$
		list$[5]=esdel$
		call AddToStr(e$,rstr$,List$[])
		clear list$[]
		list$[0]=bsdel$,"BLTYPE",fdel$
		list$[1]="ID",fdel$,"DESC",fdel$
		!TYPE: %:prct vol, Q:quantity, F:fixed, W:prct wgt   ";
		list$[2]="%",fdel$,"% of volume",fdel$
		list$[3]="Q",fdel$,"Quantity",fdel$
		list$[4]="F",fdel$,"Fixed Amount",fdel$
		list$[5]="W",fdel$,"% of weight",fdel$
		list$[6]=esdel$
		call AddToStr(e$,rstr$,List$[])
		!end of getdlists
	Case "PRODUM" ! umlist for a prod				doc=BOM851 - GetProdUMlists.doc
		returnstatus=1
		message$="OK"
		clear list$[]
		let V=-999 ! it's rm lookup!
		gosub l_5000 ! get prod
		read record #3,e2,0;pr.;
		CALL UMDList(e$,"QTY",3,E2,List$[],IntCo,Pr.)
		call AddToStr(e$,rstr$,List$[])
		! fall thru at end
	Case "GETBOM" ! also redisplay					doc=BOM851 - GetBOMLines.doc
		returnstatus=1
		message$="OK"
		! already got make item
		clear list$[]
		gosub L_1070
		List$[c3]=esdel$
		call AddToStr(e$,rstr$,List$[])
		! done
	Case "COPYBOM" ! copy from						doc=BOM851 - CopyBOMLines.doc
		returnstatus=1
		message$="OK"
		I$="C"
		goto L_8000

	Case "DELBOM"	! delete whole bom				doc=BOM851 - DeleteBOMLines.doc
		returnstatus=1
		message$="OK"
		I$="D"
		goto L_8500

	Case "SUBMITLINE" ! submit line					doc=BOM851 - SubmitBOMLine.doc
		returnstatus=1
		message$="OK"
		call dxget("SEQ",tmp$)
		let i$=Trim$(tmp$)
		Gosub L_2000 ! check/setup main (adds new rec if not found)
		if newseq Goto OutDone ! return +1 = OK so return=bail out
		! the below means record exists - get/write new data
		Gosub L_7700 ! chg seq?
		if s2[3]=1 or s2[1]=-2 ! message line
			gosub L_7400 ! new comment
		Else ! stock items
			gosub L_7200 ! new amnt
			gosub L_7600 ! new type
			gosub L_7500 ! new optional
			gosub L_7900 ! new UOM
		Endif
		! done
	Case "GETTOTALS" ! separate						doc=BOM851 - GetBOMTotals.doc
		returnstatus=1
		message$="OK"
		let I$="T" ! get only
		clear list$[]
		gosub L_1810 ! goes to L_1080
		call AddToStr(e$,rstr$,List$[])
		! done
	Case "NEXTBOM" ! next BOM						doc=BOM851 - GetNextBOM.doc
		returnstatus=1
		message$="OK"
		I$="N";NXTPRD=1;V=0
		gosub L_5000 ! get next make item (current sent)
		clear list$[]
		gosub L_1070 ! get bom for that item
		List$[c3]=esdel$
		call AddToStr(e$,rstr$,List$[])
		! done
	Case "UPDATETOTS" ! it's separate				doc=BOM851 - UpdateBOMTotals.doc
		returnstatus=1
		message$="OK"
		let i$="U" ! Update totals
		gosub L_1810 ! goes to l_1080 after avg update prompt
		! call AddToStr(e$,rstr$,List$[]) ! resend totals?
		! done
	Case "BOMSEQ" ! add/edit one line? (is the same as "SubmitLine")
		returnstatus=1
		message$="OK"
		call dxget("SEQ",tmp$)
		let i$=Trim$(tmp$)
		Gosub L_2000
		! return +1 = added OK
		call AddToStr(e$,rstr$,List$[])
		! done
	Case "DELSEQ" ! delete one line					doc=BOM851 - DeleteBOMLine.doc
		returnstatus=1
		message$="OK"
		call dxget("SEQ",tmp$)
		let i$=Trim$(tmp$)
		Gosub L_2000 ! get / setup vars - rtn+1=added a line?
		Gosub L_3500 ! delete this line
End select
OutDone: ! all done - send status
call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
call AddToStr(e$,rstr$,WebStr$)
call SetOutPut(e$,rstr$)
Goto OutEnd
! start of classic subs
L_1070: I$ = "A" ! redisplay
L_1080: V = 0 ! start of get or update totals
For S = 1 To 1000
  S[S] = 0
Next S
A3 = 0
If I$ = "U" Or I$ = "T" Goto L_1150 ! update or total
Gosub L_5800 ! screen layout / load main & line headers
L_1150: Mat Read #3,C2;P$;
R2 = C2
A5 = 0
Gosub L_4000 ! explode existing
If V Return ! on rm line
! Print " "
Read #3,C2;P$;
S2[3] = 0;S2[1] = 1
If I$ = "U" Or I$ = "T" Goto L_1320
If P1$[139,139] <> "M" Or C2>99999
	Message$="PURCHASED PART - - - - NO B.O.M. ALLOWED!"
	if c2>99999 let message$="MAXIMUM PRODUCT RECORD REACHED!"
	Returnstatus=0
	goto OutErr
	!If P1$[139,139] <> "M" Signal 3,20 \ Goto L_1010
Endif
L_1320: Rem
A1[14] = A1[1] + A1[2] + A1[3]
A1[15] = A1[4] + A1[5] + A1[6]
A3 = A1[14]
A3 = Int(A3 * 10000 + .5) / 10000
Mat Read #3,C2,156;FG_B;
If I$ = "T" Goto L_1500
E2 = C2 \ Gosub L_3800 ! read prod
For X1 = 1 To 3 \ COST = FG_B[X1] \ Gosub L_6900 \ FG_B[X1] = COST \ Next X1
COST = FG_B[14] \ Gosub L_6900 \ FG_B[14] = COST
L_1500: ! Print @0,21;'CE';
If I$ = "T" Gosub L_5600 \ Goto L_1730
If I$ = "A" Goto L_1730
Mat Read #3,C2;P$;
Mat Read #3,C2,156;FG_B;
For S9 = 1 To 7
  FG_B[S9] = A1[S9]
Next S9
FG_B[14] = A1[14]
FG_B[15] = A1[15]
FG_B[18] = A1[18]
If P$[139,139] <> "M" Goto L_1730
If Not(FG_B[14]) Goto L_1710
E2 = C2 \ Gosub L_3800
For X1 = 1 To 3 \ COST = FG_B[X1] \ Gosub L_6870 \ FG_B[X1] = COST \ Next X1
COST = FNR(FG_B[14]) \ Gosub L_6870 \ FG_B[14] = COST
If P9$[11,11] = "Y" Let FG_B[8] = COST
If AVGCOST Let FG_B[21] = COST
L_1710: Rem
Mat Write #3,C2,156;FG_B;
L_1730: A$ = N$
For S9 = 0 To 24
  A1[S9] = 0
Next S9
E8 = 0
Return ! from A or T or U
! If I$ <> "A" Goto OutEnd ! Goto L_1010 ! A=redisplay
L_1810: U9$ = "",U9$
!Print @0,21;'CE';@0,23;
NXTPRD = 0
L_1830: !Print "SEQ# OR (A:Redisplay,C:Copy,D:Delete,T:totals,E:End";
!If COST_LEV[1] > 1 Print ",U:Update Ttls";
!Print ") ";
!Print @0,22;"(N:next)  ENTER OPTION:   ";
!Input ""I$
If I$ = "N" Let NXTPRD = 1 !  \ I$ = "E"
If COST_LEV[1] < 2 If I$ = "U"  ! cannot do it
	!Goto L_1810
	returnstatus=0
	message$="You do not have Cost Update permission"
	goto OutErr
Endif
If I$ = "U"
  AVGCOST = 0
L_1835: !Input @0,21;'CE';"ADJUST AVERAGE COST? (Y/<N>) ";RESP$
  call dxget("UPDAVG",tmp$) \ RESP$=UCASE$(RTRIM$(tmp$))
  ! Call String(1,RESP$)
  If RESP$ <> "Y" And RESP$ <> "N" And RESP$ <> "" Goto L_1835
  If RESP$ = "Y" Let AVGCOST = 1
  !Print 'CS RB CR';"UPDATING FILE    PLEASE WAIT. . . "
End If 
!If I$ = "T" Print @0,21;'CE';"TOTALLING,  PLEASE WAIT . . ."
For S9 = 0 To 24
  C3 = 2
  A1[S9] = 0
Next S9
L_1900: If I$ = "U" Or I$ = "T" Goto L_1080
If I$ = "A" Goto L_1070 ! redisplay
If I$[1,1] = "C" Goto L_8000 ! copy
! If I$ = "E" Goto OutEnd ! Goto L_1010 ! end
! if i$="N" goto L_1010 ! is next bom (erp done in L_5000/L_1080)
If I$ = "D" Goto L_8500 ! delete
Message$="Missing Option";returnstatus=0
goto OutErr
!Gosub L_2000 ! seq?
!Goto L_1810 ! return and +1 used?
!I$ = "A" \ Goto L_1900
L_2000: Rem SRCH SEQ
V = I$;NewSeq=0
If V > 999 Let V = 0
If V < 1 Let V = 0
If Fra(V) <> 0 Let V = 0
If V = 0 ! bad #
	!Gosub L_6200 \ Return 
	returnstatus=0
	message$="Invalid # (1-999) only"
	goto OutErr
Endif
H = V \ R2[1] = 0 \ Gosub L_6000 ! build keys
!Gosub L_6240
F$ = " ",F$
J$ = B$ \ F$ = J$
Search #6,2,1;F$,R1,R2
If R2 = 0 Goto L_7000 ! found existing
L_2110: Search #6,3,1;F$,R1,R2
If R2 > 0 Goto L_2140 ! eof
If F$[15,16] <> B$[15,16] Goto L_2110 ! diff rev
If J$[1,9] = F$[1,9] Goto L_7000 ! found it
L_2140: Rem ! not found?
if action1$="DELSEQ" Return +1 ! DO NOT ADD NEW!! NONE FOUND - WE'RE DONE
Goto L_2920 ! it's new?
L_2300: Rem GET UM
If S2[1] = -2 Return 
UM$ = "ERR" \ If S2[0] > 0 Read #4,S2[0],10;UM$;
Return 
L_2320: Rem CHK U/M
Search #4,2,1;K2$,R6,E
If E Goto L_2400
Mat Read #4,R6,0;K2$;
If K2$[10,10] = "*" Goto L_2400 ! do not use this um?
For I = 0 To 7
  If PFU1[I] If R6 = PFU1[I] Return 1
Next I
Goto L_2400
L_2400: Rem NO GOOD
Message$="INVALID UNIT OF MEASURE!"
Returnstatus=0
Goto OutErr
L_2450: Rem U/M
CNVTU[0] = 0;CNVTU[1] = 0;CNVTU[2] = 3
!
Return 
L_2600: ! Print 'MU CR CL MU CL MU';
If I$[1,1] = "D" Return 
I$ = V2
!Gosub L_6240
! Print 'CR';
Return
Goto L_2000
L_2910: Rem NEW SEQ.
L_2920: !Print 'MU';
!Print 'CR';
!Gosub L_6240
V2 = V;S2[2] = 0;S2[3] = 0;S3 = 0;N2$ = " ",N2$
!Print @0,18;'CE';"SEQ. #=";V;
If S[1000] >= 999 let message$="TOO MANY ITEMS IN BILL OF MATERIAL. "
If S[1000] >= 999 let returnstatus=0 \ goto outErr ! Gosub L_6200 \ I$ = "D" \ Goto L_2600
H1$ = H$ \ N1$ = N$
Gosub L_5000 ! main prod prompt
Goto L_3040 ! does rtn & rtn +1? NOT ANYMORE (was null/END=rtn+1)
N$ = N1$ \ H$ = H1$ \ I$ = "D" ! no prod entered
Goto L_2600 ! return
L_3040: If R = C2 Gosub L_6200 \ goto Outerr ! \ Print 'MU'; \ Goto L_2910
N0$ = N$ \ N$ = N1$ \ H$ = H1$
N1$[1,27] = N$[1,12],N0$[1,12],"   "
R2[1] = R;NewSeq=1
H = V \ Gosub L_6000 ! build keys
N1$[25,27] = B$[7,9]
F$ = B$
If N0$[1,2] = "Z " Goto L_5400 ! enter Desc
K2$ = " ",K2$ \ If Not(PFU1[13]) Let I$ = "D" \ Goto L_2600
K2$[11,14] = "ERR " \ If PFU1[13] > 0 Read #4,PFU1[13],0;K2$;
N1$[28,30] = "   "
N1$[31,34] = P$[152,155]
N1$[35,35] = P$[156,156]
! Print Tab 48;'MU';" ######.####";"  ";K2$[11,14]
! Print Tab 48;'MU';" ";
! Input ""I$ ! BOMQTY in UM
call dxget("QTY",i$) \ i$=Trim$(I$)
! If I$ = "" Print ""
If I$ = "" ! 
 !	Let I$ = "D" \ Goto L_2600 ! done/return no add
	RETURNSTATUS=0
	Message$="NO QUANTITY ENTERED! Not added to BOM"
	goto OutErr
Endif
S2[1] = 1 ! DEFAULT IS QTY
If P9$[6,6] = "P" Let S2[1] = 0 ! % bom - ALL LINES %
S2[0] = PFU1[13] ! UM
R4[0] = I$
S3 = R4[0]
L_3210: ! continue 
If S2[3] = 0 Gosub L_5500 ! enter type
BMAMT = S3 \ Gosub L_6850 ! prdtn->base
Gosub L_6500 ! get a free rec
Return ! rtn & rtn +1
Write #6,S4;S3;
S2[0] = PFU1[13]
Mat Write #6,S4,6;N1$;
Mat Write #6,S4,48;S2;
Mat Write #6,S4,56;N2$;
Search #6,4,1;B$,S4,E
If E Gosub ERR_SEARCH
Search #6,4,2;K4$,S4,E
If E Gosub ERR_SEARCH
Search #6,4,3;W$,S4,E
If E Gosub ERR_SEARCH
! Print ""
S[V] = R
S[1000] = S[1000] + 1
Return 1 ! = added ok?
L_3500: Rem DEL LINE
Search #6,5,1;B$,R1,E
If E Gosub ERR_SEARCH
Search #6,5,2;K4$,R1,E
If E Gosub ERR_SEARCH
Search #6,5,3;W$,R1,E
If E Gosub ERR_SEARCH
Mat Write #6,S4;Z9;
E = 3
Search #6,1,0;F$,S4,E
If E Gosub ERR_SEARCH
S[1000] = S[1000] - 1
S[V] = 0
Goto L_2600 ! it's a return
L_3700: Rem READ PRODWHSE
K30$ = " ",K30$;K30$[1,12] = P$[140,151]
If Not(WHSE) Let K30$[13] = 1 Using "##" Else Let K30$[13] = WHSE Using "##"
Search #5,2,1;K30$,R[5],E \ If E > 1 Gosub ERR_SEARCH
If E = 1 Goto L_3770
Mat Read #5,R[5],78;W3;
Mat Read #5,R[5],800;WHMISC;
Mat Read #5,R[5],842;WHLM;
B[8] = W3[17];PF_LOAD2 = W3[14]
Return 
L_3770: Clear W3[]
Clear WHMISC[]
Clear WHLM[]
W3[0] = 0;WHMISC[0] = 0;WHLM[0] = 0
Return 
L_3800: Rem READ PROD
If S2[3] Return 
Mat Read #3,E2;P$;
Mat Read #3,E2,156;B;
Mat Read #3,E2,256;A;
Mat Read #3,E2,512;PFU1;
Mat Read #3,E2,554;PFU2; \ Mat Read #3,E2,620;LM;
Mat Read #3,E2,596;PRPARC; \ Mat Read #3,E2,894;C4;
Mat Read #3,E2,938;PF_LOAD2;
If Not(B[8]) Let B[8] = B[21]
If Not(B[8]) Let B[8] = B[10]
PREC[0] = E2;R[3] = E2
If PFU1[8] <= 0 Let PFU1[8] = PFU1[0]
If PFU1[13] <= 0 Let PFU1[13] = PFU1[0]
UM$ = "ERR " \ If PFU1[0] > 0 Read #4,PFU1[0],10;UM$;
If P9$[32,32] <> "Y" Goto L_3880
If WHSE Gosub L_3700
If WHSE And P9$[32,32] = "Y" Gosub L_69000
L_3880: If ECOST Gosub L_8300
A2 = B[8];ECOST = 0
Return 
Loadsvar: ! need this s[] loaded!
let lsvar=99
L_4000: Rem   EXPLOSION
S[1000] = 0
A$ = R2 Using "#####   0    0"
D0 = 1 \ I = 0
J$ = A$ \ F$ = A$
L_4050: Search #6,3,D0;F$,S4,E
If E > 2 Gosub ERR_SEARCH
If E Return 
If A$[1,5] <> F$[1,5] Return 
If F$[15,16] <> P1$[6,7] Goto L_4050
Read #6,S4;S3;
Mat Read #6,S4,48;S2;
Mat Read #6,S4,56;N2$;
If I$ = "U" Or I$ = "T" If S2[1] = -2 Goto L_4050
R4[0] = S3
J$[1,14] = F$[1,14]
if not(lsvar)
	If V If V$ = J$[6,9] Return 1
endif
S = J$[6,9]
S[S] = J$[10,14]
if j$[10,14]="    0" AND S2[1]=-2 let s[s]=-1
S[1000] = S[1000] + 1
if lsvar goto L_4050 ! load s[] only
If V Goto L_4050
Gosub L_4210
Goto L_4050
Return 
L_4210: If V Return 
E2 = J$[10,14];ECOST = 1
Gosub L_3800
If PFU1[13] If S2[0] <> PFU1[13] Gosub L_4900 \ S2[0] = PFU1[13]
Write #6,S4,48;S2[0];
If I$ = "U" Or I$ = "T" Goto L_4380
!If C3 < 18 Goto L_4370
!Input "\15\ENTER <CR>:continue, or E:end   "U9$
!If U9$ = "E" Gosub L_6240 \ Return 1
!Gosub L_5800 ! screen layout
L_4370: ! C3 = C3 + 1
L_4380: If S2[1] = -2 Let P$ = " ",P$;P$[9,34] = N2$[1,26];P$[140,141] = "Z " \ Goto L_4410
If C > A1[7] Let A1[7] = C
If B[7] > A1[7] Let A1[7] = B[7]
If B[8] Let A2 = B[8]
Gosub L_6800 ! base>prdtn
L_4410: If I$ = "U" Or I$ = "T" Goto L_4490 ! just the totals ma'am
!Print @0,C3;J$[7,9];@4,C3;P$[140,151]; ! line# / prodid
!If S2[2] = 1 Print @3,C3;"*"; ! optional
!If S2[2] = 2 Print @3,C3;"@"; ! nm? NEVER MAKE - USE ONLY (MAKE ITEM)
!Print @17,C3;P$[9,34]; \ If S2[1] = -2 Print "" ! desc
webstr$=J$[7,9],fdel$ ! seq
tmp$="N" \ if s2[1]=-2 let tmp$="Y" ! MESSAGE LINE
webstr$=webstr$,tmp$,fdel$,RTrim$(P$[140,151]),fdel$,RTrim$(p$[9,38]),fdel$
webstr$=webstr$,RTrim$(p$[63,92]),fdel$
tmp$="N" \ if s2[2]=1 let tmp$="Y"
if s2[2]=2 let tmp$="U"
webstr$=webstr$,tmp$,fdel$
R4[0] = S3
L8 = 0
If S2[1] = -2 ! message - null the rest
	webstr$=webstr$,fdel$,fdel$,fdel$,fdel$,fdel$,Fdel$
	!                type,amnt ,uom  ,fixed,cost ,ext
	List$[c3]=webstr$
	C3 = C3 + 1 ! \ Print @17,C3;P$[63,92]
	if c3>tmpcnt let tmpcnt=expandarray(e$,List$[])
	Goto L_4640 ! BYPASS all the rest
endif
!Print Using "######.####";@45,C3;BMAMT;
tmp$=" "
If S2[1] = -1 let tmp$="F"
If S2[1] = 0 let tmp$= "%"
If S2[1] = 2 let tmp$= "W"
If S2[1] = 1 let tmp$= "Q"
webstr$=webstr$,tmp$,fdel$  !bltype
webstr$=webstr$,LTrim$(BMAMT using "#######.####"),fdel$
K2$[11,13] = "ERR" \ If S2[0] > 0 Read #4,S2[0],0;K2$;
!Print K2$[11,13]; ! UOM
!If Not(COST_LEV[1]) Print "" \ Goto L_4490
!Print Using "######.#####"; Tab 60;COST
webstr$=webstr$,k2$[11,14],fdel$

L_4490: If S2[2] <> 2 If P9$[16,16] = "M" If P$[139,139] = "M" Let A2 = B[8] - B[3]
If A2 < 0 Let A2 = B[8]
If S2[2] <> 1 And (S2[1] = 0 Or S2[1] = 2) Let A5 = A5 + BMAMT
L8 = FNR((R4[0] * A2))
If (S2[1] = 0 Or S2[1] = 2) Let L8 = FNR(R4[0] * COST)
If S2[1] = 2 Let L8 = FNR((R4[0] * WGHT) * COST)
If S2[2] = 1 Let L8 = 0
If S2[1] = -2 Let L8 = 0 \ Goto L_4640
Gosub L_6920
If S2[2] <> 2 If P9$[16,16] = "M" If P$[139,139] = "M" Let L8 = L8 + B[3]
X1 = 1
If (S2[1] = 0 Or S2[1] = 2) Let X1 = .01
If S2[1] = 1 Let X1 = 1
L8 = FNP(L8)
If S2[2] = 1 Let L8 = 0
If I$ = "U" Or I$ = "T" Goto L_4600
!If Not(COST_LEV[1]) Print "" \ Goto L_4595
If S2[2] <> 2 If P9$[16,16] = "M" If P$[139,139] = "M" If B[3]
  !Print Using "###.####"; Tab 50;"(FIXED";B[3];")";
  webstr$=webstr$,"FIXED",B[3] using "###.####",fdel$
Else
	webstr$=webstr$,fdel$ ! not fixed
End If 
if not(cost_lev[1]) ! no cost sec
	webstr$=webstr$,fdel$,fdel$ ! cost & ext
Else
	webstr$=webstr$,LTrim$(COST Using "######.#####"),fdel$
	webstr$=webstr$,LTrim$(L8 Using "######.#####"),fdel$
Endif
!Print Using "######.#####"; Tab 67;L8
List$[c3]=webstr$
L_4595: C3 = C3 + 1 ! \ Print @17,C3;P$[63,92]
if c3>tmpcnt let tmpcnt=expandarray(e$,List$[])
L_4600: If S2[2] = 1 Return 
If S2[1] = -2 Let L8 = 0
If S2[2] <> 2 If P9$[16,16] = "M" If P$[139,139] = "M" Goto L_4670
If S2[1] = -1 Goto L_4820
If P$[152,155] = "MACH" Goto L_4770
If P$[152,155] = "LABR" Goto L_4770
L_4640: Rem COST*QTY
A1[1] = A1[1] + L8
Return 
L_4670: Rem MADE PART
Goto L_4640
Mat Read #3,E2,156;PF_B; \ If Not(PF_B[1]) Goto L_4640
A1[1] = A1[1] + FNR((R4[0] * PF_B[1]))
A1[2] = A1[2] + FNR((R4[0] * PF_B[2]))
A1[3] = A1[3] + PF_B[3]
A1[4] = A1[4] + FNR(R4[0] * PF_B[4])
A1[5] = A1[5] + FNR(R4[0] * PF_B[5])
A1[6] = A1[6] + PF_B[6]
A1[18] = A1[18] + PF_B[18]
Return 
L_4770: Rem MACH / LABR
X1 = 1 \ If (S2[1] = 0 Or S2[1] = 2) Let X1 = .01
A1[2] = A1[2] + FNP(R4[0] * A2)
If P$[152,155] = "MACH" Let A1[5] = A1[5] + R4[0]
If P$[152,155] <> "MACH" Let A1[4] = A1[4] + R4[0]
Return 
L_4820: Rem FIXED
A1[3] = A1[3] + L8
A1[6] = A1[6] + R4[0]
If P$[152,155] = "TIME" Let A1[18] = A1[18] + R4[0]
Return 
L_4900: Rem CHK U/M
For I9 = 0 To 7
  If PFU1[I9] If S2[0] = PFU1[I9] Return 1
Next I9
Return 
L_5000: Rem GET PROD
! V = seq # (RM) or NOT(V) = Main Prod
!If V Print @0,19;'CE';"PART # CODE...:";'CL';
!If V Print @0,22;'CE';"  ALL LISTS AVAILABLE, Z:message";@15,19;
!If Not(V) Print @0,2;'CE';"PROD CODE ...:";
If NXTPRD Let I$ = "N" \ Goto L_5040
!If Not(V) Print @0,22;'CE';" 'END' or <CR>:exit, LIST Option, or N:next";@14,2;
!Input ""I$
if not(V) call dxget("PRODID",tmp$)
if V call dxget("RMPRODID",tmp$) ! so it's diff
let tmp$=UCase$(RTrim$(tmp$))
let tmp1$=ChkAltItem$(e$,intCo,tmp$)
i$=tmp$ \ if RTrim$(tmp1$)<>"" let i$=tmp1$ ! found alt
L_5040: C3 = 2;NXTPRD = 0
!If V If I$ = "END" Return 1
!If V If I$ = "" Return 1
!If V Gosub L_6600 \ Goto L_5000 ! main prod prompt
If V Goto L_5100 ! rm item
!If I$ = "END" Goto OUTEND
!If I$ = "" Goto OUTEND
!Gosub L_6600 \ Goto L_5000 ! main prod prompt
!If Len(I$) > 12 Goto L_5000 ! main prod prompt
If Not(V) And I$ = "N" Goto L_6100 ! next make item
L_5100: If V If RTrim$(I$) = "Z" Let R = 0 \ Goto L_5240
if Len(I$)<1 let E=1 \ goto L_5160 ! no nulls allowed!
A$ = " ",A$
A$[1,Len(I$)] = I$
If A$ = "Z ZZZZZZZZZZ" Let E = 1 \ Goto L_5160
A$[13] = ""
Search #3,2,1;A$,R,E
If E > 2 Gosub ERR_SEARCH
L_5160: If E ! Gosub L_6200 \ Goto L_5000 ! main prod prompt
	let message$="PRODUCT NOT FOUND"
	let returnstatus=0
	goto outerr
Endif
L_5170: Read #3,R,8;H$;
E2 = R
if v=-999 return ! just get prodcode/record!
Gosub L_3800 ! read rec / get costs
If Not(V) Let H1 = PFU1[8]
If Not(V) Mat Read #3,R;P1$;
If V Gosub L_5310
N$ = P$[140,151]
! Print "  ";H$
L_5240: X1 = 1
If I$ = "Z" Let N$[1,12] = "Z              ";P$ = " ",P$;P$[140,151] = N$[1,12]
If V Goto L_5280
CNVTA = 1;CNVTU[0] = H1;CNVTU[1] = 0;CNVTU[2] = 5
Gosub L_6950
If A[5] = 0 Let A[5] = 1
WGHT = A[6] * AMNT / A[5]
L_5280: Rem
If Not(V) Let C2 = R
Return 
L_5310: Rem BETCO DUP CHECK
For I = 1 To 999
  If S[I] = 0 Goto L_5330
  If R = S[I] Goto L_5340
L_5330: Next I
Return 
L_5340: Rem DUP
Message$="ENTERED PREVIOUSLY, DUPLICATE PRODUCT!"
returnstatus=0
Goto OutErr
L_5400: Rem MESSAGE LINE - New seq
!Print @20,19;
Call dxget("DESC1",tmp$) \ let i$=RTrim$(tmp$) 
If I$ = "" Let I$ = "D" \ Goto L_2600 ! done/return
N2$ = " ",N2$
Gosub L_7450 \ Goto OutErr
N2$[1,26] = I$[1,26]
S3 = 0;S2[0] = 0;S2[1] = -2;S2[2] = 0;S2[3] = 1
PFU1[13] = 0
Goto L_3210
L_5500: Rem TYPE
!Print @40,21;'CE';"F:FIXED, %:% VOL, Q:QTY, W:% WGT";
!Print @46,20;'CL';@48,20;"TYPE: F,%,Q,W   ";
!Input Len 16385;""I$
Call dxget("BLTYPE",tmp$) \ let I$=UCase$(TRIM$(tmp$))
If I$ <> "F" If I$ <> "%" If I$ <> "Q" If I$ <> "W" 
	returnstatus=0
	message$="INVALID TYPE ENTERED"
	Goto OutErr ! L_5500
endif
S2[1] = 9 \ If I$ = "F" Let S2[1] = -1
If I$ = "%" Let S2[1] = 0
If I$ = "Q" Let S2[1] = 1
If I$ = "W" Let S2[1] = 2
If S2[1] = 9 ! 
	returnstatus=0
	message$="INVALID TYPE ENTERED"
	Goto OutErr ! L_5500
endif
If S2[1] = 2 If K2$[11,12] <> "LB" 
	Message$="MAIN BOM ITEM U/M MUST BE LB!" !  \ Signal 3,30
	Returnstatus=0
	goto Outerr
Endif
Return 
L_5600: Rem DISPLAY TOTALS
!Window Open @0,10; Size 80,12;
!Print 'CS';@0,2;
Clear List$[]
List$[0]=bsdel$,"BOMTOTALS",fdel$
webstr$="TOTPRCT",fdel$,"LONGLEAD",fdel$,"SETUP",fdel$
Webstr$=webstr$,"MATLCOST",fdel$,"MACHCOST",fdel$,"FIXEDCOST",fdel$,"TOTCOST",fdel$
webstr$=webstr$,"LABRTIME",fdel$,"MACHTIME",fdel$,"FIXEDTIME",fdel$,"TOTTIME",fdel$
webstr$=webstr$,"OLDLONGLEAD",fdel$,"OLDSETUP",fdel$
webstr$=webstr$,"OLDMATLCOST",FDEL$,"OLDMACHCOST",FDEL$,"OLDFIXEDCOST",FDEL$,"OLDTOTCOST",FDEL$
WEBSTR$=WEBSTR$,"OLDLABRTIME",FDEL$,"OLDMACHTIME",FDEL$,"OLDFIXEDTIME",FDEL$,"OLDTOTTIME",FDEL$
List$[1]=webstr$
If A5 
	webstr$=LTrim$(A5 Using "######.####"),"%",fdel$
Else
	webstr$=fdel$ ! must be pounds/qty
Endif
Webstr$=webstr$,LTrim$(A1[7] using "#####.###"),fdel$
!Print Tab 45;'ER';"\15\"; Tab 36;'MU';
!Print Tab 37;'BR';"TOTALS";'ER';
Webstr$=webstr$,LTrim$(A1[8] using "#####.####"),fdel$
A1[14] = A1[1] + A1[2] + A1[3]
A1[15] = A1[4] + A1[5] + A1[6]
A3 = A1[14]
A3 = Int(A3 * 10000 + .5) / 10000
If Not(COST_LEV[1]) 
	webstr$=webstr$,fdel$,fdel$,fdel$,fdel$
	!Print "" \ Goto L_5665
Else
	Webstr$=webstr$,LTrim$(A1[1] using "######.####"),fdel$
	webstr$=webstr$,LTrim$(A1[2] using "######.####"),fdel$
	webstr$=webstr$,LTrim$(A1[3] using "######.####"),fdel$ ! ;A1[1];A1[2];A1[3];
	webstr$=webstr$,LTrim$(A3 using "#######.####"),fdel$ ! total
Endif
L_5665: ! time stuff
Webstr$=webstr$,LTrim$(A1[4] using "######.####"),fdel$
webstr$=webstr$,LTrim$(A1[5] using "######.####"),fdel$
webstr$=webstr$,LTrim$(A1[6] using "######.####"),fdel$ ! ;A1[4];A1[5];A1[6];
webstr$=webstr$,LTRim$(A1[15] using "#######.####"),fdel$ ! ;A1[15]
Mat Read #3,C2,156;PF_B;
!Print "\15\"; Tab 42;'ER';"\15\";'MU';
E2 = C2 \ Gosub L_3800 ! for previous/"old"
For X1 = 1 To 3 \ COST = PF_B[X1] \ Gosub L_6900 \ PF_B[X1] = COST \ Next X1
COST = PF_B[14] \ Gosub L_6900 \ PF_B[14] = COST
webstr$=webstr$,LTrim$(PF_B[7] using "######.###"),fdel$ ! ; Tab 5;PF_B[7];
!Print Tab 38;'BR';"OLD";'ER';
webstr$=webstr$,LTrim$(PF_B[18] using "######.####"),fdel$ ! ; Tab 46;PF_B[18]
If Not(COST_LEV[1]) 
	!Print "" \ Goto L_5725
	webstr$=webstr$,fdel$,fdel$,fdel$,fdel$
Else
	webstr$=webstr$,LTrim$(PF_B[1] using "######.####"),fdel$
	webstr$=webstr$,LTrim$(PF_B[2] using "######.####"),fdel$
	webstr$=webstr$,LTrim$(PF_B[3] using "######.####"),fdel$ ! ;PF_B[1];PF_B[2];PF_B[3];
	webstr$=webstr$,LTrim$(PF_B[14] using "######.####"),fdel$  !;PF_B[14]
Endif
L_5725: ! time stuff
webstr$=webstr$,LTrim$(PF_B[4] using "######.####"),fdel$
webstr$=webstr$,LTrim$(PF_B[5] using "######.####"),fdel$
webstr$=webstr$,LTrim$(PF_B[6] Using "######.####"),fdel$ ! ;PF_B[4];PF_B[5];PF_B[6];
webstr$=webstr$,LTrim$(PF_B[15] using "######.####"),fdel$ ! ;PF_B[15]
! Print @0,Msc(34);'CE';"  PRESS <RETURN> WHEN READY  ";
List$[2]=webstr$
List$[3]=esdel$
!Input ""I$
I$ = "A"
!Print 'CS'
!Window Close 
Return 
L_5800: Rem HEADINGS
!Print 'CS MH';
!Print @0,0;"BILL OF MATERIALS EDIT";@50,0;"MX851 - REV 3.1";
let list$[0]=bsdel$,"MAIN PRODUCT",fdel$
let list$[1]="PRODID",fdel$,"DESC1",fdel$,"DESC2",fdel$,"REVLVL",fdel$,"UM",fdel$
!Print "  REV LVL ";P1$[6,7]
Read #4,H1,0;K2$;
!If P9$[26,26] = "Y" Print @29,3;P1$[63,92];
!Print @65,3;"STOCKING: ";K2$[11,14];
List$[2]=P1$[140,151],fdel$,RTrim$(H$[1,30]),fdel$,RTRIM$(P1$[63,92]),fdel$,P1$[6,7],fdel$,K2$[11,14],fdel$
List$[3]=esdel$
call AddToStr(e$,rstr$,List$[])
clear list$[]
List$[0]=bsdel$,"BOMLINES",fdel$
Webstr$="SEQ",fdel$,"MESSG",fdel$,"RMPRODID",fdel$,"DESC1",fdel$,"DESC2",fdel$
webstr$=webstr$,"OPTIONAL",fdel$,"BLTYPE",fdel$,"QTY",fdel$,"UMID",fdel$,"FIXED",fdel$
Webstr$=webstr$,"COST",fdel$,"EXT",fdel$
List$[1]=webstr$
!Print @0,4;"SEQ# MATERIAL      DESCRIPTION";
!Print Tab 51;"QTY /UM";
!If Not(COST_LEV[1]) Print "" \ Goto L_5880
!Print Tab 60;"UNIT COST";
!Print Tab 71;"EXT COST"
L_5880: L9 = 3
C3 = 2
Return 
L_6000: Rem BUILD DIR
B$ = " ",B$ \ K4$ = " ",K4$ \ W$ = " ",W$
B$[1,5] = C2 Using "#####" \ V$ = 10000 + H Using "#####"
V$ = V$[2]
B$[6,9] = V$[1,4] \ B$[10,14] = R2[1] Using "#####"
K4$[1,5] = B$[10,14] \ K4$[6,9] = B$[6,9] \ K4$[10,14] = B$[1,5]
K4$[15,16] = P1$[6,7];B$[15,16] = P1$[6,7]
If H = 0 Return 
V$ = 20000 - H Using "#####"
V$ = V$[2]
B$[17] = "" \ K4$[17] = "" \ W$[17] = ""
W$ = B$ \ W$[6,9] = V$[1,4]
Return 
L_6100: Rem NEXT ITEM (6122 says next make, rem it for NEXT item make or not)
A$ = P1$[140,151]
Search #3,3,1;A$,R,E \ If E = 2 Let EOF = 1 \ return ! Goto OUTEND
If E Gosub ERR_SEARCH
If A$ = "Z ZZZZZZZZZZ" Let EOF = 1 \ Return  ! Goto OUTEND
Mat Read #3,R,0;P1$;
If P1$[139,139] <> "M" Goto L_6100
I$ = A$
! Print @14,2;I$;
Goto L_5100
L_6150: Rem EOF - RESTART
P1$ = " ",P1$
Goto L_6100
L_6200: Rem ERROR ROUTINE
Message$="  INVALID"
returnstatus=0
goto outerr
!L_6240: Print 'MU CR CL MU';
Return 
L_6500: Rem GET FREE REC. #
E = 2
Search #6,1,0;F$,S4,E
If E = 0 Return 1
Message$="BOMFLE FILE ERROR"
returnstatus=0
goto outerr
Return 
L_6600: Rem DESC
!J4$ = I$
!If J4$[1,1] >= "0" If J4$[1,1] <= "9" Return 1
!If J4$[1,1] >= "A" If J4$[1,1] <= "Z" Return 1
!Call "MXPROD5",J4$,WH,CUST
I$ = J4$ \ Return 
L_6800: Rem BASE(S3) -> PRDTN
CNVTA = S3;CNVTU[0] = 0;CNVTU[1] = S2[0];CNVTU[2] = 5
If (S2[1] = 0 Or S2[1] = 2) Let AMNT = S3 \ Goto L_6810
Gosub L_6950
L_6810: If AMNT <= 0 Let AMNT = S3
BMAMT = AMNT
CNVTA = A2 \ CNVTU[0] = 0 \ CNVTU[1] = S2[0] \ CNVTU[2] = 2
Gosub L_6950
If AMNT <= 0 Let AMNT = A2
COST = FNR(AMNT)
Return 
L_6850: Rem PRDTN -> BASE UNITS
CNVTA = BMAMT;CNVTU[0] = S2[0];CNVTU[1] = 0;CNVTU[2] = 5
If (S2[1] = 0 Or S2[1] = 2) Let AMNT = BMAMT \ Goto L_6860
Gosub L_6950
L_6860: If AMNT <= 0 Let AMNT = BMAMT
S3 = AMNT \ Return 
L_6870: Rem STOCK -> BASE COST
CNVTA = COST \ CNVTU[0] = PFU1[8] \ CNVTU[1] = 0 \ CNVTU[2] = 2
L_6880: Gosub L_6950 \ If AMNT <= 0 Let AMNT = COST
COST = AMNT
Return 
L_6900: Rem BASE=>STK
CNVTA = COST;CNVTU[0] = 0;CNVTU[1] = PFU1[8];CNVTU[2] = 2
Goto L_6880
L_6920: CNVTA = B[3];CNVTU[0] = 0;CNVTU[1] = S2[0];CNVTU[2] = 2
Gosub L_6950 \ B[3] = AMNT
Return 
L_6940: Rem "====== unibasic 5+ logic

Return 
L_6950: Rem STD
If S2[3] = 1 Let AMNT = CNVTA \ Goto L_6990
Call "MXPRCONV5.DL4",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG,e$,rstr$
If FLAG Let E = FLAG \ Gosub ERR_SEARCH
AMNT = CNVTA
L_6990: Return 
L_7000: Rem EXST SEQ. #
J$[1,16] = F$[1,16]
S4 = R1
! Gosub L_5800 ! header / line flds
V1 = F$[10,14] \ R2[1] = V1
H = V \ Gosub L_6000 ! build keys
Read #6,S4;R4[0];
Mat Read #6,S4,48;S2;
Mat Read #6,S4,56;N2$;
If S2[3] = 1 Let P$[9,34] = N2$[1,26];P$[140,151] = "Z           " \ goto L_7055:
T9 = S2[1]
E2 = R2[1] \ Gosub L_3800 ! read prod
S3 = R4[0] \ Gosub L_6800 ! conv
L_7055: ! send one line
If action1$="DELSEQ" Return ! got it - delete it now
IF NOT(NEWSEQ) ! EXISTING...IS THIS THE SAME PRODUCT?
	let h=v;v=-999
	GOSUB L_5000 ! SEE WHAT'S SENT AS PRODUCT (just as a check!)
	let v=h ! reset seq
	if r>0 ! it's not a "Z" item
		Mat Read #3,R;P$;
	endif
	MAT READ #6,S4,6;N1$;
	IF N1$[1,12]<>P1$[140,151] OR N1$[13,24]<>P$[140,151]
		RETURNSTATUS=0
		MESSAGE$="Sequence "+Str$(V)+" is for a different product"
		goto outerr
	ENDIF
	If S2[3] = 1 Let P$[9,34] = N2$[1,26];P$[140,151] = "Z           " ! reset
ENDIF
Gosub L_2300 ! get UM (used elswhere)
Return ! rem this is single line send is wanted/needed!
! if we need a single line send - here it is (unrem L_5800 above)
!Print " 1)";J$[7,9]; Tab 8;P$[140,151]; Tab 21;P$[9,34];
webstr$=J$[7,9],fdel$ ! seq
tmp$="N" \ if s2[1]=-2 let tmp$="Y" ! MESSAGE LINE
webstr$=webstr$,tmp$,fdel$,RTrim$(P$[140,151]),fdel$,RTrim$(p$[9,38]),fdel$
webstr$=webstr$,RTrim$(p$[63,92]),fdel$
tmp$="N" \ if s2[2]=1 let tmp$="Y"
if s2[2]=2 let tmp$="U"
webstr$=webstr$,tmp$,fdel$
!If S2[3] = 1 Goto L_7093
If S2[1] = -2 or S2[3] = 1 ! message - null the rest
	webstr$=webstr$,fdel$,fdel$,fdel$,fdel$,fdel$,Fdel$
	!                type,amnt ,uom  ,fixed,cost ,ext
	List$[c3]=webstr$
	C3 = C3 + 1 ! \ Print @17,C3;P$[63,92]
	if c3>tmpcnt let tmpcnt=expandarray(e$,List$[])
	Goto L_7093 ! BYPASS all the rest
endif
!Print Using "######.####";@45,C3;BMAMT;
tmp$=" "
If S2[1] = -1 let tmp$="F"
If S2[1] = 0 let tmp$= "%"
If S2[1] = 2 let tmp$= "W"
If S2[1] = 1 let tmp$= "Q"
webstr$=webstr$,tmp$,fdel$  !bltype
webstr$=webstr$,LTrim$(BMAMT using "#######.####"),fdel$
!Print Using "2)#####.####"; Tab 48;BMAMT;" 3)TYPE ";
!If S2[1] = -1 Print "FIXED F";
!If S2[1] = 0 Print " PCTV %";
!If S2[1] = 1 Print " QTY  Q";
!If S2[1] = 2 Print " PCTW W";
webstr$=webstr$,UM$,fdel$
!Print @76,5;"4) "; \ If S2[2] = 0 Print "N";
!If S2[2] = 2 Print "U";
!If S2[2] = 1 Print "Y";
!Print @49,6;"5) ";UM$;
If S2[2] <> 2 If P9$[16,16] = "M" If P$[139,139] = "M" If B[3]
  !Print Using "###.####"; Tab 50;"(FIXED";B[3];")";
  webstr$=webstr$,"FIXED",B[3] using "###.####",fdel$
Else
	webstr$=webstr$,fdel$ ! not fixed
End If 
if not(cost_lev[1]) ! no cost sec
	webstr$=webstr$,fdel$,fdel$ ! cost & ext
Else
	webstr$=webstr$,LTrim$(COST Using "######.#####"),fdel$
	webstr$=webstr$,LTrim$(L8 Using "######.#####"),fdel$
Endif
!Print Using "######.#####"; Tab 67;L8
List$[2]=webstr$
L_7093: ! If S2[3] = 1 Print @0,7;"1:seq #, 2:comment"; \ Goto L_7095
let list$[3]=esdel$
Return
!L_7094: Print @0,7;"1:seq #, 2:amount, 3:type, 4:optional, 5:u/m";
!L_7095: Print @0,8;'CE';"ITEM # (DELETE) ";
!Input ""I$ 
!If I$[1,1] = "D" Print @0,5;'CE'; \ Goto L_3500 ! delete this line
!If I$ <> "" Goto L_7130
!I$ = "E"
!Gosub L_5800 ! screen layout
!Return 
L_7130: Rem Edit the line
C9 = I$
If C9 > 0 If C9 < 6 Goto L_7160
L_7145: !Print @0,8;'CE RB';
Goto OutDone ! L_7094
L_7160: Rem
If S2[3] = 1 If C9 > 3 Goto L_7145
If S2[3] = 1 If C9 = 2 Goto L_7400 ! only 1 & 2 valid (2=comment)
On C9 Goto L_7700,L_7200,L_7600,L_7500,L_7900
Goto L_7145
L_7200: Rem CHG QTY
Read #6,S4;S3;
Read #6,S4,48;S2[0];
call dxget("QTY",i$) \ i$=Trim$(I$)
if i$="" and bmamt let i$=Str$(BMAMT) ! keep same
If I$ <> "" Goto L_7265
goto L_7300 ! invalid entry ! I$ = "E"
!Print 'CL';
!Goto L_7055
L_7265: BMAMT = I$
If BMAMT < 0 Goto L_7300
! Print 'CR';
L_7280: Gosub L_6850 ! prdtn->base
Write #6,S4;S3;
V2 = V
Goto L_2600 ! done/return
L_7300: Gosub L_6200 ! invalid and exit
Goto L_2600 ! L_7094
L_7400: Rem NEW MESSG
!Print @0,9;'CE';"ENTER NEW COMMENT  ";
!Input Len (16384 + 26);""I$
Call dxget("DESC1",i$)
If I$ = "" let i$=N2$ ! Goto L_7055
Gosub L_7450 \ Goto OutErr
Goto L_7480
L_7450: Rem CHK
ReturnStatus=0;Message$="Invalid Characters Entered!"
For I = 1 To 26
  If I$[I,I] = "" Let I$[I,I] = " "
  If I$[I,I] < " " Return 
  If I$[I,I] > "~" Return 
Next I
returnstatus=1;message$="OK" ! back to ok
Return 1
L_7480: N2$ = I$[1,26]
Mat Write #6,S4,56;N2$;
V2 = V \ Goto L_2600 ! done/return
L_7500: Rem OPTIONAL
!Print @0,10;'CE';"  OPTIONALS:  Y:yes, N:no, U:use only, No Make";
!Print @0,9;'CL';"  IS THIS AN ''OPTIONAL'' ITEM? (Y/N/U)  ";
!Input ""I$
call dxget("OPTIONAL",tmp$) \ let i$=UCASE$(Trim$(tmp$))
If RTrim$(I$)<>"" !  = "" let i$=Str$(S2[2]) !!Goto L_7055
	If I$ = "U" Goto L_7540
	If I$ <> "Y" If I$ <> "N" Goto L_6200 ! L_7500
	L_7540: S2[2] = 0 \ If I$ = "Y" Let S2[2] = 1
	If I$ = "U" Let S2[2] = 2
	Write #6,S4,52;S2[2];
Endif
V2 = V
Goto L_2600 ! done/return
L_7600: Rem TYPE
!Print @0,9;'CE';"ENTER TYPE: %:prct vol, Q:quantity, F:fixed, W:prct wgt   ";
!Input ""K2$
call dxget("BLTYPE",tmp$) \ let k2$=UCase$(Trim$(tmp$))
If K2$ <> "" ! Goto L_7620
	!I$ = "E" \ Print 'CL'; \ Goto L_7055
	L_7620: ! 
	If K2$ <> "F" If K2$ <> "%" If K2$ <> "Q" If K2$ <> "W" Goto L_6200
	X2 = 9 \ If K2$ = "F" Let X2 = -1
	If K2$ = "%" Let X2 = 0
	If K2$ = "Q" Let X2 = 1
	If K2$ = "W" Let X2 = 2
	If X2 = 2 If UM$[1,2] <> "LB"
		!Print @0,20;'CE RB';"U/M MUST BE LB!" \ Signal 3,20
		!!If X2 = 2 If UM$[1,2] <> "LB" Print @0,20;'CE'; \ X2 = 9
		returnstatus=0
		message$="MAIN BOM ITEM U/M MUST BE LB!"
		goto outerr
	Endif
	If X2 = 9 Goto L_6200
	S2[1] = X2
	Write #6,S4,50;S2[1];
Endif
V2 = V
If T9 <> 0 And (S2[1] = 0 Or S2[1] = 2) Goto L_7280 ! T9=orig s2[1] - _7280=reconv
Goto L_2600 ! done/return
L_7700: Rem CHG SEQ #
!Print @0,9;'CE'
L_7720: !Print @0,9;"NEW SEQ.# ";
!Input ""I$ \ Print @0,9;
call dxget("NEWSEQ",tmp$) \ let i$=Trim$(tmp$)
If I$ <> "" Goto L_7740
Goto L_2600 ! L_7055 ! no change
L_7740: V2 = I$
If Fra(V2) <> 0 Goto L_7750
If V2 > 0 If V2 < 1000 Goto L_7760
L_7750: ! ALREADY LINE THERE!
Returnstatus=0
message$="Invalid Sequence entered!"
goto outErr:
!Mat Read #6,S4,6;N1$; ! ORIGINAL RECORD
!X=N1$[25,27]
!IF V2 AND X<>V2 ! NOT SAME AS IT WAS (IF SAME - IGNORE IT)
!	RETURNSTATUS=0
!	MESSAGE$="A SEQUENCE NUMBER ALREADY EXISTS AT "+STR$(V2)
!	GOTO OUTERR ! Gosub L_6200
!ENDIF
!Goto L_2600 ! L_7720
L_7760: ! CAN'T DEPEND ON THIS! yes it is now loaded!
If S[V2] <> 0 Goto L_7750
!Print " "
J$ = B$ \ K5$ = K4$ \ W1$ = W$
Mat Read #6,S4,6;N1$;
H = V2 \ Gosub L_6000 ! build keys
!TMP$=B$[1,9] ! JUST FGREC/SEQ
!CBOMLOOP: !
!SEARCH #6,3,1;TMP$,R9,E \ IF E GOTO SNSAME ! JUST FG/SEQ (MAY BE DIFF RM)
!!IF TMP$[1,9]<>J$[1,9] GOTO SNSAME ! DIFF PROD/LINE
!IF TMP$[15,16]=P1$[6,7] GOTO L_7750 ! 10-14=RMREC
!GOTO CBOMLOOP
SNSAME: ! 
Search #6,2,1;B$,R9,E ! SAME PROD/SEQ/RM/REV?
If Not(E) Goto L_7750 ! already one there
Search #6,4,1;B$,S4,E
If E Gosub ERR_SEARCH
Search #6,4,2;K4$,S4,E
If E Gosub ERR_SEARCH
Search #6,4,3;W$,S4,E
If E Gosub ERR_SEARCH
Search #6,5,3;W1$,R1,E
If E Gosub ERR_SEARCH
Search #6,5,2;K5$,R1,E
If E Gosub ERR_SEARCH
Search #6,5,1;J$,R1,E
If E Gosub ERR_SEARCH
N1$[25,27] = B$[7,9]
Mat Write #6,S4,6;N1$;
S[V2] = R2[1]
S[V] = 0
Goto L_2600 ! done/return
L_7900: Rem NEW UM
!Print @0,9;'CE';
!Print @0,9;"ENTER U/M or ''-'':list   ";
!Input ""K2$ \ If K2$ = "" Goto L_7055
call dxget("UMID",tmp$) \ let k2$=Trim$(tmp$)
!If Len(K2$) > 4 Print 'RB' \ Goto L_7900
!If K2$[1,1] = "-" Gosub L_2450
IF K2$="" LET K2$=UM$
If Len(K2$) < 4 Let K2$[Len(K2$) + 1] = "     "
let UM$=k2$[1,4]
Gosub L_2320 \ Let invum=1 ! Goto L_7900
let k2$=UM$[1,4]
If S2[1] = 2 If K2$[1,2] <> "LB" ! ) or invum=1 !_2320 exits if NG
  !Print @0,20;'CE RB';"MUST BE ''LB'' FOR % OF WEIGHT!";
  !Signal 3,20 \ Print @0,20;'CE'; \ Goto L_7900
  returnstatus=0
	message$="U/M MUST BE LB!"
  if invum let message$="INVALID U/M!"
	goto outerr
End If 
S2[0] = R6
Write #6,S4,48;S2[0];
V2 = V
Goto L_2600 ! done/return
L_8000: ! Print @0,20;'CE';"ENTER ASSEMBLY NUMBER TO COPY : ";
!Input ""I$
!If I$ = "" Goto L_1070
call dxget("COPYPROD",tmp$) \ tmp$=UCase$(RTrim$(tmp$))
let tmp1$=ChkAltItem$(e$,intCo,tmp$)
i$=tmp$ \ if RTrim$(tmp1$)<>"" let i$=tmp1$ ! found alt
K3$ = "COPY"
!Gosub L_6600 \ Goto L_8000
K3$ = " ",K3$
K3$[1,Len(I$)] = I$
Search #3,2,1;K3$,X2,E
If E or RTrim$(I$)="" !! Gosub L_6200
!If E Goto L_1830
	let message$="Product not found!"
	let returnstatus=0
	goto outerr
Endif
Mat Read #3,X2;P$;
If P$[139,139] = "M" Goto L_8140
let message$="Product is not a Make item"
let returnstatus=0
goto outerr
!Gosub L_6200
!Goto L_1830
L_8140: K3$ = " ",K3$ \ R = C2 ! check on existing prod
K3$ = R Using "#####   0    0" \ FLAG = 0
L_8160: Search #6,3,1;K3$,X3,E
If E > 2 Goto L_8200
If E Goto L_8220
X3 = K3$[1,5] \ If R <> X3 Goto L_8220
If K3$[15,16] = P1$[6,7] Let FLAG = 9
Goto L_8160
L_8200: ! already a bom for rev
returnstatus=0
Message$="A BOM already exists for product "+P1$[140,151]
Goto OutErr ! L_1830
L_8220: Rem WRITE BOM
If FLAG Goto L_8200 ! already a bom for the prod/revision
K3$ = "COPY"
C_7000: ! WHAT REV
MAT  READ #3,X2,0;P$;
!PRINT @0,20;'CE';"ENTER REVISION # TO COPY, <CR>:(";P$[6,7];")  ";
!INPUT ""K1$ \ IF K1$="" GOTO L_7100:
!IF LEN(K1$)>2 GOTO C_7000:
call dxget("COPYREV",tmp$) \ tmp$=RTrim$(tmp$)
if tmp$="" let k1$=p$[6,7] ! whatever's current
if tmp$<>"" let k1$=tmp$[1,2]
IF LEN(K1$)<2 LET K1$[LEN(K1$)+1]="  "
!IF K1$[1,1]<" " GOTO C_7000:
!IF K1$[2,2]<" " GOTO C_7000:
LET P$[6,7]=K1$[1,2]
C_7100: ! WRITE BOM
!PRINT 'CS'@13,13;"COPYING PLEASE WAIT"'RB'
!SIGNAL 3,10
LET K1$=" ",K1$
LET K5$[1,5]=X2 USING "#####"
LET K1$=X2 USING "#####   0    0"
C_7115: SEARCH #6,3,1;K1$,R3,E
IF E=2 GOTO C_7300:
IF E GOSUB Err_Search:
LET K3$=K1$
IF K5$[1,5]<>K3$[1,5] GOTO C_7300:
IF K1$[15,16]<>P$[6,7] GOTO C_7115: !!WRONG REV
LET H=K3$[6,9]
LET R2[1]=K3$[10,14]
GOSUB L_6000: ! build keys
GOSUB L_6500: ! GET FREE REC
GOTO C_7300: ! FAIL
GOTO C_7160: ! OK
! RETURN AND RETURN +1 USED!

C_7160: ! r3=ORIG , S4=NEW
MAT  READ #6,R3,0;S3;
MAT  READ #6,R3,6;N1$;
MAT  READ #6,R3,48;S2;
MAT  READ #6,R3,56;N2$;
LET N1$[1,12]=P1$[140,151]
LET N1$[36,37]=P1$[6,7]
MAT  WRITE #6,S4,0;S3;
MAT  WRITE #6,S4,6;N1$;
MAT  WRITE #6,S4,48;S2;
MAT  WRITE #6,S4,56;N2$;
SEARCH #6,4,1;B$,S4,E
IF E GOSUB Err_Search:
SEARCH #6,4,2;K4$,S4,E
IF E GOSUB Err_Search:
SEARCH #6,4,3;W$,S4,E
IF E GOSUB Err_Search:
GOTO C_7115:

C_7300: ! DONE
!PRINT 'CS'@13,13;"COPY COMPLETE !"'RB'
!SIGNAL 3,5
!LET K3$="COPY" \ GOTO L_425:
goto OutDone
D_7400: ! DOUBLE CHECK DELETE
!PRINT @0,20;'CERB';"WOULDN'T YOU RATHER JUST CHANGE REVISIONS? (Y/NO)  ";
!INPUT ""K1$ \ IF K1$="NO" GOTO D_7500:
!IF K1$<>"Y" GOTO D_7400:
!PRINT @0,20;'CE';"GOOD CHOICE! CHANGE REVISIONS IN THE PRODUCT FILE"
!SIGNAL 3,30
!GOTO OutEnd:

D_7500: ! DELETE ENTIRE BILL
LET K1$=" ",K1$ \ LET K1$=C2 USING "#####   0    0"
LET K5$=K1$[1,5]
D_7520: SEARCH #6,3,1;K1$,R3,E
IF E=2 GOTO OutDone
IF E GOSUB Err_Search:
IF K1$[1,5]<>K5$[1,5] GOTO OutDone
IF K1$[15,16]<>P1$[6,7] GOTO D_7520:
LET H=K1$[6,9] \ LET R2[1]=K1$[10,14]
GOSUB L_6000: ! bld index
IF B$[1,16]<>K1$[1,16] GOTO OutDone ! MUST BE same as initial key 
SEARCH #6,5,1;K1$,S4,E
IF E GOSUB Err_Search:
SEARCH #6,5,2;K4$,S4,E
IF E GOSUB Err_Search:
SEARCH #6,5,3;W$,S4,E
IF E GOSUB Err_Search:
MAT  WRITE #6,R3;Z9;
LET E=3
SEARCH #6,1,0;W$,R3,E
IF E GOSUB Err_Search:
GOTO D_7520:
! L_8240: Chain "MX851A1"
L_8300: Rem CALC LOADS FROM LOAD MARKUP
If P9$[32,32] = "Y" And WHSE > 0
  If WHLM[0]
    WH = WHSE;LTBL = WHLM[0];CNVTA = 0
    Gosub L_8405 \ If R[3] > 0 Let W3[17] = CNVTA;B[8] = CNVTA
  End If 
  If WHLM[1]
    WH = WHSE;LTBL = WHLM[1];CNVTA = 0
    Gosub L_8405 \ If R[3] > 0 Let W3[14] = CNVTA;PF_LOAD2 = CNVTA
  End If 
Else 
  If LM[0]
    WH = 0;LTBL = LM[0];CNVTA = 0
    Gosub L_8405 \ If R[3] > 0 Let B[8] = CNVTA
  End If 
  If LM[1]
    WH = 0;LTBL = LM[1];CNVTA = 0
    Gosub L_8405 \ If R[3] > 0 Let PF_LOAD2 = CNVTA
  End If 
End If 
Return 
L_8405: Rem CALL
OTYPE = 1
Call "MXLOAD5.DL4",OTYPE,WH,LTBL,PREC[],CNVTA,IntCo,e$,rstr$
Return 
L_8500: Rem DEL ENTIRE BILL
!Print @0,22;'CE RB';"DELETE ENTIRE BILL OF MATERIALS?  (YES/N)   ";
!Input ""K3$ \ If K3$ = "N" Goto L_1810
!If K3$ <> "YES" Goto L_8500
K3$ = "DELETE" \ Goto D_7400
Goto OutDone
L_69000: Rem ===== check/set warehouse with valid data
If P9$[32,32] = "Y" ! "warehouse pricing turned on
  X2 = W3[19] + W3[20] + W3[21] + W3[22] + W3[23] + W3[24]
  If WHPARC[1] Let C4[3] = WHPARC[1] Else If X2 Let C4[3] = 0
  For X2 = 20 To 25
    If Not(W3[X2 - 1]) Let W3[X2 - 1] = A[X2]
  Next X2
  If Not(WHLM[0]) And Not(W3[17]) Let WHLM[0] = LM[0]
  If Not(W3[17]) Let W3[17] = B[8]
  If Not(WHLM[1]) And Not(W3[14]) Let WHLM[1] = LM[1]
  If Not(W3[14]) Let W3[14] = PF_LOAD2
  If Not(W3[15]) Let W3[15] = B[21]
  If Not(W3[16]) Let W3[16] = B[10]
  If Not(W3[18]) Let W3[18] = C4[4]
  If Not(WHMISC[2]) Let WHMISC[2] = PRPARC[2]
  If WHPARC[0] Let B[22] = WHPARC[0]
  If Not(W2[3]) Let W2[3] = B[24]
End If 
Return 
OutErr: ! something entered wrong
call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
call AddToStr(e$,rstr$,WebStr$)
call SetOutPut(e$,rstr$)
End 
OUTEND: Rem EXIT
End
!Print 'CS'
Close 
!Chain "MX000"
End 
ERR_SEARCH: Rem                                            
ENUM = E;ELINE = Spc(16);CTERR = 0                         
If E = 5 Let CTERR = Err(8)                                
e$ = "RETURN STATUS",(E + (CTERR * .001))                  
e$ = e$,"/ STATEMENT",ELINE," IN PROGRAM " + Msc$(4)       
Error 11000
Rem {begin rtn.error.s}
ERR_TRAP: Rem *Error routine (escape trap)   V3.1 8/94 G.DOSCHER/REK
!
include "src/callmainerrnet.inc"
End
