!"serppoh" === description  synergy erp  purchase order entry/edit system
!
!loadsave -w -n 100,10 -o prog/dxport/serppoh.dl4 src/serppoh.src 
!
!****** includes ********
include "src/copyright.inc"
!
include "src/inc/sql_prod.inc" ! SQL defintions
!
include "src/inc/fileprod.inc" ! product
include "src/inc/fileordhead.inc" ! order header, order shipto, order rot
include "src/inc/filea80vm.inc" ! vendor file
include "src/inc/filecust.inc" ! customer
! prod desc key
include "src/inc/filepohead.inc" ! po header
include "src/inc/filepoline.inc" ! po lines file
include "src/inc/fileprodwhse.inc" ! prod warehouse
Include "src/inc/filepom.inc" ! purchase order message file
include "src/inc/filewhinfoz.inc" ! warehouse
! commodity code
include "src/inc/filenstkdesc.inc" ! non stock file
include "src/inc/filevendtag.inc" ! vendor tag file
include "src/inc/filerolz.inc" ! order line file
! Include "src/inc/filemiscchrg.inc" ! misc charge file
Include "src/inc/filepomiscchrg.inc" ! po misc charge file
! deals
! wh location
! spolot
! sprodlot
! sordlot
! altvend
include "src/inc/fileprtdefault.inc" ! port default
Include "src/inc/filespecmsg.inc" ! special message  file
include "src/inc/fileposhpvia.inc" ! purchase order ship via
include "src/inc/filebuyer.inc" ! buyer file
! For Import
include "src/inc/filepoocnfrt.inc" ! ocean freight rate
include "src/inc/filepocduty.inc" ! custom duty rate
include "src/inc/filepobroker.inc" ! broker
! for cpi
include "src/inc/filecpidet.inc"
include "src/inc/filespecprice.inc"
! for multicurrency
include "src/inc/filecurrency.inc" ! currency exchange file

External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus
Declare External Function OpenPrinter

External Lib "libprodconv.lib"           
Declare External Function ConvProdAmount 

External Lib "ubsprconv.dl4"     
Declare External Function XUnit$ 

External Lib "sffiles.lib"                                                

 Declare External Function getcurrentdate   
!
 
External Lib "libgeneralcode.lib"
Declare External Function ConvertDate
!
External Lib "ubsfunc.dl4"
Declare External Sub getportdefault,GetCostLevels,LogAccess
Declare External Function OpenFile,PDate$,FormatDate2$
Declare External Function OpenMySQLMirror ! new function
!
External Lib "getglname.lib"        
Declare External Function getglname$
!

External Lib "libdroplist.lib"
Declare External Sub PrintersDroplist



Declare Intrinsic Sub StringSearch
Declare Intrinsic Sub DateToJulian,FindF,JulianToDate,VerifyDate,CheckNumber,Time
Declare Intrinsic function findchannel
!
!
Declare sub OpenFiles
Declare sub VerifyVendor


Declare Sub Polist
Declare Sub Polinelist,PoRcvdLnList,submitrtslbl
Declare Sub powhDroplist,potypelist,freightunits
Declare Sub StartPoMisc,GetPoMisc, SubmitPoMisc
Declare Sub CalcPoTotals,initpoh,CalcImpLineTot
Declare Sub CalcExtAmt,verifystat
Declare Function CalcExtWgt,CalcExtCube
Declare Sub UpdateCPI

!
!--------------------------------------------------------------------
!
!
! ** main procedure
!
OPTION GOSUB NESTING 20  ! Default is 8
try
  !
  dim 1%,cnvcu[10],3%,cnvca[10],keycurr$[10],1%,ch_curr,3%,rec_curr,currfact
  dim e$[500],buttonlist$[5,50],nextlist$[5,100] ! error handling variables
  dim bsdel$[20],esdel$[20],rdel$[20],fdel$[20],rstr$[5000]
  dim Section$[30],Field$[10,30],Fields$[1,30]
  dim mergedir$[60],action$[20],action1$[20],options$[20]
  dim Company$[2],UserID$[8],keyvend$[10],keypoh$[12],keypom$[10],keyroh$[12]
  dim xdate$[10],keyship$[14],shipkey$[14],keyrol$[10],keyslsm$[4]
  dim rohkey3$[10],potype$[2],tmpkey$[50]
  dim msglist$[200]
  let msglist$=" ",msglist$
  
  let msglist$[17,32]=  "Note           " ! 1
  let msglist$[33,48]=  "Message        " ! 2
 
  !
  ! dim for po totals
  dim 1%,ch[99],dclvl,mctxbl[9],2%,s9[9],t1[1],mcode[9],3%,h1,v1,r5,param[9],t2[25],mcharge[9,1],tot[4],cfin[8]
  dim 1%,editstatus,source,acceptrts,sostockflag,postockflag,COST_LEV[4] 
  dim 1%,ua5[10],dispcomm$[1],CHKRECV
  dim 1%,ordedit,nolines,ch[99],FCHAN[50]
  dim 1%,tmp1,intCo,intSls,CTLC,errflag,WH,Div,portnum,chan[25],flag
  dim 1%,misccode[4],3%,miscchrg[4]
  dim 1%,hasdisc
  dim 2%,tmp2,maxcnt \ maxcnt=2000 ! max records in arrays
  dim 3%,tmp3,JDepositDate,DocNo,rec_uac,X2[9],REC_PROD
  DIM 3%,parm[25],ORGTOT[10]
  dim 2%,vendid,vendid$[6]
  dim 2%,poid,poid$[6],billcustid,billcustid$[6],ordnum
  dim 3%,ordamt,poAmt$[20],arbal,openordamt,CURTIM[10]
  dim 2%,conswh,maxwh,currdate,PONUM
  dim 2%,taxtype,delchglvl,salesarea
  dim 3%,tmprec[10],EX[18],rec_pol
  dim 4%,tmp4,VALUE_RECV,WEIGHT_RECV,CUBES_RECV,QTY_RECV 
  dim keycust$[30],keychk$[50],keypol$[50],ACCEPTRTS$[1]
  Dim 1%,flags[11],FLAG,CNVTU[2],ERRTYPE,linksoflag
  dim 3%,qty,cost,amount,baseqty,cnvta
  dim 3%,totrcvdamt,totrcvdqty,totrcvdwgt,totrcvdcube,dsp_totrcvdamt,dsp_totordamt,currfact
  dim 3%,totordamt,totordqty,totordwgt,totordcube
  dim 3%,lineqty,lineum,linecost,lineextamt,lbsunit,lbsfact 
  dim 3%,totuntc
  dim tmppo$[20],chkpo$[20],3%,rec_tmp
  dim credcoded$[16],clsdpswd$[8],potyped$[20],WORK$[600],KEYPOBR$[20]
  dim whlist$[100,100]
  Dim keyappoh$[30],2%,appoh[1],1%,apflag,ch_appoh,3%,r56
  dim potypelist$[100,100],routinglist$[100,100]
  dim custid$[6],pono$[6],billtoid$[6],userid$[8]
  dim p60$[50],p61$[256],P9$[50]
  dim List$[maxcnt,2000],sdate$[50]
  dim SList$[maxcnt,800] ! for .net selector(drop down) list
  dim logfname$[50]
  dim CustNo$[6],SearKey$[64],BegKey$[64],mode$[3]
  dim Desc$[50],PayFlag$[1],RecType$[1],DocNo$[10],ARInvKey$[64],InvType$[3]
  dim tmp$[200],tmp1$[200],WebStr$[1000],Message$[200],MSG$[500],FNAME$[100]
  dim pwkey$[50],3%,pwr
  dim blank$[200] \ blank$=" ",blank$
  dim M3$[3] \ M3$="###"
  dim M6$[6] \ M6$="######"
  dim M10$[10] \ M10$="##########"
  dim 3%,rec_poh
  let tmp$=tim(4) using "&&&&&&"
  let work$=tmp$[5,6],tmp$[1,2],tmp$[3,4]
  let currdate=work$
  dim ediflg$[4]
  dim statword$[200]
  LET statword$="ENTERED   PRINTED   REGISTEREDOPEN      IN PROCS  REC. REG'DCLOSED    "
  LET Statword$[101]="DM ENTEREDDM PRINTEDDM REGIST.DM CLOSED STATUS 11  STATUS 12 "
  let Statword$[161]="DM IN PROCESS"                                              
  dim custom_customer$[30]
  Dim K_CPI$[50]
  dim 2%,JToday
  Dim 3%,R_CPI

  !!! define structures !!! 
  dim prod. as prod ! prod
  dim Cust. as cust ! customer
  dim roh. as roh ! order header
  dim ros. as ros ! order ship
  dim rot. as rot ! order totals
  dim vend. as a80vm ! vendor file
  dim Cust. as cust ! customer
  ! prod desc key
  dim poh. as pohead ! po header
  dim pol. as poline ! po line file
  Dim pw. as prodwhse! prod warehouse
  dim pom. as pom ! po message file
  dim wh. as whinfo ! warehouse file
  ! cc codes 
  dim nstk. as  nstkdesc
  dim vtag. as vendtag ! vendor tag file
  dim rol. as rolnew ! order lines file
  dim misc. as pomiscchrg ! purchase order misc charges
  ! deals, warehouseloc, spolot, sprodlot, ordlot, altvend
  dim prt. as prtdefault ! port defaults
  dim posv. as poshpvia ! purchase order ship via
  dim buy. as buyer ! buyer file
  ! import
  dim poof. as poocnfrt ! ocean freight rate
  dim pocd. as pocduty  ! custom duty rate
  dim pobr. as pobroker ! broker rate file
  dim sql_prod. as sql_prod
  ! CPI
  dim cpid. as cpidet
  dim specp. as specprice
  ! for currency exchange
  dim curr. as currency
  Def FNR(H) = Int(Abs(H) * 100 + .5) * .01 * Sgn(H) ! rounding to nearest penny
  !
  call dxopen()
  Call dxget("S_USER.AppID",tmp$) !company #               
                                                         
  Try Let intCo = Val(tmp$) Else Let intCo = 1 !company #  
  ctlc = OpenFile(9999,intCo) \ If ctlc = -1 Error 42 !control   ! openning with read/write
  call GetSession(e$,CTLC,options$,action$,UserID$,intCo,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$,action1$)
  call LogAccess(e$)
  call GetPortDefault(e$,IntCO,UserID$,portnum,rec_uac,prt.) ! get port default
  mat read #ctlc,60,50;p60$; ! system flag variable
  mat read #ctlc,61,0;p61$;
  mat read #ctlc,19,50;p9$;
  mat read #ctlc,115,60;custom_customer$;
  Mat Read #1,3,176;JToday;
  cpiFlag = 0 \ if p61$[111,111]="Y" cpiFlag = 1
  let custom_customer$=UCase$(trim$(custom_customer$))
  Call GetCostLevels(e$,COST_LEV[],Intco,Userid$)  !
  call dxget("s_view.mergedir",mergedir$)
  
  !
  call OpenFiles()
  !
  select case action$

  case "DROPLIST" !   send droplists 
    
  !================================= Begin Action Droplist ================================================
	  if action1$="ORDHLISTS"
		
		! need buyers
		! need poshipvia
		! need ordertype
		! need warehouse
		
		
		
		
		!call RoutingDropList(e$,RoutingList$[],bsdel$,esdel$,fdel$,100,ctlc) ! ROUTING
		!call AddToStr(e$,rstr$,RoutingList$[])
		
	   endif
	  !
	  if action1$="WHINFO"
		  call FileDropListWhinfoz(e$,whList$[],100,ch_wh)
		 call AddToStr(e$,rstr$,whList$[])
	  endif
	  	 
	  
	  if action1$="POTYPE"
		
		! call potypeDropList(e$,potypeList$[],bsdel$,esdel$,fdel$,100,ctlc)
		! call AddToStr(e$,rstr$,potypeList$[])
	  endif
	  	 
	  if action1$="CUSTOMER"
		Section$="CustInfo"
		Field$[0]="CustomerCode" ! customer #
		Field$[1]="CustomerBillTo" ! bill to customer #
		Field$[2]="Name$" ! customer name
		Field$[3]="Contact$" ! contact
		Field$[4]="Addr1$" ! address line 1
		Field$[5]="Addr2$" ! address line 2
		Field$[6]="City$" ! city
		Field$[7]="State$" ! state
		Field$[8]="Zip4$" ! zip code
		Field$[9]="Phone$" ! telephone #
		
		clear List$[]
		Dir=2
		call filedroplistcust(e$,list$[],maxcnt,Ch_Cust,Section$,Field$[],Dir,SearKey$)
		call AddToStr(e$,rstr$,List$[])
	endif
	if action1$="IMPORT"
		let returnstatus=1
		let message$="OK"
		CLEAR LIST$[]
		clear fields$[]
		call filedroplistpoocnfrt(e$,list$[],maxcnt,Ch_POOF,"",fields$[],"0")
		call AddToStr(e$,rstr$,List$[])
		CLEAR LIST$[]
		 !Call filedroplistpocduty(e$,List$[],100,chan,"",fields$[],"0") !"0" pa
		call filedroplistpocduty(e$,list$[],maxcnt,Ch_pocd,"",fields$[],"0")
		call AddToStr(e$,rstr$,List$[])
		CLEAR LIST$[]
		call filedroplistpobroker(e$,list$[],maxcnt,Ch_pobr,"",fields$[],1,"","B")
		call AddToStr(e$,rstr$,List$[])
		call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
		call AddToStr(e$,rstr$,WebStr$)
	endif
		call SetOutput(e$,rstr$)



CASE "POHLIST"
	call dxget ("vendid",VendId$)
	let vendid=vendid$
	call dxget ("postatus",tmp$) ! 0=open 1=close 2=ready to receive
	let postatus=tmp$
	let returnstatus=1
	let message$="ok" ! null need to append with errors 
	! section 1- open po list
	call polist ()
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)
 
 CASE "POLLIST"
	call dxget ("vendid",VendId$)
	let vendid=vendid$
	call dxget ("poid",tmp$) ! 0=open 1=close
	let poid=tmp$
	let returnstatus=1
	let message$="ok" ! null need to append with errors 
	! section 3 -  po line list
	call polinelist ()
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)

CASE "STARTRTSLABEL" !  set flags and sends warehouse list
	let returnstatus=1
	let message$="OK"
	! whse droplist
	Call FileDropListWhinfoz(e$,whList$[],100,ch_wh)  
	Call AddToStr(e$,rstr$,whList$[])
	! Default Warehouse
	clear list$[]
	let list$[0]=bsdel$,"DfltWhse",fdel$
	webstr$ = "DfltWhse",fdel$                             
	list$[1]=webstr$
	let tmp3=prt.wh
	if tmp3<=0 or tmp3>99 let tmp3=1
	webstr$=str$(tmp3),fdel$ !!!
	list$[2]=webstr$
	list$[3]=esdel$
	call AddToStr(e$,rstr$,List$[]) 
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
    call SetOutput(e$,rstr$) ! StartPhys

 CASE "POLRCVDLIST"
	call dxget ("vendid",VendId$)
	let vendid=vendid$
	call dxget ("poid",tmp$) ! 0=open 1=close
	let poid=tmp$
	let returnstatus=1
	let message$="ok" ! null need to append with errors 
	! section 3 -  po line list
	call porcvdlnlist ()
	call AddToStr(e$,rstr$,List$[])

	clear list$[]
	list$[0]=bsdel$,"Printers",fdel$
	List$[1]="Name",fdel$,"Id",fdel$,"Default",fdel$
	call AddToStr(e$,rstr$,List$[])
	pdfoption=0
	xmloption=0 ! BROWSER NOT OK  (MULTIPLE PRINT FORMATS!)1=except,2=audit,3=update,4=future
	Call PrintersDropList(rstr$,xmloption,pdfoption)
	Call AddToStr(e$,rstr$,esdel$) ! end of section 

	! Call AddToStr(e$,rstr$,esdel$) ! end of section 
	
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)
	
CASE "SUBMITRTSLBL" !  set flags and sends warehouse list
	call submitrtslbl()
	! status section
	!call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	!call AddToStr(e$,rstr$,WebStr$)
	! done with it
    !call SetOutput(e$,rstr$) ! StartPhys	
      
case "SUBMITPOHDR"
	dim opoh. as pohead
	call dxget ("Source",tmp$)
	let source=tmp$
	if source=370
		let returnstatus=0
		let message$="No Update. Inquiry Only."
		goto endsubpohdr:
	endif
	let returnstatus=1
	let message$="OK" ! null need to append with errors 
	
	call dxget ("vendid",Vendid$)
	let vendid=vendid$
	call verifyvendor()
	If not (returnstatus) goto endsubpohdr:
	call dxget ("poid",poid$)
	let poid=poid$
	If not (poid)
		let returnstatus=99
		let message$="Invalid PO Number "+str$(poid)
		goto endsubpohdr:
	endif
	if source=371 and poid=99
		let returnstatus=99
		let message$="Invalid PO Number "+str$(poid)
		goto endsubpohdr:
	endif
	if poid<>0
		keypoh$=" ",keypoh$
		keypoh$[1,6]=vendid using "######" 
		keypoh$[7,12]=poid using "######"
		mode$="=" ! search mode 2
		dir=2
		Rec_poh=filegetpohead(e$,ch_poh,mode$,dir,keypoh$,poh.)
		if rec_poh<0
			let returnstatus=99
			let message$="PO Number "+str$(poid)+" Not On File. "
			goto endsubpohdr:
		endif
		if returnstatus<>0 !and source<>379
			call verifystat()
			if returnstatus=99 goto endsubpohdr:
		endif
		if source=371
			goto endsubpohdr:
		endif
		read record #ch_poh,rec_poh;opoh.;
		If source=379 goto POSchedl ! only get/update 3 fields in 379?
		call dxget ("ShipName",tmp$)
		poh.ShipToName$=tmp$+"                              "
		call dxget ("ShipAddr1",tmp$)                    
		poh.Address1$=tmp$+"                              "
		call dxget ("ShipAddr2",tmp$)                    
		poh.Address2$=tmp$+"                              "
		call dxget ("ShipCity",tmp$)                    
		poh.City$=tmp$+"                "
		call dxget ("ShipState",tmp$)                    
		poh.State$=tmp$+"  "
		call dxget ("ShipZip",tmp$)                    
		poh.ZipCode$=tmp$+"  "
		call dxget("PODate",tmp$) 
		xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
		poh.orderdate=xdate$[3,8]
		call dxget("VendorRef",tmp$)
	        poh.VendorRef$=tmp$+"                              "
		Webstr$=webstr$,rtrim$(poh.terms$),fdel$ ! terms
		Webstr$=webstr$,rtrim$(poh.fob$),fdel$ ! fob
		call dxget("ShipViaId",tmp$)
		poh.shipviaid=tmp$ ! ship via id       
		call dxget("ShipViaDesc",tmp$)
		poh.shipvia$=tmp$+"                              "
		call dxget("Routing",tmp$) 
		poh.Routing$=tmp$+"                              "
		call dxget("Terms",tmp$)
		poh.terms$=tmp$+"                              "
		call dxget("FOB",tmp$)   
		poh.fob$=tmp$+"                              "
		call dxget("Confirmed",tmp$) 
		if UCASE$(rtrim$(tmp$))="NO" let tmp$="NO"
		poh.ConfirmName$=tmp$+"                              "
		poh.ConfirmName$=tmp$+blank$
		call dxget("ConfDate",tmp$)
		if tmp$<>"" or tmp$<>"999999"
			xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
			poh.ConfirmDate=xdate$[3,8]
		else
			poh.confirmdate=tmp$
		endif
		call dxget("potype",tmp$)   
		let poh.type=-1
		if rtrim$(tmp$)="W" let poh.type=0
		if rtrim$(tmp$)="D" let poh.type=1
		if rtrim$(tmp$)="I" let poh.type=2
		if p60$[46,46]="Y"
			if rtrim$(tmp$)="IW" let poh.type=4
			if rtrim$(tmp$)="ID" let poh.type=5
			if rtrim$(tmp$)="II" let poh.type=6
		endif
		if poh.type<0 or poh.type>6
			let returnstatus=99
			let message$="Invalid PO Type "
			goto endsubpohdr:	
		endif
		call dxget("powh",tmp$)     
		poh.warehouse=tmp$
		If source<>381
			call dxget("SalesOrder",tmp$)
			poh.SalesOrder=tmp$
		else
			call dxget("CopyPONum",tmp$)
			poh.SalesOrder=tmp$
		endif
		call dxget("buyer",tmp$)    
		poh.buyer=tmp$   
		call dxget("UpdateLeadTime",tmp$)
		let poh.updateleadtime=0
		if tmp$="Y" let poh.UpdateLeadTime=1
		call dxget("DupDueDate",tmp$)
		if rtrim$(tmp$)<>""
			xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
			poh.poduedate=xdate$[3,8]
		endif
		if not(poh.poduedate) or poh.poduedate>991231
			call dxget("DueDate",tmp$) 
			xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
			let poh.poduedate=xdate$
		endif
		
	POSchedl: ! if only changing 3 fields in 379
		call dxget("DueDate",tmp$) 
		xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
		poh.duedate=xdate$[3,8]
		call dxget("WhseBay",tmp$)          
		poh.whsebay=tmp$    
		call dxget("DelvTime1",tmp$) \ tmp$=rtrim$(tmp$)
		CPOS=0
		Search tmp$,":",CPOS
		if len(tmp$)>2 and cpos=0 ! 
			let returnstatus=0
			let message$="Delivery Start has bad format (HH:MM). "
			goto endsubpohdr:
		Endif
		if source=379 or (CPOS>1) ! sent it (379 always)
			if source=379 and cpos=0
				Let poh.DelvTime1=0 ! no : so zero?
			Else
				x2=tmp$[1,CPOS-1];X2[1]=TMP$[CPOS+1] ! 3,3 always :
				poh.DelvTime1=x2+(X2[1]/100)
			Endif
		Endif
		call dxget("DelvTime2",tmp$) \ tmp$=rtrim$(tmp$)
		CPOS=0
		Search tmp$,":",CPOS
		if len(tmp$)>2 and cpos=0 ! 
			let returnstatus=0
			let message$="Delivery End has bad format (HH:MM). "
			goto endsubpohdr:
		Endif
		if source=379 or (CPOS>1) ! sent it (379 always)
			if source=379 and cpos=0
				Let poh.DelvTime2=0 ! no : so zero?
			Else
			x2=tmp$[1,CPOS-1];X2[1]=TMP$[CPOS+1] ! 3,3 always :
			poh.DelvTime2=x2+(X2[1]/100)
			Endif
		Endif
		if source<>381
			call dxget("VDiscType",tmp$)
			poh.PODiscType=0
			!if poh.type=1
				if tmp$="%" let poh.PODiscType=1
				if tmp$="$" let poh.PODiscType=2
			!endif
			call dxget("VDiscAmt",tmp$)
			x2=tmp$
			if x2<0 or (poh.PODiscType=1 and x2>100)
				!if poh.type=1
						let returnstatus=0
						let message$="Invalid PO Discount amount "
						goto endsubpohdr:
				!Endif
			endif
			poh.PODiscAmt=tmp$
			If p61$[136,136]="Y" and poh.PODiscAmt<>0 and poh.PODiscType=2 and poh.currfact<>0
				let cnvcu[0]=2
				let cnvca[0]=poh.PODiscAmt
				let cnvca[1]=poh.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let poh.PODiscAmt=cnvca[0]
			endif
			if poh.type=1 ! direct
				if poh.PODiscType<>1 and poh.PODiscType<>2 let poh.PODiscType=0;poh.PODiscAmt=0
				if poh.podiscamt=0 let poh.podisctype=0
				if linesexist=0 and poh.podisctype=0
					keyvend$=" ",keyvend$
					keyvend$=poh.VendorCode using "######"
					mode$="=" ! search mode 2
					dir=1
					clear vtag.
					Rec_vtag=filegetvendtag(e$,ch_vtag,mode$,dir,keyvend$,vtag.)
					if rec_vtag<0
						clear vtag.
					endif	
					if vtag.VDiscType<>1 and vtag.VDiscType<>2 let vtag.VDiscType=0;vtag.VDiscAmt=0		
					poh.PODiscType=vtag.VDiscType ! podisc[0]=vdisc[0]
					poh.PODiscAmt=vtag.VDiscAmt
				endif	
			endif
			if poh.PODiscType=0 let poh.PODiscAmt=0
			if poh.podiscamt=0 let poh.PODiscType=0
			if poh.type<>1 ! directs only
				!let poh.podiscamt=0
				!let poh.podisctype=0
			endif
		Else ! DM's
			poh.PODiscType=0
			poh.PODiscAmt=0
		Endif
		write record #ch_poh,rec_poh;poh.;
		if source=379
			let keypoh$=" ",keypoh$
			let keypoh$[1,2]=poh.status using "##"
			let keypoh$[3,8]=poid using "######"
			search #ch_poh,5,1;keypoh$,rec_tmp,e
			poh.status=POH.OLDSTATUS
			write record #ch_poh,rec_poh;poh.;
			let keypoh$=" ",keypoh$
			let keypoh$[1,2]=poh.status using "##"
			let keypoh$[3,8]=poid using "######"
			search #ch_poh,4,1;keypoh$,rec_poh,e
		endif
	endif ! returnstatus!
	endsubpohdr: ! end submiting the po header 
	clear list$[]
	List$[0]=bsdel$,"poSubmit",fdel$
	WebStr$="poId",fdel$
	List$[1]=WebStr$
	WebStr$=str$(poid),fdel$
	LIST$[2]=Webstr$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)


case  "GETPOHDR" 
	call dxget ("vendid",Vendid$)
	let vendid=vendid$
	call dxget ("poid",poid$)
	let poid=poid$
	if poid<0 OR poid>999999
		let message$="Purchase Order "+str$(poid)+" Invalid"
		let returnstatus=0
		goto endgetpohdr:
	endif
	if rtrim$(poid$)="" let poid$="0"
	if poid=0 and poid$<>"0"
		let message$="Purchase Order "+rtrim$(poid$)+" Invalid"
		let returnstatus=0
		goto endgetpohdr:
	endif
		
	call dxget ("editstatus",tmp$) ! 0 = first time, 1=edit existing, 9=submit po
	let editstatus=tmp$
	call dxget ("newpo",tmp$) !  0 = new purchase order, 1=existing
	let newpo=tmp$
	call dxget ("SOURCE",tmp$)
	let source=tmp$
	call dxget ("reopen",tmp$) ! 0 = not to reopen, 1=reopen
	if source=370 let tmp$="0" ! do not reopen
	if source=381 let tmp$="0" ! do not reopen debit memos
	if source=379 let tmp$="0";newpo=1 ! do not reopen for scheduling / exist only
	if source=371 let tmp$="0";newpo=1
	let reopen=tmp$
	LET returnstatus=1
	let message$="OK"
	if vendid<=0 and not(poid)
		let message$="No Purchase Order Number Or Vendor Id Entered"
		let returnstatus=0
		goto endgetpohdr:
	endif
	if vendid=0 and poid>0 ! po number entered and not the vendor code
		let keypoh$=" ",keypoh$
		let keypoh$[1,2]=" 1"
		LET keypoh$[3]=poid USING "######"
		for ctr=1 to 99
			let keypoh$[1,2]=ctr using "##"
			search #ch_poh,2,1;keypoh$,rec_poh,e
			if not(e)
				read record #ch_poh,rec_poh;poh.;
				let vendid=poh.vendorcode
				goto foundpoid:
			endif
			if ctr=18 let ctr=90
		next ctr
		let message$="Purchase Order "+str$(poid)+" Not On File"
		let returnstatus=0
		goto endgetpohdr:
		foundpoid: ! found the po #
		let newpo=1 ! existing po
	endif
	if source=379
		if poh.status = 7 
			message$="Purchase Order "+str$(poid)+" Is Closed"
			let returnstatus=0
			goto endgetpohdr:
		ENDIF
	endif
	call verifyvendor()
	clear poh.
	call initpoh()! init string variables

	let linesexist=0
	let openlines=0
	let powh=0
	let potype=0
	if not (returnstatus) goto EndGETPOHDR:
	if source=370
		let editstatus=1
		if poid=0
			let returnstatus=0
			let message$="Inquiry Only."
			goto endgetpohdr:
		endif
	endif
	if source=371
		let newpo=1
		if poid=0
			let returnstatus=0
			let message$="Receiving Only."
			goto endgetpohdr:
		endif
	endif	
	IF source=379
		editstatus=0
	endif
	if editstatus=0 and newpo=0 ! NEW PURCHASE ORDER 
		if poid<>0 ! verify if po already exists
			let keypoh$=" ",keypoh$
			let keypoh$[1,2]=" 1"
			LET keypoh$[3]=poid USING "######"
			for ctr=1 to 99
				let keypoh$[1,2]=ctr using "##"
				search #ch_poh,2,1;keypoh$,rec_poh,e
				if not(e)
					let returnstatus=0
					If source<>381
						let message$="Purchase Order Number Already Exists"
					else
						let message$="Debit Memo Number Already Exists"
					endif
					GOTO ENDGETPOHDR:
				endif
				if ctr=18 let ctr=90
			next ctr
		else ! new po --- get a po number
			DO ! get po number
				if source<>381
					READ #ctlc,20,94;POnum; 
					LET PONUM=PONUM+1
					write #ctlc,20,94;PONUM;
				else
					READ #ctlc,20,118;POnum; 
					LET PONUM=PONUM+1
					write #ctlc,20,118;PONUM;
				endif
				IF PONUM>999998
					LET RETURNSTATUS=0
					if source<>381
						LET MESSAGE$="PO Number have exceeded 999999"
					else
						LET MESSAGE$="Debit Memo Number have exceeded 999999"
					endif
					GOTO ENDGETPOHDR:
					exit do
				endif
				let flag=0
				LET keypoh$=" ",keypoh$ \ LET keypoh$[3,8]=PONUM USING "######"        
				FOR ctr=1 TO 99                                        
					LET keypoh$[1,2]=ctr USING "##"                           
					SEARCH #ch_poh,2,1;keypoh$,rec_tmp,E  
					if not(e) let flag=99
					if ctr=18 let ctr=90
				next ctr
				if not (flag) 
					
					let poid=PONUM
					exit do
				endif
			loop! try another po #
		endif ! new po/ getting id
		clear poh.
		call initpoh()
		poh.Status=95 
		if source=381 let poh.status=97 ! debit memo
		poh.vendorcode=vendid
		poh.VendorRec=rec_vend                     
		poh.PurchaseOrder=poid                     
		poh.OrderDate=currdate                     
		poh.DueDate=currdate                       
		poh.ConfirmDate=currdate                   
		poh.ShipVia$=vend.ShipVia$                 
		poh.Routing$=vend.Routing$                 
		poh.Terms$=vend.TermsAlpha$                
		poh.FOB$=vend.Fob$                         
		poh.ConfirmName$=" ",poh.ConfirmName$      
		if p61$[62,62]="Y"                         
		    poh.ConfirmName$[1,3]="YES"        
		else                                       
		    poh.ConfirmName$[1,3]="NO "         
		endif                                      
		poh.Warehouse=1                            
		if prt.wh let poh.warehouse=prt.wh         
		                 
		read record #ch_wh,(poh.warehouse-1);wh.;  
		Call StringSearch(UCase$(wh.zipcode$),"-",P)
		IF P<>1                                   
			let poh.ZipCode$=wh.zipcode$[1,9]  
		else ! "-" found                                                
			let poh.zipcode$=" ",poh.zipcode$               
			let poh.ZipCode$[1,5]=wh.zipcode$[1,5]          
			let poh.Zipcode$[6,9]=wh.zipcode$[7,10]         
			let p=0                                       
		endif                                                   
		poh.ShipToName$=wh.WhName$                              
		poh.Address1$=wh.Address1$                              
		poh.Address2$=wh.Address2$                              
		poh.City$=wh.City$                                      
		poh.State$=wh.State$                                    
		! end from warehouse file                               
		poh.VendorCode=vendid                                   
		poh.Type=0 ! set to warehouse                           
		IF P60$[46,46]="Y" and custom_customer$="ETNA"
			LET poh.type=4 ! import 
		endif
		poh.UpdateLeadTime=1                                    
		poh.OldStatus=0
		if source=381 let poh.OldStatus=11
		poh.Lockport=rec_uac ! 0 !!!! need the lock port                  
		poh.ShipViaID=vend.ShipViaNum ! 0 = manual, >=file 
		if p61$[136,136]="Y"
			if vend.currid<>0
				keycurr$ = " ",keycurr$                   
				keycurr$[1,4] = vend.currid Using "####"  
				Search #ch_curr,2,1;keycurr$,rec_curr,e   
				If e <> 0                                 
					poH.currfact = 0 
					poH.currid=0
				Else                                      
					Read Record #ch_curr,rec_curr;curr.; 
					let poH.currid=vend.currid
					let poH.currfact=curr.ExcRate
				endif
			else
				let poH.currfact=0
				let poH.currid=0
			endif
		else
			let poH.currfact=0
			let poH.currid=0
		endif               
		if source<>381
			if vtag.VDiscType<>1 and vtag.VDiscType<>2 let vtag.VDiscType=0;vtag.VDiscAmt=0
			if poh.type=1
				if poh.PODiscType<>1 and poh.PODiscType<>2 let poh.PODiscType=0;poh.PODiscAmt=0
				if poh.podiscamt=0 let poh.podisctype=0
				if linesexist=0 and poh.podisctype=0
					poh.PODiscType=vtag.VDiscType ! podisc[0]=vdisc[0]
					poh.PODiscAmt=vtag.VDiscAmt
				endif
			else
				poh.PODiscType=0 ! podisc[0]=vdisc[0]
				poh.PODiscAmt=0
			endif				
		Endif
		MAT  READ #CTLC,60,6;EDIFLG$;!!! edi flag check
		IF EDIFLG$[2,2]="T" or EDIFLG$[2,2]="H"
			if source<=361 ! new purchase order #
				dim 1%,ch_edi,3%,rec_edi,etp[999],keyedi$[50]
				fname$="cntrl/EDICNTRL"+STR$(INTCO)
				Call FindF(Fname$,A9)
				IF CUSTOM_CUSTOMER$="notusedyetACME"
                Call "edi875.dl4",h0[]
				let A9=0
				endif
				IF A9<>0
					ch_edi=FINDCHANNEL()
					Try 
						ROPEN #ch_edi,FNAME$
						let keyedi$[1,2]="VN"
						let keyedi$[3,8]=vendid using "######"
						search #ch_edi,2,1;keyedi$,rec_edi,e
						if not(e)
							MAT  READ #ch_edi,rec_edi,8;eTP;              
							IF NOT (INT(ABS(ETP[850]))) AND NOT (INT(ABS(ETP[875])))
								let poh.EdiStatus$=" ",poh.edistatus$
							ELSE
								let poh.EdiStatus$=" ",poh.edistatus$
								let poh.EdiStatus$[1,1]="n"         
							endif
						endif
					else
						rem no file found
						let poh.EdiStatus$=" ",poh.edistatus$
					end try
				endif
			endif
		endif
		mode$ = "a" ! add  
		                                              
		UpdStatus = fileupdatepohead(e$,ch_poh,mode$,rec_tmp,poh.)	
		      
		rec_poh = UpdStatus                                                     
               !! get record and write the file out                                      
		GOTO ENDGETPOHDR:	
	endif
	if poid<>0 and newpo<>0 ! po id and not a new po
		keypoh$=" ",keypoh$
		keypoh$[1,6]=vendid using "######" 
		keypoh$[7,12]=poid using "######"
		mode$="=" ! search mode 2
		dir=2
		Rec_poh=filegetpohead(e$,ch_poh,mode$,dir,keypoh$,poh.)
		if rec_poh<0
			let returnstatus=99
			let message$="PO Number ",keypoh$[7,12]," Not On File"
			GOTO ENDGETPOHDR:
		endif
		if editstatus<>0 ! in process edit
			if source<>370 and source<>371 and source<>381 !and source<>379
				if poh.status<>95
					let returnstatus=99
					let message$="PO Number ",keypoh$[7,12]," Is not in Edit Status"
					GOTO ENDGETPOHDR:
				endif
			endif
			if source=371
				if poh.status<>96
					let returnstatus=99
					let message$="PO Number ",keypoh$[7,12]," Is not in Receiving Status"
					GOTO ENDGETPOHDR:
				endif
			endif
			if source=381
				if poh.status<>97
					let returnstatus=99
					let message$="Debit Memo ",keypoh$[7,12]," Is not in Edit Status"
					GOTO ENDGETPOHDR:
				endif
			endif
		else
			if poh.status=95
				if source<>371 and source<>381 !and source<>379
					if poh.Lockport<>rec_uac
						let returnstatus=99
						let message$="PO Number ",keypoh$[7,12]," Is Already in Process Elsewhere"
						goto endgetpohdr:
					else
						let editstatus=1
						goto endchkpostatus:
					endif
				endif
			endif	
			if poh.status=96 and source=371 
				if poh.Lockport<>rec_uac 
					let returnstatus=99
					let message$="PO Number ",keypoh$[7,12]," Is Already in Receiving Process Elsewhere"
					goto endgetpohdr:
				else
					let editstatus=1
					goto endchkpostatus:
				endif
			endif
			if poh.status=97 and source=381 
				if poh.Lockport<>rec_uac 
					let returnstatus=99
					let message$="DM Number ",keypoh$[7,12]," Is Already in Process Elsewhere"
					goto endgetpohdr:
				else
					let editstatus=1
					goto endchkpostatus:
				endif
			endif
			if source<>371 and poh.status=5
				let returnstatus=99
				let message$="PO Number ",keypoh$[7,12]," Is in Receiving Process"
				GOTO ENDGETPOHDR:
			endif
		    if source=371
				if poh.status=6
					let returnstatus=99
					let message$="PO Number ",keypoh$[7,12]," Receiving Journal Accepted"
					goto endgetpohdr:
				endif
				if poh.status=7
					let returnstatus=99		
					let message$="PO Number ",keypoh$[7,12]," Closed for Receipts"
					goto endgetpohdr:
				endif
				if poh.status>10 and poh.status<15
					let returnstatus=99		
					let message$="Debit Memo ",keypoh$[7,12]," Invalid "
					goto endgetpohdr:
				endif
			endif

			if source=381
				if poh.status<11
					let returnstatus=99
					let message$="DM Number ",keypoh$[7,12]," Is a Purchase Order. May Not Edit"
					GOTO ENDGETPOHDR:
				endif
				if poh.status=13
					let returnstatus=99
					let message$="DM Number ",keypoh$[7,12]," Has Been Registered. May Not Edit"
					GOTO ENDGETPOHDR:
				endif
				if poh.status=14
					let returnstatus=99
					let message$="DM Number ",keypoh$[7,12]," Has Been Registered. May Not Edit"
					GOTO ENDGETPOHDR:
				endif
				if poh.status>14
					let returnstatus=99
					let message$="DM Number ",keypoh$[7,12]," In Process Elsewhere."
					GOTO ENDGETPOHDR:
				endif
				goto endchkpostatus:
			endif
			if poh.status>5 
				if poh.status<7
					let returnstatus=99
					let message$="PO Number ",keypoh$[7,12]," Is in Receiving Process"
					GOTO ENDGETPOHDR:
				endif
				if poh.status>10 and poh.status<15
					let message$="PO Number ",keypoh$[7,12]," Is a Debit Memo. May Not Edit"
					let returnstatus=99
					GOTO ENDGETPOHDR:
				endif
				if poh.status>89 and poh.status<92
					returnstatus=99
					let message$="PO Number ",keypoh$[7,12]," Is in Process Elsewhere. May Not Edit"
					GOTO ENDGETPOHDR:
				endif
				if poh.status=95
					returnstatus=99
					let message$="PO Number ",keypoh$[7,12]," Is in ERP Process Elsewhere. May Not Edit"
					GOTO ENDGETPOHDR:
				endif
				if poh.status=7 
					if not(reopen)
						returnstatus=98
						let message$="PO Number ",keypoh$[7,12]," Closed For Receiving. Do you wish to reopen"
						GOTO ENDGETPOHDR:
					else
						goto endchkpostatus:
					endif
				endif
				let returnstatus=99
				let message$="PO Number ",keypoh$[7,12]," Has Invalid Process Status. May Not Edit"
				GOTO ENDGETPOHDR:
			endif
			
		endif
		endchkpostatus: ! End checking of po status 
		if poh.type<0 or poh.type>6 !!! imports are ok now
			let returnstatus=99
			let message$="PO Number ",keypoh$[7,12]," Invalid Type for Edit"
			GOTO ENDGETPOHDR:
		endif
		if returnstatus<>0
			if  editstatus=0 !and source<>379 ! no errors have occured (no status chg-379!)
				let poh.oldstatus=poh.status
				let poh.lockport=rec_uac
				let poh.status=95
				if source=371 let poh.status=96
				if source=381 let poh.status=97
				let keypoh$=" ",keypoh$
				let keypoh$[1,2]=poh.status using "##"
				let keypoh$[3,8]=poid using "######"
				search #ch_poh,4,1;keypoh$,rec_poh,e
				let keypoh$[1,2]=poh.oldstatus using "##"
				search #ch_poh,5,1;keypoh$,rec_tmp,e
				IF POH.oldstatus=7 and reopen<>0
					let poh.oldstatus=1
				endif
				write record #ch_poh,rec_poh;poh.;
			endif
			linesexist=0
			openlines=0
			let keypol$=" ",keypol$
			let keypol$[1,6]=poid using "######"
			do
				search #ch_pol,3,1;keypol$,rec_pol,e
				if e<>0 exit do
				let tmp3=keypol$[1,6]
				if tmp3<>poid exit do
				let linesexist=99
				if source<371 and poh.totporcvd=0 let openlines=99
				if not(poh.TotPoRcvd) exit do
				! if poh.OldStatus>4 exit do
				if source>=380 exit do
				Read Record #ch_pol,rec_pol,0;Pol.;
				if pol.Status<>3 let openlines=99
				if openlines<>0 exit do
			loop
		endif
		let powh=poh.warehouse
		let potype=poh.type
		
	else
		let returnstatus=99
		message$="Error in Processing PO# "+str$(poid)
		! load defaults
	endif ! end of getting existing po
	ENDGETPOHDR: ! make the sections
	! section 1 - warehouse droplist
	call powhDroplist(List$[],poid,linesexist,potype,powh)
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	!Call AddToStr(e$,rstr$,esdel$) ! end of section
	! section 2 - po type droplist
	call potypelist(List$[],poid,linesexist,potype,powh)
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string

	! section 3 - buyer list
	clear list$[]
	!if source<>370
		Call FileDropListbuyer(e$,List$[],maxcnt,ch_buy)
	!else
		!List$[0]=bsdel$,"droplistbuyer",fdel$ ! beginning section!
		!List$[1]="ID",fdel$,"BuyerName",fdel$
		!List$[row]=esdel$ ! end section delimiter
	!endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string

	! section 4 - purchase order ship via list
	clear list$[]
	!if source<>370
		Call FileDropListposhpvia(e$,List$[],maxcnt,ch_posv)
	!else
		!List$[0]=bsdel$,"droplistbuyer",fdel$ ! beginning section!
		!List$[1]="ID",fdel$,"Desc",fdel$
		!List$[2]=esdel$ ! end section delimiter
	!endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	! section 4 - po ship detail
	Clear List$[]                                                         
	List$[0] = bsdel$ + "POHShipInfo" + fdel$ ! section name
	webstr$="VendId",fdel$
	webstr$=webstr$,"poId",fdel$
	webstr$=webstr$,"ShipName",fdel$
	webstr$=webstr$,"ShipAddr1",fdel$
	webstr$=webstr$,"ShipAddr2",fdel$
	webstr$=webstr$,"ShipCity",fdel$
	webstr$=webstr$,"ShipState",fdel$
	webstr$=webstr$,"ShipZip",fdel$
	let list$[1]=webstr$
	if returnstatus>0 and returnstatus<99! no errors send over the data
		webstr$=str$(poh.vendorcode),fdel$
		webstr$=webstr$,str$(poh.purchaseorder),fdel$
		webstr$=webstr$,poh.ShipToName$,fdel$
		webstr$=webstr$,poh.Address1$,fdel$                       
		webstr$=webstr$,poh.Address2$,fdel$                          
		webstr$=webstr$,poh.city$,fdel$
		webstr$=webstr$,poh.state$,fdel$
		webstr$=webstr$,poh.zipcode$,fdel$		
	endif
	LIST$[2]=WEBSTR$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section

	! section 5 - po header field
	Clear List$[]                                                         
	List$[0] = bsdel$ + "POHeaderInfo" + fdel$ ! section name
	webstr$="VendId",fdel$
	webstr$=webstr$,"POId",fdel$
	webstr$=webstr$,"PODate",fdel$
	webstr$=webstr$,"DueDate",fdel$
	webstr$=webstr$,"VendorRef",fdel$
	webstr$=webstr$,"ShipViaId",fdel$
	webstr$=webstr$,"ShipViaDesc",fdel$
	webstr$=webstr$,"Routing",fdel$
	webstr$=webstr$,"Terms",fdel$
	Webstr$=webstr$,"FOB",fdel$
	webstr$=webstr$,"Confirmed",fdel$
	webstr$=webstr$,"ConfDate",fdel$
	webstr$=webstr$,"droplistpotype",fdel$
	webstr$=webstr$,"potypedesc",fdel$
	webstr$=webstr$,"droplistpowh",fdel$
	webstr$=webstr$,"powhdesc",fdel$
	webstr$=webstr$,"SalesOrder",fdel$
	webstr$=webstr$,"droplistbuyer",fdel$
	webstr$=webstr$,"BuyerName",fdel$
	webstr$=webstr$,"WhseBay",fdel$
	webstr$=webstr$,"DelvTime",fdel$
	webstr$=webstr$,"UpdateLeadTime",fdel$
	webstr$=webstr$,"CopyPoNum",fdel$ ! for debit memos
	webstr$=webstr$,"CopyCMNum",fdel$ ! for debit memos
	webstr$=webstr$,"PromptClosed",fdel$ ! prompt to close and not delete
	webstr$=webstr$,"OpenLines",fdel$
	webstr$=webstr$,"Status",fdel$ ! 
	webstr$=webstr$,"DelvTime1",fdel$
	webstr$=webstr$,"DelvTime2",fdel$
	IF SOURCE<>381 ! not for dms
		webstr$=webstr$,"VDiscType",fdel$,"VDiscAmt",fdel$
	Endif
	webstr$=webstr$,"DupDueDate",fdel$
	webstr$=webstr$,"Currency",fdel$
	
	let list$[1]=webstr$
	if returnstatus<>0 ! no errors send over the data
		webstr$=str$(poh.vendorcode),fdel$
		webstr$=webstr$,str$(poh.purchaseorder),fdel$
		if poh.orderdate
			let xdate$=pdate$(poh.orderdate)
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! po date
		if Poh.duedate
			let xdate$=pdate$(poh.duedate)
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! due date
		WebStr$=WebStr$,RTrim$(poh.VendorRef$),fdel$ ! vendor ref #
		Webstr$=webstr$,str$(poh.shipviaID),fdel$ ! ship via id
		Webstr$=webstr$,rtrim$(poh.shipvia$),fdel$ ! ship via desc
		Webstr$=webstr$,rtrim$(poh.Routing$),fdel$ ! routing
		Webstr$=webstr$,rtrim$(poh.terms$),fdel$ ! terms
		Webstr$=webstr$,rtrim$(poh.fob$),fdel$ ! fob
		Webstr$=webstr$,rtrim$(poh.ConfirmName$),fdel$ ! confirmed
		if poh.ConfirmDate
			if poh.ConfirmDate<>999999
				let xdate$=pdate$(poh.ConfirmDate)
			else
				let xdate$="999999"
			endif
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! ship date
		let tmp$=""
		if poh.type=0 let tmp$="W "
		if poh.type=1 let tmp$="D "
		if poh.type=2 let tmp$="I "
		if poh.type=4 let tmp$="IW"
		if poh.type=5 let tmp$="ID"
		if poh.type=6 let tmp$="II"
		Webstr$=webstr$,tmp$,fdel$ ! po type id
		let tmp$=""
		if poh.type=0 let tmp$="Warehouse"
		if poh.type=1 let tmp$="Direct"
		if poh.type=2 let tmp$="Indirect"
		if poh.type=4 let tmp$="Import Warehouse"
		if poh.type=5 let tmp$="Import Direct"
		if poh.type=6 let tmp$="Import Indirect"
		Webstr$=webstr$,tmp$,fdel$ ! po type id description
		Webstr$=webstr$,str$(poh.warehouse),fdel$
		if poh.warehouse>0
			read record #ch_wh,(poh.warehouse-1);wh.; 
		else
			clear wh.
		endif
		Webstr$=webstr$,rtrim$(wh.whname$),fdel$
		Webstr$=webstr$,(poh.SalesOrder using "######"),fdel$
		Webstr$=webstr$,str$(poh.buyer),fdel$
		if poh.buyer>0
			read record #ch_buy,(poh.buyer);buy.;
		else
			clear buy.
		endif
		Webstr$=webstr$,rtrim$(buy.BuyerName$),fdel$
		Webstr$=Webstr$,str$(poh.WhseBay),fdel$
		let tmp$=""
		Webstr$=webstr$,tmp$,fdel$ ! delivery time
		let tmp$="N"
		if poh.UpdateLeadTime<>0 let tmp$="Y"
		Webstr$=webstr$,tmp$,fdel$
		webstr$=webstr$,str$(poh.salesorder),fdel$ ! for debit memos COPYPONUM -- need value
		webstr$=webstr$,str$(poh.debitmemo),fdel$ ! for debit memos COPYCMNUM-- need value
		let tmp$="N" ! promptclosed
		if source<370
			if poh.OldStatus<=4
				if poh.TotPoRcvd<>0 
					let tmp$="Y"
				else
					if poh.LastRtsDate<>0
						let tmp$="Y"
					endif
				endif
						
			endif
		endif
		webstr$=webstr$,tmp$,fdel$
		let tmp$="N"
		if source<370
			if openlines<>0 let tmp$="Y"
		endif
		webstr$=webstr$,tmp$,fdel$
		! status
		let x2=poh.status
		if x2>=90  and source<>370
			if poh.oldstatus>0 and poh.oldstatus<15
				let x2=poh.oldstatus
			endif
		endif
		tmp$=x2 using "&&"
		if x2>=1 and x2<=18
			tmp$=tmp$+"-"+STATWORD$[x2*10-9,x2*10]
		else
			if x2>=90 AND x2<95 let tmp$=tmp$+ "-In Process"
			if x2=95 let tmp$=tmp$+ "-PO Erp Proc"
			if x2=96 let tmp$=tmp$+ "-RTS Erp Proc"
			if x2=97 let tmp$=tmp$+ "-DM Erp Proc"
		Endif
		webstr$=webstr$,tmp$,fdel$ ! status
		tmp$=""
		if poh.DelvTime1
			tmp$=INT(poh.DelvTime1) using "&&"+":"+FRA(poh.DelvTime1)*100 using "&&"
		Endif
		webstr$=webstr$,tmp$,fdel$ ! delv time 1
		tmp$=""
		if poh.DelvTime2
			tmp$=INT(poh.DelvTime2) using "&&"+":"+FRA(poh.DelvTime2)*100 using "&&"
		Endif
		webstr$=webstr$,tmp$,fdel$ ! delv time 2
		if source<>381			
			if poh.PODiscType<>1 and poh.PODiscType<>2 let poh.PODiscType=0;poh.PODiscAmt=0
			tmp$="%"  ! \ if poh.PODiscType=1 let tmp$="%"
			if poh.PODiscType=2 let tmp$="$"
			let amount=poh.PODiscAmt
			if p61$[136,136]="Y" and poh.currfact<>0 and poh.PODiscType=2 and poh.PODiscAmt<>0! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=cnvca[0]
			endif
			webstr$=webstr$,tmp$,fdel$,amount using "###.##",fdel$ ! discount amt
		Endif		
		if not(poh.poduedate) or  poh.poduedate>991231
			let poh.poduedate=poh.duedate
		endif
		if Poh.poduedate<>0
			let xdate$=pdate$(poh.poduedate)
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! po date
		if p61$[136,136]="Y" and poh.currid<>0
			let keycurr$=" ",keycurr$
			let keycurr$=poh.currid using "####"
			search #ch_curr,2,1;keycurr$,rec_curr,e
			if not(e)
				Read Record #ch_curr,rec_curr;curr.;
				let tmp$=poh.currid using "####"
				let tmp$=tmp$+" "
				let tmp$=tmp$+rtrim$(curr.desc$)
				let webstr$=webstr$,tmp$,fdel$
			else
				let webstr$=webstr$,"",fdel$
			endif
		else
			let webstr$=webstr$,"",fdel$ ! currency
		endif
		let list$[2]=webstr$
	endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	!Call dxsave(0,"/tmp/md.txt!")
	! status section *** last section ***
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! Call dxsave(0,"/tmp/md.txt!")
	! done with it
        call SetOutPut(e$,rstr$)
!!! - end GETPOHDR
case  "RECALCDUE"  ! recalculates the due date
	call dxget ("vendid",Vendid$)
	let vendid=vendid$
	call dxget ("poid",poid$)
	let poid=poid$
	
	LET returnstatus=1
	let message$="OK"
	if vendid<=0 and not(poid)
		let message$="No Purchase Order Number Or Vendor Id Entered"
		let returnstatus=0
		goto endrecalcdue:
	endif
	keypoh$=" ",keypoh$
	keypoh$[1,6]=vendid using "######" 
	keypoh$[7,12]=poid using "######"
	mode$="=" ! search mode 2
	dir=2
	Rec_poh=filegetpohead(e$,ch_poh,mode$,dir,keypoh$,poh.)
	if rec_poh<0
		let returnstatus=0
		let message$="PO Number ",keypoh$[7,12]," Not On File"
		GOTO ENDrecalcdue:
	endif
	call dxget("DueDate",tmp$) 
	xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
	poh.duedate=xdate$[3,8]
	let keypol$=" ",keypol$
	let keypol$[1,6]=poid using "######"
	do
	 	search #ch_pol,3,1;keypol$,rec_pol,e
		if e<>0 exit do
		let tmp3=keypol$[1,6]
		if tmp3<>poid exit do
		Read Record #ch_pol,rec_pol,0;Pol.;
		if pol.status=1 or pol.status=11! not in receiving process
			let pol.duedate=poh.duedate
			Write Record #ch_pol,rec_pol,0;Pol.;
		endif
	loop

	ENDRECALCDUE: ! make the sections
	! status section *** last section ***
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! Call dxsave(0,"/tmp/md.txt!")
	! done with it
        call SetOutPut(e$,rstr$)
!!! - end RECALCDUEDATE

case "GETWHSEADDR"
	call dxget ("Warehouse",tmp$) !
	let poh.warehouse=tmp$
	LET returnstatus=1
	let message$="OK"
	if maxwh< (chf(ch_wh)-1) let maxwh=(chf(ch_wh)-1)
	if poh.warehouse<=0
		let returnstatus=0
		let message$="Invalid Warehouse"
	endif
	if poh.warehouse>(chf(ch_wh)-1)
		let returnstatus=0
		let message$="Invalid Warehouse"
	endif
	read record #ch_wh,(poh.warehouse-1);wh.;  
	Call StringSearch(UCase$(wh.zipcode$),"-",P)
	IF P<>1                                   
		let poh.ZipCode$=wh.zipcode$[1,9]  
	else ! "-" found                                                
		let poh.zipcode$=" ",poh.zipcode$               
		let poh.ZipCode$[1,5]=wh.zipcode$[1,5]          
		let poh.Zipcode$[6,9]=wh.zipcode$[7,10]         
		let p=0                                       
	endif                                                   
	Poh.ShipToName$=wh.WhName$                              
	poh.Address1$=wh.Address1$                              
	poh.Address2$=wh.Address2$                              
	poh.City$=wh.City$                                      
	poh.State$=wh.State$    
	Clear List$[]                                                         
	List$[0] = bsdel$ + "WhAddr" + fdel$ ! section name
	webstr$=webstr$,"ShipName",fdel$
	webstr$=webstr$,"ShipAddr1",fdel$
	webstr$=webstr$,"ShipAddr2",fdel$
	webstr$=webstr$,"ShipCity",fdel$
	webstr$=webstr$,"ShipState",fdel$
	webstr$=webstr$,"ShipZip",fdel$
	let list$[1]=webstr$
	if returnstatus<>0 ! no errors send over the data
		webstr$=""
		webstr$=webstr$,poh.ShipToName$,fdel$
		webstr$=webstr$,poh.Address1$,fdel$                       
		webstr$=webstr$,poh.Address2$,fdel$                          
		webstr$=webstr$,poh.city$,fdel$
		webstr$=webstr$,poh.state$,fdel$
		webstr$=webstr$,poh.zipcode$,fdel$		
	endif
	LIST$[2]=WEBSTR$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section

	
	! status section *** last section ***
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	
	! done with it
        call SetOutPut(e$,rstr$)
	!!! send over fields
case  "GETCUSTADDR" 
	let returnstatus=1
	let message$="OK"
	call dxget ("CUSTID",tmp$)
	let custid=tmp$
	if custid<=0 or custid>999999
		let returnstatus=0
		let message$="Invalid Customer Code "
	else
		let keycust$=custid using "######"
		search #ch_cust,2,1;keycust$,rec_cust,e
		if e<>0
			let returnstatus=0
			let message$="Customer "+str$(custid)+" Not Found."
		else
			read record #ch_cust,rec_cust,0;cust.;
		endif
	endif
	Clear List$[]                                                         
	List$[0] = bsdel$ + "POHShipInfo" + fdel$ ! section name
	webstr$="CustId",fdel$
	webstr$=webstr$,"ShipName",fdel$
	webstr$=webstr$,"ShipAddr1",fdel$
	webstr$=webstr$,"ShipAddr2",fdel$
	webstr$=webstr$,"ShipCity",fdel$
	webstr$=webstr$,"ShipState",fdel$
	webstr$=webstr$,"ShipZip",fdel$
	let list$[1]=webstr$
	row=2
	if returnstatus>0 and returnstatus<99! no errors send over the data
		webstr$=str$(custid),fdel$
		
		webstr$=webstr$,cust.Name$,fdel$
		webstr$=webstr$,cust.Addr1$,fdel$                       
		webstr$=webstr$,cust.Addr2$,fdel$                          
		webstr$=webstr$,cust.city$,fdel$
		webstr$=webstr$,cust.state$,fdel$
		webstr$=webstr$,cust.Zip4$,fdel$
		LIST$[2]=WEBSTR$
		row=row+1
	endif
	LIST$[row]=esdel$ ! end of section
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
    call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! Call dxsave(0,"/tmp/md.txt!")
	! done with it
        call SetOutPut(e$,rstr$)
case "GETORDADDR"
	call dxget ("ORDERID",tmp$) !
	ORDERID=tmp$
	LET returnstatus=1
	let message$="OK"
	if not (orderid)
		let returnstatus=0
		let message$="Invalid Order Id "+str$(orderid) 
		goto endordaddr:
	endif
	let keyroh$=" ",keyroh$
	let keyroh$[1,2]="1"
	let keyroh$[3]=orderid using "######"
	for stat=1 to 59
		let keyroh$[1,2]=stat using "##"
		search #ch_roh,2,1;keyroh$,rec_roh,e
		if not (e)
			read record #ch_roh,rec_roh;roh.;
			read record #ch_ros,roh.shiprec;ros.;
			goto foundorder:
		endif
	        if stat=7 let stat=57
	next stat
	let returnstatus=0
	let message$="Order Id "+str$(orderid)+" Not Found"
	goto endordaddr:
	foundorder: ! order has been found what to do now
        Poh.ShipToName$=ros.name$ 
	poh.Address1$=ros.Address$                              
	poh.Address2$=ros.Address2$                              
	poh.City$=ros.City$                                      
	poh.State$=ros.State$ 
	poh.zipcode$=" ",poh.zipcode$               
	poh.ZipCode$[1,5]=ros.zipcode$        
	let poh.Zipcode$[6,9]=ros.zip4$        
	endordaddr: ! end getting the order address
	Clear List$[]                                                         
	List$[0] = bsdel$ + "WhAddr" + fdel$ ! section name
	webstr$=webstr$,"ShipName",fdel$
	webstr$=webstr$,"ShipAddr1",fdel$
	webstr$=webstr$,"ShipAddr2",fdel$
	webstr$=webstr$,"ShipCity",fdel$
	webstr$=webstr$,"ShipState",fdel$
	webstr$=webstr$,"ShipZip",fdel$
	let list$[1]=webstr$
	if returnstatus<>0 ! no errors send over the data
		webstr$=""
		webstr$=webstr$,poh.ShipToName$,fdel$
		webstr$=webstr$,poh.Address1$,fdel$                       
		webstr$=webstr$,poh.Address2$,fdel$                          
		webstr$=webstr$,poh.city$,fdel$
		webstr$=webstr$,poh.state$,fdel$
		webstr$=webstr$,poh.zipcode$,fdel$		
	endif
	LIST$[2]=WEBSTR$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section

	
	! status section *** last section ***
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	
	! done with it
        call SetOutPut(e$,rstr$)
	!!! send over fields
	
case "SUBMITPOMSG"
	call dxget ("poid",poid$)
	let poid=poid$
	let returnstatus=1
	let message$="OK" ! null need to append with errors 
	call dxget ("SOURCE",tmp$)
	let source=tmp$
	if source=370
		let returnstatus=0
		let message$="Inquiry Only"
		goto EndPoMsgSubmit:
	endif
	if source=371
		let returnstatus=0
		let message$="Inquiry Only"
		goto EndPoMsgSubmit:
	endif
	if not(poid)
		let returnstatus=99
		let message$="PO Number "+str$(poid)+" Not on File"
		goto EndPOMsgSubmit:
	endif
    ! find po
	let keypoh$=" ",keypoh$
	let keypoh$[1,2]=" 1"
	LET keypoh$[3]=poid USING "######"
	for ctr=1 to 99
		let keypoh$[1,2]=ctr using "##"
		search #ch_poh,2,1;keypoh$,rec_poh,e
		if not(e)
			read record #ch_poh,rec_poh;poh.;
			goto foundpoidmsg:
		endif
		if ctr=18 let ctr=90
	next ctr
	let message$="Purchase Order "+str$(poid)+" Not On File"
	let returnstatus=99
	goto EndPOMsgSubmit
	foundpoidmsg:! found purchase order message
	if returnstatus<>0
			call verifystat()
			if returnstatus=99 goto endPOMsgSubmit:
	endif
	if returnstatus=1
		let keypom$=" ",keypom$
		let keypom$[1,1]="1" ! notes
		let keypom$[2,7]=poid using "&&&&&&"
		let keychk$=keypom$
		dir=1
		mode$=">"
		DO	! removes existing notes lines
			dir=1
			mode$=">"
			rec_tmp=filegetpom(e$,ch_pom,mode$,dir,keypom$,pom.)
			if rec_tmp<=0 exit do
			if keypom$[1,7]<>keychk$[1,7]  exit do
			
	                mode$ = "d" ! delete                                              
			UpdStatus = fileupdatepom(e$,ch_pom,mode$,rec_tmp,pom.)
		loop
	        let keypom$=" ",keypom$
		let keypom$[1,1]="2" ! message
		let keypom$[2,7]=poid using "&&&&&&"
		let keychk$=keypom$
		dir=1
		mode$=">"
		DO	! removes existing notes lines
			dir=1
			mode$=">"
			rec_tmp=filegetpom(e$,ch_pom,mode$,dir,keypom$,pom.)
			if rec_tmp<=0 exit do
			if keypom$[1,7]<>keychk$[1,7]  exit do
			
	                mode$ = "d" ! delete                                              
			UpdStatus = fileupdatepom(e$,ch_pom,mode$,rec_tmp,pom.)
		loop
	
		call dxget("ttlmsg",tmp$)
		let totctr=tmp$
		If totctr>=1
		for ctr=1 to totctr
			clear pom.
			call dxget ("message"+str$(ctr),tmp$)
			let pom.message$=tmp$+"                                               "
			call dxget ("messagetypeid"+str$(ctr),tmp$) 
			let pom.type$=tmp$
			if pom.type$<>"1" and pom.type$<>"2" let pom.type$="1" 
			let pom.ponum$=poid using "&&&&&&"
 			let keypom$=" ",keypom$
			let linenum=1
			let keypom$=" ",keypom$
			let keypom$[1,1]=pom.type$[1,1]
			let keypom$[2,7]=pom.ponum$[1,6]
			let keychk$=keypom$
			let keypom$[8,9]="99"
			search #ch_pom,6,1;keypom$,rec_pom,e
			if not(e) and keypom$[1,7]=keychk$[1,7]
				let linenum=keypom$[8,9]
				let linenum=linenum+1
			endif
			if linenum>99
				let returnstatus=0
				let message$="Message Line Number Exceeds Limit of 99"
			endif
			let pom.linenum$=linenum using "##"
			If returnstatus<>0 ! no error add it in
				let keypom$=" ",keypom$
				let keypom$[1,1]=pom.type$[1,1]
				let keypom$[2,7]=pom.ponum$[1,6]
				mode$ = "a" ! delete                                              
				UpdStatus = fileupdatepom(e$,ch_pom,mode$,rec_tmp,pom.)		
			endif
		next ctr
		endif ! === if totctr>=1
	endif
	EndPoMsgSubmit: ! end this
	clear list$[]
	List$[0]=bsdel$,"POMsgSubmit",fdel$
	WebStr$="POId",fdel$
	List$[1]=WebStr$
	WebStr$=str$(poid),fdel$
	LIST$[2]=Webstr$
	call AddToStr(e$,rstr$,List$[]) ! "add the list fpom subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)

case "GETPOMSG"
	! section 1 - Message Type Droplist
	call Dxget ("Source",tmp$)
	let source=tmp$
	clear list$[]
	List$[0]=bsdel$,"MessageTypeDroplist",fdel$
	WebStr$="ID",fdel$
	WebStr$=Webstr$,"Desc",fdel$
	List$[1]=WebStr$
	! if source<>370 
	let row=2
	for ctr=0 to 9
		let tmp$=rtrim$(msglist$[((ctr*16)+1),((ctr*16)+16)])
		if tmp$<>""
			webstr$=str$(ctr),fdel$
			webstr$=webstr$,tmp$,fdel$
			List$[row]=WebStr$
			let row=row+1
		endif
	next ctr
	!endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! section 2 - po Messages
	call dxget ("poid",poid$)
	let poid=poid$
	let returnstatus=1
	let message$="OK" ! null need to append with errors 
	if not(poid)
		let returnstatus=0
		let message$="PO Number "+str$(poid)+" Not on File"
	endif
	clear list$[]
	List$[0]=bsdel$,"POMessages",fdel$
	WebStr$="Message",fdel$
	WebStr$=Webstr$,"MessageTypeID",fdel$
	Webstr$=Webstr$,"MessageTypeDesc",fdel$
	List$[1]=WebStr$
	let ctr=2
	if returnstatus<>0
		let keypom$=" ",keypom$
		let keypom$="1" ! notes first
		let keypom$[2,7]=poid using "&&&&&&"
		let keychk$=keypom$
		dir=1
		mode$=">"
		DO	! note lines
			rec_tmp=filegetpom(e$,ch_pom,mode$,dir,keypom$,pom.)
			if rec_tmp<=0 exit do
			if keypom$[1,7]<>keychk$ exit do
	                WebStr$=pom.message$,fdel$
			WebStr$=Webstr$+pom.type$,fdel$
			let tmp$=rtrim$(msglist$[((msgtype*16)+1),((msgtype*16)+16)])
			Webstr$=Webstr$,tmp$,fdel$
			List$[ctr]=WebStr$
			let ctr=ctr+1
		loop
		let keypom$=" ",keypom$
		let keypom$="2" ! messages first
		let keypom$[2,7]=poid using "&&&&&&"
		let keychk$=keypom$
		dir=1
		mode$=">"
		DO	! message lines
			rec_tmp=filegetpom(e$,ch_pom,mode$,dir,keypom$,pom.)
			if rec_tmp<=0 exit do
			if keypom$[1,7]<>keychk$ exit do
	                WebStr$=pom.message$,fdel$
			WebStr$=Webstr$+pom.type$,fdel$
			let tmp$=rtrim$(msglist$[((msgtype*16)+1),((msgtype*16)+16)])
			Webstr$=Webstr$,tmp$,fdel$
			List$[ctr]=WebStr$
			let ctr=ctr+1
		loop
	endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! special message section
	clear list$[]
	!if source<>370
		Ch_spmsg = OpenFile(-1776,intCo) \ If ch_spmsg = -1 Error 42
		Call FileDropListSpecMsg(e$,List$[],maxcnt,Ch_spmsg)
	!else
		!List$[0]=bsdel$,"droplistspecmsg",fdel$
		!WebStr$="ID",fdel$
		!WebStr$=Webstr$,"Message",fdel$
		!List$[1]=WebStr$
		!List$[2]=esdel$
	!endif
	Call AddToStr(e$,rstr$,List$[])  
	 !Call AddToStr(e$,rstr$,esdel$) ! end of section
	 if ch_spmsg>0 close #ch_spmsg
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)

case "GETPOTOT"
	
	let returnstatus=1
	let message$="OK"
	Call Dxget ("SOURCE",tmp$)
	let source=tmp$
	! section 1 - Misc Charges Droplist
	List$[0]=bsdel$,"MiscChargeDroplist",fdel$
	WebStr$="ID",fdel$
	WebStr$=Webstr$,"Desc",fdel$
	List$[1]=WebStr$
	! if source<>370
	let ctr=2
	let tmpcnt=maxcnt
	let rec_tmp=(chf(ch_misc))-1
	for rec_misc=1 to rec_tmp
		read record #ch_misc,rec_misc;misc.;
		! if misc.type=1 ! po -- not for order's when using the misc chrg file
		if rtrim$(misc.desc$)<>""
			let webstr$=str$(rec_misc),fdel$
			let webstr$=webstr$,misc.desc$,fdel$
			let list$[ctr]=Webstr$
			let ctr=ctr+1
			If ctr > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
			! check the count  neex to expand variable
		 endif
		!endif
	next rec_misc
	! endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	! section 2 - freight charges
	call freightunits(List$[])
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	! section 3 - po Total
	call dxget ("vendid",Vendid$)
	call dxget ("poid",poid$)
	let vendid=vendid$
	let poid=poid$
	LET returnstatus=1
	let message$="OK"
	keypoh$=" ",keypoh$
	keypoh$[1,6]=vendid using "######" 
	keypoh$[7,12]=poid using "######"
	mode$="=" ! search mode 2
	dir=2
	Rec_poh=filegetpohead(e$,ch_poh,mode$,dir,keypoh$,poh.)
	if rec_poh<0
		let returnstatus=0
		let message$="PO Number ",keypoh$[7,12]," Not On File"
		goto endgetpotot:
	endif
	clear vend.
	call verifyvendor()
	if not (returnstatus) goto endgetpotot:
	call dxget ("SOURCE",tmp$)
	source=tmp$
	
	orgtot[0]=poh.TotAmt 
	orgtot[1]=poh.TotWeight
	orgtot[2]=poh.TotCubes
	orgtot[3]=poh.TotPieces
	call calcpototals()
	if poh.status=7 goto endgetpotot: ! not need to update closed status
	if source=370 goto endgetpotot: ! inquiry only no update needed
	if rec_poh>0
		Write Record #ch_poh,Rec_poh;poh.;
	endif
	clear parm[]
	Parm[0]=rec_poh
	Parm[1]=361 ! source
	if source=371 let parm[1]=371
	if source=381 let parm[1]=371
	Parm[2]=2 ! edit mode 2=edit/1=entry
	Parm[9]=intco ! company #
	if not (poh.FreightOverride) ! poh.override
		if not(orgtot[0]+orgtot[1]+orgtot[2]+orgtot[3]) and not (poh.oldstatus) and not(poh.FreightAmt)
				let Parm[2]=1 ! entry mode
		endif
	!IF POH.TOTAMT<>ORGTOT[0] OR poh.TotWeight<>ORGTOT[1] OR poh.TotCubes<>ORGTOT[2] OR poh.TotPieces<>ORGTOT[3]                                                                        
		 clear chan[]
		 chan[0]=ctlc 
		 chan[1]=ch_poh
		 chan[16]=ch_vend! vendor file
		 CALL "POFRGTCHG",chan[],parm[]                                            
	!endif
		if rec_poh>0
			Read Record #ch_poh,Rec_poh;poh.;
		endif
	endif
	endgetpotot: ! end getting the po total 
	clear list$[]
	List$[0]=bsdel$,"POTotalDisp",fdel$
	WebStr$="POId",fdel$
	webstr$=webstr$,"VendorID",fdel$
	webstr$=webstr$,"BuyName",fdel$
	Webstr$=webstr$,"ShipName",fdel$
	Webstr$=webstr$,"PoType",fdel$
	WebStr$=webstr$,"TotAmount",fdel$
	WebStr$=webstr$,"TotWeight",fdel$
	WebStr$=Webstr$,"TotCubes",fdel$
	Webstr$=Webstr$,"TotPiece",fdel$
	Webstr$=Webstr$,"TotValue",fdel$
	Webstr$=webstr$,"TotNumLine",fdel$
	Webstr$=webstr$,"PRONTORTS",fdel$
	webstr$=webstr$,"TotRecvAmt",fdel$
	webstr$=webstr$,"TotRecvWgt",fdel$
	webstr$=webstr$,"TotRecvCube",fdel$
	webstr$=webstr$,"TotRecvPiece",fdel$
	webstr$=webstr$,"PrevPrinted",fdel$
	webstr$=webstr$,"EDIFlag",fdel$
	webstr$=webstr$,"CostSecurity",fdel$ ! po/last cost
	webstr$=webstr$,"IncrementFlag",fdel$ ! su flag to display the po increment level
	webstr$=webstr$,"HasDiscFlag",fdel$
	webstr$=webstr$,"GrossValue",fdel$
	webstr$=webstr$,"Discount",fdel$
	webstr$=webstr$,"TotalValue",fdel$
	webstr$=webstr$,"Currency",fdel$
	List$[1]=WebStr$
	if returnstatus<>0
		WebStr$=str$(poid),fdel$
		Webstr$=webstr$+str$(vendid),fdel$
		Webstr$=webstr$+rtrim$(vend.name$),fdel$
		webstr$=webstr$+rtrim$(poh.ShipToName$),fdel$
		let tmp$=" ",tmp$
		IF poh.type=0 tmp$="W"  
		IF poh.type=1 tmp$="D"  
		IF poh.type=2 tmp$="I" 
		IF poh.type=3 tmp$="M" 
		IF poh.type=4 tmp$="IW" 
		IF poh.type=5 tmp$="ID"
		IF poh.type=6 tmp$="II" 
		IF poh.type=7 tmp$="IM"
		Webstr$=Webstr$+rtrim$(tmp$)+fdel$ ! type
		let amount=TotOrdAmt
		if p61$[136,136]="Y" and poh.currfact<>0 ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=poh.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=cnvca[0]
		endif
		Webstr$=webstr$+RTrim$(amount  Using "-----------.##") + fdel$  ! TotOrdAmt 
		Webstr$=webstr$+RTrim$(TotOrdWgt  Using "-----------.##") + fdel$ 
		Webstr$=webstr$+RTrim$(TotOrdCube Using "-----------.##") + fdel$ 
		Webstr$=webstr$+RTrim$(TotOrdQty Using "---------.##") + fdel$
		let amount=poh.totamt
		if p61$[136,136]="Y" and poh.currfact<>0 ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=poh.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=cnvca[0]
		endif
		Webstr$=webstr$+RTrim$(amount Using "----------.##") + fdel$ ! value either rcvd or ! poh.totamt
		Webstr$=webstr$+STR$(numlines) + fdel$
		webstr$=webstr$+p60$[45,45]+fdel$
		let amount=TotrcvdAmt
		if p61$[136,136]="Y" and poh.currfact<>0 ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=poh.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=cnvca[0]
		endif
		Webstr$=webstr$+RTrim$(Amount Using "-----------.##") + fdel$  ! TotrcvdAmt
		Webstr$=webstr$+RTrim$(TotrcvdWgt  Using "-----------.##") + fdel$ 
		Webstr$=webstr$+RTrim$(TotrcvdCube Using "-----------.##") + fdel$ 
		Webstr$=webstr$+RTrim$(TotrcvdQty Using "---------.##") + fdel$
		tmp$="N"
		if source=381 and poh.oldstatus=12 let tmp$="Y"
		webstr$=webstr$+Rtrim$(tmp$)+fdel$
		let tmp$="N"
		if source<370
			if poh.EdiStatus$[1,1]="n" let tmp$="Y"
		endif
		webstr$=webstr$+rtrim$(tmp$)+fdel$
		webstr$=webstr$+str$(cost_lev[2]),fdel$
		let tmp$="Y"
		if p61$[118,118]="N" let tmp$="N"
		webstr$=webstr$,tmp$,fdel$
		let tmp$="N"
		if hasdisc<>0 and cost_lev[2]<>0 let tmp$="Y"
		webstr$=webstr$,tmp$,fdel$ ! hasdiscflag
		IF HASDISC<>0
			amount=totuntc
			if p61$[136,136]="Y" and poh.currfact<>0 ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=cnvca[0]
			endif
			Webstr$=webstr$+RTrim$(amount Using "-----------.##") + fdel$  ! gross value	totuntc
			amount=totuntc-poh.totamt
			if p61$[136,136]="Y" and poh.currfact<>0 ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=cnvca[0]
			endif
			Webstr$=webstr$+RTrim$((amount) Using "-----------.##") + fdel$ ! DISCOUNT  totuntc-poh.totamt
			amount=poh.totamt
			if p61$[136,136]="Y" and poh.currfact<>0 ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=cnvca[0]
			endif
			Webstr$=webstr$+RTrim$(amount Using "-----------.##") + fdel$ ! TOTALVALUE poh.totamt
		ELSE
			Webstr$=webstr$+"0.00"+fdel$
			Webstr$=webstr$+"0.00"+fdel$
			Webstr$=webstr$+"0.00"+fdel$
		endif
		if p61$[136,136]="Y" and poh.currid<>0
			let keycurr$=" ",keycurr$
			let keycurr$=poh.currid using "####"
			search #ch_curr,2,1;keycurr$,rec_curr,e
			if not(e)
				Read Record #ch_curr,rec_curr;curr.;
				let tmp$=poh.currid using "####"
				let tmp$=tmp$+" "
				let tmp$=tmp$+rtrim$(curr.desc$)
				let webstr$=webstr$,tmp$,fdel$
			else
				let webstr$=webstr$,"",fdel$
			endif
		else
			let webstr$=webstr$,"",fdel$ ! currency
		endif
	LIST$[2]=Webstr$
	endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! section for edit fields freight fields
	clear list$[]
	List$[0]=bsdel$,"POTotalEdit",fdel$
	Webstr$="UnitFreightCode",fdel$
	Webstr$=webstr$,"FreightDesc",fdel$
	Webstr$=webstr$,"UnitFreightAmt",fdel$
	Webstr$=webstr$,"TotalFreight",fdel$
	Webstr$=webstr$,"PreviousFreight",fdel$
	let list$[1]=webstr$
	! edits fields
	if returnstatus<>0
		webstr$=str$(poh.FreightUnitCode)+ fdel$
		let tmp$=""
		if poh.freightUnitCode=0 let tmp$="Flat"
		if poh.freightUnitCode=1 let tmp$="LB"
		if poh.freightUnitCode=2 let tmp$="CWT"
		if poh.freightUnitCode=3 let tmp$="CUBE"
		If poh.freightUnitCode=4 let tmp$="PIECE"
		webstr$=webstr$+tmp$+fdel$
		amount=poh.freightUnitCh
			if p61$[136,136]="Y" and poh.currfact<>0 ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=cnvca[0]
			endif
		webstr$=webstr$+ Rtrim$(amount Using "-----------.##") + fdel$ ! poh.FreightUnitCh
		amount=poh.freightamt
			if p61$[136,136]="Y" and poh.currfact<>0 ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=cnvca[0]
			endif
		webstr$=webstr$+ Rtrim$(amount Using "-----------.##") + fdel$ ! poh.freightamt
		if source=370
			amount=poh.TotPoFreightRec
			if p61$[136,136]="Y" and poh.currfact<>0 ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=cnvca[0]
			endif
			webstr$=webstr$+ Rtrim$(amount Using "-----------.##") + fdel$ ! poh.TotPoFreightRec
		else
			webstr$=webstr$+""+fdel$
		endif
		LIST$[2]=Webstr$
	endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! misc charge section
	clear list$[]
	List$[0]=bsdel$,"PoTotMisc",fdel$
	webstr$=""
	webstr$=webstr$,"MiscId",fdel$
	webstr$=webstr$,"MiscDesc",fdel$
	webstr$=webstr$,"MiscChrg",fdel$
	list$[1]=Webstr$
	let row=2
	if returnstatus<>0
		mat read #ch_poh,rec_poh,350;miscchrg;
		mat read #ch_poh,rec_poh,330;MiscCODE; 
		webstr$=""
		for ctr=0 to 4
			if misccode[ctr]<>0
				webstr$= Rtrim$(misccode[ctr] Using "###") + fdel$
				read record #ch_misc,misccode[ctr];misc.;
				let tmp$=misc.desc$
				webstr$=webstr$+Rtrim$(tmp$)+fdel$
				let amount=miscchrg[ctr]
				if p61$[136,136]="Y" and poh.currfact<>0 ! going for base to costing um
					let cnvcu[0]=1
					let cnvca[0]=amount
					let cnvca[1]=poh.currfact
					call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
					let amount=cnvca[0]
				endif
				webstr$=webstr$+ Rtrim$(amount Using "-----------.##") + fdel$ ! miscchrg[ctr]
		
				let list$[row]=webstr$
				let row=row+1
			endif
		next ctr
	endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)





 Case "SUBMITPOTOT" 
	returnstatus=1
	let message$="OK"
	DIM 1%,resetprtstat
	call dxget ("SOURCE",tmp$)
	let source=tmp$
	if source=370
		let returnstatus=0
		let message$="Inquiry Only"
		goto endsubmitpotot:
	endif
	
	let returnstatus=1
	let message$="OK"
	call dxget ("Vendid",Vendid$)
	call dxget ("poid",poid$)
	call dxget ("editstatus",tmp$)
	let editstatus=tmp$
	let acceptrts=0
	let resetprtstat=0
	if source=371 and p60$[45,45]="Y" and editstatus=9
		call dxget ("acceptrts",tmp$)
		let acceptrts=tmp$
		if rtrim$(tmp$)="1" let acceptrts=1
	endif
	
	let vendid=vendid$
	let poid=poid$
	LET returnstatus=1
	let message$="OK"
	keypoh$=" ",keypoh$
	keypoh$[1,6]=vendid using "######" 
	keypoh$[7,12]=poid using "######"
	mode$="=" ! search mode 2
	dir=2
	Rec_poh=filegetpohead(e$,ch_poh,mode$,dir,keypoh$,poh.)
	if rec_poh<0
		let returnstatus=99
		let message$="PO Number ",keypoh$[7,12]," Not On File"
		goto endsubmitpotot:
	endif
	if returnstatus<>0
		call verifystat()
		if returnstatus=99 goto endSubmitPotot:
	endif
	if returnstatus=0 goto endsubmitpotot:
	clear vend.
	let keyvend$=vendid using "######"
	mode$="="
	dirno=1
	VendRec=FileGetA80vm(e$,Ch_vend,mode$,dirno,Keyvend$,vend.)
	if VendRec<0 ! record not found
		 let returnstatus=0
		 let message$="Vendor "+str$(vendid)+" Not on File"
		 goto endsubmitpotot:
	endif
	Mat Read #ch_poh,Rec_poh,350;MiscChrg;
	Mat Read #ch_poh,Rec_poh,330;misccode;
	LET poh.TotMiscCharges=0
	for ctr=1 to 5 ! for misc charges
		LET MiscCODE[ctr-1]=0;MiscCHrg[CTR-1]=0
		call dxget ("MiscCode"+str$(ctr),tmp$)
		let misccode[ctr-1]=tmp$
		if misccode[ctr-1]
			call dxget("MiscChrg"+str$(ctr),tmp$)
			let miscchrg[ctr-1]=tmp$
			if p61$[136,136]="Y" and poh.currfact<>0 and miscchrg[ctr-1]<>0! going to base currency
					let amount=miscchrg[ctr-1]
					let cnvcu[0]=2
					let cnvca[0]=amount
					let cnvca[1]=poh.currfact
					call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
					let miscchrg[ctr-1]=cnvca[0]
				endif
			let poh.TotMiscCharges=poh.TotMiscCharges+miscchrg[ctr-1]
		endif
	next ctr
	call dxget("UnitFreightCode",tmp$)
	poh.freightUnitCode=tmp$
	call dxget("UnitFreightAmt",tmp$)
	poh.FreightUnitCh=tmp$
	if p61$[136,136]="Y" and poh.currfact<>0 and poh.FreightUnitCh<>0 ! going for base to costing um
		let amount=poh.FreightUnitCh
		let cnvcu[0]=2
		let cnvca[0]=amount
		let cnvca[1]=poh.currfact
		call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
		let poh.FreightUnitCh=cnvca[0]
	endif
	call dxget("TotalFreight",tmp$)
	poh.FreightAmt=tmp$
	if p61$[136,136]="Y" and poh.currfact<>0 and poh.FreightAmt<>0 ! going for base to costing um
		let amount=poh.FreightAmt
		let cnvcu[0]=2
		let cnvca[0]=amount
		let cnvca[1]=poh.currfact
		call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
		let poh.FreightAmt=cnvca[0]
	endif
	call dxget("FreightEdit",tmp$)!  Y/n
	if tmp$="Y"
		poh.FreightOverride=99
	endif
	call dxget("IncrLvl",tmp$) ! y/n = no change level 1= change
	if tmp$="Y"
		poh.ChangeLevel=poh.changelevel+1
	endif
	! write out the totals
	write record #ch_poh,rec_poh;poh.; ! write file record first then misc charge array
	Mat Write #ch_poh,Rec_poh,350;MiscChrg;
	Mat Write #ch_poh,Rec_poh,330;misccode;
	if editstatus=9 and source=371
	if p9$[1,1]="Y" or p9$[1,1]="B"
		keypol$ = " ",keypol$                                         
		keypol$= POH.purchaseorder Using "######"               
		keychk$ = " ",keychk$                                         
		keychk$[1,6] = keypol$[1,6]                                   
		mode$ = ">"                                                   
		dir = 1                                                        
		Do                                                            
			rec_pol = filegetpoline(e$,ch_pol,mode$,dir,keypol$,pol.)   
			If rec_pol < 0 Exit Do                                      
			If keypol$[1,6] <> keychk$[1,6] Exit Do  
			
                        	If pol.CurrQtyRcvd <> 0  and pol.UpdStock<>0
				LET X2=pol.flags ! ! REM UNPACK pol.Flags TO FLAGS[x] 
	        			FOR K=0 TO 11                     
		   			LET FLAGS[K]=SGN(FRA(X2/2)) \ LET X2=INT(X2/2) 
				NEXT K
		       		 if not(flags[0])  and not(flags[2])! product line and not a message
					let rec_prod=pol.ProdDescRec
					read record #ch_prod,rec_prod;prod.;! read the product file
					If  prod.lotctrl$="Y"
						let tmpkey$=" ",tmpkey$ ! mtg
						let tmpkey$[1,9]=keypol$[1,9]
						Search #ch_polot,3,1;tmpkey$,rec_spolot,e
						if e=2
							let returnstatus=0
							let message$="Please check Lot Allocations for Line "+keypol$[7,9]
							goto endsubmitpotot:
						else
							if not(e)
								if tmpkey$[1,9]<>keypol$[1,9]
									let returnstatus=0
									let message$="Please check Lot Allocations for Line "+keypol$[7,9]
									goto endsubmitpotot:
								endif
							endif
						endif
					endif
				endif
			endif
		loop
	endif
endif

	! call to allocate freight charges to lines 
	clear chan[]
	chan[0]=ctlc
	chan[1]=ch_poh
	chan[2]=ch_pol
	chan[4]=Ch_Prod
	chan[5]=ch_prwh
	chan[6]=ch_nstk
	chan[14]=ch_wh
	chan[15]=ch_misc
	parm[0]=rec_poh
	parm[1]=361 ! source for po entry/edit
	if source=371 let parm[1]=371
	if source=381 let parm[1]=371
	parm[9]=intco
	Call "PO361D1.dl4",chan[],parm[]
	if editstatus=9 ! po completed
		read record #ch_poh,rec_poh;poh.;
		if source<>371 and source<>381
			let poh.status=poh.oldstatus
			if poh.status<=0 let poh.status=1
			if poh.status>89 let poh.status=1
		else
			if source=371
				let poh.status=5
				iF ACCEPTRTS<>0 AND P60$[45,45]="Y"
					let poh.status=6 ! pronto accept
				ENDIF
				IF ACCEPTRTS=0 OR P61$[91,91]="Y"
					keypol$ = " ",keypol$                                         
					keypol$= POH.purchaseorder Using "######"               
					keychk$ = " ",keychk$                                         
					keychk$[1,6] = keypol$[1,6]                                   
					mode$ = ">"                                                   
					dir = 1                                                       
					chkrecv = 0  
					linksoflag=0
					Do                                                            
						rec_pol = filegetpoline(e$,ch_pol,mode$,dir,keypol$,pol.)   
						If rec_pol < 0 Exit Do                                      
						If keypol$[1,6] <> keychk$[1,6] Exit Do  
                        If pol.CurrQtyRcvd <> 0 
							Let chkrecv = 99 !\ exit do
							if p61$[91,91]="Y"
								IF pol.salesord<>0 and pol.salesordline<>0
									let linksoflag=99
									exit do
								endif
							else
								exit do
							endif
						endif
						If pol.Freeqtyrcvd <> 0
							Let chkrecv = 99 !\exit do
							if p61$[91,91]="Y"
								IF pol.salesord<>0 and pol.salesordline<>0
									let linksoflag=99
									exit do
								endif
							else
								exit do
							endif
						endif
						X2 = pol.flags                                              
						For K = 0 To 11                                             
							flags[K] = Sgn(Fra(X2 / 2)) \ X2 = Int(X2 / 2)            
						Next K                                                      
						If flags[1] <> 0 
							Let chkrecv = 99 ! *** CLOSED SHORT **** 
							IF P61$[91,91]="Y"
								IF pol.salesord<>0 and pol.salesordline<>0
									let linksoflag=99
									exit do
								endif
							else
								exit do
							endif
						endif                                                                                     
                    Loop
					if not(chkrecv) and not(acceptrts) let poh.status=4 ! nothing short/nothing received
				endif
				! CHKREC
			else
				if source=381 ! debit memo
					let poh.status=poh.oldstatus
					if poh.status>14 let poh.status=11
					if poh.status<11 let poh.status=11
					if  poh.oldstatus=12 
						call dxget ("RESETPRTSTAT",tmp$)
						if ucase$(TMP$)="Y" let poh.status=11
					endif
				endif
			endif
		endif
		IF SOURCE<370 ! for purchase orders
		MAT  READ #CTLC,60,6;EDIFLG$;!!! edi flag check
		IF EDIFLG$[2,2]="T" or EDIFLG$[2,2]="H"
			if poh.EdiStatus$[1,1]="n"
				call dxget("TRANSEDI",tmp$)
				if rtrim$(ucase$(tmp$))="Y"
				dim 1%,ch_edi,3%,rec_edi,keyedi$[50]
				dim TRUM$[4],TRVI$[20],TRCT$[2]
				DIM 2%,TR[8]      
				DIM 3%,TR1[8],TR2[1]
			
				fname$="4/EDITRANS"+STR$(INTCO)
				Call FindF(Fname$,A9)
				IF A9<>0
					ch_edi=FINDCHANNEL()
					Try 
						OPEN #ch_edi,FNAME$
						LET Keyedi$=" ",Keyedi$;Keyedi$[1,12]=poid USING "PO##########"           
						SEARCH #ch_edi,2,1;Keyedi$,rec_edi,E                   
						if e=1                                                  
							LET E=2 \ SEARCH #ch_edi,1,0;Keyedi$,rec_edi,E \if e<>0 goto endedi:         
							                   
							FOR I=0 TO 8 \ LET TR[I]=0;TR1[I]=0 \ NEXT I                            
							LET TR2[0]=0;TR2[1]=0                                                   
							LET TRUM$=" ",TRUM$;TRVI$=" ",TRVI$;TRCT$=" ",TRCT$                     
							MAT  WRITE #ch_edi,rec_edi,0;TRVI$[1,12];                                     
							MAT  WRITE #ch_edi,rec_edi,12;TR                                              
							MAT  WRITE #ch_edi,rec_edi,48;TR1                                             
							MAT  WRITE #ch_edi,rec_edi,102;TRUM$                                          
							MAT  WRITE #ch_edi,rec_edi,106;TRVI$ \ MAT  WRITE #ch_edi,rec_edi,126;TRCT$;        
							MAT  WRITE #ch_edi,rec_edi,158;TR2;                                           
							MAT  WRITE #ch_edi,rec_edi,170;Keyedi$; 
							SEARCH #ch_edi,4,1;Keyedi$,rec_edi,E \ IF e goto endedi:
							let poh.EdiStatus$=" ",poh.edistatus$
							let poh.EdiStatus$="p",keyedi$
							endedi: ! end edi transaction
						endif
						
					else
						rem no file found
						
					end try
				endif ! file found
			endif! transedi=Y/N
			endif ! st$="N"
		endif ! edi on
	 endif ! entry/edit                                            
		write record #ch_poh,rec_poh;poh.; ! po complete
		let keypoh$=" ",keypoh$
		let keypoh$[1,2]=poh.status using "##"
		let keypoh$[3,8]=poid using "######"
		search #ch_poh,4,1;keypoh$,rec_poh,e
		let keypoh$[1,2]="95"
		if source=371 let keypoh$[1,2]="96"
		if source=381 let keypoh$[1,2]="97"
		search #ch_poh,5,1;keypoh$,rec_tmp,e
	endif ! edit status
	
                                       
	if editstatus=9 and source=371 and acceptrts<>0
		! accept receipts to status
		for ctr=0 to 25\let fchan[ctr]=-1\next ctr
		! general ledger files
		dim 1%,spo,poglflag
		dim cmd$[100]
		mat read #ctlc,51,76;SPO;
		Mat Read #ctlc,51,88;POGLFLAG;
		if p9$[17,17]="Y" and spo<>0 and poglflag<>0
			Dim GLCKEY$[50],3%,REC_GLC
			!FCHAN[20] =  50    6/GLPOPRONTO or 6/GLPOTEMP 
			!FCHAN[21] =  51    6/GLPOCNTRL1               
			!FCHAN[22] =  52    4/GLPODETL1
			fchan[21]   =   OpenFile(9710,intCo) \ If fchan[21] = -1 Error 42 !  6/GLPOCNTRL  
			GLCKEY$ = " ",GLCKEY$;GLCKEY$[1,6] = "DFAULT"
			Search #fchan[21],2,1;GLCKEY$,REC_GLC,E 
			If E
				returnstatus=9
				Message$="G/L - P/O INTERFACE CONTROL NOT SETUP PROPERLY. No Update Performed."
				goto endsubmitpotot: ! 
			End If 
			fchan[22]   =   OpenFile(9709,intCo) \ If fchan[22] = -1 Error 42 ! 4/GLPODETL
			Fname$ =  "files/"+"6/GLPOPRONTO" + Str$(intco)
			Call FindF(Fname$,A9)
			If A9<>0
				fchan[20]   =   OpenFile(9711,intCo) \ If fchan[20] = -1 Error 42 ! 6/GLPOPRONTO
			else
				fchan[20] = FindChannel()
				CMD$ = "[1:10] ",Fname$,"!"
				Build #fchan[20],CMD$
				TMPREC = 9 \ Search #fchan[20],0,1;tmpkey$,TMPREC,E
				if e>0
					returnstatus=9
					Message$="Error in Creating GL-PO Temp File. No Update Performed."
					goto endsubmitpotot: ! 
				endif
				TMPREC = 1 \ Search #fchan[20],0,0;tmpkey$,TMPREC,E
				if e>0
					returnstatus=9
					Message$="Error in Creating GL-PO Temp File. No Update Performed."
					goto endsubmitpotot: ! 
				endif 
				Close #fchan[20]
				fchan[20]   =   OpenFile(9711,intCo) \ If fchan[20] = -1 Error 42 ! 6/GLPOPRONTO
			 End If 
    		endif
		FCHAN[0]   =   ch_prod !                  
		FCHAN[1]   =   ch_vend !                 
		fchan[2]   =   OpenFile(2976,intCo) \ If fchan[2] = -1 Error 42 !    3/SPOFLEN1               
		FCHAN[3]   =   OpenFile(416,intCo) \ If fchan[3] = -1 Error 42 !7    2/PSERLNO1               
		FCHAN[4]   =   ch_poh !                
		FCHAN[5]   =   ch_pol                
		FCHAN[6]   =   Ch_PrWh ! 10    2/SPRODWHSE1              
		FCHAN[7]   =   Ch_alt ! 13    2/ALTVEND1                
		FCHAN[8]   =   ch_nstk !14    3/SNSTKDESC1              
		FCHAN[9]   =   OpenFile(2336,intCo) \ If fchan[9] = -1 Error 42!16    2/VDPRHIST1               
		FCHAN[10] =  Ch_sprodlot ! 17    3/SPRODLOT1                
		FCHAN[11] =  Ch_polot !18    3/SPOLOT1                  
		!FCHAN[12] =  -1     *****
	        If P60$[9,9] = "F" Or P60$[9,9] = "L" ! fifo/lifo
			fchan[13] = OpenFile(3008,intCo) \ If fchan[13] = -1 Error 42 !fifo lot
			fchan[14] = OpenFile(3024,intCo) \ If fchan[14] = -1 Error 42 !fifo trans
			If P61$[60,60] = "Y"
				fchan[19] = OpenFile(9948,intCo) \ If fchan[19] = -1 Error 42 !fifospc
			End If 
		End If 
		
		If SPO
			fchan[15] = OpenFile(9947,intCo) \ If fchan[15] = -1 Error 42 !poctfle
		End If 
		If P61$[22,22] = "Y" Or P61$[22,22] = "L" 
			FCHAN[16] =OpenFile(9946,intCo) ! \ If fchan[16] = -1 Error 42 ! 31    3/PORFLINE1 
		endif
		FCHAN[17] = OpenFile( 2512,intCo) ! \ If fchan[17] = -1 Error 42 ! 15    4/INVTRANS1 
		FCHAN[18] =  ch_wh  ! 29    2/WHINFO1                  
		                
		!FCHAN[20] =  50    6/GLPOPRONTO or 6/GLPOTEMP 
		!FCHAN[21] =  51    6/GLPOCNTRL1               
		!FCHAN[22] =  52    4/GLPODETL1
		!FCHAN[23] =  35    nsinvtran
		WHSE=0
		Call "PO374A.DL4",FCHAN[],REC_POH,REC_POH,WHSE,rec_uac,e$,IntCo,rstr$
		tmp$ = "";tmp3 = 0                              
		If p61$[91,91] = "Y"   
			if linksoflag<>0
				Call "264ns.dl4",tmp$,tmp3,tmp$               
				If rtrim$(tmp$)<>"" Let Message$ = Message$ + " " + tmp$ 
			End If  
		endif
	endif
	endsubmitpotot: ! 
	List$[0]=bsdel$,"SubmitTotal",fdel$
	webstr$="poId"
	List$[1]=webstr$
	WebStr$=str$(poid),fdel$
	LIST$[2]=Webstr$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
       
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)

case  "VERIFYSALESORDER" 
	dim k2$[60],K3$[60]
	Dim 1%,PGOT[38],pgmlit
	Dim 3%,WHMISC2[7],rec_pgp
	let ch_pgp=0
	call dxget ("vendid",Vendid$)
	let vendid=vendid$
	call dxget ("poid",poid$)
	let poid=poid$
	call dxget ("orderid",tmp$)
	let ORDERID=tmp$
	LET returnstatus=1
	let message$="OK"
	call verifyvendor()
	call dxget("SOURCE",tmp$)
	let source=tmp$
	if source=370
		let returnstatus=0
		let message$="Inquiry Only"
		goto EndVerifyOrder:
	endif
	if not (returnstatus) goto ENDVERIFYORDER:
	let linesexist=0
	keypoh$=" ",keypoh$
	keypoh$[1,6]=vendid using "######" 
	keypoh$[7,12]=poid using "######"
	mode$="=" ! search mode 2
	dir=2
	Rec_poh=filegetpohead(e$,ch_poh,mode$,dir,keypoh$,poh.)
	if rec_poh<0
		let returnstatus=0
		let message$="PO Number ",keypoh$[7,12]," Not On File"
		GOTO ENDVERIFYORDER:
	endif
	if not (orderid)
		let returnstatus=0
		let message$="Invalid Order Id "+str$(orderid) 
		goto endverifyorder:
	endif
	call dxget("potype",tmp$) 
	let potype$=tmp$
	let poh.type=-1
	if rtrim$(tmp$)="W" let poh.type=0
	if rtrim$(tmp$)="D" let poh.type=1
	if rtrim$(tmp$)="I" let poh.type=2
	if p60$[46,46]="Y"
		if rtrim$(tmp$)="IW" let poh.type=4
		if rtrim$(tmp$)="ID" let poh.type=5
		if rtrim$(tmp$)="II" let poh.type=6
	endif
	if poh.type<0
		let returnstatus=0
		let message$="Invalid Purchase Order Type "
		goto endverifyorder:
	endif
	let keyroh$=" ",keyroh$
	let keyroh$[1,2]="1"
	let keyroh$[3]=orderid using "######"
	for stat=1 to 59
		let keyroh$[1,2]=stat using "##"
		search #ch_roh,2,1;keyroh$,rec_roh,e
		if not (e)
			read record #ch_roh,rec_roh;roh.;
			read record #ch_ros,roh.shiprec;ros.;
			goto foundsalesorder:
		endif
	        if stat=7 let stat=57
	next stat
	for stat=90 to 99
		let keyroh$[1,2]=stat using "##"
		search #ch_roh,2,1;keyroh$,rec_roh,e
		if not (e)
			let returnstatus=0
			let message$="Order Id "+str$(orderid)+" is still in process. May not copy at this time."
			goto EndVerifyOrder:
		endif
	next stat
	let returnstatus=0
	let message$="Order Id "+str$(orderid)+" Not Found"
	goto Endverifyorder:
	foundsalesorder: ! order has been found what to do now
	call dxget ("ShipName",tmp$)
	poh.ShipToName$=tmp$+"                              "
	call dxget ("ShipAddr1",tmp$)                    
	poh.Address1$=tmp$+"                              "
	call dxget ("ShipAddr2",tmp$)                    
	poh.Address2$=tmp$+"                              "
	call dxget ("ShipCity",tmp$)                    
	poh.City$=tmp$+"                "
	call dxget ("ShipState",tmp$)                    
	poh.State$=tmp$+"  "
	call dxget ("ShipZip",tmp$)                    
	poh.ZipCode$=tmp$+"  "
	call dxget ("CopyAddr",tmp$)! 
	if potype$="D" and Tmp$="Y" 
		Poh.ShipToName$=ros.name$ 
		poh.Address1$=ros.Address$                              
		poh.Address2$=ros.Address2$                              
		poh.City$=ros.City$                                      
		poh.State$=ros.State$ 
		poh.zipcode$=" ",poh.zipcode$               
		poh.ZipCode$[1,5]=ros.zipcode$        
		poh.Zipcode$[6,9]=ros.zip4$  
	endif
	Endverifyorder: ! end verify sales order
	Clear List$[]                                                         
	List$[0] = bsdel$ + "ShipAddr" + fdel$ ! section name
	webstr$="ShipName",fdel$
	webstr$=webstr$,"ShipAddr1",fdel$
	webstr$=webstr$,"ShipAddr2",fdel$
	webstr$=webstr$,"ShipCity",fdel$
	webstr$=webstr$,"ShipState",fdel$
	webstr$=webstr$,"ShipZip",fdel$
	webstr$=webstr$,"Recopy",fdel$
	webstr$=webstr$,"RecopyMsg",fdel$
	webstr$=webstr$,"CopyOrd",fdel$
	webstr$=webstr$,"CustId",fdel$
	webstr$=webstr$,"InventUpdFlag",fdel$
	webstr$=webstr$,"InventUpdMsg",fdel$
	list$[1]=webstr$
	if returnstatus<>0 ! no errors send over the data
		webstr$=""
		webstr$=webstr$,poh.ShipToName$,fdel$
		webstr$=webstr$,poh.Address1$,fdel$                       
		webstr$=webstr$,poh.Address2$,fdel$                          
		webstr$=webstr$,poh.city$,fdel$
		webstr$=webstr$,poh.state$,fdel$
		webstr$=webstr$,poh.zipcode$,fdel$
		let tmp$="N"
		let work$=""
		if roh.PoCopyNum<>0 and roh.pocopynum<>poid and linesexist=0
			tmp$="Y"
			work$="Order "+str$(orderid)+ " Already Copied To PO "+str$(roh.pocopynum)
		endif
		
		webstr$=webstr$,tmp$,fdel$
		webstr$=webstr$,work$,fdel$
		let tmp$="Y"
		if linesexist<>0 let tmp$="N"
		webstr$=webstr$,tmp$,fdel$
		webstr$=webstr$,str$(roh.CustNum),fdel$	
		let sostockflag=1 ! sales order update stock
		if roh.OrdType=2 let sostockflag=0 ! direct
		if (roh.ordtype=3 and p60$[22,22]="N") let sostockflag=0  ! indirect 
		let postockflag=1
		if poh.type=1 let postockflag=0 ! direct
		if poh.type=4 let postockflag=0 ! import direct
		if p60$[22,22]="Y"
			if poh.type=2 let postockflag=0 ! indirect
			if poh.type=5 let postockflag=0 ! import indirect
		endif
		let tmp$="N"
		let work$=""
		let ch_pgp=0
		if sostockflag<>postockflag
			if poh.type=1 and roh.ordtype=1 ! po is a direct and sales order in a warehouse - check for mill items
				let millitem=0; nonmillitem=0
				CH_PGP=OpenFile(-9965,IntCo) \ if ch_pgp=-1 error 42 ! prodgrp
				let keyrol$=" ",keyrol$;keyrol$=orderid using "######"
				looprolverif: ! looking for mill items
				search #ch_rol,3,1;keyrol$,rec_rol,e
				if e<>0 goto endrolverif:
				let tmp3=keyrol$[1,6]
				if tmp3<>orderid goto endrolverif:
				read record #CH_ROl,rec_rol,0;rol.;
				if rol.NStkItem<>0
					let nonmillitem=nonmillitem+1
					goto looprolverif:
				else
					if rol.UpdtStk<>0
						let nonmillitem=nonmillitem+1
						goto looprolverif:	
					endif
				endif
				k2$=rol.ProdCode$+Blank$
				k2$[13]=rol.whse using "##"
				search #ch_prwh,2,1;k2$,rec_prwh,E
				if e goto looprolverif: ! no prodwhse rec
				mat read #ch_prwh,rec_prwh,846;WHMISC2;
				if whmisc2[0]>0 and whmisc2[0]<1000 ! if no prodgrp - it's not a millitem
					K3$=" ",k3$
					k3$=whmisc2[0] using "###" ! 3
					search #ch_pgp,2,1;k3$,rec_pgp,e
					if not(e)
						read #ch_pgp,rec_pgp,136;pgmlit;
						if pgmlit<>0 let millitem=millitem+1 else let nonmillitem=nonmillitem+1
					else
						let nonmillitem=nonmillitem+1
					endif
				else
					let nonmillitem=nonmillitem+1
				endif
				goto looprolverif: ! 
				endrolverif: !
				if millitem<>0 and nonmillitem=0 ! only have mill items
					goto endverstkflag:
				endif
			endif
			let tmp$="Y"
			if postockflag=1 ! po updating stock order is not
				 let work$="INVENTORY UPDATE WARNING: Purchase Order Type Updates Stock, Sales Order Type Does Not Update "
			else
				 let work$="INVENTORY UPDATE WARNING: Sales Order Updates Stock, Purchase Order Does Not "
				 if millitem<>0 let work$=work$+" Exception for Mill Item(s) "
			endif
		endif
		endverstkflag: ! 
		webstr$=webstr$,tmp$,fdel$
		webstr$=webstr$,work$,fdel$
		LIST$[2]=WEBSTR$
	endif
	
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section

	
	! status section *** last section ***
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	
	! done with it
        call SetOutPut(e$,rstr$)
	!!! send over fields

case "DIRECTSOVERIFY"
	LET returnstatus=1
	let message$="OK"
    call dxget ("orderid",tmp$)
	let ORDERID=tmp$
	LET returnstatus=1
	let message$=""
	let keyroh$=" ",keyroh$
	let keyroh$[1,2]="1"
	let keyroh$[3]=orderid using "######"
	for stat=1 to 59
		let keyroh$[1,2]=stat using "##"
		search #ch_roh,2,1;keyroh$,rec_roh,e
		if not (e)
			read record #ch_roh,rec_roh;roh.;
			if roh.ordtype<>2 ! not a direct
				let returnstatus=0
				let message$="Order Id "+str$(orderid)+" not a direct. May not copy at this time."
				goto EndDirVerify:
			endif
			call Dxget("VERIFYCREDIT",tmp$)
			if rtrim$(ucase$(tmp$))<>"Y" and roh.holdover=0
				read record #ch_rot,roh.totrec;rot.;
				if not(roh.holdover) and rot.holdcode<>0 ! does not have hold override and has a hold
					tmp3 = rot.holdcode                      
					holdcodeflag= Sgn(Fra(tmp3 / 2))
					if holdcodeflag<>0
						let returnstatus=6 ! prompt for copy
						message$="Sales Order "+str$(orderid)+ " is on Credit Hold "
						goto EndDirVerify:
					endif
				endif
			endif
			if roh.PoCopyNum<>0 
				call Dxget("VERIFYCOPY",tmp$)
				if rtrim$(ucase$(tmp$))<>"Y"
					let returnstatus=7 ! prompt for copy
					message$="Order "+str$(orderid)+ " Already Copied To PO "+str$(roh.pocopynum)+"."
					let keyrol$=" ",keyrol$
					let keyrol$[1,6]=orderid using "######"
					search #ch_rol,3,1;keyrol$,rec_rol,e
					if e=2
						returnstatus=9
						message$=message$+" Sales Order does not have any line items."
						goto enddirverify:
					endif
					let tmp3=keyrol$[1,6]
					if orderid<>tmp3
						let returnstatus=9
						message$=message$+" Sales Order does not have any line items. "
						goto enddirverify:
					endif! check for lines
					goto enddirverify:
				endif
			endif
			read record #ch_ros,roh.shiprec;ros.;
			goto foundordverif:
		endif
	        if stat=7 let stat=57
	next stat
	for stat=90 to 99
		let keyroh$[1,2]=stat using "##"
		search #ch_roh,2,1;keyroh$,rec_roh,e
		if not (e)
			let returnstatus=0
			let message$="Order Id "+str$(orderid)+" is still in process. May not copy at this time."
			goto EndDirVerify:
		endif
	next stat
	let returnstatus=0
	let message$="Order Id "+str$(orderid)+" Not Found"
	goto EndDirVerify:
	foundordverif: ! order has been found what to do now
    call dxget ("vendid",Vendid$)
	let vendid=vendid$
    if vendid<>0
		call verifyvendor()
		if not(returnstatus) goto enddircopy: ! bad vendor #
	endif
	let keyrol$=" ",keyrol$
	let keyrol$[1,6]=orderid using "######"
	search #ch_rol,3,1;keyrol$,rec_rol,e
	if e=2
		call Dxget("VERIFYCOPY",tmp$)
		if rtrim$(ucase$(tmp$))<>"Y"
			let returnstatus=9 ! prompt for copy - no lines no vendor
			message$="Order "+str$(orderid)+ " Does not have any sales order lines "
			goto enddirverify:
		else
			if not(vendid)
				let returnstatus=8! prompt for copy
				message$="Order "+str$(orderid)+ " Does not have a Vendor Assigned "
				goto enddirverify:
			endif
		endif
	endif
	if e<>0
		let returnstatus=0
		let message$="Order Id "+str$(orderid)+" May not copy at this time."
		goto enddirverify:
	endif
	let tmp3=keyrol$[1,6]
	if orderid<>tmp3
			call Dxget("VERIFYCOPY",tmp$)
			if rtrim$(ucase$(tmp$))<>"Y"
				let returnstatus=9 ! prompt for copy - no lines no vendor
				message$="Order "+str$(orderid)+ " Does not have any sales order lines "
				goto enddirverify:
			endif
	endif	
	read record #ch_rol,rec_rol;rol.;
	if vendid<>0 let rol.vendor=vendid
	if not(rol.vendor)
			let returnstatus=8! prompt for no vendor
			message$="Order "+str$(orderid)+ " Does not have a Vendor Assigned "
			goto enddirverify:
	else
		let vendid=rol.vendor
		call verifyvendor()
		if returnstatus=0
			let returnstatus=8! prompt for copy
			work$="Order "+str$(orderid)+ " Does not have a Vendor Assigned "
			goto enddirverify:	
		endif
	endif
	enddirverify: ! end verification of sales order 
	! status section *** last section ***
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	
	! done with it
        call SetOutPut(e$,rstr$)
	!!! send over fields	
! endif DIRECTSOVERIFY

case  "DIRECTSOCOPY"  ! copy direct sales order
	LET returnstatus=1
	let message$="OK"
    call dxget ("orderid",tmp$)
	let ORDERID=tmp$
	LET returnstatus=1
	let message$="OK"
	let keyroh$=" ",keyroh$
	let keyroh$[1,2]="1"
	let keyroh$[3]=orderid using "######"
	for stat=1 to 59
		let keyroh$[1,2]=stat using "##"
		search #ch_roh,2,1;keyroh$,rec_roh,e
		if not (e)
			read record #ch_roh,rec_roh;roh.;
			if roh.ordtype<>2 ! not a direct
				let returnstatus=0
				let message$="Order Id "+str$(orderid)+" not a direct. May not copy at this time."
				goto EndDirCopy:
			endif
			call Dxget("VERIFYCREDIT",tmp$)
			if rtrim$(ucase$(tmp$))<>"Y" and roh.holdover=0
				read record #ch_rot,roh.totrec;rot.;
				if not(roh.holdover) and rot.holdcode<>0 ! does not have hold override and has a hold
					tmp3 = rot.holdcode                      
					holdcodeflag= Sgn(Fra(tmp3 / 2))
					if holdcodeflag<>0
						returnstatus=0 ! let returnstatus=6 ! prompt for copy
						message$="Sales Order "+str$(orderid)+ " is on Credit Hold "
						goto enddircopy:
					endif
				endif
			endif
			if roh.PoCopyNum<>0 
				call Dxget("VERIFYCOPY",tmp$)
				if rtrim$(ucase$(tmp$))<>"Y"
					returnstatus=0 ! let returnstatus=7 ! prompt for copy
					message$="Order "+str$(orderid)+ " Already Copied To PO "+str$(roh.pocopynum)+"."
					let keyrol$=" ",keyrol$
					let keyrol$[1,6]=orderid using "######"
					search #ch_rol,3,1;keyrol$,rec_rol,e
					if e=2
						returnstatus=0 ! returnstatus=9
						message$=message$+" Sales Order does not have any line items."
						goto enddircopy:
					endif
					let tmp3=keyrol$[1,6]
					if orderid<>tmp3
						returnstatus=0 ! let returnstatus=9
						message$=message$+" Sales Order does not have any line items. "
						goto enddircopy
					endif! check for lines
					goto enddircopy:
				endif
			endif
			read record #ch_ros,roh.shiprec;ros.;
			goto foundslsord:
		endif
	        if stat=7 let stat=57
	next stat
	for stat=90 to 99
		let keyroh$[1,2]=stat using "##"
		search #ch_roh,2,1;keyroh$,rec_roh,e
		if not (e)
			let returnstatus=0
			let message$="Order Id "+str$(orderid)+" is still in process. May not copy at this time."
			goto EndDirCopy:
		endif
	next stat
	let returnstatus=0
	let message$="Order Id "+str$(orderid)+" Not Found"
	goto EndDirCopy:
	foundslsord: ! order has been found what to do now
    call dxget ("vendid",Vendid$)
	let vendid=vendid$
    if vendid<>0
		call verifyvendor()
		if not(returnstatus) goto enddircopy: ! bad vendor #
	endif
	let keyrol$=" ",keyrol$
	let keyrol$[1,6]=orderid using "######"
	search #ch_rol,3,1;keyrol$,rec_rol,e
	if e=2
		call Dxget("VERIFYCOPY",tmp$)
		if rtrim$(ucase$(tmp$))<>"Y"
			returnstatus=0 ! let returnstatus=9 ! prompt for copy - no lines no vendor
			message$="Order "+str$(orderid)+ " Does not have any sales order lines "
			goto enddircopy:
		else
			if not(vendid)
				returnstatus=0 ! let returnstatus=8! prompt for copy
				message$="Order "+str$(orderid)+ " Does not have a Vendor Assigned "
				goto enddircopy:
			endif
		endif
	endif
	if e<>0
		let returnstatus=0
		let message$="Order Id "+str$(orderid)+" May not copy at this time."
	endif
	let tmp3=keyrol$[1,6]
	if orderid<>tmp3
			call Dxget("VERIFYCOPY",tmp$)
			if rtrim$(ucase$(tmp$))<>"Y"
				returnstatus=0 ! let returnstatus=9 ! prompt for copy - no lines no vendor
				message$="Order "+str$(orderid)+ " Does not have any sales order lines "
				goto enddircopy:
			endif
	endif	
	read record #ch_rol,rec_rol;rol.;
	if vendid<>0 let rol.vendor=vendid
	if not(rol.vendor)
			returnstatus=0 ! let returnstatus=8! prompt for no vendor
			message$="Order "+str$(orderid)+ " Does not have a Vendor Assigned "
			goto enddircopy:
	else
		let vendid=rol.vendor
		call verifyvendor()
		if returnstatus=0
			!let returnstatus=8! prompt for copy
			work$="Order "+str$(orderid)+ " Does not have a Vendor Assigned "
			goto enddircopy:	
		endif
	endif
	!
	call dxget ("poid",poid$)
	let poid=poid$
	if poid<0 OR poid>999999
		let message$="Purchase Order Number "+str$(poid)+" Invalid"
		let returnstatus=0
		goto enddircopy:
	endif
	if rtrim$(poid$)="" let poid$="0"
	if poid=0 and poid$<>"0"
		let message$="Purchase Order Number "+rtrim$(poid$)+" Invalid"
		let returnstatus=0
		goto enddircopy:
	endif
	if poid<>0 ! verify if po already exists
			let keypoh$=" ",keypoh$
			let keypoh$[1,2]=" 1"
			LET keypoh$[3]=poid USING "######"
			for ctr=1 to 99
				let keypoh$[1,2]=ctr using "##"
				search #ch_poh,2,1;keypoh$,rec_poh,e
				if not(e)
					let returnstatus=4
					let message$="Purchase Order Number Already Exists"
					GOTO enddircopy:
				endif
				if ctr=18 let ctr=90
			next ctr
	Endif !
	let ponum=poid
	call initpoh()! init string variables
	! get poid
	If not(poid)
		DO ! get po number
			READ #ctlc,20,94;POnum; 
			LET PONUM=PONUM+1
			write #ctlc,20,94;PONUM;
				IF PONUM>999998
				LET RETURNSTATUS=0
				LET MESSAGE$="PO Number have exceeded 999999"
				goto enddircopy:
				exit do
			endif
			let flag=0
			LET keypoh$=" ",keypoh$ \ LET keypoh$[3,8]=PONUM USING "######"        
			FOR ctr=1 TO 99                                        
				LET keypoh$[1,2]=ctr USING "##"                           
				SEARCH #ch_poh,2,1;keypoh$,rec_tmp,E  
				if not(e)
					let flag=99
					GOTO GETNXTDIRPOID:
				endif
				if ctr=18 let ctr=90
			next ctr
			if not (flag) 
				let poid=PONUM
				exit do
			endif
			getnxtdirpoid: ! get next direct po id
		loop! try another po #
	endif
	poh.vendorcode=vendid
	poh.VendorRec=rec_vend                     
	poh.PurchaseOrder=poid                     
	poh.OrderDate=currdate                     
	poh.DueDate=currdate                       
	poh.ConfirmDate=currdate                                   
	poh.Routing$=vend.Routing$                 
	poh.Terms$=vend.TermsAlpha$
	If roh.shiptype>0 and roh.shiptype<17
		let dsp=((roh.shiptype*16)-16)
		read #ctlc,107,dsp;poh.fob$;
		if rtrim$(poh.fob$)=""
			let poh.FOB$=vend.Fob$ 
		endif
	else
		poh.FOB$=vend.Fob$ 
	endif
	poh.ConfirmName$=" ",poh.ConfirmName$      
	if p61$[62,62]="Y"                         
	    poh.ConfirmName$[1,3]="YES"        
	else                                       
	    poh.ConfirmName$[1,3]="NO "         
	endif   
	!!!set fields for direct sales order !!!!
	if rtrim$(roh.shipvia$)<>""
		poh.ShipVia$=roh.ShipVia$  
	else
		POH.SHIPVIA$="DIRECT"+blank$
	endif
    poh.ShipViaID=0 ! vend.ShipViaNum ! 0 = manual, >=file                                
	poh.Warehouse=roh.wh ! set to direct sales order warehouse                            
	poh.Type=1 ! set to direct              
	Poh.ShipToName$=ros.name$ 
	poh.Address1$=ros.Address$                              
	poh.Address2$=ros.Address2$                              
	poh.City$=ros.City$                                      
	poh.State$=ros.State$ 
	poh.zipcode$=" ",poh.zipcode$               
	poh.ZipCode$[1,5]=ros.zipcode$        
	let poh.Zipcode$[6,9]=ros.zip4$  
	poh.SalesOrder=orderid
	!!!! end field from direct sales order                                
	poh.VendorCode=vendid                                   
	poh.status=1                        
		IF P60$[46,46]="Y"
			IF CUSTOM_CUSTOMER$="ETNA"
				LET poh.type=5 ! import direct  
			ENDIF
		ENDIF
		poh.UpdateLeadTime=1                                    
		poh.OldStatus=0
		poh.Lockport=rec_uac ! 0 !!!! need the lock port                  
		if poh.type=1
			if vtag.VDiscType<>1 and vtag.VDiscType<>2 let vtag.VDiscType=0;vtag.VDiscAmt=0
			poh.PODiscType=vtag.VDiscType ! podisc[0]=vdisc[0]
			poh.PODiscAmt=vtag.VDiscAmt
		else
			poh.PODiscType=0 ! podisc[0]=vdisc[0]
			poh.PODiscAmt=0
		endif			
		
		MAT  READ #CTLC,60,6;EDIFLG$;!!! edi flag check
		IF EDIFLG$[2,2]="T" or EDIFLG$[2,2]="H"
			if source<=361 ! new purchase order #
				dim 1%,ch_edi,3%,rec_edi,etp[999],keyedi$[50]
				fname$="cntrl/EDICNTRL"+STR$(INTCO)
				Call FindF(Fname$,A9)
				IF A9<>0
					ch_edi=FINDCHANNEL()
					Try 
						ROPEN #ch_edi,FNAME$
						let keyedi$[1,2]="VN"
						let keyedi$[3,8]=vendid using "######"
						search #ch_edi,2,1;keyedi$,rec_edi,e
						if not(e)
							MAT  READ #ch_edi,rec_edi,8;eTP;              
							IF NOT (INT(ABS(ETP[850]))) AND NOT (INT(ABS(ETP[875])))
								let poh.EdiStatus$=" ",poh.edistatus$
							ELSE
								let poh.EdiStatus$=" ",poh.edistatus$
								let poh.EdiStatus$[1,1]="n"         
							endif
						endif
					else
						rem no file found
						let poh.EdiStatus$=" ",poh.edistatus$
					end try
				endif
			endif
		endif
		mode$ = "a" ! add  
		                                              
		UpdStatus = fileupdatepohead(e$,ch_poh,mode$,rec_tmp,poh.)	   
		rec_poh = UpdStatus                                                     
        if rec_poh<0
			let returnstatus=0
			let message$="Error Creating PO: "+str$(poid)+" For Sales Order "+str$(orderid)
			!! get record and write the file out                                      
			GOTO ENDDIRCOPY:	
		endif
		if rec_roh>0
			read record #ch_roh,rec_roh;roh.
			roh.PoCopyNum=poid
			Write record #ch_roh,rec_roh;roh.;
		endif
		!!! Sales Order Line Copy
		clear chan[]
		chan[0]= ctlc ! cntrl file
		chan[1]=ch_poh ! purchase order header  #60
		chan[2]=ch_pol ! po lines #61
		chan[3]=ch_roh ! order header #62
		chan[4]=ch_prod ! product file #64
		chan[5]=ch_prwh! product warehouse #65
		chan[6]=ch_nstk!  nonstock #66
		chan[7]=ch_ccode! unit of measure file #67
		chan[8]=ch_rol ! order lines #68
		chan[9]=ch_pom! po messages #69
		chan[10]=ch_rom ! order message #70
		chan[11]=ch_pogen ! po gen work #72
		chan[12]=ch_deal ! deals #19
		chan[13]=ch_cust ! customer file
		chan[14]=ch_rot ! order total file
		chan[15]=ch_alt ! alternate vendor
		chan[16]=0 ! nonstock will open in call
		chan[17]=0 ! shiplist will open in call
        chan[18] = 0 ! order ship to file will open in call
		parm[0]=rec_poh ! purchase order record #
		parm[1]=orderid ! sales order id #
		let parm[6]=0
		if p61$[124,124]="Y"
			parm[6]=99 ! copy shiplist messages into purchase order message lines
		endif
		parm[7]=99 ! flag to copy all lines and all message
		parm[8]=rec_uac
		parm[9]=intco ! control #
		msg$=""
		errtype=0
		call "posolinecopy.dl4",Chan[],parm[],msg$,errtype,userid$
		! now total
		call calcpototals()
		if rec_poh>0
			Write Record #ch_poh,Rec_poh;poh.;
			clear parm[]
			Parm[0]=rec_poh
			Parm[1]=361 ! source
			Parm[2]=1 ! 1=entry
			Parm[9]=intco ! company #                                                                        
			 clear chan[]
			chan[0]=ctlc 
			chan[1]=ch_poh
			chan[16]=ch_vend! vendor file
			CALL "POFRGTCHG",chan[],parm[]  
		endif
		
		ENDDIRCOPY:! 
		clear list$[]
		list$[0]=bsdel$,"DirectSOCopy",fdel$
		list$[1]="VendID",fdel$,"POID",fdel$
		list$[2]=str$(vendid),fdel$,str$(poid),fdel$
		list$[3]=esdel$
		call AddToStr(e$,rstr$,List$[]) ! mtg
		!clear list$[]
		!webstr$=""
		!list$[0]= bsdel$,"Warning",fdel$
		!webstr$ = "Message",fdel$                               
		!list$[1]=webstr$
		!let row=2
		!if errtype
		!	webstr$=msg$,fdel$
		!	let list$[2]=webstr$
		!	let row=row+1
		!endif
		!list$[row]=esdel$
		!call AddToStr(e$,rstr$,List$[]) ! mtg
	 ! end of section              
		if errtype<>0
			let returnstatus=0
			if errtype=2 let returnstatus=2
			let message$=msg$
		endif
	! status section *** last section ***
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	
	! done with it
        call SetOutPut(e$,rstr$)
	!!! send over fields	

case  "COPYSALESORDER" 
	call dxget ("SOURCE",tmp$)
	let source=tmp$
	if source=370
		let returnstatus=0
		let message$="Inquiry Only"
		goto EndCopyOrder:
	endif
	call dxget ("vendid",Vendid$)
	let vendid=vendid$
	call dxget ("poid",poid$)
	let poid=poid$
	call dxget ("orderid",tmp$)
	let ORDERID=tmp$
	call dxget ("custid",tmp$)
	let custid=tmP$
	LET returnstatus=1
	let message$="OK"
	call verifyvendor()
	if not (returnstatus) goto ENDCOPYORDER:
	
	keypoh$=" ",keypoh$
	keypoh$[1,6]=vendid using "######" 
	keypoh$[7,12]=poid using "######"
	mode$="=" ! search mode 2
	dir=2
	Rec_poh=filegetpohead(e$,ch_poh,mode$,dir,keypoh$,poh.)
	if rec_poh<0
		let returnstatus=0
		let message$="PO Number ",keypoh$[7,12]," Not On File"
		GOTO ENDCOPYORDER:
	endif
	if not (orderid)
		let returnstatus=0
		let message$="Invalid Order Id "+str$(orderid) 
		goto endcopyorder:
	endif
	let keyroh$=" ",keyroh$
	let keyroh$[1,6]=custid using "######"
	let keyroh$[7,12]=orderid using "######"
	search #ch_roh,2,2;keyroh$,rec_roh,e
	if not (e)
		read record #ch_roh,rec_roh;roh.;
		read record #ch_ros,roh.shiprec;ros.;
	else		
		let returnstatus=0
		let message$="Order Id "+str$(orderid)+" Not Found"
		goto Endcopyorder:
	endif
	!!! set up parameters for call !!!
	clear chan[]
	chan[0]= ctlc ! cntrl file
	chan[1]=ch_poh ! purchase order header  #60
	chan[2]=ch_pol ! po lines #61
	chan[3]=ch_roh ! order header #62
	chan[4]=ch_prod ! product file #64
	chan[5]=ch_prwh! product warehouse #65
	chan[6]=ch_nstk!  nonstock #66
	chan[7]=ch_ccode! unit of measure file #67
	chan[8]=ch_rol ! order lines #68
	chan[9]=ch_pom! po messages #69
	chan[10]=ch_rom ! order message #70
	chan[11]=ch_pogen ! po gen work #72
	chan[12]=ch_deal ! deals #19
	chan[13]=ch_cust ! customer file
	chan[14]=ch_rot ! order total file
	chan[15]=ch_alt ! alternate vendor
	chan[16]=0 ! nonstock will open in call
	chan[17]=0 ! shiplist will open in call
    chan[18]=0 ! order ship to file will open in call
	parm[0]=rec_poh ! purchase order record #
	parm[1]=orderid ! sales order id #
	parm[6]=0 ! copy shiplist messages into purchase order message lines - 0=no
	parm[7]=0 ! flag to copy all lines and all message - 0=no
	parm[8]=rec_uac
	parm[9]=intco ! control #
	msg$=""
	errtype=0
	call "posolinecopy.dl4",Chan[],parm[],msg$,errtype,userid$
	Endcopyorder: ! end verify sales order
	clear list$[]
	webstr$=""
	list$[0]= bsdel$,"Warning",fdel$
	webstr$ = "Message",fdel$                               
	list$[1]=webstr$
	if errtype
		webstr$=msg$,fdel$
		let list$[2]=webstr$
	endif
    call AddToStr(e$,rstr$,List$[]) ! mtg
	Call AddToStr(e$,rstr$,esdel$)	! end of section              
    if errtype<>0
		let returnstatus=0
		if errtype=2 let returnstatus=2
		let message$=msg$
	endif
	! mtg
	! status section *** last section ***
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	
	! done with it
        call SetOutPut(e$,rstr$)
	!!! send over fields	
! ---start verify purch order ---
case  "VERIFYPURCHORD" 
	dim opoh. as pohead
	dim 3%,rec_opoh
	call dxget ("vendid",Vendid$)
	let vendid=vendid$
	call dxget ("poid",poid$)
	let poid=poid$ ! DEBIT MEMO # 
	call dxget ("orderID",tmp$)
	let ORDERID=tmp$ ! PURCHASE ORDER #
	LET returnstatus=1
	let message$="OK"
	call verifyvendor()
	if not(returnstatus) goto endverifyponum: ! bad vendor #
	call dxget("SOURCE",tmp$)
	let source=tmp$
	if source<>381
		let returnstatus=0
		let message$="Invalid. Only For Debit Memos."
		goto EndVerifyPONUM:
	endif
	if orderid<=0 or orderid>999999
		let returnstatus=0
		let message$="Invalid Purchase Order Number "+str$(orderid)
		goto EndVerifyPONUM:
	endif
	let linesexist=0
	keypoh$=" ",keypoh$
	keypoh$[1,6]=vendid using "######" 
	keypoh$[7,12]=poid using "######" ! Debit Memo
	mode$="=" ! search mode 2
	dir=2
	Rec_poh=filegetpohead(e$,ch_poh,mode$,dir,keypoh$,poh.)
	if rec_poh<0
		let returnstatus=0
		let message$="Debit Memo ",keypoh$[7,12]," Not On File"
		GOTO ENDVERIFYPONUM:
	endif
	call dxget("potype",tmp$) 
	let potype$=tmp$
	let poh.type=-1
	if rtrim$(tmp$)="W" let poh.type=0
	if rtrim$(tmp$)="D" let poh.type=1
	if rtrim$(tmp$)="I" let poh.type=2
	if p60$[46,46]="Y"
		if rtrim$(tmp$)="IW" let poh.type=4
		if rtrim$(tmp$)="ID" let poh.type=5
		if rtrim$(tmp$)="II" let poh.type=6
	endif
	if poh.type<0
		let returnstatus=0
		let message$="Invalid Purchase Order Type "
		goto endverifyponum:
	endif
	keypoh$=" ",keypoh$
	keypoh$[1,6]=vendid using "######" 
	keypoh$[7,12]=orderid using "######" ! Purchase Order
	mode$="=" ! search mode 2
	dir=2
	Rec_opoh=filegetpohead(e$,ch_poh,mode$,dir,keypoh$,opoh.)
	if rec_opoh<0
		let returnstatus=0
		let message$="Purchase Order ",keypoh$[7,12]," Not On File"
		GOTO ENDVERIFYPONUM:
	endif
	if opoh.status <=3
		let returnstatus=0
		let message$="Purchase Order "+str$(OrderId)+" Has Not Been Received" 
		goto endverifyponum:
	endif
	Endverifyponum: ! end verify purchase order
	Clear List$[]                                                         
	List$[0] = bsdel$ + "CopyPo" + fdel$ ! section name
	webstr$=webstr$,"Recopy",fdel$
	webstr$=webstr$,"RecopyMsg",fdel$
	webstr$=webstr$,"CopyOrd",fdel$
	webstr$=webstr$,"InventUpdFlag",fdel$
	webstr$=webstr$,"InventUpdMsg",fdel$
	list$[1]=webstr$
	if returnstatus<>0 ! no errors send over the data
		webstr$=""
		let tmp$="N"
		let work$=""
		if opoh.DebitMemo<>0 and opoh.DebitMemo<>poid and linesexist=0
			tmp$="Y"
			work$="Order "+str$(orderid)+ " Already Copied To Debit Memo "+str$(opoh.DebitMemo)
		endif
		webstr$=webstr$,tmp$,fdel$
		webstr$=webstr$,work$,fdel$
		let tmp$="Y"
		if linesexist<>0 let tmp$="N"
		webstr$=webstr$,tmp$,fdel$
		!
		let tmp$="N"
		let work$=""
		if opoh.type=0 and poh.type<>0 let tmp$="Y" ! whse po <> whse dm
		if opoh.type=4 and poh.type<>0 let tmp$="Y" ! import whse po <> whse dm
		if opoh.type=1 and poh.type<>1 let tmp$="Y" ! direct po<> direct dm
		if opoh.type=5 and poh.type<>1 let tmp$="Y" ! import direct<> direct dm
		if opoh.type=2 and poh.type<>2 let tmp$="Y" ! indirect po <> indirect dm
		if opoh.type=6 and poh.type<>2 let tmp$="Y" ! import indirect <> indirect dm
		if tmp$="Y"
			let work$="INVENTORY UPDATE WARNING: The Purchase Order type and the Debit Memo type conflict"		
		endif
		webstr$=webstr$,tmp$,fdel$
		webstr$=webstr$,work$,fdel$
		LIST$[2]=WEBSTR$
	endif
	
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section

	
	! status section *** last section ***
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	
	! done with it
        call SetOutPut(e$,rstr$)
	!!! send over fields



! --- end verify purch order ---
! ---- Start copy purhcase order into debit memo
case  "COPYPURCHORD"
	dim opoh. as pohead
	dim 3%,rec_opoh
	call dxget ("SOURCE",tmp$)
	let source=tmp$
	if source<>381
		let returnstatus=0
		let message$="Invalid. Only Available for Debit Memo."
		goto EndCopyPONUM:
	endif
	call dxget ("vendid",Vendid$)
	let vendid=vendid$
	call dxget ("poid",poid$) ! debit memo #
	let poid=poid$
	call dxget ("orderid",tmp$) ! purchase order # to copy
	let ORDERID=tmp$
	
	LET returnstatus=1
	let message$="OK"
	call verifyvendor()
	if not (returnstatus) goto ENDCOPYPONUM:
	keypoh$=" ",keypoh$
	keypoh$[1,6]=vendid using "######" 
	keypoh$[7,12]=poid using "######"
	mode$="=" ! search mode 2
	dir=2
	Rec_poh=filegetpohead(e$,ch_poh,mode$,dir,keypoh$,poh.)
	if rec_poh<0
		let returnstatus=0
		let message$="DM Number ",keypoh$[7,12]," Not On File"
		GOTO ENDCOPYPONUM:
	endif
	if orderid<=0 or orderid>999999
		let returnstatus=0
		let message$="Invalid Purchase Order Id "+str$(orderid) 
		goto endcopyPONUM:
	endif
	keypoh$=" ",keypoh$
	keypoh$[1,6]=vendid using "######" 
	keypoh$[7,12]=orderid using "######"
	mode$="=" ! search mode 2
	dir=2
	Rec_opoh=filegetpohead(e$,ch_poh,mode$,dir,keypoh$,opoh.)
	if rec_opoh<0
		let returnstatus=0
		let message$="PO Number ",keypoh$[7,12]," Not On File"
		GOTO ENDCOPYPONUM:
	endif	
	
	!!! set up parameters for call !!!
	clear chan[]
	 CHAN[0]=CTLC
	 CHAN[1]=CH_POH
	 CHAN[2]=CH_POL
	 CHAN[3]=CH_VEND
	 CHAN[4]=CH_PROD
	 CHAN[5]=CH_PRWH
	 CHAN[6]=CH_NSTK
	 CHAN[7]=CH_CCODE
	 CHAN[8]=CH_WH
	 parm[0]=orderid ! purchase order # to copy debit memo into 
	 parm[1]=rec_poh ! debit memo header rec#
	 parm[2]=vendid !  vendor code
	 parm[8]=poid ! debit memo id
	 parm[9]=intco ! control #
	 msg$=""
	 errtype=0
	 call "po381lc.dl4",Chan[],parm[],rstr$,msg$,errtype
	Endcopyponum: ! end verify purchase order
	clear list$[]
	webstr$=""
	list$[0]= bsdel$,"Warning",fdel$
	webstr$ = "Message",fdel$                               
	list$[1]=webstr$
	if errtype
		webstr$=msg$,fdel$
		let list$[2]=webstr$
	endif
        call AddToStr(e$,rstr$,List$[]) ! mtg
	Call AddToStr(e$,rstr$,esdel$)	! end of section              
       
	! mtg
	! status section *** last section ***
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	
	! done with it
        call SetOutPut(e$,rstr$)
	!!! send over fields	
! -- end copy purchase order into debit memo

!!! START DELETE PURCHASE ORDER
case  "DELPURCHORD"
	call dxget ("SOURCE",tmp$)
	let source=tmp$
	if source=370
		let message$="Inquiry Only"
		let returnstatus=0
		goto enddelpo:
	endif
	call dxget ("vendid",Vendid$)
	let vendid=vendid$
	call dxget ("poid",poid$)
	let poid=poid$
	LET returnstatus=1
	let message$="OK"
	call verifyvendor()
	if not (returnstatus) goto ENDDELPO:
	keypoh$=" ",keypoh$
	keypoh$[1,6]=vendid using "######" 
	keypoh$[7,12]=poid using "######"
	mode$="=" ! search mode 2
	dir=2
	Rec_poh=filegetpohead(e$,ch_poh,mode$,dir,keypoh$,poh.)
	if rec_poh<0
		let returnstatus=99
		let message$="PO Number ",keypoh$[7,12]," Not On File"
		GOTO ENDDELPO:
	endif
	if returnstatus<>0
		call verifystat()
		if returnstatus=99 goto enddelpo:
	endif
	! Verify if ok to delete
	If source<>381 ! not a debit memo
		IF poh.TotPoRcvd<>0 ! H8[3]<>0
			let returnstatus=0
			let message$="PO Number ",keypoh$[7,12]," has receipts. May Not Delete."
			GOTO ENDDELPO:
		endif
	
		IF poh.OldStatus>4 ! ph[4]>4
			let returnstatus=0
			let message$="PO Number ",keypoh$[7,12]," has receipts in process. May Not Delete."
			GOTO ENDDELPO:
		endif
	else
		if poh.OldStatus=14
			let returnstatus=0
			let message$="DM Number ",keypoh$[7,12]," already accepted. May Not Delete."
			GOTO ENDDELPO:
		endif
		if poh.OldStatus=13
			let returnstatus=0
			let message$="DM Number ",keypoh$[7,12]," already on a journal. May Not Delete."
			GOTO ENDDELPO:
		endif
	endif
	! check for ap
	IF P9$[23,23]="Y" or P9$[23,23]="A"  ! check ap 
		MAT  READ #ctlc,51,26;APFLAG;
		IF APFLAG<>0
			Ch_appoh = openfile(9802,intCo) 
			If Ch_appoh <> -1   ! file found            
                		LET Keyappoh$=" ",Keyappoh$ 
				LET Keyappoh$[1,6]=poh.VendorCode USING "######" 
				do 
					SEARCH #ch_appoh,3,1;Keyappoh$,R56,E               
					IF E<>0 exit do                                               
					MAT  READ #ch_appoh,R56,0;APPOH; 
					IF APPOH[0]<>poh.vendorcode exit do           
					IF APPOH[1]=poh.PurchaseOrder                                      
						let returnstatus=0
						let message$="PO Number "
						if source=381 let message$="DM Number "
						let message$=message$+keypoh$[7,12]+" is in use by Accounts Payble. May Not Delete"
						exit do
					endif
				loop
				close #ch_appoh
			endif
		endif
	endif
	if not (returnstatus) goto ENDDELPO:
	!!! set up parameters for call !!!
	clear chan[]
	chan[0]= ctlc ! cntrl file
	chan[1]=ch_poh ! purchase order header  
	chan[2]=ch_pol ! po lines 
	chan[3]=ch_roh ! order header 
	chan[4]=ch_prod ! product file #64
	chan[5]=ch_prwh! product warehouse #65
	chan[6]=ch_nstk!  nonstock #66
	chan[7]=ch_ccode! unit of measure file #67
	chan[8]=ch_rol ! order lines #68
	chan[9]=ch_pom! po messages #69
	chan[10]=ch_rom ! order message #70
	chan[11]=ch_pogen ! po gen work #72
	chan[12]=ch_deal ! deals #19
	chan[13]=ch_cust ! customer file
	chan[14]=ch_rot ! order total file
	chan[15]=ch_alt ! alternate vendor
	chan[16]=ch_vend ! vendor file
	! parm variables should use s9
	parm[0]=rec_poh ! purchase order record #
	parm[1]=rec_vend ! vendor record #
	parm[10]=intco ! control #
	msg$=""
	errtype=0
	call "podelete.dl4",Chan[],parm[],msg$,errtype,rstr$
	EndDELPO: ! end DELETE PO
	if returnstatus=1 
		if source<>381
			let message$="Purchase Order "+str$(poid)+" Deleted"
		else
			let message$="Debit Memo "+str$(poid)+" Deleted"
		endif
	endif
	if errtype<>0
		let returnstatus=0
		let message$=msg$
	endif
       
	! mtg
	! status section *** last section ***
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	
	! done with it
        call SetOutPut(e$,rstr$)
	!!! send over fields	

!!! END DELETE PURCHASE ORDER

! COPYCREDITMEMO --			
case  "COPYCREDMEMO"
	dim 1%,askrecopy,ch_invh
	dim 3%,cmid,rec_invh,recopychk
	include "src/inc/fileinvh.inc"
	dim invh. as invh
	returnstatus=1
	message$="OK"
	askrecopy=0
	poid=0
	call dxget ("SOURCE",tmp$)
	let source=tmp$
	if source=370
		let returnstatus=0
		let message$="Inquiry Only"
		goto EndCopyCm:
	endif
	If source<>381
		let returnstatus=0
		let message$="Invalid. Only for Debit Memos"
		goto EndCopyCm:
	endif
	call dxget ("VENDID",Vendid$)
	let vendid=vendid$
	call dxget ("CMID",tmp$)
	let cmid=tmp$
	LET returnstatus=1
	let message$="OK"
	call verifyvendor()
	if not (returnstatus) goto ENDCOPYCM:
	
	if cmid<=0 or cmid>999999
		let returnstatus=0
		let message$="Invalid Credit Memo Id "+str$(cmid) 
		goto endcopycm:
	endif
	! open invoice history file
	ch_invh=OpenFile(1136,intCo) \ If ch_invh = -1 Error 42 
	! look for status #31
	let keyroh$=" ",keyroh$
	let keyroh$[1,2]="31"
	let KEYroh$[3,12] = cmid Using "##########"
	search #ch_invh,2,1;keyroh$,rec_invh,e
	if not (e)
		read record #ch_invh,rec_invh;invh.;
	else		
		let returnstatus=0
		let message$="Credit Memo Id "+str$(cmid)+" Not Found"
		goto Endcopycm:
	endif
	recopychk=0
	askrecopy=0
	IF INVH.PoCopyNum<>0
		call dxget ("RECOPYCHK",tmp$)
		let recopychk=tmp$
		if recopychk<>0
			let askrecopy=1
			let message$="Credit Memo has already been copied to Debit Memo "+str$(InvH.PoCopyNum)
			goto EndCopyCm:
		endif
	endif
	!!! set up parameters for call !!!
	clear chan[]
	CHAN[0]=CTLC
	CHAN[1]=CH_POH
	CHAN[2]=CH_POL
	CHAN[3]=CH_VEND
	CHAN[4]=CH_PROD
	CHAN[5]=CH_PRWH
	CHAN[6]=CH_NSTK
	CHAN[7]=CH_CCODE
	CHAN[8]=CH_WH
	CHAN[9]=CH_INVH
	parm[0]=vendid ! vendor #
	parm[1]=cmid ! sales order id #
	parm[8]=poid ! debit memo id
	parm[9]=intco ! control #
	msg$=""
	errtype=0
	call "po381cm.dl4",Chan[],parm[],rstr$,msg$,errtype
	if errtype<>0
		let returnstatus=0
		let message$=msg$
	else
		let poid=parm[8]
	endif
	Endcopycm: ! end verify sales order
	clear list$[]
	webstr$=""
	list$[0]= bsdel$,"Warning",fdel$
	webstr$ = "AskRecopy",fdel$,"Message",fdel$,"Poid",fdel$                              
	list$[1]=webstr$
	webstr$=str$(askrecopy)+fdel$
	webstr$=webstr$+rtrim$(message$)+fdel$
	webstr$=webstr$+str$(poid)+fdel$
	list$[2]=webstr$
	call AddToStr(e$,rstr$,List$[]) ! mtg
	Call AddToStr(e$,rstr$,esdel$)	! end of section              
       
	! mtg
	! status section *** last section ***
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	
	! done with it
        call SetOutPut(e$,rstr$)
	!!! send over fields		
	
	
! End Copy Credit Memo into a Debit Memo



! --- end new copy
 
 case "GETVEND" ! create vendor selected
	  let returnstatus=1
	  let message$="OK"
	  call dxget ("vendid",vendid$)
	  let vendid=vendid$
	  call verifyvendor()	
	  call dxget ("SOURCE",tmp$)
	  let source=tmp$
	  if returnstatus>0
		if not(vtag.AllowPoS) 
			If source<>370 and source<>371 and source<>381
				let returnstatus=0
				let message$=" Purchase Orders are not allowed for this Vendor. "
			endif
		endif
	  endif
	  clear list$[]
	  list$[0]= bsdel$,"BuyVend",fdel$
	  webstr$ = "ID",fdel$                               
	  webstr$ = webstr$,"Name",fdel$                     
	  webstr$ = webstr$,"Contact",fdel$                  
          webstr$ = webstr$,"Address",fdel$                  
          webstr$ = webstr$,"Address 2",fdel$                
          webstr$ = webstr$,"City",fdel$                     
	  webstr$ = webstr$,"State",fdel$                    
          webstr$ = webstr$,"Zip",fdel$                      
                      
          List$[1] = webstr$  
	  if vend.vendorcode<>0
		webstr$ = (vend.vendorcode Using "######"),fdel$   
		webstr$ = webstr$,vend.name$,fdel$                 
		webstr$ = webstr$,vend.contact$,fdel$              
		webstr$ = webstr$,vend.address$,fdel$              
		webstr$ = webstr$,vend.optaddress$,fdel$           
		webstr$ = webstr$,vend.city$,fdel$                 
		webstr$ = webstr$,vend.state$,fdel$                
		webstr$ = webstr$,vend.zip$,fdel$                  
		     
		list$[2]=webstr$
	  endif
	  call AddToStr(e$,rstr$,List$[]) ! mtg
	Call AddToStr(e$,rstr$,esdel$)	! end of section
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
 	  call SetOutput(e$,rstr$)

Case "STARTPOMISC"
	! droplist for general ledger, warehouse, pomisc charges 
	returnstatus=1
	message$="OK"
	call startpomisc()

Case "GETPOMISC"
	! gets an unique pomisc code
	returnstatus=1
	message$="OK"
	call getpomisc()



Case "SUBMITPOMISC"
	returnstatus=1
	message$="OK"
	call submitpomisc()

Case "RESETPOSTAT" 
	returnstatus=1
	let message$="OK"
	DIM 1%,resetprtstat
	call dxget ("SOURCE",tmp$)
	let source=tmp$
	if source=370
		let returnstatus=0
		let message$="Inquiry Only"
		goto endrespostat:
	endif
	
	let returnstatus=1
	let message$="OK"
	call dxget ("Vendid",Vendid$)
	call dxget ("poid",poid$)
	let vendid=vendid$
	let poid=poid$
	LET returnstatus=1
	let message$="OK"
	keypoh$=" ",keypoh$
	keypoh$[1,6]=vendid using "######" 
	keypoh$[7,12]=poid using "######"
	mode$="=" ! search mode 2
	dir=2
	Rec_poh=filegetpohead(e$,ch_poh,mode$,dir,keypoh$,poh.)
	if rec_poh<0
		let returnstatus=99
		let message$="PO Number ",keypoh$[7,12]," Not On File"
		goto endrespostat:
	endif
	if returnstatus<>0
		call verifystat()
		if returnstatus=99 goto endrespostat:
	endif
	if returnstatus=0 goto endrespostat:
	
	read record #ch_poh,rec_poh;poh.;
	if source<>371 and source<>381
		let poh.status=poh.oldstatus
		if poh.status<=0 let poh.status=1
		if poh.status>89 let poh.status=1
	else
		if source=371
			let poh.status=5

		else
			if source=381 ! debit memo
				let poh.status=poh.oldstatus
				if poh.status>14 let poh.status=11
				if poh.status<11 let poh.status=11
			endif
		endif
	endif          
	write record #ch_poh,rec_poh;poh.; ! po complete
	let keypoh$=" ",keypoh$
	let keypoh$[1,2]=poh.status using "##"
	let keypoh$[3,8]=poid using "######"
	search #ch_poh,4,1;keypoh$,rec_poh,e
	let keypoh$[1,2]="95"
	if source=371 let keypoh$[1,2]="96"
	if source=381 let keypoh$[1,2]="97"
	search #ch_poh,5,1;keypoh$,rec_tmp,e
	endrespostat: ! 
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
    call SetOutPut(e$,rstr$)

!!! NEW CALL
case  "CLOSEPURCHORD"
	call dxget ("SOURCE",tmp$)
	let source=tmp$
	if source=370
		let message$="Inquiry Only"
		let returnstatus=0
		goto endclosepo:
	endif
	call dxget ("vendid",Vendid$)
	let vendid=vendid$
	call dxget ("poid",poid$)
	let poid=poid$
	LET returnstatus=1
	let message$="OK"
	call verifyvendor()
	if not (returnstatus) goto ENDCLOSEPO:
	keypoh$=" ",keypoh$
	keypoh$[1,6]=vendid using "######" 
	keypoh$[7,12]=poid using "######"
	mode$="=" ! search mode 2
	dir=2
	Rec_poh=filegetpohead(e$,ch_poh,mode$,dir,keypoh$,poh.)
	if rec_poh<0
		let returnstatus=0
		let message$="PO Number ",keypoh$[7,12]," Not On File"
		GOTO ENDCLOSEPO:
	endif
	! Verify if ok to close
	If source>=370! not a debit memo
		let returnstatus=0
		let message$="Invalid Action For this source. May Not Closed."
		GOTO ENDclosePO:
	endif
	if poh.status<>95
		let returnstatus=99
		let message$="Purchase Order ",keypoh$[7,12]," is no longer in an edit status. May Not Close. "
		GOTO ENDclosePO
	endif
	IF poh.OldStatus>4 ! ph[4]>4
		let returnstatus=0
		let message$="PO Number ",keypoh$[7,12]," has receipts in process. May Not Delete."
		GOTO ENDclosePO:
	endif
	if not (returnstatus) goto ENDCLOSEPO:
	let keypol$=" ",keypol$
	let keypol$[1,6]=poid using "######"
	do
		search #ch_pol,3,1;keypol$,rec_pol,e
		if e<>0 exit do
		let tmp3=keypol$[1,6]
		if tmp3<>poid exit do
		Read Record #ch_pol,rec_pol,0;Pol.;
		if pol.Status=3 goto getnxtpoclose: ! already closed
		X2 = Pol.flags ! ! REM UNPACK pol.Flags TO FLAGS[x]  
		For K = 0 To 11                                      
			flags[K] = Sgn(Fra(X2 / 2)) \ X2 = Int(X2 / 2)     
		Next K                                               
		NonStk = flags[0]                                    
		ClosedShort = flags[1]                               
		ZLine = flags[2]      
		if pol.UpdStock<>0 and NonStk=0 and Zline=0 !           
			rec_prod = Pol.proddescrec                                  
			Read Record #ch_prod,rec_prod,0;prod. 
			! reduce qty on po in whsefile
			Pwkey$ = " ",Pwkey$                                    
			Pwkey$ = Pol.ProdCode$ + Pol.WHSE Using "##"           
			PWR = filegetprodwhse(e$,ch_prwh,"=",1,Pwkey$,pw.)         
			If PWR >0                                                        
				X3 = Pol.QtyOrd + Pol.FreeGoods-pol.QtyRcvdToDate  
				 pw.QtyOnPO = pw.QtyOnPO - X3  
				 Write Record #ch_prwh,pwr,0;pw.;
			endif
			X3 = Pol.QtyOrd + Pol.FreeGoods-pol.QtyRcvdToDate 
			prod.QtyOnPO = prod.QtyOnPO - X3 
			Write Record #ch_prod,rec_prod,0;prod.;
			if cpiFlag call UpdateCPI() ! cpi - see if on contract
			!
			if sqlChan >= 0 ! MySQL enabled and channel opened
				call prod_DL4SQLConvert(e$,"FROMDL4",prod.,sql_prod.,rec_prod)
				e = prod_SQLAddUpdate(e$,sqlChan,sql_prod.) ! mode="a" or "c"
				!e = prod_SQLDelete(e$,sqlChan,sql_prod.) ! mode="d"
				if e <> 1 ! returns the number of records add/updated/deleted
					error 11000 ! do bad update stuff
				end if
			end if
			!			
		endif	
		let pol.status=3
		let closedshort=1
		flags[0] = NonStk                  
		flags[1] = ClosedShort             
		flags[2] = ZLine                   
		X2 = 0                             
		For K = 0 To 11                    
			If flags[K] Let X2 = X2 + 2 ^ K  
		Next K                             
		pol.flags = X2                    
		Write Record #ch_pol,rec_pol,0;Pol.;
		getnxtpoclose: ! 
	loop
	let keypoh$=" ",keypoh$
	let keypoh$[1,2]=" 7"
	let keypoh$[3,8]=poid using "######"
	search #ch_poh,4,1;keypoh$,rec_poh,e
	
	let keypoh$=" ",keypoh$
	let keypoh$[1,2]=poh.status using "##"
	let keypoh$[3,8]=poid using "######"
	let rec_tmp=rec_poh
	search #ch_poh,5,1;keypoh$,rec_tmp,e
	let poh.status=7
	write record #ch_poh,rec_poh;poh.; ! po complete
		
	EndcLOSEPO: ! end close PO
	if returnstatus=1 
		let returnstatus=99
		let message$="Purchase Order "+str$(poid)+" Closed"
	endif
	
	! status section *** last section ***
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	
	! done with it
        call SetOutPut(e$,rstr$)
	!!! send over fields	
! start pocopypo
case  "POCOPYPO"
	dim opoh. as pohead
	dim 3%,rec_opoh
	call dxget ("vendid",Vendid$)
	let vendid=vendid$
	call dxget ("poid",poid$) ! po#
	let orgpoid=poid$
	if orgpoid<=0 or orgpoid>999999
		let returnstatus=0
		let message$="Invalid Purchase Order Id "+str$(orgpoid) 
		goto endpocopypo:
	endif
	LET returnstatus=1
	let message$="OK"
	if vendid<>0
		call verifyvendor()
		if not (returnstatus) goto ENDCOPYPONUM:
	endif
	keypoh$=" ",keypoh$
	keypoh$[1,2]=" 6" ! status is closedvendid using "######" 
	keypoh$[3,8]=orgpoid using "######"
	mode$="=" ! search mode 2
	dir=1
	Rec_opoh=filegetpohead(e$,ch_poh,mode$,dir,keypoh$,opoh.)
	if rec_opoh<0
		let returnstatus=0
		let message$="PO Number ",keypoh$[7,12]," Is not Closed"
		GOTO ENDPOCOPYPO:
	endif
	! create new po header
	! get purchase order id
	DO ! get po number
		READ #ctlc,20,94;POnum; 
		LET PONUM=PONUM+1
		write #ctlc,20,94;PONUM;
		IF PONUM>999998
			LET RETURNSTATUS=0
			LET MESSAGE$="PO Number have exceeded 999999"
			GOTO ENDGETPOHDR:
			exit do
		endif
		let flag=0
		LET keypoh$=" ",keypoh$ \ LET keypoh$[3,8]=PONUM USING "######"        
		FOR ctr=1 TO 99                                        
			LET keypoh$[1,2]=ctr USING "##"                           
			SEARCH #ch_poh,2,1;keypoh$,rec_tmp,E  
			if not(e) let flag=99
			if ctr=18 let ctr=90
		next ctr
		if not (flag) 			
			let poid=PONUM
			exit do
		endif
	loop! try another po #
	clear poh.
	call initpoh()
	poh.Status=95 
	poh.Type=opoh.type
	poh.Warehouse=opoh.warehouse
	poh.PurchaseOrder=poid                     
	poh.OrderDate=currdate                     
	poh.DueDate=currdate                       
	poh.ConfirmDate=currdate                       
	poh.ConfirmName$=" ",poh.ConfirmName$     !!! question regarding this what to do with confirm 
	if p61$[62,62]="Y"                         
		poh.ConfirmName$[1,3]="YES"
		IF NOT(VENDID) OR vendid=opoh.vendorcode
			poh.ConfirmName$= opoh.ConfirmName$[1,3]
		endif
	else                                       
		poh.ConfirmName$[1,3]="NO "         
	endif   
	poh.UpdateLeadTime=1                                    
	poh.OldStatus=0  
	poh.Lockport=rec_uac                      
! address
	poh.ShipToName$=opoh.ShiptoName$                             
	poh.Address1$=opoh.Address1$                           
	poh.Address2$=opoh.Address2$                              
	poh.City$=opoh.City$                                     
	poh.State$=opoh.State$  
	poh.ZipCode$=opoh.ZipCode$
	poh.vendorcode=opoh.vendorcode
	poh.VendorRec=opoh.VendorRec
	poh.ShipVia$=opoh.ShipVia$                 
	poh.Routing$=opoh.Routing$                 
	poh.Terms$=opoh.Terms$               
	poh.FOB$=opoh.Fob$     
	poh.ShipViaID=opoh.ShipViaID  
	poh.PODiscType=opoh.PODiscType 
	poh.PODiscAmt=opoh.PODiscAmt
	let poh.EdiStatus$=" ",poh.edistatus$
	if opoh.type<>poh.type
		if poh.type=1 and linesexist=0 ! direct
			if vtag.VDiscType<>1 and vtag.VDiscType<>2 let vtag.VDiscType=0;vtag.VDiscAmt=0
			poh.PODiscType=vtag.VDiscType ! podisc[0]=vdisc[0]
			poh.PODiscAmt=vtag.VDiscAmt
		else
			!!poh.PODiscType=0 ! podisc[0]=vdisc[0]
			poh.PODiscAmt=0
		endif
	endif
	if vendid<>0 and opoh.vendorcode<>vendid
		poh.vendorcode=vendid
		poh.VendorRec=rec_vend 
		if vtag.VDiscType<>1 and vtag.VDiscType<>2
			let vtag.VDiscType=0;vtag.VDiscAmt=0
		ENDIF
		if poh.type=1 
			poh.PODiscType=vtag.VDiscType ! podisc[0]=vdisc[0]
			poh.PODiscAmt=vtag.VDiscAmt
		endif
		if poh.type=1 or poh.type=4 ! direct
		! directs leave as is
		else
			poh.ShipVia$=vend.ShipVia$                 
			poh.Routing$=vend.Routing$                 
			poh.Terms$=vend.TermsAlpha$                
			poh.FOB$=vend.Fob$ 
			poh.ShipViaID=vend.ShipViaNum ! 0 = manual, >=file 
		endif
	else
		vendid=opoh.vendorcode
		poh.vendorcode=vendid	
	endif
	MAT  READ #CTLC,60,6;EDIFLG$;!!! edi flag check
	IF EDIFLG$[2,2]="T" or EDIFLG$[2,2]="H"
		dim 1%,ch_edi,3%,rec_edi,etp[999],keyedi$[50]
		fname$="cntrl/EDICNTRL"+STR$(INTCO)
		Call FindF(Fname$,A9)
		ch_edi=0
		IF A9<>0
			ch_edi=FINDCHANNEL()
			ROPEN #ch_edi,FNAME$
			let keyedi$[1,2]="VN"
			let keyedi$[3,8]=vendid using "######"
			search #ch_edi,2,1;keyedi$,rec_edi,e
			if not(e)
				MAT  READ #ch_edi,rec_edi,8;eTP;              
				IF NOT (INT(ABS(ETP[850]))) AND NOT (INT(ABS(ETP[875])))
					let poh.EdiStatus$=" ",poh.edistatus$
				ELSE
					let poh.EdiStatus$=" ",poh.edistatus$
					let poh.EdiStatus$[1,1]="n"
				ENDIF
			endif
		endif
	endif
	mode$ = "a" ! add                                               
	UpdStatus = fileupdatepohead(e$,ch_poh,mode$,rec_tmp,poh.)		      
	rec_poh = UpdStatus                                                     
	if rec_poh<0
		let returnstatus=0
		let message$="Error Trying to Add Purchase Order "
		goto endpocopypo:           !
	endif
	!!! set up parameters for call !!!
	clear chan[]
	 CHAN[0]=CTLC
	 CHAN[1]=CH_POH
	 CHAN[2]=CH_POL
	 CHAN[3]=CH_VEND
	 CHAN[4]=CH_PROD
	 CHAN[5]=CH_PRWH
	 CHAN[6]=CH_NSTK
	 CHAN[7]=CH_CCODE
	 CHAN[8]=CH_WH
	 chan[9]=ch_pom! po messages #69
	 chan[12]=ch_deal ! deals #19
	 chan[15]=ch_alt ! alternate vendor
	 
	 parm[0]=orgpoid ! purchase order # to copy debit memo into 
	 parm[1]=rec_poh ! new puchase order header rec#
	 parm[2]=poh.vendorcode !  new purchase order vendor code
	 parm[3]=rec_opoh ! old purchase order number
	 parm[4]=opoh.vendorcode ! old purchase order vendor code
	 parm[8]=poid ! new purchase order
	 parm[9]=intco ! control #
	 msg$=""
	 errtype=0
	 call "pocopypo.dl4",Chan[],parm[],rstr$,msg$,errtype
	 !!! parameters for line screen
		! chan[3]=ch_roh ! order header #62
		! chan[8]=ch_rol ! order lines #68		
		!!chan[10]=ch_rom ! order message #70
		!chan[11]=ch_pogen ! po gen work #72
		!chan[13]=ch_cust ! customer file
		!chan[14]=ch_rot ! order total file		
		!call "posolinecopy.dl4",Chan[],parm[],msg$,errtype,userid$
		! now total
	call calcpototals()
	if rec_poh>0
		Write Record #ch_poh,Rec_poh;poh.;
		clear parm[]
		Parm[0]=rec_poh
		Parm[1]=361 ! source
		Parm[2]=1 ! 1=entry
		Parm[9]=intco ! company #                                                                        
		 clear chan[]
		chan[0]=ctlc 
		chan[1]=ch_poh
		chan[16]=ch_vend! vendor file
		CALL "POFRGTCHG",chan[],parm[]  
	endif
		
! end pocopypo
Endpocopypo: ! end verify purchase order
	clear list$[]
	list$[0]=bsdel$,"POCopyPO",fdel$
	list$[1]="VendID",fdel$,"POID",fdel$
	list$[2]=str$(vendid),fdel$,str$(poid),fdel$
	list$[3]=esdel$
	call AddToStr(e$,rstr$,List$[]) ! mtg
	clear list$[]
	webstr$=""
	list$[0]= bsdel$,"Warning",fdel$
	webstr$ = "Message",fdel$                               
	list$[1]=webstr$
	let row=2
	if errtype
		webstr$=msg$,fdel$
		let list$[2]=webstr$
		let row=3
	endif
	let list$[row]=esdel$
    call AddToStr(e$,rstr$,List$[]) ! mtg
	
    ! status section *** last section ***
	Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	
	! done with it
     call SetOutPut(e$,rstr$)
!!! END Close PURCHASE ORDER
case  "IMPORTGETHDR" 
	LET returnstatus=1
	let message$="OK"
	call dxget ("vendid",Vendid$)
	let vendid=vendid$
        if vendid<=0 or vendid>999999
		let message$="Vendor Id "+str$(vendid)+" Invalid"
		let returnstatus=0
		goto endimpgethdr:
	endif
	call dxget ("poid",poid$)
	let poid=poid$
	if poid<=0 OR poid>999999
		let message$="Purchase Order "+str$(poid)+" Invalid"
		let returnstatus=0
		goto endimpgethdr:
	endif
	
	call dxget ("SOURCE",tmp$)
	let source=tmp$
	call verifyvendor()
	if not (returnstatus)  goto endimpgethdr:
	keypoh$=" ",keypoh$
	keypoh$[1,6]=vendid using "######" 
	keypoh$[7,12]=poid using "######"
	mode$="=" ! search mode 2
	dir=2
	Rec_poh=filegetpohead(e$,ch_poh,mode$,dir,keypoh$,poh.)
	if rec_poh<0
		let returnstatus=99
		let message$="PO Number ",keypoh$[7,12]," Not On File"
		GOTO endimpgethdr:
	endif
	if source<>370 and source<>371 and source<>381 and source<>379
		if poh.status<>95
			let returnstatus=99
			let message$="PO Number ",keypoh$[7,12]," Is not in Edit Status"
			GOTO endimpgethdr:
		endif
	endif
	if source=371
		if poh.status<>96
			let returnstatus=99
			let message$="PO Number ",keypoh$[7,12]," Is not in Receiving Status"
			GOTO endimpgethdr: 
		endif
	endif
	if source=381
		if poh.status<>97
			let returnstatus=99
			let message$="Debit Memo ",keypoh$[7,12]," Is not in Edit Status"
			GOTO endimpgethdr: 
		endif
	endif
	if poh.type<4 or poh.type>6 !!! imports are ok now
		let returnstatus=99
		let message$="PO Number ",keypoh$[7,12]," Invalid Import Order Type"
		GOTO endimpgethdr: 
	endif
	let powh=poh.warehouse
	let potype=poh.type
		
	
	endimpgethdr: ! make the sections
	! section 1 - purchase order ship via list
	clear list$[]
	Call FileDropListposhpvia(e$,List$[],maxcnt,ch_posv)
	call AddToStr(e$,rstr$,List$[])
	! section 2 - import broker
	CLEAR LIST$[]
	CLEAR FIELDS$[]
	call filedroplistpobroker(e$,list$[],maxcnt,Ch_pobr,"",fields$[],1,"","B")
	!call filedroplistpobroker(e$,list$[],maxcnt,Ch_pobr)
	call AddToStr(e$,rstr$,List$[])
	! section 3 - po import detail
	Clear List$[]                                                         
	List$[0] = bsdel$ + "POImportI" + fdel$ ! section name
	webstr$="VendId",fdel$
	webstr$=webstr$,"poId",fdel$
        webstr$=webstr$,"CableDate",fdel$
	webstr$=webstr$,"VendorCable",fdel$
	webstr$=webstr$,"ShpngType",fdel$
	webstr$=webstr$,"Broker",fdel$
	webstr$=webstr$,"MadeIn",fdel$
	webstr$=webstr$,"Shipmark",fdel$
	webstr$=webstr$,"ShipViaId",fdel$
	webstr$=webstr$,"ShipViaDesc",fdel$
	webstr$=webstr$,"SamplesAir",fdel$
	webstr$=webstr$,"SamplesAppr",fdel$
	webstr$=webstr$,"SamplesAdv",fdel$
	webstr$=webstr$,"IndivBoxAppr",fdel$
	webstr$=webstr$,"IndivBoxFree",fdel$
	webstr$=webstr$,"DisplayBoxAppr",fdel$
	webstr$=webstr$,"DisplayBoxFree",fdel$
	webstr$=webstr$,"HeaderAppr",fdel$
	webstr$=webstr$,"HeaderFree",fdel$
	let list$[1]=webstr$
	row=2
	if returnstatus>0 and returnstatus<99! no errors send over the data
		webstr$=str$(poh.vendorcode),fdel$
		webstr$=webstr$,str$(poh.purchaseorder),fdel$
		if poh.cabledate<>0
			let xdate$=pdate$(poh.cabledate)
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! cable date
		if poh.lastcabledate<>0
			let xdate$=pdate$(poh.lastcabledate)
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! last cable date	= vendor cable
		webstr$=webstr$,str$(poh.ShippingType),fdel$ ! shipping type
		webstr$=webstr$,rtrim$(poh.Broker$),fdel$ ! broker
		webstr$=webstr$,rtrim$(poh.MadeIn$),fdel$ ! made in
		webstr$=webstr$,rtrim$(poh.shipmark$),fdel$ ! ship mark
		Webstr$=webstr$,str$(poh.shipviaID),fdel$ ! ship via id
		Webstr$=webstr$,rtrim$(poh.shipvia$),fdel$ ! ship via desc 
		let tmp$="N" 
		if poh.SamplesByAir<>0 let tmp$="Y"
		webstr$=webstr$,rtrim$(tmp$),fdel$    
		Webstr$=webstr$,str$(poh.SampleApprov),fdel$ 
		Webstr$=webstr$,str$(poh.SampByAirAdv),fdel$ 
		let tmp$="N" 
		if poh.SubmitApprIndv<>0 let tmp$="Y"
		webstr$=webstr$,rtrim$(tmp$),fdel$ 
 		Webstr$=webstr$,str$(poh.InclFreeIndvBox),fdel$
		let tmp$="N"
		if poh.Display<>0 let tmp$="Y"
        webstr$=webstr$,rtrim$(tmp$),fdel$ 
		webstr$=webstr$,str$(poh.Display1),fdel$
		let tmp$="N"
		if poh.header<>0 let tmp$="Y"
		webstr$=webstr$,rtrim$(tmp$),fdel$ 
		webstr$=webstr$,str$(poh.bags),fdel$
		LIST$[2]=WEBSTR$
		let row=row+1
	endif
	
	List$[row]=esdel$! end of section
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string	
	! status section *** last section ***
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! Call dxsave(0,"/tmp/md.txt!")
	! done with it
        call SetOutPut(e$,rstr$)
!!! - end ImportGETHeader
case  "IMPORTSUBMITHDR" 
	dim oldbroker$[5]
	LET returnstatus=1
	let message$="OK"
	call dxget ("vendid",Vendid$)
	let vendid=vendid$
        if vendid<=0 or vendid>999999
		let message$="Vendor Id "+str$(vendid)+" Invalid"
		let returnstatus=0
		goto endimpsubhdr:
	endif
	call dxget ("poid",poid$)
	let poid=poid$
	if poid<=0 OR poid>999999
		let message$="Purchase Order "+str$(poid)+" Invalid"
		let returnstatus=0
		goto endimpsubhdr:
	endif
	
	call dxget ("SOURCE",tmp$)
	let source=tmp$
	call verifyvendor()
	if not (returnstatus)  goto endimpgethdr:
	keypoh$=" ",keypoh$
	keypoh$[1,6]=vendid using "######" 
	keypoh$[7,12]=poid using "######"
	mode$="=" ! search mode 2
	dir=2
	Rec_poh=filegetpohead(e$,ch_poh,mode$,dir,keypoh$,poh.)
	if rec_poh<0
		let returnstatus=99
		let message$="PO Number ",keypoh$[7,12]," Not On File"
		GOTO endimpsubhdr:
	endif
	if source<>370 and source<>371 and source<>381 and source<>379
		if poh.status<>95
			let returnstatus=99
			let message$="PO Number ",keypoh$[7,12]," Is not in Edit Status"
			GOTO endimpsubhdr:
		endif
	endif
	if source=371
		if poh.status<>96
			let returnstatus=99
			let message$="PO Number ",keypoh$[7,12]," Is not in Receiving Status"
			GOTO endimpsubhdr: 
		endif
	endif
	if source=381
		if poh.status<>97
			let returnstatus=99
			let message$="Debit Memo ",keypoh$[7,12]," Is not in Edit Status"
			GOTO endimpsubhdr: 
		endif
	endif
	if poh.type<4 or poh.type>6 !!! imports are ok now
		let returnstatus=99
		let message$="PO Number ",keypoh$[7,12]," Invalid Import Order Type"
		GOTO endimpsubhdr: 
	endif	
	let oldbroker$=poh.broker$
	
	call dxget ("CableDate",tmp$) 
	if rtrim$(tmp$)<>""
		xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
		poh.cabledate=xdate$[3,8]
	else
		poh.cabledate=0
	endif
	call dxget ("VendorCable",tmp$)
	if rtrim$(tmp$)<>""
		xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
		poh.lastcabledate=xdate$[3,8]
	else
		poh.lastcabledate=0
	endif
	call dxget ("ShpngType",tmp$)
	let tmp3=tmp$
	if tmp3<0 or tmp3>99
		let returnstatus=0
		let message$="Invalid Shipping Type "
		goto endimpsubhdr:
	endif
	poh.ShippingType=tmp3
	call dxget ("Broker",tmp$)
	if rtrim$(tmp$)=""
		let returnstatus=0
		let message$="Invalid Broker"
		goto endimpsubhdr:
	endif
	let keypobr$=rtriM$(tmp$)+blank$
	search #ch_pobr,2,1;keypobr$,tmp3,e
	if e<>0
		let returnstatus=0
		let message$="Invalid Broker"
		goto endimpsubhdr:
	endif	
	poh.broker$=rtrim$(tmp$)+blank$
	call dxget ("MadeIn",tmp$)
	let poh.MadeIn$=rtrim$(tmp$)+blank$
	call dxget ("Shipmark",tmp$)
	let poh.shipmark$=rtrim$(tmp$)+blank$ 
	call dxget("ShipViaId",tmp$)
	poh.shipviaID=tmp$ ! ship via id       
	call dxget("ShipViaDesc",tmp$)
	poh.shipvia$=tmp$+"           "
	call dxget ("SamplesAir",tmp$)
	let poh.samplesbyair=0
	if rtrim$(ucase$(tmp$))="Y" let poh.samplesbyair=1
	call dxget ("SamplesAppr",tmp$)
	let tmp3=tmp$
	if tmp3<0 or tmp3>99
		let returnstatus=0
		let message$="Invalid Number of Samples Approved"
		goto endimpsubhdr:
	endif
	poh.SampleApprov=tmp3
	call dxget ("SamplesAdv",tmp$)
	let tmp3=tmp$
	if tmp3<0 or tmp3>99
		let returnstatus=0
		let message$="Invalid Number of Samples Advanced"
		goto endimpsubhdr:
	endif
	poh.SampByAirAdv=tmp3	
	call dxget ("IndivBoxAppr",tmp$)
	poh.SubmitApprIndv=0
	if rtrim$(ucase$(tmp$))="Y" let poh.SubmitApprIndv=1
	call dxget ("IndivBoxFree",tmp$)
	let tmp3=tmp$
	if tmp3<0 or tmp3>99
		let returnstatus=0
		let message$="Invalid Number of Individual Boxes"
		goto endimpsubhdr:
	endif
	let poh.InclFreeIndvBox=tmp3
	call dxget ("DisplayBoxAppr",tmp$)
	poh.Display=0
	if rtrim$(ucase$(tmp$))="Y" let poh.display=1
	call dxget ("DisplayBoxFree",tmp$)
	let tmp3=tmp$
	if tmp3<0 or tmp3>99
		let returnstatus=0
		let message$="Invalid Number of Display Boxes"
		goto endimpsubhdr:
	endif
	let poh.display1=tmp3
	call dxget ("HeaderAppr",tmp$)
	let poh.header=0
	if rtrim$(ucase$(tmp$))="Y" let poh.header=1
	call dxget ("HeaderFree",tmp$)
	let tmp3=tmp$
	if tmp3<0 or tmp3>99
		let returnstatus=0
		let message$="Invalid Number of Header Boxes"
		goto endimpsubhdr:
	endif
	let poh.bags=tmp3
	write record #ch_poh,rec_poh;poh.;
	if rtrim$(oldbroker$)<>rtrim$(poh.broker$)
		keypol$=" ",keypol$
		keypol$[1,6]=poid using "######"  ! starts with poid
		mode$=">" ! search mode 3
		dir=1	
		Do
	 		Rec_pol=filegetpoline(e$,ch_pol,mode$,dir,keypol$,pol.)
			If Rec_pol<0   Exit Do
			let tmp3=keypol$[1,6]\if tmp3<>poid Exit Do
			Read Record #ch_pol,rec_pol;pol.;
			LET X2=pol.flags ! ! REM UNPACK pol.Flags TO FLAGS[x] 
			FOR K=0 TO 11                     
				LET FLAGS[K]=SGN(FRA(X2/2)) \ LET X2=INT(X2/2) 
			NEXT K
			if flags[2]=0 ! not a message line
					if not(flags[0]) ! product line
						let rec_prod=pol.ProdDescRec
						read record #ch_prod,rec_prod;prod.;
					else	
						let rec_nstk=pol.ProdDescRec
						read record #ch_nstk,rec_nstk;nstk.;
						clear prod.                                                           
						prod.baseum=nstk.BaseUM ! nsd1[2]
						prod.um2=nstk.CostUM !    nsd1[3]
						prod.um3=nstk.PurchUM !nsd1[4]
						prod.um4=nstk.StockUM !nsd1[5]
						prod.UMStkDefault = nstk.StockUM ! NSD1[5]
						prod.UMPurchDefault=nstk.PurchUM ! NSD1[4]
						prod.UMCostDefault= nstk.CostUM  ! NSD1[3]
						prod.UM2Fact=nstk.CostFact !nsd3[3]
						prod.UM3Fact=nstk.POFact !nsd3[4]
						prod.UM4Fact=nstk.StkFact !nsd3[5]                                             
						prod.LbsFact=nstk.WgtFact !NSD3[7]
						prod.LbsUnit=nstk.Wgt  !NSD3[6]   				
					endif
					call calcimplinetot() ! need to calculate totals
					Write Record #ch_pol,rec_pol;pol.;
			endif
		Loop
	Endif
	endimpsubhdr: ! make the sections
	! status section *** last section ***
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! Call dxsave(0,"/tmp/md.txt!")
	call SetOutPut(e$,rstr$)
end select
    !
  ! call dxclose()
else
  include "src/callmainerrnet.inc"
end try
end
 
!--------------------------------------------------------------------
sub OpenFiles()
  
  ! Open files for po entry
  
  Try
    !
    Ch_Prod = OpenFile(1792,intCo) \ If Ch_Prod = -1 Error 42  !product file 
    Ch_Roh = openfile(1840,intCo) \ If Ch_Roh = -1 Error 42     !order  header file
    Ch_Vend = OpenFile(2400,intCo) \ If Ch_Vend = -1 Error 42  ! vend
    Ch_Cust = OpenFile(1808,intCo) \ If Ch_Cust = -1 Error 42  ! customer
    Ch_PrdKey = OpenFile(1104,intCo) \ If Ch_PrdKey = -1 Error 42  !product description key file 
    Ch_Poh = openfile(2416,intCo) \ If Ch_Poh = -1 Error 42     !"po header file
    Ch_PoL = openfile(2432,intCo) \ If Ch_Pol = -1 Error 42     !"po lines file
    Ch_PrWh = OpenFile(1744,intCo) \ If Ch_PrWh = -1 Error 42  !"product warehouse file
    Ch_Pom = openfile(2464,intCo) \ If Ch_Pom = -1 Error 42     !"po message file
    Ch_Wh = OpenFile(2768,intCo) \ If Ch_Wh = -1 Error 42  !" warehouse file
    Ch_Ccode = OpenFile(-1728,intCo) \ If Ch_Ccode = -1 Error 42  !u/m codes file  
    ch_nstk=OpenFile(2448,intCo) \ If Ch_nstk = -1 Error 42 ! nonstock product
    ch_vtag=OpenFile(1120,intCo) \ If Ch_vtag = -1 Error 42 ! vemdtag
    ch_rol=OpenFile(1888,intCo) \ If Ch_rol = -1 Error 42 ! order line 
    Ch_Ros = openfile(1856,intCo) \ If Ch_Ros = -1 Error 42     !"order shipto file
    Ch_Misc = OpenFile(-9949,intCo) \ If ch_misc = -1 Error 42  !po misc charge (-2032 misc charge)
    Ch_Deal = OpenFile(-864,intCo) \ If Ch_Deal = -1 Error 42  !deals file
    Ch_Wloc= OpenFile(-2736,intCo) \ If Ch_Wloc = -1 Error 42  !warehouse location
    ch_polot=OpenFile(1088,intCo) \ If Ch_polot = -1 Error 42 !spolot file
    ch_sprodlot=OpenFile(2528,intCo) \ If Ch_sprodlot = -1 Error 42 !sprodlot file
    ch_sordlot=OpenFile(2320,intCo) \ If Ch_sordlot = -1 Error 42 !sordlot file
    Ch_Rom = openfile(1968,intCo) \ If Ch_Rom = -1 Error 42     !order  message file
    ch_alt=OpenFile(1568,intCo) \ If Ch_alt = -1 Error 42 !alternate vendor code
    ch_buy=OpenFile(-9991,intCo) \ If Ch_buy = -1 Error 42 ! buyer
    ch_posv=OpenFile(-9954,intCo) \ If Ch_posv = -1 Error 42 ! ch_posv
    ch_pogen=OpenFile(2752,intCo) \ If Ch_pogen = -1 Error 42 ! ch_pogenwrk file
    ch_deal=OpenFile(864,intCo) \ If Ch_deals = -1 Error 42 ! deals file
    ch_rot=OpenFile(1872,intCo) \ If Ch_rot = -1 Error 42 ! order total!
	sqlChan = OpenMySQLMirror(e$)
	IF p60$[46,46]="Y" ! import section
		ch_poof= OpenFile("POOCNFRT",Intco,"R") 
		ch_pocd= OpenFile("POCDUTY",Intco,"R") 
		ch_pobr= OpenFile("POBROKER",Intco,"R") 
	ENDIF
	if cpiFlag
		cpidChan = openfile(9928,intCo)
		if cpidChan = -1
			cpiFlag = 0
		else
			spChan = openfile(-1936,intCo)
		end if
	end if
	If p61$[136,136]="Y"
		ch_curr=OpenFile(-9712,IntCo) \ if ch_curr = -1 Error 42 
	endif
  else
    include "src/callsuberr.inc"
  end try
end sub ! openfiles
! 

! ------------------------------------------------------------------------
Sub PoList()  
!! this get a list of the open pos for the customer !!
try
	Dim vend$[6],keypoh$[12],xdate$[10]
	LET STATWORD$="ENTERED   PRINTED   REGISTEREDOPEN      "
	Call DXGet("vendid",vend$) \ vendid=vend$
	vend$=vendid using "######"
	vend$ = vend$+"            "
	vend$[7]="" ! "cut after 6 chars
	call dxget ("postatus",tmp$) ! 0=open 1=close 2=ready to receive
	let postatus=tmp$
	clear List$[]
	keypoh$=" ",keypoh$
	keypoh$=vend$
	List$[0]=bsdel$,"PoList",fdel$
	WebStr$="POID",fdel$
	WebStr$=WebStr$,"Ord Date",fdel$
	WebStr$=WebStr$,"Due Date",fdel$
	Webstr$=Webstr$,"Amount",fdel$
	Webstr$=Webstr$,"Whse",fdel$
	Webstr$=webstr$,"Status",fdel$
	Webstr$=Webstr$,"Type",fdel$
	Webstr$=Webstr$,"Vendor Ref",fdel$
	Webstr$=Webstr$,"Rcvd",fdel$
	Webstr$=Webstr$,"Ship Name",fdel$
	Call dxget("source",tmp$) ! 0=open 1=close 2=ready to receive
	let source=tmp$
	if source=378
		webstr$=Webstr$,"VendID",fdel$
		webstr$=Webstr$,"VendName",fdel$
	else
		webstr$=webstr$,"",fdel$
		webstr$=webstr$,"",fdel$
	endif
	webstr$=webstr$,"Highlight",fdel$
	List$[1]=WebStr$

	row=2
	tmpcnt=maxcnt
	call dxget ("source",tmp$) ! 
	let source=tmp$
	if source=378 goto srchpohlist: ! receiving labels
	if postatus=1 and source=371
		let returnstatus=0
		let message$="Invalid PO Status for Source 371 Receiving" ! 
		goto endpohlist: !
	endif
	if postatus=2 and source<>371
		let message$="Invalid PO Status. Only Valid For Source 371 Receiving"
		let returnstatus=0
		goto endpohlist: !
	endif
	if postatus=3 and source<>381 ! open debit memo only
		let message$="Invalid PO Status. Only Valid For Source 381 Debit Memo"
		let returnstatus=0
		goto endpohlist: !
	endif
	if postatus=4 and source<>381
		let message$="Invalid PO Status. Only Valid For Source 381 Debit Memo"
		let returnstatus=0
		goto endpohlist: !
	endif
	srchpohlist: ! search for po's
	keypoh$=" ",keypoh$
	keypoh$=vend$+"      " ! starts with vendomer
	mode$=">" ! search mode 3
	dir=2
	if source=378
		let keypoh$=" ",keypoh$
		if postatus=0
			let keypoh$[1,2]=" 1" ! po are open
		else
			let keypoh$[1,2]=" 5" ! po's in receiving process only  
		endif
		let mode$=">"
		dir=1
	endif
	
	Do
		Rec_poh=filegetpohead(e$,ch_poh,mode$,dir,keypoh$,poh.)
		If Rec_poh<0 Exit Do
		if source=378
			let tmp3=keypoh$[1,2]
			if tmp3>7 Exit Do		! "task46060 - was>6 - allow print of closed po's
		else
			if keypoh$[1,6]<>vend$[1,6] Exit Do
		endif
		let pook=0
		Try
			Call DXGet("WHSE",TMP$) 
			let tmp3=tmp$
			if tmp3<>0
				if poh.Warehouse<>tmp3
					let pook=0
					goto pookchk:
				endif
			endif
		else
			tmp3=0
		End Try	
		if source=378
			if postatus=2
				if poh.status=5 let pook=1 ! in process
				if poh.status=6 let pook=1 ! registered
			else
				let pook=1
			endif
			if poh.type=1 let pook=0 ! bypass directs
			if poh.type=4 let pook=0 ! bypass import directs
			goto pookchk:
		endif
		
		if poh.status<=4 and postatus=0 let pook=1
		if poh.status=7 and postatus=1 let pook=1 ! CLOSED ITEM
		If postatus=2 ! ready to receive
			if poh.status>1 and poh.status<6 let pook=1 ! ready to receive
		endif
		if poh.status=5 and postatus=2 let pook=1 ! received in process
		if poh.status>7 and poh.status<14 and postatus=3 let pook=1 ! open debit memo only
		if poh.status=14 and postatus=4 let pook=1
		pookchk: ! check if po ok
		if pook
		   	WebStr$=str$(poh.PurchaseOrder),fdel$ ! po ID 
			if poh.orderdate
				let xdate$=pdate$(poh.orderdate)
			else
				let xdate$=" ",xdate$
			endif
			WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! po order date
			
			if poh.duedate
				let xdate$=pdate$(poh.duedate)
			else
				let xdate$=" ",xdate$
			endif
			WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! po due date
			amount=poh.totamt
			if p61$[136,136]="Y" and poh.currfact<>0 ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=cnvca[0]
			endif
			Webstr$=webstr$,(amount  Using "$$$$$$$$$$#.##"),fdel$ ! poh.totamt
			Webstr$=webstr$,(poh.Warehouse using "##"),fdel$
                        
			LET tmp$=" ",tmp$
			if poh.status=7 let tmp$="CLOSED"
			if poh.status>0 and poh.status<5 
				tmp$=STATWORD$[poh.status*10-9,poh.status*10]
			endif
			If poh.status=5 let	 tmp$="RCVD PROC"
			if poh.status=6 let  tmp$="RCVD REG"
			if poh.status=14 let tmp$="DM CLOSED"
			if poh.status=11 let tmp$="DM Entered"
			if poh.Status=12 let tmp$="DM Printed"
			if poh.Status=13 let tmp$="DM Registered"
			WebStr$=WebStr$,RTrim$(tmp$),fdel$ ! status
			let tmp$=" ",tmp$
			IF poh.type=0 tmp$="W"  
			IF poh.type=1 tmp$="D"  
			IF poh.type=2 tmp$="I" 
			IF poh.type=3 tmp$="M" 
			IF poh.type=4 tmp$="IW" 
			IF poh.type=5 tmp$="ID"
			IF poh.type=6 tmp$="II" 
			IF poh.type=7 tmp$="IM"
			Webstr$=Webstr$,rtrim$(tmp$),fdel$ ! type
			WebStr$=WebStr$,RTrim$(poh.VendorRef$),fdel$ ! po#
			let tmp$=" ",tmp$
			if poh.TotPoRcvd<>0 let tmp$="*"
			Webstr$=Webstr$,rtrim$(tmp$),fdel$ ! po recd
			
			WebStr$=WebStr$,RTrim$(poh.shiptoname$),fdel$ ! ship to name
			if source=378
				webstr$=webstr$,(poh.vendorcode using "######"),fdel$
				keyvend$ = " ",keyvend$                                     
				keyvend$ = poh.vendorcode Using "######"                            
				tmp$ = "=" ! search mode 2                                 
				dir = 1                                                     
				Clear vend.                                                 
				rec_vend = filegeta80vm(e$,ch_vend,tmp$,dir,keyvend$,vend.)
				If rec_vend < 0                                             
					Vend.Name$="Vendor Not On File "                                          
				endif
				webstr$=webstr$,rtrim$(vend.name$),fdel$
			else
				let webstr$=webstr$,"",fdel$
				let webstr$=webstr$,"",fdel$
			End If  
			let tmp$="N"
			if poh.delvtime1>0 let tmp$="Y"
			webstr$=webstr$,tmp$,fdel$ ! highlight
				
			! need to have check for backpos ! 
			List$[row]=WebStr$
			row=row+1
			if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
		endif
	    Loop ! of open pos for customer
	    endpohlist: ! 
else
	! this is a remark
end try
end sub ! polist
!!! po line list 
Sub PoLineList()  
!! this get a list of po lines  !!
try
	Dim vend$[6],xdate$[10],PMASK$[20]
	dim 2%,Q0[1]
	dim 3%,qty,cost,amount,baseqty,cnvta

	tmp$="#",tmp$
	If q0[1]<=0 Let Q0[1]=2
	IF Q0[1]>=4 LET Q0[1]=4
	If Q0[1] Let Pmask$="-----------#.",tmp$[1,Q0[1]]     !price mask
	call dxget ("poid",tmp$) ! 0=open 1=close
	let poid=tmp$
	clear List$[]
	

	List$[0]=bsdel$,"PoLineList",fdel$
	WebStr$="Line",fdel$
	WebStr$=WebStr$,"ProdID",fdel$
	Webstr$=webstr$,"Description",fdel$
	WebStr$=WebStr$,"Qty",fdel$
	Webstr$=Webstr$,"Cost",fdel$
	Webstr$=Webstr$,"Whse",fdel$

	Webstr$=Webstr$,"Amount",fdel$
	List$[1]=WebStr$
	row=2
	let tmpcnt=maxcnt
	
	keypol$=" ",keypol$
	keypol$[1,6]=poid using "######"  ! starts with poid
	mode$=">" ! search mode 3
	dir=1
	
	Do
		Rec_pol=filegetpoline(e$,ch_pol,mode$,dir,keypol$,pol.)
		If Rec_pol<0   Exit Do
		let tmp3=keypol$[1,6]\if tmp3<>poid Exit Do
		LET X2=pol.flags ! ! REM UNPACK pol.Flags TO FLAGS[x] 
	        FOR K=0 TO 11                     
		   LET FLAGS[K]=SGN(FRA(X2/2)) \ LET X2=INT(X2/2) 
		NEXT K
		if flags[2]=0 ! not a message line
			WebStr$=(pol.ItemNo using "###"),fdel$ ! po line #
			Webstr$=webstr$,rtrim$(pol.ProdCode$),fdel$ ! product code
			Webstr$=webstr$,rtrim$(pol.Desc1$),fdel$ ! description
		        if not(flags[0]) ! product line
				let rec_prod=pol.ProdDescRec
				read record #ch_prod,rec_prod;prod.;
			else	
				let rec_nstk=pol.ProdDescRec
				read record #ch_nstk,rec_nstk;nstk.;
				clear prod.                                                           
				prod.baseum=nstk.BaseUM ! nsd1[2]
				prod.um2=nstk.CostUM !    nsd1[3]
				prod.um3=nstk.PurchUM !nsd1[4]
				prod.um4=nstk.StockUM !nsd1[5]
				prod.UMStkDefault = nstk.StockUM ! NSD1[5]
				prod.UMPurchDefault=nstk.PurchUM ! NSD1[4]
				prod.UMCostDefault= nstk.CostUM  ! NSD1[3]
				prod.UM2Fact=nstk.CostFact !nsd3[3]
				prod.UM3Fact=nstk.POFact !nsd3[4]
				prod.UM4Fact=nstk.StkFact !nsd3[5]                                             
				prod.LbsFact=nstk.WgtFact !NSD3[7]
				prod.LbsUnit=nstk.Wgt  !NSD3[6]  
				! nonstock po line variables                                           
				! LET PL4[12]=NSD3[6];PL4[13]=NSD3[7];PL4[14]=NSD3[2];PL4[15]=NSD3[8] 
				! LET L1$[1,30]=NSD$[13,42];L1$[31,60]=NSD$[43,72];L1$[61,80]=NSD$[73,92]   
				!  LET L1$[81,92]=NSD$[1,12]     
				
			endif
			! quantity
			if poL.status=3
				let baseqty=pol.qtyrcvdtodate
			else
				let baseqty=(pol.QtyOrd-pol.QtyrcvdToDate)+(pol.FreeGoods-pol.Totfreeqtyrcvd)
			endif
			let amount=0
			if baseqty<>0
				CNVTU[0] = 0;CNVTU[1] = prod.UMPurchDefault;CNVTU[2] = 1         
				CNVTA = baseqty                                          
				Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PRod.)
			endif
			tmp$ = XUnit$(prod.UMPurchDefault,Ch_Ccode)
			let webstr$=Webstr$,(amount using "########.##"),"/",rtrim$(tmp$),fdel$! qty

			let amount=0
			let netcost=(pol.netcost)
			CNVTU[0] = 0;CNVTU[1] = prod.UMCostDefault;CNVTU[2] = 2     
			CNVTA = NetCost 
			if cnvta<>0
				amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PRod.)  
			endif
			if p61$[136,136]="Y" and pol.currfact<>0 ! going from base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=pol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=cnvca[0]
			endif

			tmp$ = XUnit$(prod.UMCostDefault,Ch_Ccode)
			!let webstr$=Webstr$,(amount using "#########.##"),"/",rtrim$(tmp$),fdel$ ! cost
			let webstr$=Webstr$,(amount using pmask$),"/",rtrim$(tmp$),fdel$ ! cost
			tmp$=""
			LET webstr$=webstr$,str$(pol.whse),fdel$ ! warehouse #
			if baseqty<>0
				amount=pol.ExtNetCost
				if p61$[136,136]="Y" and pol.currfact<>0 ! going from base to costing um
					let cnvcu[0]=1
					let cnvca[0]=amount
					let cnvca[1]=pol.currfact
					call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
					let amount=fnr(cnvca[0])
				endif
				let tmp$=amount using "#########.##" ! amount pol.ExtNetCost
			endif
			let webstr$=webstr$,tmp$,fdel$
			
			! need to have check for backpos ! 
			List$[row]=WebStr$
			row=row+1
			if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
		endif
	    Loop ! of open pos for customer
else
	! this is a remark
end try
end sub ! polinelist


!!! --- end po line list


!------ powhdroplist ------
! filter eligible warehouse number for customer/po type
! need customer cons whs, po edit flag, 
Sub powhdroplist(list$[],poid,linesexist,potype,powh) 
Try
	 Read #ctlc,60,16;conswh;  
	 Read #ctlc,115,20;maxwh;  

  ! creates a drop lis
  clear list$[] !
   ! filter eligible warehouse number for customer/po type
   ! beginning section
    List$[0]=bsdel$,"droplistpowh",fdel$ ! beginning section
    ! heading section for .net
    List$[1]="ID",fdel$,"WhName",fdel$
    ! create data section
     row=2
    ! if source<>370
	if maxwh<>0
		if maxwh< (chf(ch_wh)-1) let maxwh=(chf(ch_wh)-1)
	endif
	for cnt=0 to maxwh  ! warehouse 1 starts at record 0
		!!! check to see if valid !!!
		read record #ch_wh,cnt;wh.;
		let webstr$=""
		if wh.whname$[1,5]<>"     " and wh.whname$<>"" ! needs to have a description to be valid
			if linesexist<>0
				if (cnt+1)=powh ! same warehouse include in list
					let tmp$=(cnt+1) using "##"
					let webstr$=tmp$,fdel$,wh.whname$,fdel$
				endif
			else
				if rtrim$(wh.Address1$)="" and powh<>(cnt+1)
					! exlcude from list in po if no address line
					! one warehouse and the warehouse is not
				else! no lines exist -- can change the warehouse
					let tmp$=(cnt+1) using "##"
					let webstr$=tmp$,fdel$,wh.whname$,fdel$
				endif
			endif
		endif
		if webstr$<>""
			 List$[row]=webstr$
			row=row+1
			if row>tmpcnt let tmpcnt=expandarray(E$,List$[])
		 endif
	next cnt
    ! Endif
    List$[row]=esdel$ ! end of section delimiter
    !
  else
    if spc(8) <> 10000
      e$="error in filedroplist whinfo"
    if spc(8) = 123 let e$=" record locked"
      if spc(8)<10000 if spc(8)<>123 call suberr(e$,Spc(8),Spc(10),Msc$(2))
    end if
    error 10000
  end try
end sub ! powhdroplist 
! ----------------------------------------------------------------------------------
 Sub potypelist(list$[],poid,linesexist,potype,powh) 
 !*** Currently For types 0,1,2 **** "W ","D ","I "
 try
	Clear list$[]
 	tmpcnt=maxcnt
	List$[0]=bsdel$,"droplistpotype",fdel$ ! beginning section!
	List$[1]="ID",fdel$,"Description",fdel$
	! if source<>370
	row=2
	IF linesexist=0 or potype=0
		List$[row]="W ",fdel$,"Warehouse",fdel$ 
		let row=row+1
	endif
	IF linesexist=0 or potype=1
		List$[row]="D ",fdel$,"Direct",fdel$ 
		let row=row+1
	endif
	IF linesexist=0 or potype=2
		List$[row]="I ",fdel$,"Indirect",fdel$ 
		let row=row+1
	endif
	if p60$[46,46]="Y" and source<>381
		IF linesexist=0 or potype=4
			List$[row]="IW",fdel$,"Import Warehouse",fdel$ 
			let row=row+1
		endif
		IF linesexist=0 or potype=5
			List$[row]="ID",fdel$,"Import Direct",fdel$ 
			let row=row+1
		endif
		IF linesexist=0 or potype=6
			List$[row]="II",fdel$,"Import Indirect",fdel$ 
			let row=row+1
		endif
	endif
	! add additional rows for import types
	! endif
	List$[row]=esdel$ ! end section delimiter
	!
  else
    include "src/callsuberr.inc"
  end try
end sub ! potypeList
! ---------------------------------------------------------------------------------
Sub freightunits(list$[]) 

 try
	Clear list$[]
 	tmpcnt=maxcnt
	List$[0]=bsdel$,"droplistfreight",fdel$ ! beginning section!
	List$[1]="ID",fdel$,"Description",fdel$
	! if source<>370
		row=2
		List$[row]="0",fdel$,"Flat",fdel$ 
		let row=row+1
		List$[row]="1",fdel$,"LB",fdel$ 
		let row=row+1
		List$[row]="2",fdel$,"CWT",fdel$ 
		let row=row+1
		List$[row]="3",fdel$,"CUBE",fdel$ 
		let row=row+1
		List$[row]="4",fdel$,"PIECE",fdel$ 
		let row=row+1
	! endif
	List$[row]=esdel$ ! end section delimiter
	!
  else
    include "src/callsuberr.inc"
  end try
end sub ! freightunits

! ----------------------------------------------------------------------------

Sub CalcPOTotals() 
                                                 	  

try
                                                    
!iF poh.status<>7 !LET poh.TotAmt=0 ! "only recalc if po is open              
!poh.TotWeight=0
NumLines=0                                                    
!poh.TotCubes=0
!poh.TotPieces=0
let totuntc=0;hasdisc=0
totordamt=0
totrordqty=0
dsp_totordamt=0
dsp_totrcvdamt=0
totordwgt=0
totordcube=0
let totrcvdamt=0
let totrcvdqty=0
let totrcvdwgt=0
let totrcvdcube=0
LET VALUE_RECV=0;WEIGHT_RECV=0;CUBES_RECV=0;QTY_RECV=0                    
let keypol$=" ",keypol$
let keypol$[1,6]=poh.PurchaseOrder using "######"
let keychk$=" ",keychk$
let keychk$[1,6]=keypol$[1,6]
let mode$=">"
let dir=1
CHKRECV=0
Do
	Rec_pol=FileGetPoline(e$,Ch_Pol,mode$,dir,keypol$,pol.)
	if rec_pol<0 exit do
	if keypol$[1,6]<>keychk$[1,6] exit do
	! unpack flags                  
	LET X2=pol.flags 
	FOR K=0 TO 11                           
		LET FLAGS[K]=SGN(FRA(X2/2)) \ LET X2=INT(X2/2) 
	NEXT K  
	IF FLAGS[1]<>0 LET CHKRECV=99 ! *** CLOSED SHORT ****
	if not(flags[2]) ! not a message line                                                               
		if not (flags[0]) ! stock item
			read record #ch_prod,pol.ProdDescRec;prod.;
		else ! nonstock item
			read record #ch_nstk,pol.ProdDescRec;nstk.;
			clear prod.
			let rec_nstk=pol.ProdDescRec
			read record #ch_nstk,rec_nstk;nstk.;
			clear prod.                                                           
			prod.baseum=nstk.BaseUM ! nsd1[2]
			prod.um2=nstk.CostUM !    nsd1[3]
			prod.um3=nstk.PurchUM !nsd1[4]
			prod.um4=nstk.StockUM !nsd1[5]
			prod.UMStkDefault = nstk.StockUM ! NSD1[5]
			prod.UMPurchDefault=nstk.PurchUM ! NSD1[4]
			prod.UMCostDefault= nstk.CostUM  ! NSD1[3]
			prod.UM2Fact=nstk.CostFact !nsd3[3]
			prod.UM3Fact=nstk.POFact !nsd3[4]
			prod.UM4Fact=nstk.StkFact !nsd3[5]                                             
			prod.LbsFact=nstk.WgtFact !NSD3[7]
			prod.LbsUnit=nstk.Wgt  !NSD3[6]  
		endif		
		! calculate totals
		NumLines=NumLines+1
		
		if source=371 or source=381
			if pol.currqtyrcvd<>0
			
			let cnvta=pol.currqtyrcvd
			If source=381 let cnvta=pol.currqtyrcvd+pol.freeqtyrcvd
			let amount=0
			if cnvta<>0
				CNVTU[0] = 0;CNVTU[1] = prod.UMPurchDefault;CNVTU[2] = 1         
				Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PRod.)
				totrcvdqty=totrcvdqty+amount
			endif                          
			lineqty = pol.currqtyrcvd-pol.freeqtyrcvd 
			if pol.currqtyrcvd<>0 LET CHKRECV=99
			if pol.freeqtyrcvd<>0 let chkrecv=99
			If source=381 let lineqty=pol.currqtyrcvd
			lineum = pol.CostUM                                                 
			linecost = pol.netcost                                              
			lineextamt = 0                                                      
			LbsUnit = pol.LbsUnit                                               
			LbsFact = pol.LbsFactor 
			currfact=0
			if lineqty<>0 and linecost<>0 
				Call CalcExtAmt(lineqty,lineum,linecost,lineextamt,LbsUnit,LbsFact,currfact) 
				totrcvdamt = totrcvdamt+ lineextamt
				if p61$[136,136]="Y" and pol.currfact<>0
					let currfact=pol.currfact
					Call CalcExtAmt(lineqty,lineum,linecost,lineextamt,LbsUnit,LbsFact,currfact) 
					let dsp_totrcvdamt=dsp_totrcvdamt+lineextamt
				else
					let dsp_totrcvdamt=dsp_totrcvdamt+lineextamt
				endif
			endif			
			lineqty = pol.currqtyrcvd
			If source=381 let lineqty=pol.currqtyrcvd+pol.freeqtyrcvd
			tmp3 = calcextwgt(lineqty,pol.LbsUnit,pol.LbsFactor) 
			totrcvdwgt=totrcvdwgt+tmp3
			tmp3 = calcextcube(lineqty,pol.cbfunit,pol.cbffactor)
			totrcvdcube=totrcvdcube+tmp3
			endif
		endif
		if source=370
			let recv_qty=0; recv_qty1=0
			if poh.Status<>5 and poh.OldStatus<>5                                               
				RECV_QTY1=(pol.QtyRcvdToDate-pol.Totfreeqtyrcvd);RECV_QTY=pol.QtyRcvdToDate
			else
				ReCV_QTY1=(pol.CurrQtyRcvd-pol.Freeqtyrcvd);RECV_QTY=pol.CurrQtyRcvd	
			endif                               
                                   
					
			let cnvta=RECV_QTY ! with free goods
			let amount=0
			if cnvta<>0
				CNVTU[0] = 0;CNVTU[1] = prod.UMPurchDefault;CNVTU[2] = 1         
				Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PRod.)
				totrcvdqty=totrcvdqty+amount
			endif  
			lineqty = RECV_QTY1 ! without the free goods
			lineum = pol.CostUM                                                 
			linecost = pol.netcost                                              
			lineextamt = 0                                                      
			LbsUnit = pol.LbsUnit                                               
			LbsFact = pol.LbsFactor  
			currfact=0
			if lineqty<>0 and linecost<>0 
				Call CalcExtAmt(lineqty,lineum,linecost,lineextamt,LbsUnit,LbsFact,currfact) 
				totrcvdamt = totrcvdamt+ lineextamt
				if p61$[136,136]="Y" and pol.currfact<>0
					let currfact=pol.currfact
					Call CalcExtAmt(lineqty,lineum,linecost,lineextamt,LbsUnit,LbsFact,currfact) 
					let dsp_totrcvdamt=dsp_totrcvdamt+lineextamt
				else
					let dsp_totrcvdamt=dsp_totrcvdamt+lineextamt
				endif
			endif
			lineqty = recv_qty ! with free goods
			tmp3=0
			if lineqty<>0
				tmp3 = calcextwgt(lineqty,pol.LbsUnit,pol.LbsFactor) 
			endif
			totrcvdwgt=totrcvdwgt+tmp3
			tmp3=0
			if lineqty<>0
				tmp3 = calcextcube(lineqty,pol.cbfunit,pol.cbffactor)
				totrcvdcube=totrcvdcube+tmp3
			endif
		endif
		! order totals ! 
		lineum = pol.CostUM                                                 
		linecost = pol.netcost                                              
		lineextamt = 0                                                      
		LbsUnit = pol.LbsUnit                                               
		LbsFact = pol.LbsFactor
		If poh.status=7
			let lineqty=pol.QtyOrd
		else
			let lineqty=pol.QtyShip 
		endif
		let currfact=0
		if lineqty<>0 and linecost<>0 
			Call CalcExtAmt(lineqty,lineum,linecost,lineextamt,LbsUnit,LbsFact,currfact) 
			totordamt = totordamt+ lineextamt
			if p61$[136,136]="Y" and pol.currfact<>0
					let currfact=pol.currfact
					Call CalcExtAmt(lineqty,lineum,linecost,lineextamt,LbsUnit,LbsFact,currfact) 
					let dsp_totordamt=dsp_totordamt+lineextamt
			else
				let dsp_totordamt=dsp_totordamt+lineextamt
			endif
		endif
		If poh.status=7
			let lineqty=pol.QtyOrd+POL.FreeGoods 
		else
			let lineqty=pol.QtyShip+pol.FreeGoods-Totfreeqtyrcvd 
		endif
		let amount=0
		let cnvta=lineqty
		if cnvta<>0
			CNVTU[0] = 0;CNVTU[1] = prod.UMPurchDefault;CNVTU[2] = 1         
			Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PRod.)
			TotOrdQty=TotOrdQty+amount
		endif
		tmp3 = calcextwgt(lineqty,pol.LbsUnit,pol.LbsFactor) 
		totordwgt=totordwgt+tmp3
		tmp3 = calcextcube(lineqty,pol.cbfunit,pol.cbffactor)
		totordcube=totordcube+tmp3
	endif
	if pol.Discpct<>0 or pol.DiscUnt<>0 let hasdisc=99
	if source=371
		if pol.LastQtyRcvD<>0
			let totuntc=totuntc+POL.ExtUnitCost
		endif
	else
		let totuntc=totuntc+POL.ExtUnitCost
	endif
Loop
if poh.status=7 or poh.status=14 ! close po or debit memo
	let totordamt=poh.totamt
	let totordwgt=poh.totweight
	let totordcube=poh.totcubes
	let totordqty=poh.TotPieces
else
	if source=371 or source=381 And poh.status > 4  !! TASK 65965
		let poh.totamt=totrcvdamt
		let poh.totweight=totrcvdwgt
		let poh.totcubes=totrcvdcube
		let poh.totpieces=totrcvdqty
	else
		if source<>370 ! not inquiry
			let poh.totamt=totordamt
			let poh.totweight=totordwgt
			let poh.totcubes=totordcube
			let poh.totpieces=totordqty
		endif
	endif
endif
	
else
	! this is a remark
end try
end sub ! calcpototals
! ------------------------------------------------------------------

! ---------------------------------------------------------------------------------
Sub VerifyVendor() 
	  

try
	  keyvend$=" ",keyvend$
	  keyvend$=vendid using "######"
	  mode$="=" ! search mode 2
	  dir=1
	  clear vend.
	  Rec_vend=filegeta80vm(e$,ch_vend,mode$,dir,keyvend$,vend.)
	  if rec_vend<0
		let returnstatus=0
		let message$="Vendor "+str$(vendid)+" Not On File. "
	  endif
	  if returnstatus>0
		keyvend$=" ",keyvend$
		keyvend$=vendid using "######"
		mode$="=" ! search mode 2
		dir=1
		clear vtag.
		Rec_vtag=filegetvendtag(e$,ch_vtag,mode$,dir,keyvend$,vtag.)
		if rec_vtag<0
			let returnstatus=0
			let message$="Vendor "+str$(vendid)+" Not In Tag File . "
		endif	
	  endif
		
else
	! this is a remark
end try
end sub ! Verify Vendor  

!--------------------------------------------------------------------
Sub CalcExtAmt(lineqty,lineum,linecost,lineextamt,lbsunit,lbsfact,currfact)

! bring extended amount to costing unit of measure factors
! cost should be in base 
 Try
	 Dim 1%,CNVTU[2],FLAG,e
	dim 3%,tmpqty,tmpcost
	DIM 3%,CNVTA
	lineextamt=0
	if lineqty=0 exit sub ! no qty extension will be zero
	if linecost=0 exit sub ! no cost exension will be zero
	If lineum=-2 ! lot costing 
		let lineextamt=linecost
		exit sub
	endif
	if lineum>=0                                                   
		LET CNVTA=lineqty
		let CNVTU[0]=0 ! currently in base
		let CNVTU[1]=lineum ! unit of measure
		let CNVTU[2]=5 ! qty
		Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PRod.)
		let tmpqty=amount
                                                
	                                                                   
		LET CNVTA=linecost
		CNVTU[0]=0
		CNVTU[1]=lineum
		CNVTU[2]=2 
		Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PRod.)
		if p61$[136,136]="Y" and currfact<>0 ! going from base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=pol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=cnvca[0]
			endif
		LET tmpcost=AMOUNT                                                      
		LET lineextamt=FNR(tmpqty*tmpcost)
		exit sub
	endif
	
	IF lineum=-1 or lineum=-3! cwt 
		let tmpqty=lineqty
		LET CNVTA=linecost
		CNVTU[0]=0
		CNVTU[1]=lineum
		CNVTU[2]=2 
		Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PRod.)   
		if p61$[136,136]="Y" and currfact<>0 ! going from base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=pol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=cnvca[0]
			endif
		LET tmpcost=AMOUNT                              
		if lineum=-1 ! cwt
			LET lineextamt=FNR(tmpcost*(lbsunit*tmpqty/lbsfact)/100)
			exit sub
		endif
		if lineum=-3 ! per lb
			LET lineextamt=FNR(tmpcost*(lbsunit*tmpqty/lbsfact))
			exit sub
		endif
	endif
 else
    include "src/callsuberr.inc"
  end try
end sub ! CalcExtAmt
!
!--------------------------------------------------------------------
 Function CalcExtWgt(lineqty,lbsunit ,lbsfact)
 ! send over the qty to calc, lbs per unit, lbs per factor
  Try
	
	Dim 3%,extwgt

	extwgt=0
	if lbsfact<>0
		let extwgt=fnr(lbsunit*lineqty/lbsfact)
	endif
 
  else
    include "src/callsuberr.inc"
  end try
end Function ExtWgt ! CalcExtWgt 
 !--------------------------------------------------------------------
 Function CalcExtCube(lineqty,cubeunit ,cubefact)
 ! send over the qty to calc, cube per unit, cube per factor
  Try
	
	Dim 3%,extcube

	extcube=0
	if cubefact<>0
		let extcube=fnr(cubeunit*lineqty/Cubefact)
	endif
 
  else
    include "src/callsuberr.inc"
  end try
end Function ExtCube ! CalcExtCube
!--------------------------------------------------------------------
! ----------------------------------------------------------------------------------------------------
Sub startpomisc()!
 Try
	include "src/inc/fileglglmz.inc" ! general ledger master file
	Dim glm. As glglm ! gl master file 
	dim 1%,poglflag
	dim keyglm$[50],3%,glmrec
	MAT  READ #ctlc,51,88;POGLFLAG;
	if not(poglflag) let p9$[17,17]="N"
	if p9$[17,17]="Y" or p9$[17,17]="M"
		ch_glm = OpenFile(-176,intCo) \ If ch_glm = -1 Error 42 !
	endif
	ReturnStatus=1
	Message$="OK" 
	Clear List$[]
	List$[0]=bsdel$,"General Ledger Account",fdel$
	WebStr$="GLACCTID",fdel$,"GLDESC",fdel$
        List$[1]=WebStr$
	If p9$[17,17]="Y" or p9$[17,17]="M"
		if returnstatus<>0 
			Webstr$=""
			Webstr$="0",fdel$
			Webstr$=webstr$,"Default",fdel$
			list$[2]=webstr$
			let row=3
			let tmpcnt=maxcnt ! 2000
			let keyglm$=" ",keyglm$
			do
				search #ch_glm,3,1;keyglm$,glmrec,e
				if e>0 exit do
				read record #ch_glm,glmrec;glm.;
				if glm.rectype$[1,1]="0" ! normal posting account
					let webstr$=Rtrim$(keyglm$),fdel$
					let webstr$=webstr$,rtrim$(glm.Desc$),fdel$
					let list$[row]=webstr$
					let row=row+1
					If row > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
				endif
			loop ! for the do
		endif
	endif
      	call AddToStr(e$,rstr$,List$[])          
	Call AddToStr(e$,rstr$,esdel$) ! end of section  ! gl
	Call FileDropListWhinfoz(e$,whList$[],100,ch_wh)  
	Call AddToStr(e$,rstr$,whList$[])
	Clear List$[]                                   
	Call FileDropListpomiscchrg(e$,List$[],100,ch_misc)
	Call AddToStr(e$,rstr$,List$[])
	CLEAR LIST$[]
	List$[0]=bsdel$,"POMiscFlag",fdel$
	WebStr$="GLFLAG",fdel$
	list$[1]=webstr$
	let tmp$="N"
	if p9$[17,17]="M" let tmp$="Y"
	if p9$[17,17]="Y" let tmp$="Y"
	webstr$=tmp$,fdel$
	list$[2]=webstr$
	Call AddToStr(e$,rstr$,List$[]) 
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! startpomisc

! ----------------------------------------------------------------------------------------------------
Sub getpomisc()! 
 Try
	dim 1%,pomiscid
	dim glname$[22],keyglm$[12]
	dim 3%,rec,whsegl[99]
	ReturnStatus=1
	Message$="OK"
	Call Dxget("POMISCID",tmp$)
	let pomiscid=tmp$
	if pomiscid<=0 or pomiscid>999
		let returnstatus=0
		let message$="Invalid Purchase Order Miscelleneous Charge Code ",str$(pomiscid)
	endif
	read record #ch_misc,pomiscid;misc.;
	if p9$[17,17]="Y" or p9$[17,17]="M"
		ch_glm = OpenFile(-176,intCo) \ If ch_glm = -1 Error 42 !
	endif
	Clear List$[]
	List$[0]=bsdel$,"POMiscInfo",fdel$
	WebStr$="POMISCID",fdel$,"POMiscDESC",fdel$,"DistChrg",fdel$
	WEBSTR$=WEBSTR$,"DFLTGLACCTID",FDEL$,"DFLTGLDESC",FDEL$,"GLFLAG",FDEL$
        List$[1]=WebStr$
	if returnstatus<>0
		Webstr$=str$(pomiscid),fdel$
		WebStr$ = WebStr$ + RTrim$(misc.desc$),fdel$ ! pomisc name
		let tmp$="N"
		if misc.DistChrg=1 let tmp$="Y"
		if misc.DistChrg=2 let tmp$="H"
		webstr$=webstr$+tmp$+fdel$
		let tmp$=""
		if p9$[17,17]="Y" or p9$[17,17]="M"
			let webstr$=webstr$+str$(misc.DefaultGL),fdel$
			let glname$=""
			if misc.DefaultGl<>0
				let keyglm$=" ",keyglm$
				let keyglm$[2,9]=misc.DefaultGl using "########"
				glname$ = getglname$(ch_glm,keyglm$,intco)
			endif
			webstr$=webstr$+rtrim$(glname$),fdel$ !gl description
			let tmp$="Y"
			let webstr$=webstr$,tmp$,fdel$

		else
			let webstr$=webstr$,tmp$,fdel$ ! gl acct #
			let webstr$=webstr$,tmp$,fdel$ ! gl description
			let webstr$=webstr$,"N",fdel$ ! gl flag
		endif
		let list$[2]=webstr$
	endif
    	call AddToStr(e$,rstr$,List$[])          
	Call AddToStr(e$,rstr$,esdel$) ! end of section  ! gl
	clear list$[]
	List$[0]=bsdel$,"POMiscWhGl",fdel$
	WebStr$="WhId",fdel$,"WhseName",fdel$
	WEBSTR$=WEBSTR$,"GLAcctId",FDEL$,"GLAcctName",FDEL$
        List$[1]=WebStr$
	if returnstatus<>0
		if p9$[17,17]="Y" or p9$[17,17]="M"
			mat read #ch_misc,pomiscid,30;whsegl;
			let row=2
			let tmpcnt=maxcnt ! 2000
			for rec=1 to 99
				read record #ch_wh,(rec-1),0;wh.;
				if rtrim$(wh.WhName$)<>""
					webstr$=""
					webstr$=str$(rec),fdel$
					webstr$=webstr$,rtrim$(wh.whname$),fdel$
					if not(whsegl[rec])
						webstr$=webstr$+"0"+fdel$
						webstr$=webstr$+"Default"+fdel$
					else
						let keyglm$=" ",keyglm$
						let keyglm$[2,9]=whsegl[rec] using "########"
						glname$ = getglname$(ch_glm,keyglm$,intco)
						webstr$=webstr$+str$(whsegl[rec]),fdel$
						webstr$=webstr$+rtrim$(glname$),fdel$
					endif
					let list$[row]=webstr$
					let row=row+1
					If row > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
				endif		
			next rec
		endif
	endif
	Call AddToStr(e$,rstr$,List$[])    
	Call AddToStr(e$,rstr$,esdel$) 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! get pomisc
!----------------------------------------------------------------------------------------------


!===========================================================================
Sub submitpomisc()! 
 Try
	dim 1%,pomiscid
	dim 1%,poglflag
	dim glname$[22],keyglm$[12]
	dim 3%,rec,glrec,whsegl[99]
	Try Close #ch_misc Else Rem
	ch_misc=OpenFile(9949,intCo) \ If Ch_misc = -1 Error 42 !pomisc codes
	ReturnStatus=1
	Message$="OK"
	MAT  READ #ctlc,51,88;POGLFLAG;
	if not(poglflag) let p9$[17,17]="N"
	Call Dxget("POMISCID",tmp$)
	let pomiscid=tmp$
	if pomiscid<=0 or pomiscid>999
		let returnstatus=0
		let message$="Invalid Purchase Order Miscellenouse Charge Code ",str$(pomiscid)
	endif
	read record #ch_misc,pomiscid;misc.;
	if p9$[17,17]="Y" or p9$[17,17]="M"
		ch_glm = OpenFile(-176,intCo) \ If ch_glm = -1 Error 42 !
	endif
	Call Dxget("UPDATETYPE",tmp$)
	IF UCASE$(RTRIM$(TMP$))="D" ! delete the transaction
		clear misc.
		write record #ch_misc,pomiscid;misc.;
		let Message$="Purchase Order Misc Charge Code Deleted"
		goto endsubmitpomisc:
	endif
	if ucase$(rtrim$(tmp$))="A" ! adding new transaction
		clear misc.
		misc.reason$=pomiscid using "###"
	endif
	Call Dxget("POMISCDESC",tmp$)
	misc.desc$=tmp$+blank$
	if rtrim$(misc.desc$)=""
		returnstatus=0
		let message$="Description Needs to Be Entered"
		goto endsubmitpomisc:
	endif
	Call Dxget("DISTCHRG",tmp$)
	misc.DistChrg=0
	if ucase$(rtrim$(tmp$))="Y" let misc.distchrg=1
	if ucase$(rtrim$(tmp$))="H" let misc.distchrg=2
	if p9$[17,17]="M" or p9$[17,17]="Y"
		Call dxget ("DFLTGLACCTID",tmp$)
		let misc.DefaultGL=tmp$
		if not(misc.DefaultGl)
			let message$="G/L Account Number Must Be Entered."
			let returnstatus=0
			goto endsubmitpomisc:
		endif
		if misc.DefaultGl<>0
			let keyglm$=" ",keyglm$
			let keyglm$[2,9]=misc.DefaultGl using "########"
			search #ch_glm,2,1;keyglm$,glrec,e
			if e<>0
				let message$="G/L Account Number "+str$(misc.DefaultGl)+" Not on File."
				let returnstatus=0
				goto endsubmitpomisc:
			endif
		endif
		Call Dxget("TOTREC",tmp$)
		let totrec=tmp$
		if totrec<0 or totrec>99
			let message$="Invalid Number of Warehouses for General Account Submitted."
			let returnstatus=0
			goto endsubmitpomisc:
		endif
		if totrec>0
			mat read #ch_misc,pomiscid,30;whsegl;
			for rec=1 to totrec
				Call dxget("WHID" + Str$(REC),tmp$)
				let wh=tmp$
				if wh<1 or wh>99
					let message$="Invalid Warehouse Number Submitted"
					let returnstatus=0
					goto endsubmitpomisc:
				endif
				CALL dxget ("GLACCTID"+STR$(REC),tmp$)
				let whsegl[wh]=tmp$
				if whsegl[wh]<>0
					let keyglm$=" ",keyglm$
					let keyglm$[2,9]=whsegl[wh] using "########"
					search #ch_glm,2,1;keyglm$,glrec,e
					if e<>0
						let message$="G/L Account Number "+str$(misc.DefaultGl)+" For Warehouse "+str$(wh)+" Not on File."
						let returnstatus=0
						goto endsubmitpomisc:
					endif
				endif
			next rec
		endif ! endif totrec
	endif ! gl flag
	write record #ch_misc,pomiscid;misc.;
	if p9$[17,17]="M" or p9$[17,17]="Y"
		whsegl[0]=MISC.DEFAULTGL
		mat write #ch_misc,pomiscid,30;whsegl;
	endif
	endsubmitpomisc: ! end of pomisc submit
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! submitpomisc

!--------------------------------------------------------------------
!--------------------------------------------------------------------------------
Sub verifystat()
! verify status on save data 
! header record needs to read first
  Try
	
	if returnstatus<>1
		goto endverifystat: ! already has error
	endif
	Call dxget("SOURCE",tmp$)
	let tmp3=tmp$
	if tmp3=370 goto endverifystat: ! inquiry
	if tmp3=361 or tmp3=369 ! po edit or auto po create
		if poh.status<>94
			let returnstatus=99
			let message$="Purchase Order is not longer in an edit status. Data is not saved. "
		endif
		goto endverifystat:
	endif
	if tmp3=371 ! receipts to stock
		if poh.status<>96
			let returnstatus=99
			let message$="Purchase Order is no longer in receipts to stock edit status. Data is not saved. "
		endif
		goto endverifystat:
	endif
	If tmp3=381 
		if poh.status<>97
			let returnstatus=99
			let message$="Purchase Order is no longer in debit memo edit status. Data is not saved. "
		endif
		goto endverifystat:
	endif
	if poh.status<95 or poh.status>97 
		let returnstatus=99
		let message$="Purchase Order is no longer in an edit status. Data is not saved. "
	endif
	endverifystat: ! end the status check
		

	! status section
	e$=""
	!
	!  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	!  call AddToStr(e$,rstr$,WebStr$)
	!  call SetOutPut(e$,rstr$)
  else
    include "src/callsuberr.inc"
 end try
end sub ! verifystat
! ====== porcvdlnlist
!!! po line list 
Sub PoRcvdLnList()  
!! this get a list of po lines  !!
try
	Dim vend$[6],xdate$[10],PMASK$[20]
	dim keyploc$[50],PLOC$[18]                  
	dim 1%,ch_prodloc,pl1[1]
	dim 2%,Q0[1]
	dim 3%,qty,cost,amount,baseqty,cnvta,rec_prodloc
	Ch_prodloc = OpenFile(-208,intCo) \ If ch_prodloc = -1 Error 42
	returnstatus=1
	let message$="OK"
	tmp$="#",tmp$
	If q0[1]<=0 Let Q0[1]=2
	IF Q0[1]>=4 LET Q0[1]=4
	If Q0[1] Let Pmask$="-----------#.",tmp$[1,Q0[1]]     !price mask
	call dxget ("poid",tmp$) !
	let poid=tmp$
	call dxget ("vendid",tmp$)
	let vendid=tmp$
	clear poh.
	call initpoh()
	if vendid>0
		let keypoh$=" ",keypoh$
		let keypoh$[1,6]=vendid using "######"
		let keypoh$[7,12]=poid using "######"
		search #ch_poh,2,2;keypoh$,rec_poh,e
		if e<>0
			let returnstatus=0
			let message$="Po Number "+str$(poid)+ "Not Found "
		else
			read record #ch_poh,rec_poh;poh.;
			if poh.type=1 or poh.type=4
				let message$="Po Number "+str$(poid)+" is a direct "
				let returnstatus=0
			endif
		endif
	else
		let keypoh$=" ",keypoh$
		let keypoh$[1,2]=" 1"
		let keypoh$[3,8]=poid using "######"
		for ctr=1 to 7   ! "task#46046 - label print - allow status 1-7 to print.
			let keypoh$[1,2]=ctr using "##"
			search #ch_poh,2,1;keypoh$,rec_poh,e
			if not(e)
				read record #ch_poh,rec_poh;poh.;
				if poh.type=1 or poh.type=4
					let message$="Po Number "+str$(poid)+" is a direct "
					let returnstatus=0
					goto endporfind:
				endif
				goto porlblfnd:
			endif
		next ctr
		!!task46046 -remmed out following code toallow print of status 6 & 7 
		!let keypoh$[1,2]=" 6"
		!let keypoh$[3,8]=poid using "######"
		!search #ch_poh,2,1;keypoh$,rec_poh,e
		!if not(e)
			!let message$="Po Number "+str$(poid)+" Receiving Journal Accepted"
			!let returnstatus=0
			!goto endporfind:
		!endif
		!let keypoh$[1,2]=" 7"
		!let keypoh$[3,8]=poid using "######"
		!search #ch_poh,2,1;keypoh$,rec_poh,e
		!if not(e)
			!let message$="Po Number "+str$(poid)+" Closed."
			!let returnstatus=0
			!goto endporfind:
		!endif

		let returnstatus=0
		let message$="Po Number "+str$(poid)+ " Not On File"
		goto endporfind: ! po was found
	endif
	porlblfnd: ! po found for label
	Call DXGet("WHSE",TMP$) 
	let whse=tmp$
	! need to get the po line
	let vendid=poh.vendorcode
	call verifyvendor()	
	endporfind: ! no po found
	clear list$[]
	list$[0]= bsdel$,"BuyVend",fdel$
	webstr$ = "ID",fdel$                               
	webstr$ = webstr$,"Name",fdel$                     
	webstr$ = webstr$,"Contact",fdel$                  
    webstr$ = webstr$,"Address",fdel$                  
    webstr$ = webstr$,"Address 2",fdel$                
    webstr$ = webstr$,"City",fdel$                     
	webstr$ = webstr$,"State",fdel$                    
    webstr$ = webstr$,"Zip",fdel$                                      
    List$[1] = webstr$
	row=2
	if returnstatus>0
		webstr$ = (vend.vendorcode Using "######"),fdel$   
		webstr$ = webstr$,vend.name$,fdel$                 
		webstr$ = webstr$,vend.contact$,fdel$              
		webstr$ = webstr$,vend.address$,fdel$              
		webstr$ = webstr$,vend.optaddress$,fdel$           
		webstr$ = webstr$,vend.city$,fdel$                 
		webstr$ = webstr$,vend.state$,fdel$                
		webstr$ = webstr$,vend.zip$,fdel$                       
		list$[2]=webstr$
		row=row+1
	endif
	List$[row]=esdel$
	call AddToStr(e$,rstr$,List$[]) ! mtg
	! section 2
	Clear List$[]                                                         
	List$[0] = bsdel$ + "POHShipInfo" + fdel$ ! section name
	webstr$="VendId",fdel$
	webstr$=webstr$,"poId",fdel$
	webstr$=webstr$,"ShipName",fdel$
	webstr$=webstr$,"ShipAddr1",fdel$
	webstr$=webstr$,"ShipAddr2",fdel$
	webstr$=webstr$,"ShipCity",fdel$
	webstr$=webstr$,"ShipState",fdel$
	webstr$=webstr$,"ShipZip",fdel$
	let list$[1]=webstr$
	let row=2
	if returnstatus>0 and returnstatus<99! no errors send over the data
		webstr$=str$(poh.vendorcode),fdel$
		webstr$=webstr$,str$(poh.purchaseorder),fdel$
		webstr$=webstr$,poh.ShipToName$,fdel$
		webstr$=webstr$,poh.Address1$,fdel$                       
		webstr$=webstr$,poh.Address2$,fdel$                          
		webstr$=webstr$,poh.city$,fdel$
		webstr$=webstr$,poh.state$,fdel$
		webstr$=webstr$,poh.zipcode$,fdel$	
		let list$[row]=webstr$
		let row=row+1
	endif
	List$[row]=esdel$
	
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	
    
	clear List$[]

	List$[0]=bsdel$,"PoLineList",fdel$
	WebStr$="Line",fdel$
	WebStr$=WebStr$,"ProdID",fdel$
	Webstr$=webstr$,"Description",fdel$
	webstr$=webstr$,"Description2",fdel$
	Webstr$=Webstr$,"Pack Size",fdel$
	Webstr$=webstr$,"Primary Location",fdel$
	Webstr$=Webstr$,"Qty Open",fdel$
	WebStr$=WebStr$,"Qty Recvd",fdel$
	Webstr$=webstr$,"UM",fdel$
	Webstr$=webstr$,"Label",fdel$
	
	
	List$[1]=WebStr$
	row=2
	let tmpcnt=maxcnt
	keypol$=" ",keypol$
	keypol$[1,6]=poid using "######"  ! starts with poid
	mode$=">" ! search mode 3
	dir=1	
	Do
		Rec_pol=filegetpoline(e$,ch_pol,mode$,dir,keypol$,pol.)
		If Rec_pol<0   Exit Do
		let tmp3=keypol$[1,6]\if tmp3<>poid Exit Do
		LET X2=pol.flags ! ! REM UNPACK pol.Flags TO FLAGS[x] 
	        FOR K=0 TO 11                     
		   LET FLAGS[K]=SGN(FRA(X2/2)) \ LET X2=INT(X2/2) 
		NEXT K
		! If flags[0]<>0 goto nxtrcvdline: ! nonstock
		if flags[2]<>0 goto nxtrcvdline: ! not a message line
		if whse<>0 
			if whse<>pol.whse goto nxtrcvdline:
		endif
		WebStr$=(pol.ItemNo using "###"),fdel$ ! po line #
		Webstr$=webstr$,rtrim$(pol.ProdCode$),fdel$ ! product code
		Webstr$=webstr$,rtrim$(pol.Desc1$),fdel$ ! description
		Webstr$=webstr$,rtrim$(pol.Desc2$),fdel$ ! description
		if not(flags[0]) ! product line
			let rec_prod=pol.ProdDescRec
			read record #ch_prod,rec_prod;prod.;			
		endif
		if flags[0]<>0 ! nonstock item
				let rec_nstk=pol.ProdDescRec
				read record #ch_nstk,rec_nstk;nstk.;
				clear prod.                                                           
				prod.baseum=nstk.BaseUM ! nsd1[2]
				prod.um2=nstk.CostUM !    nsd1[3]
				prod.um3=nstk.PurchUM !nsd1[4]
				prod.um4=nstk.StockUM !nsd1[5]
				prod.UMStkDefault = nstk.StockUM ! NSD1[5]
				prod.UMPurchDefault=nstk.PurchUM ! NSD1[4]
				prod.UMCostDefault= nstk.CostUM  ! NSD1[3]
				prod.UM2Fact=nstk.CostFact !nsd3[3]
				prod.UM3Fact=nstk.POFact !nsd3[4]
				prod.UM4Fact=nstk.StkFact !nsd3[5]                                             
				prod.LbsFact=nstk.WgtFact !NSD3[7]
				prod.LbsUnit=nstk.Wgt  !NSD3[6]  
		endif
		Webstr$=webstr$,rtrim$(prod.packsize$),fdel$ ! description
		! primary location	
		let tmp$=""
		let keyploc$=" ",keyploc$
		let keyploc$[1,12]=rtrim$(pol.ProdCode$)+blank$
		let keyploc$[13,14]=pol.whse using "##"
		Do
			if flags[0]<>0 exit do ! nonstock line
			Search #ch_prodloc,3,1;keyploc$,rec_prodloc,e
			if e<>0 exit do
			if keyploc$[1,12]<>pol.prodcode$[1,12] exit do
			let tmp3=keyploc$[13,14]
			if tmp3<>pol.whse exit do
			mat read #ch_prodloc,rec_prodloc,18;pl1;
			if pl1[1]<>0
				mat read #ch_prodloc,rec_prodloc,0;ploc$;
				let tmp$=ploc$[13,18]
				exit do
			endif
		loop
        let webstr$=webstr$,rtrim$(tmp$),fdel$ 
		! quantity opened
		let baseqty=pol.qtyship+pol.freegoods-pol.totfreeqtyrcvd
		if baseqty<0 let baseqty=0
		let amount=0
		if baseqty<>0
			CNVTU[0] = 0;CNVTU[1] = prod.UMPurchDefault;CNVTU[2] = 1         
			CNVTA = baseqty                                          
			Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PRod.)
		endif
		let webstr$=Webstr$,(amount using "########.##"),fdel$ ! received unit of measure
		! quantity received
		let baseqty=pol.CurrQtyRcvd
		let amount=0
		if baseqty<>0
			CNVTU[0] = 0;CNVTU[1] = prod.UMPurchDefault;CNVTU[2] = 1         
			CNVTA = baseqty                                          
			Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PRod.)
		endif
		let webstr$=Webstr$,(amount using "########.##"),fdel$ ! received unit of measure
		tmp$ = XUnit$(prod.UMPurchDefault,Ch_Ccode)
		
		let webstr$=Webstr$,rtrim$(tmp$),fdel$! qty	unit of measure
		let tmp3=0
		if amount<>0
			let tmp3=int(amount+.9) ! need to get to highest um
		endif
		let webstr$=webstr$,(tmp3 using "########"),fdel$ ! labels

		List$[row]=WebStr$
		row=row+1
		if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
		nxtrcvdline: ! nxtrcvdline
	Loop ! PO'S for customers
	let list$[row]=esdel$ ! end section
else
	! this is a remark
end try
end sub ! porcvdlinelist


!!! --- end po line list


!--------------------------------------------------------------------
sub SubmitRtsLbl()
! lines are being sent back to PM
! changed to 1 at a time (as user leaves line - save it!)
 Try
	Dim pOLKey$[60],filename$[50]
	let filename$="serp378zpl.dl4"
	Call FindF(filename$,a9)
	If not(a9)
		let returnstatus=0
		let message$="Label Print is Not Available.  Need Label Forms installed."
		goto endsubrtslbl
	endif
	call dxget("PRINTER",tmp$) \ i = tmp$
	if not(i)
		ReturnStatus=0
		Message$="Invalid printer selected for receiving labels"
		goto endsubrtslbl
	end if
	i = OpenPrinter(e$,0)
	Call DXGet("POID",tmp$)
	If tmp$="" goto endsubrtslbl
	PONo=tmp$
	If PONo<1 or PONo>999999 or Fra(PONo)
		ReturnStatus=0
		Message$="PURCHASE ORDER "+STR$(PONO)+" NUMBER INVALID"
		Goto endsubrtslbl
	Endif

	Call DXGet("TTLLNS",tmp$) ! number of lines sent
	let numlines=tmp$
	If numlines<0 or NumLines>999
		let returnstatus=0
		Message$="PURCHASE ORDER "+STR$(PONO)+" Invalid Number of Line to Update"
		goto endsubrtslbl ! cant update
	endif
	if numlines=0 ! no lines
		goto endsubrtslbl
	endif
	returnstatus=1 ! no error
	let eflag=0
	Message$="" ! in case issues in loop
	let message$="PO "+str$(poid)
	For lctr=1 to NumLines ! this is the loop 
		Call DXGet("LINENUMBER"+str$(lctr),tmp$) ! +Str$(X1),tmp$)
		LineNo=tmp$ ! line # (zero on new lines)
		if LineNo>0
			polkey$=" ",polkey$
			polkey$[1,6]=PONo Using "######"
			Polkey$[7,9]=lineno using "###"
			polkey$[10]="" ! cut to length (space @ 10)
			rec_pol=filegetpoline(e$,ch_pol,"=",1,polkey$,pol.)
			if rec_pol<=0 ! what do we do if not found?
				clear pol.
				let eflag=eflag+1
				let message$=" Line "+str$(lineno)+" Not On File. "
				if eflag>4 goto endsubrtslbl:
				goto nextrtslbl: 
			endif
			! flag for non-stock item in logic               
			X2 = pol.flags ! ! REM UNPACK pol.Flags TO FLAGS[
			For K = 0 To 11                                  
				flags[K] = Sgn(Fra(X2 / 2)) \ X2 = Int(X2 / 2) 
			Next K                                           
			NonStk = flags[0]                                
			ClosedShort = flags[1]                                
			ZLine = flags[2]
			if zline<>0
				let eflag=eflag+1
				let message$=" Line "+str$(lineno)+" is a message line. "
				if eflag>4 goto endsubrtslbl:
				goto nextrtslbl: 
			endif
			call dxget("LABEL"+str$(lctr),tmp$)
			let lblnum=tmp$
			if lblnum>0
				! call pono, lineno, lblnum, errflag, errmsg$
				errtype=0
				msg$=""
				call "serp378zpl.dl4",pono, lineno, lblnum, e$,IntCo,rstr$,errtype, msg$
				! error in call mtg
				if errtype<>0
					returnstatus=0
					let message$=msg$
					goto endsubrtslbl:
				endif
			endif
		endif		
		nextrtslbl: ! get 	
	Next lctr ! process next line sent (was for multiple
	try close #0 else rem
	endsubrtslbl: ! end of the line
	
	
	
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
 else
    include "src/callsuberr.inc"
 end try
end sub ! submitrtslbl


!--------------------------------------------------------------------
sub initpoh()
! lines are being sent back to PM
! changed to 1 at a time (as user leaves line - save it!)
 Try
	poh.VendorRef$=blank$    
	poh.ShipVia$=blank$      
	poh.Routing$=blank$      
	poh.Terms$=blank$        
	poh.FOB$=blank$          
	poh.ConfirmName$=blank$  
	poh.ApInvoice$=blank$    
	poh.ShipToName$=blank$   
	poh.Address1$=blank$     
	poh.Address2$=blank$     
	poh.City$=blank$         
	poh.State$=blank$        
	poh.ZipCode$=blank$      
	poh.EdiStatus$=blank$    
	poh.ShipToCountry$=blank$
	poh.Broker$=blank$       
	poh.MadeIn$=blank$       
	poh.Shipmark$=blank$     
	poh.Spare1$=blank$       
	poh.FreightCode$=blank$  
	poh.Spare2$=blank$  
else
    include "src/callsuberr.inc"
 end try
end sub ! initpoh
!--------------------------------------------------------------------
Sub CalcImpLineTot()
! need qty
! bring extended amount to costing unit of measure factors

! need the product file, need the poline, need the po header
Try
	dim 2%,cfee[2],poins,ofrate
	dim 3%,bcdamt,bbrate,tlandcost
	Dim 3%,CNVTA,Amount,rec_poh
	dim 3%,impqty,impcube,rec_pobr
	dim qtyum$[4],costum$[4],keybr$[6]
	DIM 3%,NETCOST,LANDCOST! need calc for impqty
	let impqty=0
	let impqty=pol.QtyShip
	if not(impqty) let impqty=pol.QtyOrd
	if source=371 let impqty=pol.CurrQtyRcvd
	if closed<>0 let impqty=QtyRcvdToDate
	! need calc for impcube
	let impcube=pol.ExtCubes
	if pol.CbfUnit<>0 and pol.CbfFactor <>0
		IMPCUBE=FNR(IMPQTY*pol.CbfUnit/pol.CbfFactor) 
	endif
   	 LET NETCOST=FNR(IMPQTY*pol.netcost)
	! need calc for netcost
	if (closed) exit sub
	! ocean freight calculation (pl5[0])
	if pol.OceanFrtRec<>-100
		let pol.ExtdOceanFrt=0;ofrate=0
		if pol.OceanFrtRec<>0
			Read Record #ch_poof,pol.OceanFrtRec;poof.;
			let ofrate=poof.CubicFt
			let pol.ExtdOceanFrt=FNR(IMPCUBE*OFRATE) 
		endif	
	else
		let ofrate=0
		if pol.ExtdOceanFrt<>0
			if impcube<>0
				let ofrate=(pol.ExtdOceanFrt/IMPCUBE)
			endif
		endif
	endif                     
  	! Custom Duty (pl5[1])
	LET pol.ExtdDuty=0
	if pol.DutyTypeRec<0 OR pol.DutyTypeRec>999
		let pol.DutyTypeRec=0
	endif
	if pol.DutyTypeRec>0
		Read Record #ch_pocd,pol.DutyTypeRec;pocd.;
	else
		clear pocd.
	endif
	if POCD.Cdtype=1 ! percentage	                                            
  		LET pol.ExtdDuty=FNR(NETCOST*pocd.DutyAmount/100)                       
	ELSE                                                      
  		LET CNVTA=POCD.DutyAmount;CNVTU[0]=prod.UMPurchDefault;CNVTU[1]=0;CNVTU[2]=2 
		If CNVTA <> 0       
			if p61$[136,136]="Y" and pol.currfact<>0 ! going from costing um to base
				let cnvcu[0]=2
				let cnvca[0]=pol.extdduty
				let cnvca[1]=pol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let cnvta=cnvca[0]
			endif
			amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,prod.)                                                         
  			LET BCDAMT=AMOUNT                                       
  			LET pol.ExtdDuty=FNR(AMOUNT*IMPQTY)  
		ENDIF
	ENDIF                                                     
	! Extended Broker Fee (pl5[2])
	pol.ExtdBrokerFee=0
	let keybr$=" ",keybr$;keybr$[1,5]=poh.broker$
	clear pobr.
	search #ch_pobr,2,1;keybr$,rec_pobr,e
	if not(e)
		read record #ch_pobr,rec_pobr;pobr.;
		IF pobr.RateType=0  ! dollar amount                                                  
  			LET CNVTA=pobr.Rate;CNVTU[0]=prod.UMPurchDefault;CNVTU[1]=0;CNVTU[2]=2     
  			amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,prod.)  
			if p61$[136,136]="Y" and pol.currfact<>0 ! going from base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=pol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=cnvca[0]
			endif
  			LET BBRATE=AMOUNT                                           
		ELSE                                                          
  			LET BBRATE=pobr.rate                                            
		ENDIF                                                         
		IF pobr.RateType=0 let pol.ExtdBrokerFee=FNR(BBRATE*IMPQTY)                     
		IF pobr.RateType=1 LET pol.ExtdBrokerFee=FNR(NETCOST*BBRATE/100)  
	endif  
	for ctr=0 to 2\let cfee[ctr]=0\next ctr
	IF POH.TYPE<>5 ! IMPORT DIRECT
	   MAT  READ #ctlc,32,4;CFEE;
	ENDIF
	! Extended Cart iN (pl5[3])
	LET POL.EXTDCARTGIN=0
	IF CFEE[0]<>0                            
  		LET CNVTA=CFEE[0];CNVTU[0]=prod.UMStkDefault;CNVTU[1]=0;CNVTU[2]=2  
 		amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,prod.)  
		if p61$[136,136]="Y" and pol.currfact<>0 ! going from base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=pol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=cnvca[0]
			endif
  		POL.EXTDCARTGIN=FNR(AMOUNT*IMPQTY)                          
        endif
	! Extended Whse Load (pl5[4])
	let pol.ExtdWhseLoad=0
	if cfee[1]<>0 
		LET CNVTA=CFEE[1];CNVTU[0]=prod.UMStkDefault;CNVTU[1]=0;CNVTU[2]=2  
 		amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,prod.) 
		if p61$[136,136]="Y" and pol.currfact<>0 ! going from base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=pol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=cnvca[0]
			endif
  		POL.ExtdWhseLoad =FNR(AMOUNT*IMPQTY)  
	endif
	! Extended Cart Out (pl5[5])
	let pol.ExtdCartgOut=0
        if cfee[2]<>0
		LET CNVTA=CFEE[2];CNVTU[0]=prod.UMStkDefault;CNVTU[1]=0;CNVTU[2]=2  
 		amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,prod.)  
		if p61$[136,136]="Y" and pol.currfact<>0 ! going from base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=pol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=cnvca[0]
			endif
  		POL.ExtdCartgOut=FNR(AMOUNT*IMPQTY)  
	endif 
	! ExtdInsurance (pl5[6])  
	let pol.ExtdInsurance=0                             
        READ #CTLC,32,24;POINS;
	IF POINS<>0  
		let pol.ExtdInsurance=FNR(POINS*NETCOST/100)
	endif
	! 
	LET TLANDCOST=NETCOST  
	LET TLANDCOST=TLANDCOST+pol.ExtdOceanFrt 
	LET TLANDCOST=TLANDCOST+pol.ExtdDuty     
	LET TLANDCOST=TLANDCOST+pol.ExtdBrokerFee
	LET TLANDCOST=TLANDCOST+pol.ExtdCartgIn  
	LET TLANDCOST=TLANDCOST+pol.ExtdWhseLoad 
	LET TLANDCOST=TLANDCOST+pol.ExtdCartgOut 
	LET TLANDCOST=TLANDCOST+pol.ExtdInsurance
	LET TLANDCOST=TLANDCOST+pol.AirfareAddOn 
	LET TLANDCOST=TLANDCOST+pol.MiscAddOn    
	LET POL.LandedCost=TLANDCOST 
	if impqty<>0
		LET LANDCOST=TLANDCOST/IMPQTY                                                              
		LET CNVTA=LANDCOST;CNVTU[0]=0;CNVTU[1]=pol.costum;CNVTU[2]=2 
		amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,prod.) 
		if p61$[136,136]="Y" and pol.currfact<>0 ! going from base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=pol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=cnvca[0]
			endif
		LET LANDCOST=AMOUNT 
	else
		let landcost=0
	endif
		
 else
    include "src/callsuberr.inc"
  end try
end sub ! CalcImpLineTot

sub UpdateCPI()
try
	! prod. is set with all info
	! X3 is the adjustment amount
	if not(cpiFlag) exit sub ! no cpi
	! OK line is over or under and closed
	! find the latest open contract
	! for update
	K_CPI$ = " ",K_CPI$
	K_CPI$[1,12] = prod.ProdCode$
	uCPIRec = 0
	jNewestDate = 0
	do
		R_CPI = filegetcpidet(e$,cpidChan,">",2,K_CPI$,cpid.)
		if R_CPI <= 0 exit do
		if K_CPI$[1,12] <> prod.ProdCode$ exit do
		if cpid.PurWhse <> pol.whse goto skipCPIRec ! wrong wh
		if cpid.ResStock <= 0 goto skipCPIRec ! not a res-stock contract
		R_SP = filegetspecprice(e$,spChan,"=",2,K_CPI$,specp.)
		if R_SP <= 0 goto skipCPIRec ! shouldn't happen
		if not(specp.StartDate) goto skipCPIRec ! no start date
		if specp.CancelDate
			tmp$ = specp.CancelDate using "&&&&&&"
			call DateToJulian(1, tmp$)
			if val(tmp$) < JToday goto skipCPIRec ! no longer active
		end if
		! convert reserve stock amount to base
		CNVTA = cpid.ResStock
		CNVTU[0] = specp.UMQty;CNVTU[1] = 0;CNVTU[2] = 1
		baseResStock = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,prod.)
		if baseResStock - specp.QtySinceStart <= 0 goto skipCPIRec ! contract completely sold
		tmp$ = specp.StartDate using "&&&&&&"
		call DateToJulian(1, tmp$)
		if val(tmp$) <= jNewestDate goto skipCPIRec ! not newer than what we have
		! OK - got the newest active contract for this item / WH
		jNewestDate = val(tmp$)
		uCPIRec = R_CPI
		uCPIUM = specp.UMQty
		skipCPIRec:!
	loop
	if not(uCPIRec) exit sub ! contract not found
	! got one - update the contract
	Read record #cpidChan,uCPIRec,0;cpid.
	! convert reserve stock amount to base
	CNVTA = cpid.ResStock
	CNVTU[0] = uCPIUM;CNVTU[1] = 0;CNVTU[2] = 1
	baseResStock = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,prod.)
	baseResStock = baseResStock - X3
	! convert new reserve stock amount back
	CNVTA = baseResStock
	CNVTU[0] = 0;CNVTU[1] = uCPIUM;CNVTU[2] = 1
	cpid.ResStock = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,prod.)
	write record #cpidChan,uCPIRec,0;cpid.;
else
    include "src/callsuberr.inc"
end try
end sub ! UpdateCPI
