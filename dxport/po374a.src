! >>> Program po374a
!
! description Purchase Order Receipts Accept 
!
! loadsave -w -n 100,10 -o prog/dxport/po374a.dl4 src/po374a.src
!
! ERP Scheduler Enabled
!
! --------------  notes for upgrade to rev10 for Walter E Nelson task#27544/27646----------------
!! 1/15/02 rce  cct141900 remove SalesOrder's holdforpo flag p61$[74,74] 34> Hld B/O til PO rcvd  Y
! ------------------------------------------------------------------------------
! 1.0 mm/dd/yyyy change??
!
include "src/copyright.inc"
Rem BEDIT Version: 2.2 OBJECT CODE     Created: DEC 10, 2008  13:48:17
Rem /w2/papermaster/r2005//usr/acct/mary/work/custom/xrev9/po374a.src (univ2) [mary] {51179}
Rem  Copyright (c) 2008 Universal Business Systems, Inc.
Rem    **** ALL CHANGES MUST BE MADE IN SOURCE!!! ****
Rem
Declare Intrinsic Sub DateToJulian,FindF,InpBuf,Logic,String,Time,VerifyDate
Declare Intrinsic Sub dxopen,dxget,dxset,dxclose,dxsave,getglobals
!Option Default Dialect IRIS1
Declare Intrinsic Sub DateToJulian
Declare Intrinsic sub programdump,env
Declare Intrinsic function findchannel
! external libs for subs/functions
External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus
Declare External Function getmsg$,expandarray
External Lib "ubsfunc.dl4"
Declare External Function getuidrec,getuidinfo$,OpenMySQLMirror,openfile
include "src/inc/filecpidet.inc"
include "src/inc/filespecprice.inc"
Include "src/inc/fileinvtrans.inc"
Include "src/inc/sql_prod.inc"
External Lib "invttrans.dl4"
Declare External Sub Maketrans
External Lib "libprodwh.lib"    
Declare External Sub mxwhcreate 
Include "src/inc/filecosthist.inc"
External Lib "libprod.lib"
Declare External Sub mkcosthist
OPTION GOSUB NESTING 16  ! Default is 8
Rem PO374A FROM PO374   P.O. RECEIPTS TO STOCK ACCEPT
Rem  AUTHOR: G.DOSCHER   2/19/81
Rem MOST OF PROGRAM MADE INTO A CALL 2/2001 (CALL DOES 1 PO & RETURNS)-WMB
!FCHAN[0]   =    3    2/SPROD1                 
!FCHAN[1]   =    5    2/A80VM10                
!FCHAN[2]   =    6    3/SPOFLEN1               
!FCHAN[3]   =    7    2/PSERLNO1               
!FCHAN[4]   =    8    3/SPOFLEH1               
!FCHAN[5]   =    9    3/SPOFLEL1               
!FCHAN[6]   =  10    2/SPRODWHSE1              
!FCHAN[7]   =  13    2/ALTVEND1                
!FCHAN[8]   =  14    3/SNSTKDESC1              
!FCHAN[9]   =  16    2/VDPRHIST1               
!FCHAN[10] =  17    3/SPRODLOT1                
!FCHAN[11] =  18    3/SPOLOT1                  
!FCHAN[12] =  -1     *****                     
!FCHAN[13] =  19    4/FIFOLOT1                 
!FCHAN[14] =  20    4/FIFOTRANS1               
!FCHAN[15] =  30    2/POCTFLE1                 
!FCHAN[16] =  31    3/PORFLINE1                
!FCHAN[17] =  15    4/INVTRANS1                
!FCHAN[18] =  29    2/WHINFO1                  
!FCHAN[19] =  21    4/FIFOSPC1                 
!FCHAN[20] =  50    6/GLPOPRONTO or 6/GLPOTEMP 
!FCHAN[21] =  51    6/GLPOCNTRL1               
!FCHAN[22] =  52    4/GLPODETL1  ***** 22 is being used for rol 
!FCHAN[23] =  35    4/NSINVTRANS1
!FCHAN[24] =  44	3/SPOROLL#
!FCHAN[25] =  43	2/PRODROLL# 
!-----------------------------------------------
! PROG_CH
!PROG_CH[0] 3  !product  
!PROG_CH[1] 5  ! vendor
!PROG_CH[2] 6  ! spoflen notes
!PROG_CH[3] 7  ! serial #
!PROG_CH[4] 8  ! pohead
!PROG_CH[5] 9  ! poline
!PROG_CH[6] 10 ! prodwhse
!PROG_CH[7] 13 ! altvend
!PROG_CH[8] 14 ! sntskdesc1
!PROG_CH[9] 16 ! vendpricehist
!PROG_CH[10] 17! sprodlot
!PROG_CH[11] 18! spolot
!PROG_CH[12] 99 
!PROG_CH[13] 19 ! fifolot
!PROG_CH[14] 20 ! fifotrans
!PROG_CH[15] 30 ! poctfle
!PROG_CH[16] 31 ! porfline
!PROG_CH[17] 15 ! invtrans
!PROG_CH[18] 29 ! whinfo
!PROG_CH[19] 0   
!PROG_CH[20] 0   
!PROG_CH[21] 0   
!PROG_CH[22] 98  
!PROG_CH[23] 43  ! PRODROLL
!PROG_CH[24] 44  ! SPOROLL
Try
! If Err 0 Gosub ERR_TRAP
Enter FCHAN[],POHEADREC,POHR,WAREHOUSE,urec,e$,IntCo,rstr$
Dim 1%,MAX_CH
MAX_CH = 25
Rem {begin src/inc/dim.getchan.i}
Dim 1%,CHNL
Dim 3%,CHNLSCR,CHNLFREE
Rem {end dim.getchan.i}
REM dim prodroll                                                    
DIM RL0$[62],2%,RL1[5],3%,RL2[2],RLUSER$[20],KEYRL1$[50],KEYRL2$[50]
REM dim poroll                                                      
DIM POR$[32],1%,POR1[1],3%,POR2[3],KEYPOR1$[50],KEYPOR2$[50]        
DIM PRFLG$[10]   
dim holdpoflag$[1]
dim 3%,plcurrfact,phcurrfact,1%,plcurrid,phcurrid
Dim I$[50],CMD$[50],3%,TMPREC,2%,JRNL,MJRNL,POJRNL
Dim 1%,FL1[2],FL1$[80],2%,FL2[3],3%,FL3[14],FL4[1],CHAN[50]
Dim 1%,MODE,PD1[2],POMISC[2],IMPORT,2%,D3[1],SCRATCH$[80],TMP_CH,PROG_CH[MAX_CH]
Dim 1%,FT1[3],FT1$[72],2%,FT2[3],3%,FT3[3]
Dim FSKEY$[30],1%,FC0[1],3%,FC2[1],SPCOST,PL[5]
Dim 2%,S9[9],FIFL,P60$[50],FLT$[50],3%,FQ9[2],FQTY,FLK$[50],E,R[99]
Dim 2%,WHOS
Dim UM$[4],X9$[8],1%,TRUE,FALSE,SHORT,LOTCNT,NONSTOCK
DIM 2%,X9[10],nsfmcode
Dim 1%,POGLFLAG,WH,CChan[5]
Dim 1%,Z9,OPENLINE,X0,LN,SC,SR,FLAG,P0[1023],3%,NEWCON,AMOUNT
Dim 1%,RASL[5],I,X,K,CPRT,SPO,PCT3[2],PO1[9],CNVTU[9],2%,LTIME,DAYS,DSP,DSP1,C0
Dim 1%,L1[5],LT1[3],X1[9],H4[3],NSD1[7],P1[1],P4,PFU1[20],TYPE,FLAGS[11]
Dim 1%,WH8[23],M0,SN0[1],SN1[2],W1[2],WHSE,PL0[4],2%,D9[5]
Dim 2%,B[24],C1[6],DATE,H0[5],H3[4],H6[4],L2[2],Q2[1],S,S7,NSTAT
Dim 2%,WH7[3],U4[1],SN2[9],PO,CURJDATE,COMP,PCT1[5],POCNTRL,N4
Dim 2%,AV2[6],C4[8],P2[2],T1[4],T5,J,I1[2],NSD2[4],W2[9],W7[12],X2[9]
Dim 2%,MINLEADTIME,PH[4],3%,WHLBS[1],LBRECV,WQTY,WFQTY,WCOST
Dim 3%,C9[4],H5[2],L3[6],LT2[5],R0,R1[15],T2[17],T9[1],C2[7],V4[1],PO3[10]
Dim 3%,H8[4],P3[4],Q3[1],I3,V1[2],VP1[12,3],VP2[12,3],U1,W3[24],X3[9],POH7[2]
Dim 3%,NSD3[9],A1[7],POL1[4],SN3[6],POCOST,POCOST1,A$[156],A4,PL4[23],INVBAL
Dim 3%,TOTGLCOST,INVNO
Dim 3%,FIFOCOST,CURVAL,ONHAND,PFN[1],PL5[9],PL6[10],LANDCOST,PCT2[5],GLCOST
Dim 3%,FCOST,FLAGRF[1],PORFLINE[30],DSP_PL4,PFU2[6],A[33],CNVTA[4],PCT4[1]
Dim 3%,PCT5[11],DISP_COST,DISP_QTY,DISP_EXT,FTRECA,FTRECB
Dim 3%,PCT6[1],1%,PCT7[2],PCT0[2]
Dim 3%,POCFRGT,POCMISC
Dim 3%,BPOCOST[1],EXTFREIGHT,EXTMISC,BFREIGHTCOST,BMISCCOST,BASEPOCOST
Dim 3%,PROD_LBS,PROD_FACT
dim 3%,hold_pocost,hold_avgcost,hold_netcost,hold_lrnetcost          
dim 3%,hold_whpocost,hold_whavgcost,hold_whnetcost,hold_whlrnetcost
Dim 2%,LASTCOST,FREIGHTCOST,3%,MISCCOST,NETPOCOST,EXTCOST,PCT9[4],PCT8[12]
Dim A1$[20],A2$[20],A3$[20],F$[20],L1$[120],Q1$[18],T1$[12],U5$[50]
Dim 3%,PRPARC[3],WHMISC[6],CURROL,CURWGT,ORIGQTY,QTY,LINE_QTY,NEWCOST
Dim AV1$[32],LT$[56],J$[90],J1$[90],P0$[66],P9$[50],P61$[256]
Dim LT1$[6],P1$[6],POL1$[38],K18$[50],SN$[224],SN1$[54],P8$[7],PCT$[12]
Dim SNK$[50],SNK1$[40],SNKE$[40],SNKE1$[50],DATE$[20],LETTER$[1]
Dim 1%,WPF[1024],3%,R6,R7,R9,R10,R13,R16,R17,R18,R31,WHREC
Dim X$[20],DFLTRCVLOC$[6],K30$[30],K$[20],KL$[20],K31$[50]
Dim 1%,FIFOSPECCH[10],FIFOSPEC1[10],FIFOSPEC$[150],2%,FIFOSPEC2[10],3%,FIFOSPEC3[16]
Dim 2%,ARDATE,POSTPER,S0[8],CLIENT
Dim DEV$[20],HM$[30],nextblockid$[8],Message$[600],WebStr$[600],custom_customer$[30]
Dim buttonlist$[5,50],nextlist$[5,100] ! dx error handling variables
Dim tmp$[800],tmp1$[200],blockid$[100],msg$[100]
Dim action$[30],options$[30],userid$[8],3%,fdel$[10],bsdel$[10],esdel$[10],rdel$[10]
Rem dim for glpo temp file
Dim 2%,CLIENT,JRNL,GLT1[1],3%,GLT0[1],REC_GLT,GLACCT,GLAMT,GLTKEY$[50]
Rem dim for glpocntrl variables
Dim 1%,POTYPE
Dim 1%,PRODCAT,CH_GLC,GLC0[3],3%,GLC1[9],GLACCT,REC_GLC,GLCKEY$[50]
Rem dim for glpodetl variables
Dim 2%,GLD[6],GLD$[12],GLD1$[30],GLD2$[2],4%,GLD1,REC_GLD,1%,GLD2[1],3%,GLDTRN
Dim GLDKEY1$[50],GLDKEY2$[50],KEYVEND$[40],VENDNAME$[30]
Dim Blank$[100] \ Blank$=" ",Blank$
Dim K_CPI$[50]
dim 2%,JToday
Dim 3%,R_CPI
Dim 3%
dim cpid. as cpidet
dim specp. as specprice
dim ITR. as invtrans
Dim PCH. as costhist
LET COMP=INTCO
!X2 = Spc(5)
!COMP = Int((X2 - Int(X2 / 16384) * 16384) / 64)
Def FNR(X) = Sgn(X) * (Abs(Int((Abs(X) + .005) * 100) / 100))
Mat Read #1,69,52;DFLTRCVLOC$;
Mat Read #1,3,192;FIFL;
Mat Read #1,3,176;JToday;
Mat Read #1,19,50;P9$;
Mat Read #1,60,50;P60$;
Mat Read #1,61,0;P61$;
Mat Read #1,51,76;SPO;
Mat Read #1,52,60;P8$; \ Mat Read #1,52,0;S0;
Mat Read #1,0,108;ARDATE;
Mat Read #1,51,88;POGLFLAG;
let poglflag=0 ! not being used. please check fchan[22] now being used for rol 
X$ = ARDATE Using "&&&&&&" \ POSTPER = X$[1,4]
FLAGRF = 0
If P61$[22,22] = "Y" Or P61$[22,22] = "L" Let FLAGRF = 1
cpiFlag = 0 \ if p61$[111,111]="Y" cpiFlag = 1
mat read #1,115,60;custom_customer$;
Custom_customer$=UCase$(Trim$(custom_customer$))
Let holdforpo=0
if p61$[74,74]="Y" let holdforpo=99
if custom_customer$="WENELSON" and holdforpo=0 ! incase su flag has not been set
	! cct141900
	x$ = comp using "cntrl/holdforpo#"
	Call FindF(X$,holdforpo)
	! ch_rolnew=22
endif
LET NSFMCODE=0
IF P61$[132,132]="Y"
	MAT READ #1,52,104;NSFMCODE;
	if nsfmcode<0 or nsfmcode>999
		let nsfmcode=0
	endif
endif
Gosub OPEN_FILES
if p61$[104,104]="Y"
	LET CH_ROLLID=PROG_CH[25]
	LET CH_POROLL=PROG_CH[24]
endif
FLAGRF[1] = 0
DATE$ = Tim(8) Using "&&",Tim(9) Using "&&",Tim(10) Using "&&"
DATE = DATE$
Z9 = 0
X2 = DATE \ Gosub L_17820 \ X2 = 0
If X2 Let CURJDATE = X2 Else Gosub L_17600
TRUE = 1 \ FALSE = 0
Mat Read #1,182;MINLEADTIME;
RASL = 0 \ If P9$[41,41] = "Y" Or P9$[41,41] = "W" Let RASL = 9
If Not(RASL) Or DFLTRCVLOC$ = "      " Let DFLTRCVLOC$ = "STOCK "
Mat Read #1,115;D9;
Goto PROCESS_PO
PROCESS_PO: Rem
R1[8] = POHEADREC
OPENLINE = FALSE
Mat Read #PROG_CH[4],R1[8];H0
Mat Read #PROG_CH[4],R1[8],222;H3
Mat Read #PROG_CH[4],R1[8],242;H4
Mat Read #PROG_CH[4],R1[8],330;PO1
Mat Read #PROG_CH[4],R1[8],250;H8
Mat Read #PROG_CH[1],H0[1],0;VENDNAME$;
Mat Read #PROG_CH[1],H0[1],264;C1
Mat Read #PROG_CH[1],H0[1],498;C2
Mat Read #PROG_CH[1],H0[1],448;V4
Mat Read #PROG_CH[4],R1[8],350;PO3
Mat Read #PROG_CH[4],R1[8],310;PH
Mat Read #PROG_CH[4],R1[8],528;POH7
JRNL = 0
If Not(POHR) Let JRNL = POH7[2]
TOTGLCOST = 0
T9[1] = 0
A1$[1,2] = H0[0] Using "##" \ A1$[3] = H0[2] Using "######"
Z9 = Z9 + 1
FLAGRF[1] = 0
K31$ = " ",K31$
K31$[1,6] = A1$[3,8]
K31$[7] = ""
If FLAGRF[0] = 0 Goto L_2155
Search #PROG_CH[16],3,1;K31$,R31,E
If E = 2 Goto L_2155
If E Gosub ERR_SEARCH
If K31$[1,6] <> A1$[3,8] Goto L_2155
Mat Read #PROG_CH[16],R31,0;PORFLINE;
If PORFLINE[1] <> 0 Goto L_2155
FLAGRF[1] = 1
L_2155: A2$ = H0[2] Using "######"
L_2160: Search #PROG_CH[5],3,1;A2$,R9,E \ If E > 2 Gosub ERR_SEARCH
X2 = A2$[1,6] \ If X2 <> H0[2] Let E = 2
If Not(E)
  Gosub L_6000
  If SPO <> 0 And L3[4] <> 0 And POHR <> 0 ! auto receipts to stock accept
    WH = L1[1] - 1 \ If WH < 0 Let WH = 0
    Mat Read #PROG_CH[18],WH,848;N4
    N4 = N4 + 1
    If N4 < 0 Let N4 = 1
    If N4 > 999999 Let N4 = 1
    POCNTRL = N4
    Mat Write #PROG_CH[18],WH,848;N4;
    Mat Write #PROG_CH[5],R9,508;POCNTRL
  End If 
  If Not(JRNL) Or POHR <> 0
    WH = L1[1] - 1 \ If WH < 0 Let WH = 0
    Mat Read #PROG_CH[18],WH,2974;POJRNL;
    If POJRNL <= 0 Let POJRNL = 0
    If POJRNL >= 999999 Let POJRNL = 0
    If Not(POJRNL)
      Read #1,20,166;MJRNL
      If MJRNL <= 0 Let MJRNL = 1
      If MJRNL >= 999999 Let MJRNL = 1
      JRNL = MJRNL
      MJRNL = MJRNL + 1
      Write #1,20,166;MJRNL;
      POJRNL = JRNL
      Write #PROG_CH[18],WH,2974;POJRNL;
    Else 
      JRNL = POJRNL
    End If 
  End If 
  If P8$[7,7] = "W"
    WH = L1[1] - 1 \ If WH < 0 Let WH = 0
    Mat Read #PROG_CH[18],WH,844;CLIENT;
    If Not(CLIENT) Let CLIENT = S0[0]
  Else 
    CLIENT = S0[0]
  End If 
  If FLAGS[2] Goto L_2160
  Gosub L_2800
  POCOST = PL4[0]
  If PL4[16] ! FREE GOODS
    If L3[4] Let POCOST = (((L3[4] - PL4[16]) * PL4[0]) / L3[4])
    If L1[5] < 0 ! "weight based
      WQTY = L3[4];WFQTY = PL4[16];FCOST = PL4[0]
      Gosub CALC_WGT_UNIT
      POCOST = AMOUNT
    End If 
  End If 
  If L3[4] Let BPOCOST[0] = (PL4[7] / L3[4]) Else Let BPOCOST[0] = 0
  BASEPOCOST = BPOCOST[0]
  BPOCOST[1] = BPOCOST[0]
  POCOST1 = POCOST
  BFREIGHTCOST = 0
  If L2[1] <> 0 And L3[4] <> 0
    If P60$[49,49] = "F" Or P60$[49,49] = "B" Or P60$[19,19] = "Y"
      If L1[5] = -2 ! lot cost
        BFREIGHTCOST = L2[1]
      Else 
        EXTFREIGHT = FNR(L3[4] * L2[1])
        If L1[5] = -1 Or L1[5] = -3
          If PL4[13]
            EXTFREIGHT = FNR(L3[4] * (L2[1] * (PL4[12] / PL4[13])))
          End If 
        End If 
        BFREIGHTCOST = (EXTFREIGHT / L3[4])
      End If 
    End If 
  End If 
  If P60$[49,49] = "F" Or P60$[49,49] = "B"
    If L2[1]
      If L1[5] = -1 Or L1[5] = -3
        CNVTA = L2[1]
        If L1[5] = -1 Let CNVTA = (L2[1] * 100)
        CNVTU[0] = L1[5];CNVTU[1] = 0;CNVTU[2] = 2
        Gosub L_20000
        POCOST1 = POCOST1 + AMOUNT
      Else 
        POCOST1 = POCOST1 + L2[1]
      End If 
    End If 
    BPOCOST[1] = BPOCOST[1] + BFREIGHTCOST
  End If 
  If P60$[49,49] = "M" Or P60$[49,49] = "B"
    If PL4[8]
      If L1[5] = -1 Or L1[5] = -3
        CNVTA = PL4[8]
        If L1[5] = -1 Let CNVTA = PL4[8] * 100
        CNVTU[0] = L1[5];CNVTU[1] = 0;CNVTU[2] = 2
        Gosub L_20000
        POCOST1 = POCOST1 + AMOUNT
      Else 
        POCOST1 = POCOST1 + PL4[8]
      End If 
    End If 
    If PL4[8] <> 0 And L3[4] <> 0
      If L1[5] = -2
        BMISCCOST = PL4[8]
      Else 
        EXTMISC = L3[4] * PL4[8]
        If L1[5] = -1 Or L1[5] = -3
          If PL4[13]
            EXTMISC = FNR(L3[4] * (PL4[8] * (PL4[12] / PL4[13])))
          End If 
        End If 
        BMISCCOST = (EXTMISC / L3[4])
      End If 
      BPOCOST[1] = BPOCOST[1] + BMISCCOST
    End If 
  End If 
  If P60$[19,19] = "Y"
    If L2[1]
      If L1[5] = -1 Or L1[5] = -3
        CNVTA = L2[1]
        If L1[5] = -1 Let CNVTA = L2[1] * 100
        CNVTU[0] = L1[5];CNVTU[1] = 0;CNVTU[2] = 2
        Gosub L_20000
        POCOST = POCOST + AMOUNT
      Else 
        POCOST = POCOST + L2[1]
      End If 
    End If 
    BPOCOST[0] = BPOCOST[0] + BFREIGHTCOST
  End If 
  T9[0] = POCOST * (L3[4] - PL4[16])
  T9[1] = T9[1] + T9
  If R1[8] <> L3[0] Print "HEADER RECORD POINTER ERROR" \ Gosub ERR_SEARCH
  Call Logic(1,2 ^ 0,L1[3],NONSTOCK)
  Call Logic(1,2 ^ 1,L1[3],SHORT)
  If L1[0] = 2
    X2 = H0[3] \ Gosub L_17820 \ X2 = 0
    LTIME = CURJDATE - X2
    If LTIME < 0 Let LTIME = 0
    If FLAGRF = 1 And (PL0[4] = 1 Or PL0[4] = 2) Let PL0[4] = PL0[4] + 2
    Gosub L_5000
    DISP_QTY = (L3[4] - PL4[16]);DISP_COST = PL4[0] \ Gosub CALC_DISP_EXT
    NEWCOST = DISP_EXT
    H8[3] = H8[3] + NEWCOST
    PL4[5] = PL4[5] - (L3[4] - PL4[16]) \ If PL4[5] < 0 Let PL4[5] = 0
    If L3[4] Let PL4[22] = DATE;PL4[23] = L3[4]
    L3[3] = L3[3] + L3[4] \ L3[4] = 0
    PL4[17] = PL4[17] + PL4[16];PL4[16] = 0
    PL4[18] = PL4[18] + L2[1];PL4[19] = PL4[19] + PL4[8]
    L2[1] = 0;PL4[8] = 0
    POMISC[1] = Abs(POMISC[1])
    If POMISC[1] = 100 Let POMISC[1] = 0
    If L3[3] >= L3[2] + PL4[1] Or SHORT ! LINE FILLED
      L1[0] = 3
      PL4[0] = L2[0] - (L2[0] * (PL4[2] / 100)) - PL4[3]
      DISP_QTY = L3[3];DISP_COST = PL4[0] \ Gosub CALC_DISP_EXT
      PL4[7] = DISP_EXT
      PL4[5] = 0
    Else 
      L1[0] = 1
    End If 
    If L1[0] = 1
      PL4[5] = L3[2] - (L3[3] - PL4[17]) - PL4[4] \ If PL4[5] < 0 Let PL4[5] = 0
      DISP_QTY = PL4[5];DISP_COST = PL4[0] \ Gosub CALC_DISP_EXT
      PL4[7] = DISP_EXT;PL4[20] = 0;PL4[21] = 0
    End If 
    Gosub L_6100
    Gosub UpdateCPI
  End If 
  If L1[0] <> 3 Let OPENLINE = TRUE
  !if custom_customer$="WENELSON"
	if holdforpo<>0 ! cct141900
		scratch$ = l3[1] using "######"  ! prod rec number
		loop_rolnew: Search #ch_rolnew,3,2;scratch$,r[ch_rolnew],e
		x2 = scratch$[1,6]
		if x2 <>l3[1] or E<>0 goto done_holdforpo:
		Read #ch_rolnew,R[CH_rolnew],403;holdpoflag$;
		if holdpoflag$ = "Y" Write #ch_rolnew,R[CH_rolnew],403;"";
		goto loop_rolnew:
	endif
	done_holdforpo:  !  done with 141900
  ! endif
  Goto L_2160
End If 
NSTAT = 7 \ If OPENLINE Let NSTAT = 4
POH7[0] = POH7[0] + H8[2]
POH7[1] = POH7[1] + TOTGLCOST
If OPENLINE If P60$[36,36] = "Y" Let NSTAT = 1
Gosub L_10090
Gosub L_2600
PH[4] = 0
Write #PROG_CH[4],R1[8],326;PH[4]
H3[0] = DATE
Mat Write #PROG_CH[4],R1[8];H0
Mat Write #PROG_CH[4],R1[8],222;H3
Mat Write #PROG_CH[4],R1[8],250;H8
Mat Write #PROG_CH[4],R1[8],330;PO1
Mat Write #PROG_CH[1],H0[1],498;C2
Mat Write #PROG_CH[1],H0[1],448;V4;
Mat Write #PROG_CH[4],R1[8],350;PO3
Mat Write #PROG_CH[4],R1[8],528;POH7;
K31$ = " ",K31$
K31$[1,6] = A1$[3,8]
K31$[7] = ""
If FLAGRF[0] = 0 Goto L_2590
L_2580: Search #PROG_CH[16],3,1;K31$,R31,E
If E = 2 Goto L_2590
If E Gosub ERR_SEARCH
If K31$[1,6] <> A1$[3,8] Goto L_2590
Search #PROG_CH[16],5,1;K31$,R31,E
If E Gosub ERR_SEARCH
E = 3
Search #PROG_CH[16],1,0;K31$,R31,E
If E Gosub ERR_SEARCH
Goto L_2580
L_2590: Goto OUTEND
Stop 
L_2600: Rem ORDER CHANGE STATUS TO NSTAT
X2 = A1$[1,2] \ If H0[0] <> X2 Print "HEADER STATUS ERROR" \ Gosub ERR_SEARCH
A3$ = A1$
A3$[1,2] = NSTAT Using "##"
If H0[0] <> NSTAT
  R0 = R1[8] 
  ! Check to see if already there
  search #prog_ch[4],2,1;a3$,r0,e
  if not(e) and r0=r1[8] goto delstatkey:  ! already there same record # bypass
  r0=r1[8]
  Search #PROG_CH[4],4,1;A3$,R0,E \ If E Gosub ERR_SEARCH
  delstatkey: ! delete key
  A3$[1,2] = H0[0] Using "##"
  search #prog_ch[4],2,1;a3$,r0,e\if e>1 gosub err_search:
  if not(e) 
	Search #PROG_CH[4],5,1;A3$,R0,E \ If E Gosub ERR_SEARCH
	If R0 <> R1[8] Gosub ERR_SEARCH
  endif
  H0[0] = NSTAT
End If 
Return 
L_2800: Rem GET PRODUCT
If Not(NONSTOCK)
  Gosub L_6200
  HOLD_POCOST=B[10]      
    HOLD_AVGCOST=B[21]     
    HOLD_NETCOST=PRPARC[2] 
Else 
  Gosub L_6500
  For X0 = 0 To 20
    If X0 < 21 Let PFU1[X0] = 0
    If X0 < 4 Let PFU1[X0] = NSD1[X0 + 2]
    If X0 < 7 Let PFU2[X0] = 0
    If X0 < 3 Let PFU2[X0] = NSD3[X0 + 3]
  Next X0
  PL4[12] = NSD3[6];PL4[13] = NSD3[7];PL4[14] = NSD3[2];PL4[15] = NSD3[8]
  PFU1[8] = NSD1[5];PFU1[10] = NSD1[4];PFU1[11] = NSD1[3]
  A[5] = NSD3[7];A[6] = NSD3[6];B[23] = NSD3[2];A1[3] = NSD3[8]
  B[11] = NSD1[1]
End If 
Return 
L_3000: Rem UPDATE LOT FILE
If Not(L3[4]) Goto L_3185
If POL1$[1,6] = "STOCK "
  POL1$[6,7] = L1[1] Using "&&"
End If 
If NONSTOCK<>0
  POL1$[1,7] = L1[1] Using "NSSTK&&"
End If 
If P9$[9,9] <> "N" ! TRANS HIST

  clear itr.
  itr.ProdCode$ = L1$[81,92]                  
  itr.LotNum$ = POL1$[1,12]                
  !itr.SrcCode$[1,3] = "PO#"
  !itr.SrcCode$[4,9] = H0[2] Using "######" 
  itr.srccode$[1,2]="PO"
  itr.srccode$[3,8]=H0[2] Using "######"
  itr.srccode$[9,9]="-"
  itr.srccode$[10,12]= L1[2] using "&&&"
  !itrSrcCode$[12]
  itr.Comment$[1,4]="VEN#" 
  itr.COmment$[5,11] = H3[3] Using " ######"
                 
  itr.TrnsType=1   
  itr.Whse = L1[1]                                       
  itr.EntBy = urec ! Spc(6) !!!! mtg lt1[2]
  itr.Tiebrkr = 0                    
  itr.TrnsDate  = Date                          
  itr.RunInvt  =INVBAL                    
  itr.Qty   = POL1[3]  
  If P60$[43,43] = "Y" ! RTS UPDATE NET P/O - S3
    itr.CostLoad = BPOCOST[1]
  Else 
    itr.CostLoad = BPOCOST[0]
  End If 
  itr.CostAvg  = B[21]                  
  If P9$[32,32] = "Y" And W3[15]<>0
	Let itr.CostAvg = W3[15]
  endif
  itr.NetPrice =0                    
  itr.Loc$ = POL1$[23,28]                  
  If POHR ! pronto accept
	itr.EntBy = urec 
	itr.ProntoAcpt =99 
	! Let LT1[2] = - LT1[2] **** check maketrans -- for negative was pronto accept
  Endif
  If NONSTOCK<>0
    itr.Loc$ = "NSTOCK"
    itr.RunInvt =L1[2] ! LT2[1] = L1[2]  -- running balance for non-stock keeps line # ?
    itr.Qty = l3[4] !LT2[2] = L3[4]
    itr.CostAvg = POCOST ! LT2[4] = POCOST
    HOLDPROGCH17 = PROG_CH[17]
    PROG_CH[17] = ch_nsinvt
  End If 
  If FLAGRF = 1 If FLAGRF[1] = 1 
	! Let LT1[0] = -1 \ LT1[3] = PORFLINE[5] \ LT$[35,36] = "RF"
	itr.RfRcvd = 99 ! ***** let lt1[0]=-1 check maketrans for negative was rf accept
	itr.Tiebrkr = PORFLINE[5] ! ? 
	itr.SrcCode$[11,12] ="RF"   
  endif
  ch_invtr=prog_ch[17]
  Call MakeTrans(e$,IntCo,CH_INVTR,status,itr.) !  as invtrans)
  !Call "MAKETRANS",LT$,LT1[],LT2[],LT1$,PROG_CH[17]
  If NONSTOCK<>0
    PROG_CH[17] = HOLDPROGCH17
  End If 
End If 
L_3185: Return 
L_3200: Rem SPRODLOT
If Not(L3[4]) Goto L_3490
J$ = " ",J$ \ J$[1,22] = POL1$[1,22]
J$[23,24] = L1[1] Using "##";J$[25,30] = POL1$[23,28];J$[31,42] = L1$[81,92]
Search #PROG_CH[10],2,1;J$,R17,E \ If E > 1 Gosub ERR_SEARCH
If E
  P0$ = " ",P0$;P0$[1,12] = L1$[81,92];P0$[13,24] = POL1$[1,12]
  P0$[25,28] = "PO#:" \ P0$[30,35] = H0[2] Using "######"
  P0$[55,64] = POL1$[13,22]
  P1$[1,6] = POL1$[23,28]
  P1[0] = L1[1] \ P1[1] = 1 \ P2[0] = DATE \ P2[1] = 0 \ P2[2] = 0
  For X1 = 0 To 4 \ P3[X1] = 0 \ Next X1
  P4 = 0
  E = 2 \ Search #PROG_CH[10],1,0;J$,R17,E \ If E Gosub ERR_SEARCH
  R0 = R17 \ Search #PROG_CH[10],4,1;J$,R0,E \ If E Gosub ERR_SEARCH
  J$[1,12] = L1$[81,92] \ J$[13,14] = L1[1] Using "##" \ J$[15,20] = POL1$[23,28] \ J$[21,42] = POL1$[1,22]
  R0 = R17 \ Search #PROG_CH[10],4,2;J$,R0,E \ If E Gosub ERR_SEARCH
  J$[1,2] = L1[1] Using "##" \ J$[3,8] = POL1$[23,28] \ J$[9,20] = L1$[81,92] \ J$[21,42] = POL1$[1,22]
  R0 = R17 \ Search #PROG_CH[10],4,3;J$,R0,E \ If E Gosub ERR_SEARCH
  J$[1,12] = L1$[81,92] \ J$[13,14] = L1[1] Using "##" \ J$[15,36] = POL1$[1,22]
  J$[37,42] = POL1$[23,28]
  R0 = R17 \ Search #PROG_CH[10],4,4;J$,R0,E \ If E Gosub ERR_SEARCH
Else 
  Mat Read #PROG_CH[10],R17;P0$
  Mat Read #PROG_CH[10],R17,66;P1
  Mat Read #PROG_CH[10],R17,70;P2
  Mat Read #PROG_CH[10],R17,82;P3
  Mat Read #PROG_CH[10],R17,112;P4
  Mat Read #PROG_CH[10],R17,114;P1$
End If 
P1[1] = 1 \ P2[0] = DATE \ P2[2] = P2[2] + 1
CURVAL = (P3[0] - P3[1]) * P3[2] \ If CURVAL < 0 Let CURVAL = 0
P3[0] = P3[0] + POL1[3];ONHAND = P3[0] - P3[1]
INVBAL = INVBAL + POL1[3]
If IMPORT Let POCOST = LANDCOST
If Not(IMPORT) If P60$[48,48] = "N"
  If ONHAND > 0 If CURVAL > 0 Let P3[2] = (CURVAL + (POL1[3] * POCOST1)) / ONHAND Else Let P3[2] = POCOST1
End If 
If IMPORT Or P60$[48,48] <> "N"
  If ONHAND > 0 If CURVAL > 0 Let P3[2] = (CURVAL + (POL1[3] * POCOST)) / ONHAND Else Let P3[2] = POCOST
End If 
Mat Write #PROG_CH[10],R17;P0$
Mat Write #PROG_CH[10],R17,66;P1
Mat Write #PROG_CH[10],R17,70;P2
Mat Write #PROG_CH[10],R17,82;P3
Mat Write #PROG_CH[10],R17,112;P4
Mat Write #PROG_CH[10],R17,114;P1$;
L_3490: Return 
READ_PRODWHSE: Rem READ PRODWHSE
J$ = " ",J$ \ J$ = L1$[81,92] \ J$[13] = L1[1] Using "##"
Search #PROG_CH[6],2,1;J$,R10,E \ If E Gosub ERR_SEARCH
Mat Read #PROG_CH[6],R10,32;W1
Mat Read #PROG_CH[6],R10,38;W2
Mat Read #PROG_CH[6],R10,78;W3
Mat Read #PROG_CH[6],R10,428;WH7
Mat Read #PROG_CH[6],R10,444;WH8
Mat Read #PROG_CH[6],R10,696;W7
Mat Read #PROG_CH[6],R10,800;WHMISC
Mat Read #PROG_CH[6],R10,980;WHLBS
HOLD_whPOCOST=w3[16]      
HOLD_whAVGCOST=w3[15]     
HOLD_whNETCOST=whmisc[2] 
Return 
L_3500: Rem UPDATE PRODWHSE
Gosub READ_PRODWHSE
INVBAL = W3[0]
If PL0[1]
  W7[1] = W7[0] \ W7[0] = FNR(LTIME / 30)
End If 
W7[10] = WH7[0] \ WH7[0] = DATE
If PL0[1] = 0 Goto L_3630
If W7[1]
  W2[0] = (W7[0] + W7[1]) / 2
Else 
  W2[0] = W7[0]
End If 
If MINLEADTIME And W2[0] < MINLEADTIME Let W2[0] = MINLEADTIME
L_3630: CURVAL = W3[0] * W3[15] \ If CURVAL < 0 Let CURVAL = 0
W3[0] = W3[0] + L3[4]
If A$[127,127] = "Y" Let WHLBS[0] = WHLBS[0] + LBRECV
If Not(SHORT)
  If ((L3[2] + PL4[1]) >= (L3[3] + L3[4])) Let W3[1] = W3[1] - L3[4] Else Let W3[1] = W3[1] - (L3[2] + PL4[1] - L3[3])
Else 
  W3[1] = W3[1] - (L3[2] + PL4[1] - L3[3])
End If 
If Not(L3[4]) Goto L_3672
If P9$[32,32] <> "Y" And L1[5] <> -2 Let W3[15] = B[21] \ Goto L_3657
If IMPORT And L1[5] <> -2 Let BPOCOST[0] = LANDCOST
If (IMPORT Or P60$[48,48] <> "N") And L1[5] <> -2
  If W3[0] > 0 If CURVAL > 0 Let W3[15] = (CURVAL + (L3[4] * BPOCOST[0])) / W3[0] Else Let W3[15] = BPOCOST[0]
End If 
If Not(IMPORT) And P60$[48,48] = "N" And L1[5] <> -2
  If W3[0] > 0 If CURVAL > 0 Let W3[15] = (CURVAL + (L3[4] * BPOCOST[1])) / W3[0] Else Let W3[15] = BPOCOST[1]
End If 
If W3[1] < 0 Let W3[1] = 0
L_3657: If P60$[21,21] <> "N" And L1[5] <> -2
  X2 = W2[3]
  If H3[3] = X2
    W3[16] = LASTCOST
  End If 
End If 
If P60$[43,43] <> "N" And L1[5] <> -2
  WHMISC[2] = (L3[3] + L3[4] - (PL4[16] + PL4[17])) * NETPOCOST / (L3[3] + L3[4])
  If P60$[49,49] = "M" Or P60$[49,49] = "B" Let WHMISC[2] = WHMISC[2] + MISCCOST
  If P60$[49,49] = "F" Or P60$[49,49] = "B" Let WHMISC[2] = WHMISC[2] + FREIGHTCOST
End If 
If IMPORT And P60$[43,43] = "Y" And L1[5] <> -2
  WHMISC[2] = LANDCOST
End If 
Gosub L_7500
L_3672: Mat Write #PROG_CH[6],R10,32;W1
Mat Write #PROG_CH[6],R10,38;W2
Mat Write #PROG_CH[6],R10,78;W3
Mat Write #PROG_CH[6],R10,428;WH7
Mat Write #PROG_CH[6],R10,444;WH8
Mat Write #PROG_CH[6],R10,696;W7
Mat Write #PROG_CH[6],R10,800;WHMISC
Mat Write #PROG_CH[6],R10,980;WHLBS;
if hold_whpocost<>w3[16]            
	LET pch.ctype=3                   
	lET pch.OldCost= hold_whpocost      
	LET pch.NewCost= w3[16]             
	pch.Whse=L1[1]                   
	gosub update_cost_hist: !         
endif                              
if hold_whavgcost<> W3[15]         
	LET pch.ctype=6                     
	lET pch.OldCost= hold_whavgcost     
	LET pch.NewCost=W3[15]                
	pch.Whse=l1[1]                    
	gosub update_cost_hist: !           
endif                              
if hold_whnetcost<>whmisc[2]        
  lET pch.ctype=4                     
  lET pch.OldCost= hold_whnetcost      
  LET pch.NewCost=whmisc[2]            
  pch.Whse=l1[1]                   
  Gosub update_cost_hist: !         
ENDif  
Return 
L_3700: Rem VENDOR LINE
C2[2] = C2[2] + T9
C2[3] = C2[3] + T9
V4[0] = V4[0] + L3[4]
V4[1] = V4[1] + L3[4]
Return 
L_3800: Rem ALTVEND
X2 = B[24] \ If W2[3] Let X2 = W2[3]
If P61$[51,51] = "N" Return 
If H3[3] <> X2 If H3[3] <> B[24]
  J$ = " ",J$ \ J$ = L1$[81,92] \ J$[13] = H3[3] Using "######"
  Search #PROG_CH[7],2,1;J$,R13,E \ If E > 1 Gosub ERR_SEARCH
  If E
    E = 2 \ Search #PROG_CH[7],1,0;J$,R13,E \ If E Gosub ERR_SEARCH
    Search #PROG_CH[7],4,1;J$,R13,E \ If E Gosub ERR_SEARCH
    AV1$ = " ",AV1$ \ AV1$[1,12] = L1$[81,92] \ AV1$[13,32] = L1$[61,80]
    For X1 = 0 To 6 \ AV2[X1] = 0 \ Next X1
  Else 
    Mat Read #PROG_CH[7],R13;AV1$
    Mat Read #PROG_CH[7],R13,32;AV2
  End If 
  AV1$[13,32] = L1$[61,80]
  AV2[0] = H3[3];AV2[1] = H0[3];AV2[2] = L2[0]
  AV2[5] = AV2[4] \ AV2[4] = FNR(LTIME / 30)
  If AV2[5]
    AV2[3] = (AV2[4] + AV2[5]) / 2
  Else 
    AV2[3] = AV2[4]
  End If 
  Mat Write #PROG_CH[7],R13;AV1$
  Mat Write #PROG_CH[7],R13,32;AV2;
End If 
Return 
L_4000: Rem UPDATE PRODUCT FILE
If Not(L3[4]) Goto L_4100
CURVAL = A[0] * B[21] \ If CURVAL < 0 Let CURVAL = 0
ORIGQTY = A[0];A[0] = A[0] + L3[4]
If A$[127,127] = "Y" Let PRPARC[3] = PRPARC[3] + LBRECV
If IMPORT And L1[5] <> -2 Let BPOCOST[0] = LANDCOST
If (IMPORT Or P60$[48,48] <> "N") And L1[5] <> -2
  If A[0] > 0 If CURVAL > 0 Let B[21] = (CURVAL + (L3[4] * BPOCOST[0])) / A[0] Else Let B[21] = BPOCOST[0]
End If 
If Not(IMPORT) And P60$[48,48] = "N" And L1[5] <> -2
  If A[0] > 0 If CURVAL > 0 Let B[21] = (CURVAL + (L3[4] * BPOCOST[1])) / A[0] Else Let B[21] = BPOCOST[1]
End If 
If P9$[11,11] = "Y" And L1[5] <> -2 Let B[8] = B[21]
A[17] = A[17] + L3[4]
A[28] = L3[4]
If P60$[21,21] <> "N" And L1[5] <> -2 ! "last cost flag and po cost u/m <>lot
  X2 = B[24]
  If H3[3] = X2 Or (P9$[32,32] <> "Y" And W2[3] <> 0 And W2[3] = H3[3])
    B[10] = LASTCOST
  End If 
End If 
PFN[0] = POCOST1
If P60$[43,43] <> "N" And L1[5] <> -2 ! "net po cost flag and po cost u/m <>lot
  PRPARC[2] = (L3[3] + L3[4] - (PL4[16] + PL4[17])) * NETPOCOST / (L3[3] + L3[4])
  If P60$[49,49] = "F" Or P60$[49,49] = "B" Let PRPARC[2] = PRPARC[2] + FREIGHTCOST
  If P60$[49,49] = "M" Or P60$[49,49] = "B" Let PRPARC[2] = PRPARC[2] + MISCCOST
End If 
L_4100: Rem
If IMPORT And P60$[43,43] = "Y" And L1[5] <> -2
  PRPARC[2] = LANDCOST
End If 
If Not(SHORT)
  If ((L3[2] + PL4[1]) >= (L3[3] + L3[4])) Let A[2] = A[2] - L3[4] Else Let A[2] = A[2] - (L3[2] + PL4[1] - L3[3])
Else 
  A[2] = A[2] - (L3[2] + PL4[1] - L3[3])
End If 
If A[2] < 0 Let A[2] = 0
If Not(L3[4]) Or PL0[1] = 0 Goto L_4250
C4[6] = C4[5] \ C4[5] = FNR(LTIME / 30)
If C4[6]
  B[0] = (C4[5] + C4[6]) / 2
Else 
  B[0] = C4[5]
End If 
If MINLEADTIME And B[0] < MINLEADTIME Let B[0] = MINLEADTIME
L_4250: If A$[114,114] <> "Y" Or PL4[20] = 0 Or PL4[21] = 0 Goto L_4380
If Not(L3[4]) Goto L_4380
UM$ = "ERR " \ If PFU1[0] > 0 Read #PROG_CH[12],PFU1[0],10;UM$[1,4];
If UM$[1,2] <> "LB" Goto L_4380
For I = 1 To 7 \ UM$ = "ERR "
  If PFU1[I] > 0 Read #PROG_CH[12],PFU1[I],10;UM$[1,4];
  If UM$ = "ROLL" Goto L_4300
Next I
Goto L_4380
L_4300: Rem RECALC ROLL CONVERSION (WEIGHTED AVG ROLL WEIGHT)
CURROL = 0;I = I - 1 \ If I < 0 Goto L_4380
If PFU2[I] Let CURROL = (ORIGQTY / PFU2[I]) \ If CURROL < 0 Let CURROL = 0
CURROL = Int(CURROL + .5)
CURWGT = CURROL * PFU2[I] \ If CURWGT < 0 Let CURWGT = 0
CURROL = CURROL + PL4[20];CURWGT = CURWGT + PL4[21]
NEWCON = PFU2[I] \ If PL4[20] > 0 Let NEWCON = (PL4[21] / PL4[20])
If CURROL > 0 If CURWGT > 0 Let NEWCON = (CURWGT / CURROL)
NEWCON = Int(NEWCON + .5)
If NEWCON > 0 Let PFU2[I] = NEWCON
L_4380: Gosub L_6300 ! write prod
if hold_pocost<>b[10]           
	LET pch.ctype=3               
	lET pch.OldCost= hold_pocost      
	LET pch.NewCost=b[10]             
	pch.Whse=0 ! no whse           
	gosub update_cost_hist: !       
endif                           
if hold_avgcost<>b[21]          
	LET pch.ctype=6               
	lET pch.OldCost= hold_avgcost   
	LET pch.NewCost=b[21]           
	pch.Whse=0 ! no whse         
	gosub update_cost_hist: !     
endif                         
if hold_netcost<>prparc[2]    
	LET pch.ctype=4                 
	lET pch.OldCost= hold_netcost    
	LET pch.NewCost=prparc[2]         
	pch.Whse=0 ! no whse          
	Gosub update_cost_hist: !       
ENDif
Return 
L_4400: Rem "=================================== vend/prod history
TYPE = H4[0]
J$[1,6] = H3[3] Using "######"
If NONSTOCK
  J$[7,18] = "000000000000"
Else 
  J$[7,18] = L1$[81,92]
End If 
J$[19,20] = TYPE Using "# "
Search #PROG_CH[9],2,1;J$,R16,E \ If E > 1 Gosub ERR_SEARCH
If E ! NEW RECORD
  E = 2 \ Search #PROG_CH[9],1,0;J$,R16,E \ If E Gosub ERR_SEARCH
  For X1 = 0 To 12 \ For X1[1] = 0 To 3
      VP1[X1,X1[1]] = 0;VP2[X1,X1[1]] = 0
    Next X1[1] \ Next X1
  Write #PROG_CH[9],R16,0;J$[7,18]
  Write #PROG_CH[9],R16,12;H3[3]
  Mat Write #PROG_CH[9],R16,16;VP1
  Mat Write #PROG_CH[9],R16,328;VP2
  Mat Write #PROG_CH[9],R16,640;TYPE
  Search #PROG_CH[9],4,1;J$,R16,E \ If E Gosub ERR_SEARCH
  J1$ = J$[7,18],J$[1,6]
  J1$[19,20] = TYPE Using "# "
  Search #PROG_CH[9],4,2;J1$,R16,E \ If E Gosub ERR_SEARCH
Else 
  Mat Read #PROG_CH[9],R16,16;VP1
End If 
Read #1,0,120;M0; \ X1 = M0
VP1[0,0] = VP1[0,0] + L3[4];VP1[X1,0] = VP1[X1,0] + L3[4]
VP1[0,1] = VP1[0,1] + BASEPOCOST * (L3[4] - PL4[16]);VP1[X1,1] = VP1[X1,1] + BASEPOCOST * (L3[4] - PL4[16])
VP1[0,2] = VP1[0,2] + L3[5];VP1[X1,2] = VP1[X1,2] + L3[5]
VP1[0,3] = VP1[0,3] + L3[6];VP1[X1,3] = VP1[X1,3] + L3[6]
Mat Write #PROG_CH[9],R16,16;VP1;
Return 
L_4800: Rem "=================================== serial numbers
SNKE1$ = " ",SNKE1$;SNKE1$[1,6] = H0[2] Using "######";SNKE1$[7,9] = L1[2] Using "###"
L_4810: Search #PROG_CH[2],3,1;SNKE1$,R6,E \ If E > 2 Gosub ERR_SEARCH
If E Goto L_4990
PO = SNKE1$[1,6] \ LN = SNKE1$[7,9]
If PO <> H0[2] Or LN <> L1[2] Goto L_4990
Mat Read #PROG_CH[2],R6,0;SN1$;
Mat Read #PROG_CH[2],R6,58;SN0;
If NONSTOCK Goto L_4955
If A$[8,8] <> "Y" Goto L_4955
If L3[4] = 0 Goto L_4955
If Not(LOTCNT) Let SN1$[13,24] = "STOCK        "
If SN1$[13,17] = "STOCK" Let SN1$[13,24] = L1[1] Using "STOCK&&      "
SN$ = " ",SN$;SN$[1,24] = SN1$[1,24];SN$[35,64] = SN1$[25,54]
SN$[85,144] = L1$[1,60]
Read #PROG_CH[1],H0[1],0;SN$[175,204];
SN1[0] = L1[1];SN1[1] = PFU1[0];SN1[2] = 0;INVNO = 0
SN2[0] = H0[2];SN2[1] = DATE;SN2[2] = H3[3];SN3[0] = POCOST
Read #PROG_CH[0],L3[1],632;SN$[65,84];
Read #PROG_CH[0],L3[1],652;SN2[9];
SNK$ = " ",SNK$;SNK$[1,30] = SN$[35,64]
SNK1$ = " ",SNK1$;SNK1$[1,24] = SN$[1,24]
E = 2;R7 = 0 \ Search #PROG_CH[3],1,0;SNK$,R7,E \ If E Gosub ERR_SEARCH
SNK$[31] = R7 Using "##########";SNK1$[25] = SNK$[31];SN$[25,34] = SNK$[31,40]
Search #PROG_CH[3],4,1;SNK$,R7,E \ If E Gosub ERR_SEARCH
Search #PROG_CH[3],4,2;SNK1$,R7,E \ If E Gosub ERR_SEARCH
Mat Write #PROG_CH[3],R7,0;SN$;
Write #PROG_CH[3],R7,284;INVNO;
Mat Write #PROG_CH[3],R7,290;SN1;
Mat Write #PROG_CH[3],R7,298;SN2;
Mat Write #PROG_CH[3],R7,342;SN3;
L_4955: Rem DEL
SNKE$ = " ",SNKE$;SNKE$[1,30] = SN1$[25,54];SNKE$[31] = L3[1] Using "######"
Search #PROG_CH[2],5,1;SNKE1$,R6,E \ If E Gosub ERR_SEARCH
Search #PROG_CH[2],5,2;SNKE$,R6,E \ If E Gosub ERR_SEARCH
E = 3 \ Search #PROG_CH[2],1,0;SNKE$,R6,E \ If E Gosub ERR_SEARCH
Goto L_4810
L_4990: Return

UPDATEROLLINV: REM!! update roll inventory            
if p61$[104,104]<>"Y" return
IF PRFLG$[6,6]<>"Y" RETURN                            
IF POMISC[0]=0 RETURN                                 
IF NONSTOCK RETURN                                    
IF NOT(L3[4]) RETURN                                  
LET KEYPOR1$=" ",KEYPOR1$                             
LET KEYPOR1$[1,6]=H0[2] USING "######"                
LET KEYPOR1$[7,9]=L1[2] USING "### "                  
SRCHPORL: REM search purchase order roll file         
SEARCH #CH_POROLL,3,1;KEYPOR1$,R[44],E \ IF E=2 RETURN
IF E GOSUB ERR_SEARCH:                                
LET PO=KEYPOR1$[1,6] \ IF PO<>H0[2] RETURN            
LET LN=KEYPOR1$[7,9] \ IF LN<>L1[2] RETURN            
MAT  READ #CH_POROLL,R[44],0;POR$;                    
MAT  READ #CH_POROLL,R[44],62;POR1;                   
MAT  READ #CH_POROLL,R[44],86;POR2                    
REM add to prod roll                                  
REM key for 1st directory                             
LET KEYRL1$=" ",KEYRL1$                               
LET KEYRL1$[1,12]=POR$[1,12]                          
LET KEYRL1$[13,14]=POR1[0] USING "##"                 
LET KEYRL1$[15,34]=POR$[13,32] 
REM key for 2nd directory                                                 
LET KEYRL2$=" ",KEYRL2$                                                   
LET KEYRL2$[1,20]=POR$[13,32]                                             
LET KEYRL2$[21,32]=POR$[1,12]                                             
LET KEYRL2$[33,34]=POR1[0] USING "##"                                     
LET RL0$=" ",RL0$;RLUSER$=" ",RLUSER$                                     
FOR X=0 TO 5 \ LET RL1[X]=0 \ NEXT X                                      
FOR X=0 TO 2 \ LET RL2[X]=0 \ NEXT X                                      
LET RL0$[1,12]=POR$[1,12]                                                 
LET RL0$[13,32]=POR$[13,32]                                               
LET RL1[0]=POR1[0]                                                        
LET RL1[1]=DATE                                                           
LET RL1[2]=374                                                            
LET RL1[3]=POR1[1]                                                        
LET RL1[4]=H3[3]                                                          
LET RL2[0]=POR2[2]  
LET RL2[1]=H0[2]                                                          
SEARCH #CH_ROLLID,2,1;KEYRL1$,R[43],E \ IF E>1 GOSUB ERR_SEARCH:          
IF E=1                                                                    
  LET E=2 \ SEARCH #CH_ROLLID,1,0;KEYRL1$,R[43],E \ IF E GOSUB ERR_SEARCH:
	SEARCH #CH_ROLLID,4,1;KEYRL1$,R[43],E \ IF E GOSUB ERR_SEARCH:          
	SEARCH #CH_ROLLID,4,2;KEYRL2$,R[43],E \ IF E GOSUB ERR_SEARCH:          
ENDIF                                                      
MAT  WRITE #CH_ROLLID,R[43],0;RL0$                                       
MAT  WRITE #CH_ROLLID,R[43],62;RL1                                       
MAT  WRITE #CH_ROLLID,R[43],102;RL2                                      
MAT  WRITE #CH_ROLLID,R[43],150;RLUSER$;                                 
LET KEYPOR2$=" ",KEYPOR2$                                                
LET KEYPOR2$[1,20]=POR$[13,32]                                           
LET KEYPOR2$[21,26]=POR2[3] USING "######"                               
LET KEYPOR2$[27,32]=POR2[1] USING "######"                               
LET KEYPOR2$[33,35]=POR1[1] USING "###"                                  
SEARCH #CH_POROLL,5,2;KEYPOR2$,R[44],E \ IF E GOSUB ERR_SEARCH:          
SEARCH #CH_POROLL,5,1;KEYPOR1$,R[44],E \ IF E GOSUB ERR_SEARCH:          
LET E=3 \ SEARCH #CH_POROLL,1,0;KEYPOR1$,R[44],E \ IF E GOSUB ERR_SEARCH:
GOTO SRCHPORL:                                                           
RETURN        



L_5000: Rem U/D FILES
Gosub L_2800
Gosub L_4400
Gosub L_7100
GLCOST = 0;FCOST = 0
If POMISC[0] ! "update item
  If Not(NONSTOCK)
    Gosub CALC_PROD_COSTS
    Gosub READ_PRODWHSE
    Gosub L_4000 ! update product file
    Gosub L_3500 ! update product warehouse file
    Gosub L_5300 ! update spolot
    Gosub L_5500 ! update fifo
    Gosub L_3800 ! update alt vend
  End If 
Else 
  If NONSTOCK<>0!  And POHR
    Gosub L_3000
  End If 
End If 
! UNLOCK PRODUCT FILE
If Not(NONSTOCK)
  Mat Read #PROG_CH[0],L3[1],0;A$;
else
  Mat Read #PROG_CH[8],L3[1],96;NSD1;
endif
Gosub L_3700
Gosub L_4800
if p61$[104,104]="Y"
	GOSUB UPDATEROLLINV: ! roll inventory
endif
Gosub L_7700
PL[5] = PL[5] + GLCOST
TOTGLCOST = TOTGLCOST + GLCOST
If SPO Gosub L_7800
if custom_customer$<>"HTBERRY"
	if p61$[86,86]="N" or p61$[86,86]="B"
		If NONSTOCK And L3[4] Gosub UPDT_ORDLINE
	endif
	if p61$[86,86]="S" or p61$[86,86]="B"
		if not(nonstock) and l3[4]<>0 Gosub UPDT_ORDLINE
	endif
Else ! berry updates any non-inv (stk & nonstk)
	IF not(POMISC[0]) ! NOT FROM INVENTORY
		IF l3[4] ! qty has been received
			Gosub Updt_OrdLine
		endif
	endif
Endif ! custom
!IF P61$[86,86]="S" or p61$[86,86]="B"
!	if NOT(NONSTOCK) ! STOCK ITEMS
!		IF L3[4]<>0 ! QTY RECEIVED
!			Gosub Updt_OrdLine
!		endif
!	ENDIF
!ENDIF
if NONSTOCK AND L3[4]<>0 ! NONSTK AND QTY - ALWAYS SEND ALERT
	if not(l3[4]) GOTO BYPALRT ! NO REC'D QTY
	if not(r1[8]) GOTO BYPALRT ! no PO header record #
	R1[9] = R9
	if not(r1[9]) GOTO BYPALRT ! no PO lines record #
	! If nonstock ! send alert - nonstk received tied to order or not
		clear x2[] ! CHANS
		clear x3[] ! PASSING INFO
		clear tmp$
		x2[1]=1;x2[2]=PROG_CH[4];x2[3]=PROG_CH[5];x2[4]=prog_ch[1] ! ctrl,poh,pol,vend
		x3[0]=22;x3[1]=r1[8];x3[2]=r1[9] ! alert#,rec_poh,rec_pol
		!call programdump("tmp/po374ans.txt!","")
		call "libalertproc.lib",x3[],x2[],tmp$
BYPALRT: ! bypass
Endif
IF P61$[132,132]="Y" and nonstock<>0 and l2[1]<>0
	gosub Updt_nsfrt:
endif
			
Return 
L_5200: Rem "============================= check lot control
LOTCNT = 0
If P9$[1,1] = "Y" Let LOTCNT = 1 \ Return 
If P9$[1,1] = "B" And A$[113,113] = "Y" Let LOTCNT = 1 \ Return 
POL1$[1,7] = L1[1] Using "STOCK&&"
Return 
L_5300: Rem UPDATE LOT FILES WITH SPOLOT
POL1$ = " ",POL1$
Gosub L_5200
If Not(LOTCNT) If Not(RASL)
  POL1$[23,28] = "STOCK "
  POL1[0] = H0[2] \ POL1[1] = L1[2] \ POL1[2] = L1[1]
  POL1[3] = L3[4]
  Gosub L_3200 \ Gosub L_3000
End If 
If P9$[1,1] <> "Y" Or A$[113,113] = "N" Let POL1$ = " ",POL1$
K18$[1,6] = H0[2] Using "######" \ K18$[7] = L1[2] Using "###"
L_5350: Search #PROG_CH[11],3,1;K18$,R18,E \ If E > 2 Gosub ERR_SEARCH
If E Goto L_5420
PO = K18$[1,6] \ LN = K18$[7,9]
If PO <> H0[2] Or LN <> L1[2] Goto L_5420
Mat Read #PROG_CH[11],R18,0;POL1$
Mat Read #PROG_CH[11],R18,38;POL1
If POL1[3] = 0 Goto L_5400
If Not(RASL) Let POL1$[23,28] = "STOCK "
Gosub L_3200
Gosub L_3000
L_5400: Search #PROG_CH[11],5,1;K18$,R18,E
If E Gosub ERR_SEARCH
E = 3 \ Search #PROG_CH[11],1,0;K18$,R18,E \ If E Gosub ERR_SEARCH
Goto L_5350
L_5420: Return 
L_5500: Rem UPDATE FIFOLOT & FIFOTRANS FOR FIFO & LIFO INVENTORY METHOD
FCOST = 0;SPCOST = 0
If P60$[9,9] <> "F" And P60$[9,9] <> "L" Return 
If A$[127,127] = "Y" And P61$[73,73] = "Y"
  If Not(L3[5]) Return 
Else 
  If Not(L3[4]) Return 
End If 
For CTR = 0 To 16
  If CTR < 11 Let FIFOSPECCH[CTR] = 0;FIFOSPEC1[CTR] = 0;FIFOSPEC2[CTR] = 0
  FIFOSPEC3[CTR] = 0
Next CTR
FIFOSPEC$ = " ",FIFOSPEC$
Rem set fifo spec variable for channel #
FIFOSPECCH[0] = PROG_CH[13]
FIFOSPECCH[1] = PROG_CH[14]
FIFOSPECCH[2] = PROG_CH[19]
FIFOSPECCH[3] = PROG_CH[18]
FIFOSPECCH[4] = PROG_CH[0]
FIFOSPECCH[5] = PROG_CH[6]
FIFOSPECCH[6] = 0
Rem set fifospec 1 variables
FIFOSPEC1[0] = 374
FIFOSPEC1[1] = L1[1]
FIFOSPEC1[2] = L1[1]
FIFOSPEC1[3] = L1[1]
FIFOSPEC1[4] = 0
Rem set fifospec 2 variables
FIFOSPEC2[0] = CURJDATE
FIFOSPEC2[1] = POSTPER
FIFOSPEC2[2] = POCNTRL
Rem set fifospec 3 variables
FIFOSPEC3[0] = L3[4]
FIFOSPEC3[1] = H0[2]
FIFOSPEC3[2] = H3[3]
FIFOSPEC3[3] = BPOCOST[1]
FIFOSPEC3[4] = PL4[12]
FIFOSPEC3[5] = PL4[13]
FIFOSPEC3[6] = L3[4]
FIFOSPEC3[7] = L3[5]
FIFOSPEC3[8] = 0
FIFOSPEC3[9] = 0
Rem set fifospec$ variable
FIFOSPEC$ = " ",FIFOSPEC$
FIFOSPEC$[1,12] = A$[140,151]
FIFOSPEC$[13,24] = POL1$[1,12]
FIFOSPEC$[25,34] = POL1$[13,22]
FIFOSPEC$[35,40] = POL1$[23,28]
If A$[127,127] = "Y" And P61$[73,73] = "Y" ! catch weight item store fifo in lbs
  If Not(L3[5]) Return 
  FIFOSPEC3[0] = L3[5]
  If L1[5] <> -3 ! costing um is not in lbs
    DISP_EXT = L3[4] * BPOCOST[1]
    FIFOSPEC3[3] = DISP_EXT / L3[5]
  Else 
    CNVTA = PL4[0]
    CNVTU[0] = 0;CNVTU[1] = -3;CNVTU[2] = 2
    Gosub L_20000
    If L2[1] ! check to add in freight charges
      If P60$[49,49] = "F" Or P60$[49,49] = "B"
        AMOUNT = AMOUNT + L2[1]
      End If 
    End If 
    If PL4[8] ! check to add in misc charges
      If P60$[49,49] = "M" Or P60$[49,49] = "B"
        AMOUNT = AMOUNT + PL4[8]
      End If 
    End If 
    FIFOSPEC3[3] = AMOUNT
  End If 
End If 
Call "MXFIFO.dl4",FIFOSPECCH[],FIFOSPEC1[],FIFOSPEC2[],FIFOSPEC3[],FIFOSPEC$,e$,IntCo,rstr$                                                             
! Call "MXFIFO",FIFOSPECCH[],FIFOSPEC1[],FIFOSPEC2[],FIFOSPEC3[],FIFOSPEC$
FCOST = FIFOSPEC3[8]
If P61$[60,60] = "Y" Let SPCOST = FIFOSPEC3[9]
Return 
FQ9[0] = Int(L3[4]) \ FQ9[1] = 0 \ FQ9[2] = 0
FLK$ = " ",FLK$ \ FLK$[1,12] = A$[140,151] \ FLK$[13,14] = L1[1] Using "##" \ MODE = 3
If P60$[9,9] = "L" Let FLK$[15] = "999999" \ MODE = 6
L_5530: Search #PROG_CH[13],MODE,1;FLK$,R[19],E \ If E = 2 Goto L_5700
If E Gosub ERR_SEARCH
If FLK$[1,12] <> A$[140,151] Goto L_5700
S9 = FLK$[13,14] \ If S9 <> L1[1] Goto L_5700
Mat Read #PROG_CH[13],R[19],102;FL3; \ If Not(FL3 - FL3[1]) Goto L_5530
FQ9[2] = FQ9[0] - FQ9[1]
If FQ9[2] > 0 If (FL3[0] - FL3[1]) < 0 Goto L_5595
FQTY = FL3[0]
For S9 = 1 To 5 \ FQTY = FQTY - FL3[S9] \ Next S9
For S9 = 8 To 11 \ FQTY = FQTY - FL3[S9] \ Next S9
If FQ9[2] < 0 If FQTY > 0 Goto L_5595
If FQ9[2] >= 0 Goto L_5530
If FL3[0] Goto L_5530
Mat Read #PROG_CH[13],R[19],86;FL2;
If CURJDATE = FL2[1] Goto L_5595
Goto L_5530
L_5595: Gosub L_6800
If FQ9[2] < 0 Goto L_5630
If (FL3[1] - FL3[0]) > 0 If (FL3[1] - FL3[0]) < FQ9[2] Let FQ9[2] = (FL3[1] - FL3[0])
FL3[0] = Int(FL3[0] + FQ9[2])
Goto L_5645
L_5630: If FQ9[2] > 0 Goto L_5645
FQTY = FL3[0]
For S9 = 1 To 5 \ FQTY = FQTY - FL3[S9] \ Next S9
For S9 = 8 To 11 \ FQTY = FQTY - FL3[S9] \ Next S9
If FL3[0] If FQTY < Abs(FQ9[2]) Let FQ9[2] = - (FQTY)
FL3[1] = Int(FL3[1] - FQ9[2])
L_5645: FL2[2] = CURJDATE
If BPOCOST[1] < 0 If FL3[6] Goto L_5655
If BPOCOST[1] >= 0 Let FL3[6] = BPOCOST[1]
If Not(FL3[6]) And PL4[7] = 0 Goto L_5655
If Not(FL3[6]) If P9$[32,32] = "Y" Let FL3[6] = W3[16]
If Not(FL3[6]) Let FL3[6] = B[10]
FL3[7] = FL3[6] + ((FL3[6] * FIFL) / 100)
If P8$[5,5] = "F" Let FCOST = FCOST + FNR(FQ9[2] * FL3[6])
If P8$[5,5] = "I" Let FCOST = FCOST + FNR(FQ9[2] * FL3[7])
If P61$[60,60] = "Y"
  If FL3[14] <= 0
    WHSE = FL1[0] - 1
    If WHSE < 0 Goto ENDGETSPCCOST
    If WHSE > Chf(PROG_CH[18]) Goto ENDGETSPCCOST
    Read #PROG_CH[18],WHSE,2970;WHOS;
    If Not(WHOS) Goto ENDGETSPCCOST
    FSKEY$[1,12] = A$[140,151]
    FSKEY$[13,16] = WHOS Using "####"
    Search #PROG_CH[19],2,1;FSKEY$,R[29],E \ If E > 1 Gosub ERR_SEARCH
    If Not(E)
      Mat Read #PROG_CH[19],R[29],12;FC0;
      Mat Read #PROG_CH[19],R[29],38;FC2;
      If (FC0[1] = -1 Or FC0[1] = -3) And FC2[0] <> 0 And FQ9[2] <> 0 And PL4[13] <> 0 ! "cwt or catch wgt
        CNVTA = FC2[0];CNVTU[0] = 0;CNVTU[1] = FC0[1];CNVTU[2] = 2
        Gosub L_20000 \ DSP_COST = AMOUNT
        If FC0[1] = -1 Let DISP_EXT = DSP_COST * (PL4[12] * FQ9[2] / PL4[13]) / 100
        If FC0[1] = -3 Let DISP_EXT = DSP_COST * (PL4[12] * FQ9[2] / PL4[13])
        FL3[14] = DISP_EXT / FQ9[2]
      Else 
        FL3[14] = FC2[0]
      End If 
    End If 
ENDGETSPCCOST: Rem
  End If 
  If FL3[14]
    SPCOST = SPCOST + FNR(FQ9[2] * FL3[14])
  Else 
    If P8$[5,5] = "I"
      SPCOST = SPCOST + FNR(FQ9[2] * FL3[7])
    Else 
      SPCOST = SPCOST + FNR(FQ9[2] * FL3[6])
    End If 
  End If 
End If 
L_5655: Gosub L_6850
Gosub L_5900
FQ9[1] = Int(FQ9[1] + FQ9[2])
If FQ9[0] = FQ9[1] Return 
Goto L_5530
Stop 
L_5700: Rem CREATE FIFOLOT
FL1$ = " ",FL1$
For S9 = 0 To 14
  If S9 < 3 Let FL1[S9] = 0
  If S9 < 3 Let FL2[S9] = 0
  If S9 < 2 Let FL4[S9] = 0
  FL3[S9] = 0
Next S9
FQ9[2] = FQ9[0] - FQ9[1]
FL1[0] = L1[1] \ FL1[1] = 1
FL1[2] = PFU1[0]
FL1$[1,12] = A$[140,151] \ FL1$[13,24] = POL1$[1,12]
FL1$[25,34] = POL1$[13,22]
FL1$[35,40] = POL1$[23,28]
FL1$[41,49] = H0[2] Using "PO ######" \ FL1$[50,60] = H3[3] Using "VEND ######"
FL2[1] = CURJDATE
FL4[0] = PL4[12];FL4[1] = PL4[13]
If FQ9[2] > 0 Let FL3[0] = Int(FQ9[2])
If FQ9[2] < 0 Let FL3[1] = Int(Abs(FQ9[2]))
If BPOCOST[1] > 0 Let FL3[6] = BPOCOST[1] \ If FL3[6] Goto L_5777
If BPOCOST[1] = 0
  If L3[4] = PL4[16] Let FL3[6] = BPOCOST[1] \ Goto L_5777
  If PL4[7] = 0 Let FL3[6] = BPOCOST[1] \ Goto L_5777
End If 
FLK$[1,12] = FL1$[1,12];FLK$[13,14] = FL1[0] Using "##";FLK$[15] = "999999" \ MODE = 6
If P60$[9,9] = "L" Let FLK$[15] = "" \ MODE = 3
Search #PROG_CH[13],MODE,1;FLK$,R[19],E \ If E = 2 Goto L_5772
If E Gosub ERR_SEARCH
S9 = FLK$[13,14]
If FLK$[1,12] = FL1$[1,12] And S9 = FL1[0]
  Mat Read #PROG_CH[13],R[19],192;FL4;
  Read #PROG_CH[13],R[19],186;FL3[14];
  Read #PROG_CH[13],R[19],138;FL3[6]; \ Goto L_5777
End If 
L_5772: If P9$[32,32] = "Y" And W3[16] > 0 Let FL3[6] = W3[16] \ Goto L_5777
FL3[6] = B[10]
L_5777: FL3[7] = FL3[6] + ((FL3[6] * FIFL) / 100)
If P8$[5,5] = "F" Let FCOST = FCOST + FNR(FQ9[2] * FL3[6])
If P8$[5,5] = "I" Let FCOST = FCOST + FNR(FQ9[2] * FL3[7])
If P61$[60,60] = "Y"
  If FQ9[2] > 0 Or FL3[14] = 0
    WHSE = FL1[0] - 1
    If WHSE < 0 Goto ENDGETSPCCOST1
    If WHSE > Chf(PROG_CH[18]) Goto ENDGETSPCCOST1
    Read #PROG_CH[18],WHSE,2970;WHOS;
    If Not(WHOS) Goto ENDGETSPCCOST1
    FSKEY$[1,12] = A$[140,151]
    FSKEY$[13,16] = WHOS Using "####"
    Search #PROG_CH[19],2,1;FSKEY$,R[29],E \ If E > 1 Gosub ERR_SEARCH
    If Not(E)
      Mat Read #PROG_CH[19],R[29],12;FC0;
      Mat Read #PROG_CH[19],R[29],38;FC2;
      If (FC0[1] = -1 Or FC0[1] = -3) And FC2[0] <> 0 And FQ9[2] <> 0 And PL4[13] <> 0 ! "cwt or catch wgt
        CNVTA = FC2[0];CNVTU[0] = 0;CNVTU[1] = FC0[1];CNVTU[2] = 2
        Gosub L_20000 \ DSP_COST = AMOUNT
        If FC0[1] = -1 Let DISP_EXT = DSP_COST * (PL4[12] * FQ9[2] / PL4[13]) / 100
        If FC0[1] = -3 Let DISP_EXT = DSP_COST * (PL4[12] * FQ9[2] / PL4[13])
        FL3[14] = DISP_EXT / FQ9[2]
      Else 
        FL3[14] = FC2[0]
      End If 
    End If 
ENDGETSPCCOST1: Rem
  End If 
  If FL3[14]
    SPCOST = SPCOST + FNR(FQ9[2] * FL3[14])
  Else 
    If P8$[5,5] = "I"
      SPCOST = SPCOST + FNR(FQ9[2] * FL3[7])
    Else 
      SPCOST = SPCOST + FNR(FQ9[2] * FL3[6])
    End If 
  End If 
End If 
FLK$ = " ",FLK$
E = 2 \ Search #PROG_CH[13],1,0;FLK$,R[19],E \ If E Gosub ERR_SEARCH
FL2 = R[19]
Gosub L_6850
FLK$ = " ",FLK$ \ FLK$[1,12] = FL1$[1,12] \ FLK$[13,14] = FL1 Using "##"
FLK$[15,20] = FL2[1] Using "######" \ FLK$[21,26] = FL2 Using "######"
Search #PROG_CH[13],4,1;FLK$,R[19],E \ If E Gosub ERR_SEARCH
Gosub L_5900
Return 
L_5900: Rem FIFOTRANS FILE UPDATE
FT1$ = " ",FT1$
For S9 = 0 To 3 \ FT1[S9] = 0 \ FT2[S9] = 0 \ FT3[S9] = 0 \ Next S9
FT1$[1,12] = A$[140,151] \ FT1$[13,24] = POL1$[1,12]
FT1$[25,34] = POL1$[13,22];FT1$[35,40] = POL1$[23,28]
FT1$[41,49] = H0[2] Using "PO ######"
FT1$[53,72] = H3[3] Using "VEND ###### PO RCPTS"
FT1[0] = 1
FT1[1] = L1[1]
FT1[2] = Spc(6) \ FT2[0] = FL2[0]
FT2[2] = CURJDATE \ FT3[0] = FQ9[2]
FT3[1] = FL3[6] \ FT3[2] = FL3[7] \ FT3[3] = FL3[14]
FLT$ = " ",FLT$
E = 2 \ Search #PROG_CH[14],1,0;FLT$,R[20],E \ If E Gosub ERR_SEARCH
If R[20] <= 999999 Let FT2[1] = R[20]
Gosub L_6900
FLT$[1,6] = FT2[0] Using "######" \ FLT$[7,12] = FT2[2] Using "######"
If R[20] <= 999999
  FLT$[13,18] = FT2[1] Using "######"
Else 
  FTRECA = Int((R[20] - 1000000) / 100000)
  FTRECB = Fra(R[20] / 100000) * 100000
  Call String(4,FTRECA + 193,LETTER$)
  FLT$[13,13] = LETTER$[1,1]
  FLT$[14,18] = FTRECB Using "#####"
End If 
Search #PROG_CH[14],4,1;FLT$,R[20],E \ If E Gosub ERR_SEARCH
Return 
L_6000: Rem READ LINE ITEM
Mat Read #PROG_CH[5],R9;L1
Mat Read #PROG_CH[5],R9,12;L2
Mat Read #PROG_CH[5],R9,24;L3
Mat Read #PROG_CH[5],R9,66;L1$
Mat Read #PROG_CH[5],R9,186;PL
Mat Read #PROG_CH[5],R9,222;PL0
PL0[1] = PH[2];LBRECV = L3[5]
Mat Read #PROG_CH[5],R9,232;PL4
Mat Read #PROG_CH[5],R9,376;POMISC
Mat Read #PROG_CH[5],R9,382;PL5
Mat Read #PROG_CH[5],R9,442;PL6
Mat Read #PROG_CH[5],R9,508;POCNTRL
mat read #prog_ch[5],r9,548;plcurrid;
mat read #prog_ch[5],r9,550;plcurrfact;
Gosub L_8400
If P9$[41,41] = "W" 
	Call "CHKWRASL",L1[1],RASL[]
endif
Return 
L_6100: Rem WRITE LINE REC
Mat Write #PROG_CH[5],R9;L1
Mat Write #PROG_CH[5],R9,12;L2
Mat Write #PROG_CH[5],R9,24;L3
Mat Write #PROG_CH[5],R9,66;L1$
Mat Write #PROG_CH[5],R9,186;PL
Mat Write #PROG_CH[5],R9,222;PL0
Mat Write #PROG_CH[5],R9,232;PL4
Mat Write #PROG_CH[5],R9,376;POMISC
Mat Write #PROG_CH[5],R9,382;PL5
Mat Write #PROG_CH[5],R9,442;PL6
Mat Write #PROG_CH[5],R9,508;POCNTRL;
mat write #prog_ch[5],r9,548;plcurrid;
mat write #prog_ch[5],r9,550;plcurrfact;
Return 
L_6200: Rem READ PRODUCT FILE
Mat Read #PROG_CH[0],L3[1],0;A$
Mat Read #PROG_CH[0],L3[1],156;B
Mat Read #PROG_CH[0],L3[1],256;A
Mat Read #PROG_CH[0],L3[1],460;A1
Mat Read #PROG_CH[0],L3[1],512;PFU1
Mat Read #PROG_CH[0],L3[1],554;PFU2
Mat Read #PROG_CH[0],L3[1],670;U4
Mat Read #PROG_CH[0],L3[1],894;C4
Mat Read #PROG_CH[0],L3[1],596;PRPARC
Mat Read #PROG_CH[0],L3[1],1018;PFN
mat  read #prog_ch[0],l3[1],1056;prflg$
PROD_LBS = A[6];PROD_FACT = A[5]
Return 
L_6300: Rem WRITE PRODUCT FILE
Mat Write #PROG_CH[0],L3[1],156;B
Mat Write #PROG_CH[0],L3[1],256;A
Mat Write #PROG_CH[0],L3[1],554;PFU2
Mat Write #PROG_CH[0],L3[1],894;C4
Mat Write #PROG_CH[0],L3[1],596;PRPARC
Mat Write #PROG_CH[0],L3[1],1018;PFN;
if sqlChan >= 0 ! MySQL enabled and channel opened
	e = prod_UpdateSQLFromDL4(e$, intCo, a$[140,151], sqlChan, PROG_CH[0])
	if e <> 1 ! returns the number of records add/updated/deleted
		gosub ERR_SEARCH
	end if
end if
Return 
L_6500: Rem READ NSTKDESC
Mat Read #PROG_CH[8],L3[1],96;NSD1
Mat Read #PROG_CH[8],L3[1],112;NSD2
Mat Read #PROG_CH[8],L3[1],132;NSD3
Return 
Mat Write #PROG_CH[8],L3[1],96;NSD1
Mat Write #PROG_CH[8],L3[1],112;NSD2
Mat Write #PROG_CH[8],L3[1],132;NSD3;
Return 
L_6800: Rem READ FIFOLOT
Mat Read #PROG_CH[13],R[19],0;FL1
Mat Read #PROG_CH[13],R[19],6;FL1$
Mat Read #PROG_CH[13],R[19],86;FL2
Mat Read #PROG_CH[13],R[19],102;FL3
Mat Read #PROG_CH[13],R[19],192;FL4
Return 
L_6850: Rem WRITE FIFOLOT
Mat Write #PROG_CH[13],R[19],0;FL1
Mat Write #PROG_CH[13],R[19],6;FL1$
Mat Write #PROG_CH[13],R[19],86;FL2
Mat Write #PROG_CH[13],R[19],102;FL3
Mat Write #PROG_CH[13],R[19],192;FL4;
Return 
L_6900: Rem WRITE FIFOTRANS
Mat Write #PROG_CH[14],R[20],0;FT1$;
Mat Write #PROG_CH[14],R[20],72;FT1;
Mat Write #PROG_CH[14],R[20],80;FT2;
Mat Write #PROG_CH[14],R[20],96;FT3;
Return 
X2[1] = Int(X2 / 10 ^ 2 - Int(X2 / 10 ^ 4) * 10 ^ 2)
X2[2] = Fra(X2 / 10 ^ 2) * 10 ^ 2 \ X2[3] = Int(X2 / 10 ^ 4)
X2[5] = Int(.1 * X2[1] + .7) * Int(.6 * X2[1] - 2.3 + Not(Fra(X2[3] / 4)))
X2[5] = X2[5] + Int(365.25 * (X2[3] - 1)) + (X2[1] - 1) * 30 + Not(X2[1] - 2) + X2[2]
Return 
L_7100: Rem IMPORT PO ITEMS
IMPORT = 0 \ If P60$[46,46] <> "Y" Or H4[0] < 4 Or L3[4] = 0 Return 
LANDCOST = FNR((L3[4] - PL4[16]) * PL4[0])
If LANDCOST < 0 Let LANDCOST = 0
For X = 0 To 8 \ LANDCOST = LANDCOST + PL5[X] \ Next X
PL5[9] = LANDCOST
For X = 0 To 9 \ PL6[X] = PL6[X] + PL5[X] \ Next X
LANDCOST = 0
If L3[4] Let LANDCOST = PL5[9] / L3[4]
If LANDCOST > 0 Let IMPORT = 1
Return 
L_7500: Rem CHECK OUT OF STOCK CONDITION *GORDON GRAHAM*
If W3[0] < 0 Goto L_7590
If W7[9] Goto L_7590
If Not(W7[8]) Goto L_7590
W7[9] = DATE
X2 = W7[8] \ Gosub L_17820 \ X2 = 0
If (CURJDATE - X2) < 14 Return 
DAYS = CURJDATE - X2
X9$ = DATE Using "######" \ X9 = X9$[1,4] \ X9[1] = X9$[1,2] \ X9[2] = X9$[3,4]
X9$ = W7[8] Using "######" \ X9[3] = X9$[1,4] \ X9[4] = X9$[1,2] \ X9[5] = X9$[3,4]
If X9 = X9[3] Let WH8[X9[2] - 1] = 1 \ Goto L_7590
X9$ = " ",X9$ \ X9$[1,4] = X9 Using "####" \ X9$[5,6] = "01"
X2 = X9$[1,6] \ Gosub L_17820 \ X2 = 0
If (CURJDATE - X2) < 14 Goto L_7590
WH8[X9[2] - 1] = 1
L_7590: Return 
L_7700: Rem
GLCOST = 0
If Not(POMISC[0])
  GLCOST = FNR(L3[4] * POCOST1)
  If L1[5] = -2 Let GLCOST = POCOST1
  If L1[5] = -1
    CNVTA = POCOST1;CNVTU[0] = 0;CNVTU[1] = L1[5];CNVTU[2] = 2
    Gosub L_20000
    If PL4[13]
      GLCOST = FNR(AMOUNT * (PL4[12] * (L3[4] - PL4[16]) / PL4[13]) / 100)
    Else 
      GLCOST = FNR(AMOUNT * (L3[5] * (L3[4] - PL4[16]) / L3[2]) / 100)
    End If 
  End If 
  Return 
End If 
If P8$[5,5] = "F" Or P8$[5,5] = "I"
  GLCOST = FCOST
  If P61$[60,60] = "Y" Let GLCOST = SPCOST
  Return 
End If 
If P9$[32,32] = "Y"
  If P8$[5,5] = "R" Let GLCOST = FNR(L3[4] * W3[16]) \ Goto L_7760
  If P8$[5,5] = "W" Let GLCOST = FNR(L3[4] * W3[17]) \ Goto L_7760
  If P8$[5,5] = "B" Let GLCOST = FNR(L3[4] * W3[18]) \ Goto L_7760
  GLCOST = FNR(L3[4] * W3[15])
L_7760: If GLCOST Return 
End If 
If P8$[5,5] = "R" Let GLCOST = FNR(L3[4] * B[10]) \ Goto L_7795
If P8$[5,5] = "W" Let GLCOST = FNR(L3[4] * B[8]) \ Goto L_7795
If P8$[5,5] = "B" Let GLCOST = FNR(L3[4] * C4[4]) \ Goto L_7795
GLCOST = FNR(L3[4] * B[21])
L_7795: Return 
L_7800: Rem APPO CONTROL INTERFACE
If Not(SPO) Return 
If Not(L3[4]) Return 
For X = 0 To 11 \ PCT5[X] = 0 \ Next X
For X = 0 To 12
  If X < 6 Let PCT1[X] = 0;PCT2[X] = 0
  If X < 3 Let PCT3[X] = 0;PCT7[X] = 0;PCT0[X] = 0
  If X < 2 Let PCT4[X] = 0;PCT6[X] = 0
  If X < 5 Let PCT9[X] = 0
  PCT8[X] = 0
Next X
PCT$ = " ",PCT$
PCT1[0] = H0[2];PCT1[1] = L1[2];PCT1[2] = H3[3];PCT1[3] = POCNTRL
PCT1[4] = DATE;PCT1[5] = 0
PCT2[0] = L3[4] - PL4[16]
PCT2[1] = PL4[0]
PCT7[0] = 0
If POMISC[0] ! stock update y
  If P60$[9,9] = "F" Or P60$[9,9] = "L"
    If P61$[60,60] = "Y"
      If FCOST <> SPCOST
        If (L3[4] - PL4[16]) > 0
          PCT2[1] = (GLCOST / (L3[4] - PL4[16]))
          If L1[5] = -1 Or L1[5] = -3
            A[5] = PL4[13];A[6] = PL4[12]
            CNVTU[0] = 0;CNVTU[1] = L1[5];CNVTU[2] = 2
            CNVTA = PCT2[1]
            Gosub L_20000
            CNVTA = AMOUNT
            A[5] = PROD_FACT;A[6] = PROD_LBS
            CNVTU[0] = L1[5];CNVTU[1] = 0;CNVTU[2] = 2
            Gosub L_20000
            PCT2[1] = AMOUNT
          End If 
        End If 
        If L5[1] = -2 Let PCT2[1] = GLCOST
        PCT7[0] = 99
      End If 
    End If 
  End If 
End If 
PCT2[2] = GLCOST
PCT3[1] = L1[1]
PCT$[1,12] = L1$[81,92]
If P60$[49,49] = "F" Or P60$[49,49] = "B" Or P60$[19,19] = "Y" ! update freight
  PCT5[0] = L2[1]
End If 
If P60$[49,49] = "B" Or P60$[49,49] = "M" ! update misc charge
  PCT5[1] = PL4[8]
End If 
PCT5[2] = L2[0] - PL4[0]
PCT5[3] = PL4[16]
PCT5[8] = BPOCOST[0];PCT5[9] = BPOCOST[1]
If p60$[48,48]="N" let pct5[8]=bpocost[1]  ! average is the net po cost
PCT6[0] = PL4[12]
PCT6[1] = PL4[13]
PCT7[1] = POMISC[0]
PCT7[2] = B[11]
PCT9[1] = L3[5]
If POMISC[0] And A$[127,127] = "Y" And P61$[73,73] = "Y" And L1[5] = -3
  PCT0 = 99
  PCT9[1] = PCT2[0]
  PCT2[0] = L3[5]
End If 
PCT9[3] = PL4[7]
POCFRGT = 0;POCMISC = 0
POCFRGT = (L3[4] * PCT5[0])
POCMISC = (L3[4] * PCT5[1])
If L1[5] = -1 Or L1[5] = -3 ! weighted cost items
  If PL4[13]
    POCFRGT = (L3[4] * (PCT5[0] * (PL4[12] / PL4[13])))
    POCMISC = (L3[4] * (PCT5[1] * (PL4[12] / PL4[13])))
  End If 
End If 
If L1[5] = -2
  POCFRGT = (L2[1])
  POCMISC = (PL4[8])
End If 
PCT9[4] = FNR(PL4[7] + POCFRGT + POCMISC)
If PCT7[0] ! special cost flag
  PCT9[3] = GLCOST
  PCT9[4] = FNR(GLCOST + POCFRGT + POCMISC)
End If 
PCT8[3] = POSTPER
PCT8[4] = JRNL
PCT8[5] = FNR(POCFRGT)
PCT8[6] = FNR(POCMISC)
if p61$[136,136]="Y" 
	PCT8[12]= plcurrfact! CURRENCY FACTOR
	pct0[2]=plcurrid ! currency id
else
	let pct8[12]=0
	let pct0[2]=0
endif
If POHR Let PCT0[1] = 1
K30$ = " ",K30$;K30$[1,6] = PCT1[0] Using "######";K30$[7,12] = PCT1[3] Using "######"
K30$[13,16] = PCT1[1] Using "####";K30$[17,18] = PCT3[1] Using "##"
E = 2 \ Search #PROG_CH[15],1,0;K30$,R[30],E \ If E Gosub ERR_SEARCH
Mat Write #PROG_CH[15],R[30],0;PCT1
Mat Write #PROG_CH[15],R[30],24;PCT2
Mat Write #PROG_CH[15],R[30],60;PCT3
Mat Write #PROG_CH[15],R[30],66;PCT$
Mat Write #PROG_CH[15],R[30],78;PCT4
Mat Write #PROG_CH[15],R[30],90;PCT5
Mat Write #PROG_CH[15],R[30],162;PCT6
Mat Write #PROG_CH[15],R[30],174;PCT7
Mat Write #PROG_CH[15],R[30],180;PCT9
Mat Write #PROG_CH[15],R[30],210;PCT8
Mat Write #PROG_CH[15],R[30],288;PCT0;
Search #PROG_CH[15],4,1;K30$,R[30],E \ If E Gosub ERR_SEARCH
K30$ = " ",K30$;K30$[1,6] = PCT1[3] Using "######";K30$[7,8] = PCT3[1] Using "##"
K30$[9,14] = PCT1[0] Using "######";K30$[15,18] = PCT1[1] Using "####"
Search #PROG_CH[15],4,2;K30$,R[30],E \ If E Gosub ERR_SEARCH
GLCOST = PCT9[4]
Gosub UPDATEGL
Return 
L_8400: Rem UNPACK L1[3] TO FLAGS[x]
NONSTOCK = 0
Call Logic(1,2 ^ 0,L1[3],NONSTOCK)
X2 = L1[3] \ For K = 0 To 11
  FLAGS[K] = Sgn(Fra(X2 / 2)) \ X2 = Int(X2 / 2)
Next K \ Return 
X2 = 0 \ For K = 0 To 11
  If FLAGS[K] Let X2 = X2 + 2 ^ K
Next K \ L1[3] = X2 \ Return 
update_cost_hist: ! rem                                
! set up main data                             
LET pch.ProdCode$=A$[140,151]+Blank$
pch.AccessCode$=Blank$
LET tmp1$="pgm 374 "                           
LET tmp1$=tmp1$+H0[2] USING "PO###### "             
LET tmp1$=tmp1$+L1[2] USING "LN###" 
pch.Source$=tmp1$[1,10]
pch.sOpen$=tmp1$[11]+Blank$
pch.Blankforkey$=Blank$
lET pch.CDate=0                                        
LET pch.CTime=0                                        
LET pch.CostUm=PFU1[11]                                 
IF pch.CostUm>0                                         
	FOR XCST=0 TO 7                                        
	IF PFU1[XCST]=PFU1[11]                                 
		IF XCST=0                                              
			LET pch.CstUmFactor=1                                        
		ELSE                                                   
			LET pch.CstUmFactor=PFU2[XCST-1]                             
		ENDIF                                                  
	ENDIF                                                  
	NEXT XCST                                              
ENDIF                                                  
CChan[0]=0 ! no costhist file open                                  
!CALL "mkcosthist",CSTHST$,CSTHST[],CHAN
call MkCostHist(e$,IntCo,cchan[],pch.)
return 
Rem! gl section !!!!
UPDATEGL: Rem update g/l section here
If P9$[17,17] <> "Y" Return 
If Not(POGLFLAG) Return 
PRODCAT = B[11]
Gosub GETGLCNTRL
Rem update gl inventory account +
If H4[0] = 0 Or H4[0] = 4 ! warehouse order types
  If Not(NONSTOCK)
    If POMISC[0] ! update stock yes
      GLACCT = GLC1[0]
    Else 
      GLACCT = GLC1[4]
    End If 
  Else ! nonstock items
    If P8$[4,4] = "Y"
      GLACCT = GLC1[6]
    Else 
      GLACCT = GLC1[8]
    End If 
  End If 
End If 
If H4[0] = 1 Or H4[0] = 5 ! direct order types
  If Not(NONSTOCK)
    GLACCT = GLC1[0]
  Else 
    GLACCT = GLC1[6]
  End If 
End If 
If H4[0] = 2 Or H4[0] = 6
  If Not(NONSTOCK) ! stock item
    If POMISC[0] ! update stock yes
      GLACCT = GLC1[0]
    Else 
      If P60$[22,22] = "N" ! indirect do not update stock
        GLACCT = GLC1[0]
      Else 
        GLACCT = GLC1[4]
      End If 
    End If 
  Else ! nonstock item
    If P8$[4,4] = "Y" ! nonstock update inventory is set ot "Y"
      GLACCT = GLC1[6]
    Else 
      GLACCT = GLC1[8]
    End If 
  End If 
End If 
GLAMT = GLCOST
Gosub UPGLTEMP
Rem update gl purchase account -
If Not(NONSTOCK)
  GLACCT = GLC1[1]
Else 
  GLACCT = GLC1[7]
End If 
GLAMT = - GLCOST
Gosub UPGLTEMP
Return 
GETGLCNTRL: Rem from glpocntrl
If P8$[3,3] <> "Y" Let PRODCAT = 0
POTYPE = H4[0] \ If H4[0] < 3 Let POTYPE = H4[0] + 1
If P8$[2,2] = "Y" !ORDER TYPE
  GLCKEY$ = " ",GLCKEY$ \ GLCKEY$[1,2] = L1[1] Using "##"
  If POTYPE Let GLCKEY$[5,6] = POTYPE Using "##"
  If PRODCAT Let GLCKEY$[7,8] = PRODCAT Using "##"
  Search #CH_GLC,2,1;GLCKEY$,REC_GLC,E \ If E > 1 Gosub ERR_SEARCH
  If Not(E) Goto FNDGLCNTRL
  If PRODCAT ! find without cat
    GLCKEY$[7,8] = "  "
    Search #CH_GLC,2,1;GLCKEY$,REC_GLC,E \ If E > 1 Gosub ERR_SEARCH
    If Not(E) Goto FNDGLCNTRL
  End If 
End If 
GLCKEY$ = " ",GLCKEY$ \ GLCKEY$[1,2] = L1[1] Using "##"
If PRODCAT Let GLCKEY$[7,8] = PRODCAT Using "##"
Search #CH_GLC,2,1;GLCKEY$,REC_GLC,E \ If E > 1 Gosub ERR_SEARCH
If Not(E) Goto FNDGLCNTRL
If PRODCAT
  GLCKEY$[7,8] = "  "
  Search #CH_GLC,2,1;GLCKEY$,REC_GLC,E \ If E > 1 Gosub ERR_SEARCH
  If Not(E) Goto FNDGLCNTRL
End If 
GLCKEY$ = "DFAULT"
If PRODCAT Let GLCKEY$[7,8] = PRODCAT Using "##"
Search #CH_GLC,2,1;GLCKEY$,REC_GLC,E \ If E > 1 Gosub ERR_SEARCH
If Not(E) Goto FNDGLCNTRL
GLCKEY$[7,8] = "  "
Search #CH_GLC,2,1;GLCKEY$,REC_GLC,E \ If E Gosub ERR_SEARCH
FNDGLCNTRL: Rem g/l control record found
Mat Read #CH_GLC,REC_GLC,0;GLC0;
Mat Read #CH_GLC,REC_GLC,32;GLC1;
Return 
UPGLTEMP: Rem update gl temp file
GLTKEY$ = " ",GLTKEY$ \ GLTKEY$[1,4] = CLIENT Using "####"
GLTKEY$[5,12] = GLACCT Using "########" \ GLTKEY$[13,18] = JRNL Using "######"
Search #CH_GLT,2,1;GLTKEY$,REC_GLT,E \ If E > 1 Gosub ERR_SEARCH
If E = 1
  GLT0 = GLACCT \ GLT0[1] = 0 \ GLT1[0] = JRNL \ GLT1[1] = CLIENT
  E = 2 \ Search #CH_GLT,1,0;GLTKEY$,REC_GLT,E \ If E Gosub ERR_SEARCH
  Mat Write #CH_GLT,REC_GLT,0;GLT0
  Mat Write #CH_GLT,REC_GLT,12;GLT1;
  Search #CH_GLT,4,1;GLTKEY$,REC_GLT,E \ If E Gosub ERR_SEARCH
End If 
Mat Read #CH_GLT,REC_GLT,0;GLT0; \ Mat Read #CH_GLT,REC_GLT,12;GLT1
GLT0[1] = GLT0[1] + GLAMT
Mat Write #CH_GLT,REC_GLT,0;GLT0 \ Mat Write #CH_GLT,REC_GLT,12;GLT1;
Gosub UPGLDET
GLAMT = 0
Return 
UPGLDET: Rem up gl detail file
For X9 = 0 To 6 \ GLD[X9] = 0 \ Next X9
GLD$ = " ",GLD$;GLD1$ = " ",GLD1$;GLD2$ = " ",GLD2$
GLD1 = 0;GLD2[0] = 0;GLD2[1] = 0
GLD[0] = CLIENT
GLD[1] = POSTPER
GLD[2] = H3[3]
If POHR Let GLD[3] = 99 Else Let GLD[3] = 0
GLD[4] = DATE
GLD[5] = ARDATE
GLD[6] = JRNL
GLD$[1,9] = GLACCT Using "#########"
GLD1$[1,30] = VENDNAME$[1,30]
GLD2$ = " P"
GLD2[0] = 374
GLD2[1] = 7
GLDTRN = H0[2]
GLDKEY1$ = " ",GLDKEY1$
GLDKEY1$[1,4] = GLD[1] Using "&&&&"
GLDKEY1$[5,16] = GLD$[1,12]
GLDKEY1$[17,22] = GLD[6] Using "######"
GLDKEY1$[23,30] = GLDTRN Using "########"
GLDKEY1$[31,36] = GLD[2] Using "######"
GLDKEY1$[37,38] = GLD2[1] Using "##"
Search #CH_GLD,2,1;GLDKEY1$,REC_GLD,E \ If E > 1 Gosub ERR_SEARCH
If E = 1
  E = 2 \ Search #CH_GLD,1,0;GLDKEY1$,REC_GLD,E \ If E Gosub ERR_SEARCH
  Mat Write #CH_GLD,REC_GLD,0;GLD;
  Mat Write #CH_GLD,REC_GLD,40;GLD$;
  Mat Write #CH_GLD,REC_GLD,52;GLD1$;
  Mat Write #CH_GLD,REC_GLD,82;GLD2$;
  Mat Write #CH_GLD,REC_GLD,84;GLD1;
  Mat Write #CH_GLD,REC_GLD,92;GLD2;
  Write #CH_GLD,REC_GLD,96;GLDTRN;
  Search #CH_GLD,4,1;GLDKEY1$,REC_GLD,E \ If E Gosub ERR_SEARCH
  GLDKEY2$ = " ",GLDKEY2$
  GLDKEY2$[1,6] = GLD[2] Using "######"
  GLDKEY2$[7,14] = GLDTRN Using "########"
  GLDKEY2$[15,16] = GLD2[1] Using "##"
  GLDKEY2$[17,28] = GLD$[1,12]
  GLDKEY2$[29,32] = GLD[1] Using "&&&&"
  GLDKEY2$[33,38] = GLD[6] Using "######"
  Search #CH_GLD,4,2;GLDKEY2$,REC_GLD,E \ If E Gosub ERR_SEARCH
End If 
Mat Read #CH_GLD,REC_GLD,84;GLD1
GLD1 = GLD1 + GLAMT
Mat Write #CH_GLD,REC_GLD,84;GLD1;
Return 

L_10000: Rem EXTEND COST
If NSTAT = 7 Let QTY = L3[2];LINE_QTY = L3[2] + PL4[1] Else Let QTY = PL4[5];LINE_QTY = PL4[5] + (PL4[1] - PL4[17])
DISP_QTY = QTY;DISP_COST = L2[0] \ Gosub CALC_DISP_EXT
T9 = DISP_EXT
PL4[6] = T9
PL4[0] = L2[0] - (L2[0] * (PL4[2] / 100)) - PL4[3]
If NSTAT = 7 Let QTY = L3[2];LINE_QTY = L3[2] + PL4[1] Else Let QTY = PL4[5];LINE_QTY = PL4[5] + (PL4[1] - PL4[17])
DISP_QTY = QTY;DISP_COST = PL4[0] \ Gosub CALC_DISP_EXT
PL4[7] = DISP_EXT
L3[5] = 0 \ If PL4[13] Let L3[5] = PL4[12] * (LINE_QTY) / PL4[13]
L3[6] = 0 \ If PL4[15] Let L3[6] = PL4[14] * (LINE_QTY) / PL4[15]
Return 
CALC_DISP_EXT: Rem convert qty and cost to cost um, then calc ext  cost
DISP_EXT = FNR(DISP_QTY * DISP_COST)
CNVTA[0] = DISP_COST;CNVTU[0] = 0;CNVTU[1] = L1[5];CNVTU[2] = 2 \ Gosub L_20000
DISP_COST = AMOUNT
If L1[5] = -1 Let DISP_EXT = FNR(DISP_COST * (PL4[12] * (DISP_QTY) / PL4[13]) / 100)
If L1[5] = -3 Let DISP_EXT = FNR(DISP_COST * (PL4[12] * (DISP_QTY) / PL4[13]))
If L1[5] = -2 Let DISP_EXT = FNR(DISP_COST)
Return 
CALC_WGT_UNIT: Rem "rem calc unit cost on weight-based items (using sprod vars!)
CNVTA = WCOST;CNVTU[0] = 0;CNVTU[1] = L1[5];CNVTU[2] = 2 \ Gosub L_20000
WCOST = AMOUNT
If L1[5] = -1 Let AMOUNT = WCOST * (PL4[12] * (WQTY - WFQTY) / PL4[13] / 100 / WQTY)
If L1[5] = -3 Let AMOUNT = WCOST * (PL4[12] * (WQTY - WFQTY) / PL4[13] / WQTY)
Return 
L_10090: Rem TOTAL ORDER
H8[0] = 0 \ H8[1] = 0
PO3[9] = 0;PO3[10] = 0
If OPENLINE And PO1[5] = 0 ! open lines and flat freight
  PO3[6] = 0 \ H8[2] = 0
End If 
U5$ = H0[2] Using "######"
L_10140: Search #PROG_CH[5],3,1;U5$,R9,E \ If E > 2 Gosub ERR_SEARCH
If E Goto L_10250
X2 = U5$[1,6] \ If X2 <> H0[2] Goto L_10250
Gosub L_6000
Mat Read #PROG_CH[5],R9;L1;
If FLAGS[2] Goto L_10140
Gosub L_2800 \ Gosub L_10000
H8[0] = H8[0] + PL4[7]
CNVTU[2] = 1;CNVTU[0] = 0;CNVTU[1] = L1[4];CNVTA = LINE_QTY
Gosub L_20000
PO3[10] = PO3[10] + AMOUNT
H8[1] = H8[1] + L3[5]
PO3[9] = PO3[9] + L3[6]
Goto L_10140
L_10250: Return 
L_17600: Rem GET JULIAN DATE
SCRATCH$ = "" \ Call Time(SCRATCH$)
SCRATCH$[13] = "" \ Call VerifyDate(SCRATCH$,X$,E) \ If E Gosub ERR_SEARCH
DATE = X$
Call DateToJulian(1,X$,X$,E) \ If E Gosub ERR_SEARCH
X2 = X$[1,5]
CURJDATE = X2
Return 
X$ = " ",X$ \ X$[10] = ""
X$[1,3] = Int(X2 / 10 ^ 2 - Int(X2 / 10 ^ 4) * 10 ^ 2) + 10 ^ 2 Using "###"
X$[4,6] = Fra(X2 / 10 ^ 2) * 10 ^ 2 + 10 ^ 2 Using "###"
X$[7,9] = Int(X2 / 10 ^ 4) + 10 ^ 2 Using "###"
X$[4,4] = "/" \ X$[7,7] = "/" \ X$ = X$[2]
Return 
D3[0] = X2;FLAG = 1;X$ = " "
Call "JULIANUTIL",D3[],X$,FLAG
Return 
Call VerifyDate(X$,X$,E) \ If E Let X$ = "    "
X2 = X$[1,6] \ Return 
L_17820: Rem  CONVERT YYMMDD TO JULIAN (RETURN=NOGOOD, +1=OKAY)
X$ = X2 Using "&&&&&&"
Call DateToJulian(1,X$,X$,E) \ If E Return 
X2 = X$[1,5] \ Return 1
D3[0] = X2;D3[1] = X2;FLAG = 0
Call "JULIANUTIL",D3[],X$,FLAG
Return 
X$ = X2 Using "&&&&"
D3[0] = X$[1,2];D3[1] = X$[3,4]
If D3[0] > 67 Let D3[0] = 1900 + D3[0]
If D3[0] < 68 Let D3[0] = 2000 + D3[0]
X$[1,4] = D3[0] Using "&&&&";X$[5,6] = D3[1] Using "&&"
X2 = X$[1,6] \ Return 
CALC_PROD_COSTS: Rem convert cost when po um <> prod um for weighted products
Rem for costs last, freight, misc, and netpo cost
LASTCOST = L2[0]
FREIGHTCOST = L2[1]
MISCCOST = PL4[8]
If L1[5] = -1 Or L1[5] = -3 ! need to bring base upon product weights
  If L2[1]
    CNVTA = L2[1]
    If L1[5] = -1 Let CNVTA = L2[1] * 100
    CNVTU[0] = L1[5];CNVTU[1] = 0;CNVTU[2] = 2
    Gosub L_20000
    FREIGHTCOST = AMOUNT
  End If 
  If PL4[8]
    CNVTA = PL4[8]
    If L1[5] = -1 Let CNVTA = PL4[8] * 100
    CNVTU[0] = L1[5];CNVTU[1] = 0;CNVTU[2] = 2
    Gosub L_20000
    MISCCOST = AMOUNT
  End If 
End If 
NETPOCOST = PL4[0]
If PFU1[11] <> L1[5] ! product cost um <> po cost um
  If PFU1[11] = -1 Or PFU1[11] = -3 Or L1[5] = -1 Or L1[5] = -3 ! weighted item
    If PL4[13] ! has a weight factor
      If L1[5] = -1 Or L1[5] = -3 ! po has weighted cost get base
        Rem last cost convert to base
        If L2[0]
          CNVTA = L2[0];CNVTU[0] = 0;CNVTU[1] = L1[5];CNVTU[2] = 2
          Gosub L_20000
          DISP_COST = AMOUNT
          If L1[5] = -1
            LASTCOST = DISP_COST * ((PL4[12] / PL4[13]) / 100)
          End If 
          If L1[5] = -3
            LASTCOST = DISP_COST * ((PL4[12] / PL4[13]))
          End If 
        End If 
        Rem netpo cost convert to base
        If PL4[0]
          CNVTA = PL4[0];CNVTU[0] = 0;CNVTU[1] = L1[5];CNVTU[2] = 2
          Gosub L_20000
          DISP_COST = AMOUNT
          If L1[5] = -1
            NETPOCOST = DISP_COST * ((PL4[12] / PL4[13]) / 100)
          End If 
          If L1[5] = -3
            NETPOCOST = DISP_COST * ((PL4[12] / PL4[13]))
          End If 
        End If 
        Rem freight cost convert to base
        If L2[1]
          CNVTA = L2[1];CNVTU[0] = 0;CNVTU[1] = L1[5];CNVTU[2] = 2
          Gosub L_20000
          DISP_COST = AMOUNT
          If L1[5] = -1
            FREIGHTCOST = DISP_COST * ((PL4[12] / PL4[13]) / 100)
            FREIGHTCOST = L2[1] * 100
          End If 
          If L1[5] = -3
            FREIGHTCOST = DISP_COST * ((PL4[12] / PL4[13]))
            FREIGHTCOST = L2[1]
          End If 
        End If 
        Rem misc cost convert to base
        If PL4[8]
          CNVTA = PL4[8];CNVTU[0] = 0;CNVTU[1] = L1[5];CNVTU[2] = 2
          Gosub L_20000
          DISP_COST = AMOUNT
          If L1[5] = -1
            MISCCOST = DISP_COST * ((PL4[12] / PL4[13]) / 100)
            MISCCOST = PL4[8] * 100
          End If 
          If L1[5] = -3
            MISCCOST = DISP_COST * ((PL4[12] / PL4[13]))
            MISCCOST = PL4[8]
          End If 
        End If 
      End If 
      If PFU1[11] = -1 Or PFU1[11] = -3
        If LASTCOST
          DISP_COST = (LASTCOST / (PL4[12] / PL4[13]))
          If PFU1[11] = -1 Let DISP_COST = DISP_COST * 100
          CNVTA = DISP_COST
          CNVTU[0] = PFU1[11];CNVTU[1] = 0;CNVTU[2] = 2
          Gosub L_20000
          LASTCOST = AMOUNT
        End If 
        If NETPOCOST
          DISP_COST = (NETPOCOST / (PL4[12] / PL4[13]))
          If PFU1[11] = -1 Let DISP_COST = DISP_COST * 100
          CNVTA = DISP_COST
          CNVTU[0] = PFU1[11];CNVTU[1] = 0;CNVTU[2] = 2
          Gosub L_20000
          NETPOCOST = AMOUNT
        End If 
        If FREIGHTCOST
          DISP_COST = (FREIGHTCOST / (PL4[12] / PL4[13]))
          If PFU1[11] = -1 Let DISP_COST = DISP_COST * 100
          CNVTA = DISP_COST
          CNVTU[0] = PFU1[11];CNVTU[1] = 0;CNVTU[2] = 2
          Gosub L_20000
          FREIGHTCOST = AMOUNT
        End If 
        If MISCCOST
          DISP_COST = (MISCCOST / (PL4[12] / PL4[13]))
          If PFU1[11] = -1 Let DISP_COST = DISP_COST * 100
          CNVTA = DISP_COST
          CNVTU[0] = PFU1[11];CNVTU[1] = 0;CNVTU[2] = 2
          Gosub L_20000
          MISCCOST = AMOUNT
        End If 
      Else 
        If L3[4] ! round out unit of measure
          If LASTCOST
            EXTAMT = FNR(LASTCOST * L3[4])
            LASTCOST = EXTAMT / L3[4]
          End If 
          If NETPOCOST
            EXTAMT = FNR(NETPOCOST * L3[4])
            NETPOCOST = EXTAMT / L3[4]
          End If 
          If FREIGHTCOST
            EXTAMT = FNR(FREIGHTCOST * L3[4])
            FREIGHTCOST = EXTAMT / L3[4]
          End If 
          If MISCCOST
            EXTAMT = FNR(MISCCOST * L3[4])
            MISCCOST = EXTAMT / L3[4]
          End If 
        End If 
      End If 
    End If 
  End If 
End If 
Return 
L_20000: Rem UNIT CONVERSION RETURNS AMOUNT  (rev 01/07/1992)   ! 20040 REM
If CNVTU[2] = 3 Goto L_20050
If CNVTU[2] = 1 And CNVTU[1] = CNVTU[0] Let AMOUNT = CNVTA \ Goto L_20160
If CNVTU[0] = -2 Or CNVTU[1] = -2 Let AMOUNT = CNVTA \ Goto L_20160
If CNVTU[2] = 0 Goto L_20050
If Not(CNVTA) Let AMOUNT = 0 \ Goto L_20160
L_20050: GOTO L_20120: !  If Spc(4) > 1280 Goto L_20120
!Swap 1,"MXPRCONV"
!If CNVTU[2] = 3 Goto L_20160
!L_20080: Signal 2,X1,AMOUNT,FLAG \ If X1 = -1 Let E = 0 \ Gosub ERR_SEARCH
!If X1 <> Spc(6) Goto L_20080
!If CNVTU[2] = 0 Goto L_20160
!If FLAG Let E = FLAG \ Gosub ERR_SEARCH
!Goto L_20160
L_20120: Rem "====== unibasic 5+ logic
Call "MXPRCONV5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
If CNVTU[2] = 0 Goto L_20160
If FLAG Let E = FLAG \ Gosub ERR_SEARCH
AMOUNT = CNVTA
L_20160: Return 

UPDT_ORDLINE: Rem "cct 161949 - Update Sales Order linked to Line
If custom_customer$="MORRISETTE" return ! no update on morrisette
! call programdump("tmp/po374ans.txt!","")
if not(l3[4]) return ! QTY
if not (r1[8]) return ! no header record #
R1[9] = R9
if not (r1[9]) return ! no lines record #
! ALERTS MOVED TO 5000: ROUTINE
rem If custom_customer$="ADMIRAL" return ! no update on  ADMIRAL
If PL4[10] = 0 Return ! ORDER # 
if pl4[11] = 0 return ! LINE #
if p61$[117,117]="Y" and H4[0]=1 RETURN ! DIRECT UPDATED AT 371 RECEIVING TIME
if p61$[117,117]="Y" and H4[0]=5 RETURN ! IMPORT DIRECT UPDATED AT 371 RECEIVING TIME
CLEAR CHAN[]
CHAN[1]=1 ! CNTRL FILE
CHAN[2]=PROG_CH[4] ! POH
CHAN[3]=PROG_CH[5] ! POL
chan[4] = 0 ! customer	1808
CHan[5] = 0 ! order header	1840
chan[6] = 0 ! order line	1888
chan[7] = 0 ! proddesc		2128
chan[8] = 0 ! ros			1856
chan[9] = 0 ! zone		1920 (not already opened)
chan[10]= PROG_CH[0] ! product		1792	
chan[11]= 0 ! rot			1872
chan[12]= PROG_CH[6] ! prodwhse			1744
chan[13]= PROG_CH[10]! prod lot	2528
chan[14]= 0 ! sordlot		2320
chan[15]= 0	  ! cpi det		9928
chan[16]= 0	  ! order type 10108				
Call "POUPSOQ.dl4",CHAN[],R1[],e$,IntCo,rstr$
! Swap 2,"POUPSOQ"
! Chain Write R1
Return 


Updt_Nsfrt: !
if p61$[132,132]<>"Y" return
if not(nsfmcode) return
IF NOT(L2[1]) RETURN ! no freight on line
if not (l3[4]) return ! not qty
IF POMISC[0] <>0 RETURN ! STOCK UPDATE FLAG = y
if not(nonstock) return 
if not (r1[8]) return ! no header record #
R1[9] = R9
if not (r1[9]) return ! no lines record #
If PL4[10] = 0 Return ! ORDER # 
if pl4[11] = 0 return ! LINE #
CLEAR CHAN[]
CHAN[1]=1 ! CNTRL FILE
CHAN[2]=PROG_CH[4] ! POH
CHAN[3]=PROG_CH[5] ! POL
chan[4] = 0 ! customer	1808
CHan[5] = 0 ! order header	1840
chan[6] = 0 ! order line	1888
chan[7] = 0 ! proddesc		2128
chan[8] = 0 ! ros			1856
chan[9] = 0 ! zone		1920 (not already opened)
chan[10]= PROG_CH[0] ! product		1792	
chan[11]= 0 ! rot			1872
chan[12]= PROG_CH[6] ! prodwhse			1744
chan[13]= PROG_CH[10]! prod lot	2528
chan[14]= 0 ! sordlot		2320
chan[15]= 0	  ! cpi det		9928
chan[16]= 0	  ! order type 10108				
Call "POSONSFRT.dl4",CHAN[],R1[],e$,IntCo,rstr$
RETURN

UpdateCPI: ! Update Reserve Stock Amount
	if not(cpiFlag) return ! no cpi
	if not(pomisc[0]) return ! not updating stock
	if l1[0] <> 3 return ! not closed - more to come
	if l3[2] = l3[3] return ! no overage or underage, nothing to adjust
	! OK line is over or under and closed
	cpiAdjust = l3[3] - l3[2]
	! find the latest open contract
	! for update
	K_CPI$ = " ",K_CPI$
	K_CPI$[1,12] = A$[140,151]
	uCPIRec = 0
	jNewestDate = 0
	do
		R_CPI = filegetcpidet(e$,cpidChan,">",2,K_CPI$,cpid.)
		if R_CPI <= 0 exit do
		if K_CPI$[1,12] <> A$[140,151] exit do
		if cpid.PurWhse <> l1[1] goto skipCPIRec ! wrong wh
		if cpid.ResStock <= 0 goto skipCPIRec ! not a res-stock contract
		R_SP = filegetspecprice(e$,spChan,"=",2,K_CPI$,specp.)
		if R_SP <= 0 goto skipCPIRec ! shouldn't happen
		if not(specp.StartDate) goto skipCPIRec ! no start date
		if specp.CancelDate
			tmp$ = specp.CancelDate using "&&&&&&"
			call DateToJulian(1, tmp$)
			if val(tmp$) < JToday goto skipCPIRec ! no longer active
		end if
		! convert reserve stock amount to base
		CNVTA = cpid.ResStock
		CNVTU[0] = specp.UMQty;CNVTU[1] = 0;CNVTU[2] = 1
		Gosub L_20000
		baseResStock = Amount
		if baseResStock - specp.QtySinceStart <= 0 goto skipCPIRec ! contract completely sold
		tmp$ = specp.StartDate using "&&&&&&"
		call DateToJulian(1, tmp$)
		if val(tmp$) <= jNewestDate goto skipCPIRec ! not newer than what we have
		! OK - got the newest active contract for this item / WH
		jNewestDate = val(tmp$)
		uCPIRec = R_CPI
		uCPIUM = specp.UMQty
		skipCPIRec:!
	loop
	if not(uCPIRec) return ! contract not found
	! got one - update the contract
	Read record #cpidChan,uCPIRec,0;cpid.
	! convert reserve stock amount to base
	CNVTA = cpid.ResStock
	CNVTU[0] = uCPIUM;CNVTU[1] = 0;CNVTU[2] = 1
	Gosub L_20000
	baseResStock = Amount
	baseResStock = baseResStock + cpiAdjust
	! convert new reserve stock amount back
	CNVTA = baseResStock
	CNVTU[0] = 0;CNVTU[1] = uCPIUM;CNVTU[2] = 1
	Gosub L_20000
	cpid.ResStock = Amount
	write record #cpidChan,uCPIRec,0;cpid.;
Return
OPEN_FILES: Rem	    ! currently at 23 fchan
	For I = 0 To MAX_CH
		Read TMP_CH
		If (I = 13 Or I = 14 Or I = 19) And (P60$[9,9] <> "F" And P60$[9,9] <> "L") Goto SKIP_OPEN
		If I > 19 And I < 22
			If P9$[17,17] <> "Y" Goto SKIP_OPEN
			If Not(POGLFLAG) Goto SKIP_OPEN
			If FCHAN[I] <> -1
				If I = 20 Let CH_GLT = FCHAN[20]
				If I = 21 Let CH_GLC = FCHAN[21]
				! If I = 22 Let CH_GLD = FCHAN[22]
				Goto SKIP_OPEN
			End If 
		End If 
		If I = 15 And Not(SPO) Goto SKIP_OPEN
		If I = 16 And FLAGRF <> 1 Goto SKIP_OPEN
		If I = 19 And P61$[60,60] <> "Y" Goto SKIP_OPEN
		if i=23 and fchan[i]<>-1
			let ch_nsinvt=fchan[23]
			prog_ch[23]=fchan[23]
			goto skip_open:
		endif
		IF I=22 
			if p61$[74,74]="Y" or  holdforpo<>0
				IF fchan[i]<>-1
					let ch_rolnew=fchan[22]
					let prog_ch[22]=fchan[22]
					goto skip_open:
				endif
			else
				goto skip_open:
			endif 
		endif
		If FCHAN[I] = -1
			!CHNL = 99
			!Gosub GETCHAN
			CHNL = Findchannel()
			PROG_CH[I] = CHNL
			If TMP_CH = -1
				If I = 15 Let F$ = COMP Using "2/POCTFLE#"
				If I = 16 Let F$ = "3/PORFLINE" + Str$(COMP)
				If I = 19 Let F$ = "4/FIFOSPC" + Str$(COMP)
				If I = 20 ! po tmp file
					If POHR !
						F$ = "6/GLPOPRONTO" + Str$(COMP)
						Call FindF(F$,A9)
						If Not(A9)
							If (RESTART)
								! Print @0,23;'CL';"G/L PO Pronto Interface is not found ";
								Gosub ERR_SEARCH
							Else 
								CMD$ = "[1:10] ",F$,"!"
								Build #PROG_CH[I],CMD$
								TMPREC = 9 \ Search #PROG_CH[I],0,1;I$,TMPREC,E \ If E Gosub ERR_SEARCH
								TMPREC = 1 \ Search #PROG_CH[I],0,0;I$,TMPREC,E \ If E Gosub ERR_SEARCH
								Close #PROG_CH[I]
							End If 
						End If 
					Else 
						F$ = "6/GLPOTEMP" + Str$(WHSE) + Str$(COMP)
						Call FindF(F$,A9)
						If A9 And Not(RESTART)
							! Print @0,23;'CL RB';"G/L Po Interface in use elsewhere...";
							! Signal 3,30
							Goto OUTEND
						End If 
						If RESTART And Not(A9)
							! Print @0,23;"G/L - PO Interface Not Found "; \ Signal 3,30
							Gosub ERR_SEARCH
						End If 
						If Not(A9)
							CMD$ = "[1:10] ",F$,"!"
							Build #PROG_CH[I],CMD$
							TMPREC = 9 \ Search #PROG_CH[I],0,1;I$,TMPREC,E
							If E Gosub ERR_SEARCH
							TMPREC = 1 \ Search #PROG_CH[I],0,0;I$,TMPREC,E
							If E Gosub ERR_SEARCH
							Close #PROG_CH[I]
						End If 
					End If 
					CH_GLT = PROG_CH[I]
				End If 
				If I = 21
					F$ = "6/GLPOCNTRL" + Str$(COMP)
					CH_GLC = PROG_CH[I]
				End If 
				!If I = 22
				! F$ = "4/GLPODETL" + Str$(COMP)
				! CH_GLD = PROG_CH[I]
				!nd If
				IF I=22 
					if p61$[74,74]="Y" or  holdforpo<>0
						let ch_rolnew=prog_ch[i]
						Read #1,88,1888;F$;
					else
						goto skip_open:
					endif
				endif
				IF I=23
					F$ = COMP Using "4/NSINVTRANS#" 
					let ch_nsinvt=prog_ch[i]
				endif
				if i=25
					if p61$[104,104]="Y"
						LET F$=COMP USING "2/PRODROLL#"
						let ch_rollid=prog_ch[i]
					endif
				endif
				if i=24
					if p61$[104,104]="Y"
						LET F$=COMP USING "3/SPOROLL#"	
						LET CH_POROLL=PROG_CH[i]
					endif
				endif
				Open #PROG_CH[I],F$
			Else 
				Read #1,88,Abs(TMP_CH);F$;
				If TMP_CH > 0 Open #PROG_CH[I],F$
				If TMP_CH < 0 Ropen #PROG_CH[I],F$
			End If 
		Else 
			PROG_CH[I] = FCHAN[I]
		End If 
		SKIP_OPEN: Rem
	Next I
	Data "1792","-2400","-2976","416","2416","2432","1744","1568","2448","2336","2528","-1088"
	Data "-1728","3008","3024","-1","-1","2512","2768","-1", "-1", "-1"
	Data "-1"," -1"," -1","-1"
	sqlChan = OpenMySQLMirror(e$)
	if cpiFlag
		cpidChan = openfile(9928,intCo)
		if cpidChan = -1
			cpiFlag = 0
		else
			spChan = openfile(-1936,intCo)
		end if
	end if
Return 
CLOSE_FILES: Rem
For I = 0 To MAX_CH
  If (I = 13 Or I = 14 Or I = 19) And (P60$[9,9] <> "F" And P60$[9,9] <> "L") Goto SKIP_CLOSE
  If I = 15 And Not(SPO) Goto SKIP_OPEN
  If I = 16 And FLAGRF <> 1 Goto SKIP_CLOSE
  If I = 19 And P61$[60,60] <> "Y" Goto SKIP_CLOSE
  If I > 19 And I < 22
    If P9$[17,17] <> "Y" Goto SKIP_CLOSE
    If Not(POGLFLAG) Goto SKIP_CLOSE
  End If 
  If FCHAN[I] = -1 
	IF PROG_CH[I]>1 
		Try
			Close #PROG_CH[I]
		else
			! no error
		end try
	endif
  endif
SKIP_CLOSE: Rem
Next I
if sqlChan <> -1 close #sqlChan
if cpiFlag close #cpidChan,#spChan
Return 
ERR_SEARCH: Rem
ENUM = E ;ELINE = Spc(16);CTERR = 0
If E = 5 Let CTERR = Err(8)
msg$ = "RETURN STATUS",(E + (CTERR * .001))
msg$ = msg$,"/ STATEMENT",ELINE," IN PROG "
e$ = msg$                            
Call programdump("/tmp/po374a.se!","") 
Call programdump()                   
E$=msg$ \ Error 10000
Return ! En

OUTEND: Rem "================================= exit
Gosub CLOSE_FILES
!End 
!Stop 
!! OUTEND HERE !!!
Rem {begin rtn.error.s}
Else
ERR_TRAP: Rem *Error routine (escape trap)   V3.1 8/94 G.DOSCHER/REK
!
include "src/callmainerrnet.inc"
end try
End ! the whole program
