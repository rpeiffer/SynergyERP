!! --- prodm
! description prod rec programs  
!
! loadsave -w -n 100,10 -o prog/dxport/prodm.dl4 src/prodm.src
!
! 1.0 mm/dd/yyyy change??
! 05/07/2008  revised prod & prodwhse structs
!
!include copyright, common libs, common intrinsics
include "src/copyright.inc"
!
! BUG FIX COMMENT and NEW FEATURE
!
!include structure,filehandler libs & default structure dims
!
include "src/inc/fileprod.inc" ! product
include "src/inc/sql_prod.inc" ! SQL product
include "src/inc/filea80vm.inc" ! vendor
include "src/inc/filematcode.inc" ! material code
include "src/inc/filesprodcatgy.inc" ! product category 
include "src/inc/fileprodwhse.inc" ! product warehouse
include "src/inc/sql_prodwhse.inc" ! product warehouse
include "src/inc/fileprdkeywrd.inc" ! product key word
! include "src/inc/fileprodprbk.inc" ! product price book
include "src/inc/filesyngprbk.inc" ! synergy price book/Grade
include "src/inc/fileproduda.inc" ! product user define
include "src/inc/fileprodsls.inc" ! product sales
include "src/inc/filemsdfle.inc" ! msds
include "src/inc/filehazname.inc" ! product, hazard ship to name
include "src/inc/filecosthist.inc" ! cost history
!
! *declare additional dl4 intrinsic subs & functions
Declare Intrinsic Function FindChannel
Declare Intrinsic Sub Logic,JuliantoDate, programdump, env, FindF
!
! *declare additional external libs & subs & functions
!
External Lib "ubsprodsls.dl4"
Declare External Sub prodsls
!
External Lib "net679lp.dl4"
Declare External Sub prodsoldto
!
External Lib "ubsprconv.dl4"
Declare External Function XAmount, Xunit$
!
External Lib "libprodconv.lib"
Declare External Function ConvProdAmount
!
External Lib "libgeneral.lib"
Declare External Sub SubErr,CreateNetStatus
!
External Lib "ubsfunc.dl4"
Declare External Function OpenFile,chkaltitem$,PDate$,CHKBADCHARS
Declare External Sub UserCntrl,LogAccess
Declare External Function OpenMySQLMirror
!
External lib "libprodlist.lib"
Declare external sub AltVendorList,KeyWordsList
!
External lib "libproddisplay.lib"
Declare external sub PriceBookDisplay,SafetyHazardDisplay,ShelfLifeDisplay
Declare external sub ProdInfoSection,ProdSizeDisplay,UnitOfMeasureDisplay
Declare external sub ProdItemDisplay,VendorMfgDisplay,PriceControlDisplay
Declare external sub MarkupTableDisplay,UserDefineDisplay
!
External Lib "libprodwords.lib"
Declare external sub dprdkwrd,aprdkwrd,dpturbo,apturbo
!
External Lib "libprod.lib"
Declare External sub ProdList,mkcosthist
Declare External Function getumrec,ChkPrdUM
!
External Lib "libprodwh.lib"
Declare External Function getwhavail
!
External Lib "libprodwhlist.lib"
Declare External Sub ProdWhCostHst
!
External Lib "mx671cc.dl4"
Declare External Sub prodcchg
!
External Lib "serpmxload5l.dl4"
Declare External Sub Mxload5l,mxload5pv
!
External Lib "libcpi.lib"
Declare External Sub cpiinquiry
!!Start!Dci2
External Lib "liblookuptable.lib"
Declare External Sub PriceBookStatusDesc
Declare External Function PriceTypeDesc$

External Lib "libfilematcode.lib"
Declare External Sub filedroplistmatcode

External Lib "libfilesprodcatgy.lib"
Declare External Sub filedroplistsprodcatgy

External Lib "libfilecommhead.lib"
Declare External Sub filedroplistcommhead

External Lib "libfileccodesz.lib"
Declare External Sub filedroplistccodesz

External Lib "libfilebrktbl.lib"
Declare External Sub filedroplistbrktbl

External Lib "libfileptaxtype.lib"
Declare External Sub filedroplistptaxtype

External Lib "libfilegbkgrade.lib"
Declare External Sub filedroplistgbkgrade

External Lib "libfilegbkcolor.lib"
Declare External Sub filedroplistgbkcolor

External Lib "libfilegbkfinish.lib"
Declare External Sub filedroplistgbkfinish

External Lib "libfilegbksection.lib"
Declare External Sub filedroplistgbksection

External Lib "libfilegbkgclass.lib"
Declare External Sub filedroplistgbkgclass

External Lib "libfilefsctable.lib"
Declare External Sub filedroplistfsctable

!External Lib "libfilepricemark.lib"
!Declare External Sub filedroplistpricemark

External Lib "libfilepoocnfrt.lib"
Declare External Sub filedroplistpoocnfrt

External Lib "libfilepocduty.lib"
Declare External Sub filedroplistpocduty

External Lib "libfileloadmarkx.lib"
Declare External Sub filedroplistloadmarkx

External Lib "libfilecostgrp.lib"
Declare External Sub filedroplistcostgrp

External Lib "upcxref.dl4"
Declare External Sub UPCADDEDIT,UPCLookup,UPCINQUIRY
Declare External Sub EDTCUSTGRP

!!End!Dci2
! program subs/functions
Declare Sub ProdMain, MYSales, CostChanges, SScan, OpenFiles
Declare Sub listsprodmark,listpricemark,SndLists,ProdSave
Declare Sub LBBased,plcprcupdt,PRICEFAC,ChkCWFlag,ProdSpec
Declare Sub cpyprod,DelProd,updtusrprd,listudcatgy,WebInfo
Declare Sub UWVEND,srlninfo,shzlist,EdtCosts,update_cost_hist
Declare Sub updtprdref,GetNewLPMrk
Declare Function conv_cost,getumfactor,checkum
!
!--------------------------------------------------------------------
!
!
Try 
! **main procedure
Option String Redim is legal ! in case subs dim/use same names
OPTION GOSUB NESTING 16 ! normal is 8
!
! dim variables used by program
!
dim e$[500],buttonlist$[5,50],nextlist$[5,100] !error handling variables
!
Dim 1%,x1[9],tmp1,UCA5[10],status,yy,cnvtu[2],vitemflag
Dim 1%,MthDays,ARMonth,recalcnew,2%,BDays[24]
Dim 1%,ch_prodref,ch_prodrefs
dim 2%,x2[9],currdate,tmp2,Q0[1],maxcnt \ maxcnt=100 ! init max records in arrays for list
Dim 2%,Q0[1],FChan[9],UPC[10]
Dim 3%,amount,COST_LEV[4],COMM_LEV,COLLSEC,HIDECOST,ProdRec
dim 3%,x3[9],tmp3,PRRec,VMRec,MCRec,R[99]
dim prod$[12],pum$[4],matdesc$[25],pcatdesc$[24],sub1desc$[30],sub2desc$[30]
Dim SPRSD$[30],UM$[4],UDCAT$[100],X$[20],cmcdesc$[16],PRODURL$[50]
Dim HLDLprod$[35]
Dim 1%,VNE,mfrname$[30],3%,VNR
Dim 1%,WHE,WHC,WHK$[14],3%,WHR
Dim 3%,amt,UDCAT[10],AA
Dim 3%,LBUM,LBSUM,RLUM
!
dim action$[30],options$[30],userid$[8],b$[200],action1$[30],action2$[30],fields$[1,30]
Dim bsdel$[10],esdel$[10],rdel$[10],fdel$[10],rstr$[2000]
dim tmp$[1200],tmp1$[2000],tmp2$[300],Custom_customer$[30]
Dim dlog$[50],Prod$[12],unit$[4],XDate$[10],keynext$[50]
Dim UCA2$[50],TUID$[10],p9$[50],p60$[50],p61$[256]
dim Message$[1000],WebStr$[600],SessionID$[200],KPROD$[60]
dim SearKey$[64],ProdKey$[64],VNC,vendname$[30],VNK$[6]
Dim QMASK$[20],PMASK$[20],EMASK$[20],DEC$[5],UPC1$[20]
dim Blank$[100] \ Blank$=" ",Blank$
B$=" ",B$ ! alt blank$
dim M2$[2] \ M2$="##"
dim M32$[6] \ M32$="###.##"
dim M52$[8] \ M52$="#####.##"
dim M6$[6] \ M6$="######"
dim M92$[12] \ M92$="#########.##"
!
dim List$[maxcnt,600] ! for .net 
!
Def Struct slsInfo 
  Member mm$[16]
  Member unitsale$[30]
  Member netsale$[30]
  Member costsale$[30]
  Member profit$[30]
  Member gp$[10]
End Def
!
Dim sls.[13] as slsInfo
dim PR. as prod ! product
dim sql_prod. as sql_prod
dim TmpPR. As prod ! dupe of prod
dim Duppr. as prod ! for alts,etc
dim VM. as a80vm ! vendor
dim MC. as matcode ! material code
dim PC. as sprodcatgy ! product category
dim PRW. as prodwhse ! product warehouse
dim sql_prodwhse. as sql_prodwhse
!dim PB. as prodprbk ! price book
dim PB. as syngprbk ! synergy price book/Grade
dim KW. as prdkeywrd ! prod key word
dim UDA. as produda ! product user define
dim prdsls. as prodsls ! product 24 mth sls
dim msds. as msdfle ! msds file
Dim PCH. as costhist ! cost history

Def FNR(H) = Int(Abs(H) * 100 + .5) * .01 * Sgn(H)
DEF FNT(X)=SGN(X)*(INT(ABS(X)*1000+.5)/1000)
sqlChan = -1
!
!!Start!Dci2

Dim mode$[3]

!!End!Dci2
!
tmp$="HOME" \ system 28,tmp$
Let dlog$=tmp$ + "/files/6/dx.log" 
!
call dxopen()
!
returnstatus=1 !ok
!
Call GetSession(e$,CTLC,options$,action$,UserID$,intCo,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$,Action1$,Action2$)
!
Try 
  TUID$=UserID$+Blank$
  If Len(TUID$)>10 let TUID$[11]=""
  Call UserCntrl(TUID$,UCA2$,UCA5[],status,intCo)
  Let COST_LEV[0]=UCA5[0]
  Let COST_LEV[1]=UCA5[1]
  Let COST_LEV[2]=UCA5[2]
  Let COST_LEV[3]=UCA5[3]
  Let COMM_LEV=UCA5[4]
  Let COLLSEC=UCA5[6]      
  If UCA2$[28,28]="Y" then Let hidecost=1
  If UCA2$[28,28]="N" then Let hidecost=0
Else
  Rem
End Try
! Call dxsave(0,"tmp/prodin.txt!") ! save web data sent

mat read #ctlc,19,50;p9$;
mat read #ctlc,60,50;p60$;
mat read #ctlc,61,0;p61$;
mat read #ctlc,115,60;custom_customer$;
custom_customer$=UCase$(Trim$(custom_customer$))
tmp$=" ",tmp$
clear tmp$ ! make sure nothing in it!
tmp$[1,2]=tim(8) using "&&"
tmp$[3,4]=tim(9) using "&&"
tmp$[5,6]=tim(10) using "&&" ! yymmdd
currdate=tmp$[1,6]
mat read #CTLC,11,0;BDays; ! business days per month
read #CTLC,0,120;ARMonth; 
MthDays=Bdays[ARMonth]
If MthDays<=0 let MthDays=21
Let Dec$="#",Dec$
action$=UCase$(action$)
 action$=RTrim$(Action$) ! "trim spaces from end
 action1$=UCase$(action1$)
 action1$=RTrim$(Action1$) ! "trim spaces from end
 action2$=UCase$(action2$)
 action2$=RTrim$(Action2$) ! "trim spaces from end
ADDEDIT=0
IF ACTION2$="ADD" OR ACTION2$="COPY" OR ACTION2$="EDIT" LET ADDEDIT=1

tmp$=""
Call DXGet("prodid",tmp$)
If tmp$="" CALL DXGET("keyvar",tmp$) ! not sent
tmp1$=chkaltitem$(e$,intco,tmp$)
tmp1$=RTrim$(tmp1$)
If tmp1$<>"" ! found an altitem
  ! Call DXSet("prodid",tmp1$) ! reset product code
  ! Call DXSet("keyvar",tmp1$) ! used places as this
  ! call dxset does not change any file - it sends it as output?
  Prod$=UCase$(tmp1$)+Blank$ ! use this instead of add'l calls
Else ! not found
  Prod$=UCase$(tmp$)+Blank$ ! use what we got
Endif
If Len(Prod$)>12 let Prod$[13]=""
call LogAccess(e$,"Product ID: "+prod$)
Mat read #ctlc,115,40;q0;
if q0[1]<2 let q0[1]=2
if q0[1]>5 let q0[1]=4
Let Qmask$="--------#.##"
	If Q0[1] Let Pmask$="------------.",Dec$[1,Q0[1]]     !price mask        
	Let Emask$="-$$$$$$$$$$$$.##"  !ext. price mask
! 12/2010 - DO NOT ALLOW PRODUCTS WITH SPECIAL CHAR AS 1ST CHAR
X$=PROD$[1,1] ! no space,etc
PCOK=0
IF X$>="0" AND X$<="9" LET PCOK=1 ! NUMBER
IF X$>="A" AND X$<="Z" LET PCOK=1 ! LETTER - it's always UPPERCASE
strgok=chkbadchars(e$,PROD$) ! CHECK FOR SPECIAL/OTHER BAD CHARS
if action$<>"READ" and action$<>"MAIN" let pcok=1 ! all the rest may not send code
IF NOT(PCOK) or not(strgok)
	ReturnStatus=0
    Message$="Error, Product Code must start with a letter or number"
	If not(strgok) let Message$="Error, Product Code contains invalid characters"
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	goto PMnDone
Endif
!
Select Case action$
  Case "READ","MAIN"  !										doc=Prodm-GetData.doc
    !  plus a document for inquiry not found anywhere
    Call ProdMain() ! uses "keyvar" instead of "prodid"
    !
  case "SEARCH" ! product scan (STANDARD-NonOrder)			doc = prodscan.doc
	!
	Let ReturnStatus=1
	Message$="OK"
	X2=0 ! normal scan
	Call ProdList(e$,IntCo,List$[],maxcnt,ctlc,prc,pwc,x2,0,"",UserId$)
	If E$<>""
	  Let ReturnStatus=0
	  Message$=E$
	Endif
	call AddToStr(e$,rstr$,List$[])
	!
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	!if debugdetail
	!	dmsg$="Product Search sent "+Message$ \ Call updatelog(debug)
	!Endif
	GAct=1 ! okay
		! end of prodsearch
  Case "MPPRDLIST" ! morrisette prod list w/whse qty		doc=MPProductList.doc
	Let ReturnStatus=1 ! task 32627
	Message$="OK"
	X2=100 ! special custom scan
	Call ProdList(e$,IntCo,List$[],maxcnt,ctlc,prc,pwc,x2,0,"",UserId$)
	If E$<>""
	  Let ReturnStatus=0
	  Message$=E$
	Endif
	call AddToStr(e$,rstr$,List$[])
	!
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	!if debugdetail
	!	dmsg$="Product Search sent "+Message$ \ Call updatelog(debug)
	!Endif
	GAct=1 ! okay
	! end of MPPRDLIST

  Case "DLISTS" !											doc=Prodm-GetLists.doc
	! send droplists for entry/edit
	returnstatus=1
	Message$="OK"
	call openfiles()
	!
	call SndLists()
	!
  Case "UDCATLIST"  !										doc=Prodm-GetUDCatgyList.doc
	! send udcatgy list (can be very large!)
	returnstatus=1
	Message$="OK"
	call openfiles()
	!
	call listudcatgy()
	!
  Case "WKSALES"
    !
    Chain "weeklysls.dl4"
    !
  Case "LPSOLDTO"
    !
    ! Call DXGet("prodid",prod$) \ prod$=UCase$(prod$)
    Call DXGet("keynext",keynext$) \ keynext$=UCase$(keynext$)
    Call prodSoldto(intCo,intSls,debug,dlog$,prod$,keynext$,ii ,ss, iLimit)
    !
  Case "MYSALES"
    !
    ! Call DXGet("prodid",prod$) \ prod$=UCase$(prod$)
    Call MYSales()
    !
  Case "COSTCHANGES" ! show changes							doc=CostChanges_001.doc
    !
    Call CostChanges()
	! 
  Case "SSCAN" ! 
    !
    Call SScan()
    !
  Case "STOCK"
    !
    Chain "stockinq.dl4"
    !
  Case "INVENTORY" !										doc=Inventory_001.doc
	!
	Chain "invttrans.dl4"
	!
  Case "FIFO"
	!
	Chain "fifoinq.dl4"
	!
  Case "ORDERS" !											doc=ProdOrders.doc
    !
	Chain "prodordlist.dl4"
	!
  Case "PRICETABLE" !										doc=ProdPriceTable.doc
	! is also in the relatedlinks as part of "price/cost control"
	! as this isn't working, put the tables to here
	! need the open, get, status, etc in here also
	! call dxget("prodid",Prod$) \ Prod$=ucase$(Prod$)
	! Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
	call OpenFiles()
	  !
	  row=2
      SearKey$=Prod$
      ProdRec=filegetprod(e$,PRC,"=",1,SearKey$,PR.) ! product mode=2 dir=1
      !
      ! initialize status
      if ProdRec<0 ! Product record not found
	    clear PR.
	    ReturnStatus=0
	    Message$="Error, Product not found"
      else
	    ReturnStatus=1
	    Message$="OK"
      endif
	  !
	  ! product information section, ID and desc
	  ! call ProdInfoSection(e$,0,List$[],PR.) ! (lets not send)
	  ! call AddToStr(e$,rstr$,List$[]) ! no prodinfo sent
	  call MarkupTableDisplay(e$,ProdRec,List$[],PRMC,SPMC,CTLC,PR.) ! mark up table
	  call AddToStr(e$,rstr$,List$[])
	  !
	  ! status section
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
	  !
  Case "PRODNOTES" !										doc=Prodm-GetSupptNotes.doc
	! prod spec												doc=Prodm-SubmitSupptNotes.doc
	ReturnStatus=1
	Message$="OK"
	Call prodspec()
	if e$[1,15]="RS=5  NEXTLINE=" ! 33263 - limit 100 per request
		returnstatus=5
		message$=E$[7] ! "NEXTLINE=" and the line(spec) number
		Clear e$ ! clear bogus e$
	endif
	! status section
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
	  !
  Case "WEBINFO" !											doc=Prodm-GetWebInfo.doc
	! .net stuff											doc=Prodm-SubmitWebInfo.doc
	! moved to own section
	ReturnStatus=1
	Message$="OK"
	Call webinfo()
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	!
	! end of webinfo
  Case "SNINFO" !											doc=Prodm-GetSNInfo.doc
	! serial number defaults								doc=Prodm-SubmitSNInfo.doc
	ReturnStatus=1
	Message$="OK"
	Call srlninfo()
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	!
	! end of SNINFO
  Case "GETVENDOR" ! get vendor name/check					doc=Prod-GetVendorName.doc
	! get vendor name for Product & ProdWhse Entry/edit
	returnstatus=1
	message$="OK"
	VNC=OpenFile(-2400,IntCo) \ if vnc=-1 error 42
	call dxget("VENDID",tmp$)
	let vend=tmp$
	if Vend>0
		VNK$ = Vend using M6$
		VMRec=filegeta80vm(e$,VNC,"=",1,VNK$,VM.)
	Else
		vmrec=0
	Endif
	if VMRec<0 
		let	VendName$="Not on file"
		returnstatus=0
		message$=VendName$ ! we allow zero
	else 
		VendName$=VM.Name$
	Endif
	Clear List$[]
	List$[0]=bsdel$,"VENDNAME",fdel$
	List$[1]="ID",fdel$,"NAME",fdel$
	List$[2]=Str$(VEND),fdel$,RTrim$(VendName$),fdel$
	List$[3]=esdel$
	call addtostr(e$,rstr$,List$[])
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	!
	! end of GetVendor
  Case "CHGCOST" ! changed cost or table					doc=Prodm-CostPriceCalc.doc
	! if user chgs costs or tables - recalc & send
	returnstatus=1
	message$="OK"
	call OpenFiles() 
	! enter stuff
	call edtcosts()
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	!
	! end of CHGCOST
  Case "CHGUMS" ! changed UM fields					doc=Prodm-ChangeUM.doc
	! if user chgs UM's - just get/check/write like PM - leave Base costs/prices same
	returnstatus=1
	message$="OK"
	call OpenFiles()
	! get special um's rec id #
		UM$="LB  "
		Search #ccc,2,1;UM$,r[1],E
		if not(e)
			LBUM=R[1]
		Endif
		UM$="LBS "
		Search #ccc,2,1;UM$,R[2],E
		if not(e)
			LBSUM=R[2]
		Endif
		um$="ROLL"
		SEARCH #ccc,2,1;UM$,R[3],E
		if not(e)
			RLUM=r[3]
		Endif
	! enter stuff
	call edtcosts()
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	!
	! end of CHGUMS
  Case "UPDVENDID"	!								doc=Prodm-SavePrimaryVendor.doc
	! Ed R wants vendor ID to update NOW instead of on submit
	!  if vitemflag=0 or vitemflag=2 ! only vend or both
	call OpenFiles()
	ProdKey$=prod$
	Prodrec = filegetprod(e$,PRC,"=",1,ProdKey$,PR.)
	if Prodrec<=0 goto UDVIDDone ! no existing - no update
	read record #PRC,prodrec,0;tmppr.; ! for compare
	call dxget("VUWHSE",tmp$) \ udwvend=0
	  if UCase$(RTrim$(tmp$))="Y" let udwvend=1 ! update whse w/vendor chg
	call dxget("PrimaryVendor",tmp$)
	x2=tmp$ ! should have already done GETVENDOR
	if x2=0 and p61$[126,126]="Y"
		returnstatus=0
		message$="Vendor is required!"
		goto UDVIDDone
	endif
	if x2<0 OR X2>999999
		let returnstatus=0
		let message$="Vendor Code Must Not Be Greater Than 999999"
		goto UDVIDDone
	ENDIF
	if x2<>pr.primvend and x2<>0 let vitemflag=0 ! vitemflag+1 ! 0 or 2=both
	pr.PrimVend=tmp$
	if x2=0 let udwvend=0 ! DO NOT CHANGE TO ZERO!!
	tmppr.BlankForKey$=blank$ ! always!!
	tmppr.Spare1$=blank$ ! same
	write record #PRC,Prodrec,0;tmppr.; ! write OLD w/space
	! ok - update prod
	pr.BlankForKey$=blank$
	pr.Spare1$=blank$;mode$="c"
	aa=fileupdateprod(e$,PRC,mode$,Prodrec,PR.,0,0,-1) ! w/audit(not working!?)
	if aa<0 ! bad stat
		Returnstatus=0
		Message$=E$
	Else
		returnstatus=1
		Message$="OK"
		if tmppr.PrimVend<>pr.PrimVend ! update AFTER prod update
			if udwvend=1 ! want's update
				call uwvend()
			Endif
		Endif
	endif
	UDVIDDone: ! status
	Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	Call AddToStr(e$,rstr$,WebStr$)
    call SetOutPut(e$,rstr$)
  Case "UPDVENDITEM"  !								doc=Prodm-SaveVendorItem.doc
	! Ed R wants vendoritem to update NOW instead of on submit
	! if vitemflag=1 or vitemflag=2 ! only vitem or both
	call OpenFiles()
	ProdKey$=prod$
	Prodrec = filegetprod(e$,PRC,"=",1,ProdKey$,PR.)
	if prodrec<=0 goto UDVITDone
	Read record #PRC,Prodrec,0;tmppr.; ! for compare
	call dxget("VUWHSE",tmp$) \ udwvend=0
	if UCase$(RTrim$(tmp$))="Y" let udwvend=1 ! update whse w/vendor chg
	vitemflag=0 ! flag for which item changed: vend or venditem
	   call DXGet("VendorItemCode",tmp$) \ tmp$ = ucase$(tmp$)
	   if rtrim$(tmp$)<>rtrim$(pr.venditem$) let vitemflag=1 ! changed vitem
	   pr.VendItem$=tmp$,b$
	   strgok=chkbadchars(e$,pr.VendItem$)
	   if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Vendor Item"
		goto UDVITDone
	   Endif
	if RTRIM$(PR.VENDITEM$)="" LET udwvend=0 ! no update to blank!!
	tmppr.BlankForKey$=blank$ ! always!!
	tmppr.Spare1$=blank$ ! same
	write record #PRC,Prodrec,0;tmppr.; ! write OLD w/space
	! update product
	pr.BlankForKey$=blank$
	pr.Spare1$=blank$;mode$="c"
	aa=fileupdateprod(e$,PRC,mode$,Prodrec,PR.,0,0,-1) ! w/audit(not working!?)
	if aa<0 ! bad stat
		Returnstatus=0
		Message$=E$
	Else
		returnstatus=1
		Message$="OK"
		if tmppr.VendItem$<>pr.VendItem$ ! update AFTER prod update
			if udwvend=1 ! want's update
				call uwvend()
			Endif
		endif
	endif
	UDVITDone: ! status
	Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	Call AddToStr(e$,rstr$,WebStr$)
    call SetOutPut(e$,rstr$)
  Case "RELATEDLINKS"
 	!
	! call dxget("prodid",Prod$) \ Prod$=ucase$(Prod$)
	!
	if Action1$="WAREHOUSE" !								doc=WarehouseInput.doc
	  options$="PRODWH"
      Call dxset("option",options$)
	  action$="INPUT"
      Call dxset("action",action$)
	  !
	  clear List$[]
 	  List$[0]=bsdel$,"WareHouse",fdel$
	  List$[1]="Option",fdel$,"Action",fdel$
	  List$[2]=options$,fdel$,action$,fdel$
	  List$[3]=esdel$ ! end of section
	  call AddToStr(e$,rstr$,List$[])
	  !
	else ! not warehouse (all the rest)
	  call OpenFiles()
	  !
	  row=2
      SearKey$=Prod$
      ProdRec=filegetprod(e$,PRC,"=",1,SearKey$,PR.) ! product mode=2 dir=1
      !
      ! initialize status
      if ProdRec<0 ! Product record not found
	    clear PR.
	    ReturnStatus=0
	    Message$="Error, Product not found"
      else
	    ReturnStatus=1
	    Message$="OK"
      endif
	  !
	  If action2$<>"SAVE" ! Not on save
	  ! product information section, ID and desc
		call ProdInfoSection(e$,0,List$[],PR.)
		call AddToStr(e$,rstr$,List$[])
	  Endif
	  !
	  ! process related links
	  if Action1$="ALTVENDOR" !								doc=ALTVEND_001.doc
		call AltVendorList(e$,ProdRec,List$[],maxcnt,AVC,CCC,VNC,intCo,PR.) ! alternate vendor display
	  Endif
	  if Action1$="KEYWORDS" !								doc=KEYWORDS_001.doc
	   if action2$="SAVE"   !								doc=Prodm-SubmitKWords.doc
	    SearKey$=PR.ProdCode$,"            "\SearKey$=SearKey$[1,12]
        KWRec=filegetprdkeywrd(e$,KWC,"=",1,SearKey$,KW.)
		if kwrec<0 ! new
			let kw.productcode$=PR.ProdCode$,"            " !space filled for key
		Else ! existing
			call dprdkwrd(e$,IntCo,prodrec,kwc,pr.) ! delete old keywords
		Endif
        for i=1 to 30
		 call dxget("keyword"+str$(i),tmp$)
		 strgok=chkbadchars(e$,tmp$)
		   if not(strgok)
			returnstatus=0
			Message$="Invalid Characters in keyword"+str$(i)
			goto RLDone
		   Endif
		 if i=1 let kw.keyword1$=tmp$,b$
		 if i=2 let kw.keyword2$=tmp$,b$
		 if i=3 let kw.keyword3$=tmp$,b$
		 if i=4 let kw.keyword4$=tmp$,b$
		 if i=5 let kw.keyword5$=tmp$,b$
		 if i=6 let kw.keyword6$=tmp$,b$
		 if i=7 let kw.keyword7$=tmp$,b$
		 if i=8 let kw.keyword8$=tmp$,b$
		 if i=9 let kw.keyword9$=tmp$,b$
		 if i=10 let kw.keyword10$=tmp$,b$
		 if i=11 let kw.keyword11$=tmp$,b$
		 if i=12 let kw.keyword12$=tmp$,b$
		 if i=13 let kw.keyword13$=tmp$,b$
		 if i=14 let kw.keyword14$=tmp$,b$
		 if i=15 let kw.keyword15$=tmp$,b$
		 if i=16 let kw.keyword16$=tmp$,b$
		 if i=17 let kw.keyword17$=tmp$,b$
		 if i=18 let kw.keyword18$=tmp$,b$
		 if i=19 let kw.keyword19$=tmp$,b$
		 if i=20 let kw.keyword20$=tmp$,b$
		 if i=21 let kw.keyword21$=tmp$,b$
		 if i=22 let kw.keyword22$=tmp$,b$
		 if i=23 let kw.keyword23$=tmp$,b$
		 if i=24 let kw.keyword24$=tmp$,b$
		 if i=25 let kw.keyword25$=tmp$,b$
		 if i=26 let kw.keyword26$=tmp$,b$
		 if i=27 let kw.keyword27$=tmp$,b$
		 if i=28 let kw.keyword28$=tmp$,b$
		 if i=29 let kw.keyword29$=tmp$,b$
		 if i=30 let kw.keyword30$=tmp$,b$
		next i
		if KWRec<0 let mode$="a" else let mode$="c"
		KWRec=fileupdateprdkeywrd(e$,KWC,mode$,KWREC,KW.)
		if KWRec<0 ! bad stat
			!error 10000
			Returnstatus=0
			Message$=e$
			goto RLDone
		Else ! ok
		call aprdkwrd(e$,IntCo,prodrec,kwc,pr.) ! add new keywords
        Endif
		returnstatus=1
		Message$="OK - SAVED"
		goto RLDone
	   else
	    call KeyWordsList(e$,Action1$,ProdRec,List$[],maxcnt,PRC,KWC,PR.) ! alternate vendor display
	   end if
      end if
	  if Action1$="COMPLEMENTARY" !							doc=COMPLITEMS_001.doc
	     If action2$="SAVE" !								doc=Prodm-SubmitComplItems.doc
				
		  !complimentary items
		  SearKey$=pr.ProdCode$
		  Mode$="="
		  Dir=1 ! by product number
		  KWRec=filegetprdkeywrd(e$,KWC,mode$,Dir,SearKey$,KW.)
		  if KWRec<0 !?? add mode, other fields?
			clear kw.
			let kw.productcode$=PR.ProdCode$+Blank$
		  end if
		  !!?? are there 4 or 10 complementary items?
		  call dxget("ComplItem1",tmp$) \KW.ComplItem1$=UCase$(tmp$),b$
		  !call dxget("ComplDesc11",   ??just the item #'s should be editable
		  !call dxget("ComplDesc21",
		  call dxget("ComplItem2",tmp$) \KW.ComplItem2$=UCase$(tmp$),b$
		  call dxget("ComplItem3",tmp$) \KW.ComplItem3$=UCase$(tmp$),b$
		  call dxget("ComplItem4",tmp$) \KW.ComplItem4$=UCase$(tmp$),b$
		  call dxget("ComplItem5",tmp$) \KW.ComplItem5$=UCase$(tmp$),b$
		  call dxget("ComplItem6",tmp$) \KW.ComplItem6$=UCase$(tmp$),b$
		  call dxget("ComplItem7",tmp$) \KW.ComplItem7$=UCase$(tmp$),b$
		  call dxget("ComplItem8",tmp$) \KW.ComplItem8$=UCase$(tmp$),b$
		  call dxget("ComplItem9",tmp$) \KW.ComplItem9$=UCase$(tmp$),b$
		  call dxget("ComplItem10",tmp$) \KW.ComplItem10$=UCase$(tmp$),b$
		  ! as native requires valid items - check it
		  for x=1 to 10
			if x=1 let SearKey$=KW.ComplItem1$
			if x=2 let SearKey$=KW.ComplItem2$
			if x=3 let SearKey$=KW.ComplItem3$
			if x=4 let SearKey$=KW.ComplItem4$
			if x=5 let SearKey$=KW.ComplItem5$
			if x=6 let SearKey$=KW.ComplItem6$
			if x=7 let SearKey$=KW.ComplItem7$
			if x=8 let SearKey$=KW.ComplItem8$
			if x=9 let SearKey$=KW.ComplItem9$
			if x=10 let SearKey$=KW.ComplItem10$
			if Trim$(searkey$)<>""
				Search #PRC,2,1;searkey$,R,E
				if e
					let returnstatus=0
					message$="Complementary Item "+Str$(X)+" Not found"
					goto RLDone ! don't write it
				Endif
			Endif
		  Next X
		  if KWRec<0 let mode$="a" else let mode$="c"
		  KWRec=fileupdateprdkeywrd(e$,KWC,mode$,KWREC,KW.)
		  if KWRec<0 ! bad stat
			returnstatus=0
			Message$=E$
		  Else
		  Returnstatus=1
		  Message$="OK - Saved"
		  Endif
		  goto RLDone
		 Else
			call KeyWordsList(e$,Action1$,ProdRec,List$[],maxcnt,PRC,KWC,PR.) ! complementary items
		 Endif
	  Endif ! complementaty
	  if Action1$="PRICEBOOK"  !							doc=Prodm-InqPriceBook.doc ! PriceBook_001.doc
		!if p9$[20,20]<>"F" ! do not allow on Industrial?
		!	returnstatus=0
		!	message$="Flag is not Fine Paper"
		!	goto RLDone
		!Endif
		SPBk=1
		PBC=OpenFile(9923,Intco)
		if PBC=-1 ! ERROR 42 ! synergy Price Book (only)
			returnstatus=0
			message$="Files are not built"
			goto RLDone
		Endif
		!if PBC=-1 ! web won't allow both - so Synergy Only
	     ! PBC = OpenFile(9978,intCo) \ if PBC = -1 error 42 ! product price book
		 !SPBk=0
		!Endif
		 GCC = OpenFile(-9977,intCo) \ if GCC = -1 error 42 ! product GBK color
		GFC = OpenFile(-9976,intCo) \ if GFC = -1 error 42 ! product GBK finish
		GSC = OpenFile(-9975,intCo) \ if GSC = -1 error 42 ! product GBK section
		GGC = OpenFile(-9974,intCo) \ if GGC = -1 error 42 ! product GBK grade 
		If SPbk ! synergy Price Book
			GBGC=OpenFile(-9922,IntCo) \ if gbgc=-1 Error 42 ! GBK grade class
			FSC=OpenFile(-9921,IntCo) \ if fsc=-1 error 42 ! GBK FSC ID
		Endif
	   If action2$="EDIT" or action2$="ADD" or action2$="COPY" ! doc=Prodm-EditPriceBook.doc
		
		 !!-! price book status
		  clear list$[]
		  list$[0]=bsdel$,"DROPLISTPBSTATUS",fdel$
		  list$[1]="ID",fdel$,"Description",fdel$
		  call pricebookstatusdesc(e$,1,tmp$)
		  list$[2]="1",fdel$,tmp$,fdel$
		  call pricebookstatusdesc(e$,2,tmp$)
		  list$[3]="2",fdel$,tmp$,fdel$
		  call pricebookstatusdesc(e$,3,tmp$)
		  list$[4]="3",fdel$,tmp$,fdel$
		  list$[5]=esdel$
		  call addtostr(e$,rstr$,list$[])
		  
		  !!-!GBKGRADE
		  clear list$[]
		  call filedroplistgbkgrade(e$,list$[],100,GGC)
		  call addToStr(e$,rstr$,list$[])

		  !!-!GBKCOLOR
		  clear list$[]
		  call filedroplistgbkcolor(e$,list$[],100,GCC)
		  call addToStr(e$,rstr$,list$[])

		  !!-!GBKFINISH
		  clear list$[]
		  call filedroplistgbkfinish(e$,list$[],100,GFC)
		  call addToStr(e$,rstr$,list$[])

		  !!-!GBKSECTION
		  clear list$[]
		  call filedroplistgbksection(e$,list$[],100,GSC)
		  call addToStr(e$,rstr$,list$[])

		  If SPBK
			!!-!GBKGCLASS
			clear List$[]
			call filedroplistgbkgclass(e$,List$[],100,GBGC)
			call addtostr(e$,rstr$,List$[])

			!!-!FSC ID 
			clear List$[]
			clear Fields$[] ! needs a 0 for none
			call filedroplistfsctable(e$,List$[],100,FSC,"",Fields$[],1,"","0")
			call addtostr(e$,rstr$,List$[])
		  Endif

		  !!-!!Cotton Content
		  Clear List$[]
		  List$[0]=bsdel$,"COTTONCONTENT",fdel$
		  List$[1]="ID",fdel$,"DESC",fdel$
		  List$[2]="0",fdel$,"None",fdel$
		  List$[3]="25",fdel$,"25 percent",fdel$
		  List$[4]="100",fdel$,"100 percent",fdel$
		  List$[5]=esdel$
		  call addtostr(e$,rstr$,List$[])

		  !!-!!Grain
		  clear list$[]
		  List$[0]=bsdel$,"GRAINDIR",fdel$
		  List$[1]="ID",fdel$,"DESC",fdel$
		  List$[2]="L",fdel$,"Long",fdel$
		  List$[3]="S",fdel$,"Short",fdel$
		  list$[4]=esdel$
		  call addtostr(e$,rstr$,List$[])
	   Endif
			   !!-!Filling PR.
	   If Action2$="SAVE" !									doc=Prodm-SubmitPriceBook.doc
	    
		   PR.ProdCode$=prod$
		   !?? price book
		   SearKey$=pr.ProdCode$ ! price book
		   !PBRec=filegetprodprbk(e$,PBC,"=",1,SearKey$,PB.)
		   PBRec=filegetsyngprbk(e$,PBC,"=",1,SearKey$,PB.)
		   if PBRec<0 Clear PB. ! price book not found   	Heading1$=Heading1$,"Status",fdel$,"Status Desc",fdel$
		   PB.ProdCode$=PR.ProdCode$+Blank$
		   call dxget("status",tmp$)\PB.Status=tmp$ ! PB.StatusCode=tmp$
		   call dxget("Grade",tmp$)\PR.Grade$=tmp$,b$
		   call dxget("Grain",tmp$)\PR.Grain$=tmp$,b$
		   call dxget("BasisWght",tmp$)\PR.BasisWgt=tmp$
		   call dxget("SizeWidth",tmp$)\PR.SizeWidth=tmp$
		   call dxget("SizeLength",tmp$)\PR.SizeLength=tmp$
		   call dxget("Color",tmp$)\PB.ColorID$=tmp$,B$ ! PB.Color$=tmp$,b$
		   call dxget("Finish",tmp$)\PB.Finish$=tmp$,b$
		   call dxget("Brightness",tmp$)\PB.Brightness$=tmp$,b$
		   call dxget("Opacity",tmp$)\PB.Opacity$=tmp$,b$
		   call dxget("Recycledcont",tmp$)\PB.RecyCont$=tmp$,b$ ! PB.RecycledContent$=tmp$,b$
		   call dxget("Cottoncont",tmp$)\PB.CottonCont=tmp$ ! PB.CottonContent$=tmp$,b$
		   call dxget("Laser",tmp$)\PB.Laser=0 \ if tmp$="Y" let PB.Laser=1 ! PB.Laser$=tmp$,b$
		   call dxget("GradeNumber",tmp$)\PB.GradeNo$=tmp$,b$ !PB.GradeNumber$=tmp$,b$
		   call dxget("Envelope",tmp$)\PB.Envelope=0 \ if tmp$="Y" let PB.Envelope=1 ! PB.EnvelopeNumber$=tmp$,b$
		   call dxget("AdhesiveType",tmp$)\PB.AdhvType$=TMP$,B$ ! PB.AdhesiveType$=tmp$
		   call dxget("LinealFtRoll",tmp$)\PB.FTRoll=tmp$ ! PB.LinealFtRoll=tmp$
		   call dxget("RollWeight",tmp$)\PB.RollWgt=tmp$
		   call dxget("RollDiameter",tmp$)\PB.RollDiam$=tmp$,b$ ! PB.RollDiameter$=tmp$,b$
		   call dxget("Caliper",tmp$)\PB.Caliper=tmp$
		   call dxget("PagesInch",tmp$)\PB.PgPinch=tmp$ ! PB.PagesInch=tmp$
		   call dxget("AcidFree",tmp$)\PB.AcidFree=0\if tmp$="Y" let PB.AcidFree=1
		   call dxget("Archival",tmp$)\PB.Archival=0\if tmp$="Y" let PB.Archival=1
		   call dxget("PCF",tmp$)\PB.Pcf=0\if tmp$="Y" let PB.Pcf=1
		   call dxget("ECF",tmp$)\PB.Ecf=0\if tmp$="Y" let PB.Ecf=1
		   call dxget("GSM",tmp$)\PB.Gsm=tmp$
		   call dxget("FSCCert",tmp$)\PB.FSCCert=0 \if tmp$="Y" let PB.FSCCert=1
		   call dxget("SFICert",tmp$)\PB.SFICert=0 \ if tmp$="Y" let PB.SFICert=1
		   call dxget("Digital",tmp$)\PB.Digital=0 \ if tmp$="Y" Let PB.Digital=1
		   call dxget("InkJet",tmp$)\PB.InkJet=0 \ if tmp$="Y" let PB.InkJet=1
		   call dxget("Indigo",tmp$)\PB.Indigo=0 \ if tmp$="Y" let PB.Indigo=1
		   call dxget("WindPower",tmp$)\PB.WindPower=0 \ if tmp$="Y" let PB.WindPower=1
		   call dxget("Durable",tmp$)\PB.DurPaper=0 \ IF TMP$="Y" LET PB.DurPaper=1
		   call dxget("CastCoat",tmp$)\PB.CastCoat=0 \ if tmp$="Y" let PB.CastCoat=1
		   call dxget("Recycled",tmp$)\PB.RecCont=0 \ if tmp$="Y" let PB.RecCont=1
		   Call dxget("PEFC",tmp$)\PB.PEFC=0 \ if tmp$="Y" let PB.PEFC=1
		   call dxget("PreCons",tmp$)\PB.PreCCont=tmp$
		   call dxget("PostCons",tmp$)\PB.PstCCont=tmp$
		   ! also on screen (we'll leave on Product!!)
		   ! Mill name(Vendor ID),Lbs per unit(a[5]),UOM(a[6])
		   call dxget("BookID",tmp$)\PB.BookId$=tmp$,b$
		   call dxget("CostGroup",tmp$)\PB.CostGrp$[1,50]=tmp$,b$
		   call dxget("Costcont",tmp$)\PB.CostGrp$[51,100]=tmp$,b$
		   call dxget("ItemGroup",tmp$)\PB.ItemGrp$=tmp$,b$
		   call dxget("Section",tmp$)\PB.Section$=tmp$,b$
		   call dxget("GradeClass",tmp$)\PB.GradeCl$=tmp$,b$
		   call dxget("FSCTable",tmp$)\PB.FSCID=tmp$

		   if PBRec<0 let mode$="a" else let mode$="c"

		   PBRec=fileupdatesyngprbk(e$,PBC,mode$,PBRec,PB.)
		   if PBRec<0 ! bad stat
			returnstatus=0
			Message$=E$
		   Else
		   	pr.BlankForKey$=blank$ ! always!!
			pr.Spare1$=blank$ ! same
			write record #PRC,PRodRec,0;pr.; ! update prod fields
			if sqlChan>=0
				call prod_DL4SQLConvert(e$,"FROMDL4",pr.,sql_prod.,Prodrec)
				e = prod_SQLAddUpdate(e$,sqlChan,sql_prod.)
				if e<>1 error 11000
			end if
			returnstatus=1
		   Message$="OK - Saved"
		   Endif
		   goto RLDone
	    Else
		   call PriceBookDisplay(e$,ProdRec,List$[],PBC,GCC,GFC,GSC,GGC,GBGC,FSC,PR.) ! price book
		Endif
	  Endif ! pricebook
	  if Action1$="SAFETYHAZARD" !							doc=SafetyHazard_001.doc
	  !														doc=Prodm-EditSafetyHaz.doc
	    If Action2$="SAVE" !								doc=Prodm-SubmitSafetyHaz.doc
			! WHAT IF CHANGED FLAG BUT DIDN'T SAVE IT YET?
			!if pr.DotHazardous=0 ! only allow if 1=Y, 2=Not, but name
			!	ReturnStatus=0
			!	Message$="PRODUCT not flagged as Hazardous"
			!	Goto RLDone
			!Endif
			call dxget("PSNREC",tmp$) ! prod shipping name
			let pr.ProdShipName=tmp$
			call dxget("HazardClass",tmp$)
			let pr.HazardClass$=tmp$+Blank$
			call dxget("IDNO",tmp$)
			pr.HazIDNum$=tmp$+blank$
			call dxget("GuideBook",tmp$)
			pr.ERGuildXref$=tmp$+Blank$
			call dxget("OtherDesc",tmp$)
			let pr.OtherHazDesc$=tmp$+Blank$
			call dxget("PackingGrp",tmp$)
			pr.HazPackingGrp$=tmp$+blank$
			If Prodrec>0 ! YOU DO GOT TO HAVE A PRODUCT!!
				pr.BlankForKey$=blank$ ! always!!
				pr.Spare1$=blank$ ! same
				write record #PRC,Prodrec,0;pr.;
				if sqlChan>=0
					call prod_DL4SQLConvert(e$,"FROMDL4",pr.,sql_prod.,Prodrec)
					e = prod_SQLAddUpdate(e$,sqlChan,sql_prod.)
					if e<>1 error 11000
				end if
			Else
				ReturnStatus=0
				Message$="NO PRODUCT RECORD!"
				
			Endif
			goto RLDone
		Else ! display
			if action2$="ADD" OR action2$="EDIT" or Action2$="COPY"
				call shzlist()
				call addtostr(e$,rstr$,List$[])
			Endif
			call SafetyHazardDisplay(e$,ProdRec,List$[],HNC,PR.)
		Endif
	  Endif
	  if Action1$="SHELFLIFE" !								doc=ShelfLife_001.doc
		call ShelfLifeDisplay(e$,ProdRec,List$[],PR.)
	  Endif
	  if Action1$="PRODSIZE" !								doc=Size_001.doc
		call ProdSizeDisplay(e$,ProdRec,List$[],CCC,PR.)
	  Endif
	  if Action1$="UNITOFMEASURE" !							doc=UnitOfMeasure_001.doc
	    call UnitofMeasureDisplay(e$,ProdRec,List$[],CTLC,CCC,PR.) ! unit of measure
	    call AddToStr(e$,rstr$,List$[])
	    call ProdSizeDisplay(e$,ProdRec,List$[],CCC,PR.) ! size
	  endif
	  if Action1$="ITEMCONTROL" !							doc=ItemControl_001.doc
		call ProdItemDisplay(e$,ProdRec,List$[],PTC,PR.) ! product item
	  Endif
	  if Action1$="VENDORMFG" !								doc=VendorMFG_001.doc
		call VendorMfgDisplay(e$,ProdRec,List$[],CTLC,CCC,VNC,PR.) ! vendor / manufacturing
	  Endif
	  if Action1$="PRICECONTROL" !							doc=PriceControl_001.doc
	    call PriceControlDisplay(e$,Intco,ProdRec,List$[],BRC,CCC,PTC,PR.) ! price control
	    call AddToStr(e$,rstr$,List$[])
	    call MarkupTableDisplay(e$,ProdRec,List$[],PRMC,SPMC,CTLC,PR.) ! mark up table
	  endif
	  If Action1$="COSTHISTORY" !
		call ProdWHCostHst(e$,0,List$[],maxcnt,CCC,CTLC,intCo,rstr$,PR.)
		! call AddToStr(e$,rstr$,List$[])
	  Endif
	  if Action1$="USERDEFINE" !							doc=UserDefineFields.doc
	   if action2$="SAVE" !									doc=Prodm-SubmitUDAs.doc
	    SearKey$=Pr.ProdCode$
	    UDARec=filegetproduda(e$,UDA,"=",1,SearKey$,UDA.)
	    if UDARec<0 clear UDA. 
		UDA.ProductCode$=Pr.ProdCode$
		call dxget("UDADesc1",tmp$)\pr.UdAlpha1$=tmp$,b$
		call dxget("UDADesc2",tmp$)\pr.UdAlpha2$=tmp$,b$
        call dxget("UDADesc3",tmp$)\pr.UdAlpha3$=tmp$,b$
	   	call dxget("UDADesc4",tmp$)\UDA.ANUda1$=tmp$,b$
	   	call dxget("UDADesc5",tmp$)\UDA.ANUda2$=tmp$,b$
	   	call dxget("UDADesc6",tmp$)\UDA.ANUda3$=tmp$,b$
	   	call dxget("UDADesc7",tmp$)\UDA.ANUda4$=tmp$,b$
	   	call dxget("UDADesc8",tmp$)\UDA.ANUda5$=tmp$,b$
	   	call dxget("UDADesc9",tmp$)\UDA.ANUda6$=tmp$,b$
	   	call dxget("UDADesc10",tmp$)\UDA.ANUda7$=tmp$,b$
	   	call dxget("UDADesc11",tmp$)\UDA.ANUda8$=tmp$,b$
	   	call dxget("UDADesc12",tmp$)\UDA.ANUda9$=tmp$,b$
	   	call dxget("UDADesc13",tmp$)\UDA.ANUda10$=tmp$,b$
	   	call dxget("UDADesc14",tmp$)\UDA.ANUda11$=tmp$,b$
	   	call dxget("UDADesc15",tmp$)\UDA.ANUda12$=tmp$,b$
	   	call dxget("UDADesc16",tmp$)\UDA.ANUda13$=tmp$,b$
        call dxget("UDANumber1",tmp$)\pr.Udnumeric=tmp$
        call dxget("UDANumber2",tmp$)\UDA.NumUda1=tmp$
        call dxget("UDANumber3",tmp$)\UDA.NumUda2=tmp$
        call dxget("UDANumber4",tmp$)\UDA.NumUda3=tmp$
        call dxget("UDANumber5",tmp$)\UDA.NumUda4=tmp$

		if UDARec<0 let mode$="a" else let mode$="c"
		UDARec=fileupdateproduda(e$,UDA,mode$,UDAREC,UDA.)
		if UDARec<0 !bad stat
			returnstatus=0
			Message$=E$
		Else
			pr.BlankForKey$=blank$ ! always!!
			pr.Spare1$=blank$ ! same
			Write Record #PRC,ProdRec,0;pr.;
			if sqlChan>=0
				call prod_DL4SQLConvert(e$,"FROMDL4",pr.,sql_prod.,Prodrec)
				e = prod_SQLAddUpdate(e$,sqlChan,sql_prod.)
				if e<>1 error 11000
			end if
			returnstatus=1
			Message$="OK - Saved"
		Endif
		goto RLDone
	   else
	    call UserDefineDisplay(e$,ProdRec,List$[],UDA,PR.) ! user define fields
	   end if ! action
      end if ! of uda
	  If action1$="UPCXREF"
		upc1$=Pr.ProdCode$;upc[0]=-1;upc[1]=PRC;upc[2]=-1;upc[3]=ccc
		if action2$="ADD" or Action2$="SAVE" or action2$="DELETE"
			let upc[4]=1 ! edit
			upc[5]=0 ! grp - unknown
			upc[6]=1 ! add/edit
			upc[7]=0 ! rec - unknown
			call dxget("RECNO",tmp$)
			upc[7]=tmp$
			call UPCADDEDIT(e$,IntCo,UPC1$,UPC[])
			goto PMnDone ! that's all folks (call adds netstatus/setoutput)
		Endif
		if action2$="EDIT" ! get data for edit
			upc[4]=1
		Else	! inquiry
			upc[4]=2
		Endif
		if action2$<>"SAVE" call UPCINQUIRY(e$,Intco,UPC1$,UPC[],List$[],Maxcnt)
	  Endif ! of upcxref
	  If Action1$="CUSTGRP" ! add/edit custgrp(upcxref)
		! add/edit all in same call (and returns new list)
		clear upc[]
		upc[0]=-1 ! no file
		call EDTCUSTGRP(e$,Intco,UPC[],rstr$)
		goto PMnDone ! finished - did setoutput
	  Endif
	  !
	  If Action1$="CPI" ! 
	    If p61$[111,111]="Y"
			returnstatus=1
			message$="OK"
			call cpiinquiry(e$,intco,maxcnt,userid$,0,Prod$,List$[])
		Else ! no cpi
			let returnStatus=0
			Message$="CPI is not active"
			goto RLDone ! no list
		Endif
	  Endif ! of cpi
	  ! standard on all inquiry - add list to rstr
	  call AddToStr(e$,rstr$,List$[])
	  !
	 
    endif ! of warehouse or not
	!
	RLDone: ! end of related
	Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	Call AddToStr(e$,rstr$,WebStr$)
    call SetOutPut(e$,rstr$)
	! End of RelatedLinks
  End Select
  PMnDone: ! finished
else
 include "src/callmainerrnet.inc"
end try
end  ! end of Main
!
!--------------------------------------------------------------------
Sub ProdMain()  
  !
  ! send data for main product record screen
  !
  Try
	
	! open files
	! Call programdump("/tmp/plog1!","")
	!
	call OpenFiles()
    !
	!etc for all files needed
	!
	! get product record
	! Call DXGet("keyvar",prod$)
	! Prod$ = Prod$,Blank$
	ProdKey$=prod$
	Prodrec = filegetprod(e$,PRC,"=",1,ProdKey$,PR.)
	if action2$<>""
	  If action2$<>"ADD" and action2$<>"COPY" !				doc=Prodm-GetDataDirection.doc
		mode$=blank$
		if action1$="NEXT" ! next from curr
			mode$=">"
		Endif
		if action1$="PREV" ! back 1 from curr
			mode$="<"
		Endif
		if action1$="FIRST" ! first on file
			Prod$=blank$
			mode$=">"
		Endif
		If Action1$="LAST" ! last on file
			prod$="}}}"
			mode$="<"
		Endif
		if RTrim$(mode$)<>"" ! do it
			Prodkey$=Prod$
			Prodrec = filegetprod(e$,PRC,mode$,1,ProdKey$,PR.)
			If Prodrec<=0
				returnstatus=0
				message$="End of Index reached"
				goto PMainDone
			Endif
			prod$=pr.ProdCode$+Blank$
		Endif
	  Endif
	Endif
	!
    if action2$="ADD" if Prodrec>0 !requesting to add prodid, already on file, error
     !e$="msgprodAOF" \error 10000 !Product already on file!
	 Returnstatus=0
	 Message$="PRODUCT "+RTrim$(prod$)+" ALREADY ON FILE"
	 goto PMainDone
    end if
	If Action2$="COPY" !									doc=Prodm-CopyProduct.doc
		returnstatus=1
		Message$="OK"
		call cpyprod() ! has Prodrec set upon return
		If returnstatus=0 goto PMainDone
		! if okay - fall thru and send data
	Endif		
	if (action2$="" or action2$="EDIT") and Prodrec<0 ! normal - no prod found
		!E$="msgprodNOF" \ error 10000 ! save new allow - a2$="ADD" & Prodrec<0
		returnstatus=0
		Message$="PRODUCT "+RTrim$(prod$)+" NOT FOUND"
		goto PMainDone
	Endif
	if prod$=Blank$[1,12] ! NO BLANK PRODCODES!
		!E$="msgprodinvalid" \ error 10000
		ReturnStatus=0
		Message$="BLANK PRODUCT CODE NOT ALLOWED"
		goto PMainDone
	Endif
	!!Start!Dci2
    If action2$="SAVE" !									doc=Prodm-MainSave.doc
		! get special um's rec id #
		UM$="LB  "
		Search #ccc,2,1;UM$,r[1],E
		if not(e)
			LBUM=R[1]
		Endif
		UM$="LBS "
		Search #ccc,2,1;UM$,R[2],E
		if not(e)
			LBSUM=R[2]
		Endif
		um$="ROLL"
		SEARCH #ccc,2,1;UM$,R[3],E
		if not(e)
			RLUM=r[3]
		Endif
		returnstatus=1
		Message$="OK"
		call ProdSave() ! get/check etc
		! continue & redisplay?
		goto PMainDone ! no redisplay(why do it?)
	Endif ! of save 

    If action2$="DELETE" !									doc=Prodm-DeleteProduct.doc
      If Prodrec>0 
	   ! not deleting yet until checks are ready
		 Call DELProd()
		 ! returnstatus=0
		 ! Message$="Delete not coded"
		 goto PMainDone
      Else
         !e$="file no record" \error 10000 !file no record!
		 returnstatus=1
		 Message$="Deleted - No Record"
		 goto PMainDone
      Endif
    Endif
	If action2$="ADD" ! default new? !						doc=Prodm-AddProduct.doc
		Prodrec=0 ! chg from <0
		clear pr.
		pr.ProdCode$=prod$+Blank$
		pr.NU$="12345";pr.SnModelNum$=B$;pr.HazardClass$=b$
		pr.UpdTrdserv$=b$;pr.UdAlpha1$=b$;pr.HazPackingGrp$=b$
		pr.PreOrdInd$=b$;pr.UdAlpha2$=b$;pr.HazIDNum$=b$
		pr.InsDept$=b$;pr.UdAlpha3$=b$;pr.ERGuildXref$=b$
		pr.PrdtnListCode$=b$;pr.OtherHazDesc$=b$
		pr.Grade$=b$;pr.Grain$=b$;pr.NU1$=b$
		pr.SupersedeCode$=b$;pr.PackSize$=b$
		pr.CostDiscOverrides$=b$;pr.ByPassGPMerch$=b$
		pr.PickAtNight$=b$;pr.CutItem$=b$;pr.sOpen$=b$
		pr.MarkupType$=b$;pr.Picturefile$=b$;pr.Spare1$=b$
		pr.PrimalItem$=b$;pr.Longdescfile$=b$
		pr.MsdsFile$=b$;pr.BlankForKey$=b$;PR.Space$=b$
		pr.SerNoTrack$="N";pr.LotCtrl$="N"
		pr.RollLbItem$="N";pr.CatchwgtItem$="N"
		pr.SuperPrcCalc$="N";pr.MBFlg$="B"
		pr.ComdtyCode$=blank$;pr.MatCode$=blank$
		pr.ROLLINV$="N";pr.SpareMe$=blank$
		pr.DateRecEstab=currdate
		if custom_customer$ = "PIEDMONT"
			pr.Load1MupTbl = 1 ! force
		end if
	Endif

	! get vendor name
	if PR.PrimVend>0
		VNK$ = PR.PrimVend using M6$
		VMRec=filegeta80vm(e$,VNC,"=",1,VNK$,VM.)
	Else
		vmrec=-1
	Endif
	if VMRec<0 let	VendName$="Not on file" else VendName$=VM.Name$
    !
	! get matcode description
	tmp$=RTrim$(PR.MatCode$)
	if tmp$<>""
	SearKey$=PR.MatCode$
	MCRec=filegetmatcode(e$,MTC,"=",1,SearKey$,MC.)
	Else
		mcrec=-1
	Endif
	if MCRec<0 let MatDesc$="Not Found" else MatDesc$=MC.Description$
    !
    ! get prod cat (sales cat) description
	tmp=0
	if PR.ProdCat>0 and PR.ProdCat<100
	Try read record #PCC,PR.ProdCat;PC.; else tmp=-1
	ELSE
		TMP=-1
	Endif
	if tmp=-1 let PCatDesc$="Not Found" else PCatDesc$=PC.CategoryDesc$
    !
	! get alternate (Sub) descs
	tmp$=RTrim$(PR.AltPart1$)
	if tmp$<>""
	SearKey$=PR.AltPart1$
	tmp3 = filegetprod(e$,PRC,"=",1,SearKey$,DupPR.)
	Else
	tmp3=-1
	endif
	if tmp3<0 let Sub1Desc$="" else Sub1Desc$=DupPR.Desc1$
	tmp$=RTrim$(PR.AltPart2$)
	if tmp$<>""
	SearKey$=PR.AltPart2$
	tmp3 = filegetprod(e$,PRC,"=",1,SearKey$,DupPR.)
	Else
	tmp3=-1
	endif
	if tmp3<0 let Sub2Desc$="" else Sub2Desc$=DupPR.Desc1$
	tmp$=RTrim$(PR.SupersedeCode$)
	if tmp$<>""
	SearKey$=PR.SupersedeCode$
	tmp3 = filegetprod(e$,PRC,"=",1,SearKey$,DupPR.)
	Else
	tmp3=-1
	endif
	if tmp3<0 let SPRSD$="" else SPRSD$=DupPR.Desc1$
	searkey$=" ",searkey$
	Searkey$=PR.ComdtyCode$
	Search #CMC,2,1;Searkey$,R[77],E
	if Not(E)
		mat read #cmc,r[77],0;cmcdesc$;
	Else
		cmcdesc$="COMMD INVALID"
	Endif
	!
	call plcprcupdt() ! do load cost & Price updates (Get Curr Price/Cost!)
    !
	! product rec section
	clear List$[]
	row=0;tmpcnt=maxcnt
	!
	List$[row]=bsdel$,"ProductRec",fdel$ \ row=row+1 ! beg section
	if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	!
	WebStr$="ProductID",fdel$,"SupersedeCode",fdel$
	WebStr$=WebStr$,"Description1",fdel$,"Description2",fdel$
	WebStr$=WebStr$,"MaterialCode",fdel$,"MeterialDesc",fdel$
	WebStr$=WebStr$,"DateRecEstablished",fdel$
	WebStr$=WebStr$,"Substitute1",fdel$,"Sub1Desc",fdel$
	WebStr$=WebStr$,"Substitute2",fdel$,"Sub2Desc",fdel$
	WebStr$=WebStr$,"SalesCategory",fdel$,"SalesCatDesc",fdel$
	WebStr$=WebStr$,"VendorItemCode",fdel$,"VendorCode",fdel$
	WebStr$=WebStr$,"CommodityCode",fdel$,"MSDS",fdel$
	webstr$=webstr$,"SprsdDesc",fdel$,"VendorName",fdel$
	webstr$=webstr$,"LastCostSec",fdel$
	Webstr$=Webstr$,"PRODURL",fdel$,"PRODLID",fdel$
    List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	!
	WebStr$=rtrim$(PR.ProdCode$),fdel$ ! productcode
	WebStr$=WebStr$,rtrim$(PR.SupersedeCode$),fdel$ ! supercede
	WebStr$=WebStr$,rtrim$(PR.Desc1$),fdel$ ! desc 1
	WebStr$=WebStr$,rtrim$(PR.Desc2$),fdel$ ! desc 2
	WebStr$=WebStr$,rtrim$(PR.MatCode$),fdel$ ! mat code
	WebStr$=WebStr$,rtrim$(MatDesc$),fdel$ ! mat desc
	tmp$="" \ if PR.DateRecEstab let tmp$=PDate$(PR.DateRecEstab)
	WebStr$=WebStr$,tmp$,fdel$ ! date record established
	WebStr$=WebStr$,rtrim$(PR.AltPart1$),fdel$ ! alt part 1
	WebStr$=WebStr$,rtrim$(Sub1Desc$),fdel$ ! alt part 1 desc
	WebStr$=WebStr$,rtrim$(PR.AltPart2$),fdel$ ! alt part 2
	WebStr$=WebStr$,rtrim$(Sub2Desc$),fdel$ ! alt part 2 desc
	WebStr$=WebStr$,str$(PR.ProdCat),fdel$ ! prod (sales) cat
	WebStr$=WebStr$,rtrim$(PCatDesc$),fdel$ ! prod (sales) cat desc
	WebStr$=WebStr$,rtrim$(PR.VendItem$),fdel$ ! vendor item code
	If action2$="EDIT" or action2$="ADD" or action2$="COPY"
		WebStr$=WebStr$,str$(PR.PrimVend),fdel$ ! vdr #
		WebStr$=WebStr$,rtrim$(PR.ComdtyCode$),fdel$ ! commodity code
	Else ! display
	WebStr$=WebStr$,rtrim$(str$(PR.PrimVend)),"  ",rtrim$(VendName$),fdel$ ! vdr # & name
	Webstr$=WebStr$,PR.ComdtyCode$," - ",RTrim$(cmcdesc$),fdel$ ! commod & dsc
	Endif
	webstr$=webstr$,Str$(pr.msds),fdel$ ! msds
	webstr$=webstr$,Rtrim$(SPRSD$),fdel$,rtrim$(VendName$),fdel$ ! supersede desc,vdr name
	webstr$ = webstr$,Str$(COST_LEV[2]),fdel$ ! last cost security!
	if prdurl ! get it
		let KPROD$=" ",KPROD$
		KPROD$=PR.ProdCode$+Blank$
		Search #ch_purl,2,1;kprod$,r[89],E
		if not(e)
			mat read #ch_purl,r[89],13;produrl$;
		Else
			clear produrl$
		Endif
	Endif
	webstr$=webstr$,RTrim$(PRODURL$),fdel$
	if not(prdref) ! 
		clear pr.NProdId$
	Endif
	webstr$=Webstr$,RTrim$(pr.NProdId$),fdel$
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	!
	List$[row]=esdel$ \ row=row+1 ! end of section
	Call AddToStr(e$,rstr$,List$[])  ! put header into rstr$
    !
	! price section ---------------------
	!
	clear List$[]
	row=0
	!
	List$[row]=bsdel$,"List Prices",fdel$ \ row=row+1 ! beg section
	!
	WebStr$="ListPrices",fdel$,"Price",fdel$,"UM",fdel$
    List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	!
	! list price constants
    pum$=xunit$(PR.UMPriceDefault,ccc) ! u/m
	CNVTU[0] = 0  ! convert to rcd #, 0=base
	CNVTU[1] = PR.UMPriceDefault  ! from rcd#,convert um code to record #
	CNVTU[2] = 2  ! 2= convert cost/price, 1=convert qty
	!
	Clear tmp$
	! list price 1
	CNVTA=PR.ListPrice1	
	tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	!
	tmp1=(15-1)*10 ! get lp1 from cntrl
	Read #CTLC,18,tmp1;tmp$[1,10];
	If tmp$[Len(tmp$)]<" " let tmp$[Len(tmp$)]=" "
	if Len(tmp$)<2 or tmp$[1,5]="     " Let tmp$="List 1"
	WebStr$=RTrim$(tmp$),fdel$ ! desc
	WebStr$=WebStr$,tmp3 using PMask$,fdel$ ! converted price
	WebStr$=WebStr$,pum$,fdel$ ! u/m
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
    !
	! list price 2
    CNVTA=PR.ListPrice2 
	tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	!
	tmp1=(16-1)*10 ! get lp2 from cntrl
	Read #CTLC,18,tmp1;tmp$[1,10];
	If tmp$[Len(tmp$)]<" " let tmp$[Len(tmp$)]=" "
	if Len(tmp$)<2 or tmp$[1,5]="     " Let tmp$="List 2"
	WebStr$=RTrim$(tmp$),fdel$ ! desc
	WebStr$=WebStr$,tmp3 using PMask$,fdel$ ! converted price
	WebStr$=WebStr$,pum$,fdel$ ! u/m
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	!
	! list price 3
    CNVTA=PR.ListPrice3 ! list price 3
	tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	!
    tmp1=(17-1)*10 ! get lp3 from cntrl
	Read #CTLC,18,tmp1;tmp$[1,10];
	If tmp$[Len(tmp$)]<" " let tmp$[Len(tmp$)]=" "
	if Len(tmp$)<2 or tmp$[1,5]="     " Let tmp$="List 3"
	WebStr$=RTrim$(tmp$),fdel$ ! desc
	WebStr$=WebStr$,tmp3 using Pmask$,fdel$ ! converted price
	WebStr$=WebStr$,pum$,fdel$ ! u/m
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	!
	! list price 4	   
    CNVTA=PR.ListPrice4 ! list price 4
	tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	!
    tmp1=(18-1)*10 ! get lp1 from cntrl
	Read #CTLC,18,tmp1;tmp$[1,10];
	If tmp$[Len(tmp$)]<" " let tmp$[Len(tmp$)]=" "
	if Len(tmp$)<2 or tmp$[1,5]="     " Let tmp$="List 4"
	WebStr$=RTrim$(tmp$),fdel$ ! desc
	WebStr$=WebStr$,tmp3 using PMask$,fdel$ ! converted price
	WebStr$=WebStr$,pum$,fdel$ ! u/m
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	!
	! list price 5  
    CNVTA=PR.ListPrice5 ! list price 5
	tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	!
    tmp1=(19-1)*10 ! get lp1 from cntrl
	Read #CTLC,18,tmp1;tmp$[1,10];
	If tmp$[Len(tmp$)]<" " let tmp$[Len(tmp$)]=" "
	if Len(tmp$)<2 or tmp$[1,5]="     " Let tmp$="List 5"
	WebStr$=RTrim$(tmp$),fdel$ ! desc
	WebStr$=WebStr$,tmp3 using PMask$,fdel$ ! converted price
	WebStr$=WebStr$,pum$,fdel$ ! u/m
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	!
	! list price 6  
    CNVTA=PR.ListPrice6 ! list price 6
	tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	!
    tmp1=(20-1)*10 ! get lp1 from cntrl
	Read #CTLC,18,tmp1;tmp$[1,10];
	If tmp$[Len(tmp$)]<" " let tmp$[Len(tmp$)]=" "
	if Len(tmp$)<2 or tmp$[1,5]="     " Let tmp$="List 6"
	WebStr$=RTrim$(tmp$),fdel$ ! desc
	WebStr$=WebStr$,tmp3 using PMask$,fdel$ ! converted price
	WebStr$=WebStr$,pum$,fdel$ ! u/m
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	!
    ! end of list price
	List$[row]=esdel$  ! end of section
	Call AddToStr(e$,rstr$,List$[])  ! put header into rstr$
    !
	! Cost Section -------------------
	!
	clear List$[]
	row=0
	!
	List$[row]=bsdel$,"Costs",fdel$ \ row=row+1 ! beg section
	!
	WebStr$="ListCost",fdel$,"Cost",fdel$
	WebStr$=WebStr$,"UM",fdel$,"Table",fdel$
    List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	!
	! cost constants
    pum$=xunit$(PR.UMCostDefault,ccc) ! u/m
	CNVTU[0] = 0  ! convert to rcd #, 0=base
	CNVTU[1] = PR.UMCostDefault   ! from rcd#,convert um code to record #
	CNVTU[2] = 2  ! 2= convert cost/price, 1=convert qty
	!
	Clear tmp$
	! BASE cost
	CNVTA=PR.CostBase   ! base cost
	tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,Flag,PR.)
	!
    WebStr$="BASE COST",fdel$
	If Cost_Lev[3]>0 or addedit ! add cost_lev
	WebStr$=Webstr$,tmp3 using PMask$,fdel$ ! converted amount
	WebStr$=WebStr$,pum$,fdel$ ! u/m
	Else ! add no cost_lev
		Let WebStr$=WebStr$," ",fdel$," ",fdel$ ! blank cost/UM
	Endif
	
    WebStr$=WebStr$," ",fdel$ ! no table for avg
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
    !
	! load cost
	CNVTA=PR.CostLoad ! load cost
	tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,Flag,PR.)
	!
    tmp1=(13-1)*10 ! get desc from cntrl
	Read #CTLC,18,tmp1;tmp$[1,10];
	If tmp$[Len(tmp$)]<" " let tmp$[Len(tmp$)]=" "
	if Len(tmp$)<2 or tmp$[1,5]="     " Let tmp$="Load Cost"
	WebStr$=RTrim$(tmp$),fdel$ ! desc
	If Cost_Lev[1]>0 or addedit ! add cost_lev
	WebStr$=WebStr$,tmp3 using PMask$,fdel$ ! converted amount
	WebStr$=WebStr$,pum$,fdel$ ! u/m
	WebStr$=WebStr$,Str$(PR.Load1MupTbl),fdel$ ! load cost markup
	Else ! add no cost_lev
		Let WebStr$=WebStr$," ",fdel$," ",fdel$," ",fdel$ ! blank cost/UM/table
	Endif
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
    !
	! Redistributor cost
	CNVTA=PR.CostLoad2 ! redirect cost
	tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,Flag,PR.)
	!
    tmp1=(23-1)*10 ! get desc from cntrl
	Read #CTLC,18,tmp1;tmp$[1,10];
	If tmp$[Len(tmp$)]<" " let tmp$[Len(tmp$)]=" "
	if Len(tmp$)<2 or tmp$[1,5]="     " Let tmp$="REDI Cost"
	WebStr$=RTrim$(tmp$),fdel$ ! desc
	If Cost_Lev[1]>0 or addedit ! add cost_lev
	WebStr$=WebStr$,tmp3 using PMask$,fdel$ ! converted amount
	WebStr$=WebStr$,pum$,fdel$ ! u/m
	WebStr$=WebStr$,Str$(PR.Load2MupTbl),fdel$ ! redirect cost markup
	Else ! add no cost_lev
		Let WebStr$=WebStr$," ",fdel$," ",fdel$," ",fdel$ ! blank cost/UM/table
	Endif
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
    !
	! Last cost
	CNVTA=PR.CostPO  ! last cost
	tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,Flag,PR.)
	!
    tmp1=(12-1)*10 ! get desc from cntrl
	Read #CTLC,18,tmp1;tmp$[1,10];
	If tmp$[Len(tmp$)]<" " let tmp$[Len(tmp$)]=" "
	if Len(tmp$)<2 or tmp$[1,5]="     " Let tmp$="Last Cost"
	WebStr$=RTrim$(tmp$),fdel$ ! desc
	If Cost_Lev[2]>0 or addedit ! add cost_lev
	WebStr$=WebStr$,tmp3 using PMask$,fdel$ ! converted amount
	WebStr$=WebStr$,pum$,fdel$ ! u/m
	Else ! add no cost_lev
		Let WebStr$=WebStr$," ",fdel$," ",fdel$ ! blank cost/UM
	Endif
	WebStr$=WebStr$," ",fdel$ ! no table
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
    !
	! net po cost
	CNVTA=PR.CostNetPO  ! net po cost
	tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,Flag,PR.)
	!
    tmp1=(24-1)*10 ! get desc from cntrl
	Read #CTLC,18,tmp1;tmp$[1,10];
	If tmp$[Len(tmp$)]<" " let tmp$[Len(tmp$)]=" "
	if Len(tmp$)<2 or tmp$[1,5]="     " Let tmp$="Net PO Cost"
	WebStr$=RTrim$(tmp$),fdel$ ! desc
	If Cost_Lev[2]>0 or addedit ! add cost_lev
	WebStr$=WebStr$,tmp3 using PMask$,fdel$ ! converted amount
	WebStr$=WebStr$,pum$,fdel$ ! u/m
	Else ! add no cost_lev
		Let WebStr$=WebStr$," ",fdel$," ",fdel$ ! blank cost/UM
	Endif
	WebStr$=WebStr$," ",fdel$ ! no table
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
    !
	! average cost
	CNVTA=PR.CostAvg ! avg cost
	tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,Flag,PR.)
	!
	tmp1=(14-1)*10 ! get desc from cntrl
	Read #CTLC,18,tmp1;tmp$[1,10];
	If tmp$[Len(tmp$)]<" " let tmp$[Len(tmp$)]=" "
	if Len(tmp$)<2 or tmp$[1,5]="     " Let tmp$="Avg Cost"
	WebStr$=RTrim$(tmp$),fdel$ ! desc
    ! WebStr$="AVG. COST",fdel$
	If Cost_Lev[0]>0 or addedit ! add cost_lev
	WebStr$=WebStr$,tmp3 using PMask$,fdel$ ! converted amount
	WebStr$=WebStr$,pum$,fdel$ ! u/m
	Else ! add no cost_lev
		Let WebStr$=WebStr$," ",fdel$," ",fdel$ ! blank cost/UM
	Endif
	WebStr$=WebStr$," ",fdel$ ! no table
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
    !
    ! end of cost section
	List$[row]=esdel$  ! end of section
	Call AddToStr(e$,rstr$,List$[])  ! put header into rstr$
    !
	! Section 5 Section -------------------
	!
	clear List$[]
	row=0
	!
	tmp$=RTrim$(action2$)
	if tmp$="" ! only on inquiry
	! Web Info Section
	List$[row]=bsdel$,"Web Info",fdel$ \ row=row+1 ! beg section
	List$[row]=" ",fdel$ \ row=row+1 ! blank field
	List$[row]=esdel$ \ row=row+1 ! end section
	Endif
	!
	List$[row]=bsdel$,"Available",fdel$ \ row=row+1 ! beg section
	Webstr$="Whse",fdel$,"WhseQty",fdel$
    List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	!
	! stock warehouse constants
    pum$=xunit$(PR.UMStkDefault,ccc) ! u/m
	CNVTU[0] = 0  ! convert to rcd #, 0=base
	CNVTU[1] = PR.UMStkDefault ! from rcd#,convert um code to record #
	CNVTU[2] = 1  ! 2= convert cost/price, 1=convert qty
	!
	! get warehouse
	SearKey$=PR.ProdCode$
	Do
      WHRec=filegetprodwhse(e$,WHC,">",1,SearKey$,PRW.)
      if WHRec<0 exit do
	  If SearKey$[1,12]<>PR.ProdCode$ exit do ! was 1,len(pr.prodcode$) - causes error
	  !
	  whse=PRW.Whse using M2$
	  CNVTA=getwhavail(e$,IntCo,WHC,prod$,whse) ! e$,intco,chan,product$,warehouse
	  WebStr$="WH ",str$(PRW.Whse),fdel$
	  tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,Flag,PR.)
	  WebStr$=Webstr$,tmp3 using QMask$," ",pum$,fdel$ ! converted amount & u/m
	  List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	loop 
	!
	List$[row]=esdel$ \ row=row+1  ! end of section
    !
	call AddToStr(e$,rstr$,List$[])
    If action2$="EDIT" or action2$="ADD" or action2$="COPY" ! see respective action
     !related link fields on edit page 5/8/09
	  !NO if Action1$="ALTVENDOR" call AltVendorList(e$,ProdRec,List$[],maxcnt,AVC,CCC,VNC,intCo,PR.) ! alternate vendor display
	  !NO if Action1$="KEYWORDS" call KeyWordsList(e$,Action1$,ProdRec,List$[],maxcnt,PRC,KWC,PR.) ! alternate vendor display
	  !"COMPLEMENTARY" NO SEPARATE
	  ! call KeyWordsList(e$,Action1$,Prodrec,List$[],maxcnt,PRC,KWC,PR.) ! complementary items
	  !"PRICEBOOK" NO - SEPARATE
	  ! call PriceBookDisplay(e$,Prodrec,List$[],PBC,GCC,GFC,GSC,GGC,PR.) ! price book
	  !NO if Action1$="SAFETYHAZARD" call SafetyHazardDisplay(e$,ProdRec,List$[],HNC,PR.)
	  !"SHELFLIFE" 
	  call ShelfLifeDisplay(e$,Prodrec,List$[],PR.)
	  call AddToStr(e$,rstr$,List$[])
	
	  !"UNITOFMEASURE"
	    call UnitofMeasureDisplay(e$,Prodrec,List$[],CTLC,CCC,PR.) ! unit of measure
	    call AddToStr(e$,rstr$,List$[])
	  !"PRODSIZE"
	    call ProdSizeDisplay(e$,Prodrec,List$[],CCC,PR.) ! size
	  call AddToStr(e$,rstr$,List$[])
	  !"ITEMCONTROL" 
	  call ProdItemDisplay(e$,Prodrec,List$[],PTC,PR.) ! product item
	  call AddToStr(e$,rstr$,List$[])
	  !"VENDORMFG" 
	  call VendorMfgDisplay(e$,Prodrec,List$[],CTLC,CCC,VNC,PR.) ! vendor / manufacturing
	  call AddToStr(e$,rstr$,List$[])
	  !"PRICECONTROL" 
	    call PriceControlDisplay(e$,intco,Prodrec,List$[],BRC,CCC,PTC,PR.) ! price control
	    call AddToStr(e$,rstr$,List$[])
	  !  call MarkupTableDisplay(e$,Prodrec,List$[],PRMC,SPMC,CTLC,PR.) ! mark up table
	  !call AddToStr(e$,rstr$,List$[])
	  !NO if Action1$="USERDEFINE" call UserDefineDisplay(e$,ProdRec,List$[],UDA,PR.) ! user define fields
    end if !edit
	ReturnStatus=1
	Message$="OK"
    !
	PMainDone: ! finito - send status
	Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	Call AddToStr(e$,rstr$,WebStr$)
	Call SetOutput(e$,rstr$)
    !
  else
    include "src/callsuberr.inc"
  end try
  !
End Sub  ! end of ProdMain
!
!--------------------------------------------------------------------
Function conv_cost(CNVTA)
	CNVTU[0] = 0  !convert to rcd #, 0=base
	CNVTU[1] = PR.UMCostDefault  !from rcd#,convert um code to record #
	CNVTU[2] = 2  !2= convert cost/price, 1=convert qty
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
End Function Amount
!
!--------------------------------------------------------------------
Sub MYSales()
  !
  Try
	yy=1 ! start with last year
	For yy=1 to 0 Step -1
		!
		Call ProdSLS(intCo,intSls,debug,dlog$,prod$,yy,sls.[],ii ,ss, iLimit)
		!
		! section 
		if yy=0 tmp$=bsdel$+"ThisYearSales"+fdel$+rdel$
		if yy=1 tmp$=bsdel$+"LastYearSales"+fdel$+rdel$
		!
		! header columns   Month, units, sales, cost
		tmp$=tmp$+"Month"+fdel$
		tmp$=tmp$+"units"+fdel$
		tmp$=tmp$+"sales"+fdel$
		tmp$=tmp$+"cost"+fdel$
		tmp$=tmp$+"cost_UM"+fdel$+rdel$
		Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$
		!
		! detail
		for ii = 0 to 11
			tmp$=sls.[ii].mm$+fdel$                     
			tmp$=tmp$+sls.[ii].unitsale$+fdel$             
			tmp$=tmp$+sls.[ii].netsale$+fdel$
			If Cost_Lev[1]>0 ! add load cost level
			  tmp$=tmp$+sls.[ii].costsale$+fdel$
			Else ! no cost display
			  tmp$=tmp$+" "+fdel$ ! show blank field
			 Endif
			tmp$=tmp$+sls.[ii].gp$+fdel$+rdel$		! this holds sellum
			Call AddToStr(e$,rstr$,tmp$)
		next ii
		Call AddToStr(e$,rstr$,esdel$)
		!
		! total section
		if yy=0 tmp$=bsdel$+"ThisYearTotal"+fdel$+rdel$
		if yy=1 tmp$=bsdel$+"LastYearTotal"+fdel$+rdel$
		tmp$=tmp$+"units"+fdel$
		tmp$=tmp$+"sales"+fdel$
		tmp$=tmp$+"cost"+fdel$
		tmp$=tmp$+"cost_UM"+fdel$+rdel$
		Call AddToStr(e$,rstr$,tmp$)
		!
		! total detail
		tmp$=sls.[12].unitsale$+fdel$             
		tmp$=tmp$+sls.[12].netsale$+fdel$
		If Cost_Lev[1]>0 ! add load cost level
		  tmp$=tmp$+sls.[12].costsale$+fdel$
		Else ! no cost display
		  tmp$=tmp$+" "+fdel$ ! show blank field
		Endif
		tmp$=tmp$+sls.[12].gp$+fdel$+rdel$		! this holds sellum
		Call AddToStr(e$,rstr$,tmp$+esdel$)
	Next YY
	Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
Call AddToStr(e$,rstr$,WebStr$)
	Call SetOutput(e$,rstr$)
 Else
    include "src/callsuberr.inc"
 End Try
End Sub ! done with "MYSALES"
!
!--------------------------------------------------------------------
Sub CostChanges()
  !
  Try
    !
	CTLC = OpenFile(-9999,intCo) \ If CTLC = -1 Error 42 !control
	PRC = OpenFile(-1792,intCo) \ If PRC = -1 Error 42 !prod
	CCC = OpenFile(-1728,intCo) \ If CCC = -1 Error 42  !u/m codes file
    !
	! Call DXGet("prodid",prod$) \ prod$=UCase$(prod$)
	! prod$ = prod$,Blank$
	!
	clear List$[]
	row=0;tmpcnt=maxcnt
	tmp2=Tim(6) ! todays date
	!
	List$[row]=bsdel$,"CostChanges",fdel$ \ row=row+1 ! beg section
	!
	WebStr$="CostType",fdel$,"Cost",fdel$
	WebStr$=WebStr$,"UM",fdel$,"DateChanged",fdel$
    List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	!
	SearKey$=prod$
	Prodrec=filegetprod(e$,PRC,"=",1,SearKey$,PR.)
	if Prodrec
	  Unit$=xunit$(PR.UMCostDefault,ccc)
	  !
	  if PR.PrevBaseCost and cost_lev[3]>0
	    WebStr$="PREVIOUS BASE COST",fdel$
		tmp3=PR.PrevBaseCost
		tmp$=(conv_cost(tmp3)) Using PMask$
		WebStr$=WebStr$,tmp$,fdel$
		WebStr$=WebStr$,Unit$,fdel$
		tmp$="" 
		if PR.DateBaseChg let tmp$=pdate$(PR.DateBaseChg)
		WebStr$=WebStr$,tmp$,fdel$
		List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	  endif
	   !
	  if (PR.PrevBaseCost or PR.PendBaseCost) and cost_lev[3]>0
	    WebStr$="CURRENT BASE COST",fdel$
		tmp3=PR.CostBase
		tmp$=(conv_cost(tmp3)) Using PMask$
		WebStr$=WebStr$,tmp$,fdel$
		WebStr$=WebStr$,Unit$,fdel$
		tmp1$=tmp2 using "&&&&&"
		Call JulianToDate(5,tmp1$,tmp$,F) ! returns mm/dd/yyyy
		WebStr$=WebStr$,tmp$,fdel$
		List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	  endif
	  !
	  if PR.PendBaseCost and cost_lev[3]>0
	    WebStr$="FUTURE BASE COST",fdel$
		tmp3=PR.PendBaseCost
		tmp$=(conv_cost(tmp3)) Using PMask$
		WebStr$=WebStr$,tmp$,fdel$
		WebStr$=WebStr$,Unit$,fdel$
		tmp$="" 
		if PR.PendBaseDate let tmp$=pdate$(PR.PendBaseDate)
		WebStr$=WebStr$,tmp$,fdel$
		List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	  endif
	  !
	  if PR.PrevLastCost and cost_lev[2]>0
	    WebStr$="PREVIOUS PO COST",fdel$
		tmp3=PR.PrevLastCost
		tmp$=(conv_cost(tmp3)) Using PMask$
		WebStr$=WebStr$,tmp$,fdel$
		WebStr$=WebStr$,Unit$,fdel$
		tmp$="" 
		if PR.DateLastCostChg let tmp$=pdate$(PR.DateLastCostChg)
		WebStr$=WebStr$,tmp$,fdel$
		List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	  endif
	  !
	  if (PR.PrevLastCost or PR.PendLastCost) and cost_lev[2]>0
	    WebStr$="CURRENT PO COST",fdel$
		tmp3=PR.CostPO
		tmp$=(conv_cost(tmp3)) Using PMask$
		WebStr$=WebStr$,tmp$,fdel$
		WebStr$=WebStr$,Unit$,fdel$
		tmp1$=tmp2 using "&&&&&"
		Call JulianToDate(5,tmp1$,tmp$,F) ! returns mm/dd/yyyy
		WebStr$=WebStr$,tmp$,fdel$
		List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	  endif
	  !
	  if PR.PendLastCost and cost_lev[2]>0
	    WebStr$="FUTURE PO COST",fdel$
		tmp3=PR.PendLastCost
		tmp$=(conv_cost(tmp3)) Using PMask$
		WebStr$=WebStr$,tmp$,fdel$
		WebStr$=WebStr$,Unit$,fdel$
		tmp$="" 
		if PR.PendLastCostDate let tmp$=pdate$(PR.PendLastCostDate)
		WebStr$=WebStr$,tmp$,fdel$
		List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	  endif
      !
	  ! Possibles: Load/Redi
	  ! have fut & prev - only prev has date
	  ! fut date same as base?
	  If PR.PrevLoadCost and cost_lev[1]>0
	    WebStr$="PREVIOUS LOAD COST",fdel$
		tmp3=PR.PrevLoadCost
		tmp$=(conv_cost(tmp3)) Using PMask$
		WebStr$=WebStr$,tmp$,fdel$
		WebStr$=WebStr$,Unit$,fdel$
		tmp$="" 
		if PR.DateLoadCstChg let tmp$=pdate$(PR.DateLoadCstChg)
		WebStr$=WebStr$,tmp$,fdel$
		List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	  endif
	  If PR.PrevLoad2Cost and cost_lev[1]>0
	    WebStr$="PREVIOUS REDI COST",fdel$
		tmp3=PR.PrevLoad2Cost
		tmp$=(conv_cost(tmp3)) Using PMask$
		WebStr$=WebStr$,tmp$,fdel$
		WebStr$=WebStr$,Unit$,fdel$
		tmp$="" 
		if PR.DateLoad2Chg let tmp$=pdate$(PR.DateLoad2Chg)
		WebStr$=WebStr$,tmp$,fdel$
		List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	  endif
      ! NEW STUFF ADDED
      List$[row]=esdel$ \ row=row+1  \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])! end of section
	  tmp2=Tim(6)
	  WebStr$=bsdel$,"BASE COST",fdel$ ! section for Base Cost
	  List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	  WebStr$="CostType",fdel$,"Cost",fdel$
	  WebStr$=WebStr$,"UM",fdel$,"DateChanged",fdel$
      List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	  if PR.PrevBaseCost and cost_lev[3]>0
	    WebStr$="PREVIOUS BASE COST",fdel$
		tmp3=PR.PrevBaseCost
		tmp$=(conv_cost(tmp3)) Using PMask$
		WebStr$=WebStr$,LTRIM$(tmp$),fdel$
		WebStr$=WebStr$,Unit$,fdel$
		tmp$="" 
		if PR.DateBaseChg let tmp$=pdate$(PR.DateBaseChg)
		WebStr$=WebStr$,tmp$,fdel$
		List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	  endif
	  !
	  if (PR.PrevBaseCost or PR.PendBaseCost) and cost_lev[3]>0
	    WebStr$="CURRENT BASE COST",fdel$
		tmp3=PR.CostBase
		tmp$=(conv_cost(tmp3)) Using PMask$
		WebStr$=WebStr$,LTRIM$(tmp$),fdel$
		WebStr$=WebStr$,Unit$,fdel$
		tmp1$=tmp2 using "&&&&&"
		Call JulianToDate(5,tmp1$,tmp$,F) ! returns mm/dd/yyyy
		WebStr$=WebStr$,tmp$,fdel$
		List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	  endif
	  !
	  if PR.PendBaseCost and cost_lev[3]>0
	    WebStr$="FUTURE BASE COST",fdel$
		tmp3=PR.PendBaseCost
		tmp$=(conv_cost(tmp3)) Using PMask$
		WebStr$=WebStr$,LTRIM$(tmp$),fdel$
		WebStr$=WebStr$,Unit$,fdel$
		tmp$="" 
		if PR.PendBaseDate let tmp$=pdate$(PR.PendBaseDate)
		WebStr$=WebStr$,tmp$,fdel$
		List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	  endif
	  !
	  List$[row]=esdel$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[]) ! end of section
	  WebStr$=bsdel$,"PO COST",fdel$ ! section for PO/Last Cost
	  List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	  WebStr$="CostType",fdel$,"Cost",fdel$
	  WebStr$=WebStr$,"UM",fdel$,"DateChanged",fdel$
      List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	  !
	  if PR.PrevLastCost and cost_lev[2]>0
	    WebStr$="PREVIOUS PO COST",fdel$
		tmp3=PR.PrevLastCost
		tmp$=(conv_cost(tmp3)) Using PMask$
		WebStr$=WebStr$,LTRIM$(tmp$),fdel$
		WebStr$=WebStr$,Unit$,fdel$
		tmp$="" 
		if PR.DateLastCostChg let tmp$=pdate$(PR.DateLastCostChg)
		WebStr$=WebStr$,tmp$,fdel$
		List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	  endif
	  !
	  if (PR.PrevLastCost or PR.PendLastCost) and cost_lev[2]>0
	    WebStr$="CURRENT PO COST",fdel$
		tmp3=PR.CostPo
		tmp$=(conv_cost(tmp3)) Using PMask$
		WebStr$=WebStr$,LTRIM$(tmp$),fdel$
		WebStr$=WebStr$,Unit$,fdel$
		tmp1$=tmp2 using "&&&&&"
		Call JulianToDate(5,tmp1$,tmp$,F) ! returns mm/dd/yyyy
		WebStr$=WebStr$,tmp$,fdel$
		List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	  endif
	  !
	  if PR.PendLastCost and cost_lev[2]>0
	    WebStr$="FUTURE PO COST",fdel$
		tmp3=PR.PendLastCost
		tmp$=(conv_cost(tmp3)) Using PMask$
		WebStr$=WebStr$,LTRIM$(tmp$),fdel$
		WebStr$=WebStr$,Unit$,fdel$
		tmp$="" 
		if PR.PendLastCostDate let tmp$=pdate$(PR.PendLastCostDate)
		WebStr$=WebStr$,tmp$,fdel$
		List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	  endif
      !
	end if
	!
    List$[row]=esdel$ \ row=row+1  ! end of section
    !
	call AddToStr(e$,rstr$,List$[])
	!
	!

    !
	Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	Call AddToStr(e$,rstr$,WebStr$)
	Call SetOutput(e$,rstr$)
	!
	Close #CTLC,#PRC,#CCC
	!
  Else
    include "src/callsuberr.inc"
 End Try
End Sub ! done with "CostChanges"
!
!--------------------------------------------------------------------
Sub SScan()
 Try
	Declare External Sub SalesList
	External Lib "ubssalesscan.dl4"

	Include "src/ubssscan.inc"
	
	Dim pp.[1000] As SScanInfo
	Dim s. As SScanVars
	Dim 1%, arrSales[999]

	Dim 1%,PFU1[20],3%,PFU2[6],A[33]
	Dim keyprod$[20],keycust$[6],co$[2],sls$[3],vendprod$[23]
	Dim key1$[50],dlog$[50],gp$[20]
	Dim 2%,keycust
	Dim 3%,price,cost,gp

	Call DXGet("S_USER.AppID",CO$) ! Company                                    
	Call DXGet("S_USER.Userdef1",SLS$) ! Salesman Number                        
	Call DXGet("keynext",key1$) \ key1$ = UCase$(key1$)   
	Call DXGet("prodid",tmp$) \ keyprod$ = UCase$(RTrim$(tmp$))
	!if len(keyprod$)<13 let Keyprod$=Prod$ ! in case it's a Stock alt item
	! Let KeyProd$=Prod$ ! prod$ is dimmed 12 - needs 20 for non-stks!
	if len(keyprod$)<13 
		let Keyprod$=Prod$
		let vendprod$=" ",vendprod$
	else
		let keyprod$=" ",keyprod$
		let vendprod$="~@~"+UCase$(RTrim$(tmp$))  !! need the longer value from prodid
	endif
	Call DXGet("custid",keycust$)
	keycust = keycust$ \ keycust$ = keycust using "######"

	if not(keycust$) exit sub

	dlog$="files/6/dx.log"
	!
	clear List$[]
	row=0;tmpcnt=maxcnt
	!
	List$[row]=bsdel$,"SScan",fdel$ \ row=row+1 ! beg section
	!
	WebStr$="Ref#",fdel$,"Date",fdel$
	WebStr$=WebStr$,"QTY",fdel$,"QTY_UM",fdel$
	WebStr$=WebStr$,"Cost",fdel$,"Cost_UM",fdel$
	WebStr$=WebStr$,"Price",fdel$,"Price_UM",fdel$
	WebStr$=WebStr$,"Profit",fdel$,"GP%",fdel$
    List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
    !
	s.cust$ = keycust$
	s.product$ = keyprod$
	s.strSearch$ = vendprod$
	intSls=999 ! for this call
    !
    Call SalesList(intCo,intSls,debug,dlog$,s.,pp.[],ii,ss,300,Key1$,cost_lev[], arrSales[])
	call OpenFiles()
	For i=0 to ii
		gp=pp.[ii].gpp$ ! 0
		price=pp.[i].extprice$
		cost=pp.[i].extcost$ \ if not(cost) let gp=100
		! IF either = CWT or LB the below is possibly WRONG! (as wgt could be different!!)
		!if pp.[i].punit$<>pp.[i].cunit$
		!	searkey$=keyprod$
		!	ProdRec=filegetprod(e$,PRC,"=",1,SearKey$,PR.) ! product mode=2 dir=1
         !   ! initialize status
		!	if ProdRec
		!	    ! Read Record #PRC,ProdRec;PR.;
		!		MAT READ #PRC,PRODREC,256;A;
		!		MAT READ #PRC,PRODREC,512;PFU1;
		!		MAT READ #PRC,PRODREC,554;PFU2;
		!		cnvtu[0]=0
		!		if pp.[i].cunit$[1,3]="CWT" then cnvtu[0]=-1
		!		if pp.[i].cunit$[1,3]="LOT" then cnvtu[0]=-2
		!		iF PFU1[15]=-3 AND pp.[i].cUNIT$[1,3]="LB " LET CNVTu[0]=-3 
		!		if not(cnvtu[0])
		!			UM$=pp.[i].cunit$ 
		!			SEARCH #CCC,2,1;UM$,CNVTu[0],E
		!			if e then cnvtu[0]=0
		!		endif
		!		cnvtu[1]=0
		!		if pp.[i].punit$[1,3]="CWT" then cnvtu[1]=-1
		!		if pp.[i].punit$[1,3]="LOT" then cnvtu[1]=-2
		!		iF PFU1[15]=-3 AND pp.[i].pUNIT$[1,3]="LB " LET CNVTu[1]=-3 
		!		if not(cnvtu[1])
		!			UM$=pp.[i].punit$  
		!			Search #ccc,2,1;UM$,cnvtu[1],E
		!			if e then cnvtu[1]=0
		!		endif
		!		cnvta=cost
		!		cnvtu[2]=2 ! convert cost to pricing um?
	    !		cost=XAMOUNT(CNVTU[],CNVTA,PFU1[],PFU2[],A[],CTLC,FLAG)	
		!	endif
		!endif
		If price let gp=((price-cost)/price)*100
		if price=0 and cost=0 let gp=0
		let qty=pp.[i].qty$ \ if qty=0 let gp=0 ! no ship - no gp
		WebStr$=pp.[i].refnum$,fdel$
		WebStr$=WebStr$,pp.[i].orddate$,fdel$
		WebStr$=WebStr$,pp.[i].qty$,fdel$
		WebStr$=WebStr$,pp.[i].qunit$,fdel$
		If Cost_Lev[1]>0 ! add load cost 
		  WebStr$=WebStr$,pp.[i].cost$,fdel$
		  WebStr$=WebStr$,pp.[i].cunit$,fdel$
		Else ! no cost level
		  WebStr$=WebStr$," ",fdel$," ",fdel$ ! send blank cost/um
		Endif
		WebStr$=WebStr$,pp.[i].price$,fdel$
		WebStr$=WebStr$,pp.[i].punit$,fdel$
		If Cost_Lev[1]>0 ! add load cost level
			x3=price-cost ! line totals
			Qty=1 ! as sent for line?
			if qty<>0 let x3=fnr(x3/qty)
		  WebStr$=WebStr$,LTrim$(X3 using QMask$),fdel$ ! unit profit?
		  WebStr$=WebStr$,gp using QMask$,"%",fdel$
		Else ! no cost levle
		  Webstr$=WebStr$," ",fdel$," ",fdel$ ! send blank g/p & %
		Endif
		List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	Next i 
	!
	List$[row]=esdel$ \ row=row+1
	!
	Call AddToStr(e$,rstr$,list$[])
	!
	Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	Call AddToStr(e$,rstr$,WebStr$)
	Call SetOutput(e$,rstr$)
	!
  Else
    include "src/callsuberr.inc"
 End Try
End Sub ! done with "SSCAN"
!
!-----------------------------------------------------------------------------------------
sub OpenFiles()
  !
  ! Open files for product screen
  !
  Try
    !
	CTLC = OpenFile(-9999,intCo) \ If CTLC = -1 Error 42 !control
	PRC = OpenFile(1792,intCo) \ If PRC = -1 Error 42 ! prod
	WHC = OpenFile(1744,intCo) \ If WHC = -1 Error 42 ! prodwhse
	CCC = OpenFile(-1728,intCo) \ If CCC = -1 Error 42 ! u/m codes file
	MTC = OpenFile(-2272,intCo) \ If MTC = -1 Error 42 ! mat codes file
	PCC = OpenFile(-1984,intCo) \ If PCC = -1 Error 42 ! prod cat file
	VNC = OpenFile(-2400,intCo) \ If VNC = -1 Error 42 ! vendor file
	AVC = OpenFile(-1568,intCo) \ if AVC = -1 error 42 ! alternate vendor file
	KWC = OpenFile(9979,intCo) \ if KWC = -1 error 42 ! product key word 
	PTC = OpenFile(-944,intCo) \ if PTC = -1 error 42 ! product tax type
	BRC = OpenFile(-1952,intCo) \ if BRC = -1 error 42 ! product break table
	PRMC = OpenFile("SPRICEMARK",intCo,"R") \ if PRMC = -1 error 42 ! price markup table
	SPMC = OpenFile(-1712,intCo) \ if SPMC = -1 error 42 ! product markup table
	HNC = OpenFile(-2784,intCo) \ if HNC = -1 error 42 ! hazard name
	UDA = OpenFile(9967,intCo) \ if UDA = -1 error 42 ! product user define fields
	PSC = OpenFile(2080,IntCo) \ if PSC = -1 Error 42 ! product sales
	CMC = OpenFile(-2288,IntCo) \ if CMC = -1 Error 42 ! commod code
	pdc = OpenFile(1104,IntCo) \ if PDC = -1 Error 42 ! prod desc index
	msd = OpenFile(-672,IntCo) \ if msd = -1 Error 42 ! msds file
	udc=findchannel()
	tmp$="2/usrdefcat"+STR$(Intco)
	try
		ROpen #UDC,tmp$
	Else
		UDC=0
	End try
	prdurl=0;prdref=0 ! default = files not built
	tmp$="2/produrl"+STR$(IntCo)
	call findf(tmp$,prdurl)
	if prdurl ! exists - open it
		CH_PURL=findchannel()
		Open #CH_PURL,tmp$
	Endif
	LET tmp$="2/prodref"+STR$(IntCo)    
	CALL FINDF(tmp$,FOUND)
	IF FOUND 
	   let ch_prodref=findchannel()
	   open #CH_PRODREF,tmp$
	endif
	LET tmp$="2/prodrefs" ! HAS COMPANY # (Walter E. Nelson - 8 cos)
	CALL FINDF(tmp$,FOUND)
	IF FOUND                         
	   let ch_prodrefs=findchannel()             
	   open #CH_PRODREFS,tmp$
	endif 
	Prdref=0 \ if ch_prodref<>0 let prdref=1 ! has main file - ok to prompt
	sqlChan = OpenMySQLMirror(e$)
    !
  else
    include "src/callsuberr.inc"
  end try
end sub ! openfiles
! 
!--------------------------------------------------------------------
Function getumfactor(x2,pr. as prod)
! from sent um(or factor) (in x2) - get um factor for it
! if no match - send factor back as um
 Try
	
	dim 3%,umrec
	dim 3%,factor
	let umrec=x2
	if umrec<0 ! is cwt?
		let factor=0
	Else
		factor=umrec ! default = same as sent (if no match)
	Endif
	if umrec=pr.BaseUM let factor=1
	if umrec=PR.UM2 let factor=pr.UM2Fact  
	if umrec=PR.UM3 let factor=pr.UM3Fact  
	if umrec=PR.UM4 let factor=pr.UM4Fact  
	if umrec=PR.UM5 let factor=pr.UM5Fact  
	if umrec=PR.UM6 let factor=pr.UM6Fact  
	if umrec=PR.UM7 let factor=pr.UM7Fact  
	if umrec=PR.UM8 let factor=pr.UM8Fact  
	
 else
    include "src/callsuberr.inc"
  end try
end function factor ! getumfactor
! 
!--------------------------------------------------------------------
Sub listpricemark(e$,list$[],maxrec,Chan)
! as the layout is WACKKO - for list price calc
 Try
	Dim PMDesc$[16]
	LET X2=999 ! MAX 999 RECS (1000-9999 are levels!?)
	list$[0]=bsdel$,"PRICEMARK",fdel$
	List$[1]="TBLNO",fdel$,"DESC",fdel$,"PTYPE",fdel$
	List$[2]="0",fdel$,"NONE",fdel$,"1",fdel$
	row=3
	FOR x=1 to x2
		try
			mat read #chan,x,0;pmdesc$;
		Else
			pmdesc$=""
		End try
		tmp$=RTrim$(PMDesc$)
		if tmp$<>""
			list$[row]=Str$(X),fdel$,tmp$,fdel$,"1",fdel$
			row=row+1
			if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
		Endif
	Next X
	List$[row]=esdel$
 else
    include "src/callsuberr.inc"
  end try
end sub ! listpricemark
! 
!--------------------------------------------------------------------
Sub listsprodmark(e$,list$[],maxrec,Chan)
! as the layout is WACKKO (10000+TBL) - FOR 10BRKT PRICE
 Try
	Dim PMDesc$[16]
	LET X2=999 ! MAX 999 RECS (1000-9999 are levels!)
	list$[0]=bsdel$,"SPRODMARK",fdel$
	List$[1]="TBLNO",fdel$,"DESC",fdel$,"PTYPE",fdel$
	List$[2]="0",fdel$,"NONE",fdel$,"2",fdel$
	row=3
	FOR x=1 to x2
		try
			mat read #chan,10000+x,0;pmdesc$;
		Else
			pmdesc$=""
		End try
		tmp$=RTrim$(PMDesc$)
		if tmp$<>""
			list$[row]=Str$(X),fdel$,tmp$,fdel$,"2",fdel$
			row=row+1
			if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
		Endif
	Next X
	List$[row]=esdel$
 else
    include "src/callsuberr.inc"
  end try
end sub ! listsprodmark
! 
!--------------------------------------------------------------------
Sub SndLists()
! send droplists
 Try
	! FIRST SYSTEM FLAGS
	Clear List$[]
	List$[0]=bsdel$,"SYSFLAGS",fdel$
	webstr$="PKGTYPE",fdel$,"IMPORT",FDEL$
! 	webstr$=webstr$,"AVGCS",FDEL$,"LOADCS",FDEL$,"POCS",FDEL$,"BASECS",FDEL$
! 	webstr$=webstr$,"COMMLVL",fdel$,"ROLLINV",FDEL$,"USECPI",fdel$,"CUSTOMCUST",fdel$
 	webstr$=webstr$,"ROLLINV",FDEL$,"USECPI",fdel$,"CUSTOMCUST",fdel$
	webstr$=Webstr$,"USEPRODURL",fdel$,"USEPRODLID",fdel$,"VENDREQD",fdel$
	List$[1]=webstr$
	Webstr$=P9$[20,20],fdel$,P60$[46,46],FDEL$
! 	webstr$=webstr$,Str$(cost_lev[0]),fdel$,str$(cost_lev[1]),fdel$
! 	webstr$=webstr$,Str$(cost_Lev[2]),fdel$,Str$(Cost_Lev[3]),fdel$
 	tmp$="N" \ if p61$[104,104]="Y" let tmp$="Y"
! 	webstr$=webstr$,Str$(Comm_lev),fdel$,tmp$,fdel$
 	webstr$=webstr$,tmp$,fdel$
	tmp$="N" \ if p61$[111,111]="Y" let tmp$="Y"
	webstr$=webstr$,tmp$,fdel$
	webstr$=webstr$,RTRIM$(Custom_customer$),fdel$ ! custom_cust
	tmp$="N" \ if prdurl let tmp$="Y"
	webstr$=webstr$,tmp$,fdel$ ! uses produrl file
	tmp$="N" \ if prdref let tmp$="Y"
	webstr$=webstr$,tmp$,fdel$ ! uses prodref files
	tmp$="N" \ if p61$[126,126]="Y" let tmp$="Y"
	webstr$=webstr$,tmp$,fdel$ ! vendor required
	List$[2]=Webstr$
	LIST$[3]=esdel$
	call addtostr(e$,rstr$,list$[])
	Clear List$[]
	!!-!Building section for MATCODE
      call filedroplistmatcode(e$,list$[],100,MTC)
      call addToStr(e$,rstr$,list$[])

      !!-!Building section for SPRODCATGY
	  Clear List$[]
      ! chan=openfile("SPRODCATGY",intco,"R") ! ALREADY OPEN
      call filedroplistsprodcatgy(e$,list$[],100,PCC)
      call addToStr(e$,rstr$,list$[])

      !!-!Building section for CCODES  u/m codes
	  IF PROD$<>BLANK$[1,12]
		SEARKEY$=PROD$
		PRR=FILEGETPROD(e$,PRC,"=",1,SearKey$,PR.)
		IF PRR<=0
			CLEAR PR.
		ENDIF
	  ENDIF
	  Clear list$[]
	  CLEAR FIELDS$[]
	  CLEAR TMP$
	  LET TMP$="F" ! for all per commitee
	  if pr.CatchwgtItem$="Y" let tmp$="W"
      call filedroplistccodesz(e$,list$[],100,CCC,"",Fields$[],1,"",tmp$)
	  call addToStr(e$,rstr$,list$[])

	  !!-! price types
	  clear list$[]
	  list$[0]=bsdel$,"PTYPES",fdel$
	  list$[1]="PTYPE",fdel$,"Description",fdel$
	  list$[2]="1",fdel$,PriceTypeDesc$(e$,1),fdel$
	  list$[3]="2",fdel$,PriceTypeDesc$(e$,2),fdel$
	  list$[4]=esdel$
	  call addtostr(e$,rstr$,list$[])

	  !!-!BRKTBL
	  clear list$[]
	  call filedroplistbrktbl(e$,list$[],100,BRC,"",fields$[],"0")  !"0" parameter adds  0 None to drop list)
	  call addToStr(e$,rstr$,list$[])

      !!-!Building section for PRICEMARK (depends on pricetypes!)
	  clear list$[]
      call listpricemark(e$,list$[],100,PRMC)
      call addToStr(e$,rstr$,list$[])
	  !! - Send 10 brkt SPRODMARK (send both - let web decide
	  clear list$[]
	  call listsprodmark(e$,List$[],100,SPMC)
	  call addToStr(e$,rstr$,list$[])

	  !!-!Building section for POOCNFRT
      chan=openfile("POOCNFRT",intco,"R")
      call filedroplistpoocnfrt(e$,list$[],100,chan,"",fields$[],"0")  !"0" parameter adds  0 None to drop list)
      call addToStr(e$,rstr$,list$[])
      close #chan

	  !!-!Building section for POCDUTY
      chan=openfile("POCDUTY",intco,"R")
      call filedroplistpocduty(e$,list$[],100,chan,"",fields$[],"0")  !"0" parameter adds  0 None to drop list)
      call addToStr(e$,rstr$,list$[])
      close #chan

	  !!-!PTAXTYPE
	  clear list$[]
	  call filedroplistptaxtype(e$,list$[],100,PTC)
	  call addToStr(e$,rstr$,list$[])

	 
	  !!-!LOADMARK
	  chan=openfile(-9941,intco)
	  clear list$[]
	  call filedroplistloadmarkx(e$,list$[],100,chan,"",fields$[],"0") !and 0=none
	  call addToStr(e$,rstr$,list$[])
	  close #chan

	  !!-!MSDS
	  ! chan=openfile(-672,intco)
	  clear list$[]
	  LIST$[0]=bsdel$,"MSDS",fdel$
	  List$[1]="ID",fdel$,"DESC",fdel$
	  List$[2]="0",fdel$,"NONE",fdel$
	  row=3
	  SearKey$=" ",SearKey$
	  do
		R=filegetmsdfle(e$,msd,">",1,searkey$,msds.)
		if r<0 exit do
		tmp$=RTrim$(msds.Desc$)
		list$[row]=LTrim$(Searkey$),fdel$,tmp$,fdel$
		row=row+1
		if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	  loop
	  List$[row]=esdel$
	  ! close #chan
	  call addToStr(e$,rstr$,list$[])
	  !!-!Building section for COMMODITY - can't do, too large
      !chan=openfile("COMMODITY",intco,"R") ! WRONG FILE!!
	  CLEAR list$[]
      call filedroplistcommhead(e$,list$[],500,CMC)
      call addToStr(e$,rstr$,list$[])
      !close #chan

	  !! COST GROUPS
	  Chan=OpenFile(-9916,Intco)
	  clear list$[]
	  call filedroplistcostgrp(e$,list$[],100,chan,"",fields$[],1,"","B")  !"B" parameter adds  Blank None to drop list)
      call addToStr(e$,rstr$,list$[])
      close #chan

	! all done
	! Call programdump("tmp/pdlog1!","")
	Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	Call AddToStr(e$,rstr$,WebStr$)
    call SetOutPut(e$,rstr$)
 else
    include "src/callsuberr.inc"
  end try
end sub ! SndLists
! 
!--------------------------------------------------------------------
Sub ProdSave()
! get all data
  Try
	if Prodrec>0 ! existing
			call dpturbo(e$,CTLC,IntCo,Prodrec,pr.) ! delete turbo
	Else ! NEW - space fill strings not mentioned
			clear pr.
			pr.NU$="12345";pr.SnModelNum$=B$;pr.HazardClass$=b$
			pr.UpdTrdserv$=b$;pr.UdAlpha1$=b$;pr.HazPackingGrp$=b$
			pr.PreOrdInd$=b$;pr.UdAlpha2$=b$;pr.HazIDNum$=b$
			pr.InsDept$=b$;pr.UdAlpha3$=b$;pr.ERGuildXref$=b$
			pr.PrdtnListCode$=b$;pr.OtherHazDesc$=b$
			pr.Grade$=b$;pr.Grain$=b$;pr.NU1$=b$
			pr.SupersedeCode$=b$;pr.PackSize$=b$
			pr.CostDiscOverrides$=b$;pr.ByPassGPMerch$=b$
			pr.PickAtNight$=b$;pr.CutItem$=b$;pr.sOpen$=b$
			pr.MarkupType$=b$;pr.Picturefile$=b$;pr.Spare1$=b$
			pr.PrimalItem$=b$;pr.Longdescfile$=b$
			pr.MsdsFile$=b$;pr.BlankForKey$=b$;PR.Space$=b$
			pr.NProdId$=B$
	Endif
	pr.NProdId$=pr.NProdId$+B$ ! new field - make sure no nulls
	! call dxsave(0,"tmp/prodsv.txt!")
		pr.ProdCode$=prodkey$
       call DXGet("SupersedeCode",tmp$)\pr.SupersedeCode$=UCase$(tmp$),b$
	   IF pr.SupersedeCode$=pr.ProdCode$
		returnstatus=0
		message$="Cannot Supersede same as product"
		goto PSaveDone
	   Else ! sent something
		if RTrim$(tmp$)<>""
			SearKey$=PR.SupersedeCode$
			tmp3 = filegetprod(e$,PRC,"=",1,SearKey$,DupPR.)
			if tmp3<0
				returnstatus=0
				message$="Supersede does not exist"
				goto PSaveDone
			Endif ! not found
		 Endif ! sent super
	   Endif
	   call DXGet("Description1",tmp$)\pr.Desc1$=tmp$,b$
	   if pr.desc1$=blank$[1,30]
		returnstatus=0
		Message$="Description 1 is required!"
		Goto PSaveDone
	   Endif
	   strgok=chkbadchars(e$,pr.desc1$)
	   if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Description 1"
		goto PSaveDone
	   Endif
	   call DXGet("Description2",tmp$)\pr.Desc2$=tmp$,b$
	   strgok=chkbadchars(e$,pr.desc2$)
	   if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Description 2"
		goto PSaveDone
	   Endif
	   call DXGet("MaterialCode",tmp$)\pr.MatCode$=tmp$,b$
	   if pr.MatCode$=blank$[1,1]
		returnstatus=0
		Message$="Material Code is required!"
		Goto PSaveDone
	   Endif
	   call DXGet("Substitute1",tmp$)\pr.AltPart1$=UCase$(tmp$),b$
	   IF pr.AltPart1$=pr.ProdCode$
		returnstatus=0
		message$="Cannot substitute same as product"
		goto PSaveDone
	   Else ! sent something
		if RTrim$(tmp$)<>""
			SearKey$=PR.AltPart1$
			tmp3 = filegetprod(e$,PRC,"=",1,SearKey$,DupPR.)
			if tmp3<0
				returnstatus=0
				message$="Substitute 1 does not exist"
				goto PSaveDone
			Endif ! not found
		 Endif ! sent subst
	   Endif
	   call DXGet("Substitute2",tmp$)\pr.AltPart2$=UCase$(tmp$),b$
	   IF pr.AltPart2$=pr.ProdCode$
		returnstatus=0
		message$="Cannot substitute same as product"
		goto PSaveDone
	   Else ! sent something
		if RTrim$(tmp$)<>""
			SearKey$=PR.AltPart2$
			tmp3 = filegetprod(e$,PRC,"=",1,SearKey$,DupPR.)
			if tmp3<0
				returnstatus=0
				message$="Substitute 2 does not exist"
				goto PSaveDone
			Endif ! not found
		 Endif ! sent subst
	   Endif
	   call DXGet("SalesCategory",tmp$)  \ pr.prodCat=tmp$
	   if pr.prodCat<=0
		returnstatus=0
		Message$="Sales Category is required!"
		Goto PSaveDone
	   Endif
	   call DXGet("COMMCODE",tmp$)\pr.ComdtyCode$=tmp$+blank$
	   if pr.ComdtyCode$=blank$[1,4]
		returnstatus=0
		message$="Commodity Code is required"
		goto PSaveDone
	   Endif
	   tmp2$=pr.ComdtyCode$
	   search #CMC,2,1;tmp2$,R,E
	   if e
		returnstatus=0
		message$="Commodity Code not found"
		goto PSaveDone
	   Endif
	   vitemflag=0 ! flag for which item changed: vend or venditem
	   call DXGet("VendorItemCode",tmp$) \ tmp$ = ucase$(tmp$)
	   if rtrim$(tmp$)<>rtrim$(pr.venditem$) let vitemflag=1 ! changed vitem
	   pr.VendItem$=tmp$,b$
	   strgok=chkbadchars(e$,pr.VendItem$)
	   if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Vendor Item"
		goto PSaveDone
	   Endif
	   ! call DXGet("VendorCode",tmp$)              \ pr.PrimVend=tmp$
	  call dxget("CatchweightItem",tmp$)\pr.CatchWgtItm=0\if tmp$="Y" let pr.CatchWgtItm=-3
	  if tmp$<>"Y" Let tmp$="N"
	  pr.CatchwgtItem$=tmp$
	  !shelf life
	  call dxget("MfrShelfLife",tmp$)\pr.ShelfLifeMos=tmp$
	  call dxget("DistShelfLife",tmp$)\pr.DistribShelLife=tmp$
	  call dxget("CustShelfLife",tmp$)\pr.CustShelfLife=tmp$
	  call dxget("ROLLLBITEM",tmp$)\ pr.RollLbItem$=tmp$+blank$
	  if pr.RollLbItem$<>"Y" Let pr.RollLbItem$="N"
	  !"UNITOFMEASURE"
	  if pr.RollLbItem$="Y" and rlum=0
		ReturnStatus=0
		Message$="The UM ROLL is not defined!"
		goto PSaveDone
	  Endif
	  if p61$[104,104]="Y" ! system flag (base must be lb or lbs)
		call dxget("ROLLINV",tmp$)
		if UCase$(RTrim$(tmp$))="Y" let pr.ROLLINV$="Y" Else let pr.ROLLINV$="N"
	  Else
		pr.ROLLINV$="N"
	  Endif
	  call dxget("BaseUM",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?  ALWAYS               
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R > 0 Let tmp$ = Str$(R)                  
	  !End If   
	  x1=tmp$
	  IF Prodrec>0 and x1<>pr.baseum ! changing base? chk if used
	    x2=-1 ! check only mode
		!PRS=OpenFile(-2080,intCo)  \ If PRS=-1 Error 42    ! prodsls
		X1[0]=IntCo;x1[1]=ctlc;x1[2]=PRC;x1[3]=PSC;e$=""
		call "proddel.dl4",x2,PROD$,Prodrec,tmp1$,x1[],e$,rstr$
		! Try Close #PRS Else REM
		if x2>0 or e$<>"" ! found something or error
			Returnstatus=0 ! message$ filled
			if e$=""
				message$="CAN NOT CHANGE UM: In Use by "+tmp1$
			else
				message$="ERROR IN CHECKING Base UM Usage: "+e$
			Endif
			goto PSaveDone
		Endif
	  Endif
	  pr.BaseUM=tmp$
	  if pr.BaseUM<=0
		returnstatus=0
		Message$="Base UM is required!"
		if pr.BaseUM<0 let Message$="UM is not valid for Base UM"
		Goto PSaveDone
	  Endif
	  FNDRLUM=1 ! default - has roll um or don't care
	  if pr.RollLbItem$="Y" or pr.ROLLINV$="Y"
		if pr.baseum<>LBUM and pr.baseum<>lbsum
			returnstatus=0
			Message$="BASE UM MUST BE LB or LBS for Roll items!"
			goto PSaveDone
		Endif
		FndRlum=0 ! not found yet
	  Endif
	  call dxget("ValidUnits2",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R > 0 Let tmp$ = Str$(R)                  
	  !End If 
	  pr.UM2=tmp$
	  call dxget("BaseUnits2",tmp$)\pr.UM2Fact=tmp$
	  if pr.UM2Fact<=0 let pr.um2=0
	  if fra(pr.UM2Fact)
		Returnstatus=0
		Message$="NO FRACTIONS FOR CONVERT UNITS"
		goto PSaveDone
	  Endif
	  if pr.RollLbItem$="Y" and pr.um2=rlum let fndrlum=1
	  call dxget("ValidUnits3",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R > 0 Let tmp$ = Str$(R)                  
	  !End If
	  pr.UM3=tmp$
	  call dxget("BaseUnits3",tmp$)\pr.UM3Fact=tmp$
	  if pr.UM3Fact<=0 let pr.um3=0
	  if fra(pr.UM3Fact)
		Returnstatus=0
		Message$="NO FRACTIONS FOR CONVERT UNITS"
		goto PSaveDone
	  Endif
	  if pr.RollLbItem$="Y" and pr.um3=rlum let fndrlum=1
	  call dxget("ValidUnits4",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R > 0 Let tmp$ = Str$(R)                  
	  !End If    
	  pr.UM4=tmp$
	  call dxget("BaseUnits4",tmp$)\pr.UM4Fact=tmp$
	  if pr.UM4Fact<=0 let pr.um4=0
	  if fra(pr.UM4Fact)
		Returnstatus=0
		Message$="NO FRACTIONS FOR CONVERT UNITS"
		goto PSaveDone
	  Endif
  	  if pr.RollLbItem$="Y" and pr.um4=rlum let fndrlum=1
	  call dxget("ValidUnits5",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R > 0 Let tmp$ = Str$(R)                  
	  !End If    
	  pr.UM5=tmp$
	  call dxget("BaseUnits5",tmp$)\pr.UM5Fact=tmp$
	  if pr.UM5Fact<=0 let pr.um5=0
	  if fra(pr.UM5Fact)
		Returnstatus=0
		Message$="NO FRACTIONS FOR CONVERT UNITS"
		goto PSaveDone
	  Endif
	  if pr.RollLbItem$="Y" and pr.um5=rlum let fndrlum=1
	  call dxget("ValidUnits6",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R > 0 Let tmp$ = Str$(R)                  
	  !End If    
	  pr.UM6=tmp$
	  call dxget("BaseUnits6",tmp$)\pr.UM6Fact=tmp$
	  if pr.UM6Fact<=0 let pr.um6=0
	  if fra(pr.UM6Fact)
		Returnstatus=0
		Message$="NO FRACTIONS FOR CONVERT UNITS"
		goto PSaveDone
	  Endif
	  if pr.RollLbItem$="Y" and pr.um6=rlum let fndrlum=1
	  call dxget("ValidUnits7",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R > 0 Let tmp$ = Str$(R)                  
	  !End If    
	  pr.UM7=tmp$
	  call dxget("BaseUnits7",tmp$)\pr.UM7Fact=tmp$
	  if pr.UM7Fact<=0 let pr.um7=0
	  if fra(pr.UM7Fact)
		Returnstatus=0
		Message$="NO FRACTIONS FOR CONVERT UNITS"
		goto PSaveDone
	  Endif
	  if pr.RollLbItem$="Y" and pr.um7=rlum let fndrlum=1
	  call dxget("ValidUnits8",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R > 0 Let tmp$ = Str$(R)                  
	  !End If    
	  pr.UM8=tmp$
	  call dxget("BaseUnits8",tmp$)\pr.UM8Fact=tmp$
	  if pr.UM8Fact<=0 let pr.um8=0
	  if fra(pr.UM8Fact)
		Returnstatus=0
		Message$="NO FRACTIONS FOR CONVERT UNITS"
		goto PSaveDone
	  Endif
	  if pr.RollLbItem$="Y" and pr.um8=rlum let fndrlum=1
	  if pr.RollLbItem$="Y" and fndrlum=0
		returnstatus=0
		Message$="UM ROLL not used as a UM on product!"
		Goto PSaveDone
	  Endif
	 
	  ! check um's
	  For X1=0 to 7
		if x1=0 let umrec=pr.baseum
		if x1=1 let umrec=pr.UM2
		if x1=2 let umrec=pr.UM3
		if x1=3 let umrec=pr.UM4
		if x1=4 let umrec=pr.UM5
		if x1=5 let umrec=pr.UM6
		if x1=6 let umrec=pr.UM7
		if x1=7 let umrec=pr.UM8
		If UMRec>0
			r=checkum(umrec,x1) ! check for dupes / valid etc
		  if r>0 ! not ok
			Returnstatus=0
			If R=1 Message$="U/M "+Str$(X1)+" is Not Valid"
			If R=2 Message$="U/M "+Str$(X1)+" is already Used"
			If R=3 Message$="U/M "+Str$(x1)+" cannot change. In use on Order "+Str$(L2[1])
			goto PSaveDone
		  Endif
		Else ! system or 0
		  if UMRec<0 
			let Message$="U/M "+Str$(X1)+" cannot be used for UM"
			returnstatus=0
			goto PSaveDone
		  Endif
		Endif
	  Next X1
	  !"ITEMCONTROL"
	  call dxget("DateEstablish",tmp$)
	  if tmp$="N/A" 
	   let pr.DateRecEstab=999999
	  else
	   tmp2$=tmp$[9,10],tmp$[1,2],tmp$[4,5] !mm/dd/yyyy to yymmdd
	   pr.DateRecEstab=tmp2$
	  end if
	  
	  call dxget("LotControl",tmp$)\pr.LotCtrl$=tmp$,b$
	  if pr.Lotctrl$<>"Y" Let pr.Lotctrl$="N"
	  call dxget("SerialNumbers",tmp$)\pr.SerNoTrack$=tmp$,b$
	  if pr.sernotrack$<>"Y" LET pr.sernotrack$="N"
	  if p60$[25,25]<>"Y" and pr.sernotrack$="Y" ! we gotta check
		returnstatus=0
		message$="Serial Numbers not available!"
		goto PSaveDone
	  Endif
	  call dxget("SendtoWeb",tmp$)\pr.eccosflag=0\if tmp$="Y" let pr.eccosflag=1
	  if tmp$="P" let pr.Eccosflag=2 ! new - private label
	  if tmp$="D" let pr.Eccosflag=3 ! new - mill/direct
	  call dxget("TaxTypeCode",tmp$)\pr.TaxType=tmp$
	  if pr.taxtype<=0
		returnstatus=0
		message$="Tax Type is required"
		Goto PSaveDone
	  Endif
	  ! added for task 49939 - 2 Inventory Class fields
	  call dxget("InvClass1",tmp$)
	  if rtrim$(tmp$)<>"" ! no update if not sent! (don't zero system calc)
		x2=tmp$
		if x2<0 or x2>99 or fra(x2) ! 0-99 integer ONLY
			returnstatus=0
			message$="Invalid Entry - Inventory Class 1 is 0 to 99"
			Goto PSaveDone
		  Endif
		 pr.InventClass1=x2
	  Endif
	  call dxget("InvClass2",tmp$)
	  if rtrim$(tmp$)<>"" ! no update if not sent! (don't zero system calc)
		x2=tmp$
		if x2<0 or x2>99 or fra(x2) ! 0-99 integer ONLY
			returnstatus=0
			message$="Invalid Entry - Inventory Class 2 is 0 to 99"
			Goto PSaveDone
		  Endif
		 pr.InventClass2=x2
	  Endif
	  call dxget("CntWeek",tmp$)
	  if rtrim$(tmp$)<>"" ! no update if not sent! (don't zero system calc)
		x2=tmp$
		if x2<-1 or x2>52 or fra(x2) ! -1 - 52 integer ONLY
			returnstatus=0
			message$="Invalid Entry - Count Week is -1 to 52"
			Goto PSaveDone
		  Endif
		 pr.CntWeek=x2
	  Endif
	  !"VENDORMFG"
	  call dxget("MakeBuyFlag",tmp$)\pr.MBFlg$=tmp$,b$
	  if pr.MBFlg$<>"M" let pr.MBFlg$="B"
	  call dxget("PrimaryVendor",tmp$)
	  x2=tmp$ \ if x2<>pr.primvend and vitemflag<>0 let vitemflag=vitemflag+1 ! 0 or 2=both
	  if x2<=0 and p61$[126,126]="Y" ! vendor is required!!
		returnstatus=0
		message$="Vendor is required"
		Goto PSaveDone
	  Endif
	  IF x2>999999
		let returnstatus=0
		let message$="Vendor Code Must Not Be Greater Than 999999"
		goto PSaveDone
	Endif
	  pr.PrimVend=tmp$ ! DUPE?? NO - Above is!
	  
	  ! call dxget("VendorItemNo",tmp$)\pr.VendItem$=tmp$,b$ ! DUPE??
	  call dxget("AvgLeadTime",tmp$) ! sent days
	  x3=tmp$
	  pr.Leadtime=X3/mthdays ! tmp$
	  call dxget("DefaultPurchUnit",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R <> 0 Let tmp$ = Str$(R)                  
	  !End If    
	  pr.UMPurchDefault=tmp$
	  if pr.UMPurchDefault<=0
		returnstatus=0
		message$="Valid Purchasing UM is required"
		Goto PSaveDone
	  Else
		umrec=pr.UMPurchDefault
		R=ChkPrdUM(e$,umrec,IntCo,Pr.)
		if r=0 ! not found
		  returnstatus=0
		  message$="Purchasing UM not defined"
		  Goto PSaveDone
		Endif
	  Endif
	  call dxget("VendorOrderUnit",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R <> 0 Let tmp$ = Str$(R)                  
	  !End If    
	  pr.UMVendOrd=tmp$
	  if pr.UMVendOrd<=0
		returnstatus=0
		message$="Vendor Order UM is required"
		Goto PSaveDone
	  Else
		umrec=pr.UMVendOrd
		R=ChkPrdUM(e$,umrec,IntCo,Pr.)
		if r=0 ! not found
		  returnstatus=0
		  message$="Vendor Ordering UM not defined"
		  Goto PSaveDone
		Endif
	  Endif
	  call dxget("RevisionLevel",tmp$)\pr.RevLvl$=tmp$,b$
	  strgok=chkbadchars(e$,pr.RevLvl$)
	   if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Revision Level"
		goto PSaveDone
	   Endif	  
	  call dxget("QuantityBatch",tmp$)\pr.QtyPerStrkBtch=tmp$
	  call dxget("DefaultProductionUnit",tmp$)
	  If RTrim$(tmp$)<> "" ! sent somethinh
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R <> 0 Let tmp$ = Str$(R)                  
	  End If    
	  pr.UMPrdtnDefault=tmp$ !if P9$[2,2]="M"
	  if P9$[2,2]="M"
	   if pr.UMPrdtnDefault<=0
		returnstatus=0
		message$="Production UM is required"
		Goto PSaveDone
	   Endif
	  Endif ! mfg requires
	  ! now dual use - PWO and POS
	  If pr.UMPrdtnDefault<>0 ! if entered - check it!
		umrec=pr.UMPrdtnDefault
		R=ChkPrdUM(e$,umrec,IntCo,Pr.)
		if r=0 ! not found
		  returnstatus=0
		  message$="POS/Production UM not defined"
		  Goto PSaveDone
		Endif
		If umrec<0
			returnstatus=0
			message$="POS/Production UM is not a Selling UM"
			goto PSaveDone
		endif
	  Endif
	  
	  !"PRICECONTROL"
	  call dxget("PriceType",tmp$)\pr.PriceType=tmp$
	  if pr.pricetype<=0
		returnstatus=0
		message$="Price Type is required"
		Goto PSaveDone
	  Endif
	  call dxget("MarkupTable",tmp$)\pr.MUpTbl=tmp$
	  if custom_customer$="PRBRICK" let pr.pricetype=1;pr.MUpTbl=0
	  call dxget("BreakTableNo",tmp$)\pr.BrkTbl=tmp$
	  call dxget("PriceUpCharge",tmp$)\pr.PriceUpchrg=tmp$
	  call dxget("CostUpCharge",tmp$)\pr.LoadCostUpchrg=tmp$
	  call dxget("UpChargeUnit",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R <> 0 Let tmp$ = Str$(R)                  
	  !End If    
	  pr.UMUpChrg=tmp$
	  if pr.UMUpChrg=0
		returnstatus=0
		message$="Up Charge UM is required"
		Goto PSaveDone
	  Else
		umrec=pr.UMUpChrg
		R=ChkPrdUM(e$,umrec,IntCo,Pr.)
		if r=0 ! not found
		  returnstatus=0
		  message$="Up Charge UM not defined"
		  Goto PSaveDone
		Endif
	  Endif
	  call dxget("BypassGP",tmp$)\pr.ByPassGPMerch$=tmp$,b$
	  call dxget("SupersedePricing",tmp$)\pr.SuperPrcCalc$=tmp$,b$
	  call dxget("OceanFreight",tmp$)\pr.OceanFrgtRec=tmp$
	  call dxget("CustomDuty",tmp$)\pr.CustomDutyRec=tmp$
	  call dxget("CostUpdateGroup",tmp$) ! now has table to check
	  pr.CostUpdGrp$=tmp$,b$
	  chan=openfile(-9916,Intco)
	  if chan>0 ! has file check it
		if pr.costupdgrp$<>blank$[1,11]
			SearKey$=PR.costupdgrp$+Blank$[1,1]
			searkey$[13]="" ! cut to size
			search #chan,2,1;searkey$,r[88],E
			try close #chan Else Rem
			if e
				returnstatus=0
				message$="Cost Update Group not defined"
				goto PSaveDone
			Endif
		Endif ! blank is ok
	  Endif ! has costgrp file
	  call dxget("Commission",tmp$)
	  if comm_lev=1000 let pr.CommPct=tmp$
	  call dxget("DefaultPriceUM",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R <> 0 Let tmp$ = Str$(R)                  
	  !End If    
	  pr.UMPriceDefault=tmp$
	  if pr.UMPriceDefault=0
		returnstatus=0
		message$="Price UM is required"
		Goto PSaveDone
	  Else
		umrec=pr.UMPriceDefault
		R=ChkPrdUM(e$,umrec,IntCo,Pr.)
		if r=0 ! not found
		  returnstatus=0
		  message$="Pricing UM not defined"
		  Goto PSaveDone
		Endif
	  Endif
	  !if pr.CatchwgtItem$="Y" and pr.UMPriceDefault<>-3
		!Returnstatus=0
		!Message$="Price Default MUST BE UM LB on Catch Weight"
		!goto PSaveDone
	  !Endif
	  call dxget("DefaultCostingUM",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R <> 0 Let tmp$ = Str$(R)                  
	  !End If    
	  pr.UMCostDefault=tmp$
	  if pr.UMCostDefault=0
		returnstatus=0
		message$="Cost UM is required"
		Goto PSaveDone
	  Else
		umrec=pr.UMCostDefault
		R=ChkPrdUM(e$,umrec,IntCo,Pr.)
		if r=0 ! not found
		  returnstatus=0
		  message$="Costing UM not defined"
		  Goto PSaveDone
		Endif
	  Endif
	  !if pr.CatchwgtItem$="Y" and pr.UMCostDefault<>-3
		!Returnstatus=0
		!Message$="Cost Default MUST BE UM LB on Catch Weight"
		!goto PSaveDone
	  !Endif
	  call dxget("DefaultStockingUM",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R <> 0 Let tmp$ = Str$(R)                  
	  !End If    
	  pr.UMStkDefault=tmp$
	  if pr.UMStkDefault<=0
		returnstatus=0
		message$="Valid Stocking UM is required"
		Goto PSaveDone
	  Else
		umrec=pr.UMStkDefault
		R=ChkPrdUM(e$,umrec,IntCo,Pr.)
		if r=0 ! not found
		  returnstatus=0
		  message$="Stocking UM not defined"
		  Goto PSaveDone
		Endif
	  Endif
	  call dxget("DefaultSellingUM",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R <> 0 Let tmp$ = Str$(R)                  
	  !End If    
	  pr.UMSellDefault=tmp$
	  if pr.UMSellDefault<=0
		returnstatus=0
		message$="Valid Selling UM is required"
		Goto PSaveDone
	  Else
		umrec=pr.UMSellDefault
		R=ChkPrdUM(e$,umrec,IntCo,Pr.)
		if r=0 ! not found
		  returnstatus=0
		  message$="Selling UM not defined"
		  Goto PSaveDone
		Endif
	  Endif
	  !call dxget("MINQTY",tmp$)\pr.MinQty=tmp$ ! moved to whse?
	  !CALL dxget("MAXQTY",tmp$)\pr.MaxQty=tmp$ ! on whse?
	  call dxget("CubicFeet",tmp$)\pr.CubicFeet=tmp$
	  if pr.CubicFeet<=0 let pr.CubicFeet=1
	  call dxget("CubicFtFactor",tmp$)
	  !If tmp$[1,1] > "9" ! sent um text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R <> 0 Let tmp$ = Str$(R)                  
	  !End If
	  x2=tmp$
	  r=getumfactor(x2,pr.)
	  pr.CubicFtFactor=R
	  if pr.CubicFtFactor<=0
		Returnstatus=0
		Message$="NO Cube Factor sent"
		Goto PSaveDone
	  Endif
	  call dxget("LbsUnit",tmp$)\pr.LbsUnit=tmp$
	  if pr.LbsUnit<=0 let pr.LbsUnit=1
	  call dxget("LbsFact",tmp$)
	  !If tmp$[1,1] > "9" ! sent um text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R <> 0 Let tmp$ = Str$(R)                  
	  !End If  
	  x2=tmp$
	  r=getumfactor(x2,pr.)
	  pr.LbsFact=r
	  if pr.LbsFact<=0
		Returnstatus=0
		Message$="NO Lbs Factor sent"
		Goto PSaveDone
	  Endif
	  call dxget("PriceUpType",tmp$)\pr.PriceUpchrgType=0\if tmp$="$" let pr.PriceUpchrgType=1
	  call dxget("CostUpType",tmp$)\pr.LoadUpchgType=0\if tmp$="$" let pr.LoadUpchgType=1
	  if cost_lev[0] ! =2 ! enter/edit
		  call dxget("avgcost",tmp$)
		  If RTrim$(tmp$)<>""
		  x3=tmp$
		  If x3<0 or x3>99999999
			returnstatus=0
			message$="Invalid Avg Cost"
			goto PSaveDone
		  Endif
		  cnvtu[0]=pr.UMCostDefault;cnvtu[1]=0;cnvtu[2]=2
		  cnvta=x3
		  x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		  pr.CostAvg=x3
		  endif ! sent something
	  Endif
	  if cost_lev[1] ! =2 ! enter/edit (may need for all-base diff and lev=0)
		  call dxget("LOADCOST",TMP$)
		  If RTrim$(tmp$)<>""
		  x3=tmp$
		  If x3<0 or x3>99999999
			returnstatus=0
			message$="Invalid Load Cost"
			goto PSaveDone
		  Endif
		  cnvtu[0]=pr.UMCostDefault;cnvtu[1]=0;cnvtu[2]=2
		  cnvta=x3
		  x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		  pr.CostLoad=x3
		  endif ! sent something
		  call dxget("LDMkup",tmp$)\if rtrim$(tmp$)<>"" let pr.Load1MupTbl=tmp$
		  call dxget("Load2Cost",tmp$)
		  If RTrim$(tmp$)<>""
		  x3=tmp$
		  If x3<0 or x3>99999999
			returnstatus=0
			message$="Invalid Load 2 Cost"
			goto PSaveDone
		  Endif
		  cnvtu[0]=pr.UMCostDefault;cnvtu[1]=0;cnvtu[2]=2
		  cnvta=x3
		  x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		  pr.CostLoad2=x3
		  endif ! sent something
		  call dxget("LD2Mkup",tmp$)\if RTrim$(tmp$)<>"" let pr.Load2MupTbl=tmp$
	  Endif
	  if cost_lev[2] ! =2 ! enter/edit
		  call dxget("pocost",tmp$)
		  If RTrim$(tmp$)<>""
		  x3=tmp$
		  If x3<0 or x3>99999999
			returnstatus=0
			message$="Invalid PO Cost"
			goto PSaveDone
		  Endif
		  cnvtu[0]=pr.UMCostDefault;cnvtu[1]=0;cnvtu[2]=2
		  cnvta=x3
		  x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		  pr.CostPO=x3
		  Endif ! sent something
		  call dxget("netpocost",tmp$)
		  If RTrim$(tmp$)<>""
		  x3=tmp$
		  If x3<0 or x3>99999999
			returnstatus=0
			message$="Invalid Net PO Cost"
			goto PSaveDone
		  Endif
		  cnvtu[0]=pr.UMCostDefault;cnvtu[1]=0;cnvtu[2]=2
		  cnvta=x3
		  x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		  pr.CostNetPO=x3
		  Endif ! sent something
	  Endif
	  if cost_lev[3] ! =2 ! enter/edit
		  call dxget("basecost",tmp$)
		  If RTrim$(tmp$)<>""
		  x3=tmp$
		  If x3<0 or x3>99999999
			returnstatus=0
			message$="Invalid Base Cost"
			goto PSaveDone
		  Endif
		  cnvtu[0]=pr.UMCostDefault;cnvtu[1]=0;cnvtu[2]=2
		  cnvta=x3
		  x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		  pr.CostBase=x3
		  Endif ! sent something
	  endif
	  !if pr.PriceType<>1 OR (pr.PriceType=1 AND pr.MUpTbl=0) ! matrixtbl - no change
	  ! we are getting / writing lps as that is what mx671s does
		  call dxget("LP1",tmp$)\x3=tmp$
		  If x3<0 or x3>99999999
			returnstatus=0
			message$="Invalid List Price"
			goto PSaveDone
		  Endif
		  cnvtu[0]=pr.UMPriceDefault;cnvtu[1]=0;cnvtu[2]=2
		  cnvta=x3
		  x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		  pr.ListPrice1=x3
		  ! progressive brick - if change lp1-6 - recalc mup%
		  call dxget("LP2",tmp$)\x3=tmp$
		  If x3<0 or x3>99999999
			returnstatus=0
			message$="Invalid List Price"
			goto PSaveDone
		  Endif
		  cnvtu[0]=pr.UMPriceDefault;cnvtu[1]=0;cnvtu[2]=2
		  cnvta=x3
		  x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		  pr.ListPrice2=x3
		  call dxget("LP3",tmp$)\x3=tmp$
		  If x3<0 or x3>99999999
			returnstatus=0
			message$="Invalid List Price"
			goto PSaveDone
		  Endif
		  cnvtu[0]=pr.UMPriceDefault;cnvtu[1]=0;cnvtu[2]=2
		  cnvta=x3
		  x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		  pr.ListPrice3=x3
		  call dxget("LP4",tmp$)\x3=tmp$
		  If x3<0 or x3>99999999
			returnstatus=0
			message$="Invalid List Price"
			goto PSaveDone
		  Endif
		  cnvtu[0]=pr.UMPriceDefault;cnvtu[1]=0;cnvtu[2]=2
		  cnvta=x3
		  x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		  pr.ListPrice4=x3
		  call dxget("LP5",tmp$)\x3=tmp$
		  If x3<0 or x3>99999999
			returnstatus=0
			message$="Invalid List Price"
			goto PSaveDone
		  Endif
		  cnvtu[0]=pr.UMPriceDefault;cnvtu[1]=0;cnvtu[2]=2
		  cnvta=x3
		  x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		  pr.ListPrice5=x3
		  call dxget("LP6",tmp$)\x3=tmp$
		  If x3<0 or x3>99999999
			returnstatus=0
			message$="Invalid List Price"
			goto PSaveDone
		  Endif
		  cnvtu[0]=pr.UMPriceDefault;cnvtu[1]=0;cnvtu[2]=2
		  cnvta=x3
		  x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		  pr.ListPrice6=x3
	  ! Endif
	  if custom_customer$="PRBRICK" ! has manual listprcmarkups
		! for now - only if sent from frontend
		call dxget("Lp1Markup",tmp$)
		if rtrim$(tmp$)<>"" let pr.Lp1Markup=tmp$
		call dxget("Lp2Markup",tmp$)
		if rtrim$(tmp$)<>"" let pr.Lp2Markup=tmp$
		call dxget("Lp3Markup",tmp$)
		if rtrim$(tmp$)<>"" let pr.Lp3Markup=tmp$
		call dxget("Lp4Markup",tmp$)
		if rtrim$(tmp$)<>"" let pr.Lp4Markup=tmp$
		call dxget("Lp5Markup",tmp$)
		if rtrim$(tmp$)<>"" let pr.Lp5Markup=tmp$
		call dxget("Lp6Markup",tmp$)
		if rtrim$(tmp$)<>"" let pr.Lp6Markup=tmp$
	  Endif
	  call dxget("ExceptSale",tmp$)\pr.ExceptSale=tmp$
	  call dxget("ExceptLtd",tmp$)\pr.ExceptLtd=tmp$
	  CALL dxget("Msds",tmp$)\pr.Msds=tmp$
	  IF (pr.msds=0 and Trim$(tmp$)<>"0") or pr.msds<0 ! sent text? NG
		returnstatus=0
		message$="Invalid MSDS Entry"
		goto PSaveDone
	  Endif
	  if pr.Msds>0 ! zero=none
		  tmp$=pr.msds USING "#########" 
		  SEARCH #msd,2,1;tmp$,r,E
		  if e
			returnstatus=0
			message$="Invalid MSDS Sheet"
			goto PSaveDone
		  Endif
	  endif
	  call dxget("DotHazardous",tmp$)\pr.DotHazardous=0 \ if tmp$="Y" let pr.DotHazardous=1
	  if tmp$="S" let pr.DotHazardous=2
	  call dxget("PKDDESC",tmp$)\pr.PackingDateDesc$=tmp$+BLAnk$
	  strgok=chkbadchars(e$,pr.PackingDateDesc$)
	   if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Packing Desc"
		goto PSaveDone
	   Endif
	  call dxget("PKDFORMAT",tmp$)\pr.PackingDateFormat$=tmp$+Blank$
	  strgok=chkbadchars(e$,pr.PackingDateFormat$)
	   if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Packing Date"
		goto PSaveDone
	   Endif
	  call dxget("BROKENUM",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R <> 0 Let tmp$ = Str$(R)                  
	  !End If    
	  pr.UMBrknQty=tmp$
	  if pr.UMBrknQty<=0
		returnstatus=0
		message$="Broken UM is required"
		Goto PSaveDone
	  Else
		umrec=pr.UMBrknQty
		R=ChkPrdUM(e$,umrec,IntCo,Pr.)
		if r=0 ! not found
		  returnstatus=0
		  message$="Broken UM not defined"
		  Goto PSaveDone
		Endif
	  Endif
	  call dxget("PACKUM",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R <> 0 Let tmp$ = Str$(R)                  
	  !End If    
	  pr.UMPack=tmp$
	  if pr.UMPack<=0
		returnstatus=0
		message$="Packing UM is required"
		Goto PSaveDone
	  Else
		umrec=pr.UMPack
		R=ChkPrdUM(e$,umrec,IntCo,Pr.)
		if r=0 ! not found
		  returnstatus=0
		  message$="Packing UM not defined"
		  Goto PSaveDone
		Endif
	  Endif
	  call dxget("SIZEUM",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R <> 0 Let tmp$ = Str$(R)                  
	  !End If    
	  pr.UMSize=tmp$
	  if pr.UMSize<=0
		returnstatus=0
		message$="Product Size UM is required"
		Goto PSaveDone
	  Else
		umrec=pr.UMSize
		R=ChkPrdUM(e$,umrec,IntCo,Pr.)
		if r=0 ! not found
		  returnstatus=0
		  message$="Product Size UM not defined"
		  Goto PSaveDone
		Endif
	  Endif
	  !call dxget("SizeWidth",tmp$)\pr.SizeWidth=tmp$ ! ??grade?
	  call dxget("HighSUM",tmp$)\pr.HeightOfStkUM=tmp$
	  call dxget("WIDESUM",tmp$)\pr.WidthOfStkUM=tmp$
	  call dxget("LONGSUM",tmp$)\pr.LengthOfStkUM=tmp$
	  !call dxget("SizeLength",tmp$)\pr.SizeLength=tmp$ ! ??grade?
	  call dxget("PACKSIZE",tmp$)\pr.PackSize$=tmp$+Blank$
	  strgok=chkbadchars(e$,pr.PackSize$)
	   if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Packing Size"
		goto PSaveDone
	   Endif
	  call dxget("SERVSIZE",tmp$)\pr.ServingSize$=tmp$+Blank$
	  strgok=chkbadchars(e$,pr.ServingSize$)
	   if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Serving Size"
		goto PSaveDone
	   Endif
	  call dxget("NumOfServing",tmp$)\pr.NumOfServing=tmp$
	  call dxget("ServingFactor",tmp$)
	  !If tmp$[1,1] > "9" ! sent um text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R <> 0 Let tmp$ = Str$(R)                  
	  !End If 
	  x2=tmp$
	  r=getumfactor(x2,pr.)
	  pr.ServingFactor=r ! factor
	  ! new fields
	  Call dxget("PRODURL",tmp$)
	  produrl$=tmp$+Blank$ ! max 50
	  call dxget("PRODLID",tmp$) ! long prod id (35 chars)
	  hldlprod$=tmp$+Blank$ ! retain new entry
	  call dxget("VUWHSE",tmp$) \ udwvend=0
	  if UCase$(RTrim$(tmp$))="Y" let udwvend=1 ! update whse w/vendor chg
	  ! STILL NEEDED? - hazard,s/n?
	  pr.BlankForKey$=blank$
	  pr.Spare1$=blank$
	  if Prodrec>0 ! exists - look for changes
		read record #PRC,Prodrec,0;tmpPr.; ! copy of (and original b4 changes)
		if tmppr.CatchwgtItem$<>"Y" let tmppr.CatchwgtItem$="N" ! may not be set
		if pr.CatchwgtItem$<>"Y" let pr.CatchwgtItem$="N"
		IF tmppr.CatchwgtItem$<>pr.CatchwgtItem$ ! changing flag
			call ChkCWFlag(flag)
			If Flag=0 ! Not OK
				Returnstatus=0 ! message filled
				Goto PSaveDone
			Endif
		Endif
		if tmppr.CostLoad<>pr.CostLoad
			pr.PrevLoadCost=tmppr.CostLoad
			pr.DateLoadCstChg=currdate
			LET pch.ctype=1              
			lET pch.OldCost=tmppr.CostLoad   
			LET pch.NewCost=pr.CostLoad
			call update_cost_hist()
		Endif
		if tmppr.brktbl<>pr.brktbl
			pr.PrevBrkTbl=tmppr.brktbl
		endif
		if tmppr.muptbl<>pr.muptbl
			pr.PrevMupTbl=tmppr.muptbl
		endif
		if tmppr.costbase<>pr.costbase
			pr.PrevBaseCost=tmppr.costbase
			pr.DateBaseChg=currdate
			LET pch.ctype=5 
		    lET pch.OldCost=tmppr.costbase
		    LET pch.NewCost=pr.costbase
		    Call update_cost_hist()
		Endif
		if tmppr.costpo<>pr.costpo
			pr.PrevLastCost=tmppr.costpo
			pr.DateLastCostChg=currdate
			LET pch.ctype=3              
			lET pch.OldCost=tmppr.costpo    
			LET pch.NewCost=pr.costpo        
			call update_cost_hist()
		Endif
		if tmppr.Load1MupTbl<>pr.Load1MupTbl
			pr.PrevLoad1MupTbl=tmppr.Load1MupTbl
			LET pch.ctype=8;pch.oldcost=0;pch.newcost=0
			lET pch.OldLoadTbl1=tmppr.Load1MupTbl
			LET pch.NewLoadTbl1=pr.Load1MupTbl
			call update_cost_hist()
		Endif
		if tmppr.Load2MupTbl<>pr.Load2MupTbl
			pr.PrevLoad2MupTbl=tmppr.Load2MupTbl
			LET pch.ctype=9;pch.oldcost=0;pch.newcost=0
			lET pch.OldLoadTbl2=tmppr.Load2MupTbl
			LET pch.NewLoadTbl2=pr.Load2MupTbl  
			call update_cost_hist()
		Endif
		if tmppr.costload2<>pr.costload2
			pr.PrevLoad2Cost=tmppr.costload2
			pr.DateLoad2Chg=currdate
			LET pch.ctype=2              
			lET pch.OldCost=tmppr.costload2
			LET pch.NewCost=pr.costload2
			call update_cost_hist()
		Endif
		! record if avg,netpo,lastpo changed
		IF tmppr.CostNetPO<>pr.CostNetPO
			LET pch.ctype=4  
			lET pch.OldCost=tmppr.CostNetPO
			LET pch.NewCost=pr.CostNetPO
			call update_cost_hist()
		Endif
		if tmppr.CostNetPOLast<>pr.CostNetPOLast
			LET pch.ctype=10
			lET pch.OldCost=tmppr.CostNetPOLast
			LET pch.NewCost=pr.CostNetPOLast
			call update_cost_hist()
		Endif
		if tmppr.CostAvg<>pr.CostAvg
			LET pch.ctype=6
			lET pch.OldCost=tmppr.CostAvg
			LET pch.NewCost=pr.CostAvg
			call update_cost_hist()
		Endif
		if custom_customer$="PRBRICK" ! see if lp1-6 changed manually
		! this may need convert to price UM? as even slight Base chg is still a chg
		! ie: orig=2.43211 - new lp=2.43210 is technically a change!
			if tmppr.Listprice1 and tmppr.Listprice1<>pr.Listprice1
				LPCG=1 \ call GetNewLPMrk()
			endif
			if tmppr.Listprice2 and tmppr.Listprice2<>pr.Listprice2
				LPCG=2 \ call GetNewLPMrk()
			endif
			if tmppr.Listprice3 and tmppr.Listprice3<>pr.Listprice3
				LPCG=3 \ call GetNewLPMrk()
			endif
			if tmppr.Listprice4 and tmppr.Listprice4<>pr.Listprice4
				LPCG=4 \ call GetNewLPMrk()
			endif
			if tmppr.Listprice5 and tmppr.Listprice5<>pr.Listprice5
				LPCG=5 \ call GetNewLPMrk()
			endif
			if tmppr.Listprice6 and tmppr.Listprice6<>pr.Listprice6
				LPCG=6 \ call GetNewLPMrk()
			endif
		endif
		if tmppr.VendItem$<>pr.VendItem$ or tmppr.PrimVend<>pr.PrimVend
			if udwvend=1 ! want's update
				call uwvend()
			Endif
		Endif
		if tmppr.LbsFact<>pr.LbsFact or tmppr.LbsUnit<>pr.LbsUnit
			x1[0]=pr.UMCostDefault;x1[1]=pr.UMPriceDefault
			if (x1[0]=-1 or X1[0]=-3) or (x1[1]=-1 or x1[1]=-3) ! lb based cost/price
				! need to convert hidden cost/price to new base from old
				Call LBBased() ! already know it's existing rec
			Endif
		Endif
		!if tmppr.BlankForKey$<" " ! cannot use if null (causes be on change d2!!)
			tmppr.BlankForKey$=blank$ ! always!!
			tmppr.Spare1$=blank$ ! same
			write record #PRC,Prodrec,0;tmppr.; ! write OLD w/space
		!Endif
	Endif
	!Call dxsave(0,"tmp/prodin.txt!") ! save web data sent
	!Call programdump("tmp/plog1in!","")
	if Prodrec<=0 let mode$="a" else let mode$="c" !add new or change existing record
	pr.BlankForKey$=blank$
	pr.Spare1$=blank$
	aa=fileupdateprod(e$,PRC,mode$,Prodrec,PR.,0,0,-1) ! w/audit(not working!?)
	if aa<0 ! bad stat
		Returnstatus=0
		Message$=E$
	Else
		if mode$="a" let Prodrec=aa
		LET pr.sRecord=Prodrec
		if prdref ! multi dir index of long prodid
			call updtprdref()
			let pr.NProdId$=HldLprod$+Blank$ ! update file with new entry
		Endif
		pr.BlankForKey$=blank$ ! always!!
		pr.Spare1$=blank$ ! same
		write record #PRC,Prodrec,0;pr.; ! won't know record until added!
		if sqlChan>=0
			call prod_DL4SQLConvert(e$,"FROMDL4",pr.,sql_prod.,Prodrec)
			e = prod_SQLAddUpdate(e$,sqlChan,sql_prod.)
			if e<>1 error 11000
		end if
		If mode$="a" ! add mode
			clear prdsls.
			prdsls.ProdCode$=pr.ProdCode$ ! SET UP/WRITE PRODSLS!!
			write record #PSC,Prodrec,0;prdsls.;
		Endif
		! update turbo
		call apturbo(e$,CTLC,IntCo,Prodrec,pr.) ! add new turbo
		if tmppr.Desc1$<>pr.Desc1$ ! changed desc 1
			if mode$<>"a" ! not adding - so delete old
				ProdKey$=UCase$(tmppr.Desc1$)+Blank$;ProdKey$[31]=Prod$
				Search #PDC,5,1;prodkey$,R,E
			Endif
		Endif
		ProdKey$=UCase$(pr.Desc1$)+Blank$;ProdKey$[31]=Prod$
		Search #PDC,4,1;ProdKey$,Prodrec,E ! add/update pdesckey
		! additional files to possibly update
		if prdurl
			kprod$=" ",kprod$
			kprod$=PR.ProdCode$
			Search #ch_purl,2,1;kprod$,R[98],E
			if e ! add new
				let E=2;r[98]=0
				search #ch_purl,1,0;kprod$,r[98],e \ if e error 11000
				search #ch_purl,4,1;kprod$,r[98],e \ if e error 11000
			Endif
			MAT WRITE #ch_purl,r[98],0;PR.ProdCode$;                                          
			MAT WRITE #ch_purl,r[98],13;produrl$;
		Endif
		Returnstatus=1
		Message$="Record saved"
	Endif
	 PSaveDone: ! bypass save 
  else
    include "src/callsuberr.inc"
  end try
end sub ! ProdSave
! 
!--------------------------------------------------------------------
Function checkUM(umrec,upos)
! see if 1:invalid, 2:duped, 3:in use
! on the 8 u/m's valid
 Try
	! check on special flagged products
	Dim OKey$[60]
	dIM 1%,UN[2],EUN[2]
	Dim 2%,L2[1]
	Dim 3%,S3[17]
	if pr.CatchwgtItem$="Y"
		if umrec=LBUM let UMV=1 ! can't use LB on catchwgts
		Exit function UMV
	Endif
	if umrec<0 exit function 1 ! NO CWT, LOT, ETC for valid ums
	UMV=0 ! okay
	! last dupe check
	x1=upos
	if umrec=0 goto chkumdone ! no um or change to none

	if x1=0 exit function UM ! checking base to what? (2-8 chk'd!)
	if umrec=pr.baseum let umv=2 ! always check base
	if x1=1 goto chkumdone ! fall to next for 2+
	if umrec=pr.UM2 let umv=2
	if x1=2 goto chkumdone
	if umrec=pr.um3 let umv=2
	if x1=3 goto chkumdone
	if umrec=pr.um4 let umv=2
	if x1=4 goto chkumdone
	if umrec=pr.um5 let umv=2
	if x1=5 goto chkumdone
	if umrec=pr.um6 let umv=2
	if x1=6 goto chkumdone
	if umrec=pr.um7 let umv=2
	! can't check 8 against itself
	ChkUMDone: ! finished
	if not(umv) ! ok so far-now the check for change um
		if Prodrec>0 ! get existing
			read record #PRC,Prodrec,0;tmppr.;
			! base has own check
			if x1=1 let hldum=tmppr.um2
			if x1=2 let hldum=tmppr.um3
			if x1=3 let hldum=tmppr.um4
			if x1=4 let hldum=tmppr.um5
			if x1=5 let hldum=tmppr.um6
			if x1=6 let hldum=tmppr.um7
			if x1=7 let hldum=tmppr.um8
			if hldum and hldum<>umrec ! it's a change
				OLC=OpenFile(-1888,IntCo) \ if olc=-1 exit function UMV
				OKey$=" ",OKey$
				OKey$[1,6]=Prodrec Using "######"
				ROLLoop: ! Loop prods
				Search #OLC,3,2;OKey$,r,e
				x2=okey$[1,6] \ if x2<>Prodrec let e=2
				if Not(e) ! see if orig um was used
					MAT  READ #OLC,R,250;UN;      
					MAT  READ #OLC,R,260;S3;
					MAT  READ #OLC,R,0;L2;
					MAT  READ #OLC,R,446;EUN;
					FOR X=0 TO 2
					  IF UN[X]=hldum LET UMV=3
					NEXT X
					FOR X=0 TO 2
					  IF EUN[X]=hldum LET UMV=3
					NEXT X
					IF S3[8]=hldum LET UMV=3
					IF S3[11]=hldum LET UMV=3
					IF Not(UMV) goto ROLLoop
				Endif
				Close #OLC
			Endif ! diff um
		Endif ! existing prod
	Endif ! of no errors - check if diff
 else
    include "src/callsuberr.inc"
  end try
end function UMV ! checkUM
! 
!--------------------------------------------------------------------
Sub LBBased()
! as the user changed lb factors - need internal fields changed
! taken from mx671cc - tmppr.=orig prod, pr.=new prod
  Try
	Cnvtu[0]=0;cnvtu[1]=pr.UMCostDefault;cnvtu[2]=2
	if cost_lev[0]<2 ! avg cost not EDIT'd above
		Cnvtu[0]=0;cnvtu[1]=pr.UMCostDefault;cnvtu[2]=2
		cnvta=pr.CostAvg
		x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,tmpPR.)
		cnvta=x3
		x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		pr.CostAvg=x3
	Endif
	if cost_lev[1]<2 ! load cost
		Cnvtu[0]=0;cnvtu[1]=pr.UMCostDefault;cnvtu[2]=2
		cnvta=pr.CostLoad
		x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,tmpPR.)
		cnvta=x3
		x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		pr.CostLoad=x3
		Cnvtu[0]=0;cnvtu[1]=pr.UMCostDefault;cnvtu[2]=2
		cnvta=pr.CostLoad2
		x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,tmpPR.)
		cnvta=x3
		x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		pr.CostLoad2=x3
	Endif
	if cost_lev[2]<2 ! last/po cost
		Cnvtu[0]=0;cnvtu[1]=pr.UMCostDefault;cnvtu[2]=2
		cnvta=pr.CostPO
		x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,tmpPR.)
		cnvta=x3
		x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		pr.CostPO=x3
		Cnvtu[0]=0;cnvtu[1]=pr.UMCostDefault;cnvtu[2]=2
		cnvta=pr.CostNetPO
		x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,tmpPR.)
		cnvta=x3
		x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		pr.CostNetPO=x3
	Endif
	if cost_lev[3]<2 ! base cost
		Cnvtu[0]=0;cnvtu[1]=pr.UMCostDefault;cnvtu[2]=2
		cnvta=pr.CostBase
		x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,tmpPR.)
		cnvta=x3
		x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		pr.CostBase=x3
	Endif
	Cnvtu[0]=0;cnvtu[1]=pr.UMCostDefault;cnvtu[2]=2
	cnvta=pr.PendBaseCost
	x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,tmpPR.)
	cnvta=x3
	x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	pr.PendBaseCost=x3
	cnvta=pr.PrevBaseCost
	x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,tmpPR.)
	cnvta=x3
	x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	pr.PrevBaseCost=x3
	cnvta=pr.PendLastCost
	x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,tmpPR.)
	cnvta=x3
	x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	pr.PendLastCost=x3
	cnvta=pr.PrevLastCost
	x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,tmpPR.)
	cnvta=x3
	x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	pr.PrevLastCost=x3
	cnvta=pr.PendLoadCost
	x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,tmpPR.)
	cnvta=x3
	x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	pr.PendLoadCost=x3
	cnvta=pr.PrevLoadCost
	x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,tmpPR.)
	cnvta=x3
	x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	pr.PrevLoadCost=x3
	cnvta=pr.CostNetPOLast
	x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,tmpPR.)
	cnvta=x3
	x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	pr.CostNetPOLast=x3
	cnvta=pr.PendLoad2Cost
	x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,tmpPR.)
	cnvta=x3
	x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	pr.PendLoad2Cost=x3
	cnvta=pr.PrevLoad2Cost
	x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,tmpPR.)
	cnvta=x3
	x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	pr.PrevLoad2Cost=x3
	!! whse pricing
	!! special / contract fixed prices
	!! rebate fixed
	!! po files
	!! alt vendors
	call prodcchg(e$,IntCo,ctlc,prod$,ProdRec,tmppr.,pr.)
	! all are done in prodcchg(mx671cc) and whsecchg(mx671ccw)

  else
    include "src/callsuberr.inc"
  end try
end sub ! LBBased
! 
!--------------------------------------------------------------------
sub GetNewLPMrk() 
! "changed price - recalc List Price Markup% (SPROD ONLY!)
! send in LPCG - the list price # they changed (1-6)
Try
	Dim 2%,LPMX1,3%,basecost,lpmx4,lpmx3
	If pr.MUpTbl<>0 Return ! "not using - using actual Table
	Let BaseCost=pr.costbase ! "base cost
	If Not(BASECost) Return ! "can't do anything - no base
	Let lpmX1=LPCG-1 ! "so is 0-5 instead of 1-6?
	if lpmX1=0 let lpmx4=pr.ListPrice1
	if lpmX1=1 let lpmx4=pr.ListPrice2
	if lpmX1=2 let lpmx4=pr.ListPrice3
	if lpmX1=3 let lpmx4=pr.ListPrice4
	if lpmX1=4 let lpmx4=pr.ListPrice5
	if lpmX1=5 let lpmx4=pr.ListPrice6
	! Let X4=A[20+x1] ! "the 'new' price
	If lpmx4>0 
		LPMx3=FNT((lpmx4-BASECost)*100/BASECost) ! "price-base*100/base
	  !LET LPMRK[X1]=FNT((X4-BASE)*100/BASE) ! "price-base*100/base
	Else
	  !Let LPMrk[x1]=0
	  LPMX3=0
	Endif
	!IF LPMRK[X1]<0 LET LPMRK[X1]=0
	if lpmx3<0 let lpmx3=0
	if lpmX1=0 let pr.Lp1Markup=lpmx3
	if lpmX1=1 let pr.Lp2Markup=lpmx3
	if lpmX1=2 let pr.Lp3Markup=lpmx3
	if lpmX1=3 let pr.Lp4Markup=lpmx3
	if lpmX1=4 let pr.Lp5Markup=lpmx3
	if lpmX1=5 let pr.Lp6Markup=lpmx3
else
    include "src/callsuberr.inc"
  end try
end sub ! GetNewLPMrk
! 
!--------------------------------------------------------------------
Sub plcprcupdt()
! update load costs & prices on prod
  Try
	DIM 1%,PFU1[20],m5[5,4],2%,C4[8],3%,PFU2[6],A[33]
	Dim 2%,lpmrk[5]
	Dim 3%,PREC[2],BASECOST
	let PRec[0]=Prodrec
	IF PR.Load1MupTbl
		LET WHSE=0;LTBL=PR.Load1MupTbl;CNVTA=0
		LET OTYPE=1
		if not(recalcnew)
			CALL MXLOAD5L(e$,OTYPE,WHSE,LTBL,PREC[],CNVTA,IntCo,rstr$)
		else ! pass vars
			call Mxload5pv(e$,OTYPE,WHSE,LTBL,PREC[],CNVTA,Intco,rstr$,pr., prw.)
		Endif
		LET pr.CostLoad=CNVTA
	ENDIF
	IF pr.Load2MupTbl
		LET WHSE=0;LTBL=pr.Load2MupTbl;CNVTA=0
		LET OTYPE=1
		if not(recalcnew) ! normal
			CALL MXLOAD5L(e$,OTYPE,WHSE,LTBL,PREC[],CNVTA,IntCo,rstr$)
		else ! pass vars
			call Mxload5pv(e$,OTYPE,WHSE,LTBL,PREC[],CNVTA,Intco,rstr$,pr., prw.)
		Endif
		LET pr.CostLoad2=CNVTA
	ENDIF
	if custom_customer$<>"PRBRICK" ! prgbrk uses muptbl zero
		IF pr.MUpTbl<=0 OR pr.MUpTbl>999 exit sub
	endif
	if pr.PriceType<>1 exit sub ! only matrix pricing uses pricemark
	BASECOST=pr.CostBase
	MAT READ #PRC,Prodrec,256;A;
	mat read #PRC,Prodrec,512;Pfu1;
	mat read #PRC,Prodrec,554;Pfu2;
	mat read #PRC,Prodrec,894;C4;
	! set up and use array instead of individual
	lpmrk[0]=pr.Lp1Markup;lpmrk[1]=pr.Lp2Markup;lpmrk[2]=pr.Lp3Markup
	lpmrk[3]=pr.Lp4Markup;lpmrk[4]=pr.Lp5Markup;lpmrk[5]=pr.Lp6Markup
	if recalcnew ! recalc based on new costs/tables
		if custom_customer$<>"PRBRICK" let C4[3]=pr.MUpTbl ! donot chg prgbrk
		A[5]=pr.LbsFact
		A[6]=pr.LbsUnit
	Endif
	if c4[3]>0 ! may be zerp
		Mat Read #prmc,c4[3],18;M5; ! "pricemark cost base
	else
		clear m5[] ! not used - only use base cost
	endif
	LET BASECOST=pr.CostBase ! "BASE COST

	FOR FIELD=1 TO 6 ! "now 1 to 6 for LP 1-6
		Let BASECOST=pr.CostBase ! "base default
		If M5[field-1,4]=1 Let BASECOST=pr.CostPO ! "Last
		If M5[Field-1,4]=2 Let BASECOST=PR.CostLoad ! "Load
		If M5[Field-1,4]=3 Let BASECOST=pr.CostLoad2 ! "load2
		If M5[field-1,4]=4 Let BASECOST=pr.CostAvg ! "average
		If M5[field-1,4]=5 Let BASECOST=PR.CostNetPO ! "Net PO
		X4=0 ! x4 is price
		If C4[3]=0 ! "using Per Prod/List Markup %
		  CALL "MX671MRK5.dl4",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG,C4[],FIELD,BASECOST,LPMRK[],e$,rstr$
		  ! IF FLAG LET E=FLAG \ GOSUB Err_Search:
		Else
			CALL "MX671BRK5.dl4",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG,C4[],FIELD,BASECOST,e$,rstr$
		endif
		IF NOT(FLAG) LET X4=CNVTA   
		IF P61$[50,50]="Y"
			CALL PriceFac()
		Endif
		If X4>=0 LET A[19+FIELD]=X4 
	Next Field
	! convert A[] back to sql
	pr.ListPrice1=A[20]
	pr.ListPrice2=A[21]
	pr.ListPrice3=A[22]
	pr.ListPrice4=A[23]
	pr.ListPrice5=A[24]
	pr.ListPrice6=A[25]
  else
    include "src/callsuberr.inc"
  end try
end sub ! plcprcupdt
! 
!--------------------------------------------------------------------
Sub PRICEFAC()
! REM round prices based upon pricing factor        
  Try
	dim 1%,PRFac
	Dim 3%
	Dim keycomm$[10]
	IF P61$[50,50]<>"Y" Exit Sub
	LET KEYCOMM$=pr.ComdtyCode$+Blank$
	SEARCH #CMC,2,1;KEYCOMM$,REC_CMDTY,E                          
	IF NOT(E)                                                   
	  MAT  READ #CMC,REC_CMDTY,40;PRFAC;                          
	  IF PRFAC                                                  
		LET CNVTA=X4;CNVTU[0]=0;CNVTU[1]=pr.UMPriceDefault;CNVTU[2]=2    
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		CALL "pricernd",PRFAC,AMOUNT                            
		LET CNVTA=AMOUNT;CNVTU[0]=pr.UMPriceDefault;CNVTU[1]=0;CNVTU[2]=2
		Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		LET X4=AMOUNT                                           
	  ENDIF                                                     
	ENDIF                                                       
 else
    include "src/callsuberr.inc"
  end try
end sub ! PRICEFAC
! 
!--------------------------------------------------------------------
Sub ChkCWFlag(flag)
! see if okay to change catchweight flag
 Try
	Dim FLK$[60]
	Dim 1%,CH_FL
	Dim 3%,REC_FL
	Flag=1 ! ok
	IF P61$[73,73]="Y" ! check lbs in fifo/lifo
	  IF P60$[9,9]="F" OR P60$[9,9]="L"
		! if ANY INV Exists for Product - NO CHANGE ALLOWED!!
		LET CH_FL=Openfile(-3008,IntCo) \ if ch_fl=-1 Goto NxtCWChk
		LET FLK$=" ",FLK$;FLK$[1,12]=Prod$
		SEARCH #CH_FL,3,1;FLK$,REC_FL,E
		CLOSE #CH_FL
		IF NOT(E)
		  IF FLK$[1,12]=Prod$
			Message$="Cannot Change Catch Weight.  Inventory Has Been Established"
			Flag=0
			GOTO ChCWDone
		  ENDIF
		ENDIF
	  ENDIF
	ENDIF
	NxtCWChk: ! continue
	if tmppr.CatchwgtItem$="Y" ! old = Y; new=N
		! passed first - now see if LB u/m in any default u/m
		If pr.UMCostDefault=-3 or pr.UMPriceDefault=-3
			Flag=0
			Message$="YOU CANNOT CHANGE ANSWER TO N UNTIL Catch wgt LB U/M NOT USED!"
		Endif
	Else ! old=N, new=Y
		! we force Cost/Price Defaults to be -3:LB?
		!If pr.UMCostDefault<>-3 or pr.UMPriceDefault<>-3
		! NATIVE/r9 ALLOW ANY UM for price/cost!
			!Flag=0
			!Message$="Cost and Price U/M MUST BE Catch wgt LB for to answer Y"
		!Endif
	Endif
	ChCWDone: ! finished
 else
    include "src/callsuberr.inc"
  end try
end sub ! ChkCWFlag
! 
!--------------------------------------------------------------------
Sub ProdSpec()
! prodspec notes (Support Notes)
 Try
	Dim M1$[30]
	PSN=OpenFile(1696,IntCo) \ if PSN=-1 goto PSDone
	If Action2$<>"SAVE" ! it's display
		Clear List$[]
		List$[0]=bsdel$,"PRODSUPNOTES",fdel$
		List$[1]="ID",fdel$,"LINE",fdel$,"NOTE",fdel$
		Row=2;X1=1
		call dxget("NEXTLINE",tmp$)
		NSLine=tmp$ ! sent chunk - start for next
		tmpcnt=maxcnt
		x1=0 \ if NSLine let x1=NSLine-1
		ProdKey$=Prod$
		if nsline let prodkey$=Prod$+" "+NSLine-1 using "###" ! as mode=3 (1 less)
		Do 
			Search #PSN,3,1;ProdKey$,R,E
			if prodkey$[1,12]<>prod$ let e=22
			If E exit do
			Mat read #PSN,r,12;M1$;
			tmp$=RTrim$(M1$)
			if tmp$<>""
				IF ROW>102 ! 33263 - max 100 per time
					let e$="RS=5  NEXTLINE="+ProdKey$[14,16]
					exit do
				endif
				x1=x1+1 ! print line
				x=prodkey$[14,16] ! curr line
				if (x-x1>99) or (x-x1<0) let x=0 ! ignore it (no 99 or negative null lines!!)
				if x and x<>x1 ! something missed (exclude 0)
				  for L0=x1 to x-1 ! stop 1 line before current
					Webstr$=Prod$,fdel$,Str$(L0),fdel$,fdel$
					List$[row]=webstr$
					row=row+1
					if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
				  Next L0
				Endif
				Webstr$=Prod$,fdel$,Prodkey$[14,16],fdel$,tmp$,fdel$
				List$[row]=webstr$
				row=row+1
				if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
				x1=prodkey$[14,16] ! last line printed
			Endif
		Loop
		List$[row]=esdel$
		call AddToStr(e$,rstr$,List$[])
	Else ! we're saving
		call dxget("STRTLINE",tmp$) !! 33263 - grps of 100
		PSSLine=tmp$ ! should be 0,100,200,300,400,etc
		If PSSLine<>0 goto PSDone ! LIMIT IS 1-99 ONLY
		if FRA(PSSLine/100) ! not allowed!!
			returnstatus=0
			message$="STRTLINE IS NOT A MULTIPLE OF 100!"
			goto PSDone
		Endif
		If PSSLine<0 or PSSLine>900
			returnstatus=0
			Message$="STRTLINE IS INVALID"
			goto PSDone
		Endif
		slp=1 ! PSSLine+1 ! 1,101,201,etc
		elp=99 ! PSSLine+100 ! 100,200,300,etc
		for i=slp to elp !  was   i=1 to 25
		  ProdKey$=Prod$+" "+i using "###"
		  PSRec=0
		  Search #PSN,2,1;Prodkey$,PSRec,E
		  if e let psrec=e*-1
		  if PSRec<0
			 M1$=Blank$
		  end if
		  call dxget("note"+str$(i),tmp$)
		  M1$=tmp$+blank$ ! Note
		  strgok=chkbadchars(e$,M1$)
		   if not(strgok)
			returnstatus=0
			Message$="Invalid Characters in Note "+Str$(i)
			goto PSDone
		   Endif
		  If PSRec<0 let mode$="a" else let mode$="c"
		  if rtrim$(tmp$)="" let mode$="d"
		  if mode$="a"
			let e=2;PSRec=0
			Search #PSN,1,0;ProdKey$,R,E
			if not(e)
				Search #PSN,4,1;ProdKey$,R,E
				mat write #PSN,R,12;M1$;
			Endif
		   Endif
		   if mode$="c"
			Mat write #PSN,PSRec,12;M1$;
		   Endif
		   If mode$="d" and PSRec>0
			Search #PSN,5,1;ProdKey$,R,E
			If Not(E)
				Let E=3;R=PSRec
				Search #PSN,1,0;ProdKey$,R,E
			Endif
		   Endif
		 next i
	Endif
 PSDone: ! finished
 else
    include "src/callsuberr.inc"
  end try
end sub ! ProdSpec
! 
!--------------------------------------------------------------------
Sub cpyprod()
! copy from a diff prod into prod
 Try
	dim cpprod$[12]
	! 1st check if prod is on file
	! Call dxsave(0,"tmp/prodin.txt!") ! save web data sent
	if prod$=Blank$[1,12]
		returnstatus=0
		Message$="Blank Product Code not allowed!"
		goto CPProdDone
	Endif
	PRR=filegetprod(e$,PRC,"=",1,prod$,pr.)
	if Prr>0
		returnstatus=0
		message$="Product "+RTrim$(Prod$)+" already on file!"
		goto CPProdDone
	Endif
	call dxget("frmprodid",tmp$)
	if Trim$(tmp$)=""
		returnstatus=0
		Message$="NO Copy From PRODUCT CODE SENT!"
		goto CPProdDone
	Endif
	tmp1$=chkaltitem$(e$,intco,tmp$)
	tmp1$=RTrim$(tmp1$)
	If tmp1$<>"" ! found an altitem
	  CPProd$=UCase$(tmp1$)+Blank$ ! use this instead of add'l calls
	Else ! not found
	  CPProd$=UCase$(tmp$)+Blank$ ! use what we got
	Endif
	if cpprod$=prod$
		returnstatus=0
		Message$="Cannot copy itself!"
		goto CPProdDone
	Endif
	CPRec=filegetprod(e$,PRC,"=",1,cpprod$,tmppr.)
	if CPRec<=0
		returnstatus=0
		Message$="Product "+RTrim$(cpprod$)+" not found"
		goto CPProdDone
	Endif
	! ok - so pr. is new, tmppr. is copy from
	! now clear sales,etc
	READ RECORD #PRC,CPRec,0;pr.; ! read new from copy
	pr.QtyOnHand=0;pr.QtyonPWO=0;pr.QtyOnPO=0
	pr.QtyOnOrd=0;pr.MtdSales=0;pr.YtdSales=0
	pr.MtdUnitSales=0;pr.YtdUnitSales=0;pr.MtdCostOfSales=0
	pr.YtdCostOfSales=0;pr.MtdUnitsUsedWO=0;pr.YtdUnitsUsedWO=0
	pr.MtdUsageCostWO=0;pr.YtdUsageCostWO=0;pr.YtdUnitsProdRecd=0
	pr.LastYearSales=0;pr.LastYearUsage=0;pr.sRecord=0
	pr.DemandLyUnits=0;pr.LastPoQty=0;pr.EconOrdQty=0
	pr.YtdReturn=0;pr.YtdReturnUnits=0;pr.YtdReturnCost=0
	pr.LastYearReturns=0;pr.LastPhysQty=0;pr.BOMMatCost=0
	pr.BOMMLCost=0;pr.BomFixedCosts=0;pr.BomLabrTime=0
	pr.BomMachTime=0;pr.BomFixedTime=0;pr.LongLeadTime=0
	pr.DateLastSold=0;pr.DateLastUsed=0;pr.BomTtlCost=0
	pr.BomTtlTime=0;pr.PendBrkTbl=0;pr.PendMupTbl=0
	pr.PrevBrkTbl=0;pr.PrevMupTbl=0;pr.PendLastCost=0
	pr.PendLastCostDate=0;pr.PrevLastCost=0;pr.DateLastCostChg=0
	pr.PendBaseCost=0;pr.PendBaseDate=0;pr.PrevBaseCost=0
	pr.DateBaseChg=0;pr.Lvl1Qty=0;pr.Lvl2Qty=0
	pr.FutListBaseDate=0;PR.FutListPoDate=0;pr.SupersedeCode$=blank$
	pr.LastCustNum=0;pr.LastPhysDate=0;pr.LbsOnHand=0
	pr.LbsOnOrder=0;pr.PendLoadCost=0;pr.PrevLoadCost=0
	pr.OutOfStockYtd=0;pr.FutureList=0;pr.UserDefCatgyId=0
	pr.DateRecEstab=currdate;produrl$=blank$
	pr.ProdCode$=prod$;pr.InventClass1=0;pr.InventClass2=0
	pr.CntWeek=0;pr.PendLoad2Cost=0;pr.PrevLoad2Cost=0
	if custom_customer$="ZEPHYR"
		! rest is for cct92627 to zero out cost/price on copy-custom for zephyr
		!LET B[8]=0;B[10]=0;B[21]=0;B[14]=0;LM=0;C4[4]=0;PF_LOAD2=0
		!FOR I=20 TO 25 \ LET A[I]=0 \ NEXT I
		!FOR I=0 TO 2 \ LET PRPARC[I]=0 \ NEXT I
		pr.CostLoad=0;pr.CostPO=0;pr.CostAvg=0;pr.BomTtlCost=0;pr.CostLoad2=0
		pr.Load1MupTbl=0;pr.Load2MupTbl=0;pr.CostBase=0;pr.CostNetPO=0
		pr.ListPrice1=0;pr.ListPrice2=0;pr.ListPrice3=0;pr.ListPrice4=0
		pr.ListPrice5=0;pr.ListPrice6=0;pr.CostNetPOLast=0;pr.AvgFifoCost=0
	Endif
	! add product NOW!
	mode$="a"
	pr.BlankForKey$=blank$;pr.Spare1$=blank$
	aa=fileupdateprod(e$,PRC,mode$,Prodrec,PR.,0,0,-1) ! w/audit (not working?!)
	if aa<0 ! bad stat
		Returnstatus=0
		Message$=E$
		goto CPProdDone
	Else
		if mode$="a" let Prodrec=aa
		LET pr.sRecord=Prodrec
		if prdref ! multi dir index of long prodid
			hldlprod$=pr.NProdId$+Blank$ ! set it - new
			pr.NProdId$=Blank$ ! clear old so updates
			call updtprdref()
			let pr.NProdId$=HldLprod$+Blank$ ! update file with new entry
		Endif
		pr.BlankForKey$=blank$ ! always!!
		pr.Spare1$=blank$ ! same
		write record #PRC,Prodrec,0;pr.; ! won't know record until added!
		if sqlChan>=0
			call prod_DL4SQLConvert(e$,"FROMDL4",pr.,sql_prod.,Prodrec)
			e = prod_SQLAddUpdate(e$,sqlChan,sql_prod.)
			if e<>1 error 11000
		end if
		If mode$="a" ! add mode
			clear prdsls.
			prdsls.ProdCode$=pr.ProdCode$ ! SET UP/WRITE PRODSLS!!
			write record #PSC,Prodrec,0;prdsls.;
		Endif
		! update turbo
		call apturbo(e$,CTLC,IntCo,Prodrec,pr.) ! add new turbo
		ProdKey$=UCase$(pr.Desc1$)+blank$;Prodkey$[31]=Prod$
		Search #PDC,4,1;ProdKey$,Prodrec,E ! add/update pdesckey
		! additional files to possibly update
		if prdurl
			kprod$=" ",kprod$
			kprod$=PR.ProdCode$
			Search #ch_purl,2,1;kprod$,R[98],E
			if e ! add new
				let E=2;r[98]=0
				search #ch_purl,1,0;kprod$,r[98],e \ if e error 11000
				search #ch_purl,4,1;kprod$,r[98],e \ if e error 11000
			Endif
			MAT WRITE #ch_purl,r[98],0;PR.ProdCode$;                                          
			MAT WRITE #ch_purl,r[98],13;produrl$;
		Endif
	Endif
	! now keywords copy
	KWR=filegetprdkeywrd(e$,KWC,"=",1,cpprod$,kw.)
	if KWR>0 ! has keywords/complementary on from prod
		kw.ProductCode$=prod$+Blank$ ! mv new prod
		x3=fileupdateprdkeywrd(e$,KWC,"a",X2,kw.)
		if x3>0 ! ok - update keywords
			call aprdkwrd(e$,IntCo,Prodrec,kw,pr.)
		Endif
	Endif
	! UDA - open as #UDA
	UDAR=filegetproduda(e$,UDA,"=",1,cpprod$,uda.)
	if UDAR>0 ! has uda for from prod
		uda.ProductCode$=prod$ ! mv in new prod
		X3=fileupdateproduda(e$,UDA,"a",X2,uda.)
	Endif
	! grade/pricebook
	!PBC = OpenFile(9978,intCo) \ if PBC = -1 error 42 ! product price book
	!PBR=filegetprodprbk(e$,PBC,"=",1,cpprod$,pb.)
	PBC=OpenFile(9923,IntCo) \ if PBC=-1 Goto CPProdDone ! synergy Price Book
	PBR=filegetsyngprbk(e$,PBC,"=",1,cpprod$,PB.)
	If PBR>0 ! has prbk for from prod
		PB.ProdCode$=prod$ ! mv in new prod
		!X3=fileupdateprodprbk(e$,PBC,"a",x2,pb.)
		x3=fileupdatesyngprbk(e$,PBC,"a",X2,PB.)
	Endif
  CPProdDone: ! finished
  ! Call programdump("tmp/plog1!","")
 else
    include "src/callsuberr.inc"
  end try
end sub ! cpyprod
! 
!--------------------------------------------------------------------
Sub DelProd()
! delete sent product code
 Try
	! 1st check if prod is on file
	if prod$=Blank$[1,12]
		returnstatus=0
		Message$="Blank Product Code not allowed!"
		goto DLProdDone
	Endif
	PRR=filegetprod(e$,PRC,"=",1,prod$,pr.)
	if Prr<=0
		returnstatus=0
		message$="Product "+RTrim$(Prod$)+" not on file!"
		goto DLProdDone
	Endif
	Call dxget("DELNVTL",tmp$) ! does non vital prevent deletion Y/N
	tmp$=UCase$(RTrim$(tmp$))
	if tmp$="N" let X3=0-PRR Else Let X3=PRR
	
	! ok - so it's there now what?
	X2=-11 ! product maint flag
	Let X1[0]=IntCo;x1[1]=ctlc;x1[2]=PRC;x1[3]=PSC;e$=""
	call "proddel.dl4",x2,PROD$,X3,tmp1$,x1[],e$,rstr$
	if x2=0 ! ok 
		returnstatus=1
		Message$="OK - Product "+RTrim$(Prod$)+" DELETED"
	Else
		Returnstatus=0
		Message$=tmp1$
		if RTrim$(message$)="" let message$=E$
		if x2=9 let message$="NO PRODUCT RECORD PASSED"
		if message$="" let Message$="PRODDEL ERROR "+Str$(X2)
	Endif
  DLProdDone: ! finished
 else
    include "src/callsuberr.inc"
  end try
end sub ! DelProd
! 
!--------------------------------------------------------------------
Sub listudcatgy()
! a list of user defined catgy's (in order parent down)
 Try
	Dim K1$[100,60],k2$[60],k3$[60],udcat$[100]
	Dim 3%,udcat[10],x3[100]
	Clear List$[]
	tmpcnt=maxcnt
	List$[0]=bsdel$,"USRDEFCTGY",fdel$
	List$[1]="UDCTGYREC",fdel$,"DESC",fdel$,"PARENTID",FDEL$
	List$[2]="0",fdel$,"NONE",fdel$,"0",fdel$
	row=3
	If UDC<=0 goto LUDCDone ! s/b open in openfiles
	! maybe similar to multi-level bom's somehow?
	! 1st thru base (0 parent) keys
	clear k1$[]
	k2$=Blank$
	do
		search #UDC,3,1;k2$,R[0],E
		if e exit do
		x3=k2$[1,8] \ if x3<>0 exit do ! no more parents
		mat read #udc,r[0],0;UDCAT$;
		MAT READ #UDC,R[0],100;UDCAT;
		clear k1$[] ! clear at parent
		k1$[0]=k2$
		! add to list - NO Parent not a selection
		list$[row]=Str$(R[0]),fdel$,RTrim$(UDCat$[1,30]),fdel$,Str$(UDCat[1]),fdel$
		row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
		x3[1]=r[0];lvl=1 ! cat looking for
		k1$[lvl]=x3[lvl] using "########"
		lvlloop: ! loop thru this child level
		k3$=" ",k3$
		k3$=K1$[lvl]
		do 
			search #udc,3,1;k3$,R[lvl],e
			if e exit do
			x3=k3$[1,8] \ if x3<>X3[lvl] exit do ! not same rec
			mat read #udc,r[lvl],0;UDCAT$;
			MAT READ #UDC,R[lvl],100;UDCAT;
			k1$[lvl]=k3$ ! save last key for this level
			! add to list - ALL
			Webstr$=Str$(R[lvl]),fdel$
			tmp$=""
			for x=1 to lvl \ let tmp$=tmp$," " \ next x
			webstr$=webstr$,tmp$,RTrim$(UDCat$[1,30]),fdel$,Str$(UDcat[1]),fdel$
			list$[row]=Webstr$
			row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
			lvl=lvl+1;x3[lvl]=R[lvl-1] ! record to check
			k1$[lvl]=x3[lvl] using "########" ! start new level
			goto lvlloop
		loop
		lvl=lvl-1 ! done with level - back 1 level
		!R=X3[lvl] ! get last one found
		! add to list - ONLY LAST ONES SELECTABLE
		!If R>0
		!	mat read #udc,r[0],0;UDCAT$;
		!	MAT READ #UDC,R[0],100;UDCAT;
		!	Webstr$=Str$(R[0]),fdel$
		!	X2=R[0];tmp$=""
		!	dudcloop: ! loop it up thru all levels
		 ! Try
		!	mat read #UDC,x2,0;UDCat$;
		!	MAT READ #UDC,x2,100;udcat;
		 ! Else
		!	UDCat$=Blank$;udcat[1]=0
		 ! End try
		! tmp$=tmp$,RTrim$(UDCat$[1,30])
		!  if udcat[1]>0 ! go up a level
		!	tmp$=tmp$," -> "
		!	x2=udcat[1] ! next parent level back 
		!	goto dudcloop
		 ! Endif
		!  webstr$=webstr$,RTrim$(tmp$),fdel$
		!	list$[row]=Webstr$
		!	row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
		! Endif
		if lvl>0 goto lvlloop ! back to previous level - if zero - done!
	loop ! of parent

	LUDCDone: ! "finito
	List$[row]=esdel$
	call addToStr(e$,rstr$,list$[])
	
	Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	Call AddToStr(e$,rstr$,WebStr$)
    call SetOutPut(e$,rstr$)
 else
    include "src/callsuberr.inc"
  end try
end sub ! listudcatgy
! 
!--------------------------------------------------------------------
Sub updtusrprd(octgy,nctgy,prod$)
! update the usrcatprd file with new userdefined catgy
 Try
	DIM 3%,CATID
	UCPC=findchannel()
	tmp$="2/usrcatprd"+STR$(IntCo)
	Try
		Open #UCPC,tmp$
	Else
		Exit sub
	End try
	if octgy=0 goto nucp ! no old one - add new?
	! remove old
	searkey$=" ",searkey$
	Searkey$=octgy using "########"
	Searkey$[9]=prod$
	search #UCPC,5,1;searkey$,R,E
	if not(e)
		let e=3
		Search #UCPC,1,0;searkey$,R,E
	Endif
	NUCP: ! add new key/data
	if nctgy=0 goto UUCPDone ! no new one
	catid=nctgy
	searkey$=" ",searkey$
	searkey$=catid using "########"
	Searkey$[9]=prod$
	Search #UCPC,2,1;searkey$,R,E
	if e=1 ! else ignore it (already there or tree error)
	  Let E=2;R=0
	  Search #UCPC,1,0;searkey$,R,E
	  if not(E)
		write #UCPC,r,0;catid;
		write #UCPC,R,6;prod$;
		Search #UCPC,4,1;searkey$,R,E
	  Endif
	Endif
  UUCPDone: ! finito
  if UCPC>0 Close #UCPC
 else
    include "src/callsuberr.inc"
  end try
end sub ! updtusrprd
! 
!--------------------------------------------------------------------
Sub WebInfo()
! 
 Try
	dim VNK$[6],mfrname$[30],UDCAT$[100]
	Dim 3%,UDCat[10],octgy,nctgy
	call OpenFiles()
    
	ProdKey$=prod$
	Prodrec = filegetprod(e$,PRC,"=",1,ProdKey$,PR.)
	if action2$="SAVE" and Prodrec<=0
		returnstatus=0
		Message$="PRODUCT NOT ON FILE!"
		goto WIDone
	Endif
  If Action2$<>"SAVE" ! it's display
	! Web Info Section ???(we'll use for .net fields)
	List$[row]=bsdel$,"Web Info",fdel$ \ row=row+1 ! beg section
	Webstr$="MANFTR",fdel$,"NAME",fdel$,"UDCTGYREC",fdel$,"UDCTGYDESC",FDEL$
	List$[row]=webstr$ \ row=row+1 ! fld names field
	if Prodrec>0
		if pr.spare>0
			VNK$ = PR.SPARE using M6$ ! CHANGE TO MFR if file layout changed
			VMRec=filegeta80vm(e$,VNC,"=",1,VNK$,VM.)
		else
			vmrec=-1
		endif
		if VMRec<0 let	mFRName$=BLANK$ else MFRName$=VM.Name$
		webstr$=Str$(pr.spare),fdel$,RTrim$(mfrname$),fdel$
		if udc>0
		  webstr$=webstr$,Str$(pr.UserDefCatgyId),fdel$
		  x2=pr.UserDefCatgyId;tmp$=""
		  udcloop: ! loop it up thru all levels
		  ! Try
		  If x2
			mat read #UDC,x2,0;UDCat$;
			MAT READ #UDC,x2,100;udcat;
		  Else
			UDCat$="Not Assigned",Blank$;udcat[1]=0
		  End If
		  !End try
		  tmp$=tmp$,RTrim$(UDCat$[1,30])
		  if udcat[1]>0 ! go up a level
			tmp$=tmp$," -> "
			x2=udcat[1] ! next parent level back 
			goto udcloop
		  Endif
		  webstr$=webstr$,RTrim$(tmp$),fdel$
		Else ! no udc
		  webstr$=webstr$,fdel$,fdel$ ! none
		Endif
		List$[row]=webstr$ \ row=row+1 ! fld names field
	Endif
	List$[row]=esdel$ \ row=row+1 ! end section
	call AddToStr(e$,rstr$,List$[]) ! add list to string
   Else ! it is a save
	read record #PRC,Prodrec,0;tmppr.;
	call dxget("MANFTR",tmp$) ! .net manufacturer
	pr.spare=tmp$ ! as no name assigned (and used in 55+ programs!)
	call dxget("UDCTGYREC",tmp$)
	pr.UserDefCatgyId=tmp$
	pr.BlankForKey$=blank$ ! always!!
	pr.Spare1$=blank$ ! same
	write record #PRC,Prodrec,0;pr.;
	if sqlChan>=0
		call prod_DL4SQLConvert(e$,"FROMDL4",pr.,sql_prod.,Prodrec)
		e = prod_SQLAddUpdate(e$,sqlChan,sql_prod.)
		if e<>1 error 11000
	end if
	if tmppr.UserDefCatgyId<>pr.UserDefCatgyId ! changed - change usrprdcat
		octgy=tmppr.UserDefCatgyId
		nctgy=pr.UserDefCatgyId
		call updtusrprd(octgy,nctgy,prod$)
	Endif
   Endif
   WIDone: ! finished
  else
    include "src/callsuberr.inc"
  end try
end sub ! WebInfo
! 
!--------------------------------------------------------------------
Sub UWVEND()
! update the whse vendor fields with new one(s)
 Try
	dim 3%,AA
	SearKey$=PR.ProdCode$
	pwchg=0 ! did anything change?
	Do
	  pwchg=0
      WHRec=filegetprodwhse(e$,WHC,">",1,SearKey$,PRW.)
      if WHRec<0 exit do
	  If SearKey$[1,12]<>PR.ProdCode$ exit do
	  if prw.Spare$[1,2]<>"  " ! always make sure it's blank
		let prw.Spare$=blank$
		write record #whc,whrec,0;prw.;
	  endif
	  if vitemflag=0 or vitemflag=2 ! only vend or both
		If prw.Vend=0 or prw.Vend=tmppr.PrimVend ! whse=0 or equal old
			prw.Vend=pr.PrimVend ! set to new
			pwchg=1
		Endif
	  Endif
	  if vitemflag=1 or vitemflag=2 ! only vitem or both
	    if prw.vend=pr.primvend
			tmp$=rtrim$(prw.VendPN$)
			if tmp$="" or prw.VendPN$=tmppr.VendItem$ ! whse=blank or equal old
				prw.VendPN$=pr.VendItem$+Blank$ ! set to new
				pwchg=1
			Endif
		Endif ! only change if for same vend as prodfile
	  Endif
	  if pwchg ! did a change - update whse rec
		aa=0
		aa=fileupdateprodwhse(e$,WHC,"c",whrec,prw.) ! change it - adj's keys
		if aa<0 ! a problem
			Returnstatus=0
			Message$=E$
		else
			if sqlChan>=0
				call prodwhse_DL4SQLConvert(e$,"FROMDL4",prw.,sql_prodwhse.)
				e = prodwhse_SQLUpdate(e$,sqlChan,sql_prodwhse.)
			end if
		Endif
	  Endif ! changed - update it
	Loop
 else
    include "src/callsuberr.inc"
  end try
end sub ! UWVEND
! 
!--------------------------------------------------------------------
Sub srlninfo()
! 
 Try
	Dim 3%
	call OpenFiles()
    Clear List$[]
	tmpcnt=maxcnt
	ProdKey$=prod$
	Prodrec = filegetprod(e$,PRC,"=",1,ProdKey$,PR.)
	if action2$="SAVE" and Prodrec<=0
		returnstatus=0
		Message$="PRODUCT NOT ON FILE!"
		goto SNDone
	Endif
	if p60$[25,25]<>"Y" ! or pr.SerNoTrack$<>"Y"
		returnstatus=0
		message$="Serial Numbers not available!"
		goto SNDone
	Endif
	! WHAT IF CHANGING FLAG & DID NOT SAVE NEW FLAG YET?
	!if action2$="SAVE" and pr.SerNoTrack$<>"Y"
	!	returnstatus=0
	!	Message$="PRODUCT NOT Tracking Serial Numbers!"
	!	goto SNDone
	!Endif
	If Action2$<>"SAVE" ! it's display
		if Prodrec<=0 clear pr.
		! if pr.SerNoTrack$<>"Y" clear pr. ! no data to send!
		List$[0]=bsdel$,"SNINFO",fdel$
		List$[1]="ID",fdel$,"MODEL",fdel$,"MFRWARRANTY",fdel$,"OURWARRANTY",fdel$
		row=2
		webstr$=RTrim$(prod$),fdel$
		webstr$=webstr$,RTrim$(pr.SnModelNum$),fdel$
		webstr$=webstr$,Str$(pr.SnMfgWrntyDays),fdel$,Str$(pr.SnOurWrntyDays),fdel$
		List$[row]=webstr$
		row=row+1
		List$[row]=esdel$
		call AddToStr(e$,rstr$,List$[]) ! add list to string
	Else ! it's save										doc=Prodm-SubmitSNInfo.doc
		call dxget("MODEL",TMP$)
		pr.SnModelNum$=tmp$+Blank$
		call dxget("MFRWARRANTY",tmp$)
		pr.SnMfgWrntyDays=tmp$
		call dxget("OURWARRANTY",tmp$)
		pr.SnOurWrntyDays=tmp$
		! that's all folks - write it back
		pr.BlankForKey$=blank$ ! always!!
		pr.Spare1$=blank$ ! same
		write record #PRC,Prodrec,0;pr.;
		if sqlChan>=0
			call prod_DL4SQLConvert(e$,"FROMDL4",pr.,sql_prod.,Prodrec)
			e = prod_SQLAddUpdate(e$,sqlChan,sql_prod.)
			if e<>1 error 11000
		end if
	Endif
   SNDone: ! finished
  else
    include "src/callsuberr.inc"
  end try
end sub ! srlninfo
! 
!--------------------------------------------------------------------
Sub shzlist()
! send droplist of hazard names
 Try
	dim HN. as hazname ! hazard ship to name
	! #HNC already open!
	clear List$[]
	tmpcnt=maxcnt
	List$[0]=bsdel$,"HSNAME",FDEL$
	webstr$="PSNREC",fdel$,"SHIPNAME1",fdel$,"SHIPNAME2",fdel$
	Webstr$=webstr$,"SHIPNAME3",fdel$,"SHIPNAME4",fdel$
	List$[1]=Webstr$
	row=2
	list$[row]="0",fdel$,"NONE",fdel$,fdel$,fdel$,fdel$
	row=row+1
	if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	Searkey$=" ",Searkey$
	Do
		HNRec=filegethazname(e$,HNC,">",1,Searkey$,HN.)
		if HNRec<=0 exit do
		webstr$=Str$(HNRec),fdel$,RTrim$(HN.HazShippingName1$),fdel$
		webstr$=webstr$,RTrim$(HN.HazShippingName2$),fdel$
		webstr$=webstr$,RTrim$(HN.HazShippingName3$),fdel$
		webstr$=webstr$,RTrim$(HN.HazShippingName4$),fdel$
		List$[row]=webstr$
		row=row+1
		if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	Loop
	List$[row]=esdel$
 else
    include "src/callsuberr.inc"
  end try
end sub ! shzlist
! 
!--------------------------------------------------------------------
Sub EdtCosts()
! as a lot of data is required - Only existing prods
! and only cost/price data
 Try
	UMOnly=0 \ if action$="CHGUMS" let umonly=1
	ProdKey$=prod$
	Prodrec = filegetprod(e$,PRC,"=",1,ProdKey$,PR.)
	if Prodrec<=0 ! new product
		returnstatus=0
		Message$="PRODUCT NOT ON FILE!"
		goto ECDone
	Endif
	clear prw. ! no whse data!
	! okay - get pertinent data - Need UM's? Weight? YES
	! need clarification...
	! copied from ProdSave()
	If not(umonly) ! not changed
	  call dxget("CatchweightItem",tmp$)\pr.CatchWgtItm=0\if tmp$="Y" let pr.CatchWgtItm=-3
	  if tmp$<>"Y" Let tmp$="N"
	  pr.CatchwgtItem$=tmp$
	Endif ! leave as is on umonly
	call dxget("BaseUM",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?  ALWAYS               
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R > 0 Let tmp$ = Str$(R)                  
	  !End If   
	  x1=tmp$
	! if chgum - see if base can be changed!!
	if umonly ! change um - so see if possible
		IF Prodrec>0 and x1<>pr.baseum ! changing base? chk if used
			x2=-1 ! check only mode
			!PRS=OpenFile(-2080,intCo)  \ If PRS=-1 Error 42    ! prodsls
			X1[0]=IntCo;x1[1]=ctlc;x1[2]=PRC;x1[3]=PSC;e$=""
			call "proddel.dl4",x2,PROD$,Prodrec,tmp1$,x1[],e$,rstr$
			! Try Close #PRS Else REM
			if x2>0 or e$<>"" ! found something or error
				Returnstatus=0 ! message$ filled
				if e$=""
					message$="CAN NOT CHANGE UM: In Use by "+tmp1$
				else
					message$="ERROR IN CHECKING Base UM Usage: "+e$
				Endif
				goto ECDone
			Endif
		  Endif ! of prod exists & changed it
	Endif ! of um chg only
	pr.BaseUM=tmp$
	if pr.BaseUM<=0
		returnstatus=0
		Message$="Base UM is required!"
		Goto ECDone
	Endif
	if umonly
		if pr.RollLbItem$="Y"
		  if pr.baseum<>LBUM and pr.baseum<>lbsum
			returnstatus=0
			Message$="BASE UM MUST BE LB or LBS for Roll items!"
			goto ECDone
		  Endif
		  FndRlum=0 ! not found yet
		endif ! of rolllb
	Endif
	! rest of u/m's
	call dxget("ValidUnits2",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R > 0 Let tmp$ = Str$(R)                  
	  !End If 
	  pr.UM2=tmp$
	  call dxget("BaseUnits2",tmp$)\pr.UM2Fact=tmp$
	  if pr.UM2Fact<=0 let pr.um2=0
	  if fra(pr.UM2Fact)
		Returnstatus=0
		Message$="NO FRACTIONS FOR CONVERT UNITS"
		goto ECDone
	  Endif
	  if pr.RollLbItem$="Y" and pr.um2=rlum let fndrlum=1
	  call dxget("ValidUnits3",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R > 0 Let tmp$ = Str$(R)                  
	  !End If
	  pr.UM3=tmp$
	  call dxget("BaseUnits3",tmp$)\pr.UM3Fact=tmp$
	  if pr.UM3Fact<=0 let pr.um3=0
	  if fra(pr.UM3Fact)
		Returnstatus=0
		Message$="NO FRACTIONS FOR CONVERT UNITS"
		goto ECDone
	  Endif
	  if pr.RollLbItem$="Y" and pr.um3=rlum let fndrlum=1
	  call dxget("ValidUnits4",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R > 0 Let tmp$ = Str$(R)                  
	  !End If    
	  pr.UM4=tmp$
	  call dxget("BaseUnits4",tmp$)\pr.UM4Fact=tmp$
	  if pr.UM4Fact<=0 let pr.um4=0
	  if fra(pr.UM4Fact)
		Returnstatus=0
		Message$="NO FRACTIONS FOR CONVERT UNITS"
		goto ECDone
	  Endif
  	  if pr.RollLbItem$="Y" and pr.um4=rlum let fndrlum=1
	  call dxget("ValidUnits5",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R > 0 Let tmp$ = Str$(R)                  
	  !End If    
	  pr.UM5=tmp$
	  call dxget("BaseUnits5",tmp$)\pr.UM5Fact=tmp$
	  if pr.UM5Fact<=0 let pr.um5=0
	  if fra(pr.UM5Fact)
		Returnstatus=0
		Message$="NO FRACTIONS FOR CONVERT UNITS"
		goto ECDone
	  Endif
	  if pr.RollLbItem$="Y" and pr.um5=rlum let fndrlum=1
	  call dxget("ValidUnits6",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R > 0 Let tmp$ = Str$(R)                  
	  !End If    
	  pr.UM6=tmp$
	  call dxget("BaseUnits6",tmp$)\pr.UM6Fact=tmp$
	  if pr.UM6Fact<=0 let pr.um6=0
	  if fra(pr.UM6Fact)
		Returnstatus=0
		Message$="NO FRACTIONS FOR CONVERT UNITS"
		goto ECDone
	  Endif
	  if pr.RollLbItem$="Y" and pr.um6=rlum let fndrlum=1
	  call dxget("ValidUnits7",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R > 0 Let tmp$ = Str$(R)                  
	  !End If    
	  pr.UM7=tmp$
	  call dxget("BaseUnits7",tmp$)\pr.UM7Fact=tmp$
	  if pr.UM7Fact<=0 let pr.um7=0
	  if fra(pr.UM7Fact)
		Returnstatus=0
		Message$="NO FRACTIONS FOR CONVERT UNITS"
		goto ECDone
	  Endif
	  if pr.RollLbItem$="Y" and pr.um7=rlum let fndrlum=1
	  call dxget("ValidUnits8",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R > 0 Let tmp$ = Str$(R)                  
	  !End If    
	  pr.UM8=tmp$
	  call dxget("BaseUnits8",tmp$)\pr.UM8Fact=tmp$
	  if pr.UM8Fact<=0 let pr.um8=0
	  if fra(pr.UM8Fact)
		Returnstatus=0
		Message$="NO FRACTIONS FOR CONVERT UNITS"
		goto ECDone
	  Endif
	  if pr.RollLbItem$="Y" and pr.um8=rlum let fndrlum=1
	  If umonly
		if pr.RollLbItem$="Y" and fndrlum=0
			returnstatus=0
			Message$="UM ROLL not used as a UM on product!"
			Goto ECdone
		  Endif
	  Endif
	  ! check um's
	  For X1=0 to 7
		if x1=0 let umrec=pr.baseum
		if x1=1 let umrec=pr.UM2
		if x1=2 let umrec=pr.UM3
		if x1=3 let umrec=pr.UM4
		if x1=4 let umrec=pr.UM5
		if x1=5 let umrec=pr.UM6
		if x1=6 let umrec=pr.UM7
		if x1=7 let umrec=pr.UM8
		If UMRec>0
			r=checkum(umrec,x1) ! check for dupes / valid etc
		  if r>0 ! not ok
			Returnstatus=0
			If R=1 Message$="U/M "+Str$(X1)+" is Not Valid"
			If R=2 Message$="U/M "+Str$(X1)+" is already Used"
			If R=3 Message$="U/M "+Str$(x1)+" cannot change. In use on Order "+Str$(L2[1])
			goto ECDone
		  Endif
		Endif
	  Next X1
	  call dxget("LbsUnit",tmp$)
	  if tmp$<>"" ! none - keep existing
	  pr.LbsUnit=tmp$
	  Endif
	  if pr.LbsUnit<=0 let pr.LbsUnit=1
	  call dxget("LbsFact",tmp$)
	  if tmp$<>"" ! none - keep existing
	  !If tmp$[1,1] > "9" ! sent um text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R <> 0 Let tmp$ = Str$(R)                  
	  !End If  
	  x2=tmp$
	  r=getumfactor(x2,pr.)
	  pr.LbsFact=r
	  Endif 
	  if pr.LbsFact<=0
		Returnstatus=0
		Message$="NO Lbs Factor sent"
		Goto ECDone
	  Endif
	if not(umonly) ! only fields in define/default um's
	  call dxget("PrimaryVendor",tmp$)\vendnum=tmp$
	  if vendnum<=0 and p61$[126,126]="Y"
		returnstatus=0
		message$="Vendor is required"
		Goto ECDone
	  Endif
	  pr.PrimVend=vendnum !
	Endif ! don't care on umchange - leave it
	call dxget("DefaultPriceUM",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R <> 0 Let tmp$ = Str$(R)                  
	  !End If    
	  pr.UMPriceDefault=tmp$
	  if pr.UMPriceDefault=0
		returnstatus=0
		message$="Price UM is required"
		Goto ECDone
	  Else
		umrec=pr.UMPriceDefault
		R=ChkPrdUM(e$,umrec,IntCo,Pr.)
		if r=0 ! not found
		  returnstatus=0
		  message$="Pricing UM not defined"
		  Goto ECDone
		Endif
	  Endif
	  ! evidently ANY UM can be price UM for catchweights
	  !if pr.CatchwgtItem$="Y" and pr.UMPriceDefault<>-3
		!Returnstatus=0
		!Message$="Price Default MUST BE UM LB on Catch Weight"
		!goto ECDone
	  !Endif
	  call dxget("DefaultCostingUM",tmp$)
	  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R <> 0 Let tmp$ = Str$(R)                  
	  !End If    
	  pr.UMCostDefault=tmp$
	  if pr.UMCostDefault=0
		returnstatus=0
		message$="Cost UM is required"
		Goto ECDone
	  Else
		umrec=pr.UMCostDefault
		R=ChkPrdUM(e$,umrec,IntCo,Pr.)
		if r=0 ! not found
		  returnstatus=0
		  message$="Costing UM not defined"
		  Goto ECDone
		Endif
	  Endif
	  !if pr.CatchwgtItem$="Y" and pr.UMCostDefault<>-3
	  ! evidently Rev9 allows any UM for price/cost UM
		!Returnstatus=0
		!Message$="Cost Default MUST BE UM LB on Catch Weight"
		!goto ECDone
	  !Endif
	if umonly ! only changing UM
		read record #PRC,Prodrec,0;tmppr.; ! see what old was
		call dxget("DefaultStockingUM",tmp$)
		  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R <> 0 Let tmp$ = Str$(R)                  
		  !End If    
		pr.UMStkDefault=tmp$
		if pr.UMStkDefault<=0
			returnstatus=0
			message$="Valid Stocking UM is required"
			Goto ECDone
		Else
			umrec=pr.UMStkDefault
			R=ChkPrdUM(e$,umrec,IntCo,Pr.)
			if r=0 ! not found
			  returnstatus=0
			  message$="Stocking UM not defined"
			  Goto ECDone
			Endif
		Endif
		call dxget("DefaultSellingUM",tmp$)
		  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R <> 0 Let tmp$ = Str$(R)                  
		  !End If    
		pr.UMSellDefault=tmp$
		if pr.UMSellDefault<=0
			returnstatus=0
			message$="Valid Selling UM is required"
			Goto ECDone
		Else
			umrec=pr.UMSellDefault
			R=ChkPrdUM(e$,umrec,IntCo,Pr.)
			if r=0 ! not found
			  returnstatus=0
			  message$="Selling UM not defined"
			  Goto ECDone
			Endif
		Endif
		call dxget("DefaultPurchUnit",tmp$)
		  !If tmp$[1,1] > "9" ! sent text?                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
		If R <> 0 Let tmp$ = Str$(R)                  
		  !End If    
		pr.UMPurchDefault=tmp$
		if pr.UMPurchDefault<=0
			returnstatus=0
			message$="Valid Purchasing UM is required"
			Goto ECDone
		Else
			umrec=pr.UMPurchDefault
			R=ChkPrdUM(e$,umrec,IntCo,Pr.)
			if r=0 ! not found
			  returnstatus=0
			  message$="Purchasing UM not defined"
			  Goto ECDone
			Endif
		Endif
		call dxget("DefaultProductionUnit",tmp$)
		If RTrim$(tmp$)<> "" ! sent text?                 
			R = getumrec(e$,ccc,tmp$,IntCo,PR.)
			If R <> 0 Let tmp$ = Str$(R)
		End If    
		pr.UMPrdtnDefault=tmp$ !if P9$[2,2]="M"
		if P9$[2,2]="M"
		   if pr.UMPrdtnDefault<=0
			returnstatus=0
			message$="Production UM is required"
			Goto ECdone
		Endif
		if pr.UMPrdtnDefault<>0 ! if entered check it - as now POS/PWO
			umrec=pr.UMPrdtnDefault
			R=ChkPrdUM(e$,umrec,IntCo,Pr.)
			if r=0 ! not found
			  returnstatus=0
			  message$="POS/Production UM not defined"
			  Goto ECdone
			Endif
		   Endif
		Endif ! mfg requires
	    ! FINALLY - if catchweight & factor changed
		if tmppr.LbsFact<>pr.LbsFact or tmppr.LbsUnit<>pr.LbsUnit
			x1[0]=pr.UMCostDefault;x1[1]=pr.UMPriceDefault
			if (x1[0]=-1 or X1[0]=-3) or (x1[1]=-1 or x1[1]=-3) ! lb based cost/price
				! need to convert hidden cost/price to new base from old
				Call LBBased() ! already know it's existing rec
			Endif
		Endif
		! 04/26/11 - add all fields in UM's to submit (vendor,packing,upchrg, etc)
		call dxget("VendorOrderUnit",tmp$)
		!if tmp$<>"" ! none - keep existing
		  !If tmp$[1,1] > "9" ! sent text?                 
			R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
			If R <> 0 Let tmp$ = Str$(R)                  
		  !End If    
		  pr.UMVendOrd=tmp$
		!Endif 
		  if pr.UMVendOrd<=0
			returnstatus=0
			message$="Vendor Order UM is required"
			Goto ECDone
		  Else
			umrec=pr.UMVendOrd
			R=ChkPrdUM(e$,umrec,IntCo,Pr.)
			if r=0 ! not found
			  returnstatus=0
			  message$="Vendor Ordering UM not defined"
			  Goto ECDone
			Endif
		  Endif
		call dxget("UpChargeUnit",tmp$)
		!if tmp$<>"" ! none - keep existing
		  !If tmp$[1,1] > "9" ! sent text?                 
			R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
			If R <> 0 Let tmp$ = Str$(R)                  
		  !End If    
		  pr.UMUpChrg=tmp$
		!Endif
		  if pr.UMUpChrg=0
			returnstatus=0
			message$="Up Charge UM is required"
			Goto ECDone
		  Else
			umrec=pr.UMUpChrg
			R=ChkPrdUM(e$,umrec,IntCo,Pr.)
			if r=0 ! not found
			  returnstatus=0
			  message$="Up Charge UM not defined"
			  Goto ECDone
			Endif
		  Endif
		call dxget("CubicFeet",tmp$)
		!if tmp$<>"" ! none - keep existing
		  pr.CubicFeet=tmp$
		  if pr.CubicFeet<=0 let pr.CubicFeet=1
		  call dxget("CubicFtFactor",tmp$)
		  !If tmp$[1,1] > "9" ! sent um text?                 
			R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
			If R <> 0 Let tmp$ = Str$(R)                  
		  !End If
		  x2=tmp$
		  r=getumfactor(x2,pr.)
		  pr.CubicFtFactor=R
		!Endif
		  if pr.CubicFtFactor<=0
			Returnstatus=0
			Message$="NO Cube Factor sent"
			Goto ECDone
		  Endif
		call dxget("BROKENUM",tmp$)
		!if tmp$<>"" ! none - keep existing
		  !If tmp$[1,1] > "9" ! sent text?                 
			R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
			If R <> 0 Let tmp$ = Str$(R)                  
		  !End If    
		  pr.UMBrknQty=tmp$
	    !Endif
		  if pr.UMBrknQty<=0
			returnstatus=0
			message$="Broken UM is required"
			Goto ECDone
		  Else
			umrec=pr.UMBrknQty
			R=ChkPrdUM(e$,umrec,IntCo,Pr.)
			if r=0 ! not found
			  returnstatus=0
			  message$="Broken UM not defined"
			  Goto ECDone
			Endif
		  Endif
		 call dxget("PACKUM",tmp$)
		 !if tmp$<>"" ! none - keep existing
		  !If tmp$[1,1] > "9" ! sent text?                 
			R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
			If R <> 0 Let tmp$ = Str$(R)                  
		  !End If    
		  pr.UMPack=tmp$
		 !Endif
		  if pr.UMPack<=0
			returnstatus=0
			message$="Packing UM is required"
			Goto ECDone
		  Else
			umrec=pr.UMPack
			R=ChkPrdUM(e$,umrec,IntCo,Pr.)
			if r=0 ! not found
			  returnstatus=0
			  message$="Packing UM not defined"
			  Goto ECDone
			Endif
		  Endif
		 call dxget("SIZEUM",tmp$)
		 !if tmp$<>"" ! none - keep existing
		  !If tmp$[1,1] > "9" ! sent text?                 
			R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
			If R <> 0 Let tmp$ = Str$(R)                  
		  !End If    
		  pr.UMSize=tmp$
		 !Endif

		  if pr.UMSize<=0
			returnstatus=0
			message$="Product Size UM is required"
			Goto ECDone
		  Else
			umrec=pr.UMSize
			R=ChkPrdUM(e$,umrec,IntCo,Pr.)
			if r=0 ! not found
			  returnstatus=0
			  message$="Product Size UM not defined"
			  Goto ECDone
			Endif
		  Endif
		  !call dxget("SizeWidth",tmp$)\pr.SizeWidth=tmp$ ! ??grade?
		 call dxget("HighSUM",tmp$)
		 !if tmp$<>"" ! none - keep existing
			pr.HeightOfStkUM=tmp$
		 !Endif
		 call dxget("WIDESUM",tmp$)
		 !if tmp$<>"" ! none - keep existing
			pr.WidthOfStkUM=tmp$
		 !Endif
		 call dxget("LONGSUM",tmp$)
		 !if tmp$<>"" ! none - keep existing
			pr.LengthOfStkUM=tmp$
		 !Endif
		  !call dxget("SizeLength",tmp$)\pr.SizeLength=tmp$ ! ??grade?
		 call dxget("PACKSIZE",tmp$)
		 !if tmp$<>"" ! none - keep existing
			pr.PackSize$=tmp$+Blank$
		 !Endif
		 call dxget("SERVSIZE",tmp$)
		 !if tmp$<>"" ! none - keep existing
			pr.ServingSize$=tmp$+Blank$
		 !Endif
		 call dxget("NumOfServing",tmp$)
		 !if tmp$<>"" ! none - keep existing
			pr.NumOfServing=tmp$
		 !Endif
		 call dxget("ServingFactor",tmp$)
		 if tmp$<>"" ! none - keep existing
		  !If tmp$[1,1] > "9" ! sent um text?                 
			R = getumrec(e$,ccc,tmp$,IntCo,PR.)           
			If R <> 0 Let tmp$ = Str$(R)                  
		  !End If 
		  x2=tmp$
		  r=getumfactor(x2,pr.)
		  pr.ServingFactor=r ! factor
		 Endif
		pr.BlankForKey$=blank$ ! always!!
		pr.Spare1$=blank$ ! same
		write record #PRC,ProdRec,0;pr.;
		if sqlChan>=0
			call prod_DL4SQLConvert(e$,"FROMDL4",pr.,sql_prod.,Prodrec)
			e = prod_SQLAddUpdate(e$,sqlChan,sql_prod.)
			if e<>1 error 11000
		end if
		returnstatus=1
		message$="OK - costs changed"
		goto ecdone
	Endif ! of umonly fields - rest are costchg
	call dxget("PriceType",tmp$)\pr.PriceType=tmp$
	  if pr.pricetype<=0
		returnstatus=0
		message$="Price Type is required"
		Goto ECDone
	  Endif
	  call dxget("MarkupTable",tmp$)\pr.MUpTbl=tmp$
	  if custom_customer$="PRBRICK" let pr.pricetype=1;pr.MUpTbl=0
	  call dxget("BreakTableNo",tmp$)\pr.BrkTbl=tmp$
	  if cost_lev[1] ! =2 ! enter/edit
		  call dxget("LOADCOST",TMP$)
		  If RTrim$(tmp$)<>""
		  x3=tmp$
		  cnvtu[0]=pr.UMCostDefault;cnvtu[1]=0;cnvtu[2]=2
		  cnvta=x3
		  x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		  pr.CostLoad=x3
		  endif ! sent something
		  call dxget("LDMkup",tmp$)\if RTrim$(tmp$)<>"" let pr.Load1MupTbl=tmp$
		  call dxget("Load2Cost",tmp$)
		  If RTrim$(tmp$)<>""
		  x3=tmp$
		  cnvtu[0]=pr.UMCostDefault;cnvtu[1]=0;cnvtu[2]=2
		  cnvta=x3
		  x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		  pr.CostLoad2=x3
		  endif ! sent something
		  call dxget("LD2Mkup",tmp$)\if RTrim$(tmp$)<>"" let pr.Load2MupTbl=tmp$
	  Endif
	  if cost_lev[2] ! =2 ! enter/edit
		  call dxget("pocost",tmp$)
		  If RTrim$(tmp$)<>""
		  x3=tmp$
		  cnvtu[0]=pr.UMCostDefault;cnvtu[1]=0;cnvtu[2]=2
		  cnvta=x3
		  x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		  pr.CostPO=x3
		  endif ! sent something
		  call dxget("netpocost",tmp$)
		  If RTrim$(tmp$)<>""
		  x3=tmp$
		  cnvtu[0]=pr.UMCostDefault;cnvtu[1]=0;cnvtu[2]=2
		  cnvta=x3
		  x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		  pr.CostNetPO=x3
		  endif ! sent something
	  Endif
	  if cost_lev[3] ! =2 ! enter/edit
		  call dxget("basecost",tmp$)\x3=tmp$
		  cnvtu[0]=pr.UMCostDefault;cnvtu[1]=0;cnvtu[2]=2
		  cnvta=x3
		  x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		  pr.CostBase=x3
	  endif
	  if cost_lev[0] ! =2 ! enter/edit
		  call dxget("avgcost",tmp$)
		  If RTrim$(tmp$)<>""
		  x3=tmp$
		  cnvtu[0]=pr.UMCostDefault;cnvtu[1]=0;cnvtu[2]=2
		  cnvta=x3
		  x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		  pr.CostAvg=x3
		  endif ! sent something
	  Endif
	  !if pr.PriceType<>1 OR (pr.PriceType=1 AND pr.MUpTbl=0) ! matrixtbl - no change
	  ! get and save all lp's as that is what mx671s does
		  call dxget("LP1",tmp$)\x3=tmp$
		  cnvtu[0]=pr.UMPriceDefault;cnvtu[1]=0;cnvtu[2]=2
		  cnvta=x3
		  x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		  pr.ListPrice1=x3
		  call dxget("LP2",tmp$)\x3=tmp$
		  cnvtu[0]=pr.UMPriceDefault;cnvtu[1]=0;cnvtu[2]=2
		  cnvta=x3
		  x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		  pr.ListPrice2=x3
		  call dxget("LP3",tmp$)\x3=tmp$
		  cnvtu[0]=pr.UMPriceDefault;cnvtu[1]=0;cnvtu[2]=2
		  cnvta=x3
		  x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		  pr.ListPrice3=x3
		  call dxget("LP4",tmp$)\x3=tmp$
		  cnvtu[0]=pr.UMPriceDefault;cnvtu[1]=0;cnvtu[2]=2
		  cnvta=x3
		  x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		  pr.ListPrice4=x3
		  call dxget("LP5",tmp$)\x3=tmp$
		  cnvtu[0]=pr.UMPriceDefault;cnvtu[1]=0;cnvtu[2]=2
		  cnvta=x3
		  x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		  pr.ListPrice5=x3
		  call dxget("LP6",tmp$)\x3=tmp$
		  cnvtu[0]=pr.UMPriceDefault;cnvtu[1]=0;cnvtu[2]=2
		  cnvta=x3
		  x3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		  pr.ListPrice6=x3
	  ! Endif
	  let recalcnew=1  ! use proposed? (mxload5l REREADS PROD!)
	  ! write record #PRC,ProdRec,0;pr.; ! SO - write new & call? NO - PASS PR.
	  call plcprcupdt() ! do load cost & Price updates (Get Curr Price/Cost!)
	  Clear List$[]
	  ! below copied from ProdMain sections
	tmpcnt=maxcnt
	row=0
	!
	List$[row]=bsdel$,"List Prices",fdel$ \ row=row+1 ! beg section
	!
	WebStr$="ListPrices",fdel$,"Price",fdel$,"UM",fdel$
    List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	!
	! list price constants
    pum$=xunit$(PR.UMPriceDefault,ccc) ! u/m
	CNVTU[0] = 0  ! convert to rcd #, 0=base
	CNVTU[1] = PR.UMPriceDefault  ! from rcd#,convert um code to record #
	CNVTU[2] = 2  ! 2= convert cost/price, 1=convert qty
	!
	Clear tmp$
	! list price 1
	CNVTA=PR.ListPrice1	
	tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	!
	tmp1=(15-1)*10 ! get lp1 from cntrl
	Read #CTLC,18,tmp1;tmp$[1,10];
	If tmp$[Len(tmp$)]<" " let tmp$[Len(tmp$)]=" "
	if Len(tmp$)<2 or tmp$[1,5]="     " Let tmp$="List 1"
	WebStr$=RTrim$(tmp$),fdel$ ! desc
	WebStr$=WebStr$,LTrim$(tmp3 using PMask$),fdel$ ! converted price
	WebStr$=WebStr$,pum$,fdel$ ! u/m
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
    !
	! list price 2
    CNVTA=PR.ListPrice2 
	tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	!
	tmp1=(16-1)*10 ! get lp2 from cntrl
	Read #CTLC,18,tmp1;tmp$[1,10];
	If tmp$[Len(tmp$)]<" " let tmp$[Len(tmp$)]=" "
	if Len(tmp$)<2 or tmp$[1,5]="     " Let tmp$="List 2"
	WebStr$=RTrim$(tmp$),fdel$ ! desc
	WebStr$=WebStr$,LTrim$(tmp3 using PMask$),fdel$ ! converted price
	WebStr$=WebStr$,pum$,fdel$ ! u/m
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	!
	! list price 3
    CNVTA=PR.ListPrice3 ! list price 3
	tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	!
    tmp1=(17-1)*10 ! get lp3 from cntrl
	Read #CTLC,18,tmp1;tmp$[1,10];
	If tmp$[Len(tmp$)]<" " let tmp$[Len(tmp$)]=" "
	if Len(tmp$)<2 or tmp$[1,5]="     " Let tmp$="List 3"
	WebStr$=RTrim$(tmp$),fdel$ ! desc
	WebStr$=WebStr$,LTrim$(tmp3 using Pmask$),fdel$ ! converted price
	WebStr$=WebStr$,pum$,fdel$ ! u/m
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	!
	! list price 4	   
    CNVTA=PR.ListPrice4 ! list price 4
	tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	!
    tmp1=(18-1)*10 ! get lp1 from cntrl
	Read #CTLC,18,tmp1;tmp$[1,10];
	If tmp$[Len(tmp$)]<" " let tmp$[Len(tmp$)]=" "
	if Len(tmp$)<2 or tmp$[1,5]="     " Let tmp$="List 4"
	WebStr$=RTrim$(tmp$),fdel$ ! desc
	WebStr$=WebStr$,LTrim$(tmp3 using PMask$),fdel$ ! converted price
	WebStr$=WebStr$,pum$,fdel$ ! u/m
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	!
	! list price 5  
    CNVTA=PR.ListPrice5 ! list price 5
	tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	!
    tmp1=(19-1)*10 ! get lp1 from cntrl
	Read #CTLC,18,tmp1;tmp$[1,10];
	If tmp$[Len(tmp$)]<" " let tmp$[Len(tmp$)]=" "
	if Len(tmp$)<2 or tmp$[1,5]="     " Let tmp$="List 5"
	WebStr$=RTrim$(tmp$),fdel$ ! desc
	WebStr$=WebStr$,LTrim$(tmp3 using PMask$),fdel$ ! converted price
	WebStr$=WebStr$,pum$,fdel$ ! u/m
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	!
	! list price 6  
    CNVTA=PR.ListPrice6 ! list price 6
	tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	!
    tmp1=(20-1)*10 ! get lp1 from cntrl
	Read #CTLC,18,tmp1;tmp$[1,10];
	If tmp$[Len(tmp$)]<" " let tmp$[Len(tmp$)]=" "
	if Len(tmp$)<2 or tmp$[1,5]="     " Let tmp$="List 6"
	WebStr$=RTrim$(tmp$),fdel$ ! desc
	WebStr$=WebStr$,LTrim$(tmp3 using PMask$),fdel$ ! converted price
	WebStr$=WebStr$,pum$,fdel$ ! u/m
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	!
    ! end of list price
	List$[row]=esdel$  ! end of section
	Call AddToStr(e$,rstr$,List$[])  ! put header into rstr$
    !
	! Cost Section -------------------
	!
	clear List$[]
	row=0
	!
	List$[row]=bsdel$,"Costs",fdel$ \ row=row+1 ! beg section
	!
	WebStr$="ListCost",fdel$,"Cost",fdel$
	WebStr$=WebStr$,"UM",fdel$,"Table",fdel$
    List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	!
	! cost constants
    pum$=xunit$(PR.UMCostDefault,ccc) ! u/m
	CNVTU[0] = 0  ! convert to rcd #, 0=base
	CNVTU[1] = PR.UMCostDefault   ! from rcd#,convert um code to record #
	CNVTU[2] = 2  ! 2= convert cost/price, 1=convert qty
	!
	Clear tmp$
	! BASE cost
	CNVTA=PR.CostBase   ! base cost
	tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,Flag,PR.)
	!
    WebStr$="BASE COST",fdel$
	If Cost_Lev[3]>0 or addedit ! add cost_lev
	WebStr$=Webstr$,LTrim$(tmp3 using PMask$),fdel$ ! converted amount
	WebStr$=WebStr$,pum$,fdel$ ! u/m
	Else ! add no cost_lev
		Let WebStr$=WebStr$," ",fdel$," ",fdel$ ! blank cost/UM
	Endif
	
    WebStr$=WebStr$," ",fdel$ ! no table for avg
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
    !
	! load cost
	CNVTA=PR.CostLoad ! load cost
	tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,Flag,PR.)
	!
    tmp1=(13-1)*10 ! get desc from cntrl
	Read #CTLC,18,tmp1;tmp$[1,10];
	If tmp$[Len(tmp$)]<" " let tmp$[Len(tmp$)]=" "
	if Len(tmp$)<2 or tmp$[1,5]="     " Let tmp$="Load Cost"
	WebStr$=RTrim$(tmp$),fdel$ ! desc
	If Cost_Lev[1]>0 or addedit ! add cost_lev
	WebStr$=WebStr$,LTrim$(tmp3 using PMask$),fdel$ ! converted amount
	WebStr$=WebStr$,pum$,fdel$ ! u/m
	WebStr$=WebStr$,Str$(PR.Load1MupTbl),fdel$ ! load cost markup
	Else ! add no cost_lev
		Let WebStr$=WebStr$," ",fdel$," ",fdel$," ",fdel$ ! blank cost/UM/table
	Endif
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
    !
	! Redistributor cost
	CNVTA=PR.CostLoad2 ! redirect cost
	tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,Flag,PR.)
	!
    tmp1=(23-1)*10 ! get desc from cntrl
	Read #CTLC,18,tmp1;tmp$[1,10];
	If tmp$[Len(tmp$)]<" " let tmp$[Len(tmp$)]=" "
	if Len(tmp$)<2 or tmp$[1,5]="     " Let tmp$="REDI Cost"
	WebStr$=RTrim$(tmp$),fdel$ ! desc
	If Cost_Lev[1]>0 or addedit ! add cost_lev
	WebStr$=WebStr$,LTrim$(tmp3 using PMask$),fdel$ ! converted amount
	WebStr$=WebStr$,pum$,fdel$ ! u/m
	WebStr$=WebStr$,Str$(PR.Load2MupTbl),fdel$ ! redirect cost markup
	Else ! add no cost_lev
		Let WebStr$=WebStr$," ",fdel$," ",fdel$," ",fdel$ ! blank cost/UM/table
	Endif
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
    !
	! Last cost
	CNVTA=PR.CostPO  ! last cost
	tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,Flag,PR.)
	!
    tmp1=(12-1)*10 ! get desc from cntrl
	Read #CTLC,18,tmp1;tmp$[1,10];
	If tmp$[Len(tmp$)]<" " let tmp$[Len(tmp$)]=" "
	if Len(tmp$)<2 or tmp$[1,5]="     " Let tmp$="Last Cost"
	WebStr$=RTrim$(tmp$),fdel$ ! desc
	If Cost_Lev[2]>0 or addedit ! add cost_lev
	WebStr$=WebStr$,LTrim$(tmp3 using PMask$),fdel$ ! converted amount
	WebStr$=WebStr$,pum$,fdel$ ! u/m
	Else ! add no cost_lev
		Let WebStr$=WebStr$," ",fdel$," ",fdel$ ! blank cost/UM
	Endif
	WebStr$=WebStr$," ",fdel$ ! no table
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
    !
	! net po cost
	CNVTA=PR.CostNetPO  ! net po cost
	tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,Flag,PR.)
	!
    tmp1=(24-1)*10 ! get desc from cntrl
	Read #CTLC,18,tmp1;tmp$[1,10];
	If tmp$[Len(tmp$)]<" " let tmp$[Len(tmp$)]=" "
	if Len(tmp$)<2 or tmp$[1,5]="     " Let tmp$="Net PO Cost"
	WebStr$=RTrim$(tmp$),fdel$ ! desc
	If Cost_Lev[2]>0 or addedit ! add cost_lev
	WebStr$=WebStr$,LTrim$(tmp3 using PMask$),fdel$ ! converted amount
	WebStr$=WebStr$,pum$,fdel$ ! u/m
	Else ! add no cost_lev
		Let WebStr$=WebStr$," ",fdel$," ",fdel$ ! blank cost/UM
	Endif
	WebStr$=WebStr$," ",fdel$ ! no table
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
    !
	! average cost
	CNVTA=PR.CostAvg ! avg cost
	tmp3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,Flag,PR.)
	!
	tmp1=(14-1)*10 ! get desc from cntrl
	Read #CTLC,18,tmp1;tmp$[1,10];
	If tmp$[Len(tmp$)]<" " let tmp$[Len(tmp$)]=" "
	if Len(tmp$)<2 or tmp$[1,5]="     " Let tmp$="Avg Cost"
	WebStr$=RTrim$(tmp$),fdel$ ! desc
    ! WebStr$="AVG. COST",fdel$
	If Cost_Lev[0]>0 or addedit ! add cost_lev
	WebStr$=WebStr$,LTrim$(tmp3 using PMask$),fdel$ ! converted amount
	WebStr$=WebStr$,pum$,fdel$ ! u/m
	Else ! add no cost_lev
		Let WebStr$=WebStr$," ",fdel$," ",fdel$ ! blank cost/UM
	Endif
	WebStr$=WebStr$," ",fdel$ ! no table
	List$[row]=WebStr$ \ row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
    !
    ! end of cost section
	List$[row]=esdel$  ! end of section
	Call AddToStr(e$,rstr$,List$[])  ! put header into rstr$
    !
	ECDone: ! finished
 else
    include "src/callsuberr.inc"
  end try
end sub ! EdtCosts
! 
!--------------------------------------------------------------------
Sub Update_Cost_hist()
! get main data and make the call
  Try
   LET pch.ProdCode$=pr.ProdCode$+Blank$
   pch.AccessCode$=Blank$
   LET pch.Source$="Prod Edit"+Blank$
   pch.sOpen$=Blank$
   pch.Blankforkey$=Blank$
   LET pch.CDate=0
   LET pch.CTime=0
   LET pch.CostUm=pr.UMCostDefault ! PFU1[11]
	 LET pch.CstUmFactor=0
	 IF pch.CostUm>0
	  FOR XCST=0 TO 7 
		IF XCST=0 LET tmp1=pr.BaseUM
		if xcst=1 let tmp1=pr.UM2
		if xcst=2 let tmp1=pr.UM3
		if xcst=3 let tmp1=pr.UM4
		if xcst=4 let tmp1=pr.UM5
		if xcst=5 let tmp1=pr.UM6
		if xcst=6 let tmp1=pr.UM7
		if xcst=7 let tmp1=pr.UM8
		IF tmp1=pr.UMCostDefault ! PFU1[11]
		  IF XCST=0
			LET pch.CstUmFactor=1
		  ELSE
			! LET CSTHST[7]=PFU2[XCST-1]
			if xcst=1 let pch.CstUmFactor=pr.UM2Fact
			if xcst=2 let pch.CstUmFactor=pr.UM3Fact
			if xcst=3 let pch.CstUmFactor=pr.UM4Fact
			if xcst=4 let pch.CstUmFactor=pr.UM5Fact
			if xcst=5 let pch.CstUmFactor=pr.UM6Fact
			if xcst=6 let pch.CstUmFactor=pr.UM7Fact
			if xcst=7 let pch.CstUmFactor=pr.UM8Fact
		  ENDIF
		ENDIF
	  NEXT XCST
	ENDIF
  LET pch.Whse=0
	call MkCostHist(e$,IntCo,fchan[],pch.)
  else
    include "src/callsuberr.inc"
  end try
end sub ! Update_Cost_hist
! 
!--------------------------------------------------------------------
Sub updtprdref()
! update files found on Walter E. Nelson
! dynamic catalog?
 try
	! hldlprod$ is what user just entered
	! pr.nprodid$ is what was on file
	Dim k38$[60],key2$[60],k39$[60]
	Dim key3$[60],key4$[60],k1$[12]
	let k1$=pr.ProdCode$+blank$
	HLDLProd$=HLDLProd$+Blank$
	pr.NProdId$=pr.NProdId$+Blank$ ! make each space filled
	IF HLDLProd$[1,35]=pr.NProdId$[1,35] goto end_prodref:
	if not(ch_prodref) goto end_prodref: ! NO FILE 
	let k38$=" ",k38$
	LET K38$[1,35]=pr.NProdId$[1,35]  ! original
	let k38$[36,47]=k1$[1,12]
	SEARCH #ch_prodref,5,1;K38$,E8,E                                                   
	IF E=1 GOTO del_key2:                                             
	IF E ERROR 11000
	del_key2: !       
	let key2$=" ",key2$           
	let key2$[1,12]=k1$[1,12]     
	LET key2$[13,47]=pr.NProdId$[1,35]          
	SEARCH #ch_prodref,5,2;key2$,E8,E              
	IF E=1 GOTO end_Dprodref:     
	IF E ERROR 11000  
	END_DPRODREF: ! NOW INSERT
	if rtrim$(HLDLProd$)="" goto end_prodref: ! NO NEW CODE? Delete old if one
	let k38$[1,35]=HLDLProd$[1,35] ! newly entered
	SEARCH #ch_prodref,4,1;K38$,K1,E                                                   
	IF E>1 ERROR 11000  
	let key2$[13,47]=HLDLProd$[1,35]   
	SEARCH #ch_prodref,4,2;key2$,K1,E    
	IF E>1 ERROR 11000 
	           
	end_prodref: !

	Build_prodrefs: REM "=======build prodrefs file ======       
	IF HLDLProd$[1,35]=pr.NProdId$[1,35] goto end_prodrefs:
	if not(ch_prodrefs) goto end_prodrefs: ! NO FILE
	let k39$=" ",k39$ 
	let k39$[1,2]=Intco using "##"
	LET K39$[3,37]=pr.NProdId$[1,35]   ! original   
	let k39$[38,49]=k1$[1,12]
	SEARCH #ch_prodrefs,5,1;K39$,E8,E
	IF E=1 GOTO del_key22:
	IF E ERROR 11000
	del_key22: !  
	let key2$=" ",key2$
	let key2$[1,2]=Intco using "##"
	let key2$[3,14]=k1$[1,12]  
	LET key2$[15,49]=pr.NProdId$[1,35]   
	SEARCH #ch_prodrefs,5,2;key2$,E8,E
	IF E=1 GOTO del_key3:
	IF E ERROR 11000
	del_key3: !
	let key3$=" ",key3$
	LET key3$[1,35]=pr.NProdId$[1,35] 
	let key3$[36,47]=k1$[1,12]  
	let key3$[48,49]=Intco using "##"
	SEARCH #ch_prodrefs,5,3;key3$,E8,E
	IF E=1 GOTO del_key4:
	IF E ERROR 11000
	del_key4: !
	let key4$=" ",key4$
	let key4$[1,12]=k1$[1,12]
	LET key4$[13,47]=pr.NProdId$[1,35] 
	let key4$[48,49]=Intco using "##"
	SEARCH #ch_prodrefs,5,4;key4$,E8,E
	IF E=1 GOTO end_dprodrefs:
	IF E ERROR 11000 
	end_dprodrefs: ! NOW INSERT
	if RTRIM$(HLDLPROD$)="" GOTO end_prodrefs ! no new - no add
	let k39$=" ",k39$
	LET E=2 \ LET R39=0
	SEARCH #ch_prodrefs,1,0;k39$,R39,E \ IF E ERROR 11000
	let k39$[3,37]=HLDLProd$[1,35]     ! newly entered                                
	SEARCH #ch_prodrefs,4,1;K39$,R39,E
	IF E>1 ERROR 11000
	let key2$[15,49]=HLDLProd$[1,35]
	SEARCH #ch_prodrefs,4,2;key2$,R39,E
	IF E>1 ERROR 11000
	let key3$[1,35]=HLDLProd$[1,35]
	SEARCH #ch_prodrefs,4,3;key3$,R39,E
	IF E>1 ERROR 11000
	let key4$[13,47]=HLDLProd$[1,35] 
	SEARCH #ch_prodrefs,4,4;key4$,R39,E
	IF E>1 ERROR 11000
	        
	end_prodrefs: !                   

 else
    include "src/callsuberr.inc"
  end try
end sub ! updtprdref
! 
!--------------------------------------------------------------------
