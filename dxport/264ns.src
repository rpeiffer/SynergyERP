! >>> Program 264ns
!
! description Back Order Release Accept
!
! loadsave -w -n 100,10 -o prog/dxport/264ns.dl4 src/264ns.src
!
! ERPScheduler Enabled
!
!
! 1.0 mm/dd/yyyy change??
!
include "src/copyright.inc" ! dx
Rem MX264ns - PRODUCT BACK ORDERS ACCEPT  (non-stock version)
!

include "src/inc/fileedittrack.inc" ! edit tracking
! external libs & calls
External Lib "librasl.lib"
Declare External Sub chkwhrasl
External Lib "libedittrack.lib"
Declare External Sub MakeEdittrack
External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus
External Lib "ubsfunc.dl4"
Declare External Sub getportdefault
Declare External Function OpenFile,PDate$,getuidrec,JDate$

include "src/inc/fileporelease.inc"
include "src/inc/filepoline.inc" 

Declare Intrinsic sub programdump,env,getglobals
Declare Intrinsic function findchannel

Declare Intrinsic Sub DateToJulian,FindF,InpBuf,String
Option Base Year 1980
! Option Default Dialect IRIS1

Try
	If Err 0 Gosub ERR_TRAP
	DIm 1%,CNVTU[2],UN[2]
	DIm 3%,CNVTA,UWORK[10],BASE,FIELD,CFIN[8]
	DIm 2%,C4[8],S9[9],R5,H1,V1
	dim 3%,otype,prec[3],ldstat[2]
	dim 3%,wh,orgloadcost,newloadcost,ld1,ltbl
	Dim keysot$[10],1%,ch_sot,ot2[15],3%,rec_sot,2%,lc0[1]
Dim 1%,ohcurrid,olcurrid,3%,ohcurrfact,olcurrfact
Dim 2%,nsfmcode,3%,nsfrt1[1],1%,nsfrtflag
dim 3%,PARM[20],ORGSHIPAMT,ORGFREIGHT,ORGOTHER,OLDREC,OLDORDNUM,NEWREC,ORDREC
DIM 2%,TH0[12]
Dim 1%,TDCLVL,TMCTX[9],pchan[99],oldholdcodeflag[12],holdcodeflag[12]
Dim 2%,TMCD[9],TT1[1]
Dim 3%,TMCHRG[9,1],TT2[25],TTOT[4],th1
Rem {begin src/inc/dim.prod.i}
dim 1%,ch_prod,3%,rec_prod
Dim pr_A$[156],HZ$[90],PR_A2$[30],C1$[32],PSN$[20],U3$[60]
Dim PRFLG$[10],PRMKUPTYP$[4],PIC$[50],PRIML$[12]
Dim 1%,LLC,PFTB[3],PFU1[20],LM[1],UPCT,PR_PO[1]
Dim 1%,PRBASE,PRPARC2[3],PRD1[4],AGEDAY
Dim 2%,PR_A2,PR_A3[2],B[24],PR_C4[10],PFCO[3],PLC[3],PSN[1],U2,U4[1]
Dim 2%,STK[2],FDT[1],PRMKUP[3],PRD0[2]
Dim 3%,A[33],PF_LOAD2,PFU2[6],PLV[1],PRPARC[3],U3,PFN[1]
DIM 3%,PR_A1[7]
Dim 3%,LBSORD,FUT[1],PRREDI[1],PRD2[3]
Rem {end dim.prod.i}

Rem {begin src/inc/dim.prwh.i}
dim 1%,ch_prwh,3%,rec_prwh,Key_prwh$[16]
Dim W1$[32],WH3$[24],WHFLG$[10],WHMKUPTYP$[4],WCOMM$[4]
Dim 2%,W2[9],W7[14],WH7[3],WHLPOOL,WHFDT[1],WHMKUP[3]
Dim 1%,W0[3],W1[2],WH8[47],WHPARC[5],WHRPLN,WHLM[1],FCWGT
Dim 1%,RESTRICTED,WHBASE,WHPARC2[3]
Dim 3%,W3[24],W5[25],WH9[25],WHLV[2],WHMISC[6],WHMISC2[7]
Dim 3%,WHFUT[2],VLIST,WHREDI[1],WHLBS[1]
	
	Dim ETR. as edittrack ! EDITTRACKING
	dim 1%,a1[3] ! used in sordlot not product file
	Dim 1%,CH_ZONE,CH_PROD,CH_COMMCODE,CH_CUST,CH_BOWORK,CH_ROS,CH_ROH,CH_ROM
	Dim 1%,CH_ROT,CH_ROL,CH_SPRODDESC,CH_SORDLOT,CH_SLSM,CH_BOCONV,CH_SHIPHIST
	Dim 1%,CH_CCODES,CH_TAXCODE,CH_CUSTTAX,CH_PRODWHSE,CH_CNTRL,CH_SPRODLOT
	Dim 1%,CH_CREDCK,CHOPEN[20],OWHT[1],PICKBY[1],CH[30],FChan[20],ch_por
	Dim 1%,L3[3],H4[2],J9[2],H3[1],S8,S8_OLD,LINEEXIST,OLS2[1],PL[1],S6[1],F,X0
	Dim 1%,DCLVL,DFLAG[4],PASS,FTFLG[4],LEVEL,LOCKPORT,WHSEPR,DFT_COST,LINENUM
	Dim 1%,WHLM[1],LM[1],CHAN[2],CHNLFREE,FTAX,DTAX,HTAX,TAX[100],PT[37]
	Dim 1%,MCTXBL[9],RASL[5],P1[1],ZLINE,STAT,WARN,WHSE,OWHS,LPRINTED,CTWT
	Dim 1%,CHMISC,MS1[2],MS$[32],1%,MS2[2],MISCFILE$[16],CR_CHNL[20],EUN[2]
	!Dim 1%,ETLINE,ETSTAT,ETUNIT,ETNONSTOCK,ETPRINT,ETPUNIT[1]
	Dim 2%,L2[1],L4[3],L6[5],H0[12],H5[16],D8,D1,T8,N1,OOH0[12],S1[1],T1[1],P2[2]
	Dim 2%,SLSM[9],SHIPDATE,HS3[24],H6[8],MCODE[9],LCO[1],LTAX2,X2,DT3[1],P4
	Dim 2%,B[24],S5,D0,S0$[36],S$[30],FLG$[4],K6$[50],LOC$[6],MT$[2]
	Dim 2%,OOQO,OOQBO,OOQSHIP,A2$[50],L9[1],A2[3],M1,B2[5],UN[2],A0[3]
	Dim 2%,DCHRG[11],DCOST[11],STARTCHAN,ORIG_DUEDATE,ORIG_SHIPDATE,HFAX[1]
	Dim 2%,C1[3],CCHK[5],DT3[1],LP_DATE,LP_TIME,SYS_DATE,H2,OWHT1
	Dim 2%,MAXWGT[11],DFLTCOST[11],MINCOST[11],MAXCOST[11],DFLTCHG[11],WHBLD[11]
	!Dim 2%,ETORDER,ETDATE,ETTIME,ETPORT,ETACTION,ETCUST,ETSLS
	Dim 3%,MH2,MH2$[1]
	Dim 3%,L5[3],B0[11],T2[25],C8,L7[12],L7$[6],M1$[40],B3[3],B2$[12]
	Dim 3%,CST,LTAX1,MAXTAX,P3[4],TTAX,TAXABLE,LINETAX,OREF[5]
	Dim 3%,AMOUNT,SUNIT$[4],PUNIT$[4],OLR2,V0$[12],H1$[6],OLM[6],SRN[5],UNF[6]
	Dim 3%,X1,J,X3,T9[20],K3$[60],P0$[20],H0$[20],K4$[60],S2[1]
	Dim 3%,A3[5],O7[12],S7[20],R11,R13,R133,MCHARGE[9,1],TOT[4],PFA1[7]
	Dim 3%,S3[17],TOT_SELL,OLS3$[33],OL2$[16],HMAT$[2],ORDAMT
	Dim 3%,WHREC,WGT,R1[10],PREC[3],SCR,VDATE,PARAM[5],EX[18],GP
	!Dim 3%,ETOQTY[2],ETNQTY[2],ETORIGTOT,ETINVOICE,ETUNITPRICE[1]
	Dim 3%,O_OREF[5],TL2[1] ! ETLOADCOST[1],ETWGT[1],
	Dim J$[40],J1$[30],J2$[20],J3$[40],J4$[40],J8$[8],U5$[10],P9$[50]
	Dim K1$[60],K2$[20],X$[10],T9$[26],S1$[118],J9$[50],S2$[20],S3$[25]
	Dim L1$[60],L2$[20],B0$[12],A$[50],K5$[60],Q$[60],RASL_LOC$[6],P60$[50]
	Dim A1$[60],CCHK1$[30],P61$[256],R$[33],CSZONE$[2]
	Dim K11$[20],SCRATCH$[80],F$[16],CCTEXT$[50],PASSWORD$[10],S_KEY$[42]
	Dim SL_P0$[66],K13$[60],K133$[60],K1333$[60],RTYPE$[1]
	Dim PICKFLAG$[1] ! ET$[80],ETPROD$[12],ETUSER$[10],
	Dim LPONUM$[30],LJOBNUM$[30],PSNUM$[30],MSG1$[30],MSG2$[30],K31$[20]
	Dim msg$[100],msgs$[750]
	Dim e$[500],buttonlist$[5,50],nextlist$[5,100] ! dx error handling variables
	Dim tmp$[800],tmp1$[200],nextblockid$[8],Message$[600],WebStr$[600],blockid$[100]
	Dim action$[30],options$[30],userid$[8],b$[200],3%,fdel$[10],rstr$[2000],bsdel$[10],esdel$[10],rdel$[10]
DIM 2%,NSL7[2],HA3[2]
DIM 3%,NSL8[4],NSINVNO,NNSFRT1[2]
DIM NSL$[60],NSL2$[18],HA1$[50],NSUDA$[120]
        Dim keypol$[50],3%,rec_pol
	!
	Dim keypor$[50],mode$[3]
	Dim por. As porelease
	Dim pol. as poline
	!
	Try 
		Enter tmpMessage$,type,searchval$
	else
		Dim tmpmessage$[600],searchval$[100]
	end try
	Close
	!-------------------------------------------------------
	B$=" ",B$
	!
	Try 
		!call dxopen() ! may not need this! NEEDS FOR DXTEST RUN!!
	Else
		Rem
	End try
	!
	Call getsession(e$,CTLC,options$,action$,userid$,intCO,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$)
	COID=IntCo 
	Close #1 ! as getsession opens READONLY
	J$="cntrl/cntrl"+Str$(COID)
	Open #1,J$
	Mat Read #1,60,50;P60$;
	Mat Read #1,61,0;P61$;
	let nsfmcode=0
	if p61$[132,132]="Y"
		mat read #ctlc,52,104;nsfmcode;
		if nsfmcode<0 or nsfmcode>999 let nsfmcode=0
	endif
	Def FNR(X) = Sgn(X) * (Int(Abs(X) * 100 + .5) * .01)
	Def FNV(X) = Sgn(X) * (Int(Abs(X) * 100 + .9999999) * .01)
	Def FNH(X) = ((F7 = 99 And H0[0] = 1 And T9[0] = 0) Or (F7 = 0 And T9[0] = 0))
	Try Close #9  Else REM ! blockid always has #9 as sortfile
	For J = 2 To 19
	  Read J1 \ If J1 = -1 Goto L_830
	  Read #1,88,J1;J$;
	  Open #J,J$
	L_830: Next J
	Read #1,3;J1$;
	Mat Read #1,0,100;J8$;
	Read #1,3,172;D8;
	Read #1,3,188;SHIPDATE;
	Data "1920","1792","2288","1808","2576","1856","1840","1968","1872","1888","2128","2320","1824"
	Data "2592","2496","1728","-1","2528"
	CH_CNTRL = 1
	CH_ZONE = 2
	CH_PROD = 3
	CH_COMMCODE = 4
	CH_CUST = 5
	CH_BOWORK = 6
	CH_ROS = 7
	CH_ROH = 8
	CH_ROM = 9
	CH_ROT = 10
	CH_ROL = 11
	CH_SPRODDESC = 12
	CH_SORDLOT = 13
	CH_SLSM = 14
	CH_BOCONV = 15
	CH_SHIPHIST = 16
	CH_CCODES = 17
	CH_TAXCODE = 32 ! CANNOT USE #18 - it is closed in 264a!
	CH_SPRODLOT = 19
	CH_PRODWHSE = 30
	CH_ROLTAG = 31
	CH_CUSTTAX = 50
	CH_CREDCK = 51
	CH_ET = 55
	Ch_pol=40
	SCRATCH$ = Str$(COID)
	Read #CH_CNTRL,88,1744;F$[1,16]; \ Open #CH_PRODWHSE,F$[1,16]
	Read #CH_CNTRL,88,928;F$[1,16]; \ Open #CH_CUSTTAX,F$[1,16]
	Read #CH_CNTRL,88,992;F$[1,16]; \ Open #CH_CREDCK,F$[1,16]
	Read #ch_cntrl,88,2176;F$[1,16]; \ ROpen #CH_TaxCode,f$[1,16] ! ropen
	Read #ch_cntrl,88,2432;F$[1,16]; \ open #ch_pol,f$[1,16]
	Open #CH_ET,"2/EDITTRACK" + SCRATCH$
	ROLTAGFLAG = 0
	F$ = "3/SORDROLTAG" + SCRATCH$
	Call FindF(F$,ROLTAGFLAG)
	If ROLTAGFLAG
	  Open #CH_ROLTAG,"3/sordroltag" + SCRATCH$
	End If 
	!
	CH_POR = FindChannel()
	Open #ch_por,"3/porelease"+scratch$

	CH_SOT=FindChannel()
	Open #ch_sot,"3/sordtype"+scratch$
	!
!----------------------------------------------------------------

	Mat Read #1,19,50;P9$;
	Mat Read #1,66,0;PASSWORD$;
	!
	! Call dxsave(0,"tmp/264in.txt!") ! save web data sent
	!If Err 0 Let J8 = Spc(8)
	If P9$[32,33] = "YY"
	  WHSEPR = 1
	Else 
	  WHSEPR = 0
	End If 
	If P9$[41,41] = "Y" Or P9$[41,41] = "W"
	  RASL = 1
	Else 
	  RASL = 0
	End If 
	Read #CH_CNTRL,3,172;SYS_DATE;
	LOC$ = "STOCK "
	RASL_LOC$ = "NONE  "
	If P9$[45,45] = "Y" Let S2 = 2 Else Let S2 = 1
	UIDRec=GetUIDRec(e$,IntCo,Userid$)
	!Read #1,20,2;S8;
	!If S8 <> 2 Goto L_8900
	!S8_OLD = S8
	!S8 = -3
	!Write #1,20,2;S8;
!------------------------------------------------------------------
!K3$ = " ",k3$;F8 = 0
!Search #CH_BOCONV,3,1;K3$,R0,E \ If E > 2 Gosub ERR_SEARCH
!If Not(E) Let F8 = 9
!Print 'CS';@0,0;"MX264";@25,0;"BACKORDER ACCEPT"
!Print @1,4;"ABOUT TO ACCEPT BACKORDER RELEASES.  THIS PROGRAM WILL DO THE FOLLOWING:";
!Print @3,6;"  1) Create a new ORDER at  status 1 ENTERED ";
!Print @3,7;"  2) Change the ship date to the current date plus the lead time for the zone ";
!Print @3,8;"     if the due date in the header of the original order is less than the  ";
!Print @3,9;"     current date";
!Print @3,10;"  3) Reset the order to print on the PICKLIST & ROUTING report ";
!Print @3,11;"  4) Retotal the order based on new shipping QTY.";
!Print @3,12;"  5) Delete OLD ORDER LINE if zero (0) units left to ship ";
!Print @3,13;"  6) Delete OLD ORDER if no lines left ";
!Print @3,14;"  7) CLEAR OUT THE BACK ORDER WORK FILE !! ";
!If F8 Print @1,18;'BB';">>>";'EB BR';"REMINDER!  BACKORDER NUMBER CONVERSION REPORT(265) HAS NOT BEEN CLEARED ";'ER';
!If F8 Print 'BB';"<<< ";'EB';
!Print @10,16;"DO YOU WISH TO CONTINUE (YES/<CR>) ";
!Input ""U5$
!------------------------------------------------------------

	ReturnStatus=0;Message$="OK"
!
	! Call DXGet("TYPE",tmp$) \ type=tmp$  ! 0=ALL, 1=SalesOrd 2=PO, 3=Cust
	! Call DXGet("SEARCHVAL",searchval$)
! U5$=""
! if UCase$(RTRIM$(tmp$))="Y" Let U5$="YES"
! Call programdump("tmp/264.txt!","") 
! If U5$ = "" Goto DONE_NOCLEAR
! If U5$ <> "YES" Goto DONE_NOCLEAR
!Print @0,21;"PLEASE WAIT . . .  ";'CE'; \ Signal 3,0
!
	If Err 0 Gosub ERR_TRAP
	MAIN: Rem
	K1$ = " ",K1$
	O2 = -999;INVOICE = 0
	ORDERMADE = 0
	F8 = 0
	!
	! defaults
	dir=1
	searchval=searchval$
	!
	If Type = 0		! all
		searchval$=0
		searchval$=" ",searchval$
		dir=1
	End if
	!
	keypor$=" ",keypor$
	keypor$[1,1]= 0 using "&"  ! we only want 0 flag items
	keypor$[2]=searchval using "######"

	Dir=Type
	mode$=">=" ! search mode 3
	!
MAIN_LOOP: Rem loop thru porelease file & create new orders
	!
	! Call programdump("tmp/rce1.txt!","")
	!
	!rec_por=filegetporelease(e$,ch_por,mode$,dir,keypor$,por.)
	!
	Search #ch_por,3,1;keypor$,rec_por,e
	if not(e) Read Record #ch_por,rec_por,0;por.
	Try tmp=Val(keypor$[2,7]) else e=1
	If keypor$[1,1]="1" let e=2  ! reached the end of open recs
	
	if E=2 ! all done
		!If Not(ORDERMADE) And F8 And INVOICE = 0 ! if prev is releasing and at eof
		!	Gosub RECALC_TOTALS
		!End If 
		Goto DONE
	end if

	!
	B0[9]=POR.ROHREC

	!Search #CH_BOWORK,3,2;K1$,R6,E
	!If E = 2
	!  If Not(ORDERMADE) And F8 And INVOICE = 0 ! if prev is releasing and at eof
	!    Gosub RECALC_TOTALS
	!  End If 
	!  Goto DONE
	!End If 
	!If E Gosub ERR_SEARCH
	!
	! O3 = K1$[7,12];INVOICE = 0
	O3 = POR.SordNum;INVOICE = 0
	!
	Gosub CHK_HEADER \ If INVOICE = 1 Goto MAIN_LOOP

!If INVOICE <= -1 ! "leave batch unfinished until user runs accept
!  If Not(ORDERMADE) And F8 Gosub RECALC_TOTALS
!  Goto DONE_NOCLEAR
!End If 
!If Not(ORDERMADE) If O2 > 0 If O2 <> O3 Gosub RECALC_TOTALS
!Mat Read #CH_BOWORK,R6,0;B0$;
!Mat Read #CH_BOWORK,R6,12;B0;
!If B0[7] <> 2 Goto MAIN_LOOP
!Gosub DOES_LINE_EXIST
!If Not(LINEEXIST) Goto MAIN_LOOP

!If B0[3] <> R11
  !Print @0,23;'CL RB';"ORDER/LINE CONFLICTS (SKIPPED):";K11$;
  !Signal 3,30 \ Goto MAIN_LOOP
!  Goto MAIN_LOOP
!End If 

!--------------------------------------------------------------
!---------------- Make Order Here ----------------------------
!--------------------------------------------------------------
	F8 = 0
	Gosub DOES_LINE_EXIST
	L1 = R11		! B0[3]		! ROLNEW rec#
	Gosub READ_ROL
	OOL3 = L3[2]
	WHSE = L4[3]
	ORDERMADE = 0
	If O2 <> O3 ! SAME ORDER DONT READ HEADER
	  Mat Read #CH_ROH,B0[9],0;H0
	  Mat Read #CH_ROH,B0[9],78;H4
	  Mat Read #CH_ROH,B0[9],104;H5
	  Mat Read #CH_ROS,H0[2],0;S1
	  Mat Read #CH_ROS,H0[2],8;S1$
	  Mat Read #CH_ROS,H0[2],126;S2$
	  Mat Read #CH_ROH,B0[9],444;HMAT$
	  Mat Read #CH_ROH,B0[9],482;H2;
	  Mat Read #CH_ROH,B0[9],512;OREF;
	  mat read #ch_roh,b0[9],624;ohcurrid;
      mat read #ch_roh,b0[9],626;ohcurrfact; ! 
	  Read #CH_ROS,H0[2],146;S5
	  Mat Read #CH_ROS,H0[2],150;S6
	  Mat Read #CH_ROS,H0[2],154;SRN;
	  ORIG_DUEDATE = H5[1]
	  X2 = H5[1] \ Gosub YMD2JUL \ X2 = 0
	  ORIG_JDUEDATE = X2
	  ORIG_SHIPDATE = H0[10]
	  ORIG_ORDDATE=H0[9]
	End If 
	If WHSE <= 0 Or WHSE > 99 Let WHSE = H4[2]
	let keysot$=h5[7] using "##"
	search #ch_sot,2,1;keysot$,rec_sot,e
	if e<>0
		let ot2[12]=0
	else
		mat read #ch_sot,rec_sot,32;ot2;
	endif!
	! CHECK ORDER TYPE
	IF H5[7]=21 OR H5[7]=22
		mode$="c"
		POR.UpdtFlg=2
		!
		updstat = fileupdateporelease(e$,ch_por,mode$,rec_por,por.)
		Goto MAIN_LOOP
	End If  ! H5[7]=21 OR H5[7]=22
	!
	Gosub GET_ZONE
	If O2 <> O3
	  Gosub BUILD_ROH
	  T9[19] = 0
	  Gosub READ_HOLD_EX
	End If 
	Gosub SHIPHIST
	H0[7] = N1
	Gosub WRITE_NEWORDERLINE
	Gosub WRITE_MSGLINE
	!	B0[7] = 3		! REL. FLAG
	!	Mat Write #CH_BOWORK,R6,12;B0;
	! UPDATE PURCHASE ORDER LINE WITH NEW SALES ORDER # 
	! H0[7]/N1 IS THE NEW ORDER #
	LET KEYPOL$=" ",KEYPOL$
	LET KEYPOL$[1,6]=por.PONum Using "######"    
	let keypol$[7]=por.POLineNum using "###"
	search #ch_pol,2,1;keypol$,rec_pol,e
	if not(e)
		read record #ch_pol,rec_pol;pol.;
		if pol.SalesOrd<>l2[1] or pol.SalesOrdLine <>l3[2]
			let pol.SalesOrd=l2[1]
			let pol.SalesOrdLine=l3[2]
			write record #ch_pol,rec_pol;pol.;
		endif
	endif
	mode$="c"
	POR.UpdtFlg=1
	!
	updstat = fileupdateporelease(e$,ch_por,mode$,rec_por,por.)
	!
	if F8>1 And INVOICE = 0 
		Gosub Recalc_totals
		IF P61$[132,132]="Y" AND NSFMCODE<>0 AND nsfrtflag<>0
			let ordrec=oldrec
			if ordrec<>0 gosub TotalOrd:
			let ordrec=newrec
			if ordrec<>0 gosub TotalOrd:
		endif
		let nsfrtflag=0
	endif
	!
	Goto MAIN_LOOP
!--------------------------------------------------------------
!--------------- End of Make Order -----------------------
!--------------------------------------------------------------

CHK_HEADER: Rem "Check if valid to work on (Delete, etc.)
For X1 = 1 To 99
  J$ = X1 Using "##"
  J$[3] = O3 Using "######"
  Search #CH_ROH,2,1;J$,R1[8],E \ If E > 1 Gosub ERR_SEARCH
  If Not(E)
	let oldrec=r1[8]
	let oldordnum=o3
    If X1 <= 6
      Return 
    Else 
      INVOICE = - X1
      Return 
    End If 
  End If 
  If X1 = 7 Let X1 = 57
  If X1 = 59 Let X1 = 89
Next X1
INVOICE = 1
Return 

!---------------------------------------------------------

GP_COMPONENTS: Rem "================================= gp component(s)
H5[13] = T2[1] \ H5[14] = T2[17]
If P9$[35,35] = "Y" Let H5[13] = H5[13] + T2[5]
If P9$[36,36] = "Y" Let H5[13] = H5[13] - T2[3]
If P9$[37,37] = "Y" Let H5[14] = H5[14] + T2[20]
If P9$[38,38] = "Y" Let H5[13] = H5[13] + T2[6]
H5[13] = H5[13] + TOT[1];H5[14] = H5[14] + TOT[2]
If B0[9] <> H1 Let H0[8] = 0;OREF[1] = 0
Gosub WRITE_ROH
Return 

!----------------------------------------------------------------

DOES_LINE_EXIST: Rem -----------------------------returns lineexist (1/0)
K11$ = " ",K11$
K11$[1,6] =	POR.SordNum	using "######"		! K1$[7,15]
K11$[7,10] = POR.SordLineNum using "### "
Search #CH_ROL,2,1;K11$,R11,E
If E > 2 Gosub ERR_SEARCH
If E
  LINEEXIST = 0
  !Print @0,23;'CL RB';"ORDER/LINE NOT FOUND (SKIPPED):";K11$;
  !Signal 3,30
Else 
  LINEEXIST = 1
End If 
Return 

!---------------------------------------------------------------

RECALC_TOTALS: Rem this routine recalcs first for the new order (f7=0),
Gosub READ_ROT
Gosub GET_CUST
If F7 = 99
  Gosub OPENORDERAMT
  Gosub WRITE_OPENORDERAMT
End If 
T2[7] = 0;LINETAX = 0
Gosub ZER_ROT
Gosub GET_SLSM
A$ = " ",A$ \ A$[1,6] = H0[7] Using "######"
NEXTLINE: Rem
Search #CH_ROL,3,1;A$,V11,E
If E > 2 Gosub ERR_SEARCH
N0 = A$[1,6]
If Not(E) And N0 = H0[7]
  Gosub ACCUM_TOTALS
  Goto NEXTLINE
End If 
Gosub GET_FTAX
If Not(F7) Gosub CHECK_4DELIV_CHG
If Not(F7) Gosub GET_FREIGHT_CHG
Gosub DO_DISCOUNT
Gosub DO_TAXES
Gosub WRITE_ROT
Gosub GP_COMPONENTS
If Not(F7) Let H1 = B0[9] \ Gosub READ_ROH \ F7 = 99 \ Goto RECALC_TOTALS
If F7 Let H1 = R3 \ Gosub READ_ROH \ F7 = 0
Gosub DEL_CHECK
! Swap 1,"MXSLSCOM"
clear s9[]
		let s9[0]=H0[7] ! orderid
		let s9[1]=intco
		let s9[2]=H0[11] ! roh.slsm
		let s9[4]=201 ! order entry program #
clear ch[] ! channels for files sent to mxslscom5
		LET CH[1]=CH_CNTRL;CH[3]=CH_PROD;CH[4]=CH_COMMCODE;CH[5]=CH_CUST             
		LET CH[6]=CH_PRWH;CH[7]=CH_ROS;CH[8]=CH_ROH;CH[9]=CH_ROT;CH[10]=CH_ROL    
		LET CH[11]=CH_SPRODDESC;CH[12]=CH_CUSTTAX;CH[13]=CH_SLSM
		Call "MXSLSCOM5",S9[],CH[],R5,H1,V1,CFIN[] 
Gosub CLEAR_EDIT_STATUS
ORDERMADE = 1
Return

!---------------------------------------------------------

ACCUM_TOTALS: Rem ADD LINE ITEM TO TOTALS
L1 = V11
Gosub READ_ROL
If L2[1] <> N0 Let L2[1] = N0
If L3[2] > 900 Goto L_3590
If UN[1] = -2 Let L5[3] = OLM[3] Else Let L5[3] = FNR(OLM[3] * L7[4])
If S3[8] = -3 Let S3[9] = S3[0] Else Let S3[9] = FNR(S3[0] * L7[4])
If S3[11] = -3 Let S3[10] = S3[1] Else Let S3[10] = FNR(S3[1] * L7[4])
If Not(A[5]) Let A[5] = 1
S3[4] = FNR(Abs((L6[4] * L7[4]) / A[5]))
If UN[2] = -2 Let S3[12] = L5[1] Else Let S3[12] = FNR((L5[1] * L7[4]) + S3[10])
If UN[2] = -2 Let S3[13] = L5[1] Else Let S3[13] = L7[2] * L5[1]
T2[1] = T2[1] + L5[3]
T2[16] = T2[16] + FNR(S3[4])
If Not(PFA1[3]) Let PFA1[3] = 1
T2[15] = T2[15] + FNR((L7[4] * L6[2]) / PFA1[3])
If L6[5] Let T2[8] = T2[8] + L5[3]
If Not(L6[5]) Let T2[9] = T2[9] + L5[3]
CNVTU[0] = 0;CNVTU[1] = UN[0];CNVTU[2] = 1;CNVTA = L7[4]
Gosub CONVERT
TOT_SELL = TOT_SELL + AMOUNT
If P60$[42,42] = "Y"
  If Not(L6[5]) Let LTAX1 = 0 \ LTAX2 = 0 \ Goto L_3566
  Mat Read #CH_TAXCODE,L6[5],20;T8;
  Mat Read #CH_TAXCODE,L6[5],414;RTYPE;
  If RTYPE$ <> "N" And RTYPE$ <> "U" Let RTYPE$ = "N"
  LTAX2 = T8
  LTAX1 = FNR((L5[3]) * (LTAX2 / 100))
  If RTYPE$ = "U" Let LTAX1 = FNV((L5[3]) * (LTAX2 / 100))
  Mat Read #CH_TAXCODE,L6[5],66;MAXTAX; \ If Not(MAXTAX) Goto L_3565
  If LTAX1 > FNR(MAXTAX * AMOUNT) Let LTAX1 = FNR(MAXTAX * AMOUNT)
  If RTYPE$ = "U" If LTAX1 > FNV(MAXTAX * AMOUNT) Let LTAX1 = FNV(MAXTAX * AMOUNT)
L_3565: LINETAX = LINETAX + LTAX1
L_3566: Mat Write #CH_ROL,L1,508;LTAX1
  Mat Write #CH_ROL,L1,538;LTAX2;
Else 
  Unlock #CH_ROL
End If 
L5[0] = FNR(OLM[3] * L7[2])
If UN[1] = -2
  L5[0] = FNR(OLM[3] * Sgn(L7[2]))
End If 
If OLS2[1] Let L7[5] = (L7[4] / OLS2[1]) Else Let L7[5] = L7[4]
T2[24] = T2[24] + L5[0]
T2[17] = T2[17] + S3[12]
T2[14] = T2[14] + S3[13]
T2[18] = T2[18] + FNR((B[21] * L7[4]))
L_3590: Gosub WRITE_ROL
Rem check for gp hold by line
If Not(H6[1]) !! hold override in affect from parent order
  GP = L5[3] - S3[12]
  If EX[3] If GP < EX[3] Let T9[19] = 1
  If EX[4] If GP > EX[4] Let T9[19] = 1
  If EX[17] If Not(L5[3]) Let T9[19] = 1
  If L5[3] If EX[17] If FNR((GP / L5[3]) * 100) < EX[17] Let T9[19] = 1
  If L5[3] If EX[18] If FNR((GP / L5[3]) * 100) > EX[18] Let T9[19] = 1
End If 
Return 

!------------------------------------------------------------

ZER_ROT: Rem ZERO TOTALS RECORD
For K = 0 To 25
  If Not(F7) ! only clear these for new order
    If K < 3 Let TOT[K] = 0
    If K < 10 Let MCODE[K] = 0;MCHARGE[K,0] = 0;MCHARGE[K,1] = 0;MCTXBL[K] = 0
  End If 
  If K = 3 Or K = 2 Or K = 21 Goto L_3620
  If F7 If (K >= 4 And K <= 6) Or K = 19 Or K = 20 Goto L_3620
  T2[K] = 0
L_3620: Rem
Next K
If P61$[53,53] = "N" And F7 = 0 Let DCLVL = 0
TOT_SELL = 0
Return 

!------------------------------------------------------------

OPENORDERAMT: Rem OPEN ORDER $ (P60$ check and bill to added 2/22/96-jlp)
If H5[7] = 15 And H0[5] <> 0 Return 
If H5[7] = 4 And H0[5] <> 0
  ORDAMT = T2[0]
Else 
  If P60$[40,40] = "O" And (T2[24] - TOT[4]) > 0
    ORDAMT = (T2[0] - T2[1] + T2[24] - TOT[4])
  Else 
    ORDAMT = T2[0]
  End If 
End If 
Return 

!------------------------------------------------------------

WRITE_OPENORDERAMT: Read #CH_CUST,R5,412;C8
C8 = C8 - ORDAMT
Write #CH_CUST,R5,412;C8;
If H0[1] <> H0[4]
  K5$ = " ",K5$;K5$ = H0[1] Using "######"
  Search #CH_CUST,2,1;K5$,K5,E \ If E > 2 Gosub ERR_SEARCH
  If Not(E)
    Read #CH_CUST,K5,412;C8
    If F7 Let C8 = C8 - O1
    Write #CH_CUST,K5,412;C8;
  End If 
End If 
Return 

!------------------------------------------------------------

GET_CUST: Rem
K5$ = H0[4] Using "######"
Search #CH_CUST,2,1;K5$,R5,E
If E Gosub ERR_SEARCH
Read #CH_CUST,R5,412;C8
Mat Read #CH_CUST,R5,486;A0
Mat Read #CH_CUST,R5,544;CFIN;
Return 

!------------------------------------------------------------

GET_SLSM: Rem GET SLSM/COMM
S3$ = " ",S3$ \ S3$ = H0[11] Using "###"
Search #CH_SLSM,2,1;S3$,V1,E \ If E Gosub ERR_SEARCH
Read #CH_SLSM,V1,118;C9;
Return 

!------------------------------------------------------------

READ_PROD: Rem READ PROD
If L3[0] Let B[21] = L5[1] \ Return 
If Not(PFA1[3]) Let PFA1[3] = 1
If Not(A[5]) Let A[5] = 1
Mat Read #CH_PROD,L4,156;B;
Mat Read #CH_PROD,L4,512;PFU1;
Mat Read #CH_PROD,L4,554;PFU2;
Mat Read #CH_PROD,L4,256;A; \ Mat Read #CH_PROD,L4,460;PFA1;
If B[21] <= 0 Let B[21] = L5[1]
If Not(A[5]) Let A[5] = 1
If Not(PFA1[3]) Let PFA1[3] = 1
Return 

!------------------------------------------------------------

READ_ROH: Rem READ HEADER REC.
	Mat Read #CH_ROH,H1;H0
	Mat Read #CH_ROH,H1,52;H3
	Mat Read #CH_ROH,H1,56;TOT_SELL
	Mat Read #CH_ROH,H1,66;V0$
	Mat Read #CH_ROH,H1,172;HS3
	Mat Read #CH_ROH,H1,272;H1$
	Mat Read #CH_ROH,H1,446;P0$
	Mat Read #CH_ROH,H1,78;H4
	Mat Read #CH_ROH,H1,408;H6
	Mat Read #CH_ROH,H1,444;HMAT$
	Mat Read #CH_ROH,H1,84;H0$
	Mat Read #CH_ROH,H1,104;H5
	Mat Read #CH_ROH,H1,278;SLSM
	Mat Read #CH_ROH,H1,466;HFAX
	Mat Read #CH_ROH,H1,482;H2;
	Mat Read #CH_ROH,H1,486;OWHT;
	Mat Read #CH_ROH,H1,490;OWHT1;
	Mat Read #CH_ROH,H1,512;OREF;
	mat read #ch_roh,H1,624;ohcurrid;
    mat read #ch_roh,H1,626;ohcurrfact ! 
Return 

!------------------------------------------------------------

READ_ROL: Rem READ LINE REC.
	Mat Read #CH_ROL,L1,0;L2;
	Mat Read #CH_ROL,L1,8;L3;
	Mat Read #CH_ROL,L1,16;L4;
	Mat Read #CH_ROL,L1,32;L5
	Mat Read #CH_ROL,L1,56;L6
	Mat Read #CH_ROL,L1,80;L1$;
	Mat Read #CH_ROL,L1,140;L2$;
	Mat Read #CH_ROL,L1,160;L9;
	Mat Read #CH_ROL,L1,168;L7;	
	Mat Read #CH_ROL,L1,246;PL;
    Mat Read #CH_ROL,L1,250;UN;
	Mat Read #CH_ROL,L1,256;OLS2;	
	Mat Read #CH_ROL,L1,260;S3;
	Mat Read #CH_ROL,L1,368;MT$;
	Mat Read #CH_ROL,L1,370;S3$;
	Mat Read #CH_ROL,L1,404;OLM;	
	Mat Read #CH_ROL,L1,446;EUN;
	Mat Read #CH_ROL,L1,452;UNF;
	Mat Read #CH_ROL,L1,494;LCO;
	Mat Read #CH_ROL,L1,502;CST;
	Mat Read #CH_ROL,L1,508;LTAX1;
	Mat Read #CH_ROL,L1,514;CTWT
	Mat Read #CH_ROL,L1,538;LTAX2
	READ #CH_ROL,L1,548;OWHS;
	READ #CH_ROL,L1,550;LPRINTED;
	READ #CH_ROL,L1,552;LP_DATE;
	READ #CH_ROL,L1,556;LP_TIME;
	mat read #ch_rol,l1,624;olcurrid;
	mat read #ch_rol,l1,626;olcurrfact;
 


	If Not(L3[0]) Gosub READ_PROD
Return 

!------------------------------------------------------------

READ_ROT: Rem READ TOTALS REC.
	Mat Read #CH_ROT,OOH0[3],0;T1;
	Mat Read #CH_ROT,OOH0[3],8;T2;
	Mat Read #CH_ROT,OOH0[3],168;MCODE;
	Mat Read #CH_ROT,OOH0[3],208;MCHARGE;
	Mat Read #CH_ROT,OOH0[3],328;TOT;
	Mat Read #CH_ROT,OOH0[3],358;MCTXBL;
	Mat Read #CH_ROT,OOH0[3],378;DCLVL;
Return 

!------------------------------------------------------------

WRITE_ROT: Rem WRITE TOTALS REC.
If S9[3] <> 2
  Read #CH_TAXCODE,H4[0],20;T8;
  Mat Read #CH_TAXCODE,H4[0],414;RTYPE$;
  If RTYPE$ <> "N" And RTYPE$ <> "U" Let RTYPE$ = "N"
  T2[2] = T8
  If P60$[42,42] <> "Y" Let T2[7] = 0
  If P60$[42,42] <> "Y"
    T2[7] = FNR(T2[8] * (T2[2] / 100))
    If RTYPE$ = "U" Let T2[7] = FNV(T2[8] * (T2[2] / 100))
  End If 
  If H5[7] = 6 Or H5[7] = 10 Let T2[6] = 0 - T2[7]
  Gosub DO_DISCOUNT
End If 
T2 = T2[1] - T2[3] + T2[4] + T2[5] + T2[6] + T2[7]
T1[1] = H0[7]
Gosub UNPACK_HOLD
Gosub OPENORDERAMT
CCSTATUS = 0
If H6[1] <> 0 Or Not(FNH(F7)) ! of holds are overridden
  ORDAMT = - ORDAMT
  Gosub WRITE_OPENORDERAMT
  ORDAMT = - ORDAMT
  If Not(FNH(F7)) And T9[0] = 1 And F7 = 0
    If PASSWORD$[1,1] > " "
      Gosub WRITE_CREDCK
    End If 
  End If 
Else 
  CCTEXT$ = " ",CCTEXT$;T9[0] = 0
  !Call "credck",H0[4],H0[1],ORDAMT,H0[7],CCSTATUS,CCTEXT$
  Let cr_CHNL[1]=1   !cntrl
  Let cr_CHNL[2]=ch_cust    !cust
  let cr_CHNL[3]=0  !saract
  Let cr_CHNL[4]=CH_CREDCK !credck
  E=0;Scratch$=""
  Call "credck.dl4",cr_CHNL[],H0[4],H0[1],ORDAMT,H0[7],CCSTATUS,CCTEXT$,E,Scratch$,ss
End If 
If CCSTATUS If P61$[57,57] = "Y" ! over credit limit
  If PASSWORD$[1,1] > " "
    T9[0] = 1
  End If 
End If 
Gosub CHECK_GP_HOLD
Gosub PACK_HOLD
Mat Write #CH_ROT,H0[3],0;T1
Mat Write #CH_ROT,H0[3],8;T2
Mat Write #CH_ROT,H0[3],168;MCODE
Mat Write #CH_ROT,H0[3],208;MCHARGE
Mat Write #CH_ROT,H0[3],328;TOT
Mat Write #CH_ROT,H0[3],358;MCTXBL
Mat Write #CH_ROT,H0[3],378;DCLVL;
Mat Write #CH_ROH,H1,52;H3
Mat Write #CH_ROH,H1,444;HMAT$
Mat Write #CH_ROH,H1,482;H2;
Mat Write #CH_ROH,H1,512;OREF;
mat WRITE #ch_roh,H1,624;ohcurrid;
mat WRITE #ch_roh,H1,626;ohcurrfact; ! 
Return 

!------------------------------------------------------------

WRITE_CREDCK: Rem write to credchk file if skipping credck call
K5$ = " ",K5$
K5$ = H0[1] Using "######"
Search #CH_CUST,2,1;K5$,K5,E
If E Gosub ERR_SEARCH
Mat Read #CH_CUST,K5;A1$;
Mat Read #CH_CUST,K5,142;C1;
If C1[3] = 0 Return 
Read #CH_CNTRL,0,112;X2;
Gosub YMD2JUL \ X2 = 0
CCHK[0] = C1[3];CCHK[1] = C1[0];CCHK[2] = C1[1]
CCHK[3] = X2;CCHK[4] = 0;CCHK[5] = Spc(6)
CCHK1$ = A1$[31,60];CCTEXT$ = "B/O PROCESSING"
E = 2 \ Search #CH_CREDCK,1,0;K5$,K5,E
If E Gosub ERR_SEARCH
K5$ = " ",K5$
K5$[1,6] = CCHK[2] Using "######"
K5$[7,12] = CCHK[3] Using "######"
K5$[13] = K5 Using "######"
Search #CH_CREDCK,4,1;K5$,K5,E
If E Gosub ERR_SEARCH
Mat Write #CH_CREDCK,K5;CCHK;
Mat Write #CH_CREDCK,K5,24;CCHK1$;
Mat Write #CH_CREDCK,K5,54;CCTEXT$[1,15];
Write #CH_CREDCK,K5,70;H0[7];
Write #CH_CREDCK,K5,74;ORDAMT;
Return 

!--------------------------------------------------------------

UNPACK_HOLD: Rem REM UNPACK T2[21] TO T9[x]
X2 = T2[21] \ For K = 0 To 11
  T9[K] = Sgn(Fra(X2 / 2)) \ X2 = Int(X2 / 2)
Next K
Return 
PACK_HOLD: Rem REM PACK CHAIN TYPE FROM T9[]
X2 = 0 \ For K = 0 To 11
  If T9[K] Let X2 = X2 + 2 ^ K
Next K
T2[21] = X2
Return 

!--------------------------------------------------------------

WRITE_ROL: Rem WRITE LINE REC.
	!If F7 = 0 Let LPRINTED = 0;LP_DATE = 0;LP_TIME = 0
	!L7[11] = 0;OWHS = 0
	Mat Write #CH_ROL,L1,0;L2;
	Mat Write #CH_ROL,L1,8;L3;
	Mat Write #CH_ROL,L1,16;L4;
	B[21] = L5[1]
	Mat Write #CH_ROL,L1,32;L5;
	Mat Write #CH_ROL,L1,56;L6;
	Mat Write #CH_ROL,L1,80;L1$;
	Mat Write #CH_ROL,L1,140;L2$;
	Mat Write #CH_ROL,L1,160;L9;
	Mat Write #CH_ROL,L1,168;L7;
	Mat Write #CH_ROL,L1,246;PL;
	Mat Write #CH_ROL,L1,250;UN;
	Mat Write #CH_ROL,L1,256;OLS2;
	Mat Write #CH_ROL,L1,260;S3;
	Mat Write #CH_ROL,L1,368;MT$;
	Mat Write #CH_ROL,L1,370;S3$;
	Mat Write #CH_ROL,L1,404;OLM;	
	Mat Write #CH_ROL,L1,446;EUN;
	Mat Write #CH_ROL,L1,452;UNF;
	Mat Write #CH_ROL,L1,494;LCO;
	Mat Write #CH_ROL,L1,502;CST;	
	Mat Write #CH_ROL,L1,508;LTAX1;
	Mat Write #CH_ROL,L1,514;CTWT;
	Mat Write #CH_ROL,L1,538;LTAX2;
	Write #CH_ROL,L1,548;OWHS;
	Write #CH_ROL,L1,550;LPRINTED;
	Write #CH_ROL,L1,552;LP_DATE;
	Write #CH_ROL,L1,556;LP_TIME;
	POR.SordLineNum=L3[2]
	mat write #ch_rol,l1,624;olcurrid;
	mat write #ch_rol,l1,626;olcurrfact;
Return 

!--------------------------------------------------------------

DO_DISCOUNT: Rem
If H6[7] = 0 Let T2[3] = 0
If H6[7] Let T2[3] = FNR(T2[1] * H6[7] * .01)
If H5[7] = 6 Or H5[7] = 10 Let T2[3] = T2[1]
Return 

!--------------------------------------------------------------

DO_TAXES: Rem
TAXABLE = T2[8] \ TTAX = 0
For SCR = 0 To 9
  If MCTXBL[SCR]
    TAXABLE = TAXABLE + MCHARGE[SCR,0]
    TTAX = TTAX + MCHARGE[SCR,0]
  End If 
Next SCR
If DTAX Let TAXABLE = TAXABLE - T2[3] \ TTAX = TTAX - T2[3]
If HTAX Let TAXABLE = TAXABLE + T2[6] \ TTAX = TTAX + T2[6]
If FTAX And T2[8]
  TAXABLE = TAXABLE + T2[5] + H6[6] \ TTAX = TTAX + T2[5] + H6[6]
End If 
If T2[1] > 0 If TAXABLE < 0 Let TAXABLE = 0
T2[11] = TAXABLE
If P60$[42,42] <> "Y"
  T2[7] = 0
  T2[7] = FNR(TAXABLE * (T2[2] / 100))
  If RTYPE$ = "U" Let T2[7] = FNV(TAXABLE * (T2[2] / 100))
End If 
If P60$[42,42] = "Y"
  TOT[3] = FNR(TTAX * (T2[2] / 100))
  If RTYPE$ = "U" Let TOT[3] = FNV(TTAX * (T2[2] / 100))
  T2[7] = LINETAX + TOT[3]
End If 
Return 

!--------------------------------------------------------------

SHIPHIST: Rem  "======================================= shipment history
	Mat Read #1,60,6;FLG$;
	If FLG$[1,1] = "N" Return 
	K5$ = " ",K5$;K5$[1,6] = H0[4] Using "######";K5$[7,12] = OREF[2] Using "######"
	K5$[13,15] = L3[2] Using "###";K5$[16,21] = "000000"
	E = 2
	Search #CH_SHIPHIST,1,0;K5$,R1[9],E
	If E Gosub ERR_SEARCH
	K5$[22,28] = R1[9] Using "###### "
	Search #CH_SHIPHIST,4,1;K5$,R1[9],E
	If E Gosub ERR_SEARCH
	Gosub READ_PROD
	CNVTU[0] = 0;CNVTU[1] = UN[0];CNVTU[2] = 1;CNVTA = B0[6]
	Gosub CONVERT \ DB0[6] = AMOUNT
	S$ = " ",S$ \ For X = 0 To 20 \ S7[X] = 0 \ Next X
	If UN[0] > 0 Mat Read #CH_CCODES,UN[0],10;SUNIT$;
	If UN[1] > 0 Mat Read #CH_CCODES,UN[1],10;PUNIT$;
	If UN[0] = -1 Let SUNIT$ = "CWT "
	If UN[0] = -2 Let SUNIT$ = "LOT "
	If UN[0] = -3 Let SUNIT$ = "LB  "
	If UN[1] = -1 Let PUNIT$ = "CWT "
	If UN[1] = -2 Let PUNIT$ = "LOT "
	If UN[1] = -3 Let PUNIT$ = "LB  "
	S$[1,10] = P0$;S$[11,14] = SUNIT$[1,4];S$[15,18] = PUNIT$[1,4]
	CNVTU[0] = 0;CNVTU[1] = UN[0];CNVTU[2] = 1;CNVTA = L7[3]
	Gosub CONVERT \ DB0 = AMOUNT
	S7[0] = H0[7];S7[1] = OREF[2];S7[2] = 0;S7[3] = L3[2];S7[4] = DB0[6]
	S7[5] = 0;S7[6] = 0;S7[7] = OLM[3];S7[8] = L5[0];S7[9] = H0[9]
	S7[10] = 0 \ S7[11] = 0
	S7[12] = H0[4] \ S7[13] = L4[0] \ S7[14] = L3[0]
	S7[15] = DB0
	Mat Write #CH_SHIPHIST,R1[9],0;S$;
	Mat Write #CH_SHIPHIST,R1[9],30;S7;
Return 

!--------------------------------------------------------------

FLAG_LINE_DEL: Rem "====================================== FLAG LINE DELETED
Mat Read #1,60,6;FLG$;
If FLG$[1,1] <> "Y" Return 
Read #1,3,172;D8;
K6$ = " ",K6$;K6$[1,6] = H0[4] Using "######";K6$[7,12] = OREF[2] Using "######"
K6$[13,15] = L3[2] Using "###" \ K6$[16,21] = "000000"
Search #CH_SHIPHIST,3,1;K6$,R1[9],E
If E Return 
X2 = K6$[7,12]
If OREF[2] If X2 <> OREF[2] Return 
If Not(OREF[2]) If X2 <> H0[7] Return 
X2 = K6$[12,14]
If X2 <> L3[2] Return 
X2 = K6$[15,20]
If X2 Return 
Mat Read #CH_SHIPHIST,R1[9],30;S7;
S7[10] = 264 \ S7[11] = D8
Mat Write #CH_SHIPHIST,R1[9],30;S7;
Return 

!--------------------------------------------------------------

CLEAR_BOWORK: Rem "=================================== clear BOWORKx
K1$ = " ",K1$
CLEARBO_LOOP1: Rem
Search #CH_BOWORK,3,2;K1$,R6,E
If Not(E)
  Search #CH_BOWORK,5,2;K1$,R6,E
  If E Gosub ERR_SEARCH
  Goto CLEARBO_LOOP1
End If 
K1$ = " ",K1$
CLEARBO_LOOP2: Rem
Search #CH_BOWORK,3,1;K1$,R6,E \ If E > 2 Gosub ERR_SEARCH
If Not(E)
  Search #CH_BOWORK,5,1;K1$,R6,E
  If E Gosub ERR_SEARCH
  OLR2 = K1$[27,32]
  Mat Read #CH_ROL,OLR2,168;L7
  L7[11] = 0
  Mat Write #CH_ROL,OLR2,168;L7;
  E = 3
  Search #CH_BOWORK,1,0;K1$,R6,E
  If E Gosub ERR_SEARCH
  Goto CLEARBO_LOOP2
End If 
Return 

!--------------------------------------------------------------

BUILD_ROH: Rem BUILD NEW ORDER
Read #1,20,62;N1
N1 = N1 + 1 
If N1>999998 ! let N1=800000  ! BETTER THAN STARRING OUT!?
	LET RETURNSTATUS=1 
	LET MESSAGE$="Order Number have exceeded 999999"
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
	End
Endif
Write #1,20,62;N1;
E = 2
Search #CH_ROH,1,0;K3$,R3,E \ If E Gosub ERR_SEARCH
let newrec=r3
K3$ = " ",K3$;K3$[1,2] = 90 Using "##";K3$[3] = N1 Using "######"
Search #CH_ROH,4,1;K3$,R3,E \ If E Gosub ERR_SEARCH
K3$ = " ",K3$;K3$[1,6] = H0[4] Using "######";K3$[7] = N1 Using "######"
Search #CH_ROH,4,2;K3$,R3,E \ If E Gosub ERR_SEARCH
K3$ = " ",K3$;K3$[1,3] = H0[11] Using "###";K3$[4] = N1 Using "###### "
Search #CH_ROH,4,3;K3$,R3,E \ If E Gosub ERR_SEARCH
E = 2 \ Search #CH_ROT,1,0;K3$,R8,E \ If E Gosub ERR_SEARCH
E = 2 \ Search #CH_ROS,1,0;K3$,R7,E \ If E Gosub ERR_SEARCH
H1 = B0[9] \ Gosub READ_ROH
H0[5] = H0[5] + 1
Mat Write #CH_ROH,H1;H0;
For X = 0 To 12 \ OOH0[X] = H0[X] \ Next X
For X = 0 To 5 \ O_OREF[X] = OREF[X] \ Next X
O2 = H0[7]
LOCKPORT = UIDRec !  Spc(6) ! user id rec or port?
H0[0] = 90 ! status 90?
H0[5] = 0
H6[2] = S2
H0[2] = R7
H0[3] = R8
H0[7] = N1
OREF[1] = 0;OREF[4] = 0;OREF[5] = 0
H5[15] = Tim(8) \ If H5[15] > 100 Let H5[15] = H5[15] - 100
H5[15] = H5[15] * 10000 + (Tim(9) * 100) + Tim(10)
H5[16] = Tim(11) + (Tim(12) / 100)
HFAX[0] = 0;HFAX[1] = 0
If H5[7] = 16 And P61$[54,54] = "N" ! "make sure authorized - else previous
  OWHT[0] = 1;OWHT[1] = -1;OWHT1 = H5[15]
End If 
Gosub GET_ZONE
If Not(OREF[2]) Let OREF[2] = OOH0[7]
H1 = R3 \ Gosub WRITE_ROH
Gosub MESSAGES
F8 = 1 \ Gosub BUILD_BOCONVX
ORDERCNTR=ORDERCNTR+1
Return 

!---------------------------------------------------------

WRITE_ROLTAG: Rem"cct#217031
K31$ = " ",K31$
K31$[1,6] = OOH0[7] Using "######"
K31$[7,9] = L3[2] Using "###"
Search #CH_ROLTAG,2,1;K31$,R31,E
If Not(E)
  Mat Read #CH_ROLTAG,R31,0;TL2;
  Read #CH_ROLTAG,R31,12;LINENUM;
  Read #CH_ROLTAG,R31,14;LPONUM$;
  Read #CH_ROLTAG,R31,44;LJOBNUM$;
  Read #CH_ROLTAG,R31,74;PSNUM$;
  Read #CH_ROLTAG,R31,104;MSG1$;
  Read #CH_ROLTAG,R31,134;MSG2$;
  mat read #ch_roltag,R31,164;msgs$;
  E = 2
  Search #CH_ROLTAG,1,0;K31$,R31,E
  If E Gosub ERR_SEARCH
  K31$ = " ",K31$
  K31$ = L2[1] Using "######"
  K31$[7] = L3[2] Using "### "
  Search #CH_ROLTAG,4,1;K31$,R31,E \ If E Gosub ERR_SEARCH
  Mat Write #CH_ROLTAG,R31,0;TL2;
  Write #CH_ROLTAG,R31,12;LINENUM;
  Write #CH_ROLTAG,R31,14;LPONUM$;
  Write #CH_ROLTAG,R31,44;LJOBNUM$;
  Write #CH_ROLTAG,R31,74;PSNUM$;
  Write #CH_ROLTAG,R31,104;MSG1$;
  Write #CH_ROLTAG,R31,134;MSG2$;
  mat write #ch_roltag,R31,164;msgs$;
  WRITE #CH_ROLTAG,R31,998;B$[1,1]; ! BLANK FOR KEY!
End If 
Return 

!-------------------------------------------------

WRITE_MSGLINE: Rem write the z line to the new order#
K11$ = " ",K11$
K11$[1,6] = OOH0[7] Using "######"
K11$[7,9] = OOL3 Using "###"
MSG_LOOP: Rem
Search #CH_ROL,3,1;K11$,R11,E
If E > 2 Gosub ERR_SEARCH
If E Goto END_MSGLOOP
ORDNUM = K11$[1,6]
If ORDNUM <> OOH0[7] Goto END_MSGLOOP
L1 = R11
Gosub READ_ROL
If Not(L3[0]) Goto END_MSGLOOP
If OLS2[0] <> 3 Goto END_MSGLOOP
If L3[0] If OLS2[0] = 3
!!  WAS L7[4] = B0[6] - CHANGED BECAUSE MESSAGE LINES DO NOT HAVE QTY SHIP
 L7[2] = 0;L7[3] = 0;L7[4] = 0;L7[0] = 0;L7[1] = 0
  L7[10] = 0
  L7[11] = 0
  L7[12] = 0
  L2[1] = N1
  E = 2
  Search #CH_ROL,1,0;K3$,R2,E
  If E Gosub ERR_SEARCH
  K3$ = " ",K3$
  K3$ = L2[1] Using "######"
  K3$[7] = L3[2] Using "### "
  Search #CH_ROL,4,1;K3$,R2,E \ If E Gosub ERR_SEARCH
  L1 = R2
  LPRINTED = 0;LP_DATE = 0;LP_TIME = 0
  L7[11] = 0;OWHS = 0
  Gosub WRITE_ROL
  K3$ = " ",K3$
  K3$[1,6] = OOH0[7] Using "######"
  K3$[7] = L3[2] Using "### "
  Search #CH_ROL,5,1;K3$,R1,E \ If E Gosub ERR_SEARCH
  E = 3
  Search #CH_ROL,1,0;K3$,R1,E \ If E Gosub ERR_SEARCH
End If 
Goto MSG_LOOP
END_MSGLOOP: Rem
Return 

!--------------------------------------------------------------

WRITE_NEWORDERLINE: Rem WRITE TO NEW ORDER #
F8 = 2
Gosub BUILD_BOCONVX
For X = 0 To 12 \ O7[X] = L7[X] \ Next X
OOQO = L7[2]
OOQBO = L7[3] - POR.QtyRecv  !
if ooqbo<0 then ooqbo=0  !! original order back orders should not go negative is PO receives more than the sales order bo
OOQSHIP = L7[4]
O7[12] = POR.QtyRecv	! current release qty
B0[6]=POR.QtyRecv
!-----------------------------------------------------------
!	UPDATE ORIGINAL ORDER BO QTY
L7[3]=OOQBO
L1=R11
LPRINTED = 0;LP_DATE = 0;LP_TIME = 0
L7[11] = 0;OWHS = 0
gosub Write_ROL
!-----------------------------------------------------------
! L7[2] = B0[6];L7[3] = 0;L7[4] = B0[6];L7[0] = 0;L7[1] = 0
L7[3] = 0;L7[4] = B0[6];L7[0] = 0;L7[1] = 0

L7[10] = 0
L7[11] = 0
L7[12] = 0
L2[1] = N1
! update sales order load cost section
if ot2[12]<>1 goto endloadcstupd:
if l3[0]<>0 goto endloadcstupd: ! not a stock item
if lco=11 goto endloadcstupd: !11 - special salesman cost
if lco=10 goto endloadcstupd: ! !10 - rebate salesman cost 
if l4[0]<=0 goto endloadcstupd: ! 
! read the product file
REC_PROD = L4[0]
gosub read_prod1:   
let ld1=0 ! that is the new load cost
ORGLOADCOST=0
NEWLOADCOST=0
If P9$[32,32] = "Y" ! warehouse pricing
	let ch_prwh=CH_PRODWHSE
	! get prodwhse file
	let whlm[0]=0;w3[17]=0
	Key_prwh$ = " ",Key_prwh$
	Key_prwh$[1,12] =L2$[1,12]
	Key_prwh$[13,14] = H4[2] Using "##"
	Search #CH_PRWH,2,1;Key_prwh$,REC_PRWH,E \ If E goto outend:
	If Not(E)
		gosub read_prwh:
	else
		goto endwhload:
	endif
	if whlm[0]=0 ! no table use warehouse load cost
       	LD1 = W3[17]
		if LD1<=0 goto endwhload:
		GOTO ENDLOADCOST:
	endif
	WH = H4[2];LTBL = WHLM[0]
    Gosub CALC_LOAD
    LD1 = CNVTA
	if ld1>0 goto endloadcost: 
End If 
endwhload: ! end warehouse load costing
! check the product load table
If LM[0]
       WH = 0;LTBL = LM[0]
       Gosub CALC_LOAD
       LD1 = CNVTA 
Else 
      	LD1 = B[8]
End If ! find load table
endloadcost: ! end finding load cost
if ld1>0 and ld1<>l5[1]
	let OrgLoadCost=l5[1]
	let NewLoadCost=ld1 ! get load cost		
	let l5[1]=ld1
	! recalc will update the lines
	!If Not(UNF[5]) Let UNF[5] = 1
	!NETCOST = L5[1] + CHBASE
	!S3[13] = FNR(OL7[2] * NETCOST)
	!If H5[7] = 4 Or H5[7] = 15 ! "bill and hold
	!	S3[12] = FNR(S3[7] * NETCOST)
	!Else 
	!	S3[12] = FNR(L7[4] * NETCOST)
	!End If 
	!If UN[2] = -2 Let S3[12] = FNR(NETCOST * Sgn(L7[4]));S3[13] = FNR(NETCOST * Sgn(L7[2]))
endif
endloadcstupd: ! 

E = 2
Search #CH_ROL,1,0;K3$,R2,E
If E Gosub ERR_SEARCH
K3$ = " ",K3$
K3$ = L2[1] Using "######"
K3$[7] = L3[2] Using "### "
Search #CH_ROL,4,1;K3$,R2,E \ If E Gosub ERR_SEARCH
!! DO NOT INSERT 2ND DIR FOR NON-STOCKS
IF L3[0]=0
    K3$ = " ",K3$
    K3$ = L4[0] Using "######"
    K3$[7,12] = L2[1] Using "######"
    K3$[13] = L3[2] Using "### "
    Search #CH_ROL,4,2;K3$,R2,E \ If E Gosub ERR_SEARCH
endif
Let LPRINTED = 0;LP_DATE = 0;LP_TIME = 0
L7[11] = 0;OWHS = 0
L1 = R2
Gosub WRITE_ROL
IF P61$[132,132]="Y" AND NSFMCODE<>0 AND L3[0]<>0
	let nsfrt1[0]=0
	K3$ = " ",K3$
	K3$[1,6] = OOH0[7] Using "######"
	K3$[7,9] = L3[2] Using "###"
	Search #CH_SPRODDESC,2,1;K3$,R4,E
	If not(e) 
		mat read #CH_SPRODDESC,r4,190;nsfrt1;
	endif
	if nsfrt1[0]<>0 
		let nsfrtflag=99
	endif
endif

If ROLTAGFLAG Gosub WRITE_ROLTAG
!----------------------------------------------
If P9$[41,41] = "W" 
	!Call "CHKWRASL",WHSE,RASL[] ! OLD
	WHI=0 ! no whse info file open
	RASL=0
	IF L4[3]<>0 LET WHSE= L4[3]
	Call ChkWhRasl(e$,intco,CH_CNTRL,WHI,Whse,RASL[])
Endif
!----------------------------------------------
!If RASL
!  Gosub UPDATE_SPRODLOT
!  S9[2] = R3;S9[4] = 0;S9[5] = 0
!  CHOPEN[0] = CH_CNTRL;CHOPEN[1] = CH_PROD;CHOPEN[2] = CH_ROH
!  CHOPEN[3] = CH_ROL;CHOPEN[4] = 0;CH_OPEN[5] = CH_CCODES
!  CHOPEN[6] = CH_SPRODLOT;CHOPEN[7] = 0;CHOPEN[8] = CH_SORDLOT
!  CHOPEN[9] = 0
!End If 
IF NOT(L3[0]) AND L3[1]<>0 ! PRODUCT
	GOSUB UPDATE_SPRODLOT:
	Gosub SORDLOT
ENDIF
Gosub WRITE_NEW_TO_EDITTRACK
IF L3[0]<>0
	Gosub SPRODDESC
ENDIF
If OOQBO = 0 And OOQSHIP = 0
  ! If (O7[0] + B0[6] + (O7[12] - B0[6])) <> OOQO Return 
  Gosub FLAG_LINE_DEL
  K3$ = " ",K3$
  K3$[1,6] = OOH0[7] Using "######"
  K3$[7] = L3[2] Using "### "
  Search #CH_ROL,5,1;K3$,R1,E \ If E Gosub ERR_SEARCH
  if l3[0]=0 ! not on non-stocks!
	  K3$ = " ",K3$
	  K3$ = L4[0] Using "######"
	  K3$[7,12] = OOH0[7] Using "######"
	  K3$[13] = L3[2] Using "###" ! SEARCH WITHOUT SPACE
	  Search #CH_ROL,2,2;K3$,R,E \ if e gosub err_search
	  Search #CH_ROL,5,2;K3$,R1,E \ If E Gosub ERR_SEARCH
  endif
  E = 3
  Search #CH_ROL,1,0;K3$,R1,E \ If E Gosub ERR_SEARCH
  If ROLTAGFLAG
    K31$ = " ",K31$
    K31$[1,6] = OOH0[7] Using "######"
    K31$[7] = L3[2] Using "### "
    Search #CH_ROLTAG,2,1;K31$,R31,E
    If Not(E)
      TL2[0] = 0 \ TL2[1] = 0
      LINENUM = 0
      LPONUM$ = " ",LPONUM$
      LJOBNUM$ = " ",LJOBNUM$
      PSNUM$ = " ",PSNUM$
      MSG1$ = " ",MSG1$
      MSG2$ = " ",MSG2$
	  msgs$=" ",msgs$
      Mat Write #CH_ROLTAG,R31,0;TL2;
      Write #CH_ROLTAG,R31,12;LINENUM;
      Write #CH_ROLTAG,R31,14;LPONUM$;
      Write #CH_ROLTAG,R31,44;LJOBNUM$;
      Write #CH_ROLTAG,R31,74;PSNUM$;
      Write #CH_ROLTAG,R31,104;MSG1$;
      Write #CH_ROLTAG,R31,134;MSG2$;
	  mat write #ch_roltag,R31,164;msgs$;
      Search #CH_ROLTAG,5,1;K31$,R31,E
      If E Gosub ERR_SEARCH
      E = 3
      Search #CH_ROLTAG,1,0;K31$,R31,E
      If E Gosub ERR_SEARCH
    End If 
  End If !"roltagflag
  Gosub DELSORDLOT
  Gosub WRITE_DEL_TO_EDITTRACK
  ! HERE TO RE-TOTAL LINE
Else 
  Gosub WRITE_OLD_TO_EDITTRACK
  ! HERE TO RE-TOTAL LINE
End If 
Gosub WRITE_ROL
Return 

!--------------------------------------------------------------

DELSORDLOT: Rem MAKE SURE SORDLOT IS DELETED IF LINE IS DELETED
Rem THIS SHOULD NOT BE NEEDED, BUT SOMEHOW SOME ARE GETTING THRU- WANT TO
K13$ = " ",K13$
K133$ = " ",K133$
K1333$ = " ",K1333$
K13$[1,6] = OOH0[7] Using "######"
K13$[7,9] = L3[2] Using "###"
!! K13$[10,11] = L4[3] Using "##"
K1333$ = K13$
DELSORDLOT2: Search #CH_SORDLOT,3,3;K13$,R13,E
If E = 2 Return 
If E Gosub ERR_SEARCH
If K13$[1,9] <> K1333$[1,9] Return 
Rem PRINT "DELETING SORDLOT(GARBAGE COLLECTION):";K13$
Mat Read #CH_SORDLOT,R13,0;S0$;
K133$ = " ",K133$
K133$[1,12] = S0$[1,12]
K133$[13,52] = K13$[1,40]
Search #CH_SORDLOT,5,1;K133$,R133,E
If E Gosub ERR_SEARCH
If R13 <> R133 Gosub ERR_SEARCH ! Print 'RB';"RECORD NUMBER MISMATCH!!" \ Gosub ERR_SEARCH
K133$ = " ",K133$
K133$[1,22] = K13$[18,39]
K133$[23,39] = K13$[1,17]
K133$[40,51] = S0$[1,12]
K133$[52,52] = K13$[40,40]
Search #CH_SORDLOT,5,2;K133$,R133,E
If E Gosub ERR_SEARCH
If R13 <> R133 Gosub ERR_SEARCH ! Print 'RB';"RECORD NUMBER MISMATCH!!" \ Gosub ERR_SEARCH
Search #CH_SORDLOT,5,3;K13$,R133,E
If E Gosub ERR_SEARCH
E = 3
Search #CH_SORDLOT,1,0;K13$,R133,E
If E Gosub ERR_SEARCH
Goto DELSORDLOT2
Return 

!--------------------------------------------------------------

SORDLOT: Rem SORDLOT adjust/remove old, create new
K3$ = " ",K3$
K3$[1,12] = L2$[1,12]
K3$[13,18] = OOH0[7] Using "######"
K3$[19,21] = L3[2] Using "###"
K3$[22,23] = WHSE Using "##"
K3$[24,29] = LOC$[1,6]
SORDLOT2: Rem
Search #CH_SORDLOT,3,1;K3$,R4,E
If E > 2 Gosub ERR_SEARCH
If E = 2 Return 
X2 = K3$[13,18]
X4 = K3$[19,21]
If X2 <> OOH0[7] Return 
If X4 <> L3[2] Return 
If Not(E) And X2 = OOH0[7] And X4 = L3[2] And K3$[24,29] = LOC$[1,6]
  Mat Read #CH_SORDLOT,R4,0;S0$;
  Mat Read #CH_SORDLOT,R4,36;A1;
  Mat Read #CH_SORDLOT,R4,44;A2;
  Mat Read #CH_SORDLOT,R4,60;A3;
  Mat Read #CH_SORDLOT,R4,96;OL2$;
  A3[0] = OOQBO + (A3[1] - L7[4])
  A3[1] = A3[1] - L7[4]
  Mat Write #CH_SORDLOT,R4,60;A3;
  If Not(O7[3]) And (A3[0] + A3[1] + A3[3] + A3[4] + A3[5] = 0) Gosub DELOLDSORD
  K4$ = K3$
  R7 = R4
  E = 2
  Search #CH_SORDLOT,1,0;K3$,R7,E
  If E Gosub ERR_SEARCH
  A2[0] = H0[7];A3[0] = L7[2];A3[3] = 0;A3[1] = L7[4]
  OL2$[11,16] = LOC$[1,6]
  If RASL Let OL2$[11,16] = RASL_LOC$[1,6]
  Mat Write #CH_SORDLOT,R7,0;S0$;
  Mat Write #CH_SORDLOT,R7,36;A1;
  Mat Write #CH_SORDLOT,R7,44;A2;
  Mat Write #CH_SORDLOT,R7,60;A3;
  Mat Write #CH_SORDLOT,R7,96;OL2$;
  K4$[13,18] = H0[7] Using "######"
  If RASL Let K4$[24,29] = RASL_LOC$[1,6]
  Search #CH_SORDLOT,4,1;K4$,R7,E
  If E Gosub ERR_SEARCH
  K4$ = " ",K4$
  K4$[1,12] = S0$[13,24]
  K4$[23,28] = H0[7] Using "######"
  K4$[29,31] = L3[2] Using "###"
  K4$[32,33] = A1[2] Using "##"
  K4$[34,39] = LOC$[1,6]
  K4$[40,51] = L2$[1,12]
  If RASL Let K4$[34,39] = RASL_LOC$[1,6]
  Search #CH_SORDLOT,4,2;K4$,R7,E
  If E Gosub ERR_SEARCH
  K4$ = " ",K4$
  K4$[1,6] = H0[7] Using "######"
  K4$[7,9] = L3[2] Using "###"
  K4$[10,11] = A1[2] Using "##"
  K4$[12,17] = LOC$[1,6]
  K4$[18,29] = S0$[13,24]
  If RASL Let K4$[12,17] = RASL_LOC$[1,6]
  Search #CH_SORDLOT,4,3;K4$,R7,E
  If E Gosub ERR_SEARCH
End If 
Goto SORDLOT2
Return 

!--------------------------------------------------------------

DELOLDSORD: Rem to delete sordlot records with 0 amounts
K4$ = " ",K4$
K4$[1,12] = L2$[1,12]
K4$[13,18] = OOH0[7] Using "######"
K4$[19,21] = L3[2] Using "###"
K4$[22,23] = WHSE Using "##"
K4$[24,29] = LOC$[1,6]
K4$[30,41] = S0$[13,24]
K4$[42,51] = OL2$[1,10]
Search #CH_SORDLOT,5,1;K4$,R4,E
If E Gosub ERR_SEARCH
K4$ = " ",K4$
K4$[1,12] = S0$[13,24]
K4$[13,22] = OL2$[1,10]
K4$[23,28] = OOH0[7] Using "######"
K4$[29,31] = L3[2] Using "###"
K4$[32,33] = A1[2] Using "##"
K4$[34,39] = LOC$[1,6]
K4$[40,51] = L2$[1,12]
Search #CH_SORDLOT,5,2;K4$,R4,E
If E Gosub ERR_SEARCH
K4$ = " ",K4$
K4$[1,6] = OOH0[7] Using "######"
K4$[7,9] = L3[2] Using "###"
K4$[10,11] = A1[2] Using "##"
K4$[12,17] = LOC$[1,6]
K4$[18,29] = S0$[13,24]
K4$[30,39] = OL2$[1,10]
Search #CH_SORDLOT,5,3;K4$,R4,E
If E Gosub ERR_SEARCH
E = 3
Search #CH_SORDLOT,1,0;K4$,R4,E
If E Gosub ERR_SEARCH
Return 

!--------------------------------------------------------------

UPDATE_SPRODLOT: Rem UPDATE SPROD LOT original order - backout allocation
SCRATCH$ = " ",SCRATCH$
SCRATCH$[1,12] = L2$[1,12]
SCRATCH$[13,14] = WHSE Using "##"
SCRATCH$[15,20] = LOC$[1,6]
UPD_SPRD_LOOP: Rem
Search #CH_SPRODLOT,3,2;SCRATCH$,SCR,E \ If E > 2 Gosub ERR_SEARCH
If Not(E) And SCRATCH$[1,12] = L2$[1,12] And Val(SCRATCH$[13,14]) = WHSE And SCRATCH$[15,20] = LOC$[1,6]
  Mat Read #CH_SPRODLOT,SCR,66;P1
  Mat Read #CH_SPRODLOT,SCR,82;P3
  If P1[0] <> WHSE Goto UPD_SPRD_LOOP
  P3[3] = P3[3] - B0[6]
  Mat Write #CH_SPRODLOT,SCR,66;P1
  Mat Write #CH_SPRODLOT,SCR,82;P3;
  IF RASL<>0
	SCRATCH$[15,20] = RASL_LOC$
  ELSE
	SCRATCH$[15,20] = LOC$
  ENDIF
  Search #CH_SPRODLOT,2,2;SCRATCH$,SCR,E \ If E > 1 Gosub ERR_SEARCH
  If E
    E = 2 \ Search #CH_SPRODLOT,1,0;S_KEY$,SCR,E
    If E Gosub ERR_SEARCH
    S_KEY$ = SCRATCH$[21,32],SCRATCH$[33,42],SCRATCH$[13,14],SCRATCH$[15,20],SCRATCH$[1,12]
    Search #CH_SPRODLOT,4,1;S_KEY$,SCR,E \ If E Gosub ERR_SEARCH
    S_KEY$ = SCRATCH$
    Search #CH_SPRODLOT,4,2;S_KEY$,SCR,E \ If E Gosub ERR_SEARCH
    S_KEY$ = SCRATCH$[13,14],SCRATCH$[15,20],SCRATCH$[1,12],SCRATCH$[21,32],SCRATCH$[33,42]
    Search #CH_SPRODLOT,4,3;S_KEY$,SCR,E \ If E Gosub ERR_SEARCH
    S_KEY$ = SCRATCH$[1,12],SCRATCH$[13,14],SCRATCH$[21,32],SCRATCH$[33,42],SCRATCH$[15,20]
    Search #CH_SPRODLOT,4,4;S_KEY$,SCR,E \ If E Gosub ERR_SEARCH
    SL_P0$ = " ",SL_P0$
    SL_P0$[1,12] = SCRATCH$[1,12]
    SL_P0$[13,24] = SCRATCH$[21,32]
    SL_P0$[25,46] = "BACKORDER FILL - MX264"
    Write #CH_SPRODLOT,SCR;SL_P0$
    P1[0] = SCRATCH$[13,14] \ P1[1] = 3
    Mat Write #CH_SPRODLOT,SCR,66;P1
    P2[0] = SYS_DATE \ P2[1] = 0 \ P2[2] = 1
    Mat Write #CH_SPRODLOT,SCR,70;P2
    P3[0] = 0 \ P3[1] = 0 \ P3[2] = 0 \ P3[3] = B0[6] \ P3[4] = 0
    P4 = 1
    Mat Write #CH_SPRODLOT,SCR,82;P3
    Write #CH_SPRODLOT,SCR,112;P4
    Mat Write #CH_SPRODLOT,SCR,114;SCRATCH$[15,20]
    Write #CH_SPRODLOT,SCR,120;P3[1];
  Else 
    Mat Read #CH_SPRODLOT,SCR,82;P3
    P3[3] = P3[3] + B0[6]
    Mat Write #CH_SPRODLOT,SCR,82;P3;
  End If 
End If 
END_UPD_SPRD_LOOP: Rem
Return 

!--------------------------------------------------------------

SPRODDESC: Rem SPROD DESC
	let nsfrt1[0]=0
	K3$ = " ",K3$
	K3$[1,6] = OOH0[7] Using "######"
	K3$[7,9] = L3[2] Using "###"
	Search #CH_SPRODDESC,2,1;K3$,R4,E
	If E Return 
!! CHECK IF THE OLD RECORD WILL STILL BE NEEDED
        If OOQBO <> 0 OR OOQSHIP <> 0 GOTO SPRODDESC2

mat read #CH_SPRODDESC,r4,190;nsfrt1;
	Search #CH_SPRODDESC,5,1;K3$,R4,E
	If E Gosub ERR_SEARCH
	K3$[1,6] = H0[7] Using "######"
	Search #CH_SPRODDESC,4,1;K3$,R4,E
	If E Gosub ERR_SEARCH
	Write #CH_SPRODDESC,R4,0;H0[7];
        LET NSL7[2]=R2 !REC # OF NEW SORDFLEL RECORD
        Write #CH_SPRODDESC,R4,8;NSL7[2];
Return 

SPRODDESC2: !CREATE NEW RECORD & LEAVE OLD
        MAT READ #CH_SPRODDESC,R4,0;NSL7;
        MAT READ #CH_SPRODDESC,R4,12;NSL$;
        MAT READ #CH_SPRODDESC,R4,72;NSL8;
        MAT READ #CH_SPRODDESC,R4,102;NSL2$;
        MAT READ #CH_SPRODDESC,R4,120;HA3;
        MAT READ #CH_SPRODDESC,R4,132;HA1$;
        MAT READ #CH_SPRODDESC,R4,182;NSINVNO;
        mat read #CH_SPRODDESC,r4,190;nnsfrt1;
        MAT READ #CH_SPRODDESC,R4,208;NSUDA$;

        E = 2
        Search #CH_SPRODDESC,1,0;K3$,R44,E
        If E Gosub ERR_SEARCH

        LET NSL7[0]=H0[7] !NEW ORDER #
        LET NSL7[2]=R2 !REC # OF NEW SORDFLEL RECORD
        MAT WRITE #CH_SPRODDESC,R44,0;NSL7;
        MAT WRITE #CH_SPRODDESC,R44,12;NSL$;
        MAT WRITE #CH_SPRODDESC,R44,72;NSL8;
        MAT WRITE #CH_SPRODDESC,R44,102;NSL2$;
        MAT WRITE #CH_SPRODDESC,R44,120;HA3;
        MAT WRITE #CH_SPRODDESC,R44,132;HA1$;
        MAT WRITE #CH_SPRODDESC,R44,182;NSINVNO;
        mat WRITE #CH_SPRODDESC,r44,190;nnsfrt1;
        MAT WRITE #CH_SPRODDESC,R44,208;NSUDA$;
        K3$[1,6] = H0[7] Using "######"
	Search #CH_SPRODDESC,4,1;K3$,R44,E
	If E Gosub ERR_SEARCH
Return 

!--------------------------------------------------------------

MESSAGES: Rem MESSAGES
	K3$ = " ",K3$
	K3$ = OOH0[7] Using "######"
	L_6340: Search #CH_ROM,3,1;K3$,R4,E \ If E > 2 Gosub ERR_SEARCH
	If Not(E)
	  X2 = K3$[1,6] \ If X2 <> OOH0[7] Return 
	  Mat Read #CH_ROM,R4,0;M1$; \ Read #CH_ROM,R4,40;M1;
	  Mat Read #CH_ROM,R4,44;MH2;
	  Mat Read #CH_ROM,R4,50;MH2$;
	  MH2 = H0[7]
	  MH2$ = " ",MH2$
	  K4$ = " ",K4$
	  K4$ = K3$
	  K4$[1,6] = H0[7] Using "######"
	  E = 2
	  Search #CH_ROM,1,0;K4$,R0,E
	  If E Gosub ERR_SEARCH
	  Search #CH_ROM,4,1;K4$,R0,E
	  If E Gosub ERR_SEARCH
	  Mat Write #CH_ROM,R0,0;M1$;
	  Write #CH_ROM,R0,40;M1;
	  Mat Write #CH_ROM,R0,44;MH2;
	  Mat Write #CH_ROM,RO,50;MH2$;
	  Goto L_6340
	End If 
Return 

!--------------------------------------------------------------

BUILD_BOCONVX: Rem "================= build BOCONVx
	K4$ = " ",K4$
	B2$ = " ",B2$
	E = 2 \ Search #CH_BOCONV,1,0;K4$,R0,E \ If E Gosub ERR_SEARCH
	If F8 <> 2
	  K4$[1,6] = H0[4] Using "######"
	  K4$[7,13] = N1 Using "######H"
	  K4$[14,19] = R0 Using "######"
	  Search #CH_BOCONV,4,1;K4$,R0,E \ If E Gosub ERR_SEARCH
	  B2[0] = OOH0[7]
	  B2[1] = N1
	  B2[2] = H0[4]
	  B2[3] = OOH0[9]
	  B2[4] = D8
	  B3[0] = 0 \ B3[1] = 0 \ B3[2] = 0 \ B3[3] = 0
	Else 
	  K4$ = " ",K4$
	  K4$[1,6] = H0[4] Using "######"
	  K4$[7,13] = N1 Using "######L"
	  K4$[14,16] = L3[2] Using "###"
	  K4$[17,22] = R0 Using "######"
	  B2[0] = OOH0[7];B2[1] = N1;B2[2] = 0;B2[3] = 0;B2[4] = 0
	  B2[5] = L3[2]
	  B3[0] = L7[2]
	  If B0[8] Let B3[1] = B0[8] \ Goto L_6645
	  B3[1] = B0[6]
	L_6645: B3[2] = POR.QtyRecv  ! B0[6]
	  B2$[1,12] = L2$[1,12]
	  Search #CH_BOCONV,4,1;K4$,R0,E \ If E Gosub ERR_SEARCH
	End If 
	Mat Write #CH_BOCONV,R0,0;B2
	Mat Write #CH_BOCONV,R0,24;B3
	Mat Write #CH_BOCONV,R0,48;B2$;
Return 

!--------------------------------------------------------------

DEL_CHECK: Rem CHECK FOR ORDER DELETE
K4$ = " ",K4$
K4$ = OOH0[7] Using "######"
ZLINE = 0
DELCHECK_LOOP: Rem
Search #CH_ROL,3,1;K4$,R4,E \ If E > 2 Gosub ERR_SEARCH
If Not(E) And Val(K4$[1,6]) = OOH0[7]
  Mat Read #CH_ROL,R4,256;OLS2;
  If OLS2[0] = 3 ! check for z line
    ZLINE = 1
    Goto DELCHECK_LOOP
  End If 
Else 
  If ZLINE ! delete zlines
    K4$ = " ",K4$
    K4$ = OOH0[7] Using "######"
DELZLINE_LOOP: Rem
    Search #CH_ROL,3,1;K4$,R4,E \ If E > 2 Gosub ERR_SEARCH
    If Not(E) And Val(K4$[1,6]) = OOH0[7]
      Search #CH_ROL,5,1;K4$,R4,E \ If E Gosub ERR_SEARCH
      E = 3
      Search #CH_ROL,1,0;K4$,R4,E \ If E Gosub ERR_SEARCH
      Goto DELZLINE_LOOP
    End If 
  End If 
  S9[1] = R5
  S9[2] = B0[9]
  S9[3] = 0
  !Swap 1,"MX264A"
  Call "264a.dl4",E$,s9[],IntCo,rstr$,userid$
  K4$ = " ",K4$
  K4$[1,6] = H0[4] Using "######"
  K4$[7,12] = N1 Using "######"
  Search #CH_BOCONV,3,1;K4$,R0,E \ If E > 2 Gosub ERR_SEARCH
  If E Return 
  X2 = K4$[7,12] \ If X2 <> N1 Return 
  If K4$[13,13] <> "H" Return 
  Mat Read #CH_BOCONV,R0,24;B3
  B3[3] = 1
  Mat Write #CH_BOCONV,R0,24;B3;
End If 
Return 

!--------------------------------------------------------------

L_7700: Rem *DATE  X2 TO X$ V1.0
	X$ = " ",X$ \ X$[10] = ""
	X$[1,3] = Int(X2 / 10 ^ 2 - Int(X2 / 10 ^ 4) * 10 ^ 2) + 10 ^ 2 Using "###"
	X$[4,6] = Fra(X2 / 10 ^ 2) * 10 ^ 2 + 10 ^ 2 Using "###"
	X$[7,9] = Int(X2 / 10 ^ 4) + 10 ^ 2 Using "###"
	X$[4,4] = "/" \ X$[7,7] = "/" \ X$ = X$[2]
Return 

!--------------------------------------------------------------

WRITE_ROH: Rem WRITE HEADER REC. & SHIP-TO REC.
	h5[3]=1  ! commission lock 
	h2=POR.OrigSord
	POR.SordNum=H0[7]  ! new ord num
	Mat Write #CH_ROH,H1;H0
	Mat Write #CH_ROH,H1,52;H3
	Mat Write #CH_ROH,H1,56;TOT_SELL
	Mat Write #CH_ROH,H1,64;LOCKPORT
	Mat Write #CH_ROH,H1,446;P0$
	Mat Write #CH_ROH,H1,78;H4
	Mat Write #CH_ROH,H1,66;V0$
	Mat Write #CH_ROH,H1,172;HS3
	Mat Write #CH_ROH,H1,272;H1$
	Mat Write #CH_ROH,H1,408;H6
	Mat Write #CH_ROH,H1,84;H0$
	Mat Write #CH_ROH,H1,104;H5
	Mat Write #CH_ROH,H1,278;SLSM
	Mat Write #CH_ROH,H1,444;HMAT$
	Mat Write #CH_ROH,H1,466;HFAX
	Mat Write #CH_ROH,H1,482;H2;
	Mat Write #CH_ROH,H1,486;OWHT;
	Mat Write #CH_ROH,H1,490;OWHT1;
	mat WRITE #ch_roh,H1,624;ohcurrid;
	mat WRITE #ch_roh,H1,626;ohcurrfact; ! 
	PICKBY[0] = 0;PICKBY[1] = 0
	Mat Write #CH_ROH,H1,504;PICKBY;
	Mat Write #CH_ROH,H1,512;OREF;
	If Not(F7) ! new one
	  PICKFLAG$[1,1] = S1$[118,118]
	  S1$[118,118] = "1"
	End If 
	SRN[0] = 0
	S1[1] = H0[7]
	Mat Write #CH_ROS,H0[2],0;S1
	Mat Write #CH_ROS,H0[2],8;S1$
	Mat Write #CH_ROS,H0[2],126;S2$
	Mat Write #CH_ROS,H0[2],146;S5
	Mat Write #CH_ROS,H0[2],150;S6
	Mat Write #CH_ROS,H0[2],154;SRN;
	If Not(F7) Let S1$[118,118] = PICKFLAG$[1,1]
Return 

!-----------------------------------------------------------

GET_ZONE: Rem ZONE
If P61$[34,34] = "Y" Gosub CSMZONE
A$ = " ",A$
A$ = S2$[19,20]
Search #CH_ZONE,2,1;A$,V11,E
If E
  D0 = 0
Else 
  Read #CH_ZONE,V11,28;D0;
End If 
X2 = D8
If P61$[34,34] = "Y" Let VDATE = H0[10] \ Goto BYPDCALC
X$ = X2 Using "&&&&&&"
Call DateToJulian(1,X$,X$,E)
X2 = X$[1,5]
X2 = X2 + D0
DT3[0] = X2;DT3[1] = X2;FLAG = 0
Call "JULIANUTIL",DT3[],X$,FLAG
X2 = X$
H0[10] = X2;H5[1] = X2
VDATE = X2;STAT = 1;WARN = 0;PARAM[0] = WHSE;PARAM[1] = H5[8]
Call "validdate",VDATE,STAT,WARN,PARAM[] ! ok as is
BYPDCALC: Rem "bypass Calc
H0[10] = VDATE;H5[1] = VDATE
X2 = VDATE \ Gosub YMD2JUL \ X2 = 0
JWDATE = X2
If ORIG_JDUEDATE > JWDATE
  H0[10] = ORIG_DUEDATE
  H5[1] = ORIG_DUEDATE
  H0[9] = ORIG_ORDDATE
Else 
  H0[10] = VDATE
  H5[1] = VDATE
  H0[9] = VDATE
End If 
Return

!--------------------------------------------------------------

CSMZONE: Rem "Cust/Shipto MultiZone
If Not(SRN[2]) Let SRN[2] = H0[4]
X2 = H0[9];H0[9] = D8
CSZONE$ = S2$[19,20]
Call "MXOHCSZONE",SRN[2],SRN[1],H0[9],H5[8],H4[2],H0[10],CSZONE$,H4[1],IntCo ! not ok as is
R$[32,33] = CSZONE$
S2$[19,20] = R$[32,33]
H0[9] = X2
Return 

!--------------------------------------------------------------

GET_FREIGHT_CHG: Rem -------------------------from level on freight table
If H5[7] = 16 Or H5[7] = 14 Return 
If T2[16] = 0 Return 
If H5[7] = 2
  SCR = 174
Else 
  SCR = 173
End If 
Mat Read #1,SCR,0;MAXWGT;
Mat Read #1,SCR,48;DFLTCOST;
Mat Read #1,SCR,96;MINCOST;
Mat Read #1,SCR,144;MAXCOST;
Mat Read #1,SCR,192;DFLTCHG;
Mat Read #1,SCR,240;FTFLG;
WGT = T2[16]
For LEVEL = 0 To 6
  If WGT <= MAXWGT[LEVEL] Goto FOUND_LEVEL
Next LEVEL
If LEVEL > 6 Let LEVEL = 6
FOUND_LEVEL: Rem
If FTFLG = -1 ! cwt
  T2[5] = FNR(DFLTCHG[LEVEL] * (WGT / 100))
  T2[20] = FNR(DFLTCOST[LEVEL] * (WGT / 100))
Else !flat
  T2[5] = DFLTCHG[LEVEL]
  T2[20] = DFLTCOST[LEVEL]
End If 
If MINCOST[LEVEL] And T2[20] < MINCOST[LEVEL] Let T2[20] = MINCOST[LEVEL]
If MAXCOST[LEVEL] And T2[20] > MAXCOST[LEVEL] Let T2[20] = MAXCOST[LEVEL]
Return 

!--------------------------------------------------------------

CHECK_4DELIV_CHG: Rem ---------------------------------------------
If P61$[36,36] = "Y" Return 
If P61$[53,53] = "N" Return 
If H5[7] = 16 Return 
If DCLVL
  If H5[7] <> 2
    SCR = 172
  Else 
    SCR = 171
  End If 
  Mat Read #1,SCR,48;DCHRG;
  Mat Read #1,SCR,96;DCOST;
  Mat Read #1,SCR,240;DFLAG;
  PASS = 0
  For SCR = 0 To 9
    If Int(MCODE[SCR]) = 0 Or Int(MCODE[SCR]) = DFLAG[1]
      PASS = 1
      Goto END_CHECK_EXISTING_CHRG
    End If 
  Next SCR
END_CHECK_EXISTING_CHRG: Rem
  If PASS
    CHNL = findchannel() ! 99 \ Gosub GETCHAN
    CHMISC = CHNL
    Mat Read #1,88,2032;MISCFILE$;
    Open #CHMISC,MISCFILE$
    If Int(MCODE[SCR]) = DFLAG[1]
      T2[4] = T2[4] - MCHARGE[SCR,0]
      TOT[0] = TOT[0] - MCHARGE[SCR,1]
      If Fra(MCODE[SCR]) Let TOT[2] = TOT[2] - MCHARGE[SCR,1]
    End If 
    MCODE[SCR] = DFLAG[1] + .1
    If DFLAG[0] = -3 ! flat rate
      MCHARGE[SCR,0] = DCHRG[DCLVL - 1]
      MCHARGE[SCR,1] = DCOST[DCLVL - 1]
    Else ! CWT
      MCHARGE[SCR,0] = FNR(DCHRG[DCLVL - 1] * (T2[16] / 100))
      MCHARGE[SCR,1] = FNR(DCOST[DCLVL - 1] * (T2[16] / 100))
    End If 
    If MCODE[SCR]
      Mat Read #CHMISC,Int(MCODE[SCR]),38;MS2;
      MCTXBL[SCR] = MS2[0]
      If Not(MTAX) Let MCTXBL[SCR] = MTAX
	  if T2[1]<>0 and t2[8]=0 let MCTXBL[SCR] = 0 ! No taxable mdse - not taxable
    End If 
    T2[4] = T2[4] + MCHARGE[SCR,0]
    TOT[0] = TOT[0] + MCHARGE[SCR,1]
    If Fra(MCODE[SCR]) Let TOT[2] = TOT[2] + MCHARGE[SCR,1]
  End If 
  Close #CHMISC
End If 
Return 

!--------------------------------------------------------------

CHECK_GP_HOLD: Rem put new order on gp hold if it needs to be
If F7 Return 
T9[1] = 0
If T9[19] Let T9[1] = 1
GP = 0 \ If T2[1] Let GP = (T2[1] - T2[17]) / T2[1] * 100
If Not(T2[1] = 0 And T2[17] = 0)
  If EX[15] If GP < EX[15] Let T9[1] = 1
  If EX[16] If GP > EX[16] Let T9[1] = 1
  If EX[1] If (T2[1] - T2[17]) < EX[1] Let T9[1] = 1
  If EX[2] If (T2[1] - T2[17]) > EX[2] Let T9[1] = 1
End If 
Mat Read #1,66,16;J$;
If J$[1,1] <= " " Let T9[1] = 0
If H6[1] Let T9[1] = 0
Return 

!--------------------------------------------------------------

READ_HOLD_EX: Rem ! read rules for doing holds
	Mat Read #1,88,1760;J$;
	CHNL = findchannel() ! 99 \ Gosub GETCHAN
	Open #CHNL,J$
	Mat Read #CHNL,H5[7],0;EX;
	Close #CHNL
Return 

!--------------------------------------------------------------

CLEAR_EDIT_STATUS: Rem "=================================== RESET STATUS
If H0 < 90 Return 
Read #CH_ROH,H1,416;H6[2]
Read #CH_ROH,H1,64;LOCKPORT
If H6[2] <= 1 And H5[7] <> 5 ! "not for future orders
  If P9$[45,45] = "Y" Let H6[2] = 2
End If 
If H6[2] <= 0 Let H6[2] = 1
If H6[2] > 11 Or Fra(H6[2]) Let H6[2] = 1
A$ = " ",A$;A$[1,2] = H0 Using "##";A$[3] = H0[7] Using "######"
Search #CH_ROH,2,1;A$,R1,E
If E > 1 Gosub ERR_SEARCH
If Not(E)
  Search #CH_ROH,5,1;A$,R1,E
  If E Gosub ERR_SEARCH
End If 
A$[1,2] = H6[2] Using "##"
E = 0;R1 = H1
Search #CH_ROH,4,1;A$,R1,E
If E > 1 Gosub ERR_SEARCH
H0 = H6[2];H6[2] = 0
LOCKPORT = 0
Write #CH_ROH,H1,0;H0
Write #CH_ROH,H1,416;H6[2]
Write #CH_ROH,H1,64;LOCKPORT;
Return 

!--------------------------------------------------------------

GET_FTAX: Rem CHECK TO SEE IF FREIGHT IS TAXABLE
FTAX = 0
HTAX = 0
MTAX = 0
DTAX = 0
Mat Read #CH_CUSTTAX,A0[3],36;TAX;
FTAX = TAX[99]
MTAX = TAX[98]
DTAX = TAX[100]
HTAX = TAX[97]
Return 

!--------------------------------------------------------------

NUM2DATE: Rem *UNPACK DATE  X2 TO X$      V1.0  4/04/84  G.DOSCHER
X$ = " ",X$ \ X$[10] = ""
X$[1,3] = Int(X2 / 10 ^ 2 - Int(X2 / 10 ^ 4) * 10 ^ 2) + 10 ^ 2 Using "###"
X$[4,6] = Fra(X2 / 10 ^ 2) * 10 ^ 2 + 10 ^ 2 Using "###"
X$[7,9] = Int(X2 / 10 ^ 4) + 10 ^ 2 Using "###"
X$[4,4] = "/" \ X$[7,7] = "/" \ X$ = X$[2]
If Not(X2) Let X$ = "        "
Return 
DATE2NUM: Rem *PACK DATE    X$ TO X2      V1.0  4/04/84  G.DOSCHER
X2 = X$[4,5] \ X1 = X$[1,2] \ X2 = X2 + X1 * 10 ^ 2
X1 = X$[7,8] \ X2 = X2 + X1 * 10 ^ 4
Return 
JUL2DATE: Rem REM DATE JULIAN X2 TO X$
DT3[0] = X2;FLAG = 1;X$ = " "
Call "JULIANUTIL",DT3[],X$,FLAG
Return 
YMD2JUL: Rem  REM  CONVERT YYMMDD TO JULIAN (RETURN=NOGOOD, +1=OKAY)
X$ = X2 Using "&&&&&&"
Call DateToJulian(1,X$,X$,E) \ If E Return 
X2 = X$[1,5]
Return 1
JUL2YMD: Rem  REM CONVERT JULIAN TO YYMMDD
DT3[0] = X2;DT3[1] = X2;FLAG = 0
Call "JULIANUTIL",DT3[],X$,FLAG
Return 
YM2LONGYEAR: Rem Rem Convert YYMM to YYYYMM
X$ = X2 Using "&&&&"
DT3[0] = X$[1,2];DT3[1] = X$[3,4]
If DT3[0] > 67 Let DT3[0] = 1900 + DT3[0]
If DT3[0] < 68 Let DT3[0] = 2000 + DT3[0]
X$[1,4] = DT3[0] Using "&&&&"
X$[5,6] = DT3[1] Using "&&"
X2 = X$[1,6]
Return 

!--------------------------------------------------------------

Rem {begin rtn.convert.s}
CONVERT: Rem "UNIT CONVERSION RETURNS AMOUNT  (rev 01/07/1992)   ! 20040 REM
If CNVTU[2] = 3 Or CNVTU[2] = 4 Goto CVTSTARTA
If CNVTU[2] = 1 And CNVTU[1] = CNVTU[0] Let AMOUNT = CNVTA \ Goto CVTDONE
If CNVTU[0] = -2 Or CNVTU[1] = -2 Let AMOUNT = CNVTA \ Goto CVTDONE
If CNVTU[2] = 0 Goto CVTSTARTA
If Not(CNVTA) Let AMOUNT = 0 \ Goto CVTDONE
CVTSTARTA: Rem ALL UB 5+!!  IF SPC 4>1280 GOTO cvtstartb: ! "unibasic 5+

CVTSTARTB: Rem "====== unibasic 5+ logic
Call "MXPRCONV5.dl4",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG,e$,rstr$
If CNVTU[2] = 0 Goto CVTDONE
If FLAG Let E = FLAG \ Gosub ERR_SEARCH
AMOUNT = CNVTA
CVTDONE: Return 
Rem {end rtn.convert.s}

!--------------------------------------------------------------

WRITE_DEL_TO_EDITTRACK: Rem! what it says
clear etr.
ETR.OrdNum = OOH0[7]
ETR.LineNum = L3[2]
ETR.Status = OOH0[0]
ETR.ProdCode$ = L2$[1,12]+B$
ETR.OrgQtyOrd = OOQO
ETR.OrgQtyShip = OOQSHIP
ETR.OrgQtyBO = OOQBO + B0[6]
ETR.NewQtyOrd = OOQO
ETR.NewQtyShip = OOQSHIP
ETR.NewQtyBO = OOQBO
ETR.ETDATE = Tim(6)
ETR.ETTIME = Tim(11) * 10000 + Tim(12) * 100 + Tim(13)
ETR.ETPORT = UIDRec  ! Spc(6)
ETR.ETACTION = 2
If L3[0]
  ETR.UMSell = EUN[0];ETR.NstkFlag = 1
Else 
  ETR.UMSell = UN[0];ETR.NstkFlag = 0
End If 
ETR.InvNum = O_OREF[1]
ETR.OrgOrdTot = 0
ETR.CustNum = OOH0[4]
ETR.Printer = 0
ETR.Slsm = OOH0[11]
IF ORGLOADCOST<>0 OR NEWLOADCOST<>0
	IF ORGLOADCOST<>NEWLOADCOST
	    let etr.umcost=UN[2]
		let etr.OrgLoadCost=ORGLOADCOST
		let etr.NewLoadCost=NEWLOADCOST ! get load cost
	ENDIF
ENDIF
!ETUNITPRICE[0] = 0
!ETUNITPRICE[1] = 0
!ETPUNIT[0] = 0
!ETPUNIT[1] = 0
!ETLOADCOST[0] = 0
!ETLOADCOST[1] = 0
!ETWGT[0] = 0
!ETWGT[1] = 0
ETR.AccessCode$ = "PROG 264NS  "+B$
ETR.SpareNU$=B$
Gosub CREATE_EDITTRACK

!--------------------------------------------------------------

Return 
CREATE_EDITTRACK: Rem inset record
FChan[0]=ch_et;fchan[1]=-1
Call MakeEdittrack(e$,IntCo,fchan[],etr.)
Return 
!--------------------------------------------------------------
WRITE_NEW_TO_EDITTRACK: Rem! write when line added to new order
Clear etr.
ETR.OrdNum = H0[7]
ETR.LineNum = L3[2]
ETR.Status = H0[0]
ETR.ProdCode$ = L2$[1,12]+B$
ETR.OrgQtyOrd = B0[6]
ETR.OrgQtyShip = B0[6]
ETR.OrgQtyBO = 0
ETR.NewQtyOrd = B0[6]
ETR.NewQtyShip = B0[6]
ETR.NewQtyBO = 0
ETR.ETDATE = Tim(6)
ETR.ETTIME = Tim(11) * 10000 + Tim(12) * 100 + Tim(13)
ETR.ETPORT = UIDRec	! Spc(6)
ETR.ETACTION = 11
If L3[0]
  ETR.UMSell = EUN[0];ETR.NstkFlag = 1
Else 
  ETR.UMSell = UN[0];ETR.NstkFlag = 0
End If 
ETR.InvNum = OREF[1]
ETR.OrgOrdTot = L5[3]
If UN[1] = -2 Let ETR.OrgOrdTot = OLM[3] Else Let ETR.OrgOrdTot = FNR(OLM[3] * B0[6])
ETR.CustNum = H0[4]
ETR.Printer = 0
ETR.Slsm = OOH0[11]
!ETUNITPRICE[0] = 0
!ETUNITPRICE[1] = 0
!ETPUNIT[0] = 0
!ETPUNIT[1] = 0
!ETLOADCOST[0] = 0
!ETLOADCOST[1] = 0
!ETWGT[0] = 0
!ETWGT[1] = 0
ETR.AccessCode$ = "PROG 264NS  "+B$
ETR.SpareNU$=B$
Gosub CREATE_EDITTRACK
Return 

!--------------------------------------------------------------

WRITE_OLD_TO_EDITTRACK: Rem! write edit to old order (if not deleted)
Clear etr.
ETR.OrdNum = OOH0[7]
ETR.LineNum = L3[2]
ETR.Status = OOH0[0]
ETR.ProdCode$ = L2$[1,12]+B$
ETR.OrgQtyOrd = OOQO
ETR.OrgQtyShip = OOQSHIP
ETR.OrgQtyBO = OOQBO + B0[6]
ETR.NewQtyOrd = OOQO
ETR.NewQtyShip = OOQSHIP
ETR.NewQtyBO = OOQBO
ETR.ETDATE = Tim(6)
ETR.ETTIME = Tim(11) * 10000 + Tim(12) * 100 + Tim(13)
ETR.ETPORT = UIDRec	!	Spc(6)
ETR.ETACTION = 1
If L3[0]
  ETR.UMSell = EUN[0];ETR.NstkFlag = 1
Else 
  ETR.UMSell = UN[0];ETR.NstkFlag = 0
End If 
ETR.InvNum = O_OREF[1]
ETR.OrgOrdTot = L5[3]
ETR.CustNum = OOH0[4]
ETR.Printer = 0
ETR.Slsm = OOH0[11]
!ETUNITPRICE[0] = 0
!ETUNITPRICE[1] = 0
!ETPUNIT[0] = 0
!ETPUNIT[1] = 0
!ETLOADCOST[0] = 0
!ETLOADCOST[1] = 0
!ETWGT[0] = 0
!ETWGT[1] = 0
ETR.AccessCode$ = "PROG 264NS  "+B$
ETR.SpareNU$=B$
Gosub CREATE_EDITTRACK
Return 

!--------------------------------------------------------------

ABORT: Rem
If S8 = 0 E$="BACK ORDER RELEASE NOT IN PROGRESS "
If S8 = 1 E$="BACK ORDER REGISTER HAS NOT BEEN RUN OR RERUN AFTER AN EDIT "
E$=E$+"ACCEPT ABORTED --- "
ReturnStatus=1 ! 0 ! no good (ONLY DISPLAYS IF =1 ??)
Message$=E$
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
End
! ---------------------------------------------------
read_prod1:! read product file
Rem {begin src/inc/read.prod.i}
    Mat Read #CH_PROD,REC_PROD,0;PR_A$
    Mat Read #CH_PROD,REC_PROD,156;B
    Mat Read #CH_PROD,REC_PROD,256;A
    Mat Read #CH_PROD,REC_PROD,460;PR_A1
    Mat Read #CH_PROD,REC_PROD,508;PR_A2
    Mat Read #CH_PROD,REC_PROD,512;PFU1
    Mat Read #CH_PROD,REC_PROD,554;PFU2
    Mat Read #CH_PROD,REC_PROD,596;PRPARC
    Mat Read #CH_PROD,REC_PROD,620;LM
    Mat Read #CH_PROD,REC_PROD,624;PR_PO
    Mat Read #CH_PROD,REC_PROD,628;AGEDAY
    Read #CH_PROD,REC_PROD,630;LLC
    Mat Read #CH_PROD,REC_PROD,632;PSN$
    Mat Read #CH_PROD,REC_PROD,652;PSN
    Mat Read #CH_PROD,REC_PROD,660;U2
    Mat Read #CH_PROD,REC_PROD,664;LBSORD
    Mat Read #CH_PROD,REC_PROD,670;U4
    Read #CH_PROD,REC_PROD,678;U3
    Mat Read #CH_PROD,REC_PROD,684;U3$
    Mat Read #CH_PROD,REC_PROD,744;HZ$
    Mat Read #CH_PROD,REC_PROD,834;PR_A3
    Mat Read #CH_PROD,REC_PROD,846;PFTB
    Read #CH_PROD,REC_PROD,854;UPCT
    Mat Read #CH_PROD,REC_PROD,856;C1$
    Mat Read #CH_PROD,REC_PROD,894;PR_C4
    Read #CH_PROD,REC_PROD,938;PF_LOAD2
    Mat Read #CH_PROD,REC_PROD,944;PR_A2$
    Mat Read #CH_PROD,REC_PROD,974;PFCO
    Mat Read #CH_PROD,REC_PROD,990;PLV
    Mat Read #CH_PROD,REC_PROD,1002;PLC
    Mat Read #CH_PROD,REC_PROD,1018;PFN
    Mat Read #CH_PROD,REC_PROD,1030;STK
    Mat Read #CH_PROD,REC_PROD,1048;FDT
    Mat Read #CH_PROD,REC_PROD,1056;PRFLG$
    Mat Read #CH_PROD,REC_PROD,1066;PRBASE
    Mat Read #CH_PROD,REC_PROD,1068;PRMKUP
    Mat Read #CH_PROD,REC_PROD,1084;PRMKUPTYP$
    Mat Read #CH_PROD,REC_PROD,1088;FUT
    Mat Read #CH_PROD,REC_PROD,1100;PRPARC2
    Mat Read #CH_PROD,REC_PROD,1108;PRREDI
    Mat Read #CH_PROD,REC_PROD,1120;PIC$
    Mat Read #CH_PROD,REC_PROD,1270;PRD0
    Mat Read #CH_PROD,REC_PROD,1282;PRIML$
    Mat Read #CH_PROD,REC_PROD,1294;PRD1
    Mat Read #CH_PROD,REC_PROD,1304;PRD2
	If Not(A[5]) Let A[5] = 1
    Rem {end read.prod.i}
return
! --------------------------------------------------
read_prwh: ! read prodwhse ifle
	Rem {begin src/inc/read.prwh.i}
		Mat Read #CH_PRWH,REC_PRWH,0;W1$
		Mat Read #CH_PRWH,REC_PRWH,32;W1
		Mat Read #CH_PRWH,REC_PRWH,38;W2
		Mat Read #CH_PRWH,REC_PRWH,78;W3
		Mat Read #CH_PRWH,REC_PRWH,228;W5
      Mat Read #CH_PRWH,REC_PRWH,384;WHPARC
      Read #CH_PRWH,REC_PRWH,396;WHLPOOL
      Mat Read #CH_PRWH,REC_PRWH,400;WCOMM$
      Read #CH_PRWH,REC_PRWH,404;FCWGT
      Mat Read #CH_PRWH,REC_PRWH,420;W0
      Mat Read #CH_PRWH,REC_PRWH,428;WH7
      Mat Read #CH_PRWH,REC_PRWH,444;WH8
      Mat Read #CH_PRWH,REC_PRWH,540;WH9
      Mat Read #CH_PRWH,REC_PRWH,696;W7
      Mat Read #CH_PRWH,REC_PRWH,756;WH3$
      Mat Read #CH_PRWH,REC_PRWH,780;WHLV
      Read #CH_PRWH,REC_PRWH,798;WHRPLN
      Mat Read #CH_PRWH,REC_PRWH,800;WHMISC
      Mat Read #CH_PRWH,REC_PRWH,842;WHLM
      Mat Read #CH_PRWH,REC_PRWH,846;WHMISC2
      Read #CH_PRWH,REC_PRWH,894;RESTRICTED
      Mat Read #CH_PRWH,REC_PRWH,896;WHFUT
      Mat Read #CH_PRWH,REC_PRWH,914;WHFDT
      Read #CH_PRWH,REC_PRWH,922;VLIST
      Mat Read #CH_PRWH,REC_PRWH,928;WHFLG$
      Read #CH_PRWH,REC_PRWH,938;WHBASE
      Mat Read #CH_PRWH,REC_PRWH,940;WHMKUP
      Mat Read #CH_PRWH,REC_PRWH,956;WHMKUPTYP$
      Mat Read #CH_PRWH,REC_PRWH,960;WHPARC2
      Mat Read #CH_PRWH,REC_PRWH,968;WHREDI
      Mat Read #CH_PRWH,REC_PRWH,980;WHLBS
      Rem {end read.prwh.i}
return
!------------------------------------------------
CALC_LOAD: Rem
PREC[0] = REC_PROD
IF NOT(PREC[0]) LET PREC[0]=L4[0]
PREC[2] = FNR(Abs((L6[4] * L7[2]) / A[5]))
If L6[4] And L6[4] <> A[6] ! line lbs different from prod file lbs
  PREC[3] = L6[4]
Else 
  PREC[3] = 0
End If 
CNVTA = -999 ! SET TO CALCULATE BASED UPON PROD/PRODWHSE
OTYPE = - H5[7] 
Call "MXLOAD5.DL4",OTYPE,WH,LTBL,PREC[],CNVTA,LDSTAT[2],E$,RSTR$
Return 
!--------------------------------------------------



!--------------------------------------------------------------

L_8900: Rem
If S8 = 0 E$="BACK ORDER RELEASE NOT IN PROCESS "
If S8 = 1 E$="BACK ORDER REGISTER HAS NOT BEEN RUN OR RERUN AFTER AN EDIT "
If S8 = -2 E$="A BACKORDER REGISTER IS CURRENTLY BEING PRINTED "
If S8 = -1 E$="BACKORDER ENTRY/EDIT CURRENTLY IN PROGRESS"
If S8 = -3 E$="BACKORDER ACCEPT IN PROGRESS ELSEWHERE"
E$=E$+"ACCEPT ABORTED ---  "
ReturnStatus=1 ! 0 ! no good (ONLY DISPLAYS IF =1 ??)
Message$=E$
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
End

!--------------------------------------------------------------

TotalOrd: ! total order for nonstock freight
S9[2] = ORDREC;S9[3] = 6;S9[4] = 374
PASSINFO[0] = 1
Mat Read #Ch_roh,ordrec,0;TH0;
REC_ROT=Th0[3]
Mat Read #ch_rot,REC_ROT,0;TT1         
Mat Read #ch_rot,REC_ROT,8;TT2         
Mat Read #ch_rot,REC_ROT,168;TMCD    
Mat Read #ch_rot,REC_ROT,208;TMCHRG  
Mat Read #ch_rot,REC_ROT,328;TTOT      
Mat Read #ch_rot,REC_ROT,358;TMCTX   
Mat Read #ch_rot,REC_ROT,378;TDLVL;   
PCHAN[0] = chan[1]
PCHAN[1] = 0                                              
PCHAN[2] = ch_zone  ! zone
PCHAN[3] = ch_prod ! product ch_prod
PCHAN[4] = ch_commcode! commodity code
PCHAN[5] = ch_cust ! cust        
PCHAN[6] = 0 ! ch_prwh
PCHAN[7] = ch_ros !  ch_ros
PCHAN[8] = Ch_roh ! order header 
PCHAN[9] = ch_rot ! ch_rot! ch_rot
PCHAN[10] =ch_rol !  ch_rol                                                                              
PCHAN[11] = 0
PCHAN[12] = 0! custtax
PCHAN[13] = ch_slsm !slsm
PCHAN[14] = ch_taxcode !ch_tax            
PCHAN[15] = ch_sprodlot! ch_prlt
PCHAN[16] = ch_sordlot !ch_ordl
PCHAN[17] = ch_ccodes! ch_ccodes   
PARM[0] = 1    ! credit check inquiry - set to Y for existing order     
PARM[1] = 1   ! do credit check   - set to Y  - maybe increasing sales amount                                                      
PARM[2] = 1    ! exception     - set to Y to check gp/cost exceptions                                                      
PARM[3] = 1    ! write total                                                        
PARM[4] = 1    ! update order total in customer's file                                                       
If P60$[40,40] = "S" Let PARM[4] = 1                                     
PARM[5] = 0    ! clear manual fields = N                                                          
PARM[6] = 0    ! clear cash filed =N 
PARM[9] = 99	! delivery charge  
PARM[10] = 99! ar term misc cost charge   - bypass                                                                                                        
S9[4] = 374                                                             
R5 = 0! rec_cust
TH1 = ordrec! ORDER HEADER RECORD #
V1 = 0 ! REC_SLSM    
! SAVE ORIGINAL VALUES
let orgcost=fnr(Tt2[14])
let orgamt=fnr(Tt2[24])
IF P60$[40,40]="S" 
	let orgshipamt=fnr(TT2[0]) ! Shipped amount
endif
let orgfreight=fnr(TT2[5])
LET orgother=fnr(Tt2[6])
let tmp3=Tt2[21]
For ctr = 1 To 12                       
	oldholdcodeflag[ctr] = Sgn(Fra(tmp3 / 2))
	tmp3 = Int(tmp3 / 2)                  
Next ctr
Call "ORDERTOTAL",S9[],TH1,PARM[],PCHAN[],TT1[],TT2[],TMCD[],TMCHRG[],TTOT[],TMCTX[],TDCLVL,R5,V1,CFIN[]   
Mat Read #ch_rot,REC_ROT,8;TT2;
let tmp3=Tt2[21]
For ctr = 1 To 12                       
		holdcodeflag[ctr] = Sgn(Fra(tmp3 / 2))
		tmp3 = Int(tmp3 / 2)                  
Next ctr
if oldholdcodeflag[1]<>holdcodeflag[1] ! credit 
	If p60$[40,40]="S"
		if fnr(Tt2[0])<=fnr(orgshipamt)
			let holdcodeflag[1]=oldholdcodeflag[1]
		endif
	else
		if fnr(Tt2[24])<=fnr(orgamt)  ! amount is less than or equal
			let holdcodeflag[1]=oldholdcodeflag[1] 
		endif
	endif
endif
if oldholdcodeflag[2]<>holdcodeflag[2] ! gp exception
	if fnr(Tt2[24])=orgamt and Tt2[14]=fnr(orgcost)
		let holdcodeflag[2]=oldholdcodeflag[2]
	else
		if fnr(Tt2[24])=orgamt and oldholdcodeflag[2]=0 and holdcodeflag[2]<>0
			if fnr(orgamt-orgcost)<=fnr(Tt2[24]-tT2[14]) ! original gp is less than new gp
				let holdcodeflag[2]=oldholdcodeflag[2]
			endif
		endif
	endif
endif
if fnr(orgamt)=Fnr(Tt2[24]) and fnr(orgcost)=fnr(Tt2[14])
	for ctr=3 to 12
		if oldholdcodeflag[ctr]<>holdcodeflag[ctr]
			let holdcodeflag[ctr]=oldholdcodeflag[ctr]
		endif
	next ctr
endif
tmp3 = 0                                            
For ctr = 0 To 11                                   
	If holdcodeflag[ctr + 1] Let tmp3 = tmp3 + 2 ^ ctr
Next ctr                                            
Tt2[21] = tmp3
Mat Write #ch_rot,REC_ROT,8;TT2;
return
!--------------------------------------------------


OUTEND: Rem
DONE: Rem EXIT PROGRAM
! If INVOICE >= 0 Gosub CLEAR_BOWORK
if ch_pol<>0 
	try 
		close #ch_pol
	else ! rem
	end try
endif
S8 = 0
!Write #1,20,2;S8;
DONE_NOCLEAR: Rem
!If S8 = -3
!  Write #1,20,2;S8_OLD;
!End If 
! Close 
If INVOICE <= -1
  !Window Open @10,3; Size 66,13; Using " Order Status Conflict "
  E$="Order "+Str$(O3)+" is at status "+Str$( - INVOICE)+"."
  !Print 
  !Print " There is a backorder amount associated with this order that"
  !Print " can not be processed while the order is at status "; - INVOICE;"."
  E$=E$+" Backorder processing is halted until the order status"
  E$=E$+" becomes status 1 through 6."
  E$=E$+" 264 may be re-run at that time."
  !Print 
  !Print " <CR> to continue to menu ";
  !Input ""U5$
  !Window Close 
  ReturnStatus=1 ! 0 ! no good (ONLY DISPLAYS IF =1 ??)
  Message$=E$
	  !call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  !call AddToStr(e$,rstr$,WebStr$)
	  !call SetOutPut(e$,rstr$)
Else ! all okay - done
	tmp$="OK"
	If S8=0 let tmp$=tmp$," ",Str$(ordercntr)," BACKORDER(S) RELEASED"
	IF S8<>0 let tmp$=tmp$," BO'S NOT CLEARED"
	! Call SetOutput(e$,rstr$,1,tmp$) ! send ok and message
	ReturnStatus=1 ! 0 ! no good (ONLY DISPLAYS IF =1 ??)

	  ! call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  ! call AddToStr(e$,rstr$,WebStr$)
	  ! call SetOutPut(e$,rstr$)
End If 
if ordercntr tmpmessage$=tmp$
! Try Call dxclose() Else REM
END ! Chain "MX000"

!--------------------------------------------------------------

Rem {begin rtn.error.s}
ERR_TRAP: Rem
If Spc(8) = 123
  Escdis 
  Escclr 
  Return -1
End If 
Call programdump()
Goto ERR_MAIN
ERR_SEARCH: Rem
ENUM = E + 1000;ELINE = Spc(16);CTERR = 0
If E = 5 Let CTERR = Err(8)
msg$ = "RETURN STATUS",(E + (CTERR * .001))
msg$ = msg$,"/ STATEMENT",ELINE," IN PROGRAM "+Msc$(4)
Call programdump("tmp/264nse!","") 
Call programdump()
Goto ERR_MAIN
ERR_MAIN: Rem
! If Err 0 Rem
e$ = msg$
include "src/callmainerrnet.inc"
End 
Rem {end rtn.error.s}
!~-----------------------------------------------------------
else
    include "src/callsuberr.inc"
end try
End
