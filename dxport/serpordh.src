!"serpordh" === description  synergy erp  order entry/edit system
!
! loadsave -w -n 100,10 -o prog/dxport/serpordh.dl4 src/serpordh.src
!
! 
! SERIOUSLY - IF YOU SEND A NEW FIELD TO THE WEB - SERPQTEH MUST ALSO HAVE IT!!
! ******** PLEASE MAKE ANY CHANGES ON SERPQTEH ALSO - IF APPLICABLE!! ***
! ******** ANY FIELD ADDED HERE NEEDS TO BE IN SERPQTEH ALSO **********
!******************************************************************************
! CUSTOM_CUSTOMER$
! PHILLIPS - task#14118/cct#136456 - Do not cash sales off hold
! PHILLIPS - task#14117/cct#173357 - no cred chk in pos for terms 1,3,12
! PHILLIPS - task#14104/cct#116872  - credit code=5, do not allow order
! PHILLIPS - task#14152/cct#109870 - whse transfer in invoice edit/entry flag as printed
! EVAP - OT 36 & 37 ARE NOW STANDARD ORDER TYPES
! 06/18/13 jcs task27159 - add "MSPLASTICS" custom code for: (mxslscom5 also)
! 06/23/06 rjs cct198184 - allow user to edit Comm$ & % - set EDITCOMM Flag
! American wax204881 - used closed acct password based on terms/over 90
! Task 57205 - add new source type 2082 (allow no header/total changes - just lines)
! ------------------------------------------------------------------------------
include "src/copyright.inc"
!
include "src/inc/filecust.inc" ! customer
include "src/inc/filesaract.inc" ! a/r file ! for credit checking
include "src/inc/fileordhead.inc" ! order header, order shipto, order rot
include "src/inc/fileartermcode.inc" ! a/r term codes
include "src/inc/filedeptfle.inc" ! department file
include "src/inc/filewhinfoz.inc" ! warehouse
include "src/inc/fileentdby.inc" ! enterby file 
include "src/inc/filezonefle.inc" ! zone file
include "src/inc/filedivifle.inc" ! division file
include "src/inc/filesorce.inc" ! source file
include "src/inc/filesslsmz.inc" ! slsm file
include "src/inc/fileprtdefault.inc" ! port default
include "src/inc/fileshiplist.inc" ! ship list file
Include "src/inc/filecustnotes.inc" ! customer notes file  
Include "src/inc/filerom.inc" ! order message file
Include "src/inc/filerolz.inc" ! order lines file
Include "src/inc/filemiscchrg.inc" ! misc charge file
Include "src/inc/filetaxcode.inc" ! tax code file
Include "src/inc/filecusttax.inc" ! customer tax type file
Include "src/inc/filespecmsg.inc" ! special message  file
Include "src/inc/filesordcash.inc" ! cash order file
Include "src/inc/filea80vm.inc" ! vendor file
include "src/inc/fileedittrack.inc" ! edit tracking
Include "src/inc/fileccctype.inc"
Include "src/inc/fileinvltag.inc" ! line notes
Include "src/inc/filesorddep.inc" ! deposit file
Include "src/inc/filerfpickq.inc" ! rf pick queue
! for multicurrency
include "src/inc/filecurrency.inc" ! currency exchange file

External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus
Declare External Sub CustInfoHeading,CustInfoRecord

 External Lib "sffiles.lib"                                                
 Declare External Function getcust,getmisccharge$ 
 Declare External Function getshiplist,getcurrentdate,getzone    
!
 External Lib "libdroplist.lib"
 Declare External sub CustDropList,CMTypeDropList
 Declare External sub OrdTypeDropList,RoutingDropList,ShipTermDropList
!
 External Lib "libtable.lib"
 Declare External Function GetARTypeDesc$
!
External Lib "libgeneralcode.lib"
Declare External Function ConvertDate
!
External Lib "ubsfunc.dl4"
Declare External Sub getportdefault,GetCostLevels,LogAccess
Declare External Function OpenFile,PDate$,FormatDate2$,getuidinfo$,JDate$
Declare External Function chkDteFrmt$,clrtxtc$,CHKBADCHARS,getuidrec
!
External Lib "libedittrack.lib"
Declare External Sub MakeEdittrack
!
External lib "libshipldisplay.lib"
Declare External Sub GetCustShipL
!
External Lib "getcredcdd.lib"
Declare External Function Getcredcdd$
!
External Lib "gettaxcdd.lib"
Declare External Function GetTaxCdd$
External Lib "getartermd.lib"
Declare External Function GetArTermd$
External Lib "getslsmname.lib"
Declare External Function GetSlsmname$
External Lib "getordtypd.lib"
Declare External Function Getordtypd$
External Lib "ubscredck.dl4"
Declare External Sub GetCredCk
External Lib "getcusttaxtyd.lib"
Declare External Function Getcusttaxtyd$
External Lib "cmcpinv.dl4"
Declare External Sub cmcpinv

External Lib "ubsprconv.dl4"     
Declare External Function XUnit$
External Lib "libprodconv.lib"          
Declare External Function ConvProdAmount


External Lib "libimaging.lib"
Declare External Sub GetImage

Declare Intrinsic Sub DateToJulian,JulianToDate,VerifyDate,CheckNumber,Time
Declare Intrinsic sub programdump,sortinstring,findf
Declare Intrinsic function findchannel
!
!
Declare sub OpenFiles
Declare Sub VerifyCustomer
Declare Sub LoadDefault
Declare Sub OrdHLabel,InvhLabel
Declare Sub Ordlist,OTypeProcess
Declare Sub OrdWhDroplist,OrdTypelist
Declare Sub CalcShipDate,OTMSDTIN
Declare Sub FindShiplist,TrkDel,edttrk
Declare Sub OrdHCreditCheck,ChkcreateCust,ChkCreateshiplist
Declare Sub CalcFreightCharge,gpsumm,verifystat,onholdchk
Declare Sub CalcDeliveryCharge,lp1chk
Declare Sub GetCash,SaveCash,GETCASHCUST,DeleteOrd,cashnosale,subcashnosale,opendrawer
Declare Sub GetInvHdr,GetInvHMsg,GetInvHTot,getinvhsumm,SrchInvhMsg
Declare Sub GetInvHCash,ChkBPO,CHKREBILLORDER
Declare Sub CheckImages,CountILines,fut208,SrchInvhCPO
Declare Sub GetInvHLines,FactorUm,SetPRtoInvl
Declare Sub getcustinvhlist,getinvhlisthdr,getinvhlistdet,GetInvRefId,GetOrdRefId,GetOrdOrgId
Declare Function chkDateFrmt$,getnteflgs$,getmillitmflag$,getautowhtrans$
Declare Sub DelSysChrg,dochalert,showmillitems,CurrConvUP,CurrConvDown,delartermcst
Declare Function chktagfle$
!--------------------------------------------------------------------
!
!
! ** main procedure
!
!
OPTION GOSUB NESTING 12  ! Default is 8
try
	Option String Redim is legal ! in case subs dim/use same names
  !
  dim 1%,cnvcu[10],3%,cnvca[10],keycurr$[10],1%,ch_curr,3%,rec_curr,currfact
  dim e$[500],buttonlist$[5,50],nextlist$[5,100] ! error handling variables
  dim bsdel$[20],esdel$[20],rdel$[20],fdel$[20],rstr$[3000]
  dim Section$[30],Field$[10,30],J6$[50],miflag$[5]
  dim mergedir$[60],action$[20],action1$[20],options$[20],Action2$[20]
  dim Company$[2],UserID$[8],keycust$[50],keyroh$[50],keyrom$[40]
  dim xdate$[10],keyship$[40],shipkey$[40],keyrol$[40],keyslsm$[40],keyrod$[40],keyroc$[50]
  dim rohkey3$[50],holddesc$[12,16],holdpswd$[12,16]
  dim 1%,ch_curr,3%,rec_curr,Currkey$[10],3%,amount
 
  Dim statword$[200]
  dim msglist$[200]
  let msglist$=" ",msglist$
  let msglist$[1,16]=   "Invoice        "
  let msglist$[33,48]=  "Order          " ! 2
  let msglist$[65,80]=  "Invoice/Order  " ! 4 
  let msglist$[97,112]= "Bill of Lading " ! 6
  let msglist$[129,144]="Internal       " ! 8 
  LET STATWORD$="ENTERED   PRINTED   REGISTEREDRDY TO INV"
  STATWORD$=STATWORD$+"INV ENTRD INV PRNTD INV REGD            "
  STATWORD$=STATWORD$+"C/M ENTRD C/M PRNTD C/M REGD            "!
  ! dim for order totals
  dim 1%,ch[99],dclvl,mctxbl[9],2%,s9[12],t1[1],mcode[9],3%,h1,v1,r5,param[10],t2[25],mcharge[9,1],tot[4],cfin[8]
  dim 3%,tot_ord
  dim 3%,dsp_totordamt,currfact
  dim 1%,editstatus,gencm,newxfer,cost_lev[4],holdcodeflag[12],SCType,oldholdcodeflag[12]
  dim 1%,ua5[10],x1[9],tcb,aflag[99],MAXEDITSTATUS,dispcomm$[1],EDITCOMM
  dim 1%,ordedit,nolines,ot[38],orgdelcode,newdelcode,BPFlag[9],orgdeltax,newdeltax
  dim 1%,tmp1,intCo,intSls,CTLC,errflag,WH,Div,portnum,chan[25],flag
  dim 2%,tmp2,maxcnt \ maxcnt=100 ! max records in arrays
  dim 3%,tmp3,JDepositDate,DocNo,rec_uac
  dim 2%,custid,custid$[6],shipcustid,shipcustid$[6],shipcode$[6],shipcode
  dim 2%,orderid,orderid$[6],billcustid,billcustid$[6],ordnum
  Dim 2%,orgshipdate,orgtotwgt
  dim 3%,ordamt,OrderAmt$[20],arbal,openordamt,CURTIM[10],orgamt,merchamt
  dim 3%,ordcost,orgcost,oohld
  dim 2%,conswh,maxwh,currdate,CustSec[1],numilines,X2[9]
  dim 2%,taxcode,taxtype,delchglvl,salesarea,source,credpct
  dim 3%,tmprec[10],EX[18],linetax,rec_rol,invnum,3%,X3[9],orgdelamt,newdelamt,rec_roc
  dim 4%,tmp4
  dim taxcoded$[20],custtaxtyped$[16],X$[100]
  dim tmppo$[20],chkpo$[20],3%,rec_tmp,R[99]
  dim credcoded$[16],clsdpswd$[8],ordtyped$[20],WORK$[600]
  dim whlist$[100,100],etlist$[100,100],atlist$[100,100],divlist$[100,100]
  dim srclist$[100,100],slsmlist$[100,100],deptlist$[100,100],zonelist$[100,100]
  dim ordtypelist$[100,100],routinglist$[100,100],shiptermlist$[100,100],shiptyped$[16],tmpkey$[50],zndsc$[10]
  Dim CMTypeList$[100,100],k_rfpq$[100]
  dim orderno$[6],billtoid$[6],userid$[8]
  dim p60$[50],p61$[256],P9$[50],ucf$[10]
  dim List$[maxcnt,2000],sdate$[50]
  dim SList$[maxcnt,800] ! for .net selector(drop down) list
  dim logfname$[50],bpo$[20]
  dim CustNo$[6],SearKey$[64],BegKey$[64],mode$[3],UA2$[50]
  dim Desc$[50],PayFlag$[1],RecType$[1],DocNo$[10],ARInvKey$[64],InvType$[3]
  dim tmp$[400],tmp1$[400],WebStr$[2000],Message$[200],artermd$[16],slsmname$[30],overpswd$[30]
  dim custom_customer$[30],Msg$[200]
  dim 3%,eflg,errmsg$[200]
  dim blank$[200] \ blank$=" ",blank$
  dim M3$[3] \ M3$="###"
  dim M6$[6] \ M6$="######"
  dim M10$[10] \ M10$="##########"
  dim 3%
  let tmp$=tim(4) using "&&&&&&"
  let work$=tmp$[5,6],tmp$[1,2],tmp$[3,4]
  let currdate=work$
 
  !!! define structures !!! 
  dim Cust. as cust ! customer
  dim billto. as cust ! bill to customer
  dim AR. as saract ! a/r file
  dim roh. as roh ! order header
  dim ros. as ros ! order ship to file
  dim rot. as rot ! order total file
  dim rom. as rom ! order message file
  dim rol. as rolnew ! order lines
  dim dept. as deptfle ! dept file
  dim wh. as whinfo ! warehouse file
  dim et. as entdby ! entered by file
  dim zn. as zonefle ! zone file
  dim os. as sorce ! order source file
  dim div. as divifle ! division file
  dim Sslsm. as sslsm ! salesman file
  dim Term. as artermcode ! a/r term codes
  dim prt. as prtdefault ! port defaults
  dim sh. as shiplist ! shiplist file
  dim cnotes. as custnotes ! customer note file
  dim misc. as miscchrg ! misc charges
  dim tax. as taxcode ! tax code file
  dim ctax. as custtax ! customer tax type file
  dim roc. as sordcash ! sale order cash file
  dim vend. as a80vm ! vendor file
  Dim ETR. as edittrack ! EDITTRACKING
  dim ccc. as ccctype
  dim rod. as sorddep ! order deposit lines
  dim rfpq. as rfpickq ! rf pick queue
  ! for currency exchange
  dim curr. as currency

  Def FNR(H) = Int(Abs(H) * 100 + .5) * .01 * Sgn(H)
  Def FNS(H) = Int(Abs(H) * 100) * .01 * Sgn(H) ! rounding to nearest penny
  !
  call dxopen()
  Call dxget("S_USER.AppID",tmp$) !company #               
                                                         
  Try Let intCo = Val(tmp$) Else Let intCo = 1 !company #  
  ctlc = OpenFile(9999,intCo) \ If ctlc = -1 Error 42 !control   ! openning with read/write
  call GetSession(e$,CTLC,options$,action$,UserID$,intCo,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$,action1$,action2$)
  call LogAccess(e$)
  call GetPortDefault(e$,IntCO,UserID$,portnum,rec_uac,prt.) ! get port default
  Call GetCostLevels(e$,cost_lev[],IntCo,Userid$)
  !call dxget("u_custom_customer", custom_customer$)
  mat read #ctlc,115,60;custom_customer$;
  let custom_customer$=UCase$(trim$(custom_customer$))
  mat read #ctlc,60,50;p60$; ! system flag variable
  mat read #ctlc,61,0;p61$;
  ! let p61$[136,136]="N" ! set multicurrency to N
  mat read #ctlc,19,50;p9$;
  read #ctlc,60,16;conswh;
  SCType = 0
  ! split commissions by category take priority and do not play
  ! nice with the other types
  if p9$[21,21] <> "Y"
	let SCType=p61$[72,72] \ if p61$[72,72] = "Y" SCType=1
  end if
  ucf$[1,3]="YYY" ! default - delete order/inv, invoice history print
  if rec_uac>0 ! check user cntrl
		UCC = OpenFile(-9988, intCo)
		if ucc>=0! open user cntrl file
			mat read #ucc,rec_uac,652;ucf$;
			if ucf$[1,1]="" or ucf$[1,1]=" " let ucf$[1,1]="Y"
			if ucf$[2,2]="" or ucf$[2,2]=" " let ucf$[2,2]="Y"
			if ucf$[3,3]="" or ucf$[3,3]=" " let ucf$[3,3]="Y"
			if custom_customer$="MSPLASTICS" ! default=Y
				if ucf$[4,4]="" or ucf$[4,4]=" " let ucf$[4,4]="Y"
			endif
		endif
		Try Close #UCC  Else Rem
  endif
  !
  call dxget("s_view.mergedir",mergedir$)
  ! We use action1$ or 2$ to determine what we working on: none=ORDERS, CREDIT=credits, INVOICE=invoice
  Action$=UCase$(RTrim$(action$)) ! uppercase & trim
  Action1$=UCase$(RTrim$(action1$)) ! uc & trim
  Action2$=UCase$(RTrim$(action2$))
  Credit=0;Invoice=0
  If Action1$="CREDIT" let credit=1 ! mostly action1$
  If Action2$="CREDIT" let Credit=1 ! on droplist/ordhlists option
  ! If Action2$="INVOICE" let Invoice=1
  ! set up programmed ot list - ALSO SET IN below for credits
  ot[1]=1;ot[2]=1;ot[3]=1;ot[4]=1;ot[5]=1;ot[6]=1;ot[7]=1;ot[8]=1;ot[9]=1;ot[10]=1
  ot[11]=1;ot[12]=1;ot[13]=0;ot[14]=1;ot[15]=1;ot[16]=1;ot[17]=1;ot[18]=1;ot[19]=1
  ot[20]=1;ot[21]=1;ot[22]=1;ot[23]=1;OT[24]=1
   ! ;ot[x]=1 add as needed
  For x=25 to 34 \ let ot[x]=1 \ next x ! per dd all ot 25-34 are same as 1
  if p60$[25,25]<>"Y" let ot[21]=0;ot[22]=0
  IF CUSTOM_CUSTOMER$="HTBERRY" LET ot[35]=1 ! "one-time order"
  ot[36]=1;ot[37]=1 ! evap - NOW STANDARD
  ot[38]=0 ! custom
   IF CUSTOM_CUSTOMER$="OMAHA" LET ot[38]=1 ! "delivery memo
  ! ot: 14,17,18,23 are active and treated as ot[1] even though not labelled on std/native
  ! as of 06/20: not active are ot 13 and 35+
  CALL dxget("SOURCE",tmp$)
  source=tmp$ ! s/b program #
  if source=241 or source=243 let Credit=1 ! sb in action1/2 but may not be
  if source=201 or source=208 let source=0
  if source=231 let ot[5]=0;ot[9]=0;ot[11]=0 ! not allowed
  if source=251 let ot[5]=0;ot[7]=0;ot[8]=0;ot[20]=0;ot[24]=0 ! not allowed
  if source<>231 and source<>223 and source<>207 let ot[20]=0 ! only in 223/231 is allowed?
  ch_usrctl=findchannel()
	Ropen #CH_USRCTL,"cntrl/usercntrl"
	Try
		mat read #ch_usrctl,rec_uac,336;UA2$;
		mat read #ch_usrctl,rec_uac,404;MAXEDITSTATUS;
	Else
		UA2$=" ",Ua2$;maxeditstatus=0
	End try
	Try Close #ch_usrctl Else Rem
  AFlag[1]=0 ! alert - credchk
  let maxiedstat=UA2$[35,35] ! max inv edit status
  If not(maxiedstat) let maxiedstat=6 ! set to max invoice edit status
  if maxiedstat<5 let maxiedstat=5 ! no orders
  if maxiedstat>6 let maxiedstat=6 ! no inv reg'd!!
  if maxeditstatus<1 let maxeditstatus=4 ! 0=all (in case upgraded & not entered)
  if maxeditstatus>4 let maxeditstatus=4
  roadnetedit=0 \ if UA2$[50,50]="Y" let roadnetedit=1 ! 
  EDITCOMM=0 \ if custom_customer$="MSPLASTICS" let EditComm=1 ! also set in mxslscom5
  IF CREDIT and UCF$[4,4]="Y" LET Editcomm=1 ! BY USER - edit c/m commissions
  if editcomm and P60$[24,24]="Y" let EditComm=0 ! NOT ON COMM BY LINE!!
  If Credit ! need force cm copy flag
	
	If UA2$[26,26] = "Y" Let GENCM = 1 Else Let GENCM = 0
	
	let msglist$=" ",msglist$
	let msglist$[1,16]=   "Invoice/Credit "
	let msglist$[33,48]=  "Order          " ! 2
	let msglist$[65,80]=  "Inv/Order/Cred " ! 4 
	let msglist$[97,112]= "Bill of Lading " ! 6
	let msglist$[129,144]="Internal       " ! 8 
	if (credit) ! credits only certain types
		! PER 241A - no ot 5,9,11,12,16
		! use order ot's - zero out not allowed for credits
		let ot[5]=0;ot[9]=0;ot[11]=0;ot[12]=0;ot[16]=0
		LET OT[20]=1 ! allow frgt credit?
	Endif
	
  Endif
  ! if x3=-101 ! 6057 or userid$[1,4]="JIMS" ! track EVERY WEB CALL!
	!	x=0
	!	getnxtsv: ! loop til not found
	!	tmp$="tmp/ohsvpw"+Str$(x)+".txt"
	!	Call FindF(tmp$,FOUND)
	!	if found let x=x+1 \ goto getnxtsv ! til new one to save all web submits
	!	call dxsave(0,tmp$)
  ! Endif
  !
  If Action$="INVHIST"
	include "src/inc/fileinvhead.inc"
	include "src/inc/fileinvm.inc"
	include "src/inc/fileinvl.inc"
	include "src/inc/fileprod.inc"
	Include "src/inc/filecommhead.inc"
	include "src/inc/fileccodes.inc" ! u/m file
	include "src/inc/filesordcashh.inc" ! cash screen
	Include "src/inc/filesorddeph.inc" ! deposits
	dim invh. as invh
	dim invs. as invs
	dim invt. as invt
	dim invm. as invm
	dim invl. as invl
	dim pr. as prod
	dim cmc. as commhead
	dim umc. as ccodes
	dim invc. as sordcashh
	dim invd. as sorddeph
	dim keyinvh$[50],keyinvm$[50],keyinvl$[50],qmask$[20],pmask$[20]
	Dim CCTYPE$[100]
	Dim 1%,ch_invh,ch_invs,ch_invt,ch_invl,ch_invm,2%,Q0[1]
	Dim 3%,rec_invh,rec_invl,rec_invm 
	MAT  READ #ctlc,49,0;CCTYPE$;
	Mat Read #CTLC,115,40;Q0;
	QMask$="---------#.##"
	tmp$="#",tmp$
	If q0[1]<=0 Let Q0[1]=2
	If Q0[1] Let Pmask$="-----------#.",tmp$[1,Q0[1]]     !price mask
	ch_usrctl=findchannel()
	Ropen #CH_USRCTL,"cntrl/usercntrl"
	Try
		mat read #ch_usrctl,rec_uac,336;UA2$;
	Else
		UA2$=" ",Ua2$
	End try
	Try Close #ch_usrctl Else Rem
  endif

  call OpenFiles()
  !
  select case action$

  case "DROPLIST" !   send droplists 
    
  !================================= Begin Action Droplist ================================================
	  if action1$="ORDHLISTS"		! doc=droplistordhlists.doc or CMH.droplistordhlists.doc
		let errmsg$=""
		let eflg=0
		call FileDropListEntdby(e$,etList$[],100,ch_et) ! ENTBY
		call AddToStr(e$,rstr$,etList$[])
		call FileDropListArtermcode(e$,atList$[],100,ch_terms) ! AR TERMS
		call AddToStr(e$,rstr$,atList$[]) !
		call FileDropListDivifle(e$,divList$[],100,ch_div) ! DIVISION LIST 
		call AddToStr(e$,rstr$,divList$[])
		call FileDropListSorce(e$,srcList$[],100,ch_src) ! SOURCE LIST
		call AddToStr(e$,rstr$,srcList$[])
		call FileDropListDeptfle(e$,deptList$[],100,ch_dept) ! DEPTFLE
		if rtrim$(deptlist$[2])=esdel$
			let deptlist$[2]="0",fdel$,"No Dept",fdel$
			let deptlist$[3]=esdel$
		endif
		call AddToStr(e$,rstr$,deptList$[])
		call FileDropListZonefle(e$,ZoneList$[],100,ch_zone) ! ZONE FILE
		call AddToStr(e$,rstr$,ZoneList$[])
		If Not(Credit)
			call ShipTermDropList(e$,ShipTermList$[],bsdel$,esdel$,fdel$,100,ctlc) ! SHIP TERMS
			call AddToStr(e$,rstr$,ShipTermList$[])
		Else
			call CMTypeDropList(e$,CMTypeList$[],bsdel$,esdel$,fdel$,100,ctlc,ua2$) ! CMTypes
			call AddToStr(e$,rstr$,CMTypeList$[])
		Endif
		call RoutingDropList(e$,RoutingList$[],bsdel$,esdel$,fdel$,100,ctlc) ! ROUTING
		call AddToStr(e$,rstr$,RoutingList$[])
		call FileDropListSSlsmz(e$,SLSMList$[],100,ch_Sslsm) ! slsm list
		call AddToStr(e$,rstr$,SlsmList$[])
		! verify data
		let errmsg$=""
		let eflg=0
		rec_cnt=0
		if Rtrim$(etlist$[2])=esdel$
			let eflg=eflg+1
			let errmsg$=errmsg$+"Enter By "
		endif
		if rtrim$(atlist$[2])=esdel$
			let eflg=eflg+1
			let errmsg$=errmsg$+"AR Terms "
		endif
		if rtrim$(divlist$[2])=esdel$
			let eflg=eflg+1 
			let errmsg$=errmsg$+"Division "
		endif
		if rtrim$(srcList$[2])=esdel$
			let eflg=eflg+1
			let errmsg$=errmsg$+"Source "
		endif
		if rtrim$(ZoneList$[2])=esdel$
			let eflg=eflg+1
			let errmsg$=errmsg$+"Zone "
		endif
		If Not(Credit)
			if rtrim$(ShipTermList$[2])=esdel$
				let eflg=eflg+1
				let errmsg$=errmsg$+"Ship Terms "
			endif
		Else
			if rtrim$(CMTypeList$[2])=esdel$
				let eflg=eflg+1
				let errmsg$=errmsg$+"CM Types "
			endif
		Endif
			if rtrim$(SlsmList$[2])=esdel$
			let eflg=eflg+1
			 errmsg$=errmsg$+"Sales Rep "
		endif
		let returnstatus=1
		let message$="OK"
		If eflg<>0
			let message$="Data For File(s) Need to be Set-Up: "+errmsg$
			returnstatus=0 ! error
		endif
		Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
		Call AddToStr(e$,rstr$,WebStr$)                       

	   endif
	  !
	  if action1$="WHINFO"
		 call FileDropListWhinfoz(e$,whList$[],100,ch_wh)
		 call AddToStr(e$,rstr$,whList$[])
	  endif
	  if action1$="ENTDBY"
		call FileDropListEntdby(e$,etList$[],100,ch_et)
		call AddToStr(e$,rstr$,etList$[])
	  endif
	  if action1$="ARTERM"
		call  FileDropListArtermcode(e$,atList$[],100,ch_terms)
		call AddToStr(e$,rstr$,atList$[])
	  endif
	  if action1$="DIVIFLE"
		call FileDropListDivifle(e$,divList$[],100,ch_div)
		call AddToStr(e$,rstr$,divList$[])
	  endif
	  If action1$="SORCE"
		call FileDropListSorce(e$,srcList$[],100,ch_src)
		call AddToStr(e$,rstr$,srcList$[])
	  endif
	  If action1$="SSLSM"
		call FileDropListSslsmz(e$,slsmList$[],100,ch_sslsm)
		call AddToStr(e$,rstr$,slsmList$[])
	  endif
	  If action1$="DEPT"
		call FileDropListDeptfle(e$,deptList$[],100,ch_dept)
		call AddToStr(e$,rstr$,deptList$[])
	  endif	 
	  If action1$="ZONE"
		call FileDropListZonefle(e$,ZoneList$[],100,ch_zone)
		call AddToStr(e$,rstr$,ZoneList$[])
	  endif	
	  if action1$="ORDTYPE"
		call OrdTypeDropList(e$,OrdTypeList$[],bsdel$,esdel$,fdel$,100,ctlc)
		call AddToStr(e$,rstr$,OrdTypeList$[])
	  endif
	  if action1$="SHIPTERM"
		call ShipTermDropList(e$,ShipTermList$[],bsdel$,esdel$,fdel$,100,ctlc)
		call AddToStr(e$,rstr$,ShipTermList$[])
	  endif
	  if action1$="CMTYPE"
		call CMTypeDropList(e$,CMTypeList$[],bsdel$,esdel$,fdel$,100,ctlc,ua2$)
		call AddToStr(e$,rstr$,CMTypeList$[])
	  endif
	  !if action1$="ROUTING"
		!call RoutingDropList(e$,RoutingList$[],bsdel$,esdel$,fdel$,100,ctlc)
		!call AddToStr(e$,rstr$,RoutingList$[])
	  !endif
	  if action1$="CUSTOMER"
		Section$="CustInfo"
		Field$[0]="CustomerCode" ! customer #
		Field$[1]="CustomerBillTo" ! bill to customer #
		Field$[2]="Name$" ! customer name
		Field$[3]="Contact$" ! contact
		Field$[4]="Addr1$" ! address line 1
		Field$[5]="Addr2$" ! address line 2
		Field$[6]="City$" ! city
		Field$[7]="State$" ! state
		Field$[8]="Zip4$" ! zip code
		Field$[9]="Phone$" ! telephone #
		
		clear List$[]
		Dir=2
		call filedroplistcust(e$,list$[],maxcnt,Ch_Cust,Section$,Field$[],Dir,SearKey$)
		call AddToStr(e$,rstr$,List$[])
	endif
      call SetOutput(e$,rstr$)
	! end of DROPLIST
 Case "NEWCUSTDATA" ! get flag/div list						doc=OrdH.NewCustData.doc
	returnstatus=1
	message$="OK"
	if p61$[69,69]<>"Y" let p61$[69,69]="N"
	if source<>231 and source<>251 ! only places can do this
		let P61$[69,69]="N"
	Endif
	clear list$[]
	List$[0]=bsdel$,"SYSFLAG",fdel$
	List$[1]="NEWCUSTENT",FDEL$
	list$[2]=P61$[69,69],fdel$
	list$[3]=esdel$
	call AddToStr(e$,rstr$,List$[])
	clear divlist$[]
	call FileDropListDivifle(e$,divList$[],100,ch_div) ! DIVISION LIST 
	call AddToStr(e$,rstr$,divList$[])
	! section 3 - status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)
	! end of NEWCUSTDATA
CASE "ORDHLABEL"
	call ordhlabel()

CASE "ORDHOPEN"
	call dxget ("custid",CustId$)
	let custid=custid$
	! section 1 -- shiplist - should send AFTER customer check!
	! section 1 -- shiplist 
	!let shipcustid$=custid$
	! call dxset ("shipcustid",shipCustId$)
	Call GetCustShipL(e$,List$[],SList$[],maxcnt,intCo,ReturnStatus,Message$)
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	! call AddToStr(e$,rstr$,esdel$) ! end of section already in list
	ctlc = OpenFile(9999,intCo) \ If ctlc = -1 Error 42 !control   ! openning with read/write

	! section 2 - bill to name
	
	SearKey$=custid using M6$
	mode$="="
	dirno=1
	if custid>0
		CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,SearKey$,cust.)
	else
		custrec=-1
	Endif
	if CustRec>=0 ! record found
		IF source=251 and custid<>prt.CashSaleCustNum
		 if cust.ConsignWh>0 and cust.ConsignWh<consWh
			let returnstatus=0
			let message$="CANNOT USE WAREHOUSE TRANSFER CUSTOMER "
			goto MCDone
		 endif
		endif
		If Source<>251 If custid<>prt.CashSaleCustNum
		 Custsec[0]=custid;custsec[1]=1 ! id & NO ALERT
		 call "custsec.dl4",Custsec[],ctlc,userid$,e$,rstr$
		 if custsec[0]=-1 ! not allowed
			returnstatus=0
			message$="You do not have access this customer"
			goto MCDone
		 Endif
		 
		Endif ! don't check on cash cust or cash sales
		if custom_customer$="PHILLIPS" !task#14104/cct116872 credit code=5, do not allow order
			If source=201 or Source=251 or Source=231
				if cust.creditcode=5
					let returnstatus=0
					let message$="CREDIT CODE: 5 - ORDER ABORTED"
					goto MCDone
				endif
			endif
		endif
		! task 51372 - POS ONLY CUSTOMER CHECK - only 251 & 241 + edits/inquiry
		if Source=251 or Source=241 or source=207 or source=239 or source=223 ! these are ALLOWED!
			rem ! allow through - no check
			returnstatus=1
			message$="OK"
		Else ! all others check field
			If cust.PrepaidMin=1 ! yes it has wrong label but it's a Y
				returnstatus=0
				message$="This customer is Point of Sale Only"
				goto MCDone
			endif
		Endif
		let tmp3=custid
		if cust.customerbillto<>0 and cust.customerbillto<>custid
			let keycust$=" ",keycust$
			let keycust$=cust.customerbillto using "######"
			search #ch_cust,2,1;keycust$,rec_cust,e
			if e
				let returnstatus=0
				Message$="Bill To Customer "+keycust$+" Not On File"
				goto MCDone
			endif
			read record #ch_cust,rec_cust;billto.;
		else
			let billto. = cust.
		endif
	else
		let returnstatus=0
		Message$="Customer "+SearKey$+" Not On File"
		goto MCDone
	endif
	
	clear list$[]
	
	List$[0]=bsdel$,"Billing Customer",fdel$
	WebStr$="BILLTOID",fdel$,"Name",fdel$
	WebStr$=WebStr$,"Addr1",fdel$,"Addr2",fdel$
	WebStr$=WebStr$,"City",fdel$,"State",fdel$,"ZipCode",fdel$
	WebStr$=WebStr$,"Country",fdel$,"SNOTES",fdel$,"WNOTES",fdel$
	List$[1]=WebStr$
	if custrec>0
		webstr$=str$(billto.CustomerCode)+fdel$		! custcode
		webstr$=webstr$+rtrim$(billto.Name$)+fdel$		! custname
		webstr$=webstr$+rtrim$(billto.Addr1$)+fdel$		! add1
		webstr$=webstr$+rtrim$(billto.Addr2$)+fdel$		! add2
		webstr$=webstr$+rtrim$(billto.City$)+fdel$		! city
		webstr$=webstr$+rtrim$(billto.State$)+fdel$		! state
		webstr$=webstr$+rtrim$(billto.Zip4$)+fdel$	! zipcode
		webstr$=webstr$+RTrim$(billto.Country$)+fdel$		! country
		webstr$=getnteflgs$(webstr$)
		let list$[2]=webstr$
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! section 3 - open order list
	call ordlist ()
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! section 4 - account closed
	clear list$[]
	List$[0]=bsdel$,"CLOSED ACCOUNT",fdel$
	WebStr$="Closed",fdel$,"Password",fdel$
	List$[1]=WebStr$
	needpwd=0 \ If cust.CreditCode>0 and cust.CreditCode<=16 let needpwd=1
	if custom_customer$="AMWAX" and (SOURCE=0 OR source=201 or source=231 or source=251) ! has add'l checks
		chan=findchannel()
		let atcd=chan
		open #atcd,"2/ARTERMCODE"+STR$(INTCO)
		clear term.
		IF cust.Terms>0 AND cust.Terms<=99   
		  Read Record #atcd,cust.Terms;term.;  
		ENDIF 
		if term.DiscountDays=99  or cust.AgeArAmt4 or cust.AgeArAmt3 or CUST.CreditCheckDays>=90 let needpwd=2! mark for password2
		! also bill to is checked
		clear term.
		IF billto.Terms>0 AND billto.Terms<=99   
		  Read Record #atcd,billto.Terms;term.;  
		ENDIF 
		if term.DiscountDays=99  or billto.AgeArAmt4 or billto.AgeArAmt3 or billto.CreditCheckDays>=90 let needpwd=2! mark for password2
		try close #atcd else rem
	Endif
	If needpwd ! check if password required/entered
	    if cust.CreditCode>0 and cust.CreditCode<=16
			let credcoded$=getcredcdd$(ctlc,cust.CreditCode,intco)
		else
			clear credcoded$
		endif
		read #ctlc,182,44;clsdpswd$;
		tmp$="0" ! closed = no
		if credcoded$[1,1]="*" let tmp$="1" ! closed - yes
		if needpwd=2 let tmp$="1" ! yes - needs password
		if clsdpswd$="" 
			let tmp$="0" ! no password -- no closed
		endif
	
		if clsdpswd$[1,8]="        "
			let tmp$="0"
		endif
		if tmp$="0"
			let clsdpswd$=" ",clsdpswd$
		endif
		webstr$=tmp$+fdel$  ! closed account flag
		webstr$=webstr$+rtrim$(clsdpswd$)+fdel$ ! closed account password	
		let list$[2]=webstr$
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	MCDone: ! done - send status
	! section 5 - status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)
	! end of ORDHOPEN
 Case "GETSHIPLIST"
	
	Call GetCustShipL(e$,List$[],SList$[],maxcnt,intCo,ReturnStatus,Message$)
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	ctlc = OpenFile(9999,intCo) \ If ctlc = -1 Error 42 !control   ! need to re-open after call

	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)

case "GETSHIPINFO"  ! doc=OrdH.GetShipInfo.doc
	Dim 2%,InvDate,d4ship,D4ROUTING
	call dxget ("custid",Custid$)
	let custid=custid$
	call dxget ("orderid",orderid$)
	let orderid=orderid$
	call dxget ("shipcustid",shipcustid$)
	let shipcustid=shipcustid$
	!call dxget ("shipcode",shipcode$)
	!let shipcode=shipcode$
	call dxget ("shipdateedit",tmp$)
	let shipdateedit=tmp$ !(0- recalc, 1- do not recalc)
	call dxget ("droplistzonefle",tmp$)
	let ros.zone$=tmp$+"  "
	call dxget ("droplistordwh",tmp$)
	let roh.wh=tmp$
	If Not(Credit)
		call dxget ("shipdate",tmp$)
	Else
		call dxget("dateinvd",tmp$)
	Endif
	if tmp$<>"999999"
		xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
		roh.shipdate=xdate$[3,8]
	else
		let roh.shipdate=999999
	endif
	If Not(Credit)
		call dxget ("duedate",tmp$)
		xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
		roh.duedate=xdate$[3,8]
	Else	
		call dxget("cmdate",tmp$)
		xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
		roh.InvDate=xdate$[3,8]
		roh.duedate=0 ! NOT ON CM'S
	Endif
	call dxget ("droplistsslsm",tmp$)
	let roh.slsmnum=tmp$

	call dxget ("orderdate",tmp$) ! in mm/dd/yyyy
	call VerifyDate(tmp$,xdate$,e)
	if e ! not good
		let returnstatus=0
		let message$="SUBMITORDHDR: Invalid order header date submitted, please correct."
		goto endsubordhdr
	end if
	roh.orddate = xdate$ ! yymmdd
! 	xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
! 	let roh.orddate=xdate$[3,8]

	call dxget ("Attn",tmp$)
	let roh.contact$=tmp$+Blank$ ! add spaces
	call dxget ("Truck",tmp$)
	let ros.truck=tmp$
	call dxget ("Stopnum",tmp$)
	let tmp3=tmp$
	if tmp3>=1 AND tmp3<=7999
		let roh.stopnum=tmp$
	ENDIF
	call dxget ("TaxCode",tmp$)
	let tmp3=tmp$
	if tmp3>0
		let roh.taxcode=tmp3
	endif
	call dxget ("TaxType",tmp$)
	let tmp3=tmp$
	if tmp3>0
		let ros.shiptaxtype=tmp3
	endif
	If p61$[109,109]<>"Y"
		call dxget ("dclvl",tmp$)
		let rot.delivChrgLvl=tmp$
	endif
	call dxget ("salesarea",tmp$)
	let roh.salesarea=tmp$
	call dxget ("shipedit",tmp$)
	let ros.shipedit=tmp$
	if p61$[109,109]="Y" ! RUTHERFORD
		if ros.shipedit=5 ! manual edit
			let rot.delivchrglvl=0
		endif
	endif
	call dxget ("routinglist",tmp$)
	let roh.shipvia$=tmp$+Blank$
	call dxget("PO",tmp$)
	let tmppo$=UCase$(tmp$)+Blank$
	if orderid and custid and Trim$(tmppo$)="" ! needs a po try for one
		let keycust$=custid using "######"
		let mode$="="
		let dirno=1
		let returnstatus=1
		let message$="OK"
		if custid>0
			CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
		Else
			clear cust.
		Endif
		keyroh$=" ",keyroh$
		keyroh$[1,6]=custid using "######" 
		keyroh$[7,12]=orderid using "######"
		keyroh$[13]=""
		mode$="=" ! search mode 2
		dir=2
		clear chan[]
		CHAN[0]=CH_ROH
		CHAN[1]=CH_ROS
		CHAN[2]=CH_ROT
		Rec_roh=filegetrohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
		if rec_roh<0
			if cust.porequiredflag=0 or cust.porequiredflag=2
				let tmppo$="VERBAL"
			endif
		else
			let tmppo$=roh.custpo$
		Endif
	Endif ! no po sent
	call dxget ("shipkey",tmp$)
	let shipkey$=""
	if rtrim$(tmp$)<>""
		let tmp4=tmp$
		if shipcustid=0 let shipcustid=int(tmp4)
		if shipcode=0 let shipcode=int(fra(tmp4)*10^6)
		let shipkey$[1,6]=shipcustid using "######"
		let shipkey$[7,7]="."
		let shipkey$[8,13]=shipcode using "&&&&&&"
		shipkey$[14]=""
	endif
	if shipcustid=0
		let shipcustid=custid
		let shipcode=0
		let shipedit=0
	endif
	let keycust$=shipcustid using "######"
	let mode$="="
	let dirno=1
	let returnstatus=1
	let message$="OK"
	if shipcustid>0
		CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
	Else
		custrec=-1
	Endif
	if custrec<=0
		let returnstatus=0
		let message$="Customer "+str$(shipcustid)+" Not on File"
	else ! customer is on file
		if orderid=0 let roh.CustNum=custid
		call findshiplist()
		if sh.ddiv>0 and sh.ddiv<100
			let roh.div=sh.ddiv
		else
			if prt.div>0
				let roh.div=prt.div ! port default priority
			else
				if cust.division>0
					let roh.div=cust.division 
				endif
			endif
		endif
		if p61$[109,109]="Y" ! new
			! not using the shiplist mast delivery cust at all
			!if sh.mastdelscust>0 and sh.mastdelscust<=999999.999999
			!	let ros.mastdelvcust=sh.mastdelscust
			!	let ros.mastdelvship=sh.mastdelship
			!else
				if cust.mastdelvcust<1 or cust.mastdelvcust>999999
					let cust.mastdelvcust=cust.CustomerCode
				endif
				let ros.mastdelvcust=cust.mastdelvcust
				let ros.mastdelvship=0
			!endif
		endif
		if roh.div<=0 let roh.div=1
		if shiprec<=0
			if shipcode<>0
				let returnstatus=0
				let message$="Shiplist Customer "+keyship$+" Not on File"
			endif
			if shipcode=0 and shipedit=1
				let returnstatus=0
				let message$="Shiplist Customer "+keyship$+" Not on File"
			endif
			if returnstatus<>0
				if not(shipcustid) let shipcustid=roh.custnum
				if shipcustid<>custid let ros.shipedit=4 else let ros.shipedit=0
				let ros.shipcust=roh.custnum
				let ros.shipcust=shipcustid
				let ros.shipcode=shipcode
				let ros.name$=cust.name$
				let ros.address$=cust.addr1$
				let ros.address2$=cust.addr2$
				let ros.city$=cust.city$
				let ros.state$=cust.state$
				let ros.zipcode$=cust.zip4$[1,6]
				let ros.zip4$=cust.zip4$[7,10]
				let ros.country$=cust.country$
				LET ros.truck=0
				let ros.zone$=" ",ros.zone$
				let roh.shipvia$="OUR TRUCK"
				if p61$[109,109]="Y"
					if cust.mastdelvcust<1 or cust.mastdelvcust>999999
						let cust.mastdelvcust=cust.CustomerCode
					endif
					let ros.mastdelvcust=cust.MASTDELVCUST
					let ros.mastdelvship=0
					let rot.delivchrglvl=0 !
				endif
				if p61$[34,34]="Y" ! multi-zone customer
					if not (ros.shipcust) let ros.shipcust=custid
					if not (roh.shipdate) let roh.shipdate=roh.orddate
					call "MXOHCSZONE",ros.shipcust,ros.shipcode,roh.orddate,roh.div,roh.wh,roh.shipdate,ros.zone$,roh.stopnum,IntCo
					if rtrim$(ros.zone$)<>""
						let cust.zonenumber$=ros.zone$
						let cust.sStop=roh.stopnum
						if source=251 let roh.shipdate=roh.orddate ! POS - no lead
						let roh.duedate=roh.shipdate
					endif
				endif
				let mode$="="
				let dirno=1
				clear zn.
				ZoneRec=FileGetZonefle(e$,Ch_Zone,mode$,dirno,cust.zonenumber$,zn.)
				if zonerec>0
					let ros.truck=zn.trucknum
					let ros.zone$=cust.zonenumber$
					if rtrim$(zn.shipvia$)<>""
						let roh.shipvia$=zn.shipvia$
					endif
				Else
					let ros.zone$="  " ! "00" ! default zone? (not all custs have it setup)
				endif
				let roh.taxcode=cust.taxcode
				let ros.shiptaxtype=cust.taxtype
				let roh.contact$=cust.contact$
				let roh.slsmnum=cust.salesmancode
				if not(ordnum)
					if cust.defaultwhse<>0
						let roh.wh=cust.defaultwhse
					else
						let roh.wh=prt.wh
					endif
				endif
				let roh.stopnum=cust.sStop
				if cust.CustomerDiscount
					let roh.orddisc=cust.CustomerDiscount
				endif
			endif ! *** end ship cust <> custid
		endif ! shiplist found
		if source=251 ! and prt.CashSaleCustNum =roh.custnum (NATIVE ANY IN 251)
			 MAT  READ #ctlc,182,68;D4SHIP;
			 IF D4SHIP>16 LET D4SHIP=1
			 if d4ship<>0
				roh.ShipType=d4ship
			 endif
			 MAT  READ #ctlc,182,72;D4ROUTING;   
			 IF D4ROUTING>106 LET D4ROUTING=1 
			 IF D4ROUTING<>0
				tmp$=" ",tmp$
				READ #CTLC,130,(D4ROUTING-1)*12;TMP$[1,12];
				if rtrim$(tmp$)<>""	LET roh.ShipVia$=tmp$
			endif
			let rot.delivchrglvl=0 ! cash sale no delivery charge
		Endif
		
		IF NOT(CREDIT) ! not on credits
			clear bpo$
			let bpflag[1]=1
			if shiprec>0 and custid=ros.shipcust
				if ros.shipedit=1 or ros.shipedit=2 let bpflag[1]=9
			endif
			call chkbpo()
			if not(bpflag[2]) and Trim$(BPO$)<>"" ! no issues
				let tmppo$=UCase$(BPO$) ! from cust or shiplist
			endif
		endif
	endif ! customer on file
	if returnstatus<>0
		If roh.shipdate and roh.shipdate<>999999 and Not(Credit) call calcshipdate()
        ! If Not(Credit) call calcshipdate()
	endif
	!!! send over headings
	Clear List$[]                                                         
	List$[0] = bsdel$ + "ShipInfo" + fdel$ ! section name
	webstr$="CustId",fdel$
	webstr$=webstr$,"ShipCustId",fdel$
	webstr$=webstr$,"OrderId",fdel$
	!webstr$=webstr$,"ShipCode",fdel$
	webstr$=webstr$,"ShipEdit",fdel$
	webstr$=webstr$,"Truck",fdel$
	webstr$=webstr$,"droplistdzonefle",fdel$ ! zone
	webstr$=webstr$,"TaxCode",fdel$
	webstr$=webstr$,"TaxDesc",fdel$
	webstr$=webstr$,"TaxType",fdel$ 
	webstr$=webstr$,"droplistsslsm",fdel$ ! sslsm
	webstr$=webstr$,"Attn",fdel$
	If Not(Credit)
		webstr$=webstr$,"ShipDate",fdel$
	Else
		webstr$=webstr$,"DateInvd",fdel$
	Endif
	webstr$=webstr$,"droplistordwh",fdel$
	If Not(Credit)
		webstr$=webstr$,"DueDate",fdel$
	Else
		webstr$=WebStr$,"CMDate",fdel$
	Endif
	webstr$=webstr$,"RoutingList",fdel$
	webstr$=webstr$,"StopNum",fdel$
	webstr$=webstr$,"SalesArea",fdel$
	webstr$=webstr$,"Dclvl",fdel$
	webstr$=webstr$,"Shipkey",fdel$
	webstr$=webstr$,"TaxTypeDesc",fdel$ ! customer tax type desc
	webstr$=webstr$,"droplistdivifle",fdel$
	webstr$=webstr$,"PO",fdel$
	let list$[1]=webstr$
	if returnstatus<>0 ! no errors send over the data
		webstr$=str$(roh.custnum),fdel$
		if not (ros.shipcust) let ros.shipcust=roh.custnum
		webstr$=webstr$,str$(ros.shipcust),fdel$
		webstr$=webstr$,str$(roh.ordnum),fdel$
		!webstr$=webstr$,str$(ros.shipcode),fdel$
		webstr$=webstr$,str$(ros.shipedit),fdel$
		webstr$=webstr$,str$(ros.truck),fdel$
		webstr$=webstr$,ros.zone$,fdel$
		if roh.taxcode<1 or roh.taxcode>7999
			let roh.taxcode=cust.taxcode
		endif
		webstr$=webstr$,str$(roh.taxcode),fdel$
		taxcoded$=gettaxcdd$(ch_tax,roh.TaxCode,intco)
		webstr$=webstr$,taxcoded$,fdel$
		webstr$=webstr$,str$(ros.shiptaxtype),fdel$
		WebStr$=WebStr$,Str$(roh.slsmnum),fdel$ ! salesman number
		Webstr$=webstr$,(roh.contact$),fdel$ ! contact
		if roh.shipdate
			if roh.shipdate<>999999
				let xdate$=pdate$(roh.shipdate)
			else
				let xdate$="999999"
			endif
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! ship date
		webstr$=webstr$,str$(roh.wh),fdel$ ! warehouse
		Let X2=roh.duedate
		if credit let x2=roh.InvDate
		if x2
			let xdate$=pdate$(x2)
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! due date
		if trim$(roh.shipvia$)="" let roh.shipvia$="OUR TRUCK"
		webstr$=webstr$,rtrim$(roh.shipvia$),fdel$
		webstr$=webstr$,str$(roh.stopnum),fdel$
		webstr$=webstr$,str$(roh.salesarea),fdel$
		webstr$=webstr$,str$(rot.delivchrglvl),fdel$
		webstr$=webstr$,shipkey$,fdel$
		custtaxtyped$=getcusttaxtyd$(ch_ctax,ros.shipTaxType,intco)
		webstr$=webstr$,custtaxtyped$,fdel$
		webstr$=webstr$,roh.div,fdel$
		webstr$=webstr$,tmppo$,fdel$ ! cust po
		let list$[2]=webstr$
	endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	               
	! status section *** last section ***
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	
	! done with it
        call SetOutPut(e$,rstr$)
	!!! send over fields
	! end of GETSHIPINFO
case "SUBMITORDHDR"
	! not for inq or chg line qty only!
	call dxget ("custid",Custid$)
	let custid=custid$
	call dxget ("orderid",orderid$)
	let orderid=orderid$
	call dxget ("shipcustid",shipcustid$)
	let shipcustid=shipcustid$
	call dxget ("billcustid",BillCustId$)
	let billcustid=billcustid$
	!call dxget ("shipcode",shipcode$)
	!let shipcode=shipcode$
	 Call DXGet("SOURCE",TMP$)  
	 source = TMP$   !\ if credit let source=0 ! source not used in action1$="CREDIT" 
	 if source=201 or source=208 let source=0 !  USES 0 for them!
	let returnstatus=1
	let message$="" ! null need to append with errors 
	nwonc=0 ! new order on new customer
	if source=207 goto endsubordhdr
	if source=2082 goto endsubordhdr! make sure no changes!!
	! check if customer exists
	KeyCust$=custid using "######"
	mode$="="
	dirno=1
	if custid>0
	Rec_Cust=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
	Else
		rec_cust=-1
	Endif
	if rec_cust<=0
		let returnstatus=0
		Let message$=message$+"Customer is not on file. "
		goto endsubordhdr:
	endif
	if (cust.CommissionByCategory) let SCType = 0 ! force override
	oohld=0
	if orderid<>0
		keyroh$=" ",keyroh$
		keyroh$[1,6]=custid using "######" 
		keyroh$[7,12]=orderid using "######"
		keyroh$[13]=""
		mode$="=" ! search mode 2
		dir=2
		clear chan[]
		CHAN[0]=CH_ROH
		CHAN[1]=CH_ROS
		CHAN[2]=CH_ROT 
		Rec_roh=filegetrohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
		if rec_roh<0 ! customer and order id
			let returnstatus=99
			let message$=message$+"Order Number "+str$(orderid)+" Not On File. "
			goto endsubordhdr:
		endif
		if returnstatus<>0
			call verifystat()
			if returnstatus=99 goto endsubordhdr:
		endif
		if roh.taxcode<1 or roh.taxcode>7999
			let roh.taxcode=cust.taxcode
		endif
		let taxcode=roh.taxcode
		let taxtype=ros.shiptaxtype
		let origslsm=roh.slsmnum! save the slsmnum
		let tmppo$=roh.custpo$ ! save the customer po #
		oohld=rot.HoldCode
		! save the po num 
		let neworderflag=0
	else
		let neworderflag=99
		clear roh.
		let roh.SpareNu$=blank$[1,2] !  ! " ",roh.SpareNu$
		clear rot.
		clear ros.
		let tmppo$=" ",tmppo$
		! get an order #
		If Source=223 ! inv edit - NO NEW ORDERS!
			let returnstatus=0
			let message$=message$+"Order Number "+str$(orderid)+" Not On File. "
			goto endsubordhdr:
		endif
		If p61$[136,136]="Y"
				let keycust$=custid using "######"
				mode$="="
				dirno=1
				CNoteRec=FileGetCustNotes(e$,Ch_CNotes,mode$,dirno,KeyCust$,cnotes.)
				if cnoterec<=0
					clear cnotes.
				endif
				let roh.currid=cnotes.currid
				if p61$[136,136]="Y"  and roh.currid<>0		 
					let keycurr$=" ",keycurr$
					let keycurr$=roh.currid using "####"
					search #ch_curr,2,1;keycurr$,rec_curr,e
					if not(e)
						Read Record #ch_curr,rec_curr;curr.;
					else
						let curr.ExcRate=0
						let roh.currid=0
					endif
					let roh.currfact=curr.ExcRate			
				else
					let roh.currfact=0
				endif
			else
				let roh.currid=0
				let roh.currfact=0
			endif		
	endif
	! need order type before cust po entered
	call dxget ("droplistordtype",tmp$)
	if not(neworderflag) let x2=roh.ordtype ELSE let x2=tmp$ ! retain old one!
	let roh.ordtype=tmp$;otchange=0
	If roh.ordtype<1 or roh.ordtype>38
		let returnstatus=0
		let message$="Invalid Order Type "
		goto endsubordhdr
	endif
	if not (ot[roh.ordtype])
		let returnstatus=0
		let message$="Order Type "+str$(roh.ordtype)+" Not Available At This Time"
		goto endsubordhdr:
	endif
	! process order type
	if x2<>roh.ordtype let otchange=x2 ! set to original otype
	! do for all - whether change or not
	Call OTypeProcess(flag,otchange) ! all checks (allowed, etc) done
	if flag goto endsubordhdr ! found a problem
	! comes back with ot 7,8,16 fields filled
	if roh.ordtype=19 let cust.porequiredflag=3 ! unique po on every order
	call dxget ("PO",tmp$)
	strgok=CHKBADCHARS(e$,tmp$)
	if not(strgok) ! 
		let returnstatus=0
		let message$="Invalid Characters in Customer PO"
		goto endsubordhdr
	Endif
	let tmppo$=roh.custpo$ ! save the customer po #
	let roh.custpo$=ucase$(tmp$+Blank$)
	if NOT(credit) ! credits don't check
	 If cust.porequiredflag = 2 And UCase$(roh.CustPO$[1,6]) = "VERBAL" Goto endduppochk                                                               
	 if cust.porequiredflag <>0 and cust.porequiredflag<>2 
		if rtrim$(roh.custpo$)=""
			let returnstatus=0
			let message$=message$+"Purchase Order is required by this Customer. "
			goto endsubordhdr:
		endif
		if rtrim$(ucase$(roh.custpo$))="VERBAL"
			let returnstatus=0
			let message$=message$+"Purchase Order is required by this Customer. "
			goto endsubordhdr:
		endif
	 endif
	 if returnstatus<>0 and cust.porequiredflag>1 and ucase$(tmppo$[1,20])<>ucase$(roh.custpo$[1,20])
		If cust.porequiredflag=3
			call dxget ("OVERRIDEPOCHK",tmp$)
			if rtrim$(tmp$)<>"" goto endduppochk:
		endif
	    Dim filename$[50]
		Ch_tmproh=findchannel()
		read #ctlc,88,1840;filename$;
		filename$=rtrim$(filename$)
		ropen #ch_tmproh,filename$
		let keyroh$=" ",keyroh$
		let keyroh$[1,6]=custid using "######"
		DO
			search #ch_tmproh,3,2;keyroh$,rec_tmp,e ! do not use rec_roh
			if e>0 exit do
			let tmp3=keyroh$[1,6]\if tmp3<>custid exit do
			let tmp3=keyroh$[7,12]
			if orderid<>tmp3
				mat read #ch_tmproh,rec_tmp,446;chkpo$;
				if ucase$(chkpo$[1,20])=ucase$(roh.custpo$[1,20])
					let returnstatus=0
					if cust.porequiredflag=3 let returnstatus=3
					let message$=message$+"Purchase Order in use on "+keyroh$[7,12]+". "
					goto endsubordhdr:
					exit do
				endif
			endif
		loop
		try close #ch_tmproh else rem
		! now check history file
		Ch_tmproh=findchannel()
		read #ctlc,88,1136;filename$;
		filename$=rtrim$(filename$)
		ropen #ch_tmproh,filename$
		let keyroh$=" ",keyroh$
		let keyroh$[1,6]=custid using "######"
		DO
			search #ch_tmproh,3,2;keyroh$,rec_tmp,e ! do not use rec_roh
			if e>0 exit do
			let tmp3=keyroh$[1,6]\if tmp3<>custid exit do
			let tmp3=keyroh$[7,12]
			if orderid<>tmp3
				mat read #ch_tmproh,rec_tmp,446;chkpo$;
				if ucase$(chkpo$[1,20])=ucase$(roh.custpo$[1,20])
					let returnstatus=0
					if cust.porequiredflag=3 let returnstatus=3
					let message$=message$+"Purchase Order in use on Invoice "+keyroh$[7,16]+". "
					goto endsubordhdr:
					exit do
				endif
			endif
		loop
		endduppochk: ! 
	 endif
	Endif ! credits - no check of po
	call dxget ("droplistzonefle",tmp$)
	let ros.zone$=tmp$+"  "
	let mode$="=" ! on submit - CHECK THE ZONE!!
	let dirno=1
	clear zn.
	ZoneRec=FileGetZonefle(e$,Ch_Zone,mode$,dirno,ros.zone$,zn.)
	if zonerec<=0
		let returnstatus=0
		let message$=message$+"Zone "+ros.zone$+" not found "
		goto endsubordhdr:
	endif
	let oldwhse=roh.wh
	call dxget ("droplistordwh",tmp$)
	let roh.wh=tmp$
	if not(credit)
		call dxget ("shipdate",tmp$)
	Else
		call dxget("dateinvd",tmp$)
	Endif
	if tmp$<>"999999"
		xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
		roh.shipdate=xdate$[3,8]
	else
		let roh.shipdate=999999
	endif
	If Not(Credit)
		call dxget ("duedate",tmp$)
		xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
		roh.duedate=xdate$[3,8]
	Else
		call dxget("cmdate",tmp$)
		xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
		roh.Invdate=xdate$[3,8]
	Endif
	call dxget ("droplistsslsm",tmp$)
	let roh.slsmnum=tmp$
	let roh.slsm[0]=tmp$
	if source<>223
		call dxget ("orderdate",tmp$) ! in mm/dd/yyyy
		call VerifyDate(tmp$,xdate$,e)
		if e ! not good
			let returnstatus=0
			let message$="SUBMITORDHDR: Invalid order header date submitted, please correct."
			goto endsubordhdr
		end if
		roh.orddate = xdate$ ! yymmdd
		! xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
		! let roh.orddate=xdate$[3,8]
		If source=251 let roh.invdate=roh.orddate
	Else ! inv
		call dxget("INVOICEDATE",tmp$)
		xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
		let roh.invdate=xdate$[3,8]
	Endif
	call dxget ("Attn",tmp$)
	strgok=CHKBADCHARS(e$,tmp$)
	if not(strgok) ! 
		let returnstatus=0
		let message$="Invalid Characters in Contact Name"
		goto endsubordhdr
	Endif
	let roh.contact$=tmp$+Blank$ ! add spaces
	call dxget ("Truck",tmp$)
	let ros.truck=tmp$
	call dxget ("Stopnum",tmp$)
	let tmp3=tmp$
	if tmp3>=1 AND tmp3<=7999
		let roh.stopnum=tmp$
	ENDIF
	call dxget ("TaxCode",tmp$)
	let tmp3=tmp$
	if tmp3<1 or tmp3>7999
		let tmp3=roh.taxcode! save previous header tax code
	endif
	let roh.taxcode=tmp3
	if roh.taxcode<1 or roh.taxcode>7999
		let roh.taxcode=cust.taxcode
	endif
	call dxget ("TaxType",tmp$)
	let tmp3=tmp$
	if tmp3>0
		let ros.shiptaxtype=tmp3
	endif
	if p61$[109,109]<>"Y"
		call dxget ("dclvl",tmp$)
		let rot.delivChrgLvl=tmp$
	endif
	call dxget ("salesarea",tmp$)
	let roh.salesarea=tmp$
	call dxget ("shipedit",tmp$)
	let ros.shipedit=tmp$
	if p61$[109,109]="Y" ! RUTHERFORD
		if ros.shipedit=5 ! manual edit
			let rot.delivchrglvl=0
		else
			if ros.mastdelvcust<1 or ros.mastdelvcust>999999
				if p61$[109,109]="Y"
					if cust.mastdelvcust<1 or cust.mastdelvcust>999999
						let cust.mastdelvcust=cust.CustomerCode
					endif
					let ros.mastdelvcust=cust.MASTDELVCUST
					let ros.mastdelvship=0
					let rot.delivchrglvl=0 !
				endif
			endif
		endif
	endif
	call dxget ("routinglist",tmp$)
	strgok=CHKBADCHARS(e$,tmp$)
	if not(strgok) ! 
		let returnstatus=0
		let message$="Invalid Characters in Routing"
		goto endsubordhdr
	Endif
	let roh.shipvia$=tmp$+Blank$
	call dxget ("droplistdeptfle",tmp$)
	let roh.dept=tmp$
	If Not(Credit)
		call dxget ("droplistartermcode",tmp$)
		let roh.terms=tmp$
	Else
		if roh.terms<=0 let roh.terms=cust.terms ! need terms on credits?
		call dxget("INVNUM",tmp$)
		Let X3=tmp$
		! needs neworderflag? lets
		if neworderflag and gencm and (x3<=0 or x3=roh.ordnum) ! did not copy from inv and required
			let returnstatus=0
			let message$=message$+"Credit Memo is required to copy from Invoice. "
			goto endsubordhdr:
		endif
		If X3<=0 or x3>99999999 Let X3=roh.OrdNum ! 0
		if roh.ordtype=36 or roh.ordtype=37 ! EVAP
			if X3=roh.ordnum ! was roh.invnum (not known yet!)
				let returnstatus=0
				let message$=message$+"EVAP Credit Memo is required to copy from Invoice. "
				goto endsubordhdr:
			endif
			if ROH.OrgOrd1<>0 and x3<>roh.ordnum and roh.InvNum<>x3 ! only one per credit
				let returnstatus=0
				let message$=message$+"YOU HAVE ALREADY COPIED IN AN EVAP INVOICE! "
				goto endsubordhdr:
			endif
		endif
		let roh.InvNum=x3
	Endif
	if not(Credit)	call dxget ("ShipTermList",tmp$)
	If Credit 
		Call dxget("CMTypeList",tmp$)
		if roh.OrgOrd and (roh.ordtype=36 or roh.ordtype=37)
			let x2=tmp$
			if x2<15 
				let returnstatus=0
				let message$=message$+"EVAP Credit Memo is has Type automatically set. "
				goto endsubordhdr:
			endif
		endif ! evap
	Endif
	let roh.shiptype=tmp$
	call dxget ("droplistentdby",tmp$)
	let roh.entby=tmp$
	! moved ordertype to before custpo
	call dxget("droplistdivifle",tmp$)
	let roh.div=tmp$
	if roh.div<=0 or roh.div>99
		let returnstatus=0
		let message$=message$+"Invalid Division Submitted. "
		goto endsubordhdr:
	endif
	If not(Credit)
		call dxget("droplistsorce",tmp$)
		let roh.source=tmp$
	Else
		call dxget("weight",tmp$)
		Let roh.ActWgt=tmp$
	Endif
	call dxget ("shipkey",tmp$)
	let shipkey$=""
	let shipcode=0
	if rtrim$(tmp$)<>""
		let shipkey$=tmp$
		let tmp4=shipkey$
		if not (shipcustid) let shipcustid=int(shipkey$)
		let shipcode=int(fra(tmp4)*10^6)
	endif
	! let roh.custnum=custid
	let ros.shipcode=shipcode
	let ros.shipcust=shipcustid
	if not (ros.shipcust) let ros.shipcust=roh.custnum
	call dxget("ShipName",tmp$)
	strgok=CHKBADCHARS(e$,tmp$)
	if not(strgok) ! 
		let returnstatus=0
		let message$="Invalid Characters in Ship to Name"
		goto endsubordhdr
	Endif
	let ros.name$=tmp$+Blank$
	call dxget("ShipAddr1",tmp$)
	strgok=CHKBADCHARS(e$,tmp$)
	if not(strgok) ! 
		let returnstatus=0
		let message$="Invalid Characters in Ship to Addr 1"
		goto endsubordhdr
	Endif
	let ros.address$=tmp$+Blank$
	call dxget("ShipAddr2",tmp$)
	strgok=CHKBADCHARS(e$,tmp$)
	if not(strgok) ! 
		let returnstatus=0
		let message$="Invalid Characters in Ship to Addr 2"
		goto endsubordhdr
	Endif
	let ros.address2$=tmp$+Blank$      
	call dxget("ShipCity",tmp$)
	strgok=CHKBADCHARS(e$,tmp$)
	if not(strgok) ! 
		let returnstatus=0
		let message$="Invalid Characters in Ship to City"
		goto endsubordhdr
	Endif
	let ros.city$=tmp$+Blank$
	call dxget("ShipState",tmp$)
	strgok=CHKBADCHARS(e$,tmp$)
	if not(strgok) ! 
		let returnstatus=0
		let message$="Invalid Characters in Ship to State"
		goto endsubordhdr
	Endif
	let ros.state$=tmp$+Blank$
	call dxget("ShipZip",tmp$)
	let ros.zipcode$=tmp$+Blank$
	if len(tmp$)>5
		let ros.zip4$=tmp$[6]+Blank$
	else
		let ros.zip4$=" ",ros.zip4$
	endif
	call dxget("Country",tmp$)
	strgok=CHKBADCHARS(e$,tmp$)
	if not(strgok) ! 
		let returnstatus=0
		let message$="Invalid Characters in Ship to Country"
		goto endsubordhdr
	Endif
	let ros.country$=tmp$+Blank$
	! added on task 45120 - Re-Bill Order
	If not(credit) and source<>207
		call dxget("REBILLORDER",tmp$)
		x3=tmp$  ! make sure only 0 to 999999 are used for order #
		if x3>=0 and x3<=999999
			let roh.OrgOrd1=tmp$ ! Oref[3] or H2[0]
		endif
	endif
	if ros.shipedit=5 and source<210 ! manual ship addr
		if custom_customer$="MORRISETTE" let rot.DelivChrgLvl=0
	Endif
	if not (credit) and source<221
		call dxget ("OnPickList",tmp$)
		if tmp$="N" let ros.OnPicklist$="1"
		if tmp$="Y" let ros.OnPickList$="2"
	endif
	! ot 16 variables
	! conswh gotten previously in call otypeprocess()
	If roh.ordtype=16 ! 									doc=OrdH.SubmitOrdHdr16.doc
		newxfer=0
		call dxget("XFERAUTH",tmp$)
		if UCase$(RTrim$(tmp$))="Y"
			If roh.XFERAUTH=0 ! not previously authorized
				let newxfer=1
				let roh.XferAuth=1
				roh.AuthBy=rec_uac
				roh.AuthDate=CurrDate
			Endif
		Endif ! if "N" or previously auth - leave alone
	Else ! not ot 16 - clear auth fields (leave conswh for ot 7&8)
		newxfer=0
		roh.XferAuth=0
		roh.AuthBy=0
		roh.AuthDate=0
	Endif
	if roh.ordtype=9 ! get field							doc=OrdH.SubmitOrdHdr9.doc
		call dxget("STAGINGAREA",tmp$)
		strgok=CHKBADCHARS(e$,tmp$)
		if not(strgok) ! 
			let returnstatus=0
			let message$="Invalid Characters in Staging Name"
			goto endsubordhdr
		Endif
		roh.WhStage$=tmp$+Blank$
	Else ! not ot 9 - clear field
		roh.WhStage$=blank$
	Endif
	if roh.ordtype=4 or roh.ordtype=15 or roh.ordtype=24 !  doc=OrdH.SubmitOrdHdr15.doc
		! has ship term & (shipdatelist[] if shipterm=0
		CALL dxget("SHIPTERM",tmp$)
		x2=tmp$  ! options ###=every # days, -## = that day every month
		if x2<0 and x2<-31
			let returnstatus=0
			let message$=message$+"Ship on days Invalid"
			goto endsubordhdr:
		Endif
		ROH.ShipTerm=x2
		if roh.shipterm=0 ! means entered individual dates
			! call OTMSDTIN() ! get in / arrange s3[23] (SEPARATE CALL)
		Else
			Clear roh.shipdatelist[]
		Endif
	Else
		roh.shipterm=0
		Clear roh.shipdatelist[]
	Endif
	if roh.ordtype=5 ! future - add allocate stock date
		call dxget("ALCSTKDATE",tmp$) ! allow zero - sys date
		tmp1$=chkDateFrmt$(tmp$) ! chk/convert to mm/dd/yyyy
		if tmp1$[1,1]<"0" and tmp1$[1,1]>"9" let tmp1$=""
		x$=formatdate2$(tmp1$) ! from mm/dd/yyyy to yyyymmdd
		roh.CmInvHist=x$[3,8] ! H5[10] on native
		if roh.CmInvHist<101 or roh.CmInvHist>991231 let roh.CmInvHist=0
	Endif
	! if roh.ordtype=20 ! orig (done in mx231afi)
	if returnstatus<>0 ! okay up to now
		! get the commission split information
		if SCType
			totPercent = 0
			for i = 0 to 4
				call dxget("SplitRep"+str$(i), tmp$)
				roh.Slsm[i] = tmp$
				if (i = 0 and roh.slsm[i] <> roh.slsmnum)
					let roh.slsm[i]=roh.slsmnum
				end if
				call dxget("Split"+str$(i), tmp$)
				roh.SlsmSplt[i] = tmp$
				if SCType = 2
					call dxget("SplitPct", tmp$)
					roh.SlsmPct[i] = tmp$
				end if
				totPercent = totPercent + roh.SlsmSplt[i]
				for j = 0 to i - 1
					if roh.slsm[j] and roh.slsm[j] = roh.slsm[i]
						returnstatus = 0
						message$ = "Duplicate salesrep defined in commission splits!"
						goto endsubordhdr:
					end if
				next j
			next i
			if SCType = 1 and totPercent <> 100
				returnstatus = 0
				message$ = "Commission splits do not total 100%!"
				goto endsubordhdr:
			end if
			if SCType = 3 and totPercent > 100
				returnstatus = 0
				message$ = "Commission splits cannot total more than 100%!"
				goto endsubordhdr:
			end if
		end if ! sctype
		if orderid<>0
			if origslsm<>roh.slsmnum
				let rohkey3$=" ",rohkey3$
				let rohkey3$[1,3]=roh.slsmnum using "###"
				let rohkey3$[4,9]=orderid using "######"
				search #ch_roh,4,3;rohkey3$,rec_roh,e
				let rohkey3$[1,3]=origslsm using "###"
				let rec_tmp=rec_roh
				search #ch_roh,5,3;rohkey3$,rec_tmp,e
			endif
			if ros.NU$="" let ros.NU$=Blank$ ! NO NULLS!!
			if roh.PriceType=0 let roh.PriceType=cust.PriceType
			write record #ch_roh,rec_roh;roh.;
			write record #ch_ros,roh.shiprec;ros.;
			write record #ch_rot,roh.totrec;rot.;
			if taxcode<>roh.taxcode or taxtype<>ros.shiptaxtype
				clear chan[]
				let chan[1]=ctlc
				let chan[2]=ch_prod !  2 = Product       1792
				let chan[3]=ch_cust !  3 = Customer      1808
				let chan[4]=ch_ros!  4 = order shipto  1856
				let chan[5]=ch_roh!  5 = order header  1840
				let chan[6]=ch_rot!  6 = order total   1872
				let chan[7]=ch_rol!  7 = order lines   1888
				let chan[8]=0     !  8 = product desc  2128(not opened)
				let chan[9]=ch_ctax!  9 = customer tax   928
				let chan[10]=ch_tax! 10 = tax code      2176
				let chan[11]=ch_ccode! 11 = ccodes        1728
				call "mxcalctax",chan[],rec_roh,intco
			endif
			If not(credit) and source<>207 ! record header access
			  If P60$[44,44]="Y" ! edittracking
				clear etr.
				if source let etr.ProdCode$=Str$(Source)+" ACCESS"+Blank$
				If not(source) let etr.ProdCode$="HDR ACCESS"+Blank$
				etr.EtAction=14
				call edttrk()
			  Endif
			Endif
		else ! new order
			returnstatus=1
			UNLock #ctlc ! make sure can rw it
			!DO ! DO LOOP AFTER READING - DON'T RE-READ SAME # (endless loop)
			Let NDisp=86 \ if credit let NDisp=58
			READ #ctlc,20,ndisp;ordnum ! ; ! LOCK IT!!
			DO
				LET ORDNUM=ORDNUM+1
				 IF ORDNUM>999998
					LET RETURNSTATUS=0
					LET MESSAGE$="Order Number have exceeded 999999"
					UNLOCK #CTLC
					goto endsubordhdr:
					exit do
				endif
				let flag=0
				LET keyroh$=" ",keyroh$ \ LET keyroh$[3,8]=ordnum USING "######"        
				FOR ctr=1 TO 99                                        
					LET keyroh$[1,2]=ctr USING "##"                           
					SEARCH #ch_roh,2,1;keyroh$,rec_tmp,E  
					if not(e) let flag=99
				next ctr
				if not (flag) 
					write #ctlc,20,ndisp;ordnum;
					let orderid=ordnum
					exit do
				endif
			loop
			Unlock #CTLC
			if source=251 or source=231 ! point of sale  -- need an invoice # also
				READ #ctlc,20,180;invnum
				LET INVNUM=INVNUM+1
				write #ctlc,20,180;invnum;
				IF INVNUM>99999999
					LET RETURNSTATUS=0
					LET MESSAGE$="Invoice Number have exceeded 99999999"
					goto endsubordhdr:
				endif
				let roh.invnum=invnum
			endif
			Unlock #CTLC
			IF returnstatus=1
				let roh.status=95
				if source=251 or source=231 let roh.status=94 
				if credit let roh.status=97
				IF Source=223 let roh.status=96
				call dxget ("billcustid",BillCustId$)
				let billcustid=billcustid$
				if billcustid>0 and billcustid<=999999
					let roh.billto=billcustid
				else
					if cust.customerbillto>0 and cust.customerbillto<=999999
						let roh.billto=cust.customerbillto
					else
						roh.billto=custid
					endif
				endif
				let roh.custnum=custid
				let roh.ordnum=orderid
				If Not(Credit)
					if roh.shipdate>0 and roh.shipdate<999999
					if custom_customer$="MORRISETTE" or custom_customer$="PIEDMONT"
					 let roh.invdate=currdate
					 else
						let roh.invdate=roh.shipdate
					endif
					ENDIF
				Else
					If roh.InvNum<=0 let roh.InvNum=roh.ordnum
				Endif
				let roh.lockport=rec_uac ! this should be the user access record #
				let roh.dateent=currdate
				!Call Time(SDATE$) 
				! CURTM[0] = SDATE$[15,16]                               
				! CURTM[1] = SDATE$[18,19]                               
				! CURTM[2] = SDATE$[21,22]                               
				! CURTM[3] = CURTM[0] * 10000 + CURTM[1] * 100 + CURTM[2]
				 
				!let roh.timeent=CURTM[3]
				Call Time(SDATE$) 
				CURTM[0] = SDATE$[15,16] 
				Let roh.timeent=curtm[0] 
				CURTM[1] =SDATE$[18,19]
				Let roh.timeent=roh.timeent+(curtm[1]/100)
				let roh.PriceType=cust.PriceType
				let roh.orgstatus=0 ! set to 0 - for hold credit check
				if source=251 and roh.invnum<> 0 let roh.orgstatus=5
				if credit let roh.orgstatus=9
				if source=223 or source=231 let roh.orgstatus=5
				
				! ship to file ! 
				let ros.status=31 \ if credit let ros.status=32
				let ros.ordnum=orderid
				let rot.status=21 \ IF credit let rot.status=22
				let rot.ordnum=orderid
				! new order need tax % in total file mtgtax
				read record #ch_tax,roh.taxcode;tax.;
				let rot.taxpct=tax.TaxRate
				! roh.taxcode
				clear chan[]
				CHAN[0]=CH_ROH
				CHAN[1]=CH_ROS
				CHAN[2]=CH_ROT
				clear tmprec[]

				mode$="a"
				! Write the file
				ros.NU$=Blank$
				roh.Blankforkey$=blank$
				let upstatus=fileupdaterohz(e$,chan[],mode$,tmprec[],roh.,ros.,rot.)
				let rec_roh=tmprec[0]
				let rec_ros=tmprec[1]
				let rec_rot=tmprec[2]
				! if new order and ok so far - update cust last order date
				IF upstatus>=0 and not(credit) ! source=201 or source=208 or source=0
					nwonc=0 ! new order on new customer - invoices are orders!
					if not(credit) and Cust.LastOrderDate<=0 let nwonc=1 ! new order/newcust
					Cust.LastOrderDate=currdate ! ROH.OrdDate
					write record #CH_Cust,Rec_Cust,0;cust.;
				Endif
			endif
		endif ! ! order id
		! if OTChange - add code to do ot conversion
		! If not(credit) ! otchange=orig otype if diff from new otype (credits no onorder update!)
		if otchange or newxfer ! changed or authorized a whse xfer
			clear chan[]
			clear tmprec[]
			chan[1]=ctlc
			chan[2]=ch_prod
			chan[3]=ch_prwh
			chan[4]=ch_cust
			chan[5]=ch_rol
			chan[6]=ch_roh
			tmprec[5]=rec_cust
			tmprec[8]=rec_roh
			call "mx208cnv5.dl4",tmprec[],otchange,chan[],IntCo
			! all it does is change prod/prodwhse update stock flags w/on order update
		Endif
		! check for warehouse change
		if not(credit) AND OLDWHSE<>roh.wh AND P61$[110,110]="Y" AND OLDWHSE<>0
			!  need to verify if items are allow on the new warehouse - chkmtg
			clear s9[]
			let s9[0]=orderid; s9[1]=intco
			let s9[2]=REC_ROH ! usually the slsm #
			let s9[4]=Source ! 201 ! order entry program #
			if credit let s9[4]=241
			If s9[4]=0 and int(roh.orgstatus)=0 and roh.spare2=0
				let S9[4]=201 ! could be 207!
			endif
			if s9[4]=0 let s9[4]=208
			if S9[4]=201 AND (roh.orgstatus>0 and roh.orgstatus<5) let S9[4]=208 ! NOT ENTRY
			let s9[8]=208 ! for the warehouse update
			clear ch[] ! channels for files sent to MXLINEQTY
			cH[0]=CTLC ; CH[1]=CH_ROH; CH[2]=CH_ROL
			CH[3]=CH_PRODLOT;  CH[4]=CH_SORDLOT
			CH[5]=CH_PROD; CH[6]=CH_PRWH
			S9[2]=rec_roh
			CALL "MXLINEQTY.DL4",ch[],rec_roh,roh.wh,S9[],e$,IntCo,rstr$ 
			! FOR MXRASL 
			If Credit Let S9[3] = 4;S9[4] = 243 ! credit                         
			If S9[4] <= 0 Let S9[4] = 208 ! send something!                      
			S9[12] = 0 ! olr ! PASS THE LINE JUST UPDATED (new single line mxrasl5)? 
			CLEAR CH[]
			cH[0]=CTLC ; CH[1]=CH_PROD;  CH[2]=CH_ROH; CH[3]=CH_ROL
			CH[4]=0    ; CH[5]=CH_CCODE; CH[6]=CH_PRODLOT
			CH[7]=0    ; CH[8]=CH_SORDLOT; CH[9]=0
			Call "MXRASL5.DL4",intco,Ctlc,S9[],ch[]
		ENDIF
		! Endif ! CREDITS DO CHANGE STOCK UPDATE FLAG
	endif ! returnstatus=ok!
	endsubordhdr: ! end getting data for submit ord header
	!if returnstatus=0 or orderid=0
	!	call dxsave(0,"tmp/osfail.txt")
	!	call programdump("tmp/osbfl.txt","")
	!endif
	clear list$[]
	List$[0]=bsdel$,"OrderSubmit",fdel$
	WebStr$="OrderId",fdel$
	Webstr$=webstr$,"InvoiceId",fdel$
	webstr$=webstr$,"ORDERAMT",fdel$
	webstr$=webstr$,"ORDERCOST",fdel$
	List$[1]=WebStr$
	WebStr$=str$(orderid),fdel$
	Webstr$=webstr$,str$(roh.invnum),fdel$
	webstr$=webstr$,str$(rot.mdseordamt),fdel$
	webstr$=webstr$,str$(rot.totordcost),fdel$
	LIST$[2]=Webstr$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
	call SetOutPut(e$,rstr$)
	if nwonc ! new order / new cust (any type - ord,inv,etc, excl:credits)
		! send an alert
		clear chan[]
		clear tmprec[]
		tmprec[0]=2 ! alert #2
		chan[1]=ctlc;chan[2]=ch_cust;chan[3]=Ch_sslsm
		chan[4]=ch_roh;chan[5]=ch_ros;chan[6]=ch_rot
		tmprec[1]=rec_cust;tmprec[2]=custid;tmprec[3]=roh.SlsmNum
		tmprec[4]=rec_roh
		clear tmp$
		call "libalertproc.lib",tmprec[],chan[],tmp$
	Endif
	IF P60$[44,44]="Y" ! edit tracking
		clear etr.
		if not(credit) and source<>207
			if oohld<>rot.HoldCode ! hold changed
				if source=0 let source=201
				etr.ProdCode$=Source using "###"
				etr.OrgQtyOrd=oohld
				etr.NewQtyOrd=rot.HoldCode
				etr.EtAction=13 ! set it?
				call edttrk()
			Endif
		Endif
	 Endif ! edittrack hold changes
	! end of SUBMITORDHDR
case "CREDITCHK"
	! This call will check credit limits and past due a/r balances
	call dxget ("custid",CustId$)
	let custid=custid$
	call dxget ("billcustid",BillCustId$)
	let billcustid=billcustid$
	call dxget ("orderid",OrderId$)
	let orderid=Orderid$
	call dxget ("orderamt",OrderAmt$)
	let amount=OrderAmt$
	if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		factor=roh.currfact
		call currconvdown(amount,factor)
		amount=fnr(amount)
	endif
	let ordamt=amount
	!let ordamt=orderamt$
	let returnstatus=1
	let message$="OK"
	if billcustid<=0
		let keycust$=custid using "######"
		mode$="="
		dirno=1
		if custid>0
		CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
		Else
			custrec=-1
		Endif
		if CustRec>=0 ! record found
			let billcustid=cust.customerbillto
	    else ! if custrec
			ReturnStatus=0 ! error not found
			Message$="Customer ",keycust$," not found"
			let billcustid=custid
		endif ! if custrec	!! file get !!
        endif
	let shipcustid=0
	if orderid>0 and orderid<999999
		let keyroh$=" ",keyroh$
		let keyroh$[1,6]=custid using "######"
		let keyroh$[7,12]=orderid using "######"
		keyroh$[13]=""
		mode$="="
		dirno=2
		!clear chan[]
		!CHAN[0]=CH_ROH
		!CHAN[1]=CH_ROS
		!CHAN[2]=CH_ROT
		!Rec_roh=filegetrohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
		SEARCH #CH_ROH,2,2;KEYROH$,REC_ROh,E
		IF E LET REC_ROH=0
		If Rec_roh>0
			
			Read Record #CH_ROH,Rec_roh;roh.;
			Read Record #ch_ros,roh.shiprec;ros.;
			Read Record #CH_ROT,roh.totrec;rot.;
		    if not (ros.shipcust) let ros.shipcust=roh.custnum
			let shipcustid=ros.shipcust
		endif
	endif
	if shipcustid=0 let shipcustid=custid
	clear chan[]
	chan[1] =ctlc    ! cntrl file
    chan[2] =ch_cust ! customer file
	chan[3] = 0	 ! saract file ** not opened **
	chan[4] = 0      ! credit check file ** not opened ** ch_credck
	chan[5] =ch_roh	 ! order header
	chan[6] =ch_rot	 ! order total
	chan[7] =ch_ros	 ! order ship to
	work$=""
	flag=0
	call getcredck(chan[],shipcustid,billcustid,rec_roh,ordamt,intCo,ReturnStatus,Message$,flag,work$)
	clear list$[]
	List$[0]=bsdel$,"CreditCheck",fdel$
	WebStr$="Chktype",fdel$,"Message$",fdel$,"AR Balance",fdel$
	WebStr$=Webstr$,"Open Order Amt",fdel$
	Webstr$=Webstr$,"Standard Terms",fdel$
	Webstr$=Webstr$,"Payment History",fdel$
	Webstr$=Webstr$,"Note1",fdel$
	Webstr$=Webstr$,"Note2",fdel$
	List$[1]=WebStr$
	clear cnotes.
    let arbal=0
	let openordamt=0
	credcoded$=" ",credcoded$
	artermd$=" ",artermd$
	if p61$[119,119]="Y" !IF custom_customer$="FUQUA" 
		if not(flag) ! check if notes and display
			let keycust$=billcustid using "######"
			mode$="="
			dirno=1
			if billcustid>0
				CNoteRec=FileGetCustNotes(e$,Ch_CNotes,mode$,dirno,KeyCust$,cnotes.)
			Else
				cnoterec=-1
			Endif
			if cnoterec<=0
				clear cnotes.
			endif
			
		       let rot.email$=rtrim$(cnotes.email$)
		      
			if rtrim$(cnotes.notesline1$)<>"" or rtrim$(cnotes.notesline2$)<>""
				let webstr$="99",fdel$ ! flag for notes only
				let webstr$=webstr$,"",fdel$ ! message
				let webstr$=webstr$,"",fdel$ ! ar bal
				let webstr$=webstr$,"",fdel$ ! open ord
				let webstr$=webstr$,"",fdel$ ! terms
				let webstr$=webstr$,"",fdel$ ! pay hist
				webstr$=webstr$,cnotes.notesline1$,fdel$
				webstr$=webstr$,cnotes.notesline2$,fdel$
				list$[2]=webstr$
				call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
				Call AddToStr(e$,rstr$,esdel$) ! end of section 
				goto endcredchk: ! end credit check
			endif
		endif
	end if ! custom_customer
	let tmp$=flag using "#"
	let Webstr$=tmp$,fdel$
	let webstr$=webstr$,work$,fdel$
	if flag
		clear cust.
		let keycust$=billcustid using "######"
		mode$="="
		dirno=1
		if billcustid>0
		CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
		else
			custrec=-1
		Endif
		if CustRec>=0 ! record found
			If cust.CreditCode>0 and cust.CreditCode<=16
				let credcoded$=getcredcdd$(ctlc,cust.CreditCode,intco)
			endif
			let openordamt=cust.openorder+ordamt
			let arbal=cust.currentaragebal-cust.unappliedcredit+cust.agearamt1
			let arbal=arbal+cust.agearamt2+cust.agearamt3+cust.agearamt4
			if cust.terms>0 and cust.terms<=99
				let artermd$=getartermd$(ch_terms,cust.terms,intco)	
			endif
		endif
		let keycust$=billcustid using "######"
		mode$="="
		dirno=1
		if billcustid>0
		CNoteRec=FileGetCustNotes(e$,Ch_CNotes,mode$,dirno,KeyCust$,cnotes.)
		Else
			cnoterec=-1
		Endif
		if cnoterec<=0
			clear cnotes.
		endif
	endif
	let tmp$=arbal using  "-$$$$,$$$,$$#.##"
	webstr$=webstr$,tmp$,fdel$
	let tmp$=openordamt using  "-$$$$,$$$,$$#.##"
	webstr$=webstr$,tmp$,fdel$
	webstr$=webstr$,artermd$,fdel$
	webstr$=webstr$,credcoded$,fdel$
	webstr$=webstr$,cnotes.notesline1$,fdel$
	webstr$=webstr$,cnotes.notesline2$,fdel$
	list$[2]=webstr$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	endcredchk: ! end credit check
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)
	
	! add to string
	! create status
	! end of CREDITCHK
case "GETORDERHDR" 
	Dim 2%,invdate, D4SHIP, D4ROUTING
 
	Dim 3%
	call dxget ("custid",Custid$)
	call dxget ("orderid",orderid$)
	call dxget ("shipcustid",shipcustid$)
	!call dxget ("shipcode",shipcode$)
	call dxget ("editstatus",tmp$)
	let editstatus=tmp$
	call dxget ("Source",tmp$)
	let Source=tmp$
	if source=201 or source=208 let source=0 !  USES 0 for them!
	!if credit let source=0;editstatus=0 ! not used as source# in credits & editstatus n/a & n/g
	call dxget ("shipkey",tmp$)
	let shipkey$=""
	if rtrim$(tmp$)
		let tmp4=tmp$
		if not(shipcustid) let shipcustid=int(tmp4)
		let shipcode=int(fra(tmp4)*10^6)
		let shipkey$[1,6]=shipcustid using "######"
		let shipkey$[7,7]="."
		let shipkey$[8,13]=shipcode using "&&&&&&"
		SHIPKEY$[14]=""
	endif
	let custid=custid$
	let orderid=orderid$
	
	LET returnstatus=1
	let message$="OK"
	clear roh.
	let roh.SpareNu$=Blank$[1,2] ! " ",roh.SpareNu$
	clear rot.
	clear ros.
	let linesexist=0
	let ordwh=prt.wh
	let ordtype=0
	if not (orderid) ! new order 
		if source=2082 or source=223 ! order/inv edit - NO NEW ORDERS!!
			let returnstatus=0
			if editstatus<>0 let returnstatus=99
			let message$="Order "+str$(orderid)+" Not on File"
			goto endgetordhdr:
		Endif
		let shipcustid=shipcustid$
		let shipcode=0 ! shipcode$
		if rtrim$(shipkey$)<>""
			let shipcustid=shipkey$[1,6]
			let shipcode=shipkey$[8,13]
		endif
		roh.custnum=custid
		roh.ordnum=0
		ros.shipedit=0
		if not (shipcustid)
			let shipcustid=custid
			let shipcode=0
			let ros.shipedit=0
		endif
		let ros.shipcust=shipcustid
		let keycust$=custid using "######"
		let mode$="="
		let dirno=1
		if custid>0
		CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
		else
			custrec=-1
		Endif
		if custrec<=0
			let returnstatus=0
			if editstatus<>0 let returnstatus=99
			let message$="Customer "+str$(custid)+" Not on File"
			goto endgetordhdr: 
		else ! customer is on file
			if (cust.CommissionByCategory) let SCType = 0 ! force override
			IF credit ! check for whse xfer customer
				if cust.ConsignWh>0 and cust.ConsignWh<consWh
					let returnstatus=0
					if editstatus<>0 let returnstatus=99
					let message$="Customer "+str$(custid)+" Not on valid for Credit"
					goto endgetordhdr: 
				Endif
			Endif
			if prt.div>0
				let roh.div=prt.div ! port default priority
			else
				if cust.division>0
					let roh.div=cust.division
				endif
			endif
			if roh.div<=0 let roh.div=0
			if cust.defaultwhse <> 0  let roh.wh = cust.defaultwhse
			! do always! (62459)
				let keycust$=custid using "######"
				mode$="="
				dirno=1
				CNoteRec=FileGetCustNotes(e$,Ch_CNotes,mode$,dirno,KeyCust$,cnotes.)
				if cnoterec<=0
					clear cnotes.
				endif
			If p61$[136,136]="Y"
				let roh.currid=cnotes.currid
				if p61$[136,136]="Y" and roh.currid<>0		 
					let keycurr$=" ",keycurr$
					let keycurr$=roh.currid using "####"
					search #ch_curr,2,1;keycurr$,rec_curr,e
					if not(e)
						Read Record #ch_curr,rec_curr;curr.;
					else
						let curr.ExcRate=0
						let roh.currid=0
					endif
					let roh.currfact=curr.ExcRate			
				else
					let roh.currfact=0
				endif
			else
				let roh.currid=0
				let roh.currfact=0
			endif				
			let roh.orddate=currdate
			let roh.duedate=currdate
			let roh.shipdate=currdate
			clear sh.
			call findshiplist()
			if shiprec<=0 ! shiprec not found default
				let ros.shipedit=0 ! used the bill to
				let ros.shipcode=shipcode
				let ros.name$=cust.name$
				let ros.address$=cust.addr1$
				let ros.address2$=cust.addr2$
				let ros.city$=cust.city$
				let ros.state$=cust.state$
				let ros.zipcode$=cust.zip4$[1,6]
				let ros.zip4$=cust.zip4$[7,10]
				let ros.country$=cust.country$
				LET ros.truck=0
				let ros.zone$=" ",ros.zone$
				let roh.shipvia$="OUR TRUCK"
				if p61$[34,34]="Y" ! multi-zone customer
					if not (ros.shipcust) let ros.shipcust=custid
					if not (roh.shipdate) let roh.shipdate=roh.orddate
					call "MXOHCSZONE",ros.shipcust,ros.shipcode,roh.orddate,roh.div,roh.wh,roh.shipdate,ros.zone$,roh.stopnum,IntCo
					if rtrim$(ros.zone$)<>""
						let cust.zonenumber$=ros.zone$
						let cust.sStop=roh.stopnum
						if source=251 let roh.shipdate=roh.orddate ! POS - no lead
						let roh.duedate=roh.shipdate
					endif
				endif
				let mode$="="
				let dirno=1
				clear zn.
				ZoneRec=FileGetZonefle(e$,Ch_Zone,mode$,dirno,cust.zonenumber$,zn.)
				if zonerec>0
					let ros.truck=zn.trucknum
					let ros.zone$=cust.zonenumber$
					if rtrim$(zn.shipvia$)<>""
						let roh.shipvia$=zn.shipvia$
					endif
				Else
					let ros.zone$="  " ! "00" ! default zone? (customer may not have)
				endif
				let roh.taxcode=cust.taxcode
				let ros.shiptaxtype=cust.taxtype
				let roh.contact$=cust.contact$
				let roh.slsmnum=cust.salesmancode
				if cust.defaultwhse<>0
					let roh.wh=cust.defaultwhse
				else
					let roh.wh=prt.wh
				endif
				let roh.stopnum=cust.sStop
				let roh.salesarea=cust.custsaleszone
				let rot.delivchrglvl= cust.deliverchglevel

			endif ! ship list not found
			if roh.wh=0 then roh.wh=1
			if source=231! one step ! no delivery charge - see 231 - never set
				!let rot.delivchrglvl=0
			endif
			if source=251 ! point of sales - no delivery charge
				let rot.delivchrglvl=0
			endif
			if sh.ddiv>0 and sh.ddiv<100
				let roh.div=sh.ddiv
			else
				if prt.div>0
					let roh.div=prt.div ! port default priority
				else
					if cust.division>0
						let roh.div=cust.division 
					endif
				endif
			endif
			if roh.div<=0 let roh.div=1
			if cust.defaultordertype>0 and cust.defaultordertype<39 ! check order type
			  let x2=cust.defaultordertype;otv=0
			  if NOT(credit) If ot[x2]=1 let otv=1 ! valid programmed types (eventually ALL)
			  if credit and (x2<4 or x2=6 or x2=10 or x2>27) let otv=1 ! only certain types on credits
			  If otv ! valid - can use it
				let roh.ordtype=cust.defaultordertype
			  Else 
				let roh.ordtype=1
			  Endif
			else 
				let roh.ordtype=1
			endif
			If cust.ConsignWh>0 and cust.ConsignWh<ConsWh
				let roh.ordtype=16 ! force the issue
				roh.ConsWh=cust.ConsignWh
				linesexist=9;ordtype=16 ! force ot list to 16 only
				if p61$[54,54]="N" or source>=231 ! 1step/pos AUTO auth
				  If roh.xferauth=0 and source<>2082 ! only if not already auth
					roh.xferauth=1;roh.authdate=Currdate;roh.authby=rec_uac
				  Endif
				Endif
			Endif
			roh.Source=1
			roh.ShipType=1
			If custom_customer$="JPAPER" and Credit
			   Let roh.ShipType=6  ! "default to a pickup
			Endif
			if prt.entby let roh.entby=prt.entby
			if roh.entby<=0 or roh.entby>999 let roh.entby=999
			if cust.porequiredflag=0 or cust.porequiredflag=2
				let roh.custpo$="VERBAL"
			endif
			if not(Credit) ! not on credits
				clear bpo$
				BPFlag[1]=1
				if shiprec>0 and custid=ros.shipcust
					if ros.shipedit=1 or ros.shipedit=2 let bpflag[1]=9
				endif
				call chkbpo()
				if not(bpflag[2]) and Trim$(BPO$)<>"" ! no issues
					let roh.custpo$=UCase$(BPO$) ! from cust or shiplist
				endif
			ENDIF
			roh.dept=0 ! department
			let roh.terms=cust.terms
			if not(roh.orddate) let roh.orddate=currdate
			if not (roh.duedate) let roh.duedate=currdate
			if not (roh.shipdate) let roh.shipdate=currdate
			if credit let roh.invdate=currdate
			if source=251 or source=231
				READ #ctlc,0,182;INVDATE;
				let roh.orddate=invdate
				let roh.duedate=invdate
				let roh.shipdate=invdate
				let roh.invdate=invdate
				if custom_customer$="ACME" 
					let roh.shipdate=currdate
					let roh.orddate=currdate
				endif
				if source=251 ! and prt.CashSaleCustNum =roh.custnum (NATIVE ANY IN 251)
					 MAT  READ #ctlc,182,68;D4SHIP;
					 IF D4SHIP>16 LET D4SHIP=1
					 if d4ship 
						roh.ShipType=d4ship
					 endif
					 MAT  READ #ctlc,182,72;D4ROUTING;   
					IF D4ROUTING>106 LET D4ROUTING=1 
					 IF D4ROUTING
						tmp$=" ",tmp$
						READ #CTLC,130,(D4ROUTING-1)*12;TMP$[1,12];
						LET roh.ShipVia$=tmp$
					endif
				Endif
			endif
			! get commission splits from cust/shipto
			If SCType>0 ! "commission SPLITTING
				Let tmp$=roh.CustNum Using "######";Flag=0! "custcode and mode=edit
				if ros.ShipEdit = 1 or ros.ShipEdit = 2
					Let tmp$=ros.ShipCust Using "######";tmp$[7,7]="."
					Let tmp$[8,13]=ros.ShipCode Using "&&&&&&"
				Endif
				Call "MXORDSLSM",tmp$,roh.,ch_Sslsm,Flag
				if roh.Slsm[0] <> roh.SlsmNum
					roh.SlsmNum = roh.Slsm[0]
				end if
			End if
			shipdateedit=0
			if not(credit) call calcshipdate()
		endif ! end of customer search
		goto endgetordhdr:
	endif ! of new order
	if orderid<>0
		if not(custid) ! and source=207
			if source=231 ! or source=251 ! ONLY NEW ORDERS!
				RETURNSTATUS=0
				if editstatus<>0 let returnstatus=99
				Message$="You can not edit orders with this program"
				goto endgetordhdr
			Endif
			keyroh$=" ",keyroh$
			keyroh$[3]=orderid using "######"
			For ctr=1 to 99
			  ! If ctr<20 or ctr>25 ! skip delete
				let keyroh$[1,2]=ctr using "##"
				search #ch_roh,2,1;keyroh$,rec_roh,e
				if not (e)
					if ctr>=20 and ctr<=25
						let returnstatus=0
						let message$="Order Has Been Deleted "
						if ctr=22 let message$="Credit Has Been Deleted "
						goto endgetordhdr
					endif
					read record #ch_roh,rec_roh;roh.;
					If source=251
						if editstatus<>0 and roh.status<>94
							let returnstatus=99
							Message$="You can not edit orders with this program"
							goto endgetordhdr
						else
							if roh.status<>59 and roh.status<>58 and roh.status<>94
								RETURNSTATUS=0
								Message$="You can not edit orders with this program"
								goto endgetordhdr
							endif
						endif
					endif
					let custid=roh.CustNum
					If custid<>prt.CashSaleCustNum
						 Custsec[0]=custid;custsec[1]=1 ! id & NO ALERT
						 call "custsec.dl4",Custsec[],ctlc,userid$,e$,rstr$
						 if custsec[0]=-1 ! not allowed
							returnstatus=0 ! ! or is it 99? (99 sends back to MAIN MENU!)
							message$="You do not have access this customer"
							goto endgetordhdr
						Endif
					Endif
					if roh.ordtype<1 or roh.ordtype>38
						let returnstatus=99
						let message$="Order has an invalid order type"
						goto endgetordhdr:
					endif
					if not (ot[roh.ordtype])
						let returnstatus=99
						let message$="Order Type "+str$(roh.ordtype)+" Not Available At This Time"
						goto endgetordhdr:
					endif
					if source=207 
						let editstatus=1
					else
						let editstatus=0
						if ctr<>97 ! not a credit
							if roh.status=95 and roh.lockport = rec_uac and custom_customer$ <> "EDMAR"
								let editstatus=1
							endif
							if source=223 and (roh.status=96 or roh.status=94) and roh.lockport=rec_uac
								let editstatus=1
							Endif
							if source=251 and roh.status=94 and roh.lockport=rec_uac
								let editstatus=1
							endif
						else
							if roh.status=97 and roh.lockport = rec_uac
								let editstatus=1
							endif
						endif
					endif
					linesexist=99
					goto orderidfound:
				endif
			  ! Endif ! cannot chk whole 1-99 range
			next ctr
			let returnstatus=0
			if editstatus<>0 let returnstatus=99
			let returnstatus=99
			let message$="Order Number ",STR$(ORDERID)," Not On File"
			goto endgetordhdr:
			orderidfound: ! ok
			if ctr=97 let credit=99 ! status for credit memo
			if ctr>8 and ctr<12 let credit=99
			!if source=207 let credit=0 ! no diff than order!
			if credit ! counter says credit - are we in cm progs
				if action1$="CREDIT" 
					if source=0 let source=241
					if roh.status<9 and roh.status<>97 let source=208 ! says credit but it's an order!
				Endif
				if source=241 or source=243 or source=207
					rem ! it's ok
				Else
					returnstatus=0
					if editstatus<>0 let returnstatus=99
					message$="You can not edit order "+Str$(orderid)+" here"
					goto endgetordhdr
				Endif
			Else ! it's an order
				if source=241 or source=243
					returnstatus=0
					if editstatus<>0 let returnstatus=99
					message$="You can not edit order "+Str$(orderid)+" here"
					goto endgetordhdr
				Endif
				! need chk for inv edit of order or order edit of inv
				invoice=0
				if ctr>4 and ctr<9 let invoice=1
				if ctr=94 or ctr=96 let invoice=1
				if ctr=58 or ctr=59 let invoice=1
				if invoice
					if source=223 or source=207 or source=251
						if source=251
							if editstatus<>0 and roh.status<>94
								let returnstatus=99
								Message$="You can not edit orders with this program"
								goto endgetordhdr
							else
								if roh.status<>59 and roh.status<>58 and roh.status<>94
									RETURNSTATUS=0
									Message$="You can not edit orders with this program"
									goto endgetordhdr
								endif
							endif
						endif
						rem ! it's ok
					Else
						returnstatus=0
						if editstatus<>0 let returnstatus=99
						message$="You can not edit order "+Str$(orderid)+" here"
						goto endgetordhdr
					Endif
				Else ! it's an order
					if source=223 or source=231 or source=251
						returnstatus=0
						if editstatus<>0 let returnstatus=99
						message$="You can not edit order "+Str$(orderid)+" here"
						goto endgetordhdr
					Endif
				Endif
			Endif
		endif ! of order # only
		keyroh$=" ",keyroh$
		keyroh$[1,6]=custid using "######" 
		keyroh$[7,12]=orderid using "######"
		keyroh$[13]=""
		mode$="=" ! search mode 2
		dir=2
		clear chan[]
		CHAN[0]=CH_ROH
		CHAN[1]=CH_ROS
		CHAN[2]=CH_ROT
		Rec_roh=filegetrohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
		if rec_roh<0
			let returnstatus=0
			if editstatus<>0 let returnstatus=99
			let message$="Order Number ",STR$(ORDERID)," Not On File"
			goto endgetordhdr:
		endif
		! try
			! validate order date
			! tmp$ = roh.orddate using "&&&&&&"
			! call DateToJulian(tmp$)
		! else
			! invalid date
			! let returnstatus=0
			! if editstatus<>0 let returnstatus=99
			! let message$="GETORDERHDR: Invalid order date detected.  Please call support to correct!"
			! goto endgetordhdr:
		! end try
		if custid<=0 let custid=roh.Custnum
		if custid<>roh.CustNum and roh.custnum>0 let custid=roh.custnum ! use order customer!
		let keycust$=custid using "######"
		let mode$="="
		let dirno=1
		if custid>0
			CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
		else
			custrec=-1
		Endif
		if custrec<=0
			let returnstatus=0
			if editstatus<>0 let returnstatus=99
			let message$="Customer "+str$(custid)+" Not on File"
			goto endgetordhdr: 
		endif ! customer is on file
		if (cust.CommissionByCategory) let SCType = 0 ! force override
		if ros.status=32 let Credit=99
		!if source=207 let credit=0 ! use order send
		If source=207 goto sethdrfields:
		if editstatus<>0 ! it MUST BE 90+
			if source=251 or source=231 ! point of sale
				if roh.status<>94 ! and roh.status<>58 and roh.status<>59
					let returnstatus=0
					if editstatus<>0 let returnstatus=99
					let message$="Order Number ",str$(orderid)," Is not in Edit Status"
					goto endgetordhdr:
				else
					goto checkordtype:
				endif
				
			endif
			if not(credit) and roh.status<>95
			  If source<>223
				let returnstatus=0
				if editstatus<>0 let returnstatus=99
				let message$="Order Number ",str$(orderid)," Is not in Edit Status"
				goto endgetordhdr:
			  Else ! inv edit
				if roh.status<>96 and roh.status<>94 ! not inv edit
					let returnstatus=0
					if editstatus<>0 let returnstatus=99
					let message$="Order Number ",str$(orderid)," Is not in Edit Status"
					goto endgetordhdr:
			    Endif
			  Endif
			endif
			if credit and roh.status<>97
				let returnstatus=0
				if editstatus<>0 let returnstatus=99
				let message$="Order Number ",str$(orderid)," Is not in Edit Status"
				goto endgetordhdr:
			endif
		else ! check if is 90+?
			if roh.status=94 and (source=251 or source=231) and roh.lockport=rec_uac
				let editstatus=1
				goto checkordtype:
			endif
			if source=251
				if roh.status=59 goto checkordtype:
				if roh.status=58 goto checkordtype:
				if roh.status=94 and roh.lockport=rec_uac
					let editstatus=1
					goto checkordtype:
				endif
			endif
			if roh.status=95 and roh.lockport=rec_uac and custom_customer$ <> "EDMAR"
				let editstatus=1
				goto checkordtype:
			endif
			if source=223 and (roh.status=96 or roh.status=94) and roh.lockport=rec_uac
				let editstatus=1
				goto checkordtype:
			endif
			if source=251 and roh.status=94 and roh.lockport=rec_uac
				let editstatus=1
				goto checkordtype:
			endif
			if credit and roh.status=97 and roh.lockport=rec_uac
				let editstatus=1
				goto checkordtype:
			endif
			if not(credit) and source<>223 and roh.status>4 
				let returnstatus=0
				if editstatus<>0 let returnstatus=99
				let message$="Order Number ",str$(orderid)," May Not Be Edited"
				goto endgetordhdr:
			endif
			if not(credit) and source=223
				if (roh.status<5 or roh.status>maxiedstat)
					let returnstatus=0
					if editstatus<>0 let returnstatus=99
					let message$="Order Number ",str$(orderid)," May Not Be Edited"
					goto endgetordhdr:
				endif
			endif
			if credit and roh.status>10
				let returnstatus=0
				if editstatus<>0 let returnstatus=99
				let message$="Order Number ",str$(orderid)," May Not Be Edited"
				goto endgetordhdr:
			endif
		endif
		checkordtype: ! check the order type
		if roh.ordtype>38 ! 4
			let returnstatus=0
			if editstatus<>0 let returnstatus=99
			let message$="Order Number ",str$(orderid)," Invalid Type for Edit"
			goto endgetordhdr:
		endif
		If not(credit)
		  If SOURCE=0 or SOURCE=2082 or (source>200 and Source<210 and source<>207) ! orders (0/201/208 - added max order edit status)
			If roh.status<20 and roh.status>maxeditstatus
				returnstatus=0
				if editstatus<>0 let returnstatus=99
				message$="You can not edit this status"
				goto endgetordhdr
			Endif
			if roh.status>24 and roh.orgstatus>maxeditstatus ! check inprocess
				returnstatus=0
				if editstatus<>0 let returnstatus=99
				message$="You can not edit this status"
				goto endgetordhdr
			Endif
			if roh.status=1 and maxeditstatus=1 and ros.OnPickList$="2"
				if p61$[98,98]="Y"! if picklist to make a status 2
					returnstatus=0
					if editstatus<>0 let returnstatus=99
					message$="You can not edit order - IT IS ON PICK LIST!"
					goto endgetordhdr
				Endif
			Endif
			if ros.Roadnet=2 and not(roadnetedit)
				returnstatus=0
				if editstatus<>0 let returnstatus=99
				message$="Updated to Roadnet - You can not edit this order"
				goto endgetordhdr
			Endif
		  Endif ! source check
		  if source=223 or source=221
			if ros.Roadnet=2 and not(roadnetedit)
				returnstatus=0
				if editstatus<>0 let returnstatus=99
				message$="Updated to Roadnet - You can not edit this order"
				goto endgetordhdr
			Endif
		  Endif
		  clear roc.
		  if not (ch_roc)
			Try
				ch_roc = OpenFile(2224,IntCo)
			else
				let ch_roc=-1
			end try
		  endif
		  if ch_roc>0
				let keyroc$=orderid using "######" 
				rec_roc = filegetsordcash(e$,Ch_roc,"=",1,keyroc$,roc.)
				if rec_roc<0 clear roc.
		  endif
			If int(roc.PayType1)=3 and Ucase$(roc.ccauthtype$[1,1])="P" 
					returnstatus=0
					if editstatus<>0 let returnstatus=99
					message$="Order Has Been Post Authorized - You can not edit this order"
					goto endgetordhdr! no ed
			endif
		 	If int(roc.PayType2)=3 and Ucase$(roc.ccauthtype$[2,2])="P"  ! no delete	!!! 
				returnstatus=0
				if editstatus<>0 let returnstatus=99
				message$="Order Has Been Post Authorized - You can not edit this order"
				goto endgetordhdr! no ed
			endif
		Endif ! orders - check maxeditstatus
		if editstatus=0 ! 
			let roh.orgstatus=roh.status
			let roh.lockport=rec_uac
			let roh.status=95
			if source=251 or source=231 let roh.status=94 ! point of sales
			if credit let roh.status=97
			if source=223 let roh.status=96
			let keyroh$=" ",keyroh$
			let keyroh$[1,2]=roh.status using "##"
			let keyroh$[3,8]=orderid using "######"
			search #ch_roh,4,1;keyroh$,rec_roh,e
			if roh.status<>roh.orgstatus
				let keyroh$[1,2]=roh.orgstatus using "##"
				search #ch_roh,5,1;keyroh$,rec_tmp,e
			Endif
			! roh.orgstatus=0
			write record #ch_roh,rec_roh;roh.;
		endif
		linesexist=0
		let keyrol$=" ",keyrol$;keyrol$=orderid using "######"
		search #ch_rol,3,1;keyrol$,rec_rol,e
		if not (e)
			let tmp3=keyrol$[1,6]
			if tmp3=orderid let linesexist=99
		endif
		sethdrfields: ! set header fields
		let ordwh=roh.wh
		let ordtype=roh.ordtype
		let shipkey$=""
		if ros.shipedit>0 and ros.shipedit<5
			let shipkey$[1,6]=ros.shipcust using "######"
			let shipkey$[7,7]="."
			let shipkey$[8,13]=ros.shipcode using "&&&&&&"
			shipkey$[14]=""
		endif
		if ros.shipedit=4 and ros.shipcode=0
			let shipkey$="" ! bill to another customer code
		endif
		! get commission splits from cust/shipto
		If SCType>0 ! "commission SPLITTING
			Let tmp$=roh.CustNum Using "######";Flag=1! "custcode and mode=edit
			if not(editstatus) flag = 2
			if ros.ShipEdit = 1 or ros.ShipEdit = 2
				Let tmp$=ros.ShipCust Using "######";tmp$[7,7]="."
				Let tmp$[8,13]=ros.ShipCode Using "&&&&&&"
			Endif
			Call "MXORDSLSM",tmp$,roh.,ch_Sslsm,Flag
			if roh.Slsm[0] <> roh.SlsmNum
				roh.SlsmNum = roh.Slsm[0]
			end if
		End if
		endgetordhdr: ! ***** stop here for sections ****
	else ! of order<>0?
		! load defaults
	endif
	if ordwh<=0 let ordwh=roh.wh
	if ordtype<=0 let ordtype=roh.ordtype
	!if roh.ordtype=4 or roh.ordtype=19 or roh.ordtype>35
	!	let returnstatus=0
	!	let message$="Order Type "+str$(roh.ordtype)+" Not Available At This Time"
	!	goto endgetordhdr:
	!endif
	! section 1 - warehouse droplist
	! check if allow to change warehouse
	let tmp3=linesexist
	if linesexist<>0 and p61$[110,110]="Y" and roh.orgstatus<6
		Dim filename$[50],KEYOrdT$[10],1%,WHSECHG,3%,rec_ordt	
		filename$="3/SORDTYPE"+STR$(INTCO)
		Call FindF(FILENAME$,FOUND)
		if found<>0
			Ch_ORDT=findchannel()
			ropen #ch_ordt,filename$
			let keyordt$=ordtype using "##"
			search #ch_ordt,2,1;keyordt$,rec_ordt,e
			if not(e)
				read #ch_ordt,rec_ordt,32;whsechg;
				if whsechg=1 let tmp3=0 ! 
			else
				if ordtype=2 or (ordtype=3 and p60$[22,22]="N")
				! direct order or indirect and update stock=N then change warehouse
					let tmp3=0 ! default to change warehouse if not record is set
				endif
			endif
		endif
	endif
	call OrdWhDroplist(List$[],orderid,tmp3,ordtype,ordwh) ! tmp3=linesexist
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	!Call AddToStr(e$,rstr$,esdel$) ! end of section
	! section 2 - order type droplist
	call OrdTypelist(List$[],orderid,linesexist,ordtype,ordwh)
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	! section 3 - order header detail
	Clear List$[]                                                         
	List$[0] = bsdel$ + "OrdHShipInfo" + fdel$ ! section name
	webstr$="CustId",fdel$
	webstr$=webstr$,"ShipCustId",fdel$
	webstr$=webstr$,"OrderId",fdel$
	!webstr$=webstr$,"ShipCode",fdel$
	webstr$=webstr$,"ShipName",fdel$
	webstr$=webstr$,"ShipAddr1",fdel$
	webstr$=webstr$,"ShipAddr2",fdel$
	webstr$=webstr$,"ShipCity",fdel$
	webstr$=webstr$,"ShipState",fdel$
	webstr$=webstr$,"ShipZip",fdel$
	webstr$=webstr$,"Country",fdel$
	webstr$=webstr$,"ShipEdit",fdel$
	webstr$=webstr$,"Truck",fdel$
	webstr$=webstr$,"droplistdzonefle",fdel$ ! zone
	webstr$=webstr$,"TaxCode",fdel$
	webstr$=webstr$,"TaxDesc",fdel$
	webstr$=webstr$,"TaxType",fdel$ 
	webstr$=webstr$,"Shipkey",fdel$
	webstr$=webstr$,"TaxTypeDesc",fdel$
	webstr$=webstr$,"allowshipedit",fdel$
	webstr$=webstr$,"HOLDSCRN",fdel$ ! used in quotes - here to keep same
	webstr$=webstr$,"ALLOWDELETE",fdel$ ! can user delete ord/inv/credit
	webstr$=webstr$,"SHIPREQ",fdel$
	webstr$=webstr$,"ALLOWEDIT",fdel$ ! can user edit the order
	WebStr$=WebStr$,"PREMIERCUST",fdel$ ! is a premier customer Y/N
	let list$[1]=webstr$
	if returnstatus<>0 ! no errors send over the data
		webstr$=str$(roh.custnum),fdel$
		if not (ros.shipcust) let ros.shipcust=roh.custnum
		webstr$=webstr$,str$(ros.shipcust),fdel$
		webstr$=webstr$,str$(roh.ordnum),fdel$
		!webstr$=webstr$,str$(ros.shipcode),fdel$
		tmp$=clrtxtc$(e$,ros.name$)
		webstr$=webstr$,tmp$,fdel$
		tmp$=clrtxtc$(e$,ros.address$)
		webstr$=webstr$,tmp$,fdel$
		tmp$=clrtxtc$(e$,ros.address2$)
		webstr$=webstr$,tmp$,fdel$
		tmp$=clrtxtc$(e$,ros.city$)
		webstr$=webstr$,tmp$,fdel$
		tmp$=clrtxtc$(e$,ros.state$)
		webstr$=webstr$,tmp$,fdel$
		webstr$=webstr$,ros.zipcode$,ros.zip4$,fdel$
		tmp$=clrtxtc$(e$,ros.country$)
		webstr$=webstr$,tmp$,fdel$
		webstr$=webstr$,str$(ros.shipedit),fdel$
		webstr$=webstr$,str$(ros.truck),fdel$
		webstr$=webstr$,ros.zone$,fdel$
		if roh.taxcode<1 or roh.taxcode>7999
			let roh.taxcode=cust.taxcode
		endif
		webstr$=webstr$,str$(roh.taxcode),fdel$
		taxcoded$=gettaxcdd$(ch_tax,roh.TaxCode,intco)
		webstr$=webstr$,taxcoded$,fdel$
		webstr$=webstr$,str$(ros.shiptaxtype),fdel$ 
		webstr$=webstr$,shipkey$,fdel$
		custtaxtyped$=getcusttaxtyd$(ch_ctax,ros.shipTaxType,intco)
		webstr$=webstr$,custtaxtyped$,fdel$
		let tmp$="N"
		if cust.ManualShiplist<>0 let tmp$="Y"
		webstr$=webstr$,tmp$,fdel$
		tmp$="Y" \ if credit let tmp$="N" ! no cm holds!
		webstr$=webstr$,tmp$,fdel$ ! HOLD SCREEN=Y
		tmp$="Y"
		if not(credit) ! if they're in credits - they can delete them?
			if source<=220 and ucf$[1,1]="N" let tmp$="N" ! ord
			if source>220 and ucf$[2,2]="N" let tmp$="N" ! inv
			if source=207 or source=239 let tmp$="N" ! inquiry
			if source=231 or source=251 let tmp$="Y" ! can delete if new entry?
			if source=2082 let tmp$="N" ! can only chg order line qty! NO ORD DELETE
		endif
		clear roc.
		if not (ch_roc)
			Try
				ch_roc = OpenFile(2224,IntCo)
			else
				let ch_roc=-1
			end try
		  endif
		if ch_roc>0
			let keyroc$=orderid using "######" 
			rec_roc = filegetsordcash(e$,Ch_roc,"=",1,keyroc$,roc.)
			if rec_roc<0 clear roc.
		endif
		If int(roc.PayType1)=3 and Ucase$(roc.ccauthtype$[1,1])="P" let tmp$="N" ! no delete
		If int(roc.PayType2)=3 and Ucase$(roc.ccauthtype$[2,2])="P" let tmp$="N" ! no delete
		webstr$=webstr$,tmp$,fdel$ ! can user delete this
		let tmp$="N" ! shiplist required
		if not(orderid) and not(credit) and p61$[44,44]="Y" and ros.shipcode=0 and roh.custnum=ros.shipcust and ros.shipedit<>5
			! check if multiple shiplist exists
			shipkey$=" ",shipkey$
			let shipkey$[1,6]=ros.shipcust using "######"
			let shipkey$[7,7]="."
			let shipkey$[8,13]="000000"
			search #ch_ship,3,1;shipkey$,tmp3,e
			if not(e)
				let tmp3=shipkey$[1,6]
				if tmp3=ros.shipcust
					let tmp$="Y"
				endif
			endif
		endif
		if source=231 let tmp$="N"
		webstr$=webstr$,tmp$,fdel$
		! allow edit
		let tmp$="Y"
		if source=2082 let tmp$="N" ! user can only change line qty! NO HEADER EDIT
		! check if card card payment and the credit card has been post authorized
		If int(roc.PayType1)=3 and Ucase$(roc.ccauthtype$[1,1])="P" let tmp$="N" ! allow edit
		If int(roc.PayType2)=3 and Ucase$(roc.ccauthtype$[2,2])="P" let tmp$="N" !
		webstr$=webstr$,tmp$,fdel$
		! premier customer flag
		tmp$="N" \ if cnotes.PRMCUST$="A" or cnotes.PRMCUST$="S" let tmp$="Y"
		webstr$=webstr$,tmp$,fdel$
		let list$[2]=webstr$
	endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	
	! section 4 - order header field
	Clear List$[]                                                         
	List$[0] = bsdel$ + "OrdHeaderInfo" + fdel$ ! section name
	webstr$="CustId",fdel$
	webstr$=webstr$,"OrderId",fdel$
	if source<>223
		webstr$=webstr$,"OrderDate",fdel$
	Else ! ord date becomes Invc Date
		webstr$=webstr$,"InvoiceDate",fdel$
	Endif
	webstr$=webstr$,"PO",fdel$
	webstr$=webstr$,"droplistsslsm",fdel$ ! sslsm
	webstr$=webstr$,"droplistartermcode",fdel$
	webstr$=webstr$,"Attn",fdel$
	If not(credit)
		webstr$=webstr$,"ShipDate",fdel$
	Else
		webstr$=webstr$,"DateInvd",fdel$
	Endif
	webstr$=webstr$,"droplistdeptfle",fdel$
	webstr$=webstr$,"droplistordwh",fdel$
	if not(credit)
		webstr$=webstr$,"DueDate",fdel$
		webstr$=webstr$,"ShipTermList",fdel$
	Else
		webstr$=webstr$,"Weight",fdel$
		webstr$=webstr$,"CMTypeList",fdel$
	Endif
	webstr$=webstr$,"RoutingList",fdel$
	webstr$=webstr$,"droplistentdby",fdel$
	webstr$=webstr$,"StopNum",fdel$
	webstr$=webstr$,"droplistordtype",fdel$
	webstr$=webstr$,"droplistdivifle",fdel$
	If not(credit)
		webstr$=webstr$,"droplistsorce",fdel$
	Else
		webstr$=webstr$,"CMDate",fdel$
	Endif
	webstr$=webstr$,"SalesArea",fdel$
	webstr$=webstr$,"Dclvl",fdel$
	webstr$=webstr$,"InvoiceId",fdel$
	
	! Per Web team - if ot 16 send fields now
	If roh.ordtype=16 ! add the header						doc=OrdH.GetOrderHdr16.doc
		webstr$=webstr$,"XFRTOWH",fdel$
		webstr$=webStr$,"XFERAUTH",fdel$
		webStr$=WebStr$,"XADATE",fdel$
		webstr$=webStr$,"XAUSER",fdel$
	Endif
	if roh.ordtype=7 or roh.ordtype=8 ! header field		doc=OrdH.GetOrderHdr78.doc
		webstr$=webstr$,"CONSWH",fdel$
	Endif
	! if new "std" fields added - will need to be after the ot16 fields!
	if roh.ordtype=9 ! add header fields					doc=OrdH.GetOrderHdr9.doc
		webStr$=webstr$,"STAGINGAREA",fdel$
	Endif
	if roh.ordtype=4 or roh.ordtype=15 or roh.ordtype=24 !  doc=OrdH.GetOrderHdr15.doc
		webstr$=webstr$,"SHIPTERM",fdel$
		! shipping dates?? are separate call
	Endif
	IF roh.ordtype=5 ! future
		webstr$=webstr$,"ALCSTKDATE",fdel$
	Endif
	if roh.ordtype=20 ! fgt inv
		webstr$=webstr$,"ORIGINV",fdel$
	Endif
	if not (credit) and source<221
		webstr$=webstr$,"OnPickList",fdel$ ! add to the end
	endif
	webstr$=webstr$,"Status",fdel$ !
	webstr$=webstr$,"ORIGORDID",fdel$ ! original order # - 2890
	!if custom_customer$="RUTHERFORD"
	webstr$=webstr$,"ABC",fdel$ ! task #21596 Rutherford !
	webstr$=webstr$,"CreditCode",fdel$ ! task#24516 
	!else
	!	webstr$=webstr$,"",fdel$
	!endif
	if not(credit) ! task 45120 - rebill order #
		webstr$=webstr$,"REBILLORDER",fdel$
	else
		webstr$=webstr$,"",fdel$
	endif
	IF P61$[136,136]="Y" 
		let tmp$="CURRENCY"
	ELSE
		let tmp$=""
	endif
	let webstr$=webstr$,"CURRENCY",fdel$ ! CURRENCY
	let webstr$=webstr$,"ONRFQUEUE",fdel$ ! is it on RF PICK Q?
	let list$[1]=webstr$
	if returnstatus<>0 ! no errors send over the data
		webstr$=str$(roh.custnum),fdel$
		webstr$=webstr$,str$(roh.ordnum),fdel$
		if source=251 or source=223 or source=231
			if roh.InvDate
				let xdate$=pdate$(roh.InvDate)
			else
				let xdate$=" ",xdate$
			endif
		else
			if roh.orddate
				let xdate$=pdate$(roh.orddate)
			else
				let xdate$=" ",xdate$
			endif
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! order date or invoice date
		WebStr$=WebStr$,RTrim$(roh.custpo$),fdel$ ! po#
		WebStr$=WebStr$,Str$(roh.slsmnum),fdel$ ! salesman number
		Webstr$=webstr$,str$(roh.terms),fdel$ ! terms
		tmp$=clrtxtc$(e$,roh.contact$)
		Webstr$=webstr$,tmp$,fdel$ ! contact
		if roh.shipdate
			if roh.shipdate<>999999
				let xdate$=pdate$(roh.shipdate)
			else
				let xdate$="999999"
			endif
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! ship date (date inv'd - credit)
		Webstr$=WebStr$,str$(roh.dept),fdel$ ! department
		webstr$=webstr$,str$(roh.wh),fdel$ ! warehouse
		If not(credit)
			if roh.duedate
				let xdate$=pdate$(roh.duedate)
			else
				let xdate$=" ",xdate$
			endif
			WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! due date
		Else
			WebStr$=WebStr$,str$(roh.ActWgt),fdel$ ! act wgt
		Endif
		webstr$=webstr$,str$(roh.ShipType),fdel$
		if trim$(roh.shipvia$)="" let roh.shipvia$="OUR TRUCK"
		webstr$=webstr$,rtrim$(roh.shipvia$),fdel$
		webstr$=webstr$,str$(roh.EntBy),fdel$
		webstr$=webstr$,str$(roh.stopnum),fdel$
		webstr$=webstr$,str$(roh.OrdType),fdel$
		webstr$=webstr$,str$(roh.div),fdel$
		if not(credit)
			webstr$=webstr$,str$(roh.Source),fdel$
		Else
			if roh.InvDate
				let xdate$=pdate$(roh.InvDate)
			else
				let xdate$=" ",xdate$
			endif
			WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! cm date
		Endif
		webstr$=webstr$,str$(roh.salesarea),fdel$
		webstr$=webstr$,str$(rot.delivchrglvl),fdel$
		webstr$=webstr$,str$(roh.InvNum),fdel$
		
		! now send the ot16 fields
		if roh.ordtype=16 ! send the data
			webstr$=webStr$,Str$(roh.ConsWh),fdel$
			if p61$[54,54]="N" or source>=231 ! NOT USING or 1step/pos
			  if roh.xferauth=0 and source<>2082 ! only if not prev auth
				roh.xferauth=1;roh.authdate=Currdate;roh.authby=rec_uac
			  Endif
			Endif
			tmp$="N" \ if roh.XferAuth let tmp$="Y"
			webstr$=webstr$,tmp$,fdel$
			let tmp$="0" \ if roh.XferAuth and roh.AuthDate let tmp$=PDate$(roh.AuthDate)
			webstr$=webstr$,tmp$,fdel$
			tmp$=" " \  if roh.XferAuth and roh.AuthBy let tmp$=Getuidinfo$(E$,IntCo,roh.AuthBy)
			webstr$=webStr$,RTrim$(tmp$[21]),fdel$
		Endif
		if roh.ordtype=7 or roh.ordtype=8
			webstr$=webstr$,Str$(roh.ConsWh),fdel$
		Endif
		If roh.ordtype=9 ! send data
			webstr$=Webstr$,RTrim$(roh.WhStage$),fdel$
		Endif
		if roh.ordtype=4 or roh.ordtype=15 or roh.ordtype=24
			webstr$=webstr$,Str$(roh.shipterm),fdel$
			! dates? are sep call
		Endif
		if roh.ordtype=5 ! future
			tmp$=""
			if roh.CmInvHist let tmp$=Pdate$(roh.CmInvHist)
			webstr$=webstr$,tmp$,fdel$
		Endif
		if roh.ordtype=20 ! frgt inv
			webstr$=webstr$,Str$(roh.OrgOrd),fdel$
		Endif
		if not (credit) and source<221
			let tmp$="N"
			if ros.OnPicklist$="2" let tmp$="Y"
			webstr$=webstr$,tmp$,fdel$
		endif
		
		let tmp3=roh.status
		if source<>207 and roh.status>94 and roh.OrgStatus<94
			if roh.OrgStatus let tmp3=roh.OrgStatus
		endif
		tmp$=tmp3 using "&&"
		if tmp3>=1 and tmp3<12
			let x2=tmp3
			tmp$=tmp$+"-"+STATWORD$[x2*10-9,x2*10]
		else
			if tmp3=58 let tmp$=tmp$+ "-Order Being Picked"
			if tmp3=59 let tmp$=tmp$+ "-Order Is On Hold"
			if tmp3=94 let tmp$=tmp$+ "-POS Ord Erp Proc"
			if tmp3=95 let tmp$=tmp$+ "-Order Erp Proc"
			if tmp3=96 let tmp$=tmp$+ "-Invoice Erp Proc"
			if tmp3=97 let tmp$=tmp$+ "-Credit Erp Proc"
		Endif
		webstr$=webstr$,tmp$,fdel$ ! status
		if roh.orgord
			webstr$=webstr$,Str$(roh.OrgOrd),fdel$ ! origorder
		Else
			webstr$=webstr$,"",fdel$ ! none
		Endif
		!if custom_customer$="RUTHERFORD"
			WEBSTR$=webstr$,str$(cust.AbcScore),fdel$
		!else
		!	webstr$=webstr$,"",fdel$
		!endif
		If cust.CreditCode>0 and cust.CreditCode<=16
			let credcoded$=getcredcdd$(ctlc,cust.CreditCode,intco)
			let webstr$=webstr$,str$(cust.creditcode),"-",credcoded$,fdel$
		else
			let webstr$=webstr$,"",fdel$
		endif
		if not(credit) ! task 45120
			webstr$=webstr$,Str$(ROH.OrgOrd1),fdel$
		else
			webstr$=webstr$,"",fdel$
		endif
		if p61$[136,136]="Y" and roh.currid<>0
			let keycurr$=" ",keycurr$
			let keycurr$=roh.currid using "####"
			search #ch_curr,2,1;keycurr$,rec_curr,e
			if not(e)
				Read Record #ch_curr,rec_curr;curr.;
				let tmp$=roh.currid using "####"
				let tmp$=tmp$+" "
				let tmp$=tmp$+rtrim$(curr.desc$)
				let webstr$=webstr$,tmp$,fdel$
			else
				let webstr$=webstr$,"",fdel$
			endif
		else
			let webstr$=webstr$,"",fdel$ ! currency
		endif
		! on rf pick queue
		if p61$[135,135] = "Y" AND ros.OnPicklist$="2" AND source=0 ! (201,208)
			let webstr$=webstr$+"Y"+fdel$
		else
			let webstr$=webstr$+"N"+fdel$
		end if
		let list$[2]=webstr$
	endif ! of no errors - send data
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	! section 5 commission split section
	Clear List$[]                                                         
	List$[0] = bsdel$ + "CommissionSplitInfo" + fdel$ ! section name
	webstr$="SplitFlag",fdel$
	for i = 0 to 4
		webstr$=webstr$+"SplitRep"+str$(i)+fdel$
	next i
	for i = 0 to 4
		webstr$=webstr$+"Split"+str$(i)+fdel$
	next i
	for i = 0 to 4
		webstr$=webstr$+"SplitPct"+str$(i)+fdel$
	next i
	list$[1]=webstr$
	if returnStatus <> 0
		webstr$ = str$(SCType)+fdel$
		for i = 0 to 4
			webstr$=webstr$+str$(roh.Slsm[i])+fdel$
		next i
		for i = 0 to 4
			webstr$=webstr$+str$(roh.SlsmSplt[i])+fdel$
		next i
		for i = 0 to 4
			webstr$=webstr$+str$(roh.SlsmPct[i])+fdel$
		next i
		list$[2]=webstr$
	end if
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	! Call dxsave(0,"/tmp/md.txt!")
	! status section *** last section ***
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! Call programdump("tmp/md.txt!","")
	! done with it
        call SetOutPut(e$,rstr$)
	! end of GETORDERHDR
case "CHECKSPLIT"
	! called in the event a different shiplist is selected - see
	! if there is a new commission split defined at that
	! level
	clear roh.
	clear list$[]
	call dxget("shipkey", tmp$)
	let shipkey$=""
	if rtrim$(tmp$)<>""
		call dxget("salesrep", tmp$)
		roh.SlsmNum = tmp$
		call dxget("shipkey", tmp$)
		let tmp4=tmp$
		let shipcustid=int(tmp4)
		let shipkey$[1,6]=shipcustid using "######"
		if pos(tmp$,= ".")
			let shipcode=int(fra(tmp4)*10^6)
			let shipkey$[7,7]="."
			let shipkey$[8,13]=shipcode using "&&&&&&"
			shipkey$[14]=""
			Call "MXORDSLSM",shipkey$,roh.,ch_Sslsm,3
		else
			let shipkey$[7] = ""
			Call "MXORDSLSM",shipkey$,roh.,ch_Sslsm,0
		end if
	endif
	list$[0]=bsdel$,"CommissionSplitInfo"+fdel$
	webstr$="NewTable"+fdel$
	for i = 0 to 4
		webstr$ = webstr$+"SplitRep"+str$(i)+fdel$
	next i
	for i = 0 to 4
		webstr$ = webstr$+"Split"+str$(i)+fdel$
	next i
	for i = 0 to 4
		webstr$ = webstr$+"SplitPct"+str$(i)+fdel$
	next i
	list$[1]=webstr$
	if roh.Slsm[0] ! got a new tables
		webstr$="1"+fdel$
	else
		webstr$="0"+fdel$
	end if
	for i = 0 to 4
		webstr$ = webstr$+str$(roh.Slsm[i])+fdel$
	next i
	for i = 0 to 4
		webstr$ = webstr$+str$(roh.SlsmSplt[i])+fdel$
	next i
	for i = 0 to 4
		webstr$ = webstr$+str$(roh.SlsmPct[i])+fdel$
	next i
	list$[2]=webstr$
	list$[3]=esdel$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	let returnstatus=1
	let message$="OK"
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)
	! end of CHECKSPLIT
case "VERIFYORDID" 
	
	Dim 3%
	LET returnstatus=1
	let message$="OK"
	call dxget ("custid",Custid$)
	call dxget ("orderid",orderid$)
	
	call dxget ("Source",tmp$)
	let Source=tmp$
	if source<>207 
		Let returnstatus=0
		let message$="Invalid Source Submitted"
		goto endverordid:
	endif
	
	let custid=custid$
	let orderid=orderid$
        if not (orderid) ! new order 
		
			let returnstatus=0
			let message$="Order "+str$(orderid)+" Not on File"
			goto endverordid:
        endif
	clear roh.
	let roh.SpareNu$=Blank$[1,2] ! " ",roh.SpareNu$
	clear rot.
	clear ros.
	
	if not(custid) ! and source=207
		keyroh$=" ",keyroh$
		keyroh$[3]=orderid using "######"
		For ctr=1 to 99
		  !If ctr<20 or ctr>25 ! skip delete
			let keyroh$[1,2]=ctr using "##"
			search #ch_roh,2,1;keyroh$,rec_roh,e
			if not (e)
				if ctr>=20 and ctr<=25
						let returnstatus=0
						let message$="Order Has Been Deleted "
						if ctr=22 let message$="Credit Has Been Deleted "
						goto endverordid:
					endif
				read record #ch_roh,rec_roh;roh.;
				let custid=roh.CustNum
				if source=207 
					let editstatus=1
				endif
				
				goto verordidfound:
			endif
		  !Endif ! cannot chk whole 1-99 range
		next ctr
		let returnstatus=0
		let message$="Order Number ",STR$(ORDERID)," Not On File"
		goto endverordid:
	else
		keyroh$=" ",keyroh$
		keyroh$[1,6]=custid using "######" 
		keyroh$[7,12]=orderid using "######"
		keyroh$[13]=""
		mode$="=" ! search mode 2
		dir=2
		clear chan[]
		CHAN[0]=CH_ROH
		CHAN[1]=CH_ROS
		CHAN[2]=CH_ROT
		Rec_roh=filegetrohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
		if rec_roh<0
			let returnstatus=0
			let message$="Order Number ",STR$(ORDERID)," Not On File"
			goto endverordid:
		endif
		let ctr=roh.status
		verordidfound: ! ok
 		if source=207 let credit=0 ! no diff than order!
		if ctr=97 let credit=99 ! status for credit memo
		if ctr>8 and ctr<12 let credit=99
	 endif ! of order # only
		
	 if custid<=0 let custid=roh.Custnum
		
	endverordid: ! end verifying if order exists
	! section 1 - order header field
	Clear List$[]                                                         
	List$[0] = bsdel$ + "OrdInqType" + fdel$ ! section name
	webstr$="CustId",fdel$
	webstr$=webstr$,"OrderId",fdel$
	webstr$=webstr$,"Status",fdel$
	Webstr$=webstr$,"Credit",fdel$

	list$[1]=webstr$
	let row=2
	if returnstatus<>0
		webstr$=str$(custid),fdel$
		webstr$=webstr$,str$(orderid),fdel$	
		let tmp3=roh.status
		tmp$=tmp3 using "&&"
		if tmp3>=1 and tmp3<12
			let x2=tmp3
			tmp$=tmp$+"-"+STATWORD$[x2*10-9,x2*10]
		else
			if tmp3=58 let tmp$=tmp$+ "-Order Being Picked"
			if tmp3=59 let tmp$=tmp$+ "-Order Is On Hold"
			if tmp3=94 let tmp$=tmp$+ "-POS Ord Erp Proc"
			if tmp3=95 let tmp$=tmp$+ "-Order Erp Proc"
			if tmp3=96 let tmp$=tmp$+ "-Invoice Erp Proc"
			if tmp3=97 let tmp$=tmp$+ "-Credit Erp Proc"
		Endif
		webstr$=webstr$,tmp$,fdel$ ! status
		let tmp$="N"
		if credit<>0 let tmp$="Y"
		webstr$=webstr$,tmp$,fdel$
		
		let list$[row]=webstr$
		row=row+1
	endif ! of no errors - send data
	list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	! Call dxsave(0,"/tmp/md.txt!")
	! status section *** last section ***
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)

!!! END VERIFYORDID

case "GETZONEINFO"
	call dxget ("custid",Custid$)
	let custid=custid$
	call dxget ("orderid",orderid$)
	let orderid=orderid$
	call dxget ("shipdateedit",tmp$)
	let shipdateedit=tmp$ !(0- recalc, 1- do not recalc)
	call dxget ("droplistzonefle",tmp$)
	let ros.zone$=tmp$+"  "
	call dxget ("shipdate",tmp$)
	if tmp$<>"999999"
		xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
		roh.shipdate=xdate$[3,8]
	else
		let roh.shipdate=999999
	endif
	call dxget ("duedate",tmp$)
	xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
	roh.duedate=xdate$[3,8]
	call dxget ("orderdate",tmp$) ! in mm/dd/yyyy
	call VerifyDate(tmp$,xdate$,e)
	if e ! not good
		let returnstatus=0
		let message$="GETZONEINFO: Invalid order header date, please correct."
	end if
	roh.orddate = xdate$ ! yymmdd
! 	xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
! 	let roh.orddate=xdate$[3,8]
	call dxget ("Truck",tmp$)
	let ros.truck=tmp$
	call dxget ("routinglist",tmp$)
	let roh.shipvia$=tmp$+Blank$
	let returnstatus=1
	let message$="OK"
	clear zn.
	let mode$="="
	let dirno=1
	ZoneRec=FileGetZonefle(e$,Ch_Zone,mode$,dirno,ros.zone$,zn.)
	if zonerec>0
	  if custom_customer$<>"ATHENS" ! no change on zone change
		let ros.truck=zn.trucknum 
		if rtrim$(zn.shipvia$)<>"" 
			let roh.shipvia$=zn.shipvia$
		endif
	  Else
		if ros.truck=0 let ros.truck=zn.trucknum ! only if orig=0
		if rtrim$(roh.shipvia$)="" and rtrim$(zn.shipvia$)<>"" 
			let roh.shipvia$=zn.shipvia$
		endif ! only change if original is blank/null
	  Endif
		if shipdateedit=0
			call calcshipdate()	
		endif
	else
		let returnstatus=0
		let message$="Zone "+ros.zone$+" Not On File"
	endif
	!!! send over headings
	Clear List$[]                                                         
	List$[0] = bsdel$ + "ZoneInfo" + fdel$ ! section name
	webstr$="Truck",fdel$
	webstr$=webstr$,"droplistdzonefle",fdel$ ! zone
	webstr$=webstr$,"ShipDate",fdel$
	webstr$=webstr$,"DueDate",fdel$
	webstr$=webstr$,"RoutingList",fdel$
	let list$[1]=webstr$
	if returnstatus<>0 ! no errors send over the data
		webstr$=str$(ros.truck),fdel$
		webstr$=webstr$,ros.zone$,fdel$
		if roh.shipdate
			if roh.shipdate<>999999
				let xdate$=pdate$(roh.shipdate)
			else
				let xdate$="999999"
			endif
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! ship date
		if roh.duedate
			let xdate$=pdate$(roh.duedate)
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! due date
		if trim$(roh.shipvia$)="" Let roh.shipvia$="OUR TRUCK"
		webstr$=webstr$,rtrim$(roh.shipvia$),fdel$
		let list$[2]=webstr$
	endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	               
	! status section *** last section ***
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	
	! done with it
        call SetOutPut(e$,rstr$)
	!!! send over fields
	! end of GETZONEINFO
case "SUBMITORDMSG"
	call dxget ("SOURCE",tmp$)
	let source=tmp$
	if source=201 or source=208 let source=0 !  USES 0 for them!
	if source=207
		let returnstatus=0
		message$="No Update. Inquiry Only"
		goto EndOrdMsgSubmit
	endif
	call dxget ("orderid",orderid$)
	let orderid=orderid$
	let returnstatus=1
	let message$="OK" ! null need to append with errors 
	if not(orderid)
		let returnstatus=0
		let message$="Order Number "+str$(orderid)+" Not on File"
		goto EndOrdMsgSubmit:
	else

		keyroh$=" ",keyroh$
		keyroh$[3]=orderid using "######"
		For ctr=94 to 97 
			let keyroh$[1,2]=ctr using "##"
			search #ch_roh,2,1;keyroh$,rec_roh,e
			if not (e)
				read record #ch_roh,rec_roh;roh.;
				goto chkordmsgstat:
			endif
		next ctr
		For ctr=1 to 93
			  If ctr<20 or ctr>25 ! skip delete
				let keyroh$[1,2]=ctr using "##"
				search #ch_roh,2,1;keyroh$,rec_roh,e
				if not (e)
					read record #ch_roh,rec_roh;roh.;
					goto chkordmsgstat:
				endif
			endif
		next ctr
		let returnstatus=99
		let message$="Order Number "+str$(orderid)+" Not on File"
		goto EndOrdMsgSubmit:
		chkordmsgstat: !!!!
		if returnstatus<>0
			call verifystat()
			if returnstatus=99 goto EndOrdMsgSubmit:
		endif
		let keyrom$=" ",keyrom$
		let keyrom$=orderid using "######"
		dir=1
		mode$=">"
		DO	! removes existing message lines
			dir=1
			mode$=">"
			rec_tmp=filegetrom(e$,ch_rom,mode$,dir,keyrom$,rom.)
			if rec_tmp<=0 exit do
			let tmp3=keyrom$[1,6]\if tmp3<>orderid exit do
			if rom.ordnum<>orderid
				let rom.ordnum=orderid
				let rom.space$=" ",rom.space$
				write record#ch_rom,rec_tmp;rom.;
			endif
	                mode$ = "d" ! delete                                              
			UpdStatus = fileupdaterom(e$,ch_rom,mode$,rec_tmp,rom.)
		loop
	
		call dxget("ttlmsg",tmp$)
		let totctr=tmp$
		If totctr>=1
		for ctr=1 to totctr
			clear rom.
			call dxget ("message"+str$(ctr),tmp$)
			tmp1$=clrtxtc$(e$,tmp$) ! chk/clr control chars
			let rom.message$=tmp1$+Blank$
			call dxget ("messagetypeid"+str$(ctr),tmp$)
			let msgtype=tmp$
			let rom.ordnum=orderid
			let rom.messageline=((msgtype*100)+1)
			let rom.space$=" ",rom.space$
			let keyrom$=" ",keyrom$
			let keyrom$[1,6]=orderid using "######"
			do
				let keyrom$[7,9]=rom.messageline using "###"
				search #ch_rom,2,1;keyrom$,rec_tmp,e
				if e exit do
				let tmp3=keyrom$[1,6]
				if tmp3<>orderid exit do
				let rom.messageline=rom.messageline+1
				if rom.messageline>999
					let returnstatus=0
					let message$="Message Line Number Exceeds Limit of 999"
					exit do
				endif
				if msgtype<>9
					if rom.messageline>=((msgtype*100)+201) ! 
						let returnstatus=0
						let message$="Message Line Number Exceeds Parameters"
						exit do
					endif
				endif
			loop
			If returnstatus<>0 ! no error add it in
				mode$ = "a" ! delete                                              
				UpdStatus = fileupdaterom(e$,ch_rom,mode$,rec_tmp,rom.)		
			endif
		next ctr
		endif ! === if totctr>=1
	endif
	EndOrdMsgSubmit: ! 
	clear list$[]
	List$[0]=bsdel$,"OrdMsgSubmit",fdel$
	WebStr$="OrderId",fdel$
	List$[1]=WebStr$
	WebStr$=str$(orderid),fdel$
	LIST$[2]=Webstr$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)
	! end of SUBMITORDMSG
case "GETORDMSG"
	! section 1 - Message Type Droplist
	call dxget ("SOURCE",TMP$)
	let source=tmp$
	if source=201 or source=208 let source=0 !  USES 0 for them!
	clear list$[]
	List$[0]=bsdel$,"MessageTypeDroplist",fdel$
	WebStr$="ID",fdel$
	WebStr$=Webstr$,"Desc",fdel$
	List$[1]=WebStr$
	let row=2
	! if source<>207 ! not inquiry
	for ctr=0 to 9
		let tmp$=rtrim$(msglist$[((ctr*16)+1),((ctr*16)+16)])
		if tmp$<>""
			webstr$=str$(ctr),fdel$
			webstr$=webstr$,tmp$,fdel$
			List$[row]=WebStr$
			let row=row+1
		endif
	next ctr
        ! endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! section 2 - Order Messages
	call dxget ("orderid",orderid$)
	let orderid=orderid$
	let returnstatus=1
	let message$="OK" ! null need to append with errors 

	if not(orderid)
		let returnstatus=0
		let message$="Order Number "+str$(orderid)+" Not on File"
	else
		For ctr=1 to 99
			If ctr<20 or ctr>25 ! skip delete
				let keyroh$[1,2]=ctr using "##"
				search #ch_roh,2,1;keyroh$,rec_roh,e
				if not (e)
					read record #ch_roh,rec_roh;roh.;
					goto endordmsgchk:
				endif
			endif
		next ctr
		let returnstatus=99
		let message$="Order Number "+str$(orderid)+" Not on File"	
	endif
	endordmsgchk: ! end checking for the order message
	clear list$[]
	List$[0]=bsdel$,"OrderMessages",fdel$
	WebStr$="Message",fdel$
	WebStr$=Webstr$,"MessageTypeID",fdel$
	Webstr$=Webstr$,"MessageTypeDesc",fdel$
	List$[1]=WebStr$
	let ctr=2
	if returnstatus<>0
		let keyrom$=" ",keyrom$
		let keyrom$=orderid using "######"
		dir=1
		mode$=">"
		DO	! removes existing message lines
			rec_tmp=filegetrom(e$,ch_rom,mode$,dir,keyrom$,rom.)
			if rec_tmp<=0 exit do
			let tmp3=keyrom$[1,6]\if tmp3<>orderid exit do
	                let msgtype=0 ! invoice
			if rom.messageline>200 and rom.messageline<401
				let msgtype=2 ! order
			endif
			if rom.messageline>400 and rom.messageline<601
				let msgtype=4 ! invoice/order
			endif
			if rom.messageline>600 and rom.messageline<801
				let msgtype=6 ! Bill of Lading
			endif
			if rom.messageline>800 and rom.messageline<1001
				let msgtype=8 ! Internal
			endif
			tmp$=clrtxtc$(e$,rom.message$) ! chk/clr control chars
			WebStr$=RTrim$(tmp$),fdel$ ! rom.message$,fdel$
			WebStr$=Webstr$+str$(msgtype),fdel$
			let tmp$=rtrim$(msglist$[((msgtype*16)+1),((msgtype*16)+16)])
			Webstr$=Webstr$,tmp$,fdel$
			List$[ctr]=WebStr$
			let ctr=ctr+1
		loop
	endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! special message section
	clear list$[]
	!if source<>207
		Ch_spmsg = OpenFile(-1776,intCo) \ If ch_spmsg = -1 Error 42
		Call FileDropListSpecMsg(e$,List$[],maxcnt,Ch_spmsg)
		Try Close #ch_spmsg Else Rem
	!else
		!List$[0]=bsdel$,"droplistspecmsg",fdel$
		!WebStr$="ID",fdel$
		!WebStr$=Webstr$,"Message",fdel$
		!List$[1]=WebStr$
		!List$[2]=esdel$
	!endif
	 Call AddToStr(e$,rstr$,List$[])  
	 !Call AddToStr(e$,rstr$,esdel$) ! end of section
	 
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)
	! end of GETORDMSG 
case "GETORDHOLD" 
	call dxget ("custid",Custid$)
	call dxget ("orderid",orderid$)
	call dxget ("source",tmp$)
	let source=tmp$
	let custid=custid$
	let orderid=orderid$
	LET returnstatus=1
	let message$="OK"
	keyroh$=" ",keyroh$
	keyroh$[1,6]=custid using "######" 
	keyroh$[7,12]=orderid using "######"
	keyroh$[13]=""
	mode$="=" ! search mode 2
	dir=2
	clear chan[]
	CHAN[0]=CH_ROH
	CHAN[1]=CH_ROS
	CHAN[2]=CH_ROT
	Rec_roh=filegetrohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
	if rec_roh<0
		let returnstatus=99
		let message$="Order Number ",keyroh$[7,12]," Not On File"
	endif
	clear cust.
	let keycust$=custid using "######"
	mode$="="
	dirno=1
	if custid>0
		CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
	endif
	oohld=rot.HoldCode
	clear holddesc$[]
	clear holdpswd$[]
	clear holdcodeflag[]
	if source=207
		! unpack the holdcode into flag from bit flag field
		  tmp3=rot.holdcode 
		  for ctr=1 to 12   
 			LET holdcodeflag[ctr]=SGN(FRA(tmp3/2))
			LET tmp3=INT(tmp3/2)
		  next ctr
		  for ctr=1 to 12
			read #ctlc,65,((ctr*16)-16);holddesc$[ctr];
			read #ctlc,66,((ctr*16)-16);holdpswd$[ctr];
		 next ctr
		  goto endordholdchk: ! end the order hold check
	endif
	let orgamt=fnr(rot.MdseOrdAmt)
	let orgcost=fnr(rot.TotOrdCost)
	if returnstatus<>0 ! no errors have occured
		let billcustid=roh.billto
		for ctr=1 to 12
			read #ctlc,65,((ctr*16)-16);holddesc$[ctr];
			read #ctlc,66,((ctr*16)-16);holdpswd$[ctr];
		next ctr
		clear ex[]
		overpswd$=""
		Ch_exlist = openfile(1760,intCo) \ If Ch_exlist = -1 Error 42     !"order lines file
		if ch_exlist>0
			mat read #ch_exlist,0,0;overpswd$;
			mat read #ch_exlist,roh.ordtype,0;ex;
			try close #ch_exlist  Else Rem
		endif
		! unpack the holdcode into flag from bit flag field
		  tmp3=rot.holdcode 
		  for ctr=1 to 12   
 			LET holdcodeflag[ctr]=SGN(FRA(tmp3/2))
			LET tmp3=INT(tmp3/2)
		  next ctr
		  call dxget ("orderamt",OrderAmt$)
		  let amount=OrderAmt$
		  if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			factor=roh.currfact
			call currconvdown(amount,factor)
			amount=fnr(amount)
		  endif
		  let ordamt=amount
		  call dxget ("ordercost",tmp$)
		  !let tmp3=tmp$
		  !let ordcost=tmp$
		  let amount=tmp$
		  if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
				factor=roh.currfact
				call currconvdown(amount,factor)
				amount=fnr(amount)
		  endif
		  let tmp3=amount
		  let ordcost=amount
		  !let rot.mdseordamt=ordamt
		  !let rot.totordcost=tmp3
		  let j6$=" ",j6$
		  let j6$[1,6]=roh.OrdNum using "######"
		  ordamt=0
		  ordcost=0
		  do ! go thru order lines
			search #ch_rol,3,1;j6$,r[11],e
			if e<>0 exit do
			Let X2=J6$[1,6] \ If X2<>roh.OrdNum exit do
			read record #ch_rol,r[11];rol.;
			let ordamt=ordamt+rol.extordamt
			let ordcost=ordcost+rol.extloadord
		  loop
		  LET DOchCHK=1;aflag[0]=holdcodeflag[1]
		  if credit<>0 let dochchk=0
		  if source<>201 and source<>231 and source<>251 let dochchk=0
		  if returnstatus=0 let dochchk=0
	      if roh.holdover<>0 let dochchk=0
		  if custom_customer$="MORRISETTE" and dochchk<>0
				if roh.orgstatus>0 and roh.orgstatus<9 let dochchk=0! no credit check
		  endif
		  if custom_customer$="PIEDMONT" and dochchk<>0
				if roh.orgstatus>0 and roh.orgstatus<9 let dochchk=0! no credit check
		  endif
	      if dochchk<>0 and ordamt>0 and fnr(orgamt)<fnr(ordamt)
				if source=201 or source=231! credit limit check 
					! check for credit limit pct
					mat read #ctlc,115,48;credpct;
					if credpct>0
						clear cust.
						let keycust$=custid using "######"
						mode$="="
						dirno=1
						if custid>0
							CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
							if cust.CreditCheckDays>0 and cust.CreditCheckDays<999
								let tmp3=cust.CreditLimit*(credpct/100)
								if tmp3-ordamt<=0 and tmp3-orgamt>0
									let returnstatus=2
									let message$="This Order is Equal To Or Greater Than "+str$(credpct)+" Percent of Credit Limit"
									if  rtrim$(holdpswd$[1])<>"" ! has a password check for credit
										let holdcodeflag[1]=1;aflag[1]=1  ! failed credit check
									endif
								endif 
							endif
						endif
					endif
				endif
				clear ch[] ! channels for files sent to order total
				LET CH[2]=CH_ZONE;CH[3]=CH_PROD;CH[4]=CH_COMCDE;CH[5]=CH_CUST             
				LET CH[6]=CH_PRWH;CH[7]=CH_ROS;CH[8]=CH_ROH;CH[9]=CH_ROT;CH[10]=CH_ROL    
				LET CH[11]=CH_SPRODDESC;CH[12]=CH_CTAX;CH[13]=CH_SSLSM;CH[14]=CH_TAX
				LET CH[15]=CH_SPRODLOT;CH[16]=CH_SORDLOT;CH[17]=CH_CCODE;ch[19]=ch_misc
				LET CH[20]=CH_TERMS
				clear s9[]
				let s9[0]=orderid
				let s9[1]=intco
				let s9[2]=roh.slsm
				let s9[4]=Source ! order edit program #
				if credit let s9[4]=241
				! use source except 201/208 (is 0)
				If S9[4]=0 and roh.orgstatus=0 and roh.spare2=0
					let S9[4]=201 ! new order (could be 207!)
				endif
				IF S9[4]=0 LET S9[4]=208
				if S9[4]=201 AND (roh.orgstatus>0 and roh.orgstatus<5) let S9[4]=208 ! NOT ENTRY
				! it seems web always sends source as 201? for entry & edit?
				R5 = custrec ;H1 = REC_ROH;V1 = slsmrec
				clear param[]
				param[0]=0 !cred check 
				param[1]= 0 ! no credit check 0 !no cred check
				If roh.orgstatus=0 let param[1]=1 ! credit check new order
				
				!! if source=231 let param[1]=1
				param[2]=0 !no exception check
				IF Fnr(ORGAMT)<>fnr(ORDAMT) OR fnr(ORDCOST)<>fnr(ORGCOST) LET PARAM[2]=1 ! CHECK EXCEPTION -- THINGS HAVE CHANGED
				param[3]=1 !write total data out
				param[4]=1 !no retotal of customer on order
				if p60$[40,40]="S" let param[4]=1! retotal on order if based on shipped
				param[5]=0 !do no clear manual edits
				param[6]=0 !do not clear cash
				! param[9]=99 !do not calc delivery charges
				MAT  READ #CH_ROT,roh.totrec,0;T1       
				MAT  READ #CH_ROT,roh.totrec,8;T2     
				MAT  READ #CH_ROT,roh.totrec,168;MCODE  
				MAT  READ #CH_ROT,roh.totrec,208;MCHARGE
				MAT  READ #CH_ROT,roh.totrec,328;TOT    
				MAT  READ #CH_ROT,roh.totrec,358;MCTXBL 
				MAT  READ #CH_ROT,roh.totrec,378;DCLVL;
				PARAM[8]=99 ! bypass freight charge calc
				If S9[4]=0 and roh.orgstatus=0 and roh.spare2=0
					let param[8]=0! calc freight Charge
				endif
				IF fnr(ORGAMT)<>fnr(ORDAMT) OR fnr(ORDCOST)<>fnr(ORGCOST) LET PARAM[8]=0
				param[9]=0 ! delivery charges
				let param[10]=99 ! ar term calc
				if p61$[138,138]="Y" let param[10]=0
				if t2[10]<>0 let param[9]=99 ! bypass cash sale delivery charges	
				! if s9[4]=231 let param[9]=99 ! bypass one step delivery charge
				if s9[4]=251 let param[9]=99 ! bypass point of sale delvery charge
				if s9[4]=223 let param[9]=99 ! bypass calc on invoice edit					
				if s9[4]=223 and p61$[36,36]="Y" and roh.spare2<>88
					let param[9]=0 ! need to calc
				endif
				if p61$[138,138]="Y"
					IF fnr(ORGAMT)<>fnr(ORDAMT) OR fnr(ORDCOST)<>fnr(ORGCOST)
						let param[10]=0
					else
						let param[10]=99
					endif
					if s9[4]=201 or s9[4]=208
						let param[10]=99
					endif			
				endif
				if s9[4]=201 and t2[24]<>0 let param[9]=99 ! order entry in an edit mode!
				! IF ROH.ORDNUM=7040 Call dxsave(0,"/tmp/mtg.txt!") ! programdump("tmp/ordh3!","")
				IF S9[4]=208 
					if t2[24]=0 and ordamt<>0
						let param[9]=0! need to check if it from 201 or 208
					else
						let param[9]=99
					endif
				endif
				if source=231
					if t2[24]=0 and t2[0]=0 let param[1]=1
					if not(roh.spare2)
						let param[1]=1 ! credit check
						let param[9]=0 ! delivery charges
						let param[8]=0 ! freight charges need calc
						! if p61$[136,136]="Y" let param[10]=0 
					else
						if not(param[1])
							if ordamt>0 and fnr(orgamt)<fnr(ordamt) let param[1]=1 ! order amt changed
						endif
						let param[9]=99 ! bypass on edit delivery charges
					endif
					if not(roh.spare2) let roh.spare2=99 ! edit mode
				endif		
				if source=251 and t2[24]=0 and t2[0]=0 and t2[10]=0 let param[1]=1
                if custom_customer$="PHILLIPS" !task#14117/cct#173357
					if source=251
						if roh.ordtype=1 let param[1]=0
						if roh.ordtype=3 let param[1]=0
						if roh.ordtype=12 let param[1]=0
					endif
				endif
				if custid>0 and custrec>0
					if cust.CreditCheckDays=0 let param[1]=0 ! no credit check 
				endif
				if custom_customer$="MORRISETTE" and param[1]=1
					if roh.orgstatus>0 and roh.orgstatus<9 let param[1]=0 ! no credit check
				endif
				if custom_customer$="PIEDMONT" and param[1]=1
					if roh.orgstatus>0 and roh.orgstatus<9 let param[1]=0 ! no credit check
				endif
				let orgamt=fnr(t2[24])
				let orgcost=fnr(t2[14])
				let orgwgt=fnr(t2[16])
				 If P60$[16,16] = "Y"     ! GETORDHOLD    
					orgshipdate = roh.ShipDate 
					orgtotwgt = T2[16]         
				End If        
				Call "ORDERTOTAL",S9[],H1,PARAM[],ch[],T1[],T2[],MCODE[],MCHARGE[],TOT[],MCTXBL[],DCLVL,R5,V1,CFIN[]
				read record #ch_roh,rec_roh;roh.;
				read record #ch_rot,roh.totrec;rot.;
				read record #ch_ros,roh.shiprec;ros.;
				let roh.spare2=99
				if p61$[36,36]="Y" and roh.spare2<>88 ! delivery charge on inv
					if s9[4]=231 or s9[4]=223 or s9[4]=251
						let roh.spare2=88
					endif
				endif
				write record #ch_roh,rec_roh;roh.;
				If P60$[16,16] = "Y" And abs(orgtotwgt-rot.TotWgt)<1 And orgshipdate <> 999999   ! GETORDHOLD                                                                          
					Read Record #ch_roh,rec_roh;roh.;                                   
					If orgshipdate <> roh.ShipDate And orgshipdate <> 0                 
						roh.ShipDate = orgshipdate                                        
						Write Record #ch_roh,rec_roh;roh.;                                
					End If                                                              
				End If                                                                
				 tmp3=rot.holdcode
				for ctr=1 to 12   
 					LET holdcodeflag[ctr]=SGN(FRA(tmp3/2))
					LET tmp3=INT(tmp3/2)
				next ctr
				if holdcodeflag[1] and not(aflag[0]) let aflag[1]=1 ! now on credhold
				if credit clear holdcodeflag[] ! no holds on credit
				if roh.ordtype=16 or roh.ordtype=20 or roh.ordtype=8 clear holdcodeflag[] ! no hold on wh xfer
				if roh.ordtype=37 clear holdcodeflag[] ! no hold on EVAP
			else
				if roh.totrec>0
					if rot.mdseordamt<>ordamt or rot.totordcost<>ordcost
						let rot.mdseordamt=ordamt
						let rot.totordcost=ordcost
						write Record #ch_rot,roh.totrec;rot.;
					endif
				endif
		    endif
	
		  dochchk=1 ! do it
		  if credit let dochchk=0
		  if roh.ordtype=20 or roh.ordtype=16 or roh.ordtype=8 let dochchk=0 ! not on frgt/xfer
		  if roh.ordtype=37 let dochchk=0 ! EVAP no
		  if dochcHk=1
			if not(rot.holdcode) and roh.orgstatus=0 and not(orgamt)
				let dochchk=1
			else
				if orgamt<ordamt
					let dochchk=1 ! order amount changed and is for more
				else
					let dochchk=0
				endif
			endif
		  endif
		  if custom_customer$="MORRISETTE" and dochchk<>0
					if roh.orgstatus>0 and roh.orgstatus<9 let dochchk=0 ! no credit check
		  endif
		  if custom_customer$="PIEDMONT" and dochchk<>0
					if roh.orgstatus>0 and roh.orgstatus<9 let dochchk=0 ! no credit check
		  endif
		  if source=231 and orgamt=0 and ordamt<>0 let dochchk=1
 		  if not (roh.holdover)
			if dochchk<>0 ! and not(rot.holdcode) and roh.orgstatus=0! not in hold over ride
				read #ctlc,66,0;holdpswd$[1];! credit check
					if rtrim$(holdpswd$[1])<>"" ! ! do credit check
						call ordhcreditcheck()	
						if flag and rtrim$(holdpswd$[1])<>"" ! has a password check for credit
							let holdcodeflag[1]=1;aflag[1]=1  ! failed credit check
						endif
					else
						let holdcodeflag[1]=0;aflag[1]=0
					endif
					If custom_customer$<>"MORRISETTE" AND custom_customer$<>"PIEDMONT"! always on everyone else
						call onholdchk()
					Else ! is morrisette
						if source<>201 ! no whole order gtm check in 201
							call onholdchk()
						Endif
					Endif
					if credit clear holdcodeflag[] ! no holds on credit
					if roh.ordtype=16 or roh.ordtype=20 or roh.ordtype=8 clear holdcodeflag[] ! no hold on wh xfer
					if roh.ordtype=37 clear holdcodeflag[] ! no hold on EVAP
			else
				if fnr(orgamt)<>fnr(ordamt) or fnr(orgcost)<>fnr(ordcost)
					! need to check if amt or cost changes for gp
					call onholdchk()
				endif
			endif ! if dochchk
		endif ! if dochk
		
	endif ! status<>0
	
	endordholdchk: ! end the order hold check
	! section 1 - order header detail
	Clear List$[]                                                         
	List$[0] = bsdel$ + "OrdHoldHdr" + fdel$ ! section name
	webstr$="CustId",fdel$
	webstr$=webstr$,"OrderId",fdel$
	webstr$=webstr$,"HoldOverRide",fdel$
	webstr$=webstr$,"OverRidePassword",fdel$
	webstr$=webstr$,"Note1",fdel$
	webstr$=webstr$,"Note2",fdel$
	let list$[1]=webstr$
	row=2
	if returnstatus<>0 ! no errors send over the data
		webstr$=str$(roh.custnum),fdel$
		webstr$=webstr$,str$(roh.ordnum),fdel$
		webstr$=webstr$,str$(roh.holdover),fdel$
		webstr$=webstr$,rtrim$(overpswd$),fdel$
		if holdcodeflag[1]<>0
			let keycust$=roh.BillTo using "######"
			mode$="="
			dirno=1
			CNoteRec=FileGetCustNotes(e$,Ch_CNotes,mode$,dirno,KeyCust$,cnotes.)
			if cnoterec<=0
				clear cnotes.
			endif
			webstr$=webstr$,rtrim$(cnotes.notesline1$),fdel$
			webstr$=webstr$,rtrim$(cnotes.notesline2$),fdel$
		else
			webstr$=webstr$,"",fdel$
			webstr$=webstr$,"",fdel$
		endif
		let list$[row]=webstr$
		let row=row+1
	endif
	List$[row]=esdel$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	! Call AddToStr(e$,rstr$,esdel$) ! end of section
	! section 2 - order hold code  fields
	Clear List$[]                                                         
	List$[0] = bsdel$ + "OrdHoldDet" + fdel$ ! section name
	webstr$="ID",fdel$
	webstr$=webstr$,"Description",fdel$
	webstr$=webstr$,"Password",fdel$
	webstr$=webstr$,"Value",fdel$
	let list$[1]=webstr$
	row=2
	if returnstatus<>0 ! no errors send over the data
		for ctr=1 to 12
			webstr$=str$(ctr),fdel$
			webstr$=webstr$,holddesc$[ctr],fdel$ ! hold code description
			webstr$=webstr$,rtrim$(holdpswd$[ctr]),fdel$ ! hold code password
			webstr$=webstr$,str$(holdcodeflag[ctr]),fdel$ ! hold code value
			let list$[row]=webstr$
			row=row+1
		next ctr
	endif
	list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	! Call AddToStr(e$,rstr$,esdel$) ! end of section
	! status section *** last section ***
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! Call dxsave(0,"/tmp/md.txt!")
	! done with it
     call SetOutPut(e$,rstr$)
	 if aflag[0]<>0 and aflag[1]<>0 let aflag[1]=0 ! was already on hold, not new
	 if aflag[1] and source<>207 ! just put on credithold
		call dochalert()
	 Endif
	 IF P60$[44,44]="Y" ! edit tracking
			clear etr.
			if not(credit) and source<>207
				! not writing holds here - but sending them as "held"!!
				! let tmp3=0 ! does re-read after ordertotal!
				!for ctr=0 to 11
				!	IF holdcodeflag[ctr+1] LET tmp3=tmp3+2^ctr   
				!next ctr
				!rot.holdcode=tmp3
				if oohld<>rot.HoldCode ! hold changed
					etr.ProdCode$=Source using "###"
					etr.OrgQtyOrd=oohld
					etr.NewQtyOrd=rot.HoldCode
					etr.EtAction=13 ! set it?
					call edttrk()
				Endif
			Endif
	 Endif ! edittrack hold changes
	 ! end of getordhold

case "SUBMITORDHOLD"
	call dxget ("SOURCE",tmp$)
	let source=tmp$
	! if source=201 or source=208 let source=0 !  USES 0 for them!
	if source=207
		let returnstatus=0
		message$="No Update. Inquiry Only"
		goto EndOrdHoldSubmit
	endif
	call dxget ("custid",Custid$)
	call dxget ("orderid",orderid$)
	call dxget ("HoldOverRide",tmp$)
	
	let custid=custid$
	let orderid=orderid$
	LET returnstatus=1
	let message$="OK"
	keyroh$=" ",keyroh$
	keyroh$[1,6]=custid using "######" 
	keyroh$[7,12]=orderid using "######"
	keyroh$[13]=""
	mode$="=" ! search mode 2
	dir=2
	clear chan[]
	CHAN[0]=CH_ROH
	CHAN[1]=CH_ROS
	CHAN[2]=CH_ROT
	Rec_roh=filegetrohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
	if rec_roh<0
		let returnstatus=99
		let message$="Order Number ",keyroh$[7,12]," Not On File"
	else
		if returnstatus<>0
			call verifystat()
			IF returnstatus=99 GOTO ENDORDHOLDSUBMIT
		endif
		oohld=rot.HoldCode
		call dxget ("HoldOverRide",tmp$)
		let roh.holdover=tmp$
		if roh.orgstatus=0 and roh.spare2=0
			let roh.spare2=1 ! edit status
			!let roh.orgstatus=1 ! set to 0 - for hold credit check
			!if source=251 and roh.invnum<> 0 let roh.orgstatus=5
			!if credit let roh.orgstatus=9
			!if source=223 or source=231 let roh.orgstatus=5
		endif
		Write Record # ch_roh,rec_roh;roh.;
		clear holdcodeflag[]
		for ctr=1 to 12
			call dxget ("HoldValue"+str$(ctr),tmp$)
			let holdcodeflag[ctr]=tmp$
		next ctr
		! REM PACK CHAIN TYPE FROM HOLDCODEFLAG[] 
		if credit OR ROH.holdover clear holdcodeflag[]
		!if roh.ordtype=16 or roh.ordtype=8 clear holdcodeflag[]
		if roh.ordtype=37 clear holdcodeflag[] ! no hold on EVAP
		let tmp3=0
		for ctr=0 to 11
			IF holdcodeflag[ctr+1] LET tmp3=tmp3+2^ctr   
		next ctr
		let rot.holdcode=tmp3
		Write Record #ch_rot,roh.totrec;rot.;
		IF P60$[44,44]="Y" ! edit tracking
			clear etr.
			if not(credit) and source<>207
				if oohld<>rot.HoldCode ! hold changed
					etr.ProdCode$=Source using "###"
					etr.OrgQtyOrd=oohld
					etr.NewQtyOrd=rot.HoldCode
					etr.EtAction=12 ! changed it?
					call edttrk()
				Endif
			Endif
		Endif ! edittrack hold changes
	endif   ! has rec_roh         
    EndOrdHoldSubmit: !     	
	clear list$[]
	List$[0]=bsdel$,"OrdHoldSubmit",fdel$
	WebStr$="OrderId",fdel$
	Webstr$=webstr$,"InvoiceId",fdel$
	webstr$=webstr$,"ORDERAMT",fdel$
	webstr$=webstr$,"ORDERCOST",fdel$
	List$[1]=WebStr$
	WebStr$=str$(orderid),fdel$
	Webstr$=webstr$,str$(roh.invnum),fdel$
	let amount=rot.MdseOrdAmt
	if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		let factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$,str$(amount),fdel$ ! let amount=rot.MdseOrdAmt
	amount=rot.totordcost
	if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		let factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$,str$(amount),fdel$ !rot.totordcost
	LIST$[2]=Webstr$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
    call SetOutPut(e$,rstr$)
	! end of submitordhold	

case "GETORDTOT"
	If P61$[94,94] ="Y"
		ch_rod = OpenFile(-10106,intCo)
	endif
	dim keyroc$[50],FRTOVRRD$[8],2%,FRTADDON
	dim keyrod$[50],keychk$[50],3%,rec_rod,depamt
	Dim 3%
	let returnstatus=1
	let message$="OK"
	clear list$[]
	! call programdump("tmp/ordht0!","")
	Read #CTLC,182,150;FrtAddon;
	If FrtAddon<0 or FrtAddon>500 let FrtAddon=0
	Mat Read #CTLC,182,154;FrtOVRRD$;
	FRTOVRRD$=RTrim$(FRTOVRRD$) ! trim spaces
	! section 1 - Misc Charges Droplist
	List$[0]=bsdel$,"MiscChargeDroplist",fdel$
	WebStr$="ID",fdel$
	WebStr$=Webstr$,"Desc",fdel$
	Webstr$=Webstr$,"Taxable",fdel$
	Webstr$=Webstr$,"GP",fdel$
	List$[1]=WebStr$
	let ctr=2
	let tmpcnt=maxcnt
	let rec_tmp=(chf(ch_misc))-1
	for rec_misc=1 to rec_tmp
		read record #ch_misc,rec_misc;misc.;
		if misc.type=2 ! order -- not for po's
			if rtrim$(misc.desc$)<>""
				let webstr$=str$(rec_misc),fdel$
				let webstr$=webstr$,RTrim$(misc.desc$),fdel$
				let tmp$="N"
				if misc.taxable<>0 let tmp$="Y"
				let webstr$=webstr$,tmp$,fdel$
				let tmp$="N"
				if misc.distgp<>0 let tmp$="Y"
				let webstr$=webstr$,tmp$,fdel$
				let list$[ctr]=Webstr$
				let ctr=ctr+1
				If ctr > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
				! check the count  neex to expand variable
			 endif
		endif
	next rec_misc
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	! section 2 - tax code droplist
	! tmpline$="ID",fdel$,"Desc",fdel$,"TaxRate",fdel$ 
	 Call FileDropListTaxCode(e$,List$[],maxcnt,Ch_Tax) 
	 Call AddToStr(e$,rstr$,List$[])  
	! Call AddToStr(e$,rstr$,esdel$) ! end of section
	! section 3 - Order Total
	call dxget ("CUSTID",Custid$)
	call dxget ("ORDERID",orderid$)
	let custid=custid$
	let orderid=orderid$
	call dxget ("SOURCE",tmp$)
	let source=tmp$
	LET returnstatus=1
	let message$="OK"
	!if orderid=10210 call dxsave(0,"tmp/ordht0!")
	keyroh$=" ",keyroh$
	keyroh$[1,6]=custid using "######" 
	keyroh$[7,12]=orderid using "######"
	keyroh$[13]=""
	mode$="=" ! search mode 2
	dir=2
	clear chan[]
	CHAN[0]=CH_ROH
	CHAN[1]=CH_ROS
	CHAN[2]=CH_ROT
	Rec_roh=filegetrohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
	if rec_roh<0
		let returnstatus=99
		let message$="Order Number ",keyroh$[7,12]," Not On File"
	endif
	!call programdump("/tmp/ordh2!","")
	OOHLD=ROT.HOLDCODE
	if returnstatus<>0
		clear cust.
		let keycust$=custid using "######"
		mode$="="
		dirno=1
		if custid>0
		CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
		else
			custrec=-1
		endif
		if CustRec<0! record found
			 let returnstatus=0
			 let message$="Customer "+str$(custid)+" Not on File"
		else
			  Mat Read #ch_cust,custrec,544;CFIN;
		endif
		let keyslsm$=" ",keyslsm$
		let keyslsm$[1,3]=roh.slsmnum using "###"
		keyslsm$[5]=""
		let mode="="
		dirno=1
		SlsmRec=FileGetsSlsmz(e$, Ch_sslsm , mode$ ,dirno ,KeySlsm$ ,Sslsm.)
		if slsmrec<0
			let returnstatus=0
			let message$="SalesPerson "+str$(roh.slsm)+" Not on File"
		endif
		if returnstatus<>0 and source<>207
		    if not(credit)
				roh.COMMSVGCHG=CFin[8] ! set it
			Else ! is credit
				if not(roh.CmInvHist) let roh.COMMSVGCHG=CFin[8] ! set it if not copied
			Endif
			clear ch[] ! channels for files sent to order total
			LET CH[2]=CH_ZONE;CH[3]=CH_PROD;CH[4]=CH_COMCDE;CH[5]=CH_CUST             
			LET CH[6]=CH_PRWH;CH[7]=CH_ROS;CH[8]=CH_ROH;CH[9]=CH_ROT;CH[10]=CH_ROL    
			LET CH[11]=CH_SPRODDESC;CH[12]=CH_CTAX;CH[13]=CH_SSLSM;CH[14]=CH_TAX
			LET CH[15]=CH_SPRODLOT;CH[16]=CH_SORDLOT;CH[17]=CH_CCODE;ch[19]=ch_misc
			LET CH[20]=CH_TERMS
			clear s9[]
			let s9[0]=orderid
			let s9[1]=intco
			let s9[2]=roh.slsm
			let s9[4]=Source ! order edit program #
			if credit let s9[4]=241
			! use source except 201/208 (is 0)
			If S9[4]=0 and roh.orgstatus=0 and roh.spare2=0
				let S9[4]=201 ! new order (could be 207!)
			endif
			IF S9[4]=0 LET S9[4]=208
			if source=2082 let s9[4]=208 ! order edit!
			if S9[4]=201 AND (roh.orgstatus>0 and roh.orgstatus<5) let S9[4]=208 ! NOT ENTRY
			! it seems web always sends source as 201? for entry & edit?
			R5 = custrec ;H1 = REC_ROH;V1 = slsmrec
			clear param[]
			param[0]=0 !cred check 
			param[1]= 0 ! no credit check 0 !no cred check
			If roh.orgstatus=0 and roh.spare2=0 and roh.ordtype<>16 let param[1]=1 ! credit check new order
			param[2]=1 !no exception check
			param[3]=1 !write total data out
			param[4]=1 !no retotal of customer on order
			if p60$[40,40]="S" let param[4]=1! retotal on order if based on shipped
			param[5]=0 !do no clear manual edits
			param[6]=0 !do not clear cash stuff
			param[9]=0 ! ok to calculate delivery charge
			if credit<>0 let param[9]=99 ! bypass calc of deliv charges on credit
			IF S9[4]=208 let param[9]=99 ! bypass calc of deliv charges on edit
			IF S9[4]=208 ! need to check if it from 201 or 208
				call dxget ("SOURCE",tmp$)
				let source=tmp$ 
				if source=201 let param[9]=0!  USES 0 for them!
			endif
			if custom_customer$="MORRISETTE"
				if s9[4]=208 and P61$[36,36]<>"Y" let param[9]=0 ! as done in 208c native (calc deliv chrg)
			Endif
			MAT  READ #CH_ROT,roh.totrec,0;T1       
			MAT  READ #CH_ROT,roh.totrec,8;T2     
			MAT  READ #CH_ROT,roh.totrec,168;MCODE  
			MAT  READ #CH_ROT,roh.totrec,208;MCHARGE
			MAT  READ #CH_ROT,roh.totrec,328;TOT    
			MAT  READ #CH_ROT,roh.totrec,358;MCTXBL 
			MAT  READ #CH_ROT,roh.totrec,378;DCLVL;
			Mat  Read #ch_rot, roh.totrec,380;tot_ord;
			!if s9[4]=223 and t2[10]<>0! edit
			!	let param[6]=0
			!endif
			!if s9[4]=208 and t2[10]<>0 ! order edit
			!	let param[6]=0
			!endif
			if source=231 and t2[24]=0 and t2[0]=0 and tot_ord=0 let param[1]=1 ! retotal new invoice
			if source=251 and t2[24]=0 and t2[0]=0 and tot_ord=0 let param[1]=1 ! retotal new pos invoice
			if custom_customer$="PHILLIPS" !task#14117/cct#173357
					if source=251
						if roh.ordtype=1 let param[1]=0
						if roh.ordtype=3 let param[1]=0
						if roh.ordtype=12 let param[1]=0
					endif
			endif
			if cust.CreditCheckDays=0 let param[1]=0 ! no credit check 
			if t2[10]<>0 let param[9]=99 ! bypass cash sale delivery charges
			! if s9[4]=231 let param[9]=99 ! bypass one step delivery charge
			if s9[4]=251 let param[9]=99 ! bypass point of sale delvery charge
			if s9[4]=208 let param[9]=99 ! bypass calc on sales order edit
			!if s9[4]=223 let param[9]=99 ! bypass calc on invoice edit
			if s9[4]=223 and p61$[36,36]="Y" and roh.spare2<>88 ! delivery charge on inv
				let param[9]=0 ! calc
			endif
			IF P61$[36,36]="Y" and roh.spare2<>88
				if s9[4]=223 let param[9]=0
				if s9[4]=221 let param[9]=0
				!if s9[4]=251 let param[9]=0
			endif
			if s9[4]=201 and t2[24]<>0 let param[9]=99 ! order entry in an edit mode
			If source=231 and roh.spare2<>0 let param[9]=99 ! bypass delivery calc on edit
			!IF ROH.ORDNUM=7040 Call dxsave(0,"/tmp/mtg.txt!") ! programdump("tmp/ordh3!","")
			IF S9[4]=208 and t2[24]=0 ! need to check if it from 201 or 208
				call dxget ("SOURCE",tmp$)
				let source=tmp$ 
				if source=201 let param[9]=0!  USES 0 for them!
			endif
			let orgamt=fnr(t2[24])
			let orgcost=fnr(t2[14])
			let orgfreight=fnr(t2[5])
			let orgother=fnr(t2[6])
			If P60$[16,16] = "Y"    ! GETORDTOT     
				orgshipdate = roh.ShipDate 
				orgtotwgt = T2[16]         
			End If                       
			LET T2[5]=0
			LET T2[6]=0
			tmp3 = rot.holdcode
			For ctr = 1 To 12                       
				holdcodeflag[ctr] = Sgn(Fra(tmp3 / 2))
				tmp3 = Int(tmp3 / 2)                  
			Next ctr
			aflag[0]=holdcodeflag[1]
			let gpflag=holdcodeflag[2]
			For cntr = 1 To 12                          
				oldholdcodeflag[cntr] = holdcodeflag[cntr]
			Next cntr                                   
			!let orgfreight=t2[5]
			!let orgother=t2[6]

			param[8]=0
			! reduce the on order amount
			if custom_customer$="MORRISETTE" and param[1]=1
					if roh.orgstatus>0 and roh.orgstatus<9 let param[1]=0 ! no credit check
			endif
			if custom_customer$="PIEDMONT" and param[1]=1
					if roh.orgstatus>0 and roh.orgstatus<9 let param[1]=0 ! no credit check
			endif
			If P60$[16,16] = "Y"         
				orgshipdate = roh.ShipDate 
				orgtotwgt = T2[16]         
			End If                       
			IF source<>207
				Call "ORDERTOTAL",S9[],H1,PARAM[],ch[],T1[],T2[],MCODE[],MCHARGE[],TOT[],MCTXBL[],DCLVL,R5,V1,CFIN[]
			endif
			read record #ch_roh,rec_roh;roh.
			read record #ch_rot,roh.totrec;rot.
			read record #ch_ros,roh.shiprec;ros.
			roh.spare2=99
			if p61$[36,36]="Y" and roh.spare2<>88 ! delivery charge on inv
				if s9[4]=231 or s9[4]=223 or s9[4]=251
					let roh.spare2=88
				endif
			endif
			Write Record #ch_roh,rec_roh,0;roh.;
			if fnr(orgamt)=Fnr(t2[24]) and fnr(orgcost)=fnr(t2[14]) and fnr(orgfreight)<>fnr(t2[5])
				Read Record #ch_rot,roh.totrec;rot.;
				let t2[5]=orgfreight
				let rot.FrgtChrg =orgfreight
				Write Record #ch_rot,roh.totrec;rot.;
			endif
			if fnr(orgamt)=fnr(t2[24]) and fnr(orgcost)=fnr(t2[14]) and fnr(orgother)<>fnr(t2[6])
				Read Record #ch_rot,roh.totrec;rot.;
				let t2[6]=orgother
				let rot.OthChrg  =orgother
				Write Record #ch_rot,roh.totrec;rot.;
			endif
			if roh.ordtype=16 or roh.ordtype=8 or (not(credit) and roh.ordtype=37) or (credit and roh.ordtype=37 and roh.shiptype=16) ! whse xfer - no totals!
				let rot.TaxPct=0;rot.OrdDisc=0;rot.MiscChrg=0 ! 2-4
				rot.FrgtChrg=0;rot.OthChrg=0;rot.TaxAmt=0 ! 5-7
				rot.PrepaidFrgt=0;rot.FrgtCost=0 ! 19,20
				rot.OrdTot=0;rot.Subtot=0 ! 0,1
				rot.TotMiscCost=0;rot.MiscChrg4Prof=0;rot.MiscCost4Prof=0
				rot.TotChrgTax=0;rot.holdcode=0
				clear rot.MiscChrgCode[]
				clear rot.MCharge[]
				clear rot.MCTxbl[]
				if (not(credit) and roh.ordtype=37) or (credit and roh.ordtype=37 and roh.shiptype=16) ! evap ship - add'l clearing
					rot.Subtot=0;rot.CashSaleFlag=0;rot.MdseOrdAmt=0
					rot.TotChrgTax=0
				Endif ! this order is no charges at all - EOM gets totals
			Endif
			if roh.ordtype=6 or roh.ordtype=10 ! sample/donation
				let rot.OthChrg=0-rot.TaxAmt
				roh.OrdDisc=100;rot.OrdDisc=rot.Subtot
			Endif
			tmp3 = rot.holdcode
			For ctr = 1 To 12                       
				holdcodeflag[ctr] = Sgn(Fra(tmp3 / 2))
				tmp3 = Int(tmp3 / 2)                  
			Next ctr
			if holdcodeflag[1] and not(aflag[0]) let aflag[1]=1 ! put on hold!
			if fnr(orgamt)=fnr(t2[24]) and fnr(orgcost)=fnr(t2[14]) and gpflag<>holdcodeflag[2]
				let holdcodeflag[2]=gpflag
				tmp3 = 0                                            
				For ctr = 0 To 11                                   
					If holdcodeflag[ctr + 1] Let tmp3 = tmp3 + 2 ^ ctr
				Next ctr                                            
				rot.holdcode = tmp3
				Write Record #ch_rot,roh.totrec;rot.;  
			endif
			if orgamt=t2[24] and orgcost=t2[14] 
				For cntr=3 to 12
					if oldholdcodeflag[cntr]<>holdcodeflag[cntr]
						let holdcodeflag[cntr]=oldholdcodeFLAG[cntr]
						let tmp3 = 0                                            
						For ctr = 0 To 11                                   
							If holdcodeflag[ctr + 1] Let tmp3 = tmp3 + 2 ^ ctr
						Next ctr                                            
						rot.holdcode = tmp3
						Write Record #ch_rot,roh.totrec;rot.;  
					endif
				Next cntr
			endif
			if fnr(orgamt)=fnr(t2[24]) and fnr(orgcost)=fnr(t2[14]) and fnr(orgfreight)<>fnr(t2[5])
				Read Record #ch_rot,roh.totrec;rot.;
				let t2[5]=orgfreight
				let rot.FrgtChrg =orgfreight
				Write Record #ch_rot,roh.totrec;rot.;
			endif
			if fnr(orgamt)=fnr(t2[24]) and fnr(orgcost)=fnr(t2[14]) and fnr(orgother)<>fnr(t2[6])
				Read Record #ch_rot,roh.totrec;rot.;
				let t2[6]=orgother
				let rot.OthChrg  =orgother
				Write Record #ch_rot,roh.totrec;rot.;
			endif
			                                                         
			! calculate the commission 
			IF source<>207
				clear s9[]
				let s9[0]=orderid
				let s9[1]=intco
				let s9[2]=roh.slsm
				let s9[4]=201 ! order entry program #
				if credit let s9[4]=241
				if roh.status=96 let s9[4]=223
				if roh.status=94 let s9[4]=231
				R5 = custrec ;H1 = REC_ROH;V1 = slsmrec
				Clear Ch[] ! channels for files sent to mxslscom5                   
				Ch[1] = ctlc;Ch[3] = Ch_prod;Ch[4] = Ch_comcde;Ch[5] = ch_cust      
				Ch[6] = ch_prwh;Ch[7] = ch_ros;Ch[8] = ch_roh;Ch[9] = ch_rot;Ch[10]=CH_ROL                                          
				Ch[11] = CH_SPRODDESC;Ch[12] = ch_ctax;Ch[13] = ch_sslsm            
				Call "MXSLSCOM5",S9[],Ch[],R5,H1,V1,CFIN[]
			endif
			if source=0 and roh.ordtype=5 and roh.CmInvHist=0
				if not(credit)
					call fut208()
				Endif
			Endif
		endif ! returnstatus<>0
		if not(credit) and source=201 and rot.MdseOrdAmt>0 and fnr(orgamt)<fnr(rot.MdseOrdAmt) and returnstatus<>0 and not(roh.holdover)
			! check for credit limit pct
			mat read #ctlc,115,48;credpct;
			if credpct>0
				if cust.CreditCheckDays>0 and cust.CreditCheckDays<999
					let tmp3=cust.CreditLimit*(credpct/100)
					if tmp3-rot.MdseOrdAmt<=0 and tmp3-orgamt>0
						let returnstatus=2
						let message$="This Order is Equal To Or Greater Than "+str$(credpct)+" Percent of Credit Limit"
						if  rtrim$(holdpswd$[1])<>"" ! has a password check for credit
							Read Record #ch_rot,roh.totrec;rot.; 
							tmp3 = rot.holdcode                     
							For ctr = 1 To 12                       
								holdcodeflag[ctr] = Sgn(Fra(tmp3 / 2))
								tmp3 = Int(tmp3 / 2)                  
							Next ctr
							if not(holdcodeflag[1])                              
								let holdcodeflag[1]=1;aflag[1]=1  ! failed credit check
								tmp3 = 0                                            
								For ctr = 0 To 11                                   
									If holdcodeflag[ctr + 1] Let tmp3 = tmp3 + 2 ^ ctr
								Next ctr                                            
								rot.holdcode = tmp3
								Write Record #ch_rot,roh.totrec;rot.;  
							endif
						endif
					endif 
				endif
			endif
		endif			 
		!call programdump("/tmp/ordh4!","")
	endif  	
    dochchk=1 ! do it 
    if credit let dochchk=0
    if roh.ordtype=20 or roh.ordtype=16 or roh.ordtype=8 let dochchk=0 ! not on frgt/xfer
	if roh.ordtype=37 let dochchk=0 ! no chk on EVAP
    if roh.holdover<>0 let dochcHk=0
	if source=207 let dochchk=0
	if custom_customer$="ACME" and source=231 and roh.ordtype=2 let dochchk=0 ! 128990 - no credit check on directs
	Read Record #ch_rot,roh.totrec;rot.;
	if fnr(orgamt)>=fnr(rot.mdseordamt) let dochcHk=0
	if rot.mdseordamt<0 let dochcHk=0
	if custom_customer$="MORRISETTE" and dochchk<>0
			if roh.orgstatus>0 and roh.orgstatus<9 let dochchk=0 ! no credit check
	endif
	if custom_customer$="PIEDMONT" and dochchk<>0
			if roh.orgstatus>0 and roh.orgstatus<9 let dochchk=0 ! no credit check
	endif
	if dochcHk<>0
		! unpack the holdcode into flag from bit flag field
		tmp3=rot.holdcode 
		for ctr=1 to 12   
 			LET holdcodeflag[ctr]=SGN(FRA(tmp3/2))
			LET tmp3=INT(tmp3/2)
		next ctr 
		let custid=roh.custnum
		let billcustid=roh.billto
		let shipcustid=ros.shipcust
		if not(param[1]) ! no credit check prior
			read #ctlc,66,0;holdpswd$[1];! credit check
			if rtrim$(holdpswd$[1])<>"" ! ! do credit check
				call ordhcreditcheck()	
				if flag and rtrim$(holdpswd$[1])<>"" ! has a password check for credit
					let holdcodeflag[1]=1;aflag[1]=1  ! failed credit check
				endif
			else
				let holdcodeflag[1]=0;aflag[1]=0
			endif
		endif
		call OnHoldChk()
		tmp3 = 0                                            
		For ctr = 0 To 11                                   
			If holdcodeflag[ctr + 1] Let tmp3 = tmp3 + 2 ^ ctr
		Next ctr                                            
		rot.holdcode = tmp3
		Write Record #ch_rot,roh.totrec;rot.;
	else
		if roh.holdover=0 and source<>207! no override
			if fnr(orgamt)<>fnr(rot.mdseordamt) or fnr(orgcost)<>fnr(rot.totordcost)
				! need to check if amt or cost changes for gp
				call onholdchk()
				tmp3 = 0                                            
				For ctr = 0 To 11                                   
					If holdcodeflag[ctr + 1] Let tmp3 = tmp3 + 2 ^ ctr
				Next ctr                                            
				rot.holdcode = tmp3
				Write Record #ch_rot,roh.totrec;rot.;
			endif
		endif
	endif ! dochck
	If P60$[16,16] = "Y" And abs(orgtotwgt-rot.TotWgt)<1 And orgshipdate <> 999999 ! GETORDTOT                                                                 
			Read Record #ch_roh,rec_roh;roh.;                                   
			If orgshipdate <> roh.ShipDate And orgshipdate <> 0                 
				roh.ShipDate = orgshipdate                                        
				Write Record #ch_roh,rec_roh;roh.;                                
			End If                                                              
	End If 
	IF SOURCE=207 AND CREDIT=0 AND ROH.STATUS>8
		IF ROH.STATUS=97 LET CREDIT =99
		IF ROH.STATUS>8 AND ROH.STATUS<12 LET CREDIT=99
	ENDIF
	clear list$[]
	List$[0]=bsdel$,"OrderTotalDisp",fdel$
	WebStr$="OrderId",fdel$
	WebStr$=webstr$,"TotUnitsOrd",fdel$
	WebStr$=webstr$,"TotUnitsSell",fdel$
	WebStr$=webstr$,"TotWeight",fdel$
	WebStr$=Webstr$,"TotCubes",fdel$
	Webstr$=Webstr$,"Totcharge4prof",fdel$
	Webstr$=Webstr$,"Totcost4prof",fdel$
	Webstr$=webstr$,"HoldStatus",fdel$
	Webstr$=webstr$,"ShipDate",fdel$
	Webstr$=webstr$,"Zone",fdel$
	webstr$=webstr$,"ZoneDesc",fdel$
	webstr$=webstr$,"Subtotal",fdel$
	webstr$=webstr$,"TaxableMerch",fdel$
	webstr$=webstr$,"TaxableTotCharges",fdel$
	webstr$=webstr$,"TaxPct",Fdel$
	webstr$=webstr$,"TaxAmt",fdel$
	webstr$=webstr$,"TotShipMerchCost",fdel$
	webstr$=webstr$,"TotFrgtCost",fdel$
	webstr$=webstr$,"TotMiscCost",fdel$
	webstr$=webstr$,"TotFrgtAdd",fdel$
	webstr$=webstr$,"DelivChrgLvl",fdel$
	webstr$=webstr$,"LineTax",fdel$
	! need to add morrisette (now std) fields
	WebStr$=webstr$,"MINGPDol",fdel$ ! min gp$ (hard code & custom morrisette)
	! eventually - can make std - if stored in 924
	Webstr$=webstr$,"CUSTOMCUST",fdel$ ! - per 16805 - send custom customer
	webstr$=webstr$,"CUSTQUOTE",fdel$ ! for quotes only
	webstr$=webstr$,"DepositAmt",fdel$ !
	let tmp$=""
	if p61$[136,136]="Y" let tmp$="Currency" 
	webstr$=webstr$,"Currency",fdel$ ! "Currency"
	List$[1]=WebStr$
	WebStr$=str$(orderid),fdel$
	Webstr$=webstr$+RTrim$(rot.totordqty Using "----------.##") + fdel$   
	Webstr$=webstr$+RTrim$(roh.totsellunits Using "----------.##") + fdel$ 
	Webstr$=webstr$+RTrim$(rot.totwgt Using "----------.##") + fdel$ 
	Webstr$=webstr$+RTrim$(rot.totcubes Using "----------.##") + fdel$ 
	let amount=roh.totdol4prof
	if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		let factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	Webstr$=webstr$+RTrim$(amount Using "----------.##") + fdel$ ! roh.totdol4prof
	let amount=roh.totcost4prof
	if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		let factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	Webstr$=webstr$+RTrim$(amount Using "----------.##") + fdel$ ! roh.totcost4prof
	if credit let rot.holdcode=0 ! no holds on credit
	if roh.ordtype=16 let rot.holdcode=0 ! no holds on whs xfer
	if roh.ordtype=37 let rot.holdcode=0 ! no holds on EVAP
	If rot.holdcode<>0
		Webstr$=webstr$+"On Hold",fdel$
	else
		Webstr$=webstr$+" "+fdel$
	endif
	If roh.shipdate <> 999999                          
	  xdate$ = pdate$(roh.shipdate)                    
	Else                                               
	  xdate$ = "999999"                                
	End If                                                              
	Webstr$ = Webstr$,RTrim$(xdate$),fdel$ ! ship date 
	Webstr$=webstr$,ros.zone$,fdel$! zone
	tmp$=" ",tmp$;tmp$=ros.zone$+"  "
	tmp$[3]=""
	zonerec = FileGetZonefle(e$,Ch_Zone,"=",1,tmp$,zn.)
	If zonerec < 0                                               
		let zn.desc$="Zone Not On File"
	endif
	webstr$=webstr$+zn.desc$+fdel$
	let amount=rot.subtot
	if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		let factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	Webstr$=webstr$+LTrim$((amount) Using "----------.##") + fdel$ ! rot.subtot
	let amount=rot.taxmdseamt
	if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		let factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	Webstr$=webstr$+LTrim$((amount) Using "----------.##") + fdel$ ! rot.taxmdseamt
	let amount=(rot.taxable-rot.taxmdseamt)
	if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		let factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	Webstr$=webstr$+LTrim$((amount) Using "----------.##") + fdel$ ! (rot.taxable-rot.taxmdseamt)
	Webstr$=webstr$+LTrim$((rot.taxpct) Using "---.####%") + fdel$
	let amount=rot.taxamt
	if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		let factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	Webstr$=webstr$+LTrim$((amount) Using "----------.##") + fdel$ ! rot.taxamt
	! total cost ! need to check security
	let amount=rot.totshipcost
    if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		let factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$+ Ltrim$(amount Using "----------.##") + fdel$ ! rot.totshipcost
	let amount=rot.frgtcost
	if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		let factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$+ Ltrim$(amount Using "----------.##") + fdel$ ! rot.frgtcost
	let amount=rot.totmisccost
	if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		let factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$+ Ltrim$(amount Using "----------.##") + fdel$ ! rot.totmisccost
	let amount=roh.totfrgtadd
	if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		let factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$+ Ltrim$(amount Using "----------.##") + fdel$ ! roh.totfrgtadd
	
	Webstr$=webstr$+RTrim$(rot.delivchrglvl using "##")+fdel$
	let linetax=0
	let amount=0
	if P60$[42,42]="Y" and rot.subtot<>0  ! tax by line
		linetax=rot.taxamt-rot.totchrgtax
		let amount=linetax
		if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			let factor=roh.currfact
			call currconvup(amount,factor)
			let amount=fns(amount)
		endif
	endif
	webstr$=webstr$+ Ltrim$(amount Using "----------.##") + fdel$ ! linetax
	If custom_customer$="MORRISETTE" and not(credit)
		webstr$=webstr$,"50.00",fdel$
	Else ! until std - nothing
		webstr$=webstr$,"0",fdel$ ! Highlight <0 (anywhere?)
	Endif
	webstr$=webstr$,Custom_customer$,fdel$ ! per 16805 - send customer
	webstr$=webstr$,"N",fdel$ ! NOT FOR ORDERS! multi-cust quotes
	let depamt=0
	if p61$[94,94]="Y" and not(credit)
		let keyrod$=" ",keyrod$
		let keyrod$[1,6]=roh.custnum using "######"
		let keyrod$[7,12]=roh.ordnum using "######"
		do
			search #ch_rod,3,1;keyrod$,rec_rod,e
			if e<>0 exit do
			let tmp3=keyrod$[1,6]\if tmp3<>roh.custnum exit do
			let tmp3=keyrod$[7,12]\if tmp3<>roh.ordnum exit do
			read record #ch_rod, rec_rod;rod.;
			let depamt=depamt+rod.ChkAmt
		loop
	endif
	let amount=depamt
	if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		let factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$+ Ltrim$(depamt Using "----------.##") + fdel$ ! depamt
	if p61$[136,136]="Y"   and roh.currid<>0
		let keycurr$=" ",keycurr$
		let keycurr$=roh.currid using "####"
		search #ch_curr,2,1;keycurr$,rec_curr,e
		if not(e)
			Read Record #ch_curr,rec_curr;curr.;
			let tmp$=roh.currid using "####"
			let tmp$=tmp$+" "
			let tmp$=tmp$+rtrim$(curr.desc$)
			let webstr$=webstr$,tmp$,fdel$
		else
			let webstr$=webstr$,"",fdel$
		endif
	else
		let webstr$=webstr$,"",fdel$ ! currency
	endif
	LIST$[2]=Webstr$
	
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	! salesman section
	! new data added relating to commservcrhg
	let comm_gp_dollars=0
	let comm_gp_prc=0
	let adj_sales=0
	if p61$[79,79]="Y"
		if roh.COMMSVGCHG
			adj_sales=roh.TotDol4Prof-(roh.TotDol4Prof*(roh.COMMSVGCHG/100))
			let comm_gp_dollars=roh.TotDol4Prof-roh.TotCost4Prof
			let comm_gp_dollars=comm_gp_dollars-(roh.TotDol4Prof*(roh.COMMSVGCHG/100))
			If ADJ_SALES let comm_gp_prc=(comm_gp_dollars/adj_sales)*100
			let comm_gp_prc=int(comm_gp_prc)
		end if
	end if
	clear list$[]
	List$[0]=bsdel$,"OrdTotSlsmComm",fdel$
	webstr$="SlsmID",fdel$
	webstr$=webstr$,"SlsmName",fdel$
	webstr$=webstr$,"SlsmCommPct",fdel$
	webstr$=webstr$,"SlsmCommAmt",fdel$
	!if p61$[79,79]="Y" ! native conditional - web always send header
		webstr$=webstr$,"SlsmCommGPDol",fdel$
		webstr$=webstr$,"SlsmCommGPPct",fdel$
	!Else
	!Endif
	list$[1]=webstr$
	let row=2
	for ctr=0 to 4 ! salesperson code
		if roh.slsm[ctr]<>0
			webstr$=Rtrim$(roh.slsm[ctr] Using "###") + fdel$
			let slsmname$=""	
			if roh.slsm[ctr]>0 and roh.slsm[ctr]<=999
				let slsmname$=getslsmname$(ch_sslsm,roh.slsm[ctr],intco)	
			endif
			webstr$=webstr$+rtrim$(slsmname$)+fdel$
			webstr$=webstr$+Rtrim$(roh.slsmpct[ctr] Using "###.##%") + fdel$
			! if credit<>0 let roh.slsmcomm[ctr]=(0-roh.slsmcomm[ctr])
			webstr$=webstr$+Rtrim$(roh.slsmcomm[ctr] using "--------#.##")+fdel$
			if p61$[79,79]="Y" and roh.COMMSVGCHG
				webstr$=webstr$,LTrim$(comm_gp_dollars USING "-----#.##"),fdel$
				webstr$=webstr$,LTrim$(comm_gp_prc USING "-------#%"),fdel$
			Else
				webstr$=webstr$,"",fdel$,"",fdel$
			Endif
			let list$[row]=webstr$
			let row=row+1
		endif
	next ctr
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	! end salesman section
	!call programdump("/tmp/ordh5!","")
	! section for edit fields
	clear list$[]
	List$[0]=bsdel$,"OrderTotalEdit",fdel$
	WebStr$="TaxCode",fdel$
	WebStr$=webstr$,"TaxDesc",fdel$
	Webstr$=webstr$,"FrgtChrg",fdel$
	Webstr$=webstr$,"OrdDisc",fdel$
	
	Webstr$=webstr$,"Other",fdel$
	Webstr$=webstr$,"PrepaidFrgt",fdel$
	Webstr$=webstr$,"FrgtCost",fdel$
	Webstr$=webstr$,"OrdDiscPct",fdel$
	! add here - morrisette (now standard fields) ORDERS ONLY-NOT CREDITS!!!
	webstr$=webstr$,"FrgtAddonPct",fdel$ !! freight addon % - exc ot 2,6,8,16
	let list$[1]=webstr$
	if roh.taxcode<1 or roh.taxcode>7999
		let roh.taxcode=cust.taxcode
	endif
	Webstr$=str$(roh.taxcode),fdel$
	taxcoded$=gettaxcdd$(ch_tax,roh.TaxCode,intco)
	webstr$=webstr$,taxcoded$,fdel$
	!!
	let amount=rot.frgtChrg
	if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		let factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$ + Rtrim$(amount Using "----------.##") + fdel$ ! rot.frgtChrg
	if roh.ordtype=6 or roh.ordtype=10
		let rot.orddisc=rot.subtot ! donation/sample 100% discount
		roh.orddisc=100
	Endif
	if roh.orddisc<>0 ! discount % - recalc the discount amount
			let rot.orddisc=ABS(FNR(roh.orddisc*rot.subtot/100))*SGN(rot.subtot)
	endif
	!!
	let amount=rot.orddisc
	if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		let factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! rot.orddisc
	let amount=rot.othchrg
	if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		let factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! rot.othchrg
	let amount=rot.prepaidfrgt
	if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		let factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! rot.prepaidfrgt
	let amount=rot.frgtcost
	if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		let factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! rot.frgtcost
	let amount=roh.orddisc
	if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		let factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$+ str$(amount)+fdel$ ! roh.orddisc
	x3=FrtAddon
	if credit let x3=0 ! NOT ON CREDITS
	If roh.ordtype=2 or roh.ordtype=6 or roh.ordtype=8 or roh.ordtype=16 let x3=0
	if roh.ordtype=37 let x3=0 ! no frght on EVAP ship
	let amount=x3
	if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		let factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$,Str$(amount),fdel$ ! freight addon  
	LIST$[2]=Webstr$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! misc charge section
	clear list$[]
	List$[0]=bsdel$,"OrderTotMisc",fdel$
	webstr$=""
	webstr$=webstr$,"MiscId",fdel$
	webstr$=webstr$,"MiscDesc",fdel$
	webstr$=webstr$,"MiscChrg",fdel$
	webstr$=webstr$,"MiscCost",fdel$
	webstr$=webstr$,"MiscTax",fdel$
	webstr$=webstr$,"MiscGP",fdel$ ! not edittable
	webstr$=webstr$,"MiscDel",fdel$ ! not edittable
	list$[1]=Webstr$
	let row=2
	mat read #ch_rot,roh.totrec,208;mcharge;
	mat read #ch_rot,roh.totrec,168;MCODE; 
	mat read #ch_rot,roh.totrec,358;MCTXBL;
	!call programdump("/tmp/ordh6!","")
	for ctr=0 to 9
		if mcode[ctr]>0
			webstr$=""
			webstr$=Rtrim$(mcode[ctr] Using "###") + fdel$
			let tmp$=""
			read record #ch_misc,mcode[ctr];misc.;
			let tmp$=misc.desc$
			webstr$=webstr$+Rtrim$(tmp$)+fdel$
			let amount=mcharge[ctr,0] 
			if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
				let factor=roh.currfact
				call currconvup(amount,factor)
				let amount=fns(amount)
			endif
			webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! mcharge[ctr,0] 
			let amount=mcharge[ctr,1] 
			if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
				let factor=roh.currfact
				call currconvup(amount,factor)
				let amount=fns(amount)
			endif
			webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! mcharge[ctr,1]
			let tmp$="N"
			if mctxbl[ctr]<>0 let tmp$="Y"
			webstr$=webstr$+tmp$+fdel$ ! tax
			let tmp$="N"
			if int(fra(mcode[ctr])*10) let tmp$="Y"
			webstr$=webstr$+tmp$+fdel$ ! gp
			let tmp$="N"
			IF INT(FRA(MCODE[ctr]*10)*10)=9 let tmp$="Y"
			IF INT(FRA(MCODE[ctr]*10)*10)=8 let tmp$="A"
			webstr$=webstr$+tmp$+fdel$ ! del charge
			list$[row]=webstr$
			let row=row+1
		endif
	next ctr
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! flag status for calculating taxes and commissions
	clear list$[]
	List$[0]=bsdel$,"OrderTotFlags",fdel$
	WebStr$="TaxByLine",fdel$
	WebStr$=webstr$,"MiscTaxable",fdel$
	Webstr$=webstr$,"FreightTaxable",fdel$
	Webstr$=webstr$,"DiscTaxable",fdel$
	Webstr$=Webstr$,"OtherTaxable",fdel$
	Webstr$=Webstr$,"TaxRoundFlag",fdel$
	Webstr$=Webstr$,"DisplayCommiss",fdel$
	Webstr$=Webstr$,"CommCalc",fdel$
	Webstr$=Webstr$,"GPFrtChrg",fdel$
	Webstr$=Webstr$,"GPDisc",fdel$
	Webstr$=Webstr$,"GPFrtCost",fdel$
	Webstr$=Webstr$,"GPOther",fdel$
	Webstr$=Webstr$,"DelChrgCalc",fdel$
	WebStr$ = WebStr$,"CostSecurity",fdel$
	webstr$ = webstr$,"NonPrtFlag",fdel$
	webstr$=webstr$,"ThirdPtyTax",fdel$ ! tax calc'd by 3rd party (don't do it here!)
    webstr$=webstr$,"SpecFrgttax",fdel$
	webstr$=webstr$,"SpecFrgtTaxRate",fdel$
	! need to add in morrisette (now std) fields
	webstr$=webstr$,"FRGTOVRRD",fdel$ ! user flag
	webstr$=webstr$,"FOVRRDPWD",fdel$ ! override password
	! frght override Y/n, FOverride passwd
	webstr$=webstr$,"MiscCostSec",fdel$
	webstr$=webstr$,"FrtCostSec",fdel$
	webstr$=webstr$,"EDITCOMM",fdel$ ! can edit commission
	Webstr$=Webstr$,"COMMOVRRD",fdel$ ! commission override flag
	webstr$=webstr$,"DepositFlag",fdel$ 
	webstr$=webstr$,"BlockTaxEdit",fdel$
	webstr$=webstr$,"MILLITEMS",fdel$ ! mill item flag
	webstr$=webstr$,"BOPROCESS",fdel$ ! auto bo whsxfer
	let list$[1]=webstr$
	webstr$=""
	let tmp$="N"
	if p60$[42,42]="Y" let tmp$="Y"
	if p60$[42,42]="T" let tmp$="T"
	Webstr$=tmp$,fdel$!  taxby line
	clear ctax.
	if ros.shiptaxtype
		read record #ch_ctax,ros.shiptaxtype;ctax.;
	endif
	let tmp$="N"
	if ctax.mtax let tmp$="Y"
	Webstr$=webstr$,tmp$,fdel$ ! misc tax
	let tmp$="N"
	if ctax.ftax let tmp$="Y"
	Webstr$=webstr$,tmp$,fdel$ !freight tax 
	let tmp$="N"
	if ctax.dtax let tmp$="Y"
	if roh.ordtype=6 or roh.ordtype=10 let tmp$="N" ! NOT TAXABLE
	Webstr$=webstr$,tmp$,fdel$ ! disc tax
	let tmp$="N"
	if ctax.htax let tmp$="Y"
	if roh.ordtype=6 or roh.ordtype=10 let tmp$="N" ! NOT TAXABLE
	Webstr$=webstr$,tmp$,fdel$ ! other tax
	clear tax.
	let tmp$="N"
	if roh.taxcode
		read record #ch_tax,roh.taxcode;tax.;
		if tax.roundtype$="U" leT tmp$="U"
	endif
	Webstr$=webstr$,tmp$,fdel$ ! tax round
	! display commission
	let dispcomm$="Y"
	IF SOURCE=231 OR SOURCE=221 OR SOURCE=223 OR SOURCE=251
		IF P9$[31,31]="N" let dispcomm$="N" ! OR P9$[45,45]="N"  let dispcomm$="N"
	endif
	if source<221 and source<>207! order entry
		IF P9$[31,31]="N" let dispcomm$="N"
		! if P9$[45,45]="N"  let dispcomm$="N"
	endif
	!IF P9$[14,14]="N" let dispcomm$="N" 
	if roh.ordtype=19 and roh.Ot19Comp=1 let dispcomm$="N" ! not on ot19 partials
	if (not(credit) and (roh.ordtype=36 or roh.ordtype=37)) or (credit and roh.shiptype=16 and (roh.ordtype=36 or roh.ordtype=37)) ! evap - no display orders/inv
		if source>200 and source<239 let dispcomm$="N" ! ord/inv
		if source>249 let dispcomm$="N" ! cash sales
		if credit and roh.ShipType=16 let dispcomm$="N" ! curr mo EVAP credit
	Endif
	if dispcomm$="Y"
		if rec_uac>0 ! check user cntrl
			UCC = OpenFile(-9988, intCo)
			if ucc>=0! open user cntrl file
				mat read #ucc,rec_uac,386;ua5;
				let dispcomm$="N"
				if ua5[4]>0 and ua5[4]<1000 ! verify the salesman
					if ua5[4]=roh.slsmnum let dispcomm$="Y"
				endif
				if ua5[4]=1000 let dispcomm$="Y"
			endif
			Try Close #UCC  Else Rem
		endif
	endif
	Webstr$=webstr$,dispcomm$,fdel$ ! display commission yes or no
	Webstr$=webstr$,p9$[14,14],fdel$  !  Commis Calc. N=no L or P = Load (GP) S= merchandise Dollars
	let tmp$="N" 
	If p9$[35,35]="Y" let tmp$="Y"
	Webstr$=webstr$,tmp$,fdel$ ! gp freight charge flag
	let tmp$="N"
	if p9$[36,36]="Y" let tmp$="Y" ! 
	Webstr$=webstr$,tmp$,fdel$ ! gp discount flag
	let tmp$="N"
	if p9$[37,37]="Y" let tmp$="Y"
	Webstr$=webstr$,tmp$,fdel$ ! gp freight cost flag
	let tmp$="N"
	if p9$[38,38]="Y" let tmp$="Y"
	Webstr$=webstr$,tmp$,fdel$ ! gpother
	let tmp$="N" ! delivery charge flag
	if rot.delivchrglvl<>0 let tmp$="Y"
	if P61$[36,36]="Y" let tmp$="N" ! calc on invoice
	Webstr$=webstr$,tmp$,fdel$ ! del calc
	webstr$ = webstr$,Str$(COST_LEV[1]),fdel$ ! load cost security
	let tmp$="N"
	if rec_uac>0 ! check user cntrl
		UCC = OpenFile(-9988, intCo)
		if ucc>=0! open user cntrl file
			mat read #ucc,rec_uac,336;UA2$;
			! misc user flags
		endif
		Try Close #UCC  Else Rem
	endif
	if source=2082 or (source<221 and source<>207) ! order entry
	  if p9$[45,45]<>"Y"
		if roh.orgstatus>1 and roh.orgstatus<=4
			let tmp3=ua2$[23,23]
			if tmp3>0
				if roh.orgstatus<=tmp3
					let tmp$="Y"
				endif
			endif
		 endif 
	  endif
	endif
	webstr$=webstr$,tmp$,fdel$! line print status
	TCB=0
	Read #ch_tax,roh.TaxCode,412;TCB;
	tmp$="N" 
	if custom_customer$="HTBERRY" or P61$[140,140]="Y" ! custom_customer$="PIEDMONT"
		if tcb=1 let tmp$="C" ! cch does it
		if tcb=2 let tmp$="A" ! avalara
	endif
	webstr$=webstr$,tmp$,fdel$ ! third party tax calc
	let tmp$="N"
	let tmp3=0
	if ctax.ftax<>0
			read record #ch_tax,roh.taxcode;tax.;
			if tax.desc$[1,1]="+" ! special tax use level 1
				let tmp$="Y"
				let tmp3=tax.Brkdn1Pct
			endif
	endif
	webstr$=webstr$,tmp$,fdel$ ! special freight tax
	Webstr$=webstr$+RTrim$((tmp3) Using "---.####") + fdel$
	tmp$="Y" \ if not(credit) and ua2$[45,45]="N" let tmp$="N" ! YES IS DEFAULT!!!
	webstr$=webstr$,tmp$,fdel$ ! user override
	If credit clear FrtOVRRD$ ! NOT ON CREDITS 
	webstr$=webstr$,FrtOVRRD$,fdel$ ! override password
	! misc cost security
	let tmp3=ua2$[18,18]
	if tmp3<0 let tmp3=0
	if tmp3>2 let tmp3=2
	if rtrim$(ua2$[18,18])="" let tmp3=2
	Webstr$=webstr$,str$(tmp3),fdel$
	! freight cost security
	let tmp3=ua2$[17,17]
	if tmp3<0 let tmp3=0
	if tmp3>2 let tmp3=2
	if rtrim$(ua2$[17,17])="" let tmp3=2
	Webstr$=webstr$,str$(tmp3),fdel$
	!webstr$=webstr$,"MiscCostSec",fdel$
	!webstr$=webstr$,"FrtCostSec",fdel$
	tmp$="N" \ if EDITCOMM let tmp$="Y" ! or credit ! (all credits?)
	IF Credit and ucf$[4,4]="Y" let tmp$="Y" ! credit edit commission
	if P60$[24,24]="Y" or (source<220 and not(CREDIT)) or source=239 let tmp$="N" ! not on comm by line or orders
	if source=2082 let tmp$="N"
	webstr$=webstr$,tmp$,fdel$ ! can edit commiss
	tmp1$=Str$(roh.CommOver) \ if tmp$="N" let tmp1$="0"
	webstr$=webstr$,tmp1$,fdel$ ! comm override type - 0:none 1:% 2:$
	let tmp$="N"
	if p61$[94,94]="Y" and depamt>0 let tmp$="Y" ! deposit
	webstr$=webstr$,tmp$,fdel$
	let tmp$="N"
	if ua2$[32,32]="Y" let tmp$="Y" ! edit tax - flag in file is to block tax 
	webstr$=webstr$,tmp$,fdel$
	miflag$=getmillitmflag$() ! see if any mill items (N/Y/H/D)
	webstr$=webstr$,miflag$,fdel$
	tmp$="N" \ if p61$[120,120]="Y" or p61$[120,120]="E" let tmp$="Y"
	TMP$=getautowhtrans$() ! CHECK sordtype
	if credit or source>208 let tmp$="N" ! not for cm's,inv's
	if source=207 let tmp$="N" ! NOT FOR INQUIRY
	if source=2082 let tmp$="N"
	webstr$=webstr$,tmp$,fdel$ ! use bo auto whse xfer
	List$[2]=Webstr$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	call dxget ("SOURCE",tmp$)
	let source=tmp$	
	if source=207 and returnstatus=1
		if not(ch_roc)
			ch_roc = OpenFile(2224,IntCo) 
			
		endif
		if ch_roc>0
			let keyroc$=orderid using "######" 
			rec_roc = filegetsordcash(e$,Ch_roc,"=",1,keyroc$,roc.)
			if rec_roc>0 let returnstatus=9 ! flag for inquiry cash sales screen exists
		endif
	endif
	!new section - show any mill item po's
	call showmillitems(miflag$) ! checks source & miflag$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
     call SetOutPut(e$,rstr$)
	!call programdump("/tmp/ordh7!","")
	if aflag[0]<>0 and aflag[1]<>0 let aflag[1]=0 ! was already on hold - not new
	if aflag[1] and source<>207 ! put on credithold
		call dochalert()
	Endif
	IF P60$[44,44]="Y" ! edit tracking
		clear etr.
		if not(credit) and source<>207
			if oohld<>rot.HoldCode ! hold changed
				etr.ProdCode$=Source using "###"
				etr.OrgQtyOrd=oohld
				etr.NewQtyOrd=rot.HoldCode
				etr.EtAction=13 ! set it?
				call edttrk()
			Endif
		Endif
	Endif ! edittrack hold changes
	! end of GETORDTOT
Case "GETSLSMCOMM"! get saleman commission					doc=OrdH.GetSlsmComm.doc
	if source=207
		let returnstatus=0
		message$="No Update. Inquiry Only"
		goto EndGetSlsmComm
	endif
	let returnstatus=1
	let message$="OK"
	call dxget ("custid",Custid$)
	call dxget ("orderid",orderid$)
	let custid=custid$
	let orderid=orderid$
	
	keyroh$=" ",keyroh$
	keyroh$[1,6]=custid using "######" 
	keyroh$[7,12]=orderid using "######"
	keyroh$[13]=""
	mode$="=" ! search mode 2
	dir=2
	clear chan[]
	CHAN[0]=CH_ROH
	CHAN[1]=CH_ROS
	CHAN[2]=CH_ROT
	Rec_roh=filegetrohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
	if rec_roh<0
		let returnstatus=0
		let message$="Order Number ",keyroh$[7,12]," Not On File"
		goto EndGetSlsmComm
	endif
	if not(source) and not(credit)
		if roh.status=97 
			let credit=99
			let source=241
		endif
	endif
	call verifystat()
	if returnstatus=99 goto endgetslsmcomm
	if returnstatus<>0
		clear cust.
		let keycust$=custid using "######"
		mode$="="
		dirno=1
		if custid>0
		CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
		Else
			custrec=-1
		Endif
		if CustRec<0 ! record not found
			 let returnstatus=0
			 let message$="Customer "+str$(custid)+" Not on File"
			 goto EndGetSlsmComm
		else
			  Mat Read #ch_cust,custrec,544;CFIN;
		endif
		let keyslsm$=" ",keyslsm$
		let keyslsm$[1,3]=roh.slsmnum using "###"
		KEYSLSM$[5]=""
		let mode="="
		dirno=1
		SlsmRec=FileGetsSlsmz(e$,Ch_sslsm,mode$,dirno,KeySlsm$,Sslsm.)
		if slsmrec<0
			let returnstatus=0
			let message$="SalesPerson "+str$(roh.slsm)+" Not on File"
			goto EndGetSlsmComm
		endif
		if returnstatus<>0
		clear ch[] ! channels for files sent to order total
		LET CH[2]=CH_ZONE;CH[3]=CH_PROD;CH[4]=CH_COMCDE;CH[5]=CH_CUST             
		LET CH[6]=CH_PRWH;CH[7]=CH_ROS;CH[8]=CH_ROH;CH[9]=CH_ROT;CH[10]=CH_ROL    
		LET CH[11]=CH_SPRODDESC;CH[12]=CH_CTAX;CH[13]=CH_SSLSM;CH[14]=CH_TAX
		LET CH[15]=CH_SPRODLOT;CH[16]=CH_SORDLOT;CH[17]=CH_CCODE 
		clear s9[]
		let s9[0]=orderid
		let s9[1]=intco
		let s9[2]=roh.slsm
		let s9[4]=201 ! order entry program #
		if rot.status=22 let s9[4]=241
		if roh.status=96 Let s9[4]=223
		if roh.status=94 let s9[4]=231
		R5 = custrec ;H1 = REC_ROH;V1 = slsmrec
		MAT  READ #CH_ROT,roh.totrec,0;T1       
		MAT  READ #CH_ROT,roh.totrec,8;T2       
		MAT  READ #CH_ROT,roh.totrec,168;MCODE  
		MAT  READ #CH_ROT,roh.totrec,208;MCHARGE
		MAT  READ #CH_ROT,roh.totrec,328;TOT    
		MAT  READ #CH_ROT,roh.totrec,358;MCTXBL 
		MAT  READ #CH_ROT,roh.totrec,378;DCLVL  
		! start the dxgets here
		TOT[0]=0;TOT[1]=0;TOT[2]=0;T2[4]=0 ! CLEAR MISC VARIABLES
		if roh.ordtype=16 or roh.ordtype=8 goto OTBYPS
		if (not(credit) and roh.ordtype=37) or (credit and roh.ordtype=37 and roh.shiptype=16) goto OTBYPS ! no misc on EVAP ship
		for ctr=1 to 10 ! for misc charges
			LET MCODE[ctr-1]=0;MCHARGE[(CTR-1),0]=0;MCHARGE[(CTR-1),1]=0;MCTXBL[CTR-1]=0
			call dxget ("MiscCode"+str$(ctr),tmp$)
			let mcode[ctr-1]=tmp$
			if mcode[ctr-1]
				call dxget("MiscChrg"+str$(ctr),tmp$)
				let amount=tmp$
				if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
					factor=roh.currfact
					call currconvdown(amount,factor)
					amount=fnr(amount)
				endif
				let mcharge[(ctr-1),0]=amount
				T2[4]=T2[4]+MCHARGE[(CTR-1),0]
				call dxget("MiscCost"+str$(ctr),tmp$)
				let amount=tmp$
				if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
					factor=roh.currfact
					call currconvdown(amount,factor)
					amount=fnr(amount)
				endif
				let mcharge[(ctr-1),1]=amount
				TOT[0]=TOT[0]+MCHARGE[(CTR-1),1]
				call dxget("MiscTax"+str$(ctr),tmp$)
				if tmp$="Y" 
					let mctxbl[ctr-1]=1 
				else
					let mctxbl[ctr-1]=0
				endif
				call dxget("MiscGP"+str$(ctr),tmp$)
				if tmp$="Y"
					LET MCODE[CTR-1]=MCODE[CTR-1]+.1 
					LET TOT[1]=TOT[1]+MCHARGE[(CTR-1),0]
					LET TOT[2]=TOT[2]+MCHARGE[(CTR-1),1]
				endif
				call dxget("MiscDel"+str$(ctr),tmp$)
				if tmp$="Y"
					let mcode[ctr-1]=mcode[ctr-1]+.09
				else
					if rtrim$(tmp$)="A"
						let mcode[ctr-1]=mcode[ctr-1]+.08
					endif
				endif
			endif
		next ctr
		call dxget("FrgtChrg",tmp$)
		let amount=tmp$
				if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
					factor=roh.currfact
					call currconvdown(amount,factor)
					amount=fnr(amount)
				endif
		let t2[5]=amount
		call dxget("OrdDisc",tmp$)
		let amount=tmp$
				if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
					factor=roh.currfact
					call currconvdown(amount,factor)
					amount=fnr(amount)
				endif
		let t2[3]=amount
		call dxget("Other",tmp$)
		let amount=tmp$
				if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
					factor=roh.currfact
					call currconvdown(amount,factor)
					amount=fnr(amount)
				endif
		let t2[6]=amount
		call dxget("PrepaidFrgt",tmp$)
		let amount=tmp$
				if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
					factor=roh.currfact
					call currconvdown(amount,factor)
					amount=fnr(amount)
				endif
		let t2[19]=amount ! prepaid freight
		call dxget("FrgtCost",tmp$)
		let amount=tmp$
				if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
					factor=roh.currfact
					call currconvdown(amount,factor)
					amount=fnr(amount)
				endif
		let t2[20]=amount
		OTBYPS: ! bypass - NO Get for ordertype
		! write out the totals
		MAT  write #CH_ROT,roh.totrec,8;T2       
		MAT  write #CH_ROT,roh.totrec,168;MCODE  
		MAT  write #CH_ROT,roh.totrec,208;MCHARGE
		MAT  write #CH_ROT,roh.totrec,328;TOT    
		MAT  write #CH_ROT,roh.totrec,358;MCTXBL 
		! calc for profit fields
		LET roh.totdol4prof=T2[1]-roh.totfrgtadd \ LET roh.totcost4prof=T2[17]     
		IF P9$[35,35]="Y" LET roh.totdol4prof=roh.totdol4prof+T2[5]+roh.totfrgtadd
		IF P9$[36,36]="Y" LET roh.totdol4prof=roh.totdol4prof-T2[3]      
		IF P9$[37,37]="Y" LET roh.totcost4prof=roh.totcost4prof+T2[20]     
		IF P9$[38,38]="Y" LET roh.totdol4prof=roh.totdol4prof+T2[6]      
		LET roh.totdol4prof=roh.totdol4prof+TOT[1];roh.totcost4prof=roh.totcost4prof+TOT[2] 
		write #ch_roh,rec_roh,156;roh.totdol4prof;
		write #ch_roh,rec_roh,160;roh.totcost4prof;
		
		! calculate the commission
		let s9[4]=201 ! order entry program #
		if roh.status=96 Let s9[4]=223
		if roh.status=94 let s9[4]=231
		if rot.status=22 or credit let s9[4]=241
		if rot.status=97 and not(credit)
			let credit=99
			let s9[4]=241
		endif
		clear ch[] ! channels for files sent to mxslscom5
		LET CH[1]=CTLC;CH[3]=CH_PROD;CH[4]=CH_COMCDE;CH[5]=CH_CUST             
		LET CH[6]=CH_PRWH;CH[7]=CH_ROS;CH[8]=CH_ROH;CH[9]=CH_ROT;CH[10]=CH_ROL    
		LET CH[11]=CH_SPRODDESC;CH[12]=CH_CTAX;CH[13]=CH_SSLSM
		Call "MXSLSCOM5",S9[],CH[],R5,H1,V1,CFIN[] 
		! reread return data
		read record #ch_roh,Rec_roh,0;roh.;
	   endif ! of second status<>0
	endif ! of 1st status<>0
	EndGetSlsmComm: ! 
	! new data added relating to commservcrhg
	let comm_gp_dollars=0
	let comm_gp_prc=0
	let adj_sales=0
	if p61$[79,79]="Y"
		if roh.COMMSVGCHG
			adj_sales=roh.TotDol4Prof-(roh.TotDol4Prof*(roh.COMMSVGCHG/100))
			let comm_gp_dollars=roh.TotDol4Prof-roh.TotCost4Prof
			let comm_gp_dollars=comm_gp_dollars-(roh.TotDol4Prof*(roh.COMMSVGCHG/100))
			If ADJ_SALES let comm_gp_prc=(comm_gp_dollars/adj_sales)*100
			let comm_gp_prc=int(comm_gp_prc)
		end if
	end if
	List$[0]=bsdel$,"SlsmComm",fdel$
	webstr$="SlsmID",fdel$
	webstr$=webstr$,"SlsmName",fdel$
	webstr$=webstr$,"SlsmCommPct",fdel$
	webstr$=webstr$,"SlsmCommAmt",fdel$
	!if p61$[79,79]="Y" ! native conditional - web always send header
		webstr$=webstr$,"SlsmCommGPDol",fdel$
		webstr$=webstr$,"SlsmCommGPPct",fdel$
	!Else
	!Endif
	list$[1]=webstr$
	let row=2
	for ctr=0 to 4 ! salesperson code
		if roh.slsm[ctr]<>0
			webstr$=Rtrim$(roh.slsm[ctr] Using "###") + fdel$
			let slsmname$=""	
			if roh.slsm[ctr]>0 and roh.slsm[ctr]<=999
				let slsmname$=getslsmname$(ch_Sslsm,roh.slsm[ctr],intco)	
			endif
			webstr$=webstr$+rtrim$(slsmname$)+fdel$
			webstr$=webstr$+Ltrim$(roh.slsmpct[ctr] Using "###.##%") + fdel$
			! if credit<>0 let roh.slsmcomm[ctr]=(0-roh.slsmcomm[ctr])
			webstr$=webstr$+Ltrim$(roh.slsmcomm[ctr] using "--------#.##")+fdel$
			if p61$[79,79]="Y" and roh.COMMSVGCHG
				webstr$=webstr$,LTrim$(comm_gp_dollars USING "-----#.##"),fdel$
				webstr$=webstr$,LTrim$(comm_gp_prc USING " ---#%"),fdel$
			Else
				webstr$=webstr$,"",fdel$,"",fdel$
			Endif
			let list$[row]=webstr$
			let row=row+1
		endif
	next ctr
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	! end salesman section
	!call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	!Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
    Call SetOutPut(e$,rstr$)
	! GETSLSMCOMM done
Case "SUBMITSLSMCOMM"! save saleman commission				doc=OrdH.SubmitCommission.doc
	if source=207 or source=239
		let returnstatus=0
		message$="No Update. Inquiry Only"
		goto EndSveSlsmComm
	endif
	if P60$[24,24]="Y" or Not(EditComm) ! (Not(Credit) and custom_customer$<>"MSPLASTICS")
		let returnstatus=0
		message$="No Update. No Edit Allowed"
		goto EndSveSlsmComm
	endif
	! ok - let's go
	let returnstatus=1
	let message$="OK"
	call dxget ("custid",Custid$)
	call dxget ("orderid",orderid$)
	let custid=custid$
	let orderid=orderid$
	
	keyroh$=" ",keyroh$
	keyroh$[1,6]=custid using "######" 
	keyroh$[7,12]=orderid using "######"
	keyroh$[13]=""
	mode$="=" ! search mode 2
	dir=2
	clear chan[]
	CHAN[0]=CH_ROH
	CHAN[1]=CH_ROS
	CHAN[2]=CH_ROT
	Rec_roh=filegetrohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
	if rec_roh<0
		let returnstatus=0
		let message$="Order Number ",keyroh$[7,12]," Not On File"
		goto EndSveSlsmComm
	endif
	if returnstatus<>0
		clear cust.
		let keycust$=custid using "######"
		mode$="="
		dirno=1
		if custid>0
		CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
		Else
			custrec=-1
		Endif
		if CustRec<0 ! record not found
			 let returnstatus=0
			 let message$="Customer "+str$(custid)+" Not on File"
			 goto EndSveSlsmComm
		else
			  Mat Read #ch_cust,custrec,544;CFIN;
		endif
		let keyslsm$=" ",keyslsm$
		let keyslsm$[1,3]=roh.slsmnum using "###"
		KEYSLSM$[5]=""
		let mode="="
		dirno=1
		SlsmRec=FileGetsSlsmz(e$,Ch_sslsm,mode$,dirno,KeySlsm$,Sslsm.)
		if slsmrec<0
			let returnstatus=0
			let message$="SalesPerson "+str$(roh.slsm)+" Not on File"
			goto EndSveSlsmComm
		endif
		if returnstatus<>0 ! ok
			if roh.ordtype=16 or roh.ordtype=8 goto NoSSC
			if (not(credit) and roh.ordtype=37) or (credit and roh.ordtype=37 and roh.shiptype=16) goto NoSSC ! no misc on EVAP ship
			! get type of change
			call dxget("COMMOVRRD",tmp$)
			let x2=tmp$ ! 0=none/normal, 1=% chg, 2=$ chg
			if x2<0 or x2>2 ! ng
				let returnstatus=0
				let message$="Commission Override invalid"
				goto EndSveSlsmComm
			endif
			let roh.CommOver=x2
			if roh.CommOver=0 goto CommUDone ! set back to no override & recalc it.
			! get slsm list & change
			clear message$ ! store any/all issues
			for X=1 to 5
				call dxget("SlsmID"+Str$(X),tmp$)
				if rtrim$(tmp$)="" goto BPCUD
				x2=tmp$;x1=-1 ! as entered
				if x2<=0 goto BPCUD ! none sent
				for ctr=0 to 4
					if roh.slsm[ctr]<>0
						if x2=roh.slsm[ctr]
							let x1=ctr
							let ctr=9
						endif
					endif
				next ctr
				if x1=-1 ! not found
					let returnstatus=0
					let message$=message$+"Salesperson "+Str$(X2)+" not found  "
					goto BPCUD
				endif
				if roh.CommOver=1 ! % change
					call dxget("SlsmCommPct"+Str$(X),tmp$)
					let x2=tmp$
					If X2<0 or x2>100
						returnstatus=0
						message$=message$+"Commission Percent "+Str$(X)+" invalid  "
						goto BPCUD
					Endif
					let roh.SlsmPct[x1]=x2
					! will need to recalc/redisplay (web makes GETSLSMCOMM call)
				Endif
				if roh.CommOver=2 ! $ change
					call dxget("SlsmCommAmt"+Str$(X),tmp$)
					let x3=tmp$ ! any checks (could be negative!)
					let roh.SlsmComm[x1]=x3
					let roh.SlsmPct[x1]=0 ! as classic does it
				Endif
			BPCUD: ! bypass
			Next X
			CommUDone: ! all done write it
			Write record #CH_roh,Rec_roh,0;roh.;
		NoSSC: ! no slsmcomm change
		Endif ! of status<>0 comm data
	endif ! of status<>0 main data
	EndSveSlsmComm: ! finished
	! status section
	if returnstatus=1 and Trim$(message$)="" let message$="OK" ! as it's cleared
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it (web makes GETSLSMCOMM call)
    call SetOutPut(e$,rstr$)
	! end of SUBMITSLSMCOMM
Case "GETFREIGHTCHARGE"
	let returnstatus=1
	let message$="OK"
	call dxget ("custid",Custid$)
	call dxget ("orderid",orderid$)
	let custid=custid$
	let orderid=orderid$
	LET returnstatus=1
	let message$="OK"
	keyroh$=" ",keyroh$
	keyroh$[1,6]=custid using "######" 
	keyroh$[7,12]=orderid using "######"
	keyroh$[13]=""
	mode$="=" ! search mode 2
	dir=2
	clear chan[]
	clear roh.
	clear rot.
	CHAN[0]=CH_ROH
	CHAN[1]=CH_ROS
	CHAN[2]=CH_ROT
	Rec_roh=filegetrohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
	if rec_roh<0
		let returnstatus=0
		let message$="Order Number ",keyroh$[7,12]," Not On File"
	endif
	if credit=0 and rot.Status=22 let credit=1
	if returnstatus
		call calcfreightcharge()
	endif
	List$[0]=bsdel$,"CalcFreight",fdel$
	WebStr$="FreightChrg",fdel$
	WebStr$=webstr$,"FreightCost",fdel$
	let list$[1]=webstr$
	!webstr$= Rtrim$(rot.frgtchrg Using "----------.##") + fdel$
	!webstr$=webstr$+ Rtrim$(rot.frgtcost Using "----------.##") + fdel$
	Let amount=rot.frgtchrg
	if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		let factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$= Rtrim$(amount Using "----------.##") + fdel$ !rot.frgtchrg
	Let amount=rot.frgtcost
	if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		let factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$+ Rtrim$(rot.frgtcost Using "----------.##") + fdel$ ! rot.frgtcost
	LIST$[2]=Webstr$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)
	! end of GETFREIGHTCHARGE
Case "GETDELIVERYCHARGE"
	let returnstatus=1
	let message$="OK"
	call dxget ("custid",Custid$)
	call dxget ("orderid",orderid$)
	let custid=custid$
	let orderid=orderid$
	LET returnstatus=1
	let message$="OK"
	clear rot.
	keyroh$=" ",keyroh$
	keyroh$[1,6]=custid using "######" 
	keyroh$[7,12]=orderid using "######"
	keyroh$[13]=""
	mode$="=" ! search mode 2
	dir=2
	clear chan[]
	CHAN[0]=CH_ROH
	CHAN[1]=CH_ROS
	CHAN[2]=CH_ROT
	Rec_roh=filegetrohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
	if rec_roh<0
		let returnstatus=0
		let message$="Order Number ",keyroh$[7,12]," Not On File"
	endif
	clear ctax.
	! clear rot. - clear all after read?
	if roh.ordtype=16 or roh.ordtype=8 let returnstatus=0 ! no changes allowed!
	if (not(credit) and roh.ordtype=37) or (credit and roh.ordtype=37 and roh.shiptype=16) let returnstatus=0 ! no changes allowed!
	if returnstatus<>0
		if ros.shiptaxtype<>0
			read record #ch_ctax,ros.shiptaxtype;ctax.;
		endif
		rot.miscchrg=0;rot.totmisccost=0;rot.miscchrg4prof=0;rot.misccost4prof=0
		for ctr=0 to 9
			let rot.mcharge[ctr,0]=0;rot.mcharge[ctr,1]=0
			let rot.MiscChrgCode[ctr]=0
			let rot.mctxbl[ctr]=0
		next ctr
		call dxget ("DELIVCHGLVL",tmp$)
		if p61$[109,109]<>"Y"
			if RTrim$(tmp$)<>"" let rot.delivchrglvl=tmp$
		endif
		rot.miscchrg4prof=0
		for ctr=1 to 10 ! for misc charges
			call dxget ("MiscId"+str$(ctr),tmp$)
			let rot.MiscChrgCode[ctr-1]=tmp$
			if rot.MiscChrgCode[ctr-1]
				call dxget("MiscChrg"+str$(ctr),tmp$)
				amount=tmp$
				if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
					 factor=roh.currfact
					call currconvdown(amount,factor)	
					let amount=fnr(amount)
				endif
				let rot.mcharge[(ctr-1),0]=amount
				rot.miscchrg=rot.miscchrg+rot.MCHARGE[(CTR-1),0]
				call dxget("MiscCost"+str$(ctr),tmp$)
				amount=tmp$
				if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
					factor=roh.currfact
					call currconvdown(amount,factor)
					let amount=fnr(amount)
				endif
				let rot.mcharge[(ctr-1),1]=amount
				rot.totmisccost=rot.totmisccost+rot.MCHARGE[(CTR-1),1]
				call dxget("MiscTax"+str$(ctr),tmp$)
				if tmp$="Y" 
					let rot.mctxbl[ctr-1]=1 
				else
					let rot.mctxbl[ctr-1]=0
				endif
				
				call dxget("MiscGP"+str$(ctr),tmp$)
				
				if tmp$="Y"
					LET rot.MiscChrgCode[ctr-1]=rot.MiscChrgCode[ctr-1]+.1 
					LET rot.miscchrg4prof=rot.miscchrg4prof+rot.MCHARGE[(CTR-1),0]
					LET rot.misccost4prof=rot.misccost4prof+rot.MCHARGE[(CTR-1),1]
				endif
				call dxget("MiscDel"+str$(ctr),tmp$)
				if tmp$="Y"
					let rot.MiscChrgCode[ctr-1] = rot.MiscChrgCode[ctr-1]+.09 
				endif
				if rtrim$(tmp$)="A"
					let rot.MiscChrgCode[ctr-1] = rot.MiscChrgCode[ctr-1]+.08
				endif
			endif
		next ctr
		call calcdeliverycharge()
		Write Record #ch_rot,roh.totrec;rot.;
	endif	
	List$[0]=bsdel$,"DeliveryCharge",fdel$
	webstr$=""
	webstr$=webstr$,"DelivChrgLvl",fdel$
	Webstr$=Webstr$,"Totcharge4prof",fdel$
	Webstr$=Webstr$,"Totcost4prof",fdel$
	webstr$=webstr$,"TotMiscCost",fdel$
	let list$[1]=webstr$
	let webstr$=""
	if returnstatus=1
		Webstr$=webstr$+RTrim$(rot.delivchrglvl using "##")+fdel$
		let amount=roh.totdol4prof
		if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			let factor=roh.currfact
			call currconvup(amount,factor)
			let amount=fns(amount)
		endif
		Webstr$=webstr$+RTrim$(amount Using "----------.##") + fdel$ !roh.totdol4prof
		let amount=roh.totcost4prof
		if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			let factor=roh.currfact
			call currconvup(amount,factor)
			let amount=fns(amount)
		endif
		Webstr$=webstr$+RTrim$(amount Using "----------.##") + fdel$ ! roh.totcost4prof
		let amount=rot.totmisccost
		if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			let factor=roh.currfact
			call currconvup(amount,factor)
			let amount=fns(amount)
		endif
		webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! rot.totmisccost
	    LIST$[2]=Webstr$
	endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! section 2 - misc charge section
	! misc charge section
	clear list$[]
	List$[0]=bsdel$,"DeliveryMisc",fdel$
	webstr$=""
	webstr$=webstr$,"MiscId",fdel$
	webstr$=webstr$,"MiscDesc",fdel$
	webstr$=webstr$,"MiscChrg",fdel$
	webstr$=webstr$,"MiscCost",fdel$
	webstr$=webstr$,"MiscTax",fdel$
	webstr$=webstr$,"MiscGP",fdel$ ! not edittable
	webstr$=webstr$,"MiscDel",fdel$ ! not edittable
	list$[1]=Webstr$
	let row=2
	mat read #ch_rot,roh.totrec,208;mcharge;
	mat read #ch_rot,roh.totrec,168;MCODE; 
	mat read #ch_rot,roh.totrec,358;MCTXBL;
	for ctr=0 to 9
		if mcode[ctr]>0
			webstr$=""
			webstr$=Rtrim$(mcode[ctr] Using "###") + fdel$
			let tmp$=""
			read record #ch_misc,mcode[ctr];misc.;
			let tmp$=misc.desc$
			webstr$=webstr$+Rtrim$(tmp$)+fdel$
			let amount=mcharge[ctr,0] 
			if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
				let factor=roh.currfact
				call currconvup(amount,factor)
				let amount=fns(amount)
			endif
			webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! mcharge[ctr,0] 
			let amount=mcharge[ctr,1] 
			if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
				let factor=roh.currfact
				call currconvup(amount,factor)
				let amount=fns(amount)
			endif
			webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! mcharge[ctr,1]
			let tmp$="N"
			if mctxbl[ctr]<>0 let tmp$="Y"
			webstr$=webstr$+tmp$+fdel$ ! tax
			let tmp$="N"
			if int(fra(mcode[ctr])*10) let tmp$="Y"
			webstr$=webstr$+tmp$+fdel$ ! gp
			let tmp$="N"
			IF INT(FRA(MCODE[ctr]*10)*10)=9 let tmp$="Y"
			IF INT(FRA(MCODE[ctr]*10)*10)=8 let tmp$="Y"
			webstr$=webstr$+tmp$+fdel$ ! del charge
			list$[row]=webstr$
			let row=row+1
		endif
	next ctr
	
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)

	! end of GETDELIVERYCHARGE

 Case "SUBMITORDTOT"
	dim 1%,dflag[4]
	dim 2%,dcost[11],dchrg[11]
	eflag=0
	let returnstatus=1
	let message$="OK"
	let message$=""
	call dxget ("custid",Custid$)
	call dxget ("orderid",orderid$)
	call dxget ("editstatus",tmp$)
	let editstatus=tmp$
	let custid=custid$
	let orderid=orderid$
	call dxget ("SOURCE",tmp$)
	let source=tmp$ 
	if source=207 goto sotdone ! no edit
	if credit let source=0
	if source=201 or source=208 let source=0 !  USES 0 for them!
	clear tmp$ ! to be sure!
	call dxget("NOTFINAL",tmp$)
	UPDTSTAT=1 \ if ucase$(RTrim$(tmp$))="Y" let UPDTSTAT=0
	! task 36030 - need a way to only update totals - with no status chg.
	! if UCase$(USERID$[1,4])="JIMS" call dxsave(0,"tmp/sotin.txt!")
	LET returnstatus=1
	! let message$="OK"
	keyroh$=" ",keyroh$
	keyroh$[1,6]=custid using "######" 
	keyroh$[7,12]=orderid using "######"
	keyroh$[13]=""
	mode$="=" ! search mode 2
	dir=2
	clear chan[]
	CHAN[0]=CH_ROH
	CHAN[1]=CH_ROS
	CHAN[2]=CH_ROT
	Rec_roh=filegetrohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
	if rec_roh<0
		let returnstatus=99
		let message$="Order Number ",keyroh$[7,12]," Not On File"
	endif
	if returnstatus<>0
		call verifystat()
		if returnstatus=99 goto endsubmitordtot
	endif
	if returnstatus<>0
		clear cust.
		let keycust$=custid using "######"
		mode$="="
		dirno=1
		if custid>0
		CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
		Else
			custrec=-1
		Endif
		if CustRec<0 ! record not found
			 let returnstatus=0
			 let message$=message$+"Customer "+str$(custid)+" Not on File"
		else
			  Mat Read #ch_cust,custrec,544;CFIN;
		endif
		let keyslsm$=" ",keyslsm$
		let keyslsm$[1,3]=roh.slsmnum using "###"
		keyslsm$[5]=""
		let mode="="
		dirno=1
		SlsmRec=FileGetsSlsmz(e$,Ch_sslsm,mode$,dirno,KeySlsm$,Sslsm.)
		if slsmrec<0
			let returnstatus=0
			let message$=message$+ "SalesPerson "+str$(roh.slsm)+" Not on File"
		endif
	  if returnstatus<>0
		clear ch[] ! channels for files sent to order total
			LET CH[2]=CH_ZONE;CH[3]=CH_PROD;CH[4]=CH_COMCDE;CH[5]=CH_CUST             
		LET CH[6]=CH_PRWH;CH[7]=CH_ROS;CH[8]=CH_ROH;CH[9]=CH_ROT;CH[10]=CH_ROL    
		LET CH[11]=CH_SPRODDESC;CH[12]=CH_CTAX;CH[13]=CH_SSLSM;CH[14]=CH_TAX
		LET CH[15]=CH_SPRODLOT;CH[16]=CH_SORDLOT;CH[17]=CH_CCODE 
		clear s9[]
		let s9[0]=orderid
		let s9[1]=intco
		let s9[2]=roh.slsm
		let s9[4]=201 ! order entry program #
		if credit let s9[4]=241
		if source=223 let s9[4]=223
		if source=231 let s9[4]=231
		R5 = custrec ;H1 = REC_ROH;V1 = slsmrec
		MAT  READ #CH_ROT,roh.totrec,0;T1       
		MAT  READ #CH_ROT,roh.totrec,8;T2       
		MAT  READ #CH_ROT,roh.totrec,168;MCODE  
		MAT  READ #CH_ROT,roh.totrec,208;MCHARGE
		MAT  READ #CH_ROT,roh.totrec,328;TOT    
		MAT  READ #CH_ROT,roh.totrec,358;MCTXBL 
		MAT  READ #CH_ROT,roh.totrec,378;DCLVL  
		! start the dxgets here
		if source=2082 ! no edits - but need totals/reset
			s9[4]=208;UPDTSTAT=1 ! YES UPDATE STATUS(the only reason to call)
			goto OTBYPTS
		Endif
		TOT[0]=0;TOT[1]=0;TOT[2]=0;T2[4]=0 ! CLEAR MISC VARIABLES
		if roh.ordtype=16 or roh.ordtype=8 goto OTBYPTS
		if (not(credit) and roh.ordtype=37) or (credit and roh.ordtype=37 and roh.shiptype=16) goto OTBYPTS
		clear param[]
		let param[9]=99 ! bypass delivery calc on submit
		let param[10]=99
		for ctr=1 to 10 ! for misc charges
			orgdelcode=0
			orgdelamt=0
			orgdeltax=0
			orgartcode=0;orgartamt=0;orgartcost=0
			if mcode[ctr-1]<>0
				if int(fra(mcode[ctr-1]*10)*10)=9
					let orgdelcode=int(mcode[ctr-1])
					let orgdelamt=mcharge[ctr-1]
					let orgdeltax=mctxbl[ctr-1]
					let param[9]=88 ! originally had a freight code
				endif
				if p61$[138,138]="Y"
					if int(fra(mcode[ctr-1]*10)*10)=8
						let orgartcode=int(mcode[ctr-1])
						let orgartamt=mcharge[(ctr-1),0]
						let orgartcost=mcharge[(ctr-1),1]
						let param[10]=88 ! originally had a ar term code
					endif
				endif
			endif
			let newdelcode=0
			let newdelamt=0
			let newdeltax=0
			newartcode=0;newartamt=0;newartcost=0
			LET MCODE[ctr-1]=0;MCHARGE[(CTR-1),0]=0;MCHARGE[(CTR-1),1]=0;MCTXBL[CTR-1]=0
			call dxget ("MiscCode"+str$(ctr),tmp$)
			let mcode[ctr-1]=tmp$
			if mcode[ctr-1]
				call dxget("MiscChrg"+str$(ctr),tmp$)
				amount=tmp$
				if fra(amount*100)<>0
					let eflag=eflag+1
					let returnstatus=0
					let message$=message$+" Misc Charge "+str$(ctr)+" Exceeds 2 decimal places "
					! Goto endsubmitordtot
				endif
				if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
					factor=roh.currfact
					call currconvdown(amount,factor)
					let amount=fnr(amount)
				endif
				let mcharge[(ctr-1),0]=amount
				T2[4]=T2[4]+ MCHARGE[(CTR-1),0]
				call dxget("MiscCost"+str$(ctr),tmp$)
				let amount=tmp$
				if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
					factor=roh.currfact
					call currconvdown(amount,factor)
					let amount=fnr(amount)
				endif
				let mcharge[(ctr-1),1]=amount
				TOT[0]=TOT[0]+MCHARGE[(CTR-1),1]
				call dxget("MiscTax"+str$(ctr),tmp$)
				if tmp$="Y" 
					let mctxbl[ctr-1]=1 
				else
					let mctxbl[ctr-1]=0
				endif
				call dxget("MiscGP"+str$(ctr),tmp$)
				if tmp$="Y"
					LET MCODE[CTR-1]=MCODE[CTR-1]+.1 
					LET TOT[1]=TOT[1]+MCHARGE[(CTR-1),0]
					LET TOT[2]=TOT[2]+MCHARGE[(CTR-1),1]
				endif
				call dxget("MiscDel"+str$(ctr),tmp$)  ! MISC DELIVERY CHARGE???
				if tmp$="Y"
					IF roh.ordtype=1 or p61$[36,36]="Y" ! inv's always whse type?                                                       
						LET rec_tmp=172 
					ELSE                                                                    
						LET rec_tmp=171 
					ENDIF 
					MAT  READ #1,rec_tmp,48;DCHRG;                                              
					MAT  READ #1,rec_tmp,96;DCOST;                                              
					MAT  READ #1,rec_tmp,240;DFLAG;  
					if dflag[1]=mcode[ctr-1]    !! is a auto charge 
					if rot.DelivChrgLvl
						If DFLAG[0] = -3 ! flat rate
							let newdelamt=DCHRG[rot.DelivChrgLvl-1]
						else
							LET newdelamt=FNR(DCHRG[rot.DelivChrgLvl-1]*(rot.TotWgt/100))                                                                  
						endif
					endif
						let newdelcode=mcode[ctr-1]
						read record #ch_misc,(INT(mcode[ctr-1]));misc.;
						let newdeltax=misc.taxable
					endif
					if newdelamt=orgdelamt and newdelcode=orgdelcode and newdeltax=orgdeltax
						let mcode[ctr-1]=mcode[ctr-1]+.09
						let param[9]=99
					endif			
				endif
				if rtrim$(tmp$)="A" and p61$[138,138]="Y"
					newartcode=mcode[ctr-1]
					newartamt=mcharge[(ctr-1),0]
					newartcost=mcharge[(ctr-1),1]
					if newartamt=orgartamt and newartcode=orgartcode and newartcost=orgartcost
						let mcode[ctr-1]=mcode[ctr-1]+.08
						let param[10]=99
					endif
				endif
			endif
		next ctr
		call dxget("FrgtChrg",tmp$)
		let amount=tmp$
		if amount<>0
			if fra(amount*100)<>0
				eflag=eflag+1
				let returnstatus=0
				let message$=message$+" Freight Exceeds 2 decimals places "
				!Goto endsubmitordtot
			endif
		endif
		if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			factor=roh.currfact
			call currconvdown(amount,factor)
			let amount=fnr(amount)
		endif
		let t2[5]=amount
		call dxget("OrdDisc",tmp$)
		let amount=tmp$
		if amount<>0
			if fra(amount*100)<>0
				eflag=eflag+1
				let returnstatus=0
				let message$=message$+" Discount Exceeds 2 decimals places "
				!Goto endsubmitordtot
			endif
		endif	
		if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			factor=roh.currfact
			call currconvdown(amount,factor)
			let amount=fnr(amount)
		endif
		let t2[3]=amount
		call dxget("OrdDiscPct",tmp$)
		let roh.orddisc=tmp$
		if not(t2[3]) let roh.orddisc=0
		if roh.ordtype=6 or roh.ordtype=10 let roh.orddisc=100
		write #ch_roh,rec_roh,436;roh.orddisc
		call dxget("Other",tmp$)
		let amount=tmp$
		if amount<>0
			if fra(amount*100)<>0
				eflag=eflag+1
				let returnstatus=0
				let message$=message$+" Other Chrg Exceeds 2 decimals places "
				!Goto endsubmitordtot
			endif
		endif	
		if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			factor=roh.currfact
			call currconvdown(amount,factor)
			let amount=fnr(amount)
		endif
		let t2[6]=amount
		call dxget("PrepaidFrgt",tmp$)
		let amount=tmp$
		if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			factor=roh.currfact
			call currconvdown(amount,factor)
			let amount=fnr(amount)
		endif
		let t2[19]=amount ! prepaid freight
		call dxget("FrgtCost",tmp$)
		let amount=tmp$
		if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			factor=roh.currfact
			call currconvdown(amount,factor)
			let amount=fnr(amount)
		endif
		let t2[20]=amount
		call dxget("TaxAmt",tmp$)
		let amount=tmp$
		if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
			factor=roh.currfact
			call currconvdown(amount,factor)
			let amount=fnr(amount)
		endif
		let t2[7]=amount
		if t2[7]<>0
			if fra(t2[7]*100)<>0
				let t2[7]=fnr(t2[7])
			endif
		endif	
		call dxget("TaxCode",tmp$)
		let tmp3=tmp$
		if tmp3<1 or tmp3>7999
			let returnstatus=0
			let message$=message$+"Invalid Tax Code Submitted "+str$(tmp3)
			goto endsubmitordtot:
		endif
		let roh.taxcode=tmp$
		call dxget("TaxPct",tmp$)
		let t2[2]=tmp$
		if eflag<>0
			let returnstatus=0
			goto endsubmitordtot:
		endif
		if returnstatus=0 goto endsubmitordtot:
		let message$="OK"
			
		OTBYPTS: ! no totals change comes here
		IF roh.ordtype=6 or roh.ordtype=10
			t2[6]=0-t2[7] ! oth=neg tax
			t2[3]=t2[1] ! disc=subtotal
		Endif
		! third party tax calc run/check
		if custom_customer$="HTBERRY" or P61$[140,140]="Y" ! custom_customer$="PIEDMONT" ! as it should only do upon totals accept
			read #ch_tax,roh.taxcode,412;tcb; ! tax calcby
			If TCB=1 or tcb=2 ! tax calc'd by CCH/AvaTax - go get it now 
				Let OrderRec=rec_roh ! header rec # - orders/credits same? Y
				Chan[1]=CH_cust;Chan[2]=CH_ROH;Chan[3]=CH_ROS;Chan[4]=CH_ROT ! cust,roh,ros,rot
				Chan[5]=CH_ROL;Chan[6]=CH_TAX;Chan[7]=CH_CTAX ! " ROL, TAXCODE, CTAXTYPE
				if tcb=1 Call "cch.calc.dsout.dl4",OrderRec,Chan[],Intco,rstr$
				if tcb=2 Call "ava.gettaxout.dl4",OrderRec,Chan[],Intco,rstr$
				MAT  READ #CH_ROT,roh.totrec,8;T2 ! re-read totals & tax t2[0]&t2[7](/t2[6])
			Endif
		Endif ! custom berry/piedmont tax calc by third party
		! write out the totals
		MAT  write #CH_ROT,roh.totrec,8;T2       
		MAT  write #CH_ROT,roh.totrec,168;MCODE  
		MAT  write #CH_ROT,roh.totrec,208;MCHARGE
		MAT  write #CH_ROT,roh.totrec,328;TOT    
		MAT  write #CH_ROT,roh.totrec,358;MCTXBL 
		! calc for profit fields
		LET roh.totdol4prof=T2[1]-roh.totfrgtadd \ LET roh.totcost4prof=T2[17]     
		IF P9$[35,35]="Y" LET roh.totdol4prof=roh.totdol4prof+T2[5]+roh.totfrgtadd
		IF P9$[36,36]="Y" LET roh.totdol4prof=roh.totdol4prof-T2[3]      
		IF P9$[37,37]="Y" LET roh.totcost4prof=roh.totcost4prof+T2[20]     
		IF P9$[38,38]="Y" LET roh.totdol4prof=roh.totdol4prof+T2[6]      
		LET roh.totdol4prof=roh.totdol4prof+TOT[1];roh.totcost4prof=roh.totcost4prof+TOT[2] 
		write #ch_roh,rec_roh,156;roh.totdol4prof;
		write #ch_roh,rec_roh,160;roh.totcost4prof;
		write #ch_roh,rec_roh,78;roh.taxcode;
		! for order total - if 3rd party tax calc - cannot change tax $!right after we got it!
		clear ch[] ! channels for files sent to order total
		LET CH[2]=CH_ZONE;CH[3]=CH_PROD;CH[4]=CH_COMCDE;CH[5]=CH_CUST             
		LET CH[6]=CH_PRWH;CH[7]=CH_ROS;CH[8]=CH_ROH;CH[9]=CH_ROT;CH[10]=CH_ROL    
		LET CH[11]=CH_SPRODDESC;CH[12]=CH_CTAX;CH[13]=CH_SSLSM;CH[14]=CH_TAX
		LET CH[15]=CH_SPRODLOT;CH[16]=CH_SORDLOT;CH[17]=CH_CCODE;ch[19]=ch_misc
		LET CH[20]=CH_TERMS
		clear s9[]
		let s9[0]=orderid
		let s9[1]=intco
		let s9[2]=roh.slsm
		let s9[4]=Source ! 201 ! order entry program #
		if credit let s9[4]=241
		! use source except 201/208 (is 0)
		If s9[4]=0 and int(roh.orgstatus)=0 and roh.spare2=0
			let S9[4]=201 ! could be 207!
		endif
		if s9[4]=0 let s9[4]=208
		if source=2082 let s9[4]=208 ! order edit
		if S9[4]=201 AND (roh.orgstatus>0 and roh.orgstatus<5) let S9[4]=208 ! NOT ENTRY
		! it seems web always sends source as 201? for entry & edit?
		R5 = custrec ;H1 = REC_ROH;V1 = slsmrec
		param[0]=0 !cred check 
		!param[1]=1 !no cred check
		param[1]= 0 ! no credit check 0 !no cred check
		If roh.orgstatus=0 and roh.spare2=0 and roh.ordtype<>16 let param[1]=1 
		param[2]=0 !no exception check
		param[3]=1 !write total data out
		param[4]=1 !no retotal of customer on order
		if p60$[40,40]="S" let param[4]=1! retotal on order if based on shipped
		param[5]=0 !do no clear manual edits
		param[6]=0 !no clear cash stuff
		if not(param[9])
			if credit<>0 let param[9]=99 ! bypass credit delivery charges
		endif
		
		MAT  READ #CH_ROT,roh.totrec,0;T1       
		MAT  READ #CH_ROT,roh.totrec,8;T2       
		MAT  READ #CH_ROT,roh.totrec,168;MCODE  
		MAT  READ #CH_ROT,roh.totrec,208;MCHARGE
		MAT  READ #CH_ROT,roh.totrec,328;TOT    
		MAT  READ #CH_ROT,roh.totrec,358;MCTXBL 
		MAT  READ #CH_ROT,roh.totrec,378;DCLVL;
		!if s9[4]=223 and t2[10]<>0! edit
		!	let param[6]=0
		!endif
		if not(param[9])
			if t2[10]<>0 let param[9]=99 ! bypass cash sale delivery charges
			if s9[4]=231 let param[9]=99 ! bypass one step delivery charge
			if s9[4]=251 let param[9]=99 ! bypass point of sale delverycharge
			if s9[4]=208 let param[9]=99 ! bypass calc on sales order edit
			if s9[4]=223 let param[9]=99 ! bypass calc on invoice edit
			if s9[4]=201 and t2[24]<>0
				let param[9]=99 ! order entry in an edit mode
				!IF ROH.ORDNUM=7040 Call dxsave(0,"/tmp/mtg.txt!") ! programdump("tmp/ordh3!","")
				let s9[4]=208 ! it's an edit
			endif
		endif
		let param[10]=99 ! bypass calc
		if p61$[138,138]="Y"
			if s9[4]=231 let param[10]=0 ! bypass one step delivery charge
			if s9[4]=251 let param[10]=0 ! bypass point of sale delverycharge
			if s9[4]=223 let param[10]=0 ! invoice edit
			if credit<>0 let param[10]=0 
		endif
		IF S9[4]=208 and t2[24]=0 ! need to check if it from 201 or 208
				call dxget ("SOURCE",tmp$)
				let source=tmp$ 
				if source=201 let param[9]=0!  USES 0 for them!
		endif ! mtg
		PARAM[8]=99 ! bypass freight charge calc
		if not(param[9]) let param[9]=99 ! submitting totals no need to calc
		if custom_customer$="MORRISETTE" and param[1]=1
					if roh.orgstatus>0 and roh.orgstatus<9 let param[1]=0 ! no credit check
		endif
		if custom_customer$="PIEDMONT" and param[1]=1
					if roh.orgstatus>0 and roh.orgstatus<9 let param[1]=0 ! no credit check
		endif
		If P60$[16,16] = "Y"    ! submit order total     
			orgshipdate = roh.ShipDate
			orgtotwgt = T2[16]        
		End If                      
		if NOT(UPDTSTAT) let param[6]=0;param[9]=99;param[10]=99 ! just total it please
		Call "ORDERTOTAL",S9[],H1,PARAM[],ch[],T1[],T2[],MCODE[],MCHARGE[],TOT[],MCTXBL[],DCLVL,R5,V1,CFIN[]
		read record #ch_roh,rec_roh;roh.
		read record #ch_rot,roh.totrec;rot.
		read record #ch_ros,roh.shiprec;ros.
		roh.spare2=99
		if p61$[36,36]="Y" and roh.spare2<>88 ! delivery charge on inv
				if s9[4]=231 or s9[4]=223 or s9[4]=251
					let roh.spare2=88
				endif
		endif
		write record #ch_roh,rec_roh;roh.;
		If P60$[16,16] = "Y" And abs(orgtotwgt-rot.TotWgt)<1 And orgshipdate <> 999999   ! order total                                                                           
            Read Record #ch_roh,rec_roh;roh.;                                   
            If orgshipdate <> roh.ShipDate And orgshipdate <> 0                 
              roh.ShipDate = orgshipdate                                        
              Write Record #ch_roh,rec_roh;roh.;                                
            End If                                                              
          End If                                                                
		if NOT(UPDTSTAT) goto BYPSTUP ! task 36030 - no status chg - just totals
		! reset status !
		if editstatus=9 and source<>251 ! order completed
			OStat=roh.status ! status in key 
			let roh.status=int(roh.orgstatus)
			if roh.status=0
				let roh.status=1
				if source=251 and roh.invnum<>0 let roh.status=5 
				if credit let roh.status=9
				if source=223 or source=231 let roh.status=5
				! new order is original status = 0, current status in process
				! if we get here, we know the original status is 0, if not in process
				! this means 2 people must've edited the order at the same time and this
				! is the second session submitting the order
				if (OStat < 90) ! current status is not in process!
					returnstatus=2
					message$="ERROR!! Original status: "+str$(ostat)+"  - Order Reset to Status: "+str$(roh.status)
				end if
			endif
			if not(credit) and source>=231 and roh.ordtype=16 ! 1step/POS
			  if source<>2082
				IF P61$[55,55]="N" AND roh.ordtype=16 let roh.status=6
			  Endif ! not Inv on up
			Endif
			if source=223 and roh.orgstatus=6 let roh.status=5 ! set it back to not printed
			if credit and roh.status=10 let roh.status=9 ! credits back to not printed per csr
			if p9$[45,45]<>"Y"
				if roh.orgstatus>1 and roh.orgstatus<=4
					call dxget("RESETPRTSTAT",tmp$)
					if rtrim$(ucase$(tmp$))="Y"
						if rec_uac>0 ! check user cntrl
							UCC = OpenFile(-9988, intCo)
							if ucc>=0! open user cntrl file
								mat read #ucc,rec_uac,336;UA2$;
								let tmp3=ua2$[23,23]
								if tmp3>0
									if roh.orgstatus<=tmp3
										let roh.status=1
									endif
								endif
							endif
						endif
						Try Close #UCC  Else Rem
					endif
				endif 
			Else ! bypass 221 flag=Y
				if not(credit) and (source=0 or source=201 or source=208 or source=2082) ! orders only
					if roh.ordtype<>5 and roh.status<=1 let roh.status=2
				Endif
			endif
			if custom_customer$="PHILLIPS" ! task#14152/cct#109870
				if source=223
					if roh.ordtype<>16
						let roh.status=5
					else
						let roh.status=roh.orgstatus
						if roh.status<5 or roh.status>6
							let roh.status=6
						endif
					endif
				endif
				if roh.ordtype=16
					if source=221 or source=231
						if roh.ordtype=16
							let roh.status=6 ! flag as printed
						endif
					endif
				endif
			endif
			let keyroh$=" ",keyroh$
			let keyroh$[1,2]=roh.status using "##"
			let keyroh$[3,8]=orderid using "######"
			search #ch_roh,4,1;keyroh$,rec_roh,e
			if ostat<=0 and credit let ostat=97
			if ostat<=0 and source=231 let ostat=94
			if ostat<=0 and source=251 let ostat=94
			if ostat<=0 and source=223 let ostat=96
			if ostat<=0 let ostat=95
			if ostat<>roh.status
				let keyroh$[1,2]=ostat using "##"
				search #ch_roh,5,1;keyroh$,rec_tmp,e
			Endif
			roh.orgstatus=0
			write record #ch_roh,rec_roh;roh.; ! order complete
			read record #ch_rot,roh.totrec;rot.;
			read record #ch_ros,roh.shiprec;ros.; 
		endif ! of returnstatus<>0??
		! endif order total
		! add order & line alerts
		if not(credit)
			clear ch[] ! channels for files sent to MXLINEPT
			LET CH[2]=CH_ZONE;CH[3]=CH_PROD;CH[4]=CH_COMCDE;CH[5]=CH_CUST             
			LET CH[6]=CH_PRWH;CH[7]=CH_ROS;CH[8]=CH_ROH;CH[9]=CH_ROT;CH[10]=CH_ROL    
			LET CH[11]=CH_SPRODDESC;CH[12]=CH_CTAX;CH[13]=CH_SSLSM;CH[14]=CH_TAX
			LET CH[15]=CH_SPRODLOT;CH[16]=CH_SORDLOT;CH[17]=CH_CCODE;ch[19]=ch_misc
			LET CH[20]=CH_TERMS
			clear s9[]
			S9[2]=rec_roh
			call "mxlinept.dl4",CH[],s9[],IntCo ! ttlavl<linept/min chk (whole order)
		Endif
	   endif ! order data ok
	   BYPSTUP: ! bypass status & mxlinept alert
	endif ! of order ok
	endsubmitordtot: ! end submit of order totals
	clear list$[]
	List$[0]=bsdel$,"SubmitTotal",fdel$
	webstr$="OrderId",fdel$
	If (custom_customer$="HTBERRY" and tcb=1) or (p61$[140,140]="Y" and tcb=2) ! cch/avalara custom_customer$="PIEDMONT"
		webstr$=webstr$,"TaxAmt",fdel$,"Other",fdel$,"OrderTotal",fdel$
	else
		webstr$=webstr$,"",fdel$,"",fdel$,"",fdel$
	Endif
	webstr$=webstr$,"PROMPTPRICES",FDEL$,"PRNTPRICEDEF",fdel$
	Webstr$=webstr$,"InvoiceId",fdel$
	webstr$=webstr$,"ORDERAMT",fdel$
	webstr$=webstr$,"ORDERCOST",fdel$
	List$[1]=WebStr$
	WebStr$=str$(orderid),fdel$
	! return status of 2 is now used to indicate a message possibly needs to
	! be displayed in addition to the CCH stuff. so, here's how it works:
	! returnstatus=2 means:
	! if messsage in status section is not null, display it, otherwise don't
	! if additional columns needed by CCH are present, use them, otherwise don't
	If (custom_customer$="HTBERRY" and tcb=1) or (p61$[140,140]="Y" and tcb=2) ! cch flds changed custom_customer$="PIEDMONT"
	  If returnstatus=1 or returnstatus=2 ! ok so far
		!webstr$=webstr$,"TaxAmt",fdel$,"Other",fdel$,"OrderTotal",fdel$
		Webstr$=webstr$+RTrim$((rot.taxamt) Using "----------.##") + fdel$
		Webstr$=webstr$+RTrim$((rot.OthChrg) Using "----------.##") + fdel$
		Webstr$=webstr$+RTrim$((rot.OrdTot) Using "----------.##") + fdel$
		let returnstatus=2 ! message to webside
	  else
		webstr$=webstr$,"",fdel$,"",fdel$,"",fdel$
	  Endif ! ok and third party
	else
		webstr$=webstr$,"",fdel$,"",fdel$,"",fdel$
	Endif
	let tmp$="N"
	if custom_customer$="SWP"
		IF not(source) !if source=208 or source=243
			let tmp$="Y" ! prompt to print prices
			if credit and roh.ShipType<>6 let tmp$="N" !pickups only

		endif
	endif
	webstr$=webstr$,tmp$,fdel$
	let tmp$="0" ! for no
	if cust.PrintOrderPrices<>0 let tmp$="1" !  for yes customer's default
	webstr$=webstr$,tmp$,fdel$
	Webstr$=webstr$,str$(roh.invnum),fdel$
	let amount=rot.MdseOrdAmt
	if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		let factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$,str$(amount),fdel$ ! rot.mdseordamount
	let amount=rot.totordcost 
	if p61$[136,136]="Y" and roh.currfact<>0 and amount<>0
		let factor=roh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$,str$(amount),fdel$ ! rot.totordcost
	LIST$[2]=Webstr$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	
	sotdone: ! done
	! they want the status "message" to indicate how the tptc went!
	If (custom_customer$="HTBERRY" and tcb=1) or (P61$[140,140]="Y" and tcb=2) ! cch flds changed
	  ! so do what order/inv print does - check for transid in ordtrans file!
	  If returnstatus=1 or returnstatus=2 ! ok so far
		tchan=findchannel()
		if tcb=1 ! cch
			tmp$="7/cchordtrans"+Str$(intco)
		endif
		if tcb=2 ! avalara
			tmp$="7/avaordtrans"+Str$(Intco)
		endif
		if tmp$[1,2]="7/" ! ok continue - got filename
			Try 
				ROpen #tchan,tmp$
			Else
				message$="No Order trans file for tptc"
				goto tptccdone
			End try
			tmp$=" ",tmp$
			tmp$=roh.ordnum using "######"
			Search #tchan,2,1;tmp$,R,E
			if e let tmp$=" ",tmp$
			if tmp$[7,9]="   " or Rtrim$(tmp$)=""
				let message$="NO TAX CALCULATION - SEE LOG"
				! hopefully this makes it to the user!
			endif
			try close #tchan else rem
			tptccdone: ! finished
		Endif
	  Endif ! of status of action is ok
	Endif ! of tptc
	! status section
	if source=251 and returnstatus=1
		let returnstatus=9
	endif
	if source=223 and returnstatus=1
		if roh.terms=1
			let returnstatus=9
		endif
		if not(ch_roc)
			ch_roc = OpenFile(2224,IntCo) 	
		endif
		if ch_roc>0
			let keyroc$=orderid using "######" 
			rec_roc = filegetsordcash(e$,Ch_roc,"=",1,keyroc$,roc.)
			if rec_roc>0 
				if roc.payamt1<>0 or roc.payamt2<>0 or roc.paytype1<>0 or roc.paytype2<>0
					let returnstatus=9 ! flag for cash sales screen exists
				endif
			endif
		endif
	endif
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)
	! end of SUBMIT ORDTOT
case "GETCASHCUST" ! get default cash CUSTOMER data
	Call GETCASHCUST()
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)	
	! end getcashcust
case "GETCASH" ! get cash data
	Call GETCASH()
	! status section
	!call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	!call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)	
	! end getcash

case "SAVECASH" ! SAVE cash data
	Call SAVECASH()
	! status section
	!call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	!call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)	
	! end savecash

Case "CASHNOSALE"	! 252 Point of Sale Cash Drawer - No Sale
	Call CASHNOSALE()
	call SetOutPut(e$,rstr$)	
	
      
Case "SUBCASHNOSALE"   ! 252 Point of Sale Cash Drawer - No Sale
	Call SubCASHNOSALE()
	call SetOutPut(e$,rstr$)

case "DELETEORD" ! delete order/invoice
	Call DELETEORD()
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)	
	! end Deleteord

 case "GETCUSTDFLT" ! ! CUSTOMER SELECTED
	call dxget ("custid",CustId$)
	call dxget ("orderno",OrderNo$)
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
 	call SetOutput(e$,rstr$)
	

 case "GETCUSTOMER" ! create customer selected
	
	  call dxget ("custid",SearKey$)
	  SearKey$=ucase$(SearKey$)
	
	  isnumber=1 ! 1 = numeric   0 = alpha
	  Try call CheckNumber(SearKey$) else isnumber=0
	    
	  if action1$="VERIFYCUSTOMER" call VerifyCustomer() 
	  call SetOutput(e$,rstr$)
 case "GETNEWCUST" ! get template cust (231/251)			doc=OrdH.GetNewCust.doc
	returnstatus=1
	message$="OK"
	If P61$[69,69] <> "Y"
		returnstatus=0
		message$="FLAG TO ALLOW CREATE CUSTOMER = NO"
		goto chkcrtdone
	Endif
	if source<>231 and source<>251
		returnstatus=0
		message$="Wrong program to create customer"
		goto chkcrtdone
	Endif
	! do we deny if order exists? PM Native only on new ord/inv
	call dxget("ORDERID",tmp$)
	x3=tmp$
	if x3<>0
		returnstatus=0
		message$="Order has been submitted, can not create a customer"
		goto chkcrtdone
	Endif
	Senddata=1
	call ChkcreateCust()
	
chkcrtdone: ! done
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
 	call SetOutput(e$,rstr$)
 ! end of GETNEWCUST
 Case "CRTNEWCUST" ! create it								doc=OrdH.SubmitNewCust.doc
	returnstatus=1
	message$="OK"
	If P61$[69,69] <> "Y"
		returnstatus=0
		message$="FLAG TO ALLOW CREATE CUSTOMER = NO"
		goto crtncdone
	Endif
	if source<>231 and source<>251 ! source gotten at start
		returnstatus=0
		message$="Wrong program to create customer"
		goto crtncdone
	Endif
	! do we deny if order exists? PM Native only on new ord/inv
	call dxget("ORDERID",tmp$)
	x3=tmp$
	if x3<>0 ! let's deny
		returnstatus=0
		message$="Order has been submitted, can not create a customer"
		goto crtncdone
	Endif
	Senddata=0
	call ChkcreateCust()
	e$=""
	! If clflag=-1 goto SORDHDone ! already sent message
 crtncdone: ! done
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	Sccdone: ! 
 	call SetOutput(e$,rstr$)
 ! end of CRTNEWCUST
 case "CHKCMINV" ! See if inv used on other cm's
	! check if inv# entered is used elsewhere
	returnstatus=1
	message$="OK"
	call dxget ("custid",SearKey$)
	SearKey$=ucase$(SearKey$)
	
	isnumber=1 ! 1 = numeric   0 = alpha
	Try call CheckNumber(SearKey$) else isnumber=0
	    
	call VerifyCustomer() 
	If ReturnStatus=0 ! NO GOOD
		goto chkinvdone
	Else
	  ! if good passes back cust. & billto. data
	  Call dxget("ORDERID",tmp$) ! need order? couldn't hurt
	  Orderid=tmp$
	  call dxget("INVNUM",tmp$)
	  InvNum=tmp$
	  if invnum<=0 goto chkinvdone ! got to have it!!
	  if invnum=orderid goto chkinvdone ! no invoice to check!
	  keyroh$=" ",keyroh$
	  keyroh$[1,6]=custid using "######" 
	  keyroh$[7,12]=orderid using "######"
	  keyroh$[13]=""
	  mode$="=" ! search mode 2
	  dir=2
	  clear chan[]
	  CHAN[0]=CH_ROH
	  CHAN[1]=CH_ROS
	  CHAN[2]=CH_ROT
	  Rec_roh=filegetrohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
	  if rec_roh<0 ! not found
		!let returnstatus=0
		!let message$="Credit ",keyroh$[7,12]," Not On File"
		!goto chkinvdone
		! we'll allow no rec for check
		rec_roh=0
		roh.ordnum=orderid
		roh.custnum=cust.CustomerCode
		roh.invnum=invnum ! 
		roh.BillTo=cust.CustomerBillTo
	  else ! good one
		If ros.status<>32
			returnstatus=0
			message$="ORDER "+Str$(orderid)+" is not a credit memo!"
			goto chkinvdone
		Endif
		let roh.invnum=invnum
	  endif ! of bad or good cm
	  ! call programdump("tmp/jcmc.txt!","")
	  ! start on checking
	  Clear List$[]
	  List$[0]=bsdel$,"INVLINES",fdel$
	  WebStr$="LINE",fdel$,"PRODID",fdel$,"DESC1",fdel$,"DESC2",fdel$
	  Webstr$=WebStr$,"QTYORD",fdel$,"QTYSHIP",fdel$,"QTYUM",fdel$
	  WebStr$=WebStr$,"PRICE",fdel$,"PRCUM",fdel$,"COST",fdel$,"COSTUM",fdel$
	  WebStr$=WebStr$,"TAX",fdel$,"WHSE",fdel$
	  List$[1]=webstr$
	  row=2;tmpcnt=maxcnt
		clear ch[]
		ch[0]=ctlc
		ch[1]=ch_roh
		ch[2]=ch_ros
		ch[3]=ch_rot
		ch[4]=ch_rol
		ch[5]=ch_sproddesc
		ch[6]=ch_rom
		ch[7]=ch_ar
		ch[8]=ch_ccode
		ch[9]=ch_prod
		ch[10]=ch_prwh
		mode=1 ! just check it
		clear s9[]
		call cmcpinv(e$,Intco,ch[],s9[],rec_uac,rec_roh,returnStatus,Message$,List$[],row,tmpcnt,mode,roh.,ros.,rot.)
		if returnstatus=0 ! no good
			roh.invnum=roh.ordnum ! reset to cm #?
		Endif
		call AddToStr(e$,rstr$,list$[]) 
	Endif ! of good customer
	chkinvdone: ! done
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
 	call SetOutput(e$,rstr$)
 ! end of CHKCMINV
 case "COPYINVTOCM" ! Pass invnum and line start/end
	! as this is long & complicated - throw it to external sub
	returnstatus=1
	message$="OK"
	call dxget ("custid",SearKey$)
	SearKey$=ucase$(SearKey$)
	clear list$[]
	isnumber=1 ! 1 = numeric   0 = alpha
	Try call CheckNumber(SearKey$) else isnumber=0
	    
	call VerifyCustomer() 
	If ReturnStatus=0 ! NO GOOD
		goto cpinvdone
	Else
	  ! if good passes back cust. & billto. data
	  Call dxget("ORDERID",tmp$) ! need order? couldn't hurt
	  Orderid=tmp$
	  call dxget("INVNUM",tmp$)
	  InvNum=tmp$
	  if invnum<=0 goto cpinvdone ! got to have it!!
	  if invnum=orderid goto cpinvdone ! no inv num to copy
	  ! added morrisette - now std
	  Call dxget("COPYINVCOMM",tmp$)
	  tmp$=UCase$(RTrim$(tmp$))
	  cpicr=1 \ if tmp$="N" let cpicr=0 ! 0=no copy, 1=copy(default)
	  keyroh$=" ",keyroh$
	  keyroh$[1,6]=custid using "######" 
	  keyroh$[7,12]=orderid using "######"
	  keyroh$[13]=""
	  mode$="=" ! search mode 2
	  dir=2
	  clear chan[]
	  CHAN[0]=CH_ROH
	  CHAN[1]=CH_ROS
	  CHAN[2]=CH_ROT
	  Rec_roh=filegetrohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
	  if rec_roh<0 ! not found
		let returnstatus=0
		let message$="Credit ",keyroh$[7,12]," Not On File"
		goto cpinvdone
		!
	  else ! good one
		If ros.status<>32
			returnstatus=0
			message$="ORDER "+Str$(orderid)+" is not a credit memo!"
			goto cpinvdone
		Endif
		let roh.invnum=invnum
	  endif ! of bad or good cm
	  ! as may not send all - just total = to all
	  call CountILines() ! see how many lines on inv
		List$[0]=bsdel$,"LINECPRESULT",fdel$
		List$[1]="LINE#",fdel$,"COPYRESULT",fdel$
		row=2;tmpcnt=maxcnt
		clear s9[]
		CALL dxget("TTLLNCP",tmp$)
		tmp$=UCase$(RTrim$(tmp$))
		x3=tmp$ \ if x3 and x3>=numilines let tmp$="ALL" ! so copies ALL
		if x3=0 and numilines=0 let tmp$="ALL" ! so copies totals too in cmcpinv
		if tmp$="ALL" 
			let s9[8]=-1 \ gosub Docpln
			Goto CPLNDone
		Endif
		let x1=tmp$
		If X1>0
		  for X=1 to x1
			call dxget("CPLINE"+Str$(X),tmp$) ! this may end up a list & so a for next loop!
			x2=Trim$(tmp$)
			if x2>=0 
				let s9[8]=x2
				Gosub docpln
				let s9[7]=1 ! did header copy already
			Endif
		   Next X
		Endif
 	    goto CPLNDone
		Docpln: ! do the line copy
		clear ch[]
		ch[0]=ctlc
		ch[1]=ch_roh
		ch[2]=ch_ros
		ch[3]=ch_rot
		ch[4]=ch_rol
		ch[5]=ch_sproddesc
		ch[6]=ch_rom
		ch[7]=ch_ar
		ch[8]=ch_ccode
		ch[9]=ch_prod
		ch[10]=ch_prwh
		S9[6]=cpicr ! copy inv comm rate 0/1 n/y
		mode=2 ! copy it
		call cmcpinv(e$,Intco,ch[],s9[],rec_uac,rec_roh,returnStatus,Message$,List$[],row,tmpcnt,mode,roh.,ros.,rot.)
		If S9[8]=-1 let WebStr$="ALL",fdel$,Message$,fdel$
		If S9[8]>0 let webstr$=Str$(S9[8]),fdel$,Message$,fdel$
		List$[row]=WebStr$
		row=row+1 \ If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
		! returns with returnstatus & messsage, always new roh.,ros.rot.
		! web would then do action=getorderhdr for reload

	    Return
	  CPLNDone: ! finished
	  List$[row]=esdel$
	  call AddToStr(e$,rstr$,list$[])
	Endif ! of good customer
	cpinvdone: ! done
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
 	call SetOutput(e$,rstr$)
	! end of COPYINVTOCM
 Case "GETOTFLDS" ! send OT data not sent in header			doc=OrdH.GetOTFlds.doc
	! due to changing from default to a diff ordertype
	let returnstatus=1
	let message$="OK"
	call dxget ("custid",Custid$)
	let custid=custid$
	call dxget ("orderid",orderid$)
	let orderid=orderid$
	call dxget ("ordtype",tmp$)
	let ordtype=tmp$
	let keycust$=custid using "######"
	let mode$="="
	let dirno=1
	if custid>0
		CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
	else
		custrec=-1
	Endif
	if custrec<=0
		let returnstatus=0
		let message$="Customer "+str$(custid)+" Not on File"
	Else ! okay
		if orderid<>0
			keyroh$=" ",keyroh$
			keyroh$[1,6]=custid using "######" 
			keyroh$[7,12]=orderid using "######"
			keyroh$[13]=""
			mode$="=" ! search mode 2
			dir=2
			clear chan[]
			CHAN[0]=CH_ROH
			CHAN[1]=CH_ROS
			CHAN[2]=CH_ROT
			Rec_roh=filegetrohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
			if rec_roh<0
				let returnstatus=0
				let message$=message$+"Order Number "+str$(orderid)+" Not On File. "
				goto endgetotdata:
			endif
		Else ! new - need ordtype to decide
			if ordtype=16
				if cust.ConsignWh>0 and cust.ConsignWh<conswh
					let roh.ConsWh=cust.ConsignWh
					roh.Xferauth=0;roh.Authdate=0;roh.authby=0
					if p61$[54,54]="N" or source>=231 ! notusing or 1step/POS
						roh.xferauth=1;roh.authdate=Currdate;roh.authby=rec_uac
					Endif
				Else
					Returnstatus=0
					Message$=Message$+"Customer is not a transfer customer. "
					Goto Endgetotdata
				Endif
			Endif
			if ordtype=7 or ordtype=8
				if cust.ConsignWh<conswh or cust.ConsignWh=0
					Returnstatus=0
					Message$=Message$+"Customer is not a consignment customer. "
					Goto Endgetotdata
				Endif
				let roh.ConsWh=cust.ConsignWh
			Endif
		Endif
		if ordtype=0 let ordtype=roh.OrdType
		! now the individual order type data sends
		clear list$[]
		List$[0]=bsdel$,"ORDTYPE"+Str$(Ordtype),fdel$
		row=1
		List$[1]="FLDS",fdel$ ! default no fields
		List$[2]="NONE",fdel$ ! default no data
		row=3 ! the above are for no changes needed
		if ordtype<1 or ordtype>38 goto OTDDone
		If ordtype=16 ! add the header
			webstr$="XFRTOWH",fdel$
			webstr$=webStr$,"XFERAUTH",fdel$
			webStr$=WebStr$,"XADATE",fdel$
			webstr$=webStr$,"XAUSER",fdel$
			List$[1]=WebStr$
			webstr$=Str$(roh.ConsWh),fdel$
			tmp$="N" \ if roh.XferAuth let tmp$="Y"
			webstr$=webstr$,tmp$,fdel$
			let tmp$="0" \ if roh.XferAuth and roh.AuthDate let tmp$=PDate$(roh.AuthDate)
			webstr$=webstr$,tmp$,fdel$
			tmp$=" " \  if roh.XferAuth and roh.AuthBy let tmp$=Getuidinfo$(E$,IntCo,roh.AuthBy)
			webstr$=webStr$,RTrim$(tmp$[21]),fdel$
			List$[2]=WebStr$
			row=3
		Endif
		if ordtype=7 or ordtype=8
			List$[1]="CONSWH",fdel$
			List$[2]=Str$(roh.ConsWh),fdel$
			row=3
		Endif
		If ordtype=9 ! 
			List$[1]="STAGINGAREA",fdel$
			List$[2]=roh.WhStage$,fdel$
			row=3
		Endif
		if ordtype=4 or ordtype=15 or ordtype=24
			List$[1]="SHIPTERM",fdel$,"MSDATENT",fdel$
			webstr$=" ",webstr$ ! clear all first
			Webstr$=Str$(roh.shipterm),fdel$
			for x=0 to 23
				x2=roh.shipdatelist[x]
				if x2>100 ! valid dates are start at 000101 (01/01/2000)
					tmp$=PDate$(X2)
					Webstr$=Webstr$,tmp$,","
				Endif
			Next X
			if webstr$[len(webstr$)]="," let webstr$[len(webstr$)]="" ! remove last ","
			webstr$=webstr$,fdel$ ! add fld delim
			List$[2]=webstr$
			row=3
		Endif
		IF ordtype=5 ! future
			LIST$[1]="ALCSTKDATE",fdel$
			tmp$=""
			if roh.CmInvHist let tmp$=PDate$(roh.CmInvHist)
			list$[2]=tmp$,fdel$
			row=3
		Endif
		if ordtype=20 ! frgt inv
			list$[1]="ORIGINV",fdel$
			list$[2]=Str$(roh.OrgOrd),fdel$
			row=3
		Endif
		OTDDone: ! finished
	  List$[row]=esdel$
	  call AddToStr(e$,rstr$,list$[])	
	Endif ! of valid or invalid custid
	endgetotdata: ! done
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
 	call SetOutput(e$,rstr$)
	! end of GETOTFLDS
 Case "SUBMITOTFLDS" ! update ot 9,16,4,15,24 (if done as separate window/call)
	let returnstatus=1
	let message$="OK"
	call dxget ("custid",Custid$)
	let custid=custid$
	call dxget ("orderid",orderid$)
	let orderid=orderid$
	call dxget ("ordtype",tmp$)
	let ordtype=tmp$
	let keycust$=custid using "######"
	let mode$="="
	let dirno=1
	if custid>0
		CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
	else
		custrec=-1
	Endif
	if custrec<=0
		let returnstatus=0
		let message$="Customer "+str$(custid)+" Not on File"
	Else ! okay
		!if orderid<>0 ! HAS TO HAVE ORDER ID!!
			keyroh$=" ",keyroh$
			keyroh$[1,6]=custid using "######" 
			keyroh$[7,12]=orderid using "######"
			keyroh$[13]=""
			mode$="=" ! search mode 2
			dir=2
			clear chan[]
			CHAN[0]=CH_ROH
			CHAN[1]=CH_ROS
			CHAN[2]=CH_ROT
			Rec_roh=filegetrohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
			if rec_roh<0
				let returnstatus=0
				let message$=message$+"Order Number "+str$(orderid)+" Not On File. "
				goto SPendgetotdata:
			endif
		!Else ! new - need ordtype to decide
		!Endif
		if ordtype=0 let ordtype=roh.OrdType
		roh.ordtype=ordtype
		! now the individual order type data sends
		if roh.ordtype=5 ! future
			call dxget("ALCSTKDATE",tmp$) ! allow zero - sys date
			tmp1$=chkDateFrmt$(tmp$) ! chk/convert to mm/dd/yyyy
			if tmp1$[1,1]<"0" and tmp1$[1,1]>"9" let tmp1$=""
			x$=formatdate2$(tmp1$) ! from mm/dd/yyyy to yyyymmdd
			roh.CmInvHist=x$[3,8] ! H5[10] on native
			if roh.CmInvHist<101 or roh.CmInvHist>991231 let roh.CmInvHist=0
		Endif
		if roh.ordtype=9
			call dxget("STAGINGAREA",tmp$)
			let roh.WhStage$=tmp$+Blank$
		Endif
		If roh.ordtype=16
			call dxget("XFERAUTH",tmp$)
			if UCase$(RTrim$(tmp$))="Y"
				If roh.XFERAUTH=0 ! not previously authorized
					let roh.XferAuth=1
					roh.AuthBy=rec_uac
					roh.AuthDate=CurrDate
				Endif
			Endif ! if "N" or previously auth - leave alone
		Else
			roh.XferAuth=0
			roh.AuthBy=0
			roh.AuthDate=0
		Endif
		! roh.ordtype=20 ! frgt inv (done in mx231afi)
		if roh.ordtype=4 or roh.ordtype=15 or roh.ordtype=24 ! doc=OrdH.SubmitOT15Flds.doc
			! has ship term & (shipdatelist[] if shipterm=0
			CALL dxget("SHIPTERM",tmp$)
			x2=tmp$  ! options ###=every # days, -## = that day every month
			if x2<0 and x2<-31
				let returnstatus=0
				let message$=message$+"Ship on day Invalid"
				goto SPendgetotdata:
			Endif
			ROH.ShipTerm=x2
			if roh.shipterm=0 ! means entered individual dates
				call OTMSDTIN() ! get in / arrange S3[23]
			Else ! no dates
				Clear roh.shipdatelist[]
			Endif
		Else
			roh.shipterm=0
			Clear roh.shipdatelist[]
		Endif
		WRITE RECORD #CH_ROH,REC_ROH,0;roh.;
	Endif
	SPendgetotdata: 
	! done
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
 	call SetOutput(e$,rstr$)
	! end of SUBMITOTFLDS
 CASE "CREATEMIPO"  !							doc= ORDH-CreateMIPO.doc
	! call to create PO's for Mill items on the order
	! set up for the po create call
	call dxget ("CUSTID",Custid$)
	call dxget ("ORDERID",orderid$)
	let custid=custid$
	let orderid=orderid$
	call dxget ("SOURCE",tmp$)
	let source=tmp$
	LET returnstatus=1
	let message$="OK"
	if source<>201 and source<>208 goto SPOCDone ! ONLY ORDERS!
	keyroh$=" ",keyroh$
	keyroh$[1,6]=custid using "######" 
	keyroh$[7,12]=orderid using "######"
	keyroh$[13]=""
	mode$="=" ! search mode 2
	dir=2
	clear chan[]
	CHAN[0]=CH_ROH
	CHAN[1]=CH_ROS
	CHAN[2]=CH_ROT
	Rec_roh=filegetrohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
	if rec_roh<0
		let returnstatus=99
		let message$="Order Number ",keyroh$[7,12]," Not On File"
	endif

	if returnstatus<>1 goto SPOCDone ! something failed - abort
	Clear List$[]
	Clear message$
	clear s9[]
	let s9[4]=source
	let s9[2]=rec_roh
	clear ch[]
	ch[1]=ch_prod;ch[2]=ch_prwh;ch[3]=ch_wh;ch[4]=ch_ccode
	ch[5]=ch_roh;ch[6]=ch_rol;ch[7]=ch_ros;ch[8]=ch_rot
	ch[9]=ch_rom;ch[10]=ch_sproddesc
	call "sopocrte.dl4",S9[],Intco,Ch[],userid$,E$,returnstatus,message$,List$[]
	Call addtostr(e$,rstr$,List$[]) ! return list of po created
	SPOCDone: ! done
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
 	call SetOutput(e$,rstr$)
	! end of CREATEMIPO
 CASE "INVHIST"
	dim 1%,reftype,3%,refid
	dim filename$[50],keyinvd$[50],3%,rec_invd
	returnstatus=1
	message$="OK"
	! call dxsave(0,"tmp/239in.txt!")
	IF RTRIM$(UCASE$(ACTION1$))="SEARCH"
		dim Invlist$[500,2000]
		let tmpcnt=500
		call dxget("SEARCHTYPE",tmp$)
		if rtrim$(ucase$(tmp$))="C"  ! customer search
			call getcustinvhlist()
		endif
		if rtrim$(ucase$(tmp$))="O" ! order number search
			call GetOrdRefId()
		endif
		if rtrim$(ucase$(tmp$))="I" ! invoice number search
			call GetInvRefId()
		endif
		if rtrim$(ucase$(tmp$))="H" ! orig order number history search
			call GetOrdOrgId()
		endif
		Call CheckImages()	! look for delivery receipt
	endif
	
	if rtrim$(UCASE$(ACTION1$))="DETAIL"
		call dxget("CUSTID",tmp$)
		let custid=tmp$
		call dxget("REFID",tmp$)
		let refid=tmp$
		call dxget("STATUS",tmp$)
		let reftype=0
		if rtrim$(ucase$(tmp$))="INV" let reftype=30
		if rtrim$(ucase$(tmp$))="C/M" let reftype=31
		If custid>0 and custid<>prt.CashSaleCustNum
			 Custsec[0]=custid;custsec[1]=1 ! id & NO ALERT
			 call "custsec.dl4",Custsec[],ctlc,userid$,e$,rstr$
			 if custsec[0]=-1 ! not allowed
				returnstatus=0
				message$="You do not have access this customer"
				goto INVHDone
			 Endif
		Endif ! don't check on cash cust or cash sales		
		call getinvhdr()   ! get the invoice header
		Call getinvhlines()! get the invoice lines
		Call getinvhmsg()  ! get the invoice message
		Call getinvhtot()  ! get the invoice total
		Call CheckImages()	! look for delivery receipt
		Call getinvhcash() ! get cash total	
	endif
	if rtrim$(UCASE$(ACTION1$))="SUMMARY"
		call dxget("CUSTID",tmp$)
		let custid=tmp$
		call dxget("REFID",tmp$)
		let refid=tmp$
		call dxget("STATUS",tmp$)
		let reftype=0
		if rtrim$(ucase$(tmp$))="INV" let reftype=30
		if rtrim$(ucase$(tmp$))="C/M" let reftype=31
		If custid>0 and custid<>prt.CashSaleCustNum
			 Custsec[0]=custid;custsec[1]=1 ! id & NO ALERT
			 call "custsec.dl4",Custsec[],ctlc,userid$,e$,rstr$
			 if custsec[0]=-1 ! not allowed
				returnstatus=0
				message$="You do not have access this customer"
				goto INVHDone
			 Endif
		Endif ! don't check on cash cust or cash sales	
		call getinvhsumm() ! get the invoice header/ total section
		Call CheckImages()	! look for delivery receipt
	endif
	if rtrim$(UCASE$(ACTION1$))="INVHLABELS"
		call INVHLABEL()
	endif
	if rtrim$(UCASE$(ACTION1$))="SRCHINVHMSG"
		call srchinvhmsg() ! 
	endif
	if rtrim$(UCASE$(ACTION1$))="SRCHINVHCPO"
		call SrchInvhCPO()
	Endif
	if rtrim$(UCASE$(ACTION1$))="GPSUMMARY"
		call GPSUMM()
	Endif 
	if rtrim$(UCase$(Action1$))="COSTLOOKUP"
		returnstatus=1
		message$="OK"
		call dxget("CUSTID",tmp$)
		let custid=tmp$
		call dxget("REFID",tmp$)
		let refid=tmp$
		call dxget("LineNum",tmp$)
		let lineno=tmp$
		call "costlookup.dl4",e$,Intco,Custid,Refid,Lineno,rstr$
		! done - adds to rstr$
	Endif
	INVHDone: ! done
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
 	call SetOutput(e$,rstr$)! 
	
! ===== End Invoice History 
CASE "CREATESHIPLIST"
returnstatus=1
message$="OK"
CALL ChkCreateshiplist()
	e$=""
	! If clflag=-1 goto SORDHDone ! already sent message
 shcrtncdone: ! done
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	shSccdone: ! 
 	call SetOutput(e$,rstr$)

!=== end CREATESHIPLIST
  Case "GETTOTORD"
  ! for cc on Mid-Atlantic - need ordered totals - not shipped
	Dim 3%,OOTOT
	If P61$[94,94] ="Y"
		ch_rod = OpenFile(-10106,intCo)		
	endif
	dim keyrod$[50],keychk$[50],3%,rec_rod,depamt
	dim 3%,ordtaxamt,ordtaxable
	call dxget ("CUSTID",Custid$)
	call dxget ("ORDERID",orderid$)
	let custid=custid$
	let orderid=orderid$
	!call dxget ("SOURCE",tmp$)
	!let source=tmp$
	LET returnstatus=1
	let message$="OK"
	!if orderid=10210 call dxsave(0,"tmp/ordht0!"
	keyroh$=" ",keyroh$
	keyroh$[1,6]=custid using "######" 
	keyroh$[7,12]=orderid using "######"
	keyroh$[13]=""
	mode$="=" ! search mode 2
	dir=2
	clear chan[]
	CHAN[0]=CH_ROH
	CHAN[1]=CH_ROS
	CHAN[2]=CH_ROT
	Rec_roh=filegetrohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
	if rec_roh<0
		let returnstatus=99
		let message$="Order Number ",keyroh$[7,12]," Not On File"
		goto GTOTDone
	endif
	! check for deposits
	let depamt=0
	if p61$[94,94]="Y" 
		let keyrod$=" ",keyrod$
		let keyrod$[1,6]=roh.custnum using "######"
		let keyrod$[7,12]=roh.ordnum using "######"
		do
			search #ch_rod,3,1;keyrod$,rec_rod,e
			if e<>0 exit do
			let tmp3=keyrod$[1,6]\if tmp3<>roh.custnum exit do
			let tmp3=keyrod$[7,12]\if tmp3<>roh.ordnum exit do
			read record #ch_rod, rec_rod;rod.;
			let depamt=depamt+rod.ChkAmt
		loop
	endif
	! calculate tax on items not shipped on backorder
	let ordtax=0;ordtaxable=0
	if p61$[42,42]<>"Y" and rot.taxpct=0 goto endordtax:
	if rot.Subtot<>rot.MdseOrdAmt
		let keyrol$=" ",keyrol$;keyrol$=roh.ordnum using "######"
		do
			search #ch_rol,3,1;keyrol$,rec_rol,e
			if e>0 exit do
			let tmp3=keyrol$[1,6]
			if tmp3<>roh.ordnum exit do
			read record #ch_rol,rec_rol;rol.;
			if rol.TaxFlg<>0 and rol.QtyBO<>0
				if (rol.extordamt-rol.extshipamt)>0 
				! calc tax amt
					If p60$[42,42]="Y" and rol.TaxPct<>0
						let ordtax=ordtax+fnr((rol.extordamt-rol.extshipamt)*rol.taxpct/100)
					else
						let ordtaxable=rol.extordamt-rol.extshipamt
					endif
				endif
			endif
		loop
	endif
	if p60$[42,42]<>"Y" and ordtaxable<>0
		let ordtax=fnr((ordtaxable*rot.taxpct)/100)
	endif
	endordtax: ! 
	!call programdump("/tmp/ordh2!","")
	! T2[0] = T2[1] - T2[3] + T2[4] + T2[5] + T2[6] + T2[7]
	Clear List$[]
	List$[0]=bsdel$,"TOTORDERED",fdel$
	List$[1]="ORDERTOTO",fdel$ ! that's all we need? !,"
	OOTOT=rot.MdseOrdAmt-rot.OrdDisc+rot.MiscChrg+rot.FrgtChrg+rot.OthChrg+rot.TaxAmt-depamt+ordtax
	list$[2]=Str$(OOTOT),fdel$
	List$[3]=esdel$
	call AddToStr(e$,rstr$,lisT$[])

	GTOTDONE:  !finished
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
 	call SetOutput(e$,rstr$)

  ! End of qty ord totals
  Case "CHKREBILLORDER" ! task 45120 - quick check
  ! check what's entered - send any issue back
	dim 2%,INVCust,CurCust
	Dim 3% ! maintain as default! do not change
	returnstatus=1;message$="OK"
	call dxget("CUSTID",tmp$) \ CurCust=tmp$ ! need for compare!
	call dxget("REBILLORDER",tmp$)
	OrgOrd1=tmp$ ! zero/null allowed!
	if OrgOrd1<0 or OrgOrd1>999999
		returnstatus=0;message$="INVALID ORDER NUMBER"
		goto crborddone
	endif
	if OrgOrd1=0 goto crborddone ! zero allowed!
	Ch_Invh = openfile(-1136,intCo) \ If Ch_Invh = -1 Error 42     !"Invoice header file
	Ch_Invk = openfile(-9994,intCo) \ If Ch_invK = -1 Error 42     !"Invoice history Key file
	SearKey$=" ",SearKey$
	SearKey$=OrgOrd1 using "######"
	SEARCH #Ch_Invk,2,3;SearKey$,R,E
	if E
		returnstatus=0;message$="ORDER IS NOT IN HISTORY"
	else
		Read #ch_invh,r,16;Invcust;
		if invcust<>curcust
			returnstatus=0;message$="THAT ORDER IS FOR A DIFFERENT CUSTOMER"
		endif
	endif
	try close #CH_Invh else rem
	try close #CH_Invk else rem
	crborddone: ! finished
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
 	call SetOutput(e$,rstr$)
  ! end of checkrebillorder

end select
    !
SORDHDone: ! done
  ! call dxclose()
else
  include "src/callmainerrnet.inc"
  !call dxclose()
end try
end
 
!--------------------------------------------------------------------
sub OpenFiles()
  
  ! Open files for order entry
  
  Try
    !
   if action$<>"INVHIST"!
    Ch_Cust = OpenFile(1808,intCo) \ If Ch_Cust = -1 Error 42  ! customer
    Ch_Ar = OpenFile(-1504,intCo) \ If Ch_Ar = -1 Error 42  ! a/r invoice
    Ch_Terms = OpenFile(-9981,intCo) \ If Ch_Terms = -1 Error 42  ! a/r term codes
    Ch_Misc = OpenFile(-2032,intCo) \ If ch_misc = -1 Error 42  !misc charge 
    Ch_Ship = OpenFile(-2112,intCo) \ If Ch_Ship = -1 Error 42  !shiplist
    Ch_Zone = OpenFile(-1920,intCo) \ If Ch_Zone = -1 Error 42  !zone file              
    Ch_CSZ = openfile(-9997,intCo) \ If  Ch_CSZ  = -1 Error 42 !"cust/ship zone file  
    Ch_Prod = OpenFile(1792,intCo) \ If Ch_Prod = -1 Error 42  !product file 
    Ch_PrWh = OpenFile(1744,intCo) \ If Ch_PrWh = -1 Error 42  !"product warehouse file
    Ch_Wh = OpenFile(-2768,intCo) \ If Ch_Wh = -1 Error 42  !" warehouse file
    Ch_Ccode = OpenFile(-1728,intCo) \ If Ch_Ccode = -1 Error 42  !u/m codes file   
    Ch_Dept = openfile(-1632,intCo) \ If Ch_Dept = -1 Error 42   !dept file 
    Ch_Roh = openfile(1840,intCo) \ If Ch_Roh = -1 Error 42     !"order header file
    Ch_RoL = openfile(1888,intCo) \ If Ch_Rol = -1 Error 42     !"order lines file
    Ch_Ros = openfile(1856,intCo) \ If Ch_Ros = -1 Error 42     !"order shipto file
    Ch_Rot = openfile(1872,intCo) \ If Ch_Rot = -1 Error 42     !"order total file
    Ch_Rom = openfile(1968,intCo) \ If Ch_Rom = -1 Error 42     !"order message file
    Ch_Tax = openfile(-2176,intCo) \ If Ch_Tax = -1 Error 42   !"tax code file
    Ch_Ctax = openfile(-928,intCo) \ If Ch_Ctax = -1 Error 42    !"cust tax type file
    Ch_sslsm= OpenFile(-1824,intCo) \ If Ch_sslsm = -1 Error 42 !salesman 
    Ch_lstpr=OpenFile(-1376,intCo) \ If Ch_lstpr = -1 Error 42 !LAST PRICE
    Ch_slstpr=OpenFile(-9982,intCo) \ If Ch_slstpr = -1 Error 42 !SHIP TO LAST PRICE
    Ch_Et=OpenFile(-1664,intCo) \ If Ch_et = -1 Error 42 !ENTERBY
    Ch_Div=OpenFile(-688,intCo) \ If Ch_div = -1 Error 42 !DIVISION 
    Ch_Src=OpenFile(-1216,intCo) \ If Ch_src = -1 Error 42 !order source
    Ch_Cnotes=OpenFile(-720,intCo) \ If Ch_cnotes = -1 Error 42 !order source
    ch_comcde=OpenFile(-2288,intCo) \ If Ch_comcde = -1 Error 42 !commodity code
    ch_sproddesc=OpenFile(2128,intCo) \ If Ch_sproddesc = -1 Error 42 ! nonstock product
    ch_sprodlot=OpenFile(2528,intCo) \ If Ch_sprodlot = -1 Error 42 !sprodlot file
    ch_sordlot=OpenFile(2320,intCo) \ If Ch_sordlot = -1 Error 42 !sordlot file
    if p61$[135,135] = "Y"
		ch_rfpq = OpenFile(9603,intCo) \ if ch_rfpq = -1 Error 42 !rf pick file
    end if
	If p61$[136,136]="Y"
		ch_curr=OpenFile(-9712,IntCo) \ if ch_curr = -1 Error 42 
	endif
   else
	Ch_Cust = OpenFile(-1808,intCo) \ If Ch_Cust = -1 Error 42  ! customer
	!Ch_Ar = OpenFile(-1504,intCo) \ If Ch_Ar = -1 Error 42  ! a/r invoice
	 Ch_Terms = OpenFile(-9981,intCo) \ If Ch_Terms = -1 Error 42  ! a/r term codes
	 Ch_Misc = OpenFile(-2032,intCo) \ If ch_misc = -1 Error 42  !misc charge 
	!Ch_Ship = OpenFile(-2112,intCo) \ If Ch_Ship = -1 Error 42  !shiplist
	Ch_Zone = OpenFile(-1920,intCo) \ If Ch_Zone = -1 Error 42  !zone file              
	Ch_CSZ = openfile(-9997,intCo) \ If  Ch_CSZ  = -1 Error 42 !"cust/ship zone file  
	Ch_Prod = OpenFile(-1792,intCo) \ If Ch_Prod = -1 Error 42  !product file 
	!Ch_PrWh = OpenFile(1744,intCo) \ If Ch_PrWh = -1 Error 42  !"product warehouse file
	Ch_Wh = OpenFile(-2768,intCo) \ If Ch_Wh = -1 Error 42  !" warehouse file
	Ch_Ccode = OpenFile(-1728,intCo) \ If Ch_Ccode = -1 Error 42  !u/m codes file   
	Ch_Dept = openfile(-1632,intCo) \ If Ch_Dept = -1 Error 42   !dept file 
	Ch_Invh = openfile(-1136,intCo) \ If Ch_Invh = -1 Error 42     !"Invoice header file
	Ch_Invl = openfile(-1184,intCo) \ If Ch_InvL = -1 Error 42     !"Invoice lines file
	Ch_InvS = openfile(-1152,intCo) \ If Ch_InvS = -1 Error 42     !"Invoice shipto file
	Ch_Invt = openfile(-1168,intCo) \ If Ch_Invt = -1 Error 42     !"Invoice total file
	Ch_Invm = openfile(9955,intCo) \ If Ch_invM = -1 Error 42     !"Invoice message file
	Ch_Invk = openfile(-9994,intCo) \ If Ch_invK = -1 Error 42     !"Invoice history Key file
	Ch_Tax = openfile(-2176,intCo) \ If Ch_Tax = -1 Error 42   !"tax code file
	!Ch_Ctax = openfile(-928,intCo) \ If Ch_Ctax = -1 Error 42    !"cust tax type file
	Ch_sslsm= OpenFile(-1824,intCo) \ If Ch_sslsm = -1 Error 42 !salesman 
	!Ch_lstpr=OpenFile(-1376,intCo) \ If Ch_lstpr = -1 Error 42 !LAST PRICE
	!Ch_slstpr=OpenFile(-9982,intCo) \ If Ch_slstpr = -1 Error 42 !SHIP TO LAST PRICE
	 Ch_Et=OpenFile(-1664,intCo) \ If Ch_et = -1 Error 42 !ENTERBY
	 Ch_Div=OpenFile(-688,intCo) \ If Ch_div = -1 Error 42 !DIVISION 
	Ch_Src=OpenFile(-1216,intCo) \ If Ch_src = -1 Error 42 !order source
	!Ch_Cnotes=OpenFile(-720,intCo) \ If Ch_cnotes = -1 Error 42 !order source
	ch_comcde=OpenFile(-2288,intCo) \ If Ch_comcde = -1 Error 42 !commodity code
	!**mtg **	ch_sproddesc=OpenFile(-2128,intCo) \ If Ch_sproddesc = -1 Error 42 ! nonstock product
	! CHECK FOR NON-STOCK HISTORY FILE FOR SPRODDESC 
	!ch_sprodlot=OpenFile(2528,intCo) \ If Ch_sprodlot = -1 Error 42 !sprodlot file
	!ch_sordlot=OpenFile(2320,intCo) \ If Ch_sordlot = -1 Error 42 !sordlot file
	If p61$[136,136]="Y"
		ch_curr=OpenFile(-9712,IntCo) \ if ch_curr = -1 Error 42 
	endif

   Endif
    !
  else
    include "src/callsuberr.inc"
  end try
end sub ! openfiles
! 
!--------------------------------------------------------------------
sub VerifyCustomer()
  !
  ! Checks customer text from web or customer # for verifydocument call
  ! if found changes action1$ to VerifyCustomer
  ! if not sends error message back to web
  !
  Try
    let returnstatus=1
    let message$="OK"
    if isnumber=1 ! customer number
	  tmp3=SearKey$ \ SearKey$=tmp3 using M6$
	  mode$="="
	  dirno=1
	  if tmp3>0
	  CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,SearKey$,cust.)
	  else
		custrec=-1
	  Endif
	  if CustRec>=0 ! record found
	       let custid=tmp3
	       if cust.customerbillto<>0 and cust.customerbillto<>custid
			  mode$="="
			 dirno=1
			 let searkey$=cust.customerbillto using "######"
			 BCustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,SearKey$,billto.)
			 if BCustRec>=0 ! record found
				let action1$="AcctClsd"
			 else
				let returnstatus=0
				Message$="Bill To Customer "+str$(cust.customerbillto)+" Not On File"
			 endif       
  	       else
	        let billto. = cust. 
	       endif 
	  else ! if custrec
	  ReturnStatus=0 ! error not found
	    Message$="Customer ",str$(tmp3)," not found"
	  endif ! if custrec
   endif ! isnumber=1
   ! need customer info header !!!
   ! if returnstatus  ! customer was found 
   !!! send over data section
   !!! 
   ! endif
   ! status section
   
	  
  else
    include "src/callsuberr.inc"
  end try
end sub ! verifycustomer
!
!--------------------------------------------------------------------
Sub GETCASH()
!-------------------------------------------------------------------
! defaults for cash sales
 try
	If P61$[94,94] ="Y"
		ch_rod = OpenFile(-10106,intCo)		
	endif
	dim keyrod$[50],keychk$[50],3%,rec_rod,depamt
	Dim keymat$[2],kcm$[40],field$[10,30]	
	dim 1%,ch_roc,ch_ccc,tmpcnt
	dim 3%,rec_ccc,rec_roc
	dim CCTYPE$[100],keyccc$[50],keyroc$[50]
	dim paytype$[60]
	let paytype$=" ",paytype$
	let paytype$[1]= "None        "
	let paytype$[13]="Cash        "
	let paytype$[25]="Check       "
	let paytype$[37]="Credit Card "
	let paytype$[49]="Other       "
	tmpcnt=maxcnt
	MAT  READ #ctlc,49,0;CCTYPE$;
	clear ccc.
	clear roc.
	ReturnStatus=1
	Message$="OK"
	
	! section 1 --- Pay Type Droplist 
	clear list$[]
	List$[0] = bsdel$,"CASHPAYTYPE",fdel$
	Webstr$="Id",fdel$,"Desc",fdel$
	List$[1]=webstr$
	let row=2
	for ctr=0 to 4
		webstr$=Str$(ctr),fdel$
		webstr$=WEBSTR$,rtrim$(PAYTYPE$[ctr*12+1,ctr*12+12]),fdel$
		list$[row]=webstr$
		row=row+1
	next ctr
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	! section 2 -- Credit Card Types
	clear list$[]
	List$[0] = bsdel$,"CREDCARDTYPE",fdel$
	Webstr$="Id",fdel$,"Desc",fdel$
	list$[1] = webstr$
	webstr$="0",fdel$,"None",fdel$
	list$[2]=webstr$
	row=3
	for ctr=1 to 9
		tmp$=cctype$[ctr*10-9,ctr*10]
		if rtrim$(tmp$)<>""
			webstr$=str$(ctr),fdel$
			webstr$=webstr$,rtrim$(CCTYPE$[ctr*10-9,ctr*10]),fdel$
			list$[row]=webstr$
			row=row+1
		endif
	next ctr
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	! section 3 - Customer Credit Card List
	clear list$[]
	List$[0] = bsdel$,"CUSTCREDITCARD",fdel$
	
	Webstr$="CCARD TYPE",fdel$,"TYPE DESC",fdel$,"CREDIT CARD NUMBER",fdel$,"EXPIRES",fdel$
	webstr$=WEBSTR$,"DEPT NAME",fdel$,"Hidden Card Number",fdel$
	Webstr$=webstR$,"Addr",fdel$,"Zip",fdel$
	List$[1]=webstr$
	if not(ch_ccc)
		ch_ccc = OpenFile(-9970,IntCo)
		if ch_ccc=-1 goto EndGetCashSect3
	endif
	! get the order # 
	 Call dxget("ORDERID",tmp$)                                   
	If tmp$ = ""                                                 
		Message$ = "ORDER # MISSING"                               
		ReturnStatus = 0                                           
		Goto EndGetCashSect3
	                                        
	End If
	orderid = tmp$  
	call dxget ("custid",Custid$)
	let custid=custid$
	                                          
	If orderid > 0 And orderid < 999999 And Not(Fra(orderid))    
		keyroh$ = " ",keyroh$                                             
		keyroh$[1,6] = custid Using "######"                              
		keyroh$[7,12] = orderid Using "######" 
		keyroh$[13]=""
		mode$ = "=" ! search mode 2                                       
		dir = 2                                                           
		Clear chan[]                                                      
		chan[0] = ch_roh                                                  
		chan[1] = ch_ros                                                  
		chan[2] = ch_rot                                                  
		rec_roh = filegetrohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.) 
		If rec_roh <= 0 ! no order found                               
			Message$ = "ORDER # NOT FOUND"                           
			ReturnStatus = 0                                         
			Goto EndGetCashSect3                                         
		 End If 
	else
		Message$ = "Invalid Order Number " +str$(orderid)                          
		ReturnStatus = 0                                         
		Goto EndGetCashSect3        
	End If
	if ROH.ordtype=19 and roh.Ot19Comp=1 ! partial
		returnstatus=0
		message$="No cash sale entry on Bill Complete Partial"
		Goto EndGetCashSect3
	endif
	if ROH.ordtype=37 ! and roh.Ot19Comp=1 ! partial
		returnstatus=0
		message$="No cash sale entry on EVAP Shipping"
		Goto EndGetCashSect3
	endif
	let row=2
	let keyccc$=roh.CustNum  using "######"
	                                  
	Do !                        
		rec_ccc = filegetccctype(e$,Ch_ccc,">",1,keyccc$,ccc.)  
		If rec_ccc <= 0 Exit Do                                 
		x2=keyccc$[1,6] \ If x2 <> roh.CustNum Exit Do
		webstr$=str$(ccc.CCType),fdel$
		let tmp$=""
		if ccc.cctype>0 and ccc.cctype<10
			ctr = ccc.cctype
			let tmp$=CCTYPE$[ctr*10-9,ctr*10]
		endif
		webstr$=webstr$,rtrim$(tmp$),fdel$
		let tmp$=rtrim$(ccc.CCNum$)
		if len(tmp$)>4
			for ctr=1 to (len(tmp$)-4)
				let tmp$[ctr,ctr]="*"
			next ctr
		endif
		webstr$=webstr$,tmp$,fdel$
		tmp$=ccc.ExpDate USING "&&&&&&"
		webstr$=webstr$,tmp$[1,2],"/",tmp$[3,6],fdel$
		webstr$=webstr$,rtrim$(ccc.CCName$),fdel$
		webstr$=webstr$,rtrim$(ccc.CCNum$),fdel$
		webstr$=webstr$,rtrim$(ccc.CCAddr$),fdel$
		webstr$=webstr$,rtrim$(ccc.CCZip$),fdel$ 
	        If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
		list$[row]=webstr$
		let row=row+1
	Loop
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section	
	! 
	EndGetCashSect3: ! end section 3
	
	! section 4 - Cash Screen
	clear list$[]
	CALL dxget("SOURCE",tmp$)
    source=tmp$ ! s/b program #
	List$[0] = bsdel$,"GETCASH",fdel$
	Webstr$=""
	Webstr$="PAYTYPE1",fdel$
	Webstr$=webstr$,"PAYTYPE1DESC",fdel$
	Webstr$=webstr$,"PAYAMT1",fdel$
	Webstr$=webstr$,"PAYACCT1",fdel$
	Webstr$=webstr$,"PAYDESC1",fdel$
	Webstr$=webstr$,"CCNAME1",fdel$
	Webstr$=webstr$,"CCADDR1",fdel$
	Webstr$=webstr$,"CCZIP1",fdel$
	webstr$=webstr$,"CCEXP1",fdel$
	webstr$=webstr$,"CCTYPE1",fdel$
	webstr$=webstr$,"CCTYPE1DESC",fdel$
	webstr$=webstr$,"CCAPPR1",fdel$
	webstr$=webstr$,"CCSWIPE1",fdel$
	webstr$=webstr$,"CCVERIF1",fdel$
	Webstr$=webstr$,"PAYTYPE2",fdel$
	Webstr$=webstr$,"PAYTYPE2DESC",fdel$
	Webstr$=webstr$,"PAYAMT2",fdel$
	Webstr$=webstr$,"PAYACCT2",fdel$
	Webstr$=webstr$,"PAYDESC2",fdel$
	Webstr$=webstr$,"CCNAME2",fdel$
	Webstr$=webstr$,"CCADDR2",fdel$
	Webstr$=webstr$,"CCZIP2",fdel$
	webstr$=webstr$,"CCEXP2",fdel$
	webstr$=webstr$,"CCTYPE2",fdel$
	webstr$=webstr$,"CCTYPE2DESC",fdel$
	webstr$=webstr$,"CCAPPR2",fdel$
	webstr$=webstr$,"CCSWIPE2",fdel$
	webstr$=webstr$,"CCVERIF2",fdel$
	webstr$=webstr$,"SOCSEC",fdel$
	webstr$=webstr$,"LICENSE",fdel$
	webstr$=webstr$,"LICEXP",fdel$
	webstr$=webstr$,"PAYNAME",fdel$
	webstr$=webstr$,"TRANSID",FDEL$
	webstr$=webstr$,"INVOICEAMT",FDEL$
	webstr$=webstr$,"DEPOSITAMT",FDEL$
	webstr$=webstr$,"BALANCE",FDEL$
	webstr$=webstr$,"INVOICEID",FDEL$
	webstr$=webstr$,"TERMDESC",fdel$
	webstr$=webstr$,"DOB",fdel$
	webstr$=webstr$,"CCTRTYPE1",fdel$
	webstr$=webstr$,"CCTRTYPE2",fdel$
	webstr$=webstr$,"ALLOWBALDUE",FDEL$
	webstr$=webstr$,"CCINTERFACE",fdel$
	
        list$[1]=webstr$                          
	if returnstatus=0 goto EndGetCashSect4:
	if not(ch_roc)
		ch_roc = OpenFile(2224,IntCo) 
		If ch_roc = -1 
			let returnstatus=1
			Message$="Order Cash File Not Found"
			goto EndGetCashSect4:
		endif
	endif
	let keyroc$=orderid using "######" 
	
	rec_roc = filegetsordcash(e$,Ch_roc,"=",1,keyroc$,roc.)
	if rec_roc<0 ! add new
		clear roc.
		if ROH.ordtype=16 ! transfer
			returnstatus=0
			message$="No cash sale entry on Warehouse Transfer"
			Goto EndGetCashSect4:
		endif
		if ROH.ordtype=37 ! EVAP shipper
			returnstatus=0
			message$="No cash sale entry on EVAP Shipping"
			Goto EndGetCashSect4:
		endif
		roc.OrdNum=orderid
		!IF P9$[48,48]="Y"  ! 498 - always set
			if prt.CRBankNum > 0 let roc.BankNum1=prt.CRBankNum 
			if prt.CashSlsBankNum> 0 let roc.BankNum2=prt.CashSlsBankNum
			if roc.banknum1<=0 let roc.banknum1=1
			if roc.banknum2<=0 let roc.banknum2=1
		!ENDIF
		roc.nu1$=blank$
		roc.InvNum=roh.InvNum
		!rec_roc = fileupdatesordcash(e$,ch_roc,"a",0,roc.) 
		!if rec_roc<0
		!	let returnstatus=1
		!	Message$="Error Adding Order Cash Record"
		!	goto EndGetCashSect4:
		!endif
	endif
	! check for deposits
	let depamt=0
	if p61$[94,94]="Y" 
		let keyrod$=" ",keyrod$
		let keyrod$[1,6]=roh.custnum using "######"
		let keyrod$[7,12]=roh.ordnum using "######"
		do
			search #ch_rod,3,1;keyrod$,rec_rod,e
			if e<>0 exit do
			let tmp3=keyrod$[1,6]\if tmp3<>roh.custnum exit do
			let tmp3=keyrod$[7,12]\if tmp3<>roh.ordnum exit do
			read record #ch_rod, rec_rod;rod.;
			let depamt=depamt+rod.ChkAmt
		loop
	endif
	webstr$=""
	webstr$=str$(int(roc.Paytype1)),fdel$
	if roc.paytype1<0 or  roc.paytype1 > 4 let roc.paytype1=0 ! set to none
	let ctr=int(roc.paytype1)
	webstr$=webstr$,rtrim$(PAYTYPE$[ctr*12+1,ctr*12+12]),fdel$
	webstr$=webstr$,str$(roc.PayAmt1),fdel$
	webstr$=webstr$,rtrim$(roc.PayAcct1$),fdel$
	webstr$=webstr$,rtrim$(roc.PayDesc1$),fdel$
	webstr$=webstr$,rtrim$(roc.CcName1$),fdel$
	webstr$=webstr$,rtrim$(roc.CCaddr1$),fdel$
	Webstr$=webstr$,rtrim$(roc.CCZip1$),fdel$
	let tmp$=roc.ccexp1 using "&&&&&&"
	webstr$=webstr$,tmp$[1,2],"/",tmp$[3,6],fdel$
	webstr$=webstr$,str$(roc.CCType1),fdel$
	let tmp$=""
	if roc.cctype1>0 and roc.cctype1<=9
		let ctr=roc.cctype1
		tmp$=CCTYPE$[ctr*10-9,ctr*10]
	else
		roc.cctype1=0
		let tmp$="None"
	endif
	webstr$=webstr$,tmp$,fdel$ ! cctype1 desc
	!webstr$=webstr$,str$(roc.ccappr1),fdel$ ! approval #
	webstr$=webstr$,rtrim$(roc.authcode1$),fdel$ ! approval # was roc.ccappr1
	tmp$="N"
	if (roc.CardSwipe1) let tmp$="Y"
	webstr$=webstr$,tmp$,fdel$
	webstr$=webstr$,str$(roc.CcVerif1),fdel$
	webstr$=webstr$,str$(int(roc.Paytype2)),fdel$
	if roc.paytype2<0 or  roc.paytype2 > 4 let roc.paytype2=0 ! set to none
	let ctr=int(roc.paytype2)
	webstr$=webstr$,rtrim$(PAYTYPE$[ctr*12+1,ctr*12+12]),fdel$
	webstr$=webstr$,str$(roc.PayAmt2),fdel$
	webstr$=webstr$,rtrim$(roc.PayAcct2$),fdel$
	webstr$=webstr$,rtrim$(roc.PayDesc2$),fdel$
	webstr$=webstr$,rtrim$(roc.CcName2$),fdel$
	webstr$=webstr$,rtrim$(roc.CCaddr2$),fdel$
	Webstr$=webstr$,rtrim$(roc.CCZip2$),fdel$
	let tmp$=roc.ccexp2 using "&&&&&&"
	webstr$=webstr$,tmp$[1,2],"/",tmp$[3,6],fdel$
	webstr$=webstr$,str$(roc.CCType2),fdel$
	let tmp$=""
	if roc.cctype2>0 and roc.cctype2<=9
		let ctr=roc.cctype2
		tmp$=CCTYPE$[ctr*10-9,ctr*10-9]
	else
		roc.cctype2=0
		let tmp$="None"
	endif
	webstr$=webstr$,tmp$,fdel$
	!webstr$=webstr$,str$(roc.ccappr2),fdel$ ! approval #
	webstr$=webstr$,rtrim$(roc.authcode2$),fdel$ ! approval # ! wsa roc.ccappr2
	tmp$="N"
	if (roc.CardSwipe2) let tmp$="Y"
	webstr$=webstr$,tmp$,fdel$
	webstr$=webstr$,str$(roc.CcVerif2),fdel$
	webstr$=webstr$,str$(roc.SocSec),fdel$                                       
  	webstr$=webstr$,rtrim$(roc.license$),fdel$
	webstr$=webstr$,rtrim$(roc.Expire$),fdel$
	webstr$=webstr$,rtrim$(roc.payorname$),fdel$
	webstr$=webstr$,rtrim$(roc.transid$),fdel$ ! remove payemp
	webstr$=webstr$,str$(rot.OrdTot),fdel$ ! invoice total
	webstr$=webstr$,str$(depamt),fdel$ ! deposit total
	tmp3=(rot.ordtot-depamt-roc.PayAmt1-roc.PayAmt2)
	webstr$=webstr$,str$(tmp3),fdel$
	webstr$=webstr$,str$(roc.invnum),fdel$
	artermd$=""
	 If roh.terms > 0 And roh.terms <= 99              
		artermd$ = getartermd$(ch_terms,roh.terms,intco) 
	endif
	webstr$=webstr$,rtrim$(artermd$),fdel$
	if roc.birthday
		let xdate$=pdate$(roc.birthday)
		if roc.birthday>currdate and xdate$[7,8]="20"
			let xdate$[7,8]="19"
		endif
	else
		let xdate$=" ",xdate$
	endif
	WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! order date
	webstr$=webstr$,roc.CCAuthType$[1,1],fdel$
	webstr$=webstr$,roc.CCAuthType$[2,2],fdel$
	let tmp$="Y" ! yes allow balance due
	if source=251 or source=253
		if not(prt.CashSaleCustNum)
			read #ctlc,2,50;custid;
			let prt.cashsalecustnum=custid
		endif
		if prt.CashSaleCustNum=roh.CustNum let tmp$="N"
		if prt.CashSaleCustNum=roh.Billto let tmp$="N"
		chan=findchannel()
		let atcd=chan
		open #atcd,"2/ARTERMCODE"+STR$(INTCO)
		clear term.
		IF ROH.Terms>0 AND ROH.Terms<=99   
			Read Record #atcd,ROH.Terms;term.;  
			if term.DiscountDays=99 let tmp$="N"
		endif
	endif
	webstr$=webstr$,tmp$,fdel$
	if rtrim$(p61$[127,127])="" let p61$[127,127]="X"
	webstr$=webstr$,p61$[127,127],fdel$
	list$[2]=webstr$
	EndGetCashSect4: ! end of section 4
	Call AddToStr(e$,rstr$,List$[])             
	Call AddToStr(e$,rstr$,esdel$) ! end of section   
	if returnstatus=1 let message$="OK" ! set if no other problems
	
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! call SetOutPut(e$,rstr$)
 else
	include "src/callsuberr.inc"
 end try
End sub !getcash

Sub SAVECASH()
!-------------------------------------------------------------------
! defaults for cash sales
 try
	dim oroc. as sordcash ! sale order cash file
	dim 1%,ch_roc,tmpcnt,tmp_CashSaleFlag
	dim 3%,rec_roc,cctranamt
	dim keyroc$[50],cctrantype$[1]
	clear roc.
	Clear oroc.
	tmp_CashSaleFlag=-1  ! set to something it should not be so can tell if changed below
	ReturnStatus=1
	Message$="OK"
	Call dxget("ORDERID",tmp$)                                   
	If tmp$ = ""                                                 
		Message$ = "ORDER # MISSING"                               
		ReturnStatus = 0                                           
		Goto EndSaveCash:
	End If
	orderid = tmp$  
	call dxget ("custid",Custid$)
	let custid=custid$
	If orderid > 0 And orderid < 999999 And Not(Fra(orderid))    
		keyroh$ = " ",keyroh$                                             
		keyroh$[1,6] = custid Using "######"                              
		keyroh$[7,12] = orderid Using "######" 
		keyroh$[13]=""
		mode$ = "=" ! search mode 2                                       
		dir = 2                                                           
		Clear chan[]                                                      
		chan[0] = ch_roh                                                  
		chan[1] = ch_ros                                                  
		chan[2] = ch_rot                                                  
		rec_roh = filegetrohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.) 
		If rec_roh <= 0 ! no order found                               
			Message$ = "ORDER # NOT FOUND"                           
			ReturnStatus = 0                                         
			Goto EndSaveCash:                                        
		 End If 
	else
		Message$ = "Invalid Order Number " +str$(orderid)                          
		ReturnStatus = 0                                         
		Goto EndSaveCash:       
	End If    
	oohld=rot.holdcode
	call dxget ("SOURCE",tmp$)
	let source=tmp$ \ if credit let source=0
	if source=201 or source=208 let source=0 !  USES 0 for them!
	if not(ch_roc)
		ch_roc = OpenFile(2224,IntCo) 
		If ch_roc = -1 
			let returnstatus=0
			Message$="Order Cash File Not Found"
			goto EndSaveCash:
		endif
	endif
	clear oroc.
	let keyroc$=orderid using "######" 
	rec_roc = filegetsordcash(e$,Ch_roc,"=",1,keyroc$,roc.)
	if rec_roc>0 Read Record #ch_roc,rec_roc;oroc.;
	if rec_roc<0 ! add new
		clear roc.
	endif
	if prt.CRBankNum>0
		let roc.BankNum1=prt.CRBankNum ! 499 set to last submitted  ! CASH BANK
	else
		if not(roc.banknum1) let roc.banknum1=1
	endif
	if prt.CashSlsBankNum>0
		let roc.BankNum2=prt.CashSlsBankNum ! CREDIT CARD BANK
	else
		if not(roc.banknum2) let roc.banknum2=1
	endif
	call Dxget("PAYTYPE1",tmp$) 
	roc.Paytype1=tmp$
	if roc.paytype1<0 or  roc.paytype1 > 4 let roc.paytype1=0 ! set to none
   	call dxget("PAYAMT1",tmp$)
	roc.PayAmt1=tmp$
	if roc.payAmt1<>0 and roc.paytype1=0 ! task#67343 
		let returnstatus=0
		Message$="Payment 1 Entered without a Payment Type"
		goto EndSaveCash:
	endif
	call dxget("PAYACCT1",tmp$)
	roc.PayAcct1$=tmp$+blank$
	IF CUSTOM_CUSTOMER$="REUTHER"  ! amex goes to bank 5
		IF roc.payacct1$[1,1]="3" and int(roc.PayType1)=3 LET roc.BankNum2=5 ! setting credit card bank
	endif
	call dxget("PAYDESC1",tmp$)
	roc.PayDesc1$=tmp$+blank$
	call dxget("CCNAME1",tmp$)
	roc.CcName1$=tmp$+blank$
	call dxget("CCADDR1",tmp$)
	roc.CCaddr1$=tmp$+blank$
	call dxget("CCZIP1",tmp$)
	roc.CCZip1$=tmp$+blank$
	call dxget("CCEXP1",tmp$)
	if tmp$[3,3]="/"
		let tmp1$=tmp$[1,2],tmp$[4,7]
	else
		let tmp1$=tmp$
	endif
	roc.ccexp1=tmp1$
	call dxget("CCTYPE1",tmp$)
	roc.CCType1=tmp$
	if roc.Paytype1=3
		If roc.cctype1>0 and roc.cctype1<10
			let roc.paytype1=roc.paytype1+(roc.cctype1/10)
		endif
	endif
  	call dxget("CCAPPR1",tmp$)
	!roc.ccappr1=tmp$ ! approval #
	roc.authcode1$=rtrim$(tmp$)+blank$
	call dxget("CCSWIPE1",tmp$)
	if tmp$="N" let tmp$="0"
	if tmp$="Y" let tmp$="1"
	roc.CardSwipe1=tmp$
	call dxget("CCVERIF1",tmp$) 
	roc.CcVerif1=tmp$
	call dxget("CCTRTYPE1",tmp$)
	if ucase$(rtrim$(tmp$))="C" ! and ucase$(rtrim$(roc.CCAuthType$[1,1]))<>"C" ! credit
		let roc.payamt1=abs(roc.payamt1)*(-1)
	endif
	roc.CCAuthType$[1,1]=tmp$+Blank$
	if ucase$(roc.CCAuthType$[1,1])="V" and roc.payamt1<>0 let roc.PayAmt1=0
	
	! start the 2 here
	call Dxget("PAYTYPE2",tmp$) 
	roc.Paytype2=tmp$
	if roc.paytype2<0 or  roc.paytype2 > 4 let roc.paytype2=0 ! set to none
   	call dxget("PAYAMT2",tmp$)
	roc.PayAmt2=tmp$
	if roc.payAmt2<>0 and roc.paytype2=0 ! ! task#67343 
		let returnstatus=0
		Message$="Payment 2 Entered without a Payment Type"
		goto EndSaveCash:
	endif
	call dxget("PAYACCT2",tmp$)
	roc.PayAcct2$=tmp$+blank$
	IF CUSTOM_CUSTOMER$="REUTHER"  ! amex goes to bank 5
		IF roc.payacct2$[1,1]="3" and int(roc.PayType2)=3 LET roc.BankNum2=5
	endif
	call dxget("PAYDESC2",tmp$)
	roc.PayDesc2$=tmp$+blank$
	call dxget("CCNAME2",tmp$)
	roc.CcName2$=tmp$+blank$
	call dxget("CCADDR2",tmp$)
	roc.CCaddr2$=tmp$+blank$
	call dxget("CCZIP2",tmp$)
	roc.CCZip2$=tmp$+blank$
	call dxget("CCEXP2",tmp$)
	if tmp$[3,3]="/"
		let tmp1$=tmp$[1,2],tmp$[4,7]
	else
		let tmp1$=tmp$
	endif
	roc.ccexp2=tmp1$
	call dxget("CCTYPE2",tmp$)
	roc.CCType2=tmp$
	if roc.Paytype2=3
		If roc.cctype2>0 and roc.cctype2<10
			let roc.paytype2=roc.paytype2+(roc.cctype2/10)
		endif
	endif
  	call dxget("CCAPPR2",tmp$)
	roc.authcode2$=rtrim$(tmp$)+blank$
	!roc.ccappr2=tmp$ ! approval #
	call dxget("CCSWIPE2",tmp$)
	if tmp$="N" let tmp$="0"
	if tmp$="Y" let tmp$="1"
	roc.CardSwipe2=tmp$
	call dxget("CCVERIF2",tmp$) 
	roc.CcVerif2=tmp$
	call dxget("CCTRTYPE2",tmp$)
	roc.CCAuthType$[2,2]=tmp$+Blank$
	call dxget("SOCSEC",tmp$)
	roc.SocSec=tmp$
	call dxget("LICENSE",tmp$)
	roc.license$=tmp$+blank$
	call dxget("LICEXP",tmp$)
	roc.Expire$=tmp$+blank$
	call dxget("PAYNAME",tmp$)
	roc.payorname$=tmp$+blank$
	call dxget("TRANSID",tmp$)        
	roc.transid$=tmp$+blank$
  	if roc.Ccauthtype$[1,1]="A" 
		if oroc.ccauthtype$[1,1]<>"A"  or rtrim$(oroc.transid$)<>rtrim$(roc.transid$)
			let roc.preauthdate=currdate
		endif
	endif
	call dxget ("DOB",tmp$) ! in mm/dd/yyyy
	if rtrim$(tmp$)="0" or rtrim$(tmp$)=""
		let roc.birthday=0
	else
		xdate$=formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd 
		let roc.birthday=xdate$[3,8]
		if not (roc.birthday)
			!let returnstatus=1
			!Message$="Invalid (DOB) Date of Birth Entered"
			!goto EndSaveCash:
			! ! ALWAYS WRITE RECORD!!!
		endif		
	endif
	if rec_roc<0 ! add new
		! clear roc.
		if roc.PayType1<>0 or roc.PayType2<>0 or roc.PayAmt1<>0 or roc.PayAmt2<>0 or source=251
			roc.OrdNum=orderid
			!IF P9$[48,48]="Y"  - 498 ALWAYS SET
			if prt.CRBankNum>0 let	roc.BankNum1=prt.CRBankNum 
			if prt.CashSlsBankNum>0 let roc.BankNum2=prt.CashSlsBankNum
				if roc.BankNum1<=0 let roc.BankNum1=1
				if roc.BankNum2<=0 let roc.BankNum2=1

			!ENDIF
			roc.nu1$=blank$
			roc.InvNum=roh.InvNum
			roc.preauthdate=0
			roc.transid2$=blank$ !! need to remove this was transid
			roc.spareme$=blank$
			rec_roc = fileupdatesordcash(e$,ch_roc,"a",0,roc.) 
			if rec_roc<0
				let returnstatus=0
				Message$="Error Adding Order Cash Record"
				goto EndSaveCash:
			endif
			write record # ch_roc,rec_roc;roc.;
		endif
	else
		write record # ch_roc,rec_roc;roc.; 
	endif
	! update totals
	let rot.AmtRcvd=roc.payamt1+roc.payamt2
	if custom_customer$<>"PHILLIPS" and custom_customer$<>"AMERICANOSMENT"
		if rot.AmtRcvd>=rot.OrdTot let rot.HoldCode=0
	else
		if source<>251 and custom_customer$<>"AMERICANOSMENT"  ! task#task#14118/cct#136456 - Do not cash sales off hold
			if rot.AmtRcvd>=rot.OrdTot let rot.HoldCode=0
		endif
	endif
	
	IF credit<>0 let rot.HoldCode=0
	if roh.ordtype=16 let rot.HoldCode=0
	if roh.ordtype=37 let rot.HoldCode=0
	if roc.PayType1<>0 or roc.PayType2<>0  or roc.PayAmt1<>0 or roc.PayAmt2<>0
		tmp_CashSaleFlag=1
	endif
	If rot.amtrcvd <> 0 Let rot.CashSaleFlag = 1 
	if custom_customer$="AMERICANOSMENT" and rot.AmtRcvd>=rot.OrdTot and rot.holdcode<>0
		! unpack hold code
		tmp3=rot.holdcode 
		for ctr=1 to 12   
 			if ctr<>1 LET holdcodeflag[ctr]=SGN(FRA(tmp3/2))
			LET tmp3=INT(tmp3/2)
		next ctr 
		let holdcodeflag[1]=0 ! just flagging credit hold off since paid
		! pack hold code
		let tmp3=0
		for ctr=0 to 11
			IF holdcodeflag[ctr+1] LET tmp3=tmp3+2^ctr   
		next ctr
		let rot.holdcode=tmp3
	endif
	write Record #ch_rot,roh.totrec;rot.;
	if roc.PayType1<>0 or roc.PayType2<>0 ! OR source=251
      if custom_customer$<>"MORRISETTE" ! morrisette - custom no terms change??
		roh.Terms=1 ! set terms to cash sales
	  Endif
		Write Record #ch_roh,rec_roh;roh.
	endif
	IF P60$[44,44]="Y" ! edit tracking
		clear etr.
		if not(credit) and source<>207
			if oohld<>rot.HoldCode ! hold changed
				etr.ProdCode$=Source using "###"
				etr.OrgQtyOrd=oohld
				etr.NewQtyOrd=rot.HoldCode
				etr.EtAction=13 ! set it?
				call edttrk()
			Endif
		Endif
	Endif ! edittrack hold changes
	Call DXGet("EDITSTATUS",TMP$) 
	editstatus = TMP$  
	! reset status here
	If editstatus = 9 And (source = 251 or source=231 or source=223) ! order completed      
		Ostat=roh.status ! status in key
		roh.status = roh.orgstatus                               
		! If roh.status = 0 Let roh.status = 5 ! send to invoice entered
		Let roh.status = 5 ! send to invoice entered ALWAYS unless hold/pick
		if not(credit) and source>=221 and roh.ordtype=16
			IF P61$[55,55]="N" AND roh.ordtype=16 let roh.orgstatus=6
		Endif
		call dxget ("ACPTTYPE",tmp$)
		tmp$=ucase$(tmp$)
		if tmp$[1,4]="HOLD" let roh.status=59
		if tmp$[1,4]="PICK" let roh.status=58
		!! - remmed out the next line - not longer custom for Jersey Paper- see-task31695
		! if custom_customer$="JPAPER" and tmp$[1,4]="PICK" let roh.status=5 ! custom - no status 58
		keyroh$ = " ",keyroh$                                    
		keyroh$[1,2] = roh.status Using "##"                     
		keyroh$[3,8] = orderid Using "######"                    
		Search #ch_roh,4,1;keyroh$,rec_roh,e 
		if ostat<=0 let ostat=94 !
		if ostat<>roh.status ! don't delete orig!
			keyroh$[1,2] = ostat using "##"           
			Search #ch_roh,5,1;keyroh$,rec_tmp,e 
		Endif
		roh.orgstatus=0
		let tmp_CashSaleFlag=1
		Write Record #ch_roh,rec_roh;roh.; ! order complete      
		Read Record #ch_rot,roh.totrec;rot.;  
		if tmp_CashSaleFlag<>-1   !! got changed
			rot.CashSaleFlag = tmp_CashSaleFlag
			write Record #ch_rot,roh.totrec;rot.;
		endif
		Read Record #ch_ros,roh.shiprec;ros.;  
		opendrawflag=0
		if source=251 ! point of sale
			if roc.paytype1=1 ! cash payment #1
				if oroc.paytype1<>roc.paytype1 ! paytype change to cash payment
					let opendrawflag=99
				else
					if oroc.payamt1<>roc.payamt1 ! payment amount changed
						let opendrawflag=99 
					endif
				endif
			endif
			if roc.paytype2=1 ! cash payment #2
				if oroc.paytype2<>roc.paytype2 ! paytype change to cash payment
					let opendrawflag=99
				else
					if oroc.payamt2<>roc.payamt2 ! payment amount changed
						let opendrawflag=99 
					endif
				endif
			endif
			if opendrawflag<>0
				call opendrawer()
			endif
		endif
	End If  
	if int(roc.paytype1)=3  or int(oroc.paytype1)=3 ! credit card transaction
		if oroc.ccauthtype$[1,1]<>roc.ccauthtype$[1,1]  or rtrim$(oroc.transid$)<>rtrim$(roc.transid$)
			If P60$[44,44]="Y" ! edittracking
				clear etr.
				etr.NewQtyOrd=rot.holdcode
				LET ETR.Printer=0
				LET ETR.OrdNum=roh.Ordnum ! H0[7]
				LET ETR.Status=roh.Status ! H6[2]
				LET ETR.InvNum=roh.InvNum ! OREF[1]
				LET ETR.CustNum=roh.CustNum ! H0[4]
				LET ETR.OrgOrdTot=roc.payamt1! T2[0]
				if roc.CCAuthType$[1,1]="V" LET ETR.OrgOrdTot=oroc.payamt1! T2[0]
				LET etr.EtAction=65 ! hold code set by system
				LET ETR.LineNum=0
				etr.AccessCode$=Userid$+Blank$
				if roc.CCAuthType$[1,1]="A" 
					LET ETR.ProdCode$="PREAUTHORIZE"+blank$ ! 237 USING "###" ! +Blank$ ?							 
				ELSE
					if roc.CCAuthType$[1,1]="V" 
						LET ETR.ProdCode$="VOIDED"+blank$ ! 237 USING "###" ! +Blank$ ?
					else
						if roc.CCAuthType$[1,1]="D" 
							LET ETR.ProdCode$="DECLINED"+blank$ ! 237 USING "###" ! +Blank$ ?
						else
							if roc.CCAuthType$[1,1]="P" 
								LET ETR.ProdCode$="POSTAUTHORIZE"+blank$ ! 237 USING "###" ! +Blank$ ?
							else
								if roc.CCAuthType$[1,1]="X" 
									LET ETR.ProdCode$="EXPIRED"+blank$ ! 237 USING "###" ! +Blank$ ?
								endif
							endif
						endif
					endif
				endiF
				if int(oroc.paytype1)=3  and int(oroc.paytype1)<>3 
					LET ETR.ProdCode$="PAY TYPE CHG"+blank$	
				ENDIF
				LET ETR.UMSell=0;ETR.NstkFlag=0 
				etr.SpareNU$=Blank$
				x2[0]=-1;x2[1]=-1 ! no files open
				Call MakeEdittrack(e$,IntCo,X2[],etr.)
			  Endif
			 ENDIF
		ENDIF
	EndSaveCash: ! end of section 
	
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! call SetOutPut(e$,rstr$)
 else
	include "src/callsuberr.inc"
 end try
End sub !savecash

Sub Deleteord()
!-------------------------------------------------------------------

 try
	Dim 1%,L3[3],L1[5],SS2[1]
	Dim 2%,stat[10],delmsg$[20],J6$[50],K28$[50]
	Dim 2%,L4[3],L2[2]
	Dim 3%,L7[12],pl4[23],PONUM
	ReturnStatus=1
	Message$="OK"
	Call dxget("ORDERID",tmp$)                                   
	If tmp$ = ""                                                 
		Message$ = "ORDER # MISSING"                               
		ReturnStatus = 0                                           
		Goto EndDelOrd:
	End If
	orderid = tmp$  
	call dxget ("custid",Custid$)
	let custid=custid$
	If orderid > 0 And orderid < 999999 And Not(Fra(orderid))    
		keyroh$ = " ",keyroh$                                             
		keyroh$[1,6] = custid Using "######"                              
		keyroh$[7,12] = orderid Using "######" 
		keyroh$[13]=""
		mode$ = "=" ! search mode 2                                       
		dir = 2                                                           
		Clear chan[]                                                      
		chan[0] = ch_roh                                                  
		chan[1] = ch_ros                                                  
		chan[2] = ch_rot                                                  
		rec_roh = filegetrohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
		e$=""
		If rec_roh <= 0 ! no order found                               
			Message$ = "ORDER # NOT FOUND"                           
			ReturnStatus = 0                                         
			Goto EndDelOrd:                                        
		 End If 
	else
		Message$ = "Invalid Order Number " +str$(orderid)                          
		ReturnStatus = 0                                         
		Goto EndDelOrd:       
	End If 
	call verifystat()
	if returnstatus=99
		let returnstatus=0 ! setting it to 0 so message displays
		let message$="Cannot Delete This Order. Order is no longer in edit status"
		goto enddelord: ! 
	endif
	IF Roh.ordtype=15 and roh.boctr<>0
		returnstatus=0
		message$="CANNOT DELETE...ALREADY BEEN BILLED!!!!"
		goto enddelord
	Endif
	call dxget("SOURCE",tmp$)
	source=tmp$
	Let ALLWDEL=1
	If Roh.ordtype=19 !  ! "see if can delete order
		Let J6$=" ",J6$;J6$[1,6]=roh.OrdNum Using "######"
		ROL_Loop: ! "thru lines on order
		Search #Ch_rol,3,1;J6$,r[11],e
		IF E goto ROLDOne 
		Let X2=J6$[1,6] \ If X2<>roh.OrdNum Goto ROLDone:
		Mat Read #ch_rol,r[11],168;L7;
		If L7[0] Let ALLWDEL=0 ! "PREVIOUS SHIPMENTS!!
		Goto ROL_loop:
		ROLDONE: ! "return
	Endif
	if not(allwdel) ! can't do it
		returnstatus=0
		message$="CANNOT DELETE...ALREADY HAD SHIPMENTS!!!!"
		goto enddelord
	Endif
	Let ALLWDEL=1 ! ! "cct#219550
	if roh.status<5 or (roh.status>89 and roh.OrgStatus<5) ! ORDERS ONLY!
		CH_POL=Openfile(-2432,Intco) \ if ch_pol=-1 goto ROLPDone
		Let J6$=" ",J6$;J6$[1,6]=roh.OrdNum Using "######"
		ROLP_Loop: ! "thru lines on order
		Search #Ch_rol,3,1;J6$,r[11],e
		IF E goto ROLPDOne 
		Let X2=J6$[1,6] \ If X2<>roh.OrdNum Goto ROLPDone:
		mat read #ch_rol,R[11],0;L2;
		mat read #ch_rol,R[11],8;L3;
		Mat Read #ch_rol,r[11],16;L4;
		Mat Read #ch_rol,r[11],256;SS2;
		IF SS2[0]=3 Goto ROLP_loop: !SKIP MESSAGE LINES
	if custom_customer$="HTBERRY" 
!! TASK 65595 IF NON-STOCK & PO NO DELETE
           IF L3[0]=1 and L4[2]<>0 Let ALLWDEL=0
        endif
                If L4[2] ! po - but is it there/linked
			LET K28$=" ",K28$
		   LET K28$[1,6]=L4[2] USING "######"
		   POLINE_LOOP: !
		   SEARCH #CH_POL,3,1;K28$,R28,E  
		   IF E=2 GOTO ROLPDONE   
		   LET TMPNUM=K28$[1,6]     
		   IF TMPNUM<>L4[2] GOTO END_poline_LOOP:   
		   MAT READ #CH_POL,R28;L1; 
		   MAT READ #CH_POL,R28,232;PL4;   
		   IF PL4[10]=L2[1] and PL4[11]=L3[2] and L1[0]<>3 
			  Let ALLWDEL=0
			  let ponum=val(k28$[1,6])
			endif
			if AllwDel goto poline_loop:
			Goto ROLPDone ! just need 1 found to abort delete
			 end_poline_loop: !
			 ! Allwdel= PO Exists
		Endif
		Goto ROLP_loop:
		ROLPDONE: ! "return
		If CH_POL>0 Try Close #CH_POL Else Rem
	Endif
	IF CUSTOM_CUSTOMER$="WENELSON" or Custom_customer$="ACME"
		CALL dxget ("CONFIRMDELETE",tmp$)
		if rtrim$(ucase$(tmp$))<>""
			LET ALLWDEL=99 ! ALLOW FOR DELETE
		else
			let returnstatus=2
			if not(ponum)
				message$="Order is Linked to a Purchase Order!"
			else
				message$="Order is Linked to Purchase Order "+str$(ponum)+"!"
			endif
			let message$=message$+" Press OK to Delete "
			goto enddelord
		endif
	endif
	if not(allwdel) ! can't do it
		returnstatus=0
		if not(ponum)
			message$="CANNOT DELETE...LINKED TO A PO!!!"
		else
			message$="CANNOT DELETE...LINKED TO A PO "+str$(ponum)+" !!!"
		endif
		goto enddelord
	Endif
	! final check - is user flagged to allow
	if (roh.status>89 and roh.OrgStatus<5) ! ORDERS ONLY!
		if roh.status<>0 and roh.orgstatus<>0 ! still in 1st entry - allow it!
			if ucf$[1,1]="N" and not(credit)
				returnstatus=0
				message$="CANNOT DELETE ORDER...YOU ARE NOT ALLOWED!"
				call programdump("tmp/oedel.txt!","")
				goto enddelord
			endif
		endif
	endif
	
	! for inv/credits - use same as flag sent!
	tmp$="Y"
		if not(credit) ! if they're in credits - they can delete them?
			if source<=220 and ucf$[1,1]="N" let tmp$="N" ! ord
			if source>220 and ucf$[2,2]="N" let tmp$="N" ! inv
			if source=207 or source=239 let tmp$="N" ! inquiry
			if source=231 or source=251 let tmp$="Y" ! can delete if new entry?
			if source=223 and ucf$[2,2]="N" ! not allowed to delete invoice
				CALL DXGET("RESETORD",tmp1$)
				if rtrim$(ucase$(tmp1$))="Y"
					let tmp$="Y" ! reset to order 
				else
					let tmp$="N" ! deleting entire not allowed
				endif
			endif
				
		endif
		clear roc.
		if not (ch_roc)
			Try
				ch_roc = OpenFile(2224,IntCo)
			else
				let ch_roc=-1
			end try
		  endif
		if ch_roc>0
			let keyroc$=orderid using "######" 
			rec_roc = filegetsordcash(e$,Ch_roc,"=",1,keyroc$,roc.)
			if rec_roc<0 clear roc.
		endif
		If int(roc.PayType1)=3 and Ucase$(roc.ccauthtype$[1,1])="P" let tmp$="N" ! no delete
		If int(roc.PayType2)=3 and Ucase$(roc.ccauthtype$[2,2])="P" let tmp$="N" ! no delete
		! tmp$ = can user delete this
	if (roh.status>89 and roh.OrgStatus>=5) ! INVOICE
		if source<220 let tmp$="N" ! deleting an invoice using order - NO
		!if roh.status<>0 and roh.orgstatus<>0 ! still in 1st entry - allow it!
			if tmp$="N" ! ucf$[2,2]="N" and not(credit)
				returnstatus=0
				message$="CANNOT DELETE INVOICE...YOU ARE NOT ALLOWED!"
				call programdump("tmp/iedel.txt!","")
				goto enddelord
			endif
		! endif ! status ALWAYS NOT ZERO!
	endif
	searkey$=CustiD using "######"
	if custid>0
	CustRec = FileGetCust(e$,Ch_Cust,"=",1,SearKey$,cust.)
	Else
		custrec=-1
	Endif
	if custrec<0
		message$="Customer "+str$(custid)+" Not on File"
		returnstatus=0
		goto EndDelORd:
	endif
	call dxget ("SOURCE",tmp$)
	let source=tmp$
	if source=201 or source=208 let source=0 !  USES 0 for them!
	if source=0 and credit let source=241
	call dxget ("DELREASON",tmp$)
	let DELMSG$=tmp$+BLANK$
	! verify if ok to delete
	
	if not(returnstatus) goto endDelOrd: ! cannot delete
	IF P61$[94,94]="Y"
		if source=251 or source=223 or source=231
			let stat[3]=source ! program delete type #  (S9[3]) (206=order, 225-invoice, 245 = cm)
			CALL DXGET("RESETORD",tmp$)
			if rtrim$(ucase$(tmp$))="Y" 
				goto justreset:
			endif	
		endif
		 ch_rod = openfile(10106,intCo)                                            
		 If ch_rod >0                                                                                                                         
			keyrod$ = " ",keyrod$                                                     
			keyrod$[1,6] = custid Using "######"                             
			keyrod$[7,12] = orderid Using "######" ! order # 
			keyrod$[13]=""
			do
				search #ch_rod,3,1;keyrod$,rec_rod,e
				if e<>0 exit do
				let tmp=keyrod$[1,6]\if tmp<>custid exit do
				let tmp=keyrod$[7,12]\if tmp<>orderid exit do
				let returnstatus=0
				let message$="Deposit is still open for Order "+str$(orderid)
				goto enddelord:
			loop
		 endif
	endif
	! set up parameters for call
	CLEAR STAT[]
	STAT[0] = intco !  company #
	STAT[1] = custrec ! customer record # (S9[1])
    STAT[2] = rec_roh !   (S9[2])
    STAT[3] = 206 ! 
	if source=251 or source=223 or source=231
		let stat[3]=source ! program delete type #  (S9[3]) (206=order, 225-invoice, 245 = cm)
		CALL DXGET("RESETORD",tmp$)
		if rtrim$(ucase$(tmp$))="Y" 
			goto justreset:
		endif	
	endif
	if source=241 or source=243 let stat[3]=245
	if source=231 let stat[3]=231 ! if 231/251 - is delete upon entry
	if source=223 ! inv edit(also delete)
		if Roh.ordtype=20 !or roh.Terms=1 ! all ot's to delete here(no order equiv)
			let Stat[3]=225;Source=225 ! so not 223 
		Else
			let Stat[3]=225;Source=225
			if roh.spare2=88 let roh.spare2=99
			!goto justreset ! reset to status4 - no order delete
		Endif
	Endif
	if source=0 ! check if actually from 223
		if roh.OrgStatus=5 or roh.OrgStatus=6 let source=225;stat[3]=225 ! deleting invoice
		if credit let source=245;stat[3]=245
		if source=0 let source=stat[3]
	Endif ! stat > 220 means delete stat=21 >
	STAT[4] = source ! program #
	CLEAR CH[]
	CH[0]=ctlc ! control file
	CH[1]=CH_CUST ! Customer file
	ch[2]=ch_prod
	ch[3]=ch_roh! order header #8
	ch[4]=ch_rol! order lines #11
	ch[5]=ch_ros! order ship file #9
	ch[6]=ch_rom ! order message file
	ch[7]=CH_SPRODDESC ! order nonstock
	ch[8]=ch_rot! order total
	ch[9]=ch_roc ! order cash screen 
	ch[10]=0 ! order acknowledgement
	ch[11]=0 ! - not used
	ch[12]=ch_prwh
	ch[13]=0 ! trace delete
	ch[14]=0 ! edit track
	ch[15]=ch_sordlot ! order lot file
	ch[16]=ch_sprodlot ! product lot file
	Call "mx201e.dl4",Ch[],STAT[],rec_uac,delmsg$,e$,rstr$,returnstatus,message$
	if source=251 let source=0 ! deleted the point of sale
	if p61$[135,135] = "Y" and not(credit)
		! RF Picking enabled - check to delete any
		! lines associated with this order
		k_rfpq$ = " ",k_rfpq$
		k_rfpq$[1,6] = orderID using "######"
		do
			r_rfpq = filegetrfpickq(e$,ch_rfpq,">",4,k_rfpq$,rfpq.,1)
			if r_rfpq<0 exit do
			if val(k_rfpq$[1,6]) <> orderID exit do
			! need to delete this one
			e = fileupdaterfpickq(e$,ch_rfpq,"d",r_rfpq,rfpq.)
			! not sure what to do here, delete of order did
			! not fail, but what if delete of rf queue item
			! fails?
		loop
	end if
	Justreset: ! no delete - reset to printed
	If source=223 or source=251! reset to status 4 from 5 or 6
	  If P60$[44,44]="Y" ! edittracking
		clear etr.
		etr.ProdCode$="INV DELETED"+Blank$
		etr.EtAction=10
		call edttrk()
	  Endif
	  ! deleted inv track
	  Call Trkdel()
	    ! ok - change to status 4
		roh.orgstatus=roh.status ! what it currently is!
		if roh.orgstatus<1 or roh.orgstatus>99
			let roh.orgstatus=96
			if source=251 let roh.orgstatus=94
		endif
		roh.status=4
		let keyroh$=" ",keyroh$
		let keyroh$[1,2]=roh.status using "##"
		let keyroh$[3,8]=orderid using "######"
		search #ch_roh,4,1;keyroh$,rec_roh,e
		if E>1 ! for some reason could be 4 already?
			returnstatus=0
			message$="Search Error "+Str$(E)+" Insert key "+keyroh$
			call programdump("tmp/invreset!","")
		Endif
		let keyroh$[1,2]=roh.orgstatus using "##"
		if roh.orgstatus<>roh.status
			Search #ch_roh,2,1;keyroh$,rec_tmp,e
			if not(E)
				search #ch_roh,5,1;keyroh$,rec_tmp,e
				if e
					returnstatus=0
					message$="Search Error "+Str$(E)+" Delete Original key "+keyroh$
					call programdump("tmp/invret!","")
				Endif
			Else
				returnstatus=0
				message$="Search Error "+Str$(E)+" Find key "+keyroh$
				call programdump("tmp/invreset2!","")
			Endif
		Endif
		roh.orgstatus=0
		! delete delivery charge calc on invoice
		if p61$[36,36]="Y" call DelSysChrg()
		write record #ch_roh,rec_roh;roh.;
		if e=0
			returnstatus=1
			Message$="Invoice was reset to an order"
		Endif
	Endif

	EndDelOrd: ! end of section 
	
	
 else
	include "src/callsuberr.inc"
 end try
End sub !delorder

sub DelSysChrg()
  try
	! remove any previously system calculated delivery charges
	dim dc_key$[20]

	if p61$[36,36]<>"Y" exit sub ! calculated on the order do not delete
	for scr=0 to 9 ! remove calculated delivery charges
		if int(fra(rot.MiscChrgCode[scr]*10)*10)=9 !  sys calculated delivery charge
			let rot.MiscChrg=rot.MiscChrg-rot.MCharge[scr,0] ! total misc charges
			let rot.totmisccost=rot.totmisccost-rot.MCharge[scr,1] ! total misc cost
			if int(fra(rot.MiscChrgCode[scr])*10) ! flagged for gp
				let rot.MiscChrg4Prof=rot.MiscChrg4Prof-rot.mcharge[scr,0] ! gp misc charge
				let rot.MiscCost4Prof=rot.MiscCost4Prof-rot.mcharge[scr,1] ! gp misc cost
			endif
			if rot.MCTxbl[scr] ! check if taxable
				let rot.taxable=rot.taxable-rot.mcharge[scr,0] ! taxable $
				let rot.TotChrgTax=rot.TotChrgTax-fnr(rot.mcharge[scr,0]*(rot.TaxPct/100))
				let rot.TaxAmt=rot.TaxAmt-fnr(rot.mcharge[scr,0]*(rot.TaxPct/100))
			endif
			let rot.MiscChrgCode[scr]=0;rot.mcharge[scr,0]=0;rot.mcharge[scr,1]=0
			let rot.MCTxbl[scr]=0
			rot.ordtot = rot.subtot - rot.orddisc + rot.miscchrg + rot.frgtchrg + rot.othchrg + rot.taxamt

			write record #ch_rot,roh.totrec;rot.;
			let ch_delvchrg=findchannel()
			open #ch_delvchrg,"3/DELVCHRG"+str$(intCo)
			if custom_customer$ = "AFP" ! All Florida Paper uses customer billto code as key
				DC_KEY$=roh.billto USING "######",".",0 USING "&&&&&&",roh.shipdate USING "&&&&&&"
			else
				DC_KEY$=ros.shipcust USING "######",".",ros.shipcode USING "&&&&&&",roh.shipdate USING "&&&&&&"
			end if
			SEARCH #ch_delvchrg,2,1;DC_KEY$,DC_REC,E
			IF not(E)
				!*  we have a record we need to delete invoice delivery charge
				SEARCH #ch_delvchrg,5,1;DC_KEY$,DC_REC,E
				if e
					e$ = "Search error deleting delivery charge key"
					error 10000
				end if
				E=3 \ SEARCH #ch_delvchrg,1,0;DC_KEY$,DC_REC,E
				if e
					e$ = "Search error freeing delivery charge record"
					error 10000
				end if
			endif
			close #ch_delvchrg
		endif
	next scr
 else
	include "src/callsuberr.inc"
 end try
end sub ! end DelSysChrg

! begin delete the ar term code
sub delartermcst()
  try
	! remove any previously system calculated delivery charges
	dim dc_key$[20]

	if p61$[138,138]<>"Y" exit sub ! ar term misc cost not active
	for scr=0 to 9 ! remove calculated delivery charges
		if int(fra(rot.MiscChrgCode[scr]*10)*10)=8 !  sys calculated delivery charge
			let rot.MiscChrg=rot.MiscChrg-rot.MCharge[scr,0] ! total misc charges
			let rot.totmisccost=rot.totmisccost-rot.MCharge[scr,1] ! total misc cost
			if int(fra(rot.MiscChrgCode[scr])*10) ! flagged for gp
				let rot.MiscChrg4Prof=rot.MiscChrg4Prof-rot.mcharge[scr,0] ! gp misc charge
				let rot.MiscCost4Prof=rot.MiscCost4Prof-rot.mcharge[scr,1] ! gp misc cost
			endif
			if rot.MCTxbl[scr] ! check if taxable
				let rot.taxable=rot.taxable-rot.mcharge[scr,0] ! taxable $
				let rot.TotChrgTax=rot.TotChrgTax-fnr(rot.mcharge[scr,0]*(rot.TaxPct/100))
				let rot.TaxAmt=rot.TaxAmt-fnr(rot.mcharge[scr,0]*(rot.TaxPct/100))
			endif
			let rot.MiscChrgCode[scr]=0;rot.mcharge[scr,0]=0;rot.mcharge[scr,1]=0
			let rot.MCTxbl[scr]=0
			rot.ordtot = rot.subtot - rot.orddisc + rot.miscchrg + rot.frgtchrg + rot.othchrg + rot.taxamt
			write record #ch_rot,roh.totrec;rot.;
		endif
	next scr
 else
	include "src/callsuberr.inc"
 end try
end sub ! delartermcst: 



! end delete the ar term code
!!!! end deleteorder !!!!!
Sub GETCASHCUST()
!-------------------------------------------------------------------
! defaults for cash sales customer
 try
	Dim 2%,custid,3%
	ReturnStatus=1
	Message$="OK"
	if not(prt.CashSaleCustNum)
		read #ctlc,2,50;custid;
		let prt.cashsalecustnum=custid
	endif
	if not(prt.CashSaleCustNum)
		let returnstatus=0
		Message$="Point of Sale Default Customer Not Setup"
	endif
	mode$ = "="                                                 
	dirno = 1  
	searkey$=prt.CashSaleCustNum using "######"
	CustRec = FileGetCust(e$,Ch_Cust,mode$,dirno,SearKey$,cust.)
	if custrec<=0
		let returnstatus=0
		message$="Point of Sales Customer "+str$(prt.cashsalecustnum)+" Not on File"
	endif
	! section 1 --- Pay Type Droplist 
	clear list$[]
	List$[0] = bsdel$,"CASHCUST",fdel$
	Webstr$="CustId",fdel$,"CustName",fdel$
	List$[1]=webstr$
	if returnstatus<>0
		webstr$=str$(prt.CashSaleCustNum),fdel$
		webstr$=webstr$,rtrim$(cust.name$),fdel$
		list$[2]=webstr$
	endif
	
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	!
 else
	include "src/callsuberr.inc"
 end try
End sub !getcashcust

!--------------------------------------------------------------------
 Sub OrdHdr()
  ! NOTE: This does not seem to used?!
  ! Create order header info information heading for .net
  !
try
  dim head$[10],keyprog$[30],retval$[512],orderno$[10]
  dim 2%,custid,billtoid
  dim 3%,ch_prgd,rec_prgd$,orderno,e,ctr
  
  !!!!!!! order detail !!!!!
	Try
		 Call DXGet("orderno",orderno$)
	else
		let orderno$=" ",orderno$
	end try
   let orderno=orderno$
   !get the specific order detail
    Call DXGet("custid",CustID$) ! Customer Number
    let custid=val(custid$)
    !call dxget ("billtoid",BillCustId$)
    !let billtoid=billcustid$
    
    Ch_prgd = OpenFile(-9940,intCo) \ If Ch_prgd = -1 Error 42  ! progdflt file
    let retval$=" ",retval$
    if ch_prgd>0
		let keyprog$=" ",keyprog$
		let keyprog$[1,4]="201A"
		if credit let keyprog$[1,4]="241A"
		search #ch_prgd,2,1;keyprog$,rec_prgd,e
		if not(e)
			mat read #ch_prgd,rec_prgd,0;retval$;
		endif
		Try close #ch_prgd  Else Rem
    endif
    returnstatus=1
    message$="OK"
    clear roh.
    let roh.SpareNu$=Blank$[1,2] ! " ",roh.SpareNu$
    clear ros.
    clear rot.
    ! get customer & Bill to info 

    ! get billto info here
    if cust.customerbillto<>0 and cust.customerbillto<>custid
	let keycust$=" ",keycust$
	let keycust$=custid using "######"
	search #ch_cust,2,1;keycust$,rec_cust,e
	if e
		let returnstatus=0
		Message$="Bill To Customer "+keycust$+" Not On File"
	endif
	read record #ch_cust,rec_cust;billto.;
    else
	let billto. = cust.
    endif
    if orderno<>0 ! for edit --- item already exists
	let keyroh$=" ",keyroh$
	let keyroh$[1,6]=custid using "######"
	let keyroh$[7,12]=orderno using "######"
	keyroh$[13]=""
	search #ch_roh,2,1;keyroh$,rec_roh,e
	if not (e)
		read record #ch_roh,rec_roh;roh.;
		read record #ch_ros,roh.shiprec;ros.;
		read record #ch_rot,roh.totrec;rot.;
	else
	       clear roh.
	       let roh.SpareNu$=Blank$[1,2] ! " ",roh.SpareNu$
	       clear ros.
	       clear rot.
	       ReturnStatus=0 ! 
	       Message$="Order Number "+orderno$+" Not on File"
        endif
    else
		! need to load default variables into order totals
	    
		rec_ship = getshiplist(e$,SHC,custid$,shipcust,tmp$,sh.)
    endif
  ! ***** stop here *****

   !! --- start order header section --- 
   tmp$=bsdel$+"OrderHeader"+fdel$+rdel$
   Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$
   !! order header headings ^M
   let ctr=7
   tmp$="ORD NUM"+fdel$             
   if retval$[ctr,ctr]="F"
	let tmp$=tmp$+"*"
   endif
   let ctr=ctr+1
   tmp$=tmp$+"ORDER DATE"+fdel$  !#7
if retval$[ctr,ctr]="F"
	let tmp$=tmp$+"*"
endif
let ctr=ctr+1
tmp$=tmp$+"PO"+fdel$	!#8
if retval$[ctr,ctr]="F"
	let tmp$=tmp$+"*"
endif
let ctr=ctr+1
read #ctlc,18,60;head$; ! salesman name head
tmp$=tmp$+head$+fdel$	!#9
if retval$[ctr,ctr]="F"
	let tmp$=tmp$+"*"
endif
let ctr=ctr+1
If not(credit)
tmp$=tmp$+"TERMS"+fdel$ !#10
Else
	tmp$=tmp$+"INVNO"+fdel$
Endif
if retval$[ctr,ctr]="F"
	let tmp$=tmp$+"*"
endif
let ctr=ctr+1
tmp$=tmp$+"ATTN"+fdel$	!#11
if retval$[ctr,ctr]="F"
	let tmp$=tmp$+"*"
endif
let ctr=ctr+1
if not(credit)
tmp$=tmp$+"SHIP DATE"+fdel$ ! #12
Else
	tmp$=tmp$+"DATE INVD"+fdel$
Endif
if retval$[ctr,ctr]="F"
	let tmp$=tmp$+"*"
endif
let ctr=ctr+1

tmp$=tmp$+"DEPT"+fdel$      ! #13
if retval$[ctr,ctr]="F"
	let tmp$=tmp$+"*"
endif
let ctr=ctr+1
if not(credit)
read #ctlc,18,30;head$;     ! warehouse name head
tmp$=tmp$+head$+fdel$       ! #14 
Else
	read #ctlc,18,80;head$;
tmp$=tmp$+head$+fdel$	 ! #14 ! entered by
Endif
if retval$[ctr,ctr]="F"
	let tmp$=tmp$+"*"
endif
let ctr=ctr+1
if not(credit)
tmp$=tmp$+"DUE DATE"+fdel$  ! #15
Else
	tmp$=tmp$+"WEIGHT"+fdel$
Endif
if retval$[ctr,ctr]="F"
	let tmp$=tmp$+"*"
endif
let ctr=ctr+1
If not(credit)
tmp$=tmp$+"SHIP#"+fdel$   ! #16
Else
	tmp$=tmp$+"CMTYPE"+fdel$
Endif
if retval$[ctr,ctr]="F"
	let tmp$=tmp$+"*"
endif
let ctr=ctr+1
tmp$=tmp$+"ROUTING"+fdel$ ! #17
if retval$[ctr,ctr]="F"
	let tmp$=tmp$+"*"
endif
let ctr=ctr+1
if not(Credit)
read #ctlc,18,80;head$;
tmp$=tmp$+head$+fdel$	 ! #18 ! entered by
Else
	tmp$=tmp$+"CM DATE"+fdel$
Endif
if not(Credit)
tmp$=tmp$+"ZONE"+fdel$   ! #19 
Else
tmp$=tmp$+"TYPE"+fdel$   ! #19
Endif
if retval$[ctr,ctr]="F"
	let tmp$=tmp$+"*"
endif
let ctr=ctr+1
if not(credit)
tmp$=tmp$+"TRUCK"+fdel$  ! #20 
Else
	tmp$=tmp$+"DIVISION"+fdel$  ! #20
Endif
if retval$[ctr,ctr]="F"
	let tmp$=tmp$+"*"
endif
let ctr=ctr+1
if not(credit)
tmp$=tmp$+"STOP"+fdel$   ! #21
Else
	read #ctlc,18,30;head$;     ! warehouse name head 
tmp$=tmp$+head$+fdel$       ! #21
Endif
if retval$[ctr,ctr]="F"
	let tmp$=tmp$+"*"
endif
let ctr=ctr+1
if not(credit)
tmp$=tmp$+"TYPE"+fdel$   ! #22
Else
	tmp$=tmp$+"ZONE"+fdel$   ! #22 
Endif
if retval$[ctr,ctr]="F"
	let tmp$=tmp$+"*"
endif
let ctr=ctr+1
if not(credit)
tmp$=tmp$+"DIVISION"+fdel$  ! #23
Else
	tmp$=tmp$+"TRUCK"+fdel$  ! #23
Endif
if retval$[ctr,ctr]="F"
	let tmp$=tmp$+"*"
endif
let ctr=ctr+1
if not(credit)
tmp$=tmp$+"SOURCE"+fdel$ ! #24
Else
	tmp$=tmp$+"STOP"+fdel$   ! #24
Endif
! ship to defaults 
let ctr=1
if retval$[ctr,ctr]="F"
	let tmp$=tmp$+"*" ! #1
endif
let ctr=ctr+1
let tmp$=tmp$+"ShipName"+fdel$ ! #1
let ctr=1
if retval$[ctr,ctr]="F"
	let tmp$=tmp$+"*" 
endif
let ctr=ctr+1
let tmp$=tmp$+"ShipAddr1"+fdel$ ! #2
let ctr=1
if retval$[ctr,ctr]="F"
	let tmp$=tmp$+"*" 
endif
let ctr=ctr+1
let tmp$=tmp$+"ShipAddr2"+fdel$ ! #3
let ctr=1
if retval$[ctr,ctr]="F"
	let tmp$=tmp$+"*" ! 
endif
let ctr=ctr+1
let tmp$=tmp$+"ShipCity"+fdel$ ! #4
let ctr=1
if retval$[ctr,ctr]="F"
	let tmp$=tmp$+"*" 
endif
let ctr=ctr+1
let tmp$=tmp$+"ShipState"+fdel$ ! #5
let ctr=1
if retval$[ctr,ctr]="F"
	let tmp$=tmp$+"*" ! 
endif
let ctr=ctr+1
let tmp$=tmp$+"ShipZip"+fdel$ ! #6

tmp$=tmp$+rdel$
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$  

!!! end of section
	


!tmp$=orderno$+fdel$                           
!tmp$=tmp$+ ol.OrderDate$+fdel$                
!tmp$=tmp$+ ol.WHSE$+fdel$                     
!tmp$=tmp$+ ol.truck$+fdel$                    
!tmp$=tmp$+ ol.slsno$+" "+rtrim$(ol.slsname$)+fdel$
!tmp$=tmp$+ ol.tcost$+fdel$                    
!! order header 2nd line                      
!tmp$=tmp$+ol.status$+fdel$                    
!tmp$=tmp$+ ol.shipdate$+fdel$                 
!tmp$=tmp$+ ol.division$+fdel$                 
!tmp$=tmp$+ ol.stp$+fdel$                      
!tmp$=tmp$+ ol.EnteredBy$+fdel$                
!tmp$=tmp$+ ol.attn$+fdel$                     
!tmp$=tmp$+ ol.gtm$+fdel$                      
!!! order header 3rd line                     
!tmp$=tmp$+ ol.duedate$+fdel$                  
!tmp$=tmp$+ ol.Type$+fdel$                     
!tmp$=tmp$+ ol.zne$+fdel$                      
!tmp$=tmp$+ ol.term$+fdel$                     
!tmp$=tmp$+ ol.tgpp$+fdel$                     
!tmp$=tmp$+ rdel$   
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$                               
Call AddToStr(e$,rstr$,esdel$)	! end of section
!! ---- start order shipto/soldto section ---
tmp$=bsdel$+"OrderAddress"+fdel$+rdel$
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$   

!! order address heading
tmp$="CustomerNo"+fdel$
tmp$=tmp$+"SoldAddress1"+fdel$
tmp$=tmp$+"SoldAddress2"+fdel$
tmp$=tmp$+"SoldAddress3"+fdel$
tmp$=tmp$+"SoldAddress4"+fdel$
tmp$=tmp$+"ShipAddress1"+fdel$
tmp$=tmp$+"ShipAddress2"+fdel$
tmp$=tmp$+"ShipAddress3"+fdel$
tmp$=tmp$+"ShipAddress4"+fdel$
tmp$=tmp$+rdel$
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$
!tmp$=ol.custnumber$+fdel$
!tmp$=tmp$+ol.SoldAddr1$+fdel$
!tmp$=tmp$+ol.SoldAddr2$+fdel$
!tmp$=tmp$+ol.SoldAddr3$+fdel$
!tmp$=tmp$+ol.SoldAddr4$+fdel$
!tmp$=tmp$+ol.S2Addr1$+fdel$
!tmp$=tmp$+ol.S2Addr2$+fdel$
!tmp$=tmp$+ol.S2Addr3$+fdel$
!tmp$=tmp$+ol.S2Addr4$+fdel$
!tmp$=tmp$+rdel$
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$
Call AddToStr(e$,rstr$,esdel$)	! end of section

!! ---- end order address section ----
!! order total section
tmp$=bsdel$+"OrderTotal"+fdel$+rdel$
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$
!!! heading line
!tmp$="Total Weight"+fdel$ 
!tmp$=tmp$+"Subtotal"+fdel$
!tmp$=tmp$+"Total Cube"+fdel$
!tmp$=tmp$+"Tax"+fdel$
!tmp$=tmp$+"Freight"+fdel$
!tmp$=tmp$+"Misc"+fdel$
!tmp$=tmp$+"Discount"+fdel$
!tmp$=tmp$+"Grand Total"+fdel$
!tmp$=tmp$+rdel$
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$
!!! second line data
!tmp$=ol.totweight$+fdel$ 
!tmp$=tmp$+ol.Tresale$+fdel$
!tmp$=tmp$+ol.totcube$+fdel$ 
!tmp$=tmp$+ol.Tax$+fdel$
!tmp$=tmp$+ol.Freight$+fdel$
!tmp$=tmp$+ol.misc$+fdel$
!tmp$=tmp$+ol.discount$+fdel$
!tmp$=tmp$+ol.grandtotal$+fdel$
!tmp$=tmp$+rdel$
Call AddToStr(e$,rstr$,tmp$)  ! put header into rstr$
Call AddToStr(e$,rstr$,esdel$)	! end of section
    dim bsdel$[20],esdel$[20],rdel$[20],fdel$[20]
	dim WebStr$[300]
	!
	!call env(1,"BSDEL",bsdel$)
   ! call env(1,"ESDEL",esdel$)
   ! call env(1,"RDEL",rdel$)
   ! call env(1,"FDEL",fdel$)
    !
	List$[0]=bsdel$,"OrdHeadCust",fdel$ ! beginning section
	!
	WebStr$="OrderNo",fdel$,"CustID",fdel$,"BillToID",fdel$,"Name",fdel$ ! headings
	WebStr$=WebStr$,"Address1",fdel$,"Address2",fdel$,"City",fdel$
	WebStr$=WebStr$,"State",fdel$,"Zip",fdel$,"Phone",fdel$
	List$[1]=WebStr$
	!
	row=2
	! submit data
	let webstr$=ordernum using "######"
	! let webstr$,w

  else
    include "src/callsuberr.inc"
  end try
  !
end sub ! CustomerInfoHeading



!
! ------------------------------------------------------------------------
Sub OrdHLabel()
  !
  ! Create order header Labels for .net
  !
try
  dim head$[10],keyprog$[30],retval$[512]
  dim 3%,ch_prgd,rec_prgd,e,ctr
 
   !get the specific order detail
     Call DXGet("SOURCE",TMP$)  
    source = TMP$ 
	if source=201 or source=208 or source=207 let source=0 !  USES 0 for them!
    Ch_prgd = OpenFile(-9940,intCo) \ If Ch_prgd = -1 Error 42  ! progdflt file
    let retval$=" ",retval$
    if ch_prgd>0
		let keyprog$=" ",keyprog$
		let keyprog$[1,4]="201A"
		if source=251
			let keyprog$[1,4]="251A"
		endif
		if credit let keyprog$[1,4]="241A"
		if source=223 let keyprog$[1,4]="223A"
		if source=231 let keyprog$[1,4]="231A"
		search #ch_prgd,2,1;keyprog$,rec_prgd,e
		if not(e)
			mat read #ch_prgd,rec_prgd,0;retval$;
		endif
		try close #ch_prgd  ELSE REM
    endif
    returnstatus=1
    message$="OK"
   
 Clear List$[]                                                         
 List$[0] = bsdel$ + "OrdHLabels" + fdel$ ! section name                 
 tmp$ = "Std Name" + fdel$                                            
 tmp$ = tmp$ + "Label" + fdel$ 
 tmp$ = tmp$ + "Req" +fdel$
 tmp$ = tmp$ + "Droplist" + fdel$
 List$[1] = tmp$ ! put header into rstr$                            
 row = 2 ! starting row for data   
  If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])                  
           
 let tmp$="SHIPNAME"+fdel$ ! #1   
 let tmp$=tmp$+"ShipName"+fdel$ ! #1
 if retval$[1,1]="F"
	let tmp$=tmp$+"Y" +fdel$! #1
 else
	let tmp$=tmp$+"N" +fdel$! #1
 endif
 let tmp$=tmp$," ",fdel$ ! droplist name
 list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 

let tmp$="SHIPADDR1"+fdel$ ! #2
let tmp$=tmp$+"ShipAddr1"+fdel$ ! #2
if retval$[2,2]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
 let tmp$=tmp$," ",fdel$ ! droplist name
 list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

let tmp$="SHIPADDR2"+fdel$ ! #3
let tmp$=tmp$+"ShipAddr2"+fdel$ ! #3
if retval$[3,3]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
 let tmp$=tmp$," ",fdel$ ! droplist name
 list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

let tmp$="SHIPCITY"+fdel$ ! #4
let tmp$=tmp$+"ShipCity"+fdel$ ! #4
if retval$[4,4]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
 let tmp$=tmp$," ",fdel$ ! droplist name
 list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

let tmp$="SHIPST"+fdel$ ! #5
let tmp$=tmp$+"ShipState"+fdel$ ! #5
if retval$[5,5]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
 let tmp$=tmp$," ",fdel$ ! droplist name
 list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

let tmp$="SHIPZIP"+fdel$ ! #6
let tmp$=tmp$+"ShipZip"+fdel$ ! #6
if retval$[6,6]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
 let tmp$=tmp$," ",fdel$ ! droplist name
 list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
 
tmp$="ORDDATE"+fdel$  !#7
if not(source) OR CREDIT
	tmp$=tmp$+"ORDER DATE"+fdel$  !#7
Else
	if source=251 or source=223 or source=231
		let tmp$=tmp$,"INVOICE DATE",fdel$
	endif
endif
   if retval$[7,7]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
 let tmp$=tmp$," ",fdel$ ! droplist name
 list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])


tmp$="PO"+fdel$	!#8
tmp$=tmp$+"PO"+fdel$	!#8
 if retval$[8,8]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
 let tmp$=tmp$," ",fdel$ ! droplist name
 list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])


tmp$="SLSMNO"+fdel$	!#9
read #ctlc,18,60;head$; ! salesman name head
tmp$=tmp$+head$+fdel$	!#9
if retval$[9,9]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
 let tmp$=tmp$,"droplistsslsm",fdel$ ! droplist name **** for the salesperson
 list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 

If Not(Credit)
	tmp$="TERMS"+fdel$ !#10
	tmp$=tmp$+"TERMS"+fdel$ !#10
Else
	tmp$="INVNO"+fdel$ ! #10
	tmp$=tmp$+"INVNO"+fdel$
Endif
if retval$[10,10]="F" or (Credit and GENCM=1) ! force it
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
 If Not(Credit) let tmp$=tmp$,"droplistartermcode ",fdel$ 
 If Credit let tmp$=tmp$," ",fdel$ ! droplist name
 list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

tmp$="ATTN"+fdel$	!#11
tmp$=tmp$+"ATTN"+fdel$	!#11
if retval$[11,11]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
let tmp$=tmp$," ",fdel$ ! droplist name
list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

If Not(Credit)
tmp$="SHIPDATE"+fdel$ ! #12
tmp$=tmp$+"SHIP DATE"+fdel$ ! #12
Else
	tmp$="DATEINVD"+fdel$ ! #12
	tmp$=tmp$+"DATE INVD"+fdel$
Endif
if retval$[12,12]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
let tmp$=tmp$," ",fdel$ ! droplist name
list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

tmp$="DEPT"+fdel$      ! #13
tmp$=tmp$+"DEPT"+fdel$      ! #13
if retval$[13,13]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
let tmp$=tmp$,"droplistdeptfle",fdel$ ! droplist name
list$[row]=tmp$
 let row=row+1
 If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

If Not(Credit)
tmp$="WHSE"+fdel$
read #ctlc,18,30;head$;     ! warehouse name head 
tmp$=tmp$+head$+fdel$       ! #14 
Else
	tmp$="ENTBY"+fdel$ ! #14
read #ctlc,18,80;head$;
tmp$=tmp$+head$+fdel$	 ! #14 ! entered by
Endif
IF retval$[14,14]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
If Not(Credit) let tmp$=tmp$,"droplistordwh",fdel$ ! droplist name
if credit let tmp$=tmp$,"droplistentdby",fdel$ ! droplist name 
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

If not(credit)
tmp$="DUEDATE"+fdel$  ! #15
tmp$=tmp$+"DUE DATE"+fdel$  ! #15
Else
	tmp$="WEIGHT"+fdel$
	tmp$=tmp$+"WEIGHT"+fdel$ ! #15
Endif
IF retval$[15,15]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
let tmp$=tmp$," ",fdel$ ! droplist name
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
	
If Not(Credit)
tmp$="SHIPNO"+fdel$   ! #16
tmp$=tmp$+"SHIP#"+fdel$   ! #16
Else
	tmp$="CMTYPE"+fdel$ ! #16
	tmp$=tmp$+"CMTYPE"+fdel$
Endif
IF retval$[16,16]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
  If not(credit) let tmp$=tmp$,"ShipTermList",fdel$ 
  If Credit let tmp$=tmp$+"CMTypeList"+fdel$
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

tmp$="ROUTING"+fdel$ ! #17
tmp$=tmp$+"ROUTING"+fdel$ ! #17
IF retval$[17,17]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
 let tmp$=tmp$,"RoutingList",fdel$
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

If Not(Credit)
tmp$="ENTBY"+fdel$ ! #18
read #ctlc,18,80;head$;
	tmp$=tmp$+head$+fdel$	 ! #18 ! entered by
Else
	tmp$="CMDATE"+fdel$	! #18
	tmp$=tmp$+"CM DATE"+fdel$
Endif
IF retval$[18,18]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
If Not(Credit) let tmp$=tmp$,"droplistentdby",fdel$ ! droplist name 
if credit let tmp$=tmp$," ",fdel$ ! droplist name 
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

If Not(Credit)
tmp$="ZONE"+fdel$   ! #19 
tmp$=tmp$+"ZONE"+fdel$   ! #19 
Else
	tmp$="ORDTYPE"+fdel$   ! #19
tmp$=tmp$+"TYPE"+fdel$   ! #19
Endif
IF retval$[19,19]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
If Not(Credit) let tmp$=tmp$,"droplistzonefle",fdel$ ! droplist name 
If Credit let tmp$=tmp$,"droplistordtype",fdel$ ! droplist name
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

If Not(Credit)
tmp$="TRUCK"+fdel$  ! #20
tmp$=tmp$+"TRUCK"+fdel$  ! #20 
Else
	tmp$="DIV"+fdel$  ! #20
tmp$=tmp$+"DIVISION"+fdel$  ! #20
Endif
IF retval$[20,20]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
If Not(Credit) let tmp$=tmp$," ",fdel$ ! droplist name
if credit let tmp$=tmp$,"droplistdivifle",fdel$ ! droplist name
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

If Not(Credit)
tmp$="STOP"+fdel$   ! #21
tmp$=tmp$+"STOP"+fdel$   ! #21
Else
	tmp$="WHSE"+fdel$
read #ctlc,18,30;head$;     ! warehouse name head 
tmp$=tmp$+head$+fdel$       ! #21
Endif
IF retval$[21,21]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
If Not(Credit) let tmp$=tmp$," ",fdel$ ! droplist name
IF credit let tmp$=tmp$,"droplistordwh",fdel$ ! droplist name
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

If Not(Credit)
tmp$="ORDTYPE"+fdel$   ! #22
tmp$=tmp$+"TYPE"+fdel$   ! #22
Else
	tmp$="ZONE"+fdel$   ! #22 
tmp$=tmp$+"ZONE"+fdel$   ! #22 
Endif
IF retval$[22,22]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
If Not(Credit) let tmp$=tmp$,"droplistordtype",fdel$ ! droplist name
if credit let tmp$=tmp$,"droplistzonefle",fdel$ ! droplist name 
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

If Not(Credit)
tmp$="DIV"+fdel$  ! #23
tmp$=tmp$+"DIVISION"+fdel$  ! #23
Else
	tmp$="TRUCK"+fdel$  ! #23
tmp$=tmp$+"TRUCK"+fdel$  ! #23
Endif
IF retval$[23,23]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
if not(Credit) let tmp$=tmp$,"droplistdivifle",fdel$ ! droplist name
if credit let tmp$=tmp$," ",fdel$ ! droplist name
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

If Not(Credit)
tmp$="SRCE"+fdel$ ! #24
tmp$=tmp$+"SOURCE"+fdel$ ! #24
Else
	tmp$="STOP"+fdel$   ! #24
tmp$=tmp$+"STOP"+fdel$   ! #24
Endif
IF retval$[24,24]="F"
	let tmp$=tmp$+"Y" +fdel$
 else
	let tmp$=tmp$+"N" +fdel$
 endif
If Not(Credit) let tmp$=tmp$,"droplistsorce",fdel$ ! droplist name
If Credit let tmp$=tmp$," ",fdel$ ! droplist name
list$[row]=tmp$

Call AddToStr(e$,rstr$,List$[])  ! put header into rstr$  
Call AddToStr(e$,rstr$,esdel$) ! end of section

call SetOutput(e$,rstr$)
ELSE
! THIS IS A REMARK
END TRY

End sub ! ordhlabel
Sub OrdList()  
!! this get a list of the open orders for the customer !!
try
	Dim cust$[6],keyroh$[50],xdate$[10],statword$[200]
	dim 2%,bo,3%
	! need in read only mode to prevent record locking
	Try close #ch_roh Else Rem
	Try close #ch_ros Else Rem
	Try close #ch_rot Else Rem
	Ch_Roh = openfile(-1840,intCo) \ If Ch_Roh = -1 Error 42     !"order header file
  	Ch_Ros = openfile(-1856,intCo) \ If Ch_Ros = -1 Error 42     !"order shipto file
	Ch_Rot = openfile(-1872,intCo) \ If Ch_Rot = -1 Error 42     !"order total file
	
	LET STATWORD$="ENTERED   PRINTED   REGISTEREDRDY TO INV"
	STATWORD$=STATWORD$+"INV ENTRD INV PRNTD INV REGD            "
	STATWORD$=STATWORD$+"C/M ENTRD C/M PRNTD C/M REGD            "
	Call DXGet("custid",cust$) \ custid=cust$
	cust$=custid using "######"
	cust$ = cust$+Blank$
	cust$[7]="" ! "cut after 6 chars
	clear List$[]
	keyroh$=" ",keyroh$
	keyroh$=cust$
	Call DXGet("SOURCE",tmp$) 
	source=tmp$ \ if credit let source=0
	if source=201 or source=208 let source=0 !  USES 0 for them!
	List$[0]=bsdel$,"OpenOrderList",fdel$
	WebStr$="OrderID",fdel$
	WebStr$=WebStr$,"Date",fdel$,"Status",fdel$
	WebStr$=WebStr$,"PO#",fdel$,"Ship To Name",fdel$,"Type",fdel$,"BackOrder",fdel$
	Webstr$=webstr$,"Ship Date",fdel$,"Whse",fdel$
	List$[1]=WebStr$
	row=2
	if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	keyroh$=" ",keyroh$
	keyroh$=cust$+Blank$ ! starts with customer
	mode$=">" ! search mode 3
	dir=2
	clear chan[]
	CHAN[0]=CH_ROH
	CHAN[1]=CH_ROS
	CHAN[2]=CH_ROT
	Do
		Rec_roh=filegetrohz(e$,chan[],mode$,dir,keyroh$,roh.,ros.,rot.)
		If Rec_roh<0 or keyroh$[1,6]<>Cust$[1,6] Exit Do
		if source=231 exit do ! NO OPENS (or treat as inv edit?)
		if not(ot[roh.ordtype]) goto getnxtcustord: ! not set up serp
		if not(source) or source=207 ! regular order 201/208
			If Not(Credit) and Not(Invoice)
				IF source<>207
					if roh.status>4 and roh.status<>95 goto getnxtcustord:
					if roh.status=95
						if roh.lockport<>rec_uac goto getnxtcustord:! check if being entered by the same user
				!goto getnxtcustord:
					endif
				else
					! 207 INQUIRY STATUS
					! if roh.status>8 and roh.status<12 goto getnxtcustord: ! bypass credit memos
					! if roh.status=97 goto getnxtcustord: ! bypass credit memo in process
					if roh.status>12 AND roh.status<58 goto getnxtcustord:
					if roh.status>59 and roh.status<93 goto getnxtcustord:
					if roh.status>97
						if roh.lockport<>rec_uac goto getnxtcustord:
					endif
				endif
			Endif
		  If Credit 
			If roh.status<9 Or (roh.status>12 and roh.status<>97) goto getnxtcustord
			if roh.status=97
				if roh.lockport<>rec_uac goto getnxtcustord:! check if being entered by the same user
				!goto getnxtcustord:
			endif
		  Endif
			
		endif
		if source=251 ! from cash sales/point of sale
			if roh.status<70 goto getnxtcustord: ! was <58 - but can't show on list
			if roh.status>59 and roh.status<>94 goto getnxtcustord:
			if roh.status=94
				if roh.lockport<>rec_uac goto getnxtcustord:
				!goto getnxtcustord:
			endif
		endif
		If source=223 ! inv edit - 5/6 & 96 only
			if roh.status<5 goto getnxtcustord
			if roh.status>6 and roh.status<>96 goto getnxtcustord
			if roh.status=96
				if roh.lockport<>rec_uac goto getnxtcustord:
				!goto getnxtcustord:
			endif
			if roh.status=94
				if roh.lockport<>rec_uac goto getnxtcustord:
			endif
		endif
		WebStr$=str$(roh.ordnum),fdel$ ! order ID 
		if roh.orddate
			let xdate$=pdate$(roh.orddate)
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! order date
		LET tmp$=" ",tmp$
		if not(source)
		  If Not(Credit) and Not(Invoice)
			if roh.status<=4
				tmp$=STATWORD$[roh.status*10-9,roh.status*10]
			else
				if roh.status=95
					tmp$="Order Erp Proc"
				endif
			endif
		   Endif
		  If Credit
			if roh.status>=9 and roh.status<=12
				let x2=roh.status ! -8
				tmp$=STATWORD$[x2*10-9,x2*10]
			else
				if roh.status=97
					tmp$="Credit Erp Proc"
				endif
			endif
		   Endif
		else
			if source=207 ! 
				if roh.status>=1 and roh.status<12
					let x2=roh.status
					tmp$=STATWORD$[x2*10-9,x2*10]
				else
					tmp$="In Edit Proc"
					if roh.status=58 let tmp$="Order Being Picked"
					if roh.status=59 let tmp$="Order Is On Hold"
					if roh.status=94 let tmp$="POS Ord Erp Proc"
					if roh.status=95 let tmp$="Order Erp Proc"
					if roh.status=96 let tmp$="Invoice Erp Proc"
					if roh.status=97 let tmp$="Credit Erp Proc"
				Endif
			Endif
			if source=251 ! point of sale
				if roh.status=58 let tmp$="Order Being Picked"
				if roh.status=59 let tmp$="Order Is On Hold"
				if roh.status=94 let tmp$="POS Ord Erp Proc"
			endif
			if source=223 ! inv edit
				if roh.status=5 or roh.status=6
					let x2=roh.status ! -4
					tmp$=STATWORD$[x2*10-9,x2*10]
				else
					if roh.status=96
						tmp$="Invoice Erp Proc"
					endif
				endif
			Endif
			
		endif
		WebStr$=WebStr$,RTrim$(tmp$),fdel$ ! status
		WebStr$=WebStr$,RTrim$(roh.custpo$),fdel$ ! po#
		read record #ch_ros,roh.shiprec;ros.;
		WebStr$=WebStr$,RTrim$(ros.name$),fdel$ ! ship to name
		let ordtyped$=getordtypd$(ctlc,roh.ordtype,intco)
		tmp$=ordtyped$
		Webstr$=Webstr$,rtrim$(tmp$),fdel$ ! order type
		let bo=0
		let keyrol$=" ",keyrol$;keyrol$=roh.ordnum using "######"
		do
			search #ch_rol,3,1;keyrol$,rec_rol,e
			if e>0 exit do
			let tmp3=keyrol$[1,6]
			if tmp3<>roh.ordnum exit do
			read #ch_rol,rec_rol,186;bo;
			if bo exit do
		loop
		tmp$=""
		if bo let tmp$=tmp$+"*"
		Webstr$=Webstr$,rtrim$(tmp$),fdel$ ! backorder
		! need to have check for backorders ! -- done above in bo
		if roh.ShipDate>0 and roh.ShipDate<>999999
			let xdate$=pdate$(roh.ShipDate)
		else
			let xdate$=" ",xdate$
			if roh.ShipDate=999999 let xdate$="99/99/9999"
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! order ship date
		Webstr$=Webstr$,Str$(roh.wh),fdel$ ! order header warehouse
		List$[row]=WebStr$
		row=row+1
		if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
		getnxtcustord: ! get the next customer order
	    Loop ! of open orders for customer
else
	include "src/callsuberr.inc"
end try
end sub ! ordlist
!------ ordwhdroplist ------
! filter eligible warehouse number for customer/order type
! need customer cons whs, order edit flag, 
Sub OrdWhdroplist(list$[],orderid,linesexist,ORDTYPE,ordwh) 

  ! creates a drop list
  !
   ! filter eligible warehouse number for customer/order type
  ! need customer cons whs, order edit flag, 
  Try
     read #ctlc,60,16;conswh;
     read #ctlc,115,20;maxwh;

    tmpcnt=99
    !
    ! beginning section
    List$[0]=bsdel$,"droplistordwh",fdel$ ! beginning section
 
    ! heading section for .net
    List$[1]="ID",fdel$,"WhName",fdel$

    ! create data section
    row=2
    if maxwh<>0
		if maxwh< (chf(ch_wh)-1) let maxwh=(chf(ch_wh)-1)
    endif
	if conswh>0 and orderid<>0
      if ordtype<>7 and ordtype<>8 ! ot 7/8 gets ALL WHSES
		if maxwh>conswh let maxwh=conswh-1
      endif
	Endif
	If Orderid=0 and conswh>0 ! not known what ot yet!
		if cust.ConsignWh<conswh ! not consign - transfer?
			if maxwh>conswh let maxwh=conswh-1
		Endif
	Endif
    for cnt=0 to maxwh  ! warehouse 1 starts at record 0
	!!! check to see if valid !!!
	read record #ch_wh,cnt;wh.;
	if row>tmpcnt let tmpcnt=expandarray(E$,List$[])
	let webstr$=""
	if wh.whname$[1,5]<>"     " and wh.whname$<>"" ! needs to have a description to be valid
		if orderid<>0 ! orderid -- then it is an edit
			if linesexist<>0
				if (cnt+1)=ordwh ! same warehouse include in list
					let tmp$=(cnt+1) using "##"
					let webstr$=tmp$,fdel$,wh.whname$,fdel$
				else
					IF P61$[110,110]<>"Y"
						if ordtype=2 or (ordtype=3 and p60$[22,22]="N")
						! direct order or indirect and update stock=N then change warehouse
							let tmp$=(cnt+1) using "##"
							let webstr$=tmp$,fdel$,wh.whname$,fdel$
						endif
					endif
				endif
			else
				! no lines exist -- can change the warehouse
				let tmp$=(cnt+1) using "##"
				let webstr$=tmp$,fdel$,wh.whname$,fdel$
			endif
		else
			! new order 
			let tmp$=(cnt+1) using "##"
			let webstr$=tmp$,fdel$,wh.whname$,fdel$
		endif
	endif
	if webstr$
		 List$[row]=webstr$
		row=row+1
        endif
        !
      next cnt
    !
    if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
    List$[row]=esdel$ ! end of section delimiter
    !
  else
    if spc(8) <> 10000
      e$="error in filedroplist whinfo"
    if spc(8) = 123 let e$=" record locked"
      if spc(8)<10000 if spc(8)<>123 call suberr(e$,Spc(8),Spc(10),Msc$(2))
    end if
    error 10000
  end try
end sub ! ordwhdroplist 
! ----------------------------------------------------------------------------------
 Sub OrdTypelist(list$[],orderid,linesexist,ORDTYPE,ordwh) 
 !*** Currently For types 1, 2, and 3 only ****
 ! added 5, 6, 7, 8, 9, 10, 11, 12, 15, 16, 20, 21, 22, 24, & 25 THRU 34
 try
	Clear list$[]
 	tmpcnt=maxcnt
	List$[0]=bsdel$,"droplistordtype",fdel$ ! beginning section!
	!if orderid=6226 call programdump("/tmp/ordhtl!","")
	!
	List$[1]="ID",fdel$,"Description",fdel$
    !
	if cust.ConsignWh>0 and orderid=0 and ordtype=16 let orderid=-1;linesexist=9 ! only ot for customer
	if cust.ConsignWh>0 and orderid<>0 and ordtype=16 let linesexist=9 ! only ot for customer
	ostat=roh.status \ if ostat>89 let ostat=roh.OrgStatus
	!
	row=2
	for cnt=1 to 38 ! include all - parse valid
	   if not(ot[cnt]) goto excltype ! not set up
	   if credit and (cnt=9 or cnt=12 or cnt=16) goto excltype ! not on cm's
	   !IF source=223 ! only can change 1 or 12 or 13 OT?
		!if ordtype
	    !Endif
	   ! Endif
	   if ostat>1 and ordtype<>9 and cnt=9 goto excltype ! orderstat>1 - no to ot9
	   ! IF cust.ConsignWh=0 and ordtype<>16 and (cnt=16 or cnt=7 or cnt=8) goto excltype ! no cons whs
	   IF cust.ConsignWh=0 and (cnt=16 or cnt=7 or cnt=8) goto excltype ! no cons whs
		let dsp=(cnt-1)*20
	        read #ctlc,62,dsp;desc$[1,20];
		let webstr$=""
		if rtrim$(desc$)<>"" ! we have a description
			if orderid <>0 ! come from order edit
				if linesexist<>0 ! there are lines on this order
					if ordtype=cnt ! include same order type always
						webstr$=str$(cnt),fdel$
						webstr$=webstr$,rtrim$(Desc$),fdel$
					else
						! WE'LL USE MX208A AS A GUIDE
						if (ordtype>=1 and ordtype<=3) OR (ordtype>=28 and ordtype<>36 and ordtype<>37) ! can chg to any (use otypeprocess() to check)
						  IF cnt<>4 and cnt<>8 and cnt<>15 and cnt<>16 and cnt<>20 and cnt<>21 and cnt<>22 and cnt<>36 and cnt<>37
							webstr$=str$(cnt),fdel$
							webstr$=webstr$,rtrim$(Desc$),fdel$
						  Endif
						Endif
						if ordtype=21 or ordtype=22 ! can only go from 21 to 22 or 22 to 21
							if cnt=21 or cnt=22
								webstr$=str$(cnt),fdel$
								webstr$=webstr$,rtrim$(Desc$),fdel$
							endif
						endif
						if ordtype=5 or ordtype=11 ! can chg to any (use otypeprocess() to check)
						  IF cnt<>4 and cnt<>8 and cnt<>15 and cnt<>16 and cnt<>20 and cnt<>21 and cnt<>22 and cnt<>36 and cnt<>37
							webstr$=str$(cnt),fdel$
							webstr$=webstr$,rtrim$(Desc$),fdel$
						  Endif
						Endif
						!if ordtype=2 and (cnt=3 and p60$[22,22]="N")
						!	! orignal direct & indirect don't update stock
						!	webstr$=str$(cnt),fdel$
						!	webstr$=webstr$,rtrim$(Desc$),fdel$
						!endif
						!if ordtype=3 ! indirect 
						!	if cnt=2 ! direct
						!		if p60$[22,22]="N" ! include the direct type
						!			webstr$=str$(cnt),fdel$
						!			webstr$=webstr$,rtrim$(Desc$),fdel$
						!		endif	
						!	endif
						!	if cnt<>2
						!		if p60$[22,22]="Y"
						!			webstr$=str$(cnt),fdel$
						!			webstr$=webstr$,rtrim$(Desc$),fdel$
						!		endif	
						!	endif
						!endif ! ot 3
						if ordtype=6 or ordtype=9 or ordtype=10 or ordtype=12 ! allowed change to any
						  IF cnt<>4 and cnt<>8 and cnt<>15 and cnt<>16 and cnt<>20 and cnt<>21 and cnt<>22 and cnt<>36 and cnt<>37
							webstr$=str$(cnt),fdel$
							webstr$=webstr$,rtrim$(Desc$),fdel$
						  Endif
						Endif
						! if ordtype= ! future use - allow change of ordtypes
					endif ! same/diff ot
				else
					! no lines on order can edit this
					webstr$=str$(cnt),fdel$
					webstr$=webstr$,rtrim$(Desc$),fdel$
				endif
			else
				! new order can use any type
				webstr$=str$(cnt),fdel$
				webstr$=webstr$,rtrim$(Desc$),fdel$
			endif
		
		endif ! has desc
		if webstr$
			if row>tmpcnt let tmpcnt=expandarray(E$,List$[])
			let list$[row]=Webstr$
			row=row+1
		endif
	excltype: ! exclude type
	next cnt
	!
	if row>tmpcnt let tmpcnt=expandarray(E$,List$[])
	List$[row]=esdel$ ! end section delimiter
	if orderid=-1 let orderid=0 ! reset
	!
  else
    include "src/callsuberr.inc"
  end try
end sub ! OrdTypeList
! ---------------------------------------------------------------------------------
Sub CalcShipDate() 
	  

try
	
	dim keyzone$[2],SDATE$[50],t2$[7]
	dim 1%,flag,stat,warn
	dim 2%, cuttime,dt3[1],CURTIM[9]
	dim 3%,vdate,param[5] 
	MAT  READ #ctlc,182,84;CUTTIME;
	if cuttime<=0 let cuttime=24 ! always a day away -- from build order
	If credit exit sub
	If source=251 exit sub ! They're at the counter - SHIP IS NOW!
	clear zn.
	let keyzone$=ros.zone$
	search #ch_zone,2,1;keyzone$,rec_zone,e
	if not(e)
		read record #ch_zone,rec_zone;zn.;
		let ros.truck=zn.trucknum
		if shipdateedit=0
			IF P61$[34,34]<>"Y" ! "cust/shiplist multi-zone 
		 		 if roh.orddate let roh.shipdate=roh.orddate
				 if zn.leadtime<0 let zn.leadtime=1 ! always a day away NOT ACCORD TO 666
				 LET TMP$=roh.shipdate USING "&&&&&&"  ! yymmdd format                        
				 Call DateToJulian(1,tmp$,tmp$,e)
				 LET TMP3=TMP$[1,5] 
				 if orderid=0
					LET  sdate$="" 
					Call Time(SDATE$)
					LET CURTIM[0]=SDATE$[15,16] ! HOUR                                      
					LET CURTIM[1]=SDATE$[18,19]  ! MINUTER                                    
					LET CURTIM[2]=SDATE$[21,22]  ! SECOND                                    
					LET CURTIM[3]=CURTIM[0]*10000+CURTIM[1]*100+CURTIM[2]  ! TIME CALC                 
					IF CURTIM[3]>CUTTIME 
						LET TMP3=TMP3+1 ! a day away 
					Endif
				 endif ! check cut off on new order
				 LET TMP3=TMP3+zn.leadtime                                   
				 LET VDATE=TMP3;STAT=0;WARN=0;PARAM[0]=roh.wh;PARAM[1]=roh.div
				 CALL "validdate",vdate,STAT,WARN,PARAM[]  
				 let tmp3=vdate ! 1st check - see if lead time is on a holiday
	 			 if P60$[16,16]="Y" ! CALC SHIPDATE BY zone days
					if roh.ordtype<>4 and roh.ordtype<>15 and roh.ordtype<>16
						mat read #ch_zone,rec_zone,36;t2$; ! zone days
						x=0;x1=0;x1[1]=0 ! first see if any days ship!! avoid eloop
						for i=1 to 7 ! use matrix - not individ
						  if t2$[i,I]="Y" let x=x+1
						next i
						if x>0 ! has at least 1 day!
						ZNNXTDAY: ! loop until shipping day for zone
							x1=x1+1
						ZNNXTCHK: ! check it if holiday change
							x$=TMP3 USING "&&&&&"
							Call JulianToDate(1,X$,X$,E)
							IF NOT(E)
								J1 = X$[7,8] \ J2 = X$[1,2] \ J3 = X$[4,5]
								If J1 < 85 Let J1 = J1 + 100
								Z4 = J2 + 1 \ Z5 = Int(1 / Z4 + .7) \ Z6 = J1 - Z5 \ Z7 = Z4 + 12 * Z5
								Z8 = Int(Z7 * 30.6001) + Int(Z6 * 365.25) + J3 \ Z9 = Z8 - 7 * (Int(Z8 / 7))
								I = Z9 + 1
								If T2$[I,I] = "N"
									if x1>14 goto bpdloop ! give 14 tries - give up
									let tmp3=tmp3+1
									goto znnxtday
								 BPDLoop: ! end or bypass
								endif ! if Y - ok
								LET VDATE=TMP3;STAT=0;WARN=0;PARAM[0]=roh.wh;PARAM[1]=roh.div
								CALL "validdate",vdate,STAT,WARN,PARAM[]  
								If tmp3<>vdate and x1[1]<15 ! 2nd chk
									let tmp3=vdate ! 2nd check
									let x1[1]=x1[1]+1
									goto ZNNXTCHK
								Endif
							endif
						Endif ! zone has ship days
					Endif ! valid order type
				 Endif ! calc ship date
				 LET DT3[0]=tmp3 \ LET DT3[1]=tmp3\ LET FLAG=0              
				 CALL "JULIANUTIL",DT3[],TMP$,FLAG   ! julian to yymmdd                      
				 LET TMP3=TMP$      
				 LET roh.shipdate=TMP3  ! should be valid zone date too
				 let roh.duedate=TMP3 
			endif ! multi-zone - no calc!
			if roh.shipdate<=0 let roh.shipdate=roh.orddate
			if roh.shipdate=0 exit sub ! no date - no calc!
			if roh.shipdate=999999 exit sub ! backorder - no calc!
			LET VDATE=roh.shipdate;STAT=1;WARN=0;PARAM[0]=roh.wh;PARAM[1]=roh.div
			CALL "validdate",vdate,STAT,WARN,PARAM[]  
		        let roh.shipdate=vdate
		        let roh.duedate=vdate
			!if orderid=0 ! moved to before validdate
			
			!endif ! new order check time stamp 
				
		endif ! emd shipdate edit flag
	 endif ! end zone record on file
	
else
	include "src/callsuberr.inc"
end try
end sub ! calcshipdate
! ------------------------------------------------------------------
Sub findshiplist() ! getshiplistinfo **** subroutine
! need to have custid,orderid,shipcustid,shipcode
! customer file should have been read already 
try
	dim 2%,taxcode,taxtype,delchglvl,salesarea
	dim 2%,staxcode,staxtype
	dim 3%,rec_ship1,rec_sslsm
	dim keyship1$[40],keyslsm$[40]
	let taxcode=0;taxtype=0;delchglvl=0;salesarea=0
	keyship$=(shipcustid+(shipcode/10^6)) using "######.######"
	shipkey$=""
	mode$="="
	dirno=1
	ShipRec=FileGetShiplist(e$,Ch_Ship,mode$,dirno,KeyShip$,sh.)
	if shiprec>0 ! ship list found
		if not (orderid) 
			clear ros. ! initialize the ship variable
		endif
		let ros.ordnum=orderid
		let ros.name$=sh.name$
		let ros.address$=sh.address$
		let ros.address2$=sh.optaddress$
		let ros.city$=sh.city$
		let ros.state$=sh.state$
		let ros.zipcode$=sh.zipcode$[1,6]
		let ros.zip4$=sh.zipcode$[7,10]
		let ros.country$=sh.country$
		let ros.shipedit=0
		if not(shipcustid)
			let shipcustid=ros.shipcust
			if not (shipcustid)
				let shipcustid=roh.custnum
			endif
		endif
		if sh.email$[1,5]<>"     " and len(sh.email$)>5
		If rtrim$(sh.email$)<>""
			let rot.email$=rtrim$(sh.email$)+blank$
		endif
		endif
		if shipcode=0 let ros.shipedit=1 
  		if shipcode<>0 let ros.shipedit=2
		if shipcustid<>custid let ros.shipedit=4
		roh.shipvia$=sh.Routing$
		if TRIM$(ROH.shipvia$)="" let roh.shipvia$="OUR TRUCK"
		let ros.shipcode=shipcode
		let ros.shipcust=shipcustid
		
		let shipkey$=sh.shiplistnumber using "######.######"
		if rtrim$(sh.contact$)<>""
			let roh.contact$=sh.contact$+Blank$
		else
			if not(orderid)
				let roh.contact$=cust.contact$+Blank$
			endif
		endif
		if p61$[34,34]<>"Y" or orderid=0 ! not multi zone customer 
			let roh.StopNum=sh.sstop$
		endif
		if sh.saleszone<>0
			let roh.salesarea=sh.saleszone
			if ros.shipcust<>custid
				let roh.salesarea=0 ! 
			endif
		else
			if ros.shipcust=custid
				if not(roh.salesarea) let roh.salesarea=cust.custsaleszone
			endif
		endif
		if custid<>shipcustid
			if sh.zone$=" 0" or sh.zone$="  "
				let ros.truck=0
			endif
		endif
		let taxcode=sh.taxcode
		let taxtype=sh.taxtype
		let delchglvl=sh.deliverychrglvl
		!if taxtype=0 or taxcode=0 ! no tax code let check default ship cust
			!if shipcode<>0 ! lets look in default
			!	let keyship1$=" ",keyship1$
			!	let keyship1$=shipcustid using "######.######"
			!	search #ch_ship,2,1;keyship1$,rec_ship1,e
			!	if not (e)
			!		if not(taxtype)
			!			read #ch_ship,rec_ship1,498;staxtype;
			!			let taxtype=staxtype
			!		endif
			!		if not(taxcode)
			!			read #ch_ship,rec_ship1,184;staxcode;
			!			let taxcode=staxcode
			!		endif
			!	endif
			!endif
		!endif
		if not (taxcode) let taxcode=cust.taxcode
		if not (taxtype) let taxtype=cust.taxtype
		let roh.taxcode=taxcode
		let ros.shiptaxtype=taxtype
		if not (orderid) ! new order ! set the warehouse #
			if sh.defaultwhse<>0
				let roh.wh=sh.defaultwhse
			endif
			if sh.ddiv>0 and sh.ddiv<100
				let roh.div=sh.ddiv
			endif
		endif
		if roh.div<=0 let roh.div=1
		if not (roh.wh)
			let roh.wh=cust.defaultwhse
		endif
		if not (roh.wh)
			let roh.wh=prt.wh
		endif
		If custom_customer$<>"SWP"
			if not (roh.wh) let roh.wh=1 ! 
		endif
		if p61$[109,109]<>"Y"
			let rot.delivchrglvl = sh.deliverychrglvl
		endif
		if sh.slsm<>0
			let keyslsm$=" ",keyslsm$
			let keyslsm$[1,3]=sh.slsm using "###"
			keyslsm$[5]=""
			search #ch_Sslsm,2,1;keyslsm$,rec_slsm,e
			if not(e)
				let roh.slsmnum=sh.slsm
			endif
		endif
		if not(roh.slsmnum) let roh.slsmnum=cust.salesmancode
		let roh.stopnum=sh.sStop$
		let ros.zone$=sh.zone$

		if not(orderid) and rtrim$(ros.zone$)=""
			let ros.zone$=cust.zonenumber$
		endif
		let ros.zone$=ros.zone$+"  "
		if p61$[34,34]="Y" ! multi-zone customer
			if not (ros.shipcust) let ros.shipcust=custid
			if not (roh.shipdate) let roh.shipdate=roh.orddate
			call "MXOHCSZONE",ros.shipcust,ros.shipcode,roh.orddate,roh.div,roh.wh,roh.shipdate,ros.zone$,roh.stopnum,IntCo
			If source=251 let roh.shipdate=roh.orddate ! POS - SHIP NOW!
			let roh.duedate=roh.shipdate	
		endif
		if rtrim$(ros.zone$)=""
			if rtrim$(sh.zone$)<>"" let ros.zone$=sh.zone$
			if rtrim$(ros.zone$)=""
				if rtrim$(cust.zonenumber$)<>"" let ros.zone$=cust.zonenumber$
			endif
		endif
		! now let's get the zone 
		let mode$="="
		let dirno=1
		clear zn.
		ZoneRec=FileGetZonefle(e$,Ch_Zone,mode$,dirno,ros.zone$,zn.)
		if zonerec>0
			let ros.truck=zn.trucknum
			!let ros.zone$=sh.zone$
			if rtrim$(zn.shipvia$)<>""
				let roh.shipvia$=zn.shipvia$
			endif
		Else ! zone not found
			let ros.zone$="  " ! "00" ! default? (I know not all customers have it setup!)
		endif
		if trim$(roh.shipvia$)=""
			let roh.shipvia$="OUR TRUCK"+Blank$
		endif
		
	else
		let shiprec=0
	endif ! end of shiprec
else
	include "src/callsuberr.inc"
end try
end sub  ! findshiplist
! ---------------------------------------------------------------------------------
Sub OrdHCreditCheck() 
	  

try
	if custom_customer$="PHILLIPS" !task#14117/cct#173357
		if source=251
			flag=0
			if roh.ordtype=1 exit sub
			if roh.ordtype=3 exit sub
			if roh.ordtype=12 exit sub
		endif
	endif
	if cust.CreditCheckDays=0
		let flag=0
		exit sub
	endif
	
	if shipcustid=0 let shipcustid=custid
	clear chan[]
	chan[1] =ctlc    ! cntrl file
	chan[2] =ch_cust ! customer file
	chan[3] = 0	 ! saract file ** not opened **
	chan[4] = 0      ! credit check file ** not opened ** ch_credck
	chan[5] =ch_roh	 ! order header
	chan[6] =ch_rot	 ! order total
	chan[7] =ch_ros	 ! order ship to
	work$=""
	flag=0
	if credit exit sub
	call getcredck(chan[],shipcustid,billcustid,rec_roh,ordamt,intCo,ReturnStatus,Message$,flag,work$)! need gp check	
	if flag
		clear cust.
		let keycust$=billcustid using "######"
		mode$="="
		dirno=1
		if billcustid>0
		CustRec=FileGetCust(e$,Ch_Cust,mode$,dirno,KeyCust$,cust.)
		else
			custrec=-1
		endif
		if CustRec>=0 ! record found
			If cust.CreditCode>0 and cust.CreditCode<=16
				let credcoded$=getcredcdd$(ctlc,cust.CreditCode,intco)
			endif
			let openordamt=cust.openorder+ordamt
			let arbal=cust.currentaragebal-cust.unappliedcredit+cust.agearamt1
			let arbal=arbal+cust.agearamt2+cust.agearamt3+cust.agearamt4
			if cust.terms>0 and cust.terms<=99
				let artermd$=getartermd$(ch_terms,cust.terms,intco)	
			endif
		endif
		let keycust$=billcustid using "######"
		mode$="="
		dirno=1
		CNoteRec=FileGetCustNotes(e$,Ch_CNotes,mode$,dirno,KeyCust$,cnotes.)
		if cnoterec<=0
			clear cnotes.
		endif
	endif
else
	include "src/callsuberr.inc"
end try
end sub ! ordhcreditcheck    
! ================== CalcFreightCharge =========================
Sub CalcFreightCharge() 
! should already have the order type and totals
! need dim for the the routine
dim 1%,calcfrgtflag,ftflg
dim 2%,maxwgt[11],dfltcost[11],mincost[11],maxcost[11],dfltchg[11]
dim 3%,wgt
try
	! calculate freight from tables                            
	calcfrgtflag=99                                            
	IF roh.ordtype=16 OR roh.ordtype=14 let calcfrgtflag=0
	if (not(credit) and roh.ordtype=37) or (credit and roh.ordtype=37 and roh.shiptype=16) let calcfrgtflag=0
	IF rot.subtot=0 let calcfrgtflag=0                         
	IF rot.totwgt=0 let calcfrgtflag=0                         
	IF roh.ordtype=8 or roh.ordtype=20 let calcfrgtflag=0   
	! if credit let calcfrgtflag=0 ! CAN DO MANUALLY
	if calcfrgtflag<>0                                         
		IF roh.ordtype=2                                   
		      LET rec_tmp=174                            
		 ELSE
			LET rec_tmp=173                            
		ENDIF
		 MAT  READ #ctlc,rec_tmp,0;MAXWGT;                  
		MAT  READ #ctlc,rec_tmp,48;DFLTCOST;               
		MAT  READ #ctlc,rec_tmp,96;MINCOST;                
		MAT  READ #ctlc,rec_tmp,144;MAXCOST;               
		MAT  READ #ctlc,rec_tmp,192;DFLTCHG;               
		MAT  READ #ctlc,rec_tmp,240;FTFLG;                 
		LET WGT=rot.totwgt                                 
		FOR LEVEL=0 TO 6                                   
		  IF WGT<=MAXWGT[LEVEL] GOTO FOUND_LEVEL:    
		NEXT LEVEL                                         
		IF LEVEL>6 LET LEVEL=6
		FOUND_LEVEL: ! level found REM   
		IF FTFLG=-1 ! cwt                                                       
			 LET rot.frgtchrg=DFLTCHG[LEVEL]*(WGT/100)                       
			 LET rot.frgtcost=DFLTCOST[LEVEL]*(WGT/100)                      
		ELSE  !flat                                                            
				LET rot.frgtchrg=DFLTCHG[LEVEL]                                 
				LET rot.frgtcost=DFLTCOST[LEVEL]                                
		ENDIF                                                                   
		IF MINCOST[LEVEL] AND rot.frgtcost<MINCOST[LEVEL] LET rot.frgtcost=MINCOST[LEVEL]                                                                       
		IF MAXCOST[LEVEL] AND rot.frgtcost>MAXCOST[LEVEL] LET rot.frgtcost=MAXCOST[LEVEL]                                                                       
        ! send back freight charge --- rot.frgtchrg                             
        ! send back freight cost --- rot.frgtcost                               
	endif                                                                           
                                                                              
else
	include "src/callsuberr.inc"
end try
end sub ! calcfreightcharge      
!========= CALCDELIVERYCHARGE =========

Sub CalcDeliveryCharge() 
! should already have the order type and totals
! need dim for the the routine
dim 1%,calcflag,dflag[4]
dim 2%,dcost[11],dchrg[11]
Dim 3%
try
	! Call dxsave(0,"tmp/cdelc.txt!")
	let calcflag=99   
	IF source<220  ! orders do check
		IF P61$[36,36]="Y" let calcflag=0 ! deliv calc at invoice time
	Else ! invoice plus
		if p61$[53,53]="N" and roh.OrgOrd<>0 let calcflag=0
		IF P61$[36,36]="N" and p61$[53,53]<>"Y" let calcflag=0
		!IF P61$[36,36]="Y" OR (p61$[53,53]="Y" and P61$[36,36]<>"Y" in 223c do calc
	Endif
	if credit or source=251 let calcflag=0 ! don't delete prev on credit (copied)
	if roh.ordtype=20 let calcflag=0 ! manual
	if custom_customer$="ACME" and (source=221 or source=223 or source=231 or source=251) ! 
		if p61$[53,53]="N" and roh.OrgOrd let rot.DelivChrgLvl=0
	Endif ! if p61$[53,53]="N" and ORef[2] let dclvl=0 ! ACME CUSTOM? (in mx223c)
	if calcflag ! need to delete previous misc charge/cost                          
		FOR ctr=0 TO 9                                                          
			IF INT(FRA(rot.MiscChrgCode[ctr]*10)*10)=9 !syscalc deliv chrg  
			  LET rot.MiscChrg=rot.MiscChrg-rot.Mcharge[ctr,0]        
			  LET rot.TotMiscCost=rot.TotMiscCost-rot.Mcharge[ctr,1]
			endif
                        IF INT(FRA(rot.MiscChrgCode[ctr])*10) ! flagged for gp  
                                LET rot.MiscChrg4Prof=rot.MiscChrg4Prof-rot.Mcharge[ctr,0]                                                                      
                                LET rot.MiscCost4Prof=rot.MiscCost4Prof-rot.Mcharge[ctr,1]                                                                      
                        ENDIF                                                   
                        LET rot.MiscChrgCode[ctr]=0;rot.Mcharge[ctr,0]=0;rot.Mcharge[ctr,1]=0                                                                   
                                                                         
		NEXT ctr                                                                
	endif ! end deleting of previous charges                                        
	IF P61$[53,53]="N" ! if don't do backorders                                     
	  IF roh.BOctr<>0 OR roh.OrgOrd<>0 let calcflag=0!roh.spare4=h5[6]org ord#
	ENDIF                                                                           
	IF roh.shipvia$[1,1]="+" let calcflag= 0  
	if custom_customer$="GPG" or custom_customer$="ACME" ! jliu 202985
		if UCase$(roh.shipvia$[1,3])<>"OUR" let calcflag=0
	Endif
	IF roh.OrdType=16 OR roh.OrdType=8 let calcflag=0
	if (not(credit) and roh.ordtype=37) or (credit and roh.ordtype=37 and roh.shiptype=16) let calcflag=0
	if  Rot.DelivChrgLvl=0 let calcflag=0
	if p61$[36,36]="N" ! order delv chrg
		if roh.OrdType<1 let calcflag=0 
		if custom_customer$<>"HTBERRY" ! all else
			if roh.OrdType>2 let calcflag=0 ! pm native: IF H5[7]>0 AND H5[7]<3 do calc
		Else ! htberry
			if roh.ordtype>2 and roh.ordtype<>35 let calcflag=0 ! 35 is same as 1
		Endif
	Endif
	whsetype=0 \ if roh.ordtype=1 let whsetype=1
	if custom_customer$="HTBERRY" and roh.ordtype=35 let whsetype=1 ! same as ot1
	if calcflag<>0                                                                  
		IF whseType=1 or p61$[36,36]="Y" ! inv's always whse type?                                                       
		     LET rec_tmp=172 
		 ELSE                                                                    
		    LET rec_tmp=171 
		ENDIF 
		
		 MAT  READ #1,rec_tmp,48;DCHRG;                                              
		MAT  READ #1,rec_tmp,96;DCOST;                                              
		MAT  READ #1,rec_tmp,240;DFLAG;                                             
		FOR ctr=0 TO 9 ! check to see if charge was manually calculated         
		IF INT(rot.MiscChrgCode[ctr])=DFLAG[1] let calcflag=0                 
		NEXT ctr                                                                
		REM! check for next avail misc code                                     
		FOR ctr=0 TO 9                                                          
			IF INT(rot.MiscChrgCode[ctr])=0 GOTO CALCDELIVCHG:                    
		NEXT ctr                                                                
		let calcflag=0                                                          
		CALCDELIVCHG: REM ok to calc delivery chargs                            
		 if ctr<0 let calcflag=0                                                 
		 if ctr>9 let calcflag=0                                                 
         if calcflag <>0                                                            
			 LET rot.MiscChrgCode[ctr]=DFLAG[1]+.09                          
			 IF INT(rot.MiscChrgCode[ctr])                                   
				read record #ch_misc,(INT(rot.MiscChrgCode[ctr]));misc.;        
				IF misc.distgp ! flag in gp calc                        
					LET rot.MiscChrgCode[ctr]=rot.MiscChrgCode[ctr]+.1      
				endif                                                                                             
				 IF DFLAG[0]=-3 ! flat rate                                      
					LET rot.Mcharge[ctr,0]=DCHRG[rot.DelivChrgLvl-1]        
					LET rot.Mcharge[ctr,1]=DCOST[rot.DelivChrgLvl-1]        
				 ELSE  ! CWT                                                    
					 LET rot.Mcharge[ctr,0]=FNR(DCHRG[rot.DelivChrgLvl-1]*(rot.TotWgt/100))                                                                  
					 LET rot.Mcharge[ctr,1]=FNR(DCOST[rot.DelivChrgLvl-1]*(rot.TotWgt/100))                                                                  
				 ENDIF                                                           
                                
				  LET rot.MCTXBL[ctr]=misc.taxable                              
				  IF ctax.mtax =0 LET rot.MCTXBL[ctr]=0
				  if rot.Subtot<>0 and rot.TaxMdseAmt=0 let rot.MCTXBL[ctr]=0 ! not taxable if no taxable mdse
			ENDIF                                                           
			 LET rot.MiscChrg=rot.MiscChrg+rot.Mcharge[ctr,0]                
			 LET rot.TotMiscCost=rot.TotMiscCost+rot.Mcharge[ctr,1]  
		     IF INT(FRA(rot.MiscChrgCode)*10) ! include in gross profit      
				 LET rot.MiscChrg4Prof=rot.MiscChrg4Prof+rot.Mcharge[ctr,0]                                                                              
				 LET rot.MiscCost4Prof=rot.MiscCost4Prof+rot.Mcharge[ctr,1]                                                                              
			ENDIF                                                           
		 ENDIF                                                                   
	Endif                                                                       
                                                                                                                                                                                                                                                             
                                                                              
else
	include "src/callsuberr.inc"
end try
end sub ! calcdeliverycharge                                           
!-----------------------------------------------------------------------
Sub OTypeProcess(flag,otchange)
! checking of order type - first whse/conswhse and ot 7,8,16
! flag=status of check: 0=okay, 1=no good
! otchange= if changed the ot - otchange=original Ordertype on file
! need to verify if products are allowed on the new order type - chkmtg
Try
	dim k2$[60],K3$[60]
	Dim 1%,PGOT[38]
	Dim 3%,WHMISC2[7]
	let ch_pgp=0
	flag=0 ! no problems
	if otchange=4 or otchange=8 or otchange=15 or otchange=16 or otchange=24 ! can never change from
		let returnstatus=0
		Let message$=message$+"Cannot change from order type "+Str$(OTChange)+". "
		goto OtChkDone ! once entered, you're stuck with it!?
	Endif
	if otchange=19 and roh.ordtype<>19 ! bill completes from 19 to x
		if roh.BOCTR<>0 ! already shipped - out of luck
			let returnstatus=0
			Let message$=message$+"Cannot change from order type "+Str$(OTChange)+". "
			goto OtChkDone ! once entered, you're stuck with it!?
		Endif
	Endif
	if otchange and roh.ordtype=19 and otchange<>19 ! to 19 from x
		if roh.BOCTR<>0 ! already shipped - out of luck
			let returnstatus=0
			Let message$=message$+"Cannot change to order type "+Str$(roh.ordtype)+". "
			goto OtChkDone ! once entered, you're stuck with it!?
		Endif
	Endif
	If cust.ConsignWh>0 And cust.ConsignWh<100 ! whoops only ot 16 allowed!
		if cust.ConsignWh<conswh and roh.ordtype<>16
			let returnstatus=0
			Let message$=message$+"Customer may only be used for transfers. "
			goto OtChkDone
		Endif
	Endif
	If (roh.ordtype=7 or roh.ordtype=8) and (cust.consignwh<Conswh or cust.consignwh=0)
		ReturnStatus=0
		Message$=Message$+"Customer not set up for consignment warehouse. "
		goto otchkdone
	Endif
	If roh.ordtype=16 and (cust.ConsignWh=0 or cust.ConsignWh>=ConswH) ! whoops no ot 16 allowed!
		let returnstatus=0
		Let message$=message$+"Customer is not set up for transfers. "
		goto OtChkDone
	Endif
	if (roh.ordtype=7 or roh.ordtype=8 or roh.ordtype=16) and cust.ConsignWh>0
		if roh.conswh=0 let roh.ConsWh=cust.ConsignWh ! only if not there already?
	Endif
	if (roh.ordtype=8 or roh.ordtype=16) and roh.ConsWh=roh.wh
		let returnstatus=0
		Let message$=message$+"Cannot transfer to same warehouse. "
		goto OtChkDone
	Endif
	IF (P61$[54,54]="N" or source>=231) AND roh.ordtype=16 ! auto authorize
	  If roh.xferauth=0 ! not prev auth
		let roh.XferAuth=1;roh.AuthBy=-1;roh.AuthDate=currdate
	  Endif
	Endif
	if roh.ordtype<>7 and roh.ordtype<>8 and roh.ordtype<>16 let roh.ConsWh=0
	IF not(credit) and (roh.ordtype=36 or roh.ordtype=37) ! EVAP (36=bill, 37=ship)
		rec=rec_roh;evflag=0 ! can have no prev bill on 36 - 37 REQUIRES bill
		if rec_roh<=0 or neworderflag 
			let rec=0-billcustid;evflag=roh.ordtype ! new - not yet written
			if billcustid<=0 let rec=0-custid
		endif
		call "chk36hist.dl4",REC,EVFLAG,Intco,ch_roh
		if evflag=0 and roh.ordtype=37 ! shipping w/o billing a no go
			returnstatus=0
			message$=message$+"NO EVAP HISTORY BILLING INVOICE FOUND FOR THIS MONTH! "
			goto otchkdone
		endif
	Endif
	if credit ! only ot 1,2,3,6,10, 24 and >27 allowed
		let x2=roh.ordtype ! new (and look at ot[])
		if x2=5 or x2=9 or X2=11 or x2=12 or x2=16 ! (x2>10 and x2<27)
		  if x2<>24 ! we allow ot 24
			let returnstatus=0
			Let message$=message$+"Invalid Order Type for Credits. "
			goto OtChkDone
		  Endif ! of special ot allowed
		Endif
		if otchange and otchange<>36 and otchange<>37
			if x2=36 or x2=37 ! orig<>EVAP - Now is - NO good
				let returnstatus=0
				Let message$=message$+"Cannot change to EVAP Credits. "
				goto OtChkDone
			  Endif ! of special ot allowed
		Endif
	Endif
	ostat=roh.status \ if ostat>80 let ostat=roh.OrgStatus
	! if orderid=6226 call programdump("/tmp/ordhtc!","")
	if ostat>1 ! see it ot9 from / to
		if otchange>0 and otchange<>9 and roh.ordtype=9 ! from any ot to 9
			returnstatus=0
			message$=message$+"Can not change to Order type 9 - Order is not status 1"
			goto OtChkDone
		Endif
		! can add more status driven checks here!
	Endif
	If not(otchange) goto otchkdone ! all new orders have no previous ot
	IF roh.ordtype<0 or roh.ordtype>38 goto endchkotlines:
	CH_PGP=OpenFile(-9965,IntCo) \ if ch_pgp=-1 error 42 ! prodgrp
	let keyrol$=" ",keyrol$;keyrol$=orderid using "######"
	chkotlines: ! check if lines on sales order can go on for this group
	search #ch_rol,3,1;keyrol$,rec_rol,e
	if e<>0 goto endchkotlines:
	let tmp3=keyrol$[1,6]
	if tmp3<>orderid goto endchkotlines:
	read record #CH_ROl,rec_rol,0;rol.;
	if rol.NStkItem goto chkotlines: ! no nonstocks
	k2$=rol.ProdCode$+Blank$
	k2$[13]=rol.whse using "##"
	search #ch_prwh,2,1;k2$,rec_prwh,E
	if e goto chkotlines: ! no prodwhse rec
	mat read #ch_prwh,rec_prwh,846;WHMISC2;
	if whmisc2[0]>0 and whmisc2[0]<1000 ! if no prodgrp - it's not a millitem
		K3$=" ",k3$
		k3$=whmisc2[0] using "###" ! 3
		search #ch_pgp,2,1;k3$,r[4],e
		if not(e)
			mat read #ch_pgp,r[4],30;pgot;
			if not (pgot[roh.ordtype])
				returnstatus=0
				message$=message$+"Product "+rtrim$(rol.prodcode$)+" not allowed this type"
				goto OtChkDone		
			endif
		endif
	endif
	goto chkotlines:
	endchkotlines: ! 
	If not(otchange) goto otchkdone ! all new orders have no previous ot
	! now the changed ot code
	linesexist=0
	let keyrol$=" ",keyrol$;keyrol$=orderid using "######"
	search #ch_rol,3,1;keyrol$,rec_rol,e
	if not (e)
		let tmp3=keyrol$[1,6]
		if tmp3=orderid let linesexist=99
	endif
	let x2=roh.ordtype ! to make for less typing - x2=NEW ORDERTYPE
	Let returnstatus=1 ! ok so far
	IF X2=20 AND otchange<>20 let returnstatus=0
	IF P60$[25,25]<>"Y" AND (x2=21 OR x2=22) let returnstatus=0
	IF (x2<>6 AND x2<>10) AND (otchange=6 OR otchange=10) ! change from sample/donation
		roh.OrdDisc=0
		rot.OrdDisc=0;rot.OthChrg=0
	Endif
	If Linesexist ! first see if change allowed  X2=new ot, otchange=old ot
		IF x2=15 AND OTCHANGE<>15 let returnstatus=0
		IF X2=4 AND OTCHANGE<>4 let returnstatus=0
		IF (X2=21 OR X2=22) AND (otchange<>21 AND otchange<>22) let returnstatus=0
		IF (X2<>21 AND X2<>22) AND (otchange=21 OR otchange=22) let returnstatus=0
		IF (X2=7 OR X2=8) let returnstatus=0
		! any other lines exist and ot changed exceptions?
	Endif	
	if returnstatus=0 Let message$=message$+"Cannot change from order type "+Str$(OTChange)+". "
	OtChkDone: ! done
	if ch_pgp<>0
		Try Close #CH_PGP else Rem
	endif
	if returnstatus=0 let flag=1 ! found a problem
else
	Flag=1 ! a problem
end try
end sub ! OTypeProcess                                           
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
Sub GetInvHdr()
  Try
	! do not set returnstatus
	! load values into a section for the invoice 
	
	

	if custid<=0 or custid>999999
		let returnstatus=0
		let message$="Invalid Customer Code "
	Else
		let keycust$=custid using "######"
		search #ch_cust,2,1;keycust$,rec_cust,e
		if e<>0
			let returnstatus=0
			let message$="Customer Code "+str$(custid)+" Not On File"
		else
			read record #ch_cust,rec_cust,0;cust.;
			if refid<=0 or refid>99999999
				let returnstatus=0
				let message$="Invalid Reference Number"
			else
				let keyinvh$=" ",keyinvh$
				let keyinvh$[1,6]=custid using "######"
				let keyinvh$[7,16]=refid using "##########"
				Search #ch_invh,2,2;keyinvh$,rec_invh,e
				if e<>0
					if reftype ! try status/refid (possibly sent billto)
						keyinvh$=" ",keyinvh$
						keyinvh$[1,2]=Reftype using "##"
						keyinvh$[3,12]=refid using "##########"
						search #ch_invh,2,1;keyinvh$,rec_invh,e
						if e=0
							read record #ch_invh,rec_invh,0;invh.;
							read record #ch_invs,invh.shiprec,0;invs.;
							read record #ch_invt,invh.totrec,0;invt.;
						Else
							returnstatus=0
							let message$="Reference Number "+str$(refid)+" For Customer "+str$(custid)+" Not On File"
						Endif
					Else ! no reftype - try 30/31
						reftype=30
						keyinvh$=" ",keyinvh$
						keyinvh$[1,2]=Reftype using "##"
						keyinvh$[3,12]=refid using "##########"
						search #ch_invh,2,1;keyinvh$,rec_invh,e
						if e=0
							read record #ch_invh,rec_invh,0;invh.;
							read record #ch_invs,invh.shiprec,0;invs.;
							read record #ch_invt,invh.totrec,0;invt.;
						Else
							reftype=31
							keyinvh$=" ",keyinvh$
							keyinvh$[1,2]=Reftype using "##"
							keyinvh$[3,12]=refid using "##########"
							search #ch_invh,2,1;keyinvh$,rec_invh,e
							if e=0
								read record #ch_invh,rec_invh,0;invh.;
								read record #ch_invs,invh.shiprec,0;invs.;
								read record #ch_invt,invh.totrec,0;invt.;
							Else
								returnstatus=0
								let message$="Reference Number "+str$(refid)+" For Customer "+str$(custid)+" Not On File"
							Endif
						Endif
					Endif ! try based on reftype
				else
					read record #ch_invh,rec_invh,0;invh.;
					read record #ch_invs,invh.shiprec,0;invs.;
					read record #ch_invt,invh.totrec,0;invt.;
				endif
			endif
		endif
	endif

	Clear List$[]                                                         
	List$[0] = bsdel$ + "InvHdrAddr" + fdel$ ! section name
	webstr$="CustId",fdel$
	webstr$=webstr$+"BillName",fdel$
	webstr$=webstr$+"BillAddr1",fdel$
	webstr$=webstr$+"BillAddr2",fdel$
	webstr$=webstr$+"BillCity",fdel$
	webstr$=webstr$+"BillState",fdel$
	Webstr$=webstr$+"BillZip",fdel$
	webstr$=webstr$,"ShipCustId",fdel$
	webstr$=webstr$,"OrderId",fdel$
	webstr$=webstr$,"InvNum",fdel$
	webstr$=webstr$,"InvType",fdel$
	webstr$=webstr$,"ShipName",fdel$
	webstr$=webstr$,"ShipAddr1",fdel$
	webstr$=webstr$,"ShipAddr2",fdel$
	webstr$=webstr$,"ShipCity",fdel$
	webstr$=webstr$,"ShipState",fdel$
	webstr$=webstr$,"ShipZip",fdel$
	webstr$=webstr$,"Country",fdel$
	
	
	let list$[1]=webstr$
	if returnstatus<>0 ! no errors send over the data
		webstr$=str$(invh.custnum),fdel$
		Webstr$=webstr$+rtrim$(cust.name$),fdel$! bill to name
		Webstr$=webstr$+rtrim$(cust.addr1$),fdel$
		Webstr$=webstr$+rtrim$(cust.addr2$),fdel$
		Webstr$=webstr$+rtrim$(cust.city$),fdel$
		Webstr$=Webstr$+rtrim$(cust.state$),fdel$
		Webstr$=webstr$+rtrim$(cust.zip4$),fdel$
		tmp$=str$(invs.shipcust)
		IF invs.ShipEdit>=1 and invs.ShipEdit<5
			tmp$=tmp$,".",(invs.ShipCode using "&&&&&&")
		Endif
		webstr$=webstr$,tmp$,fdel$
		webstr$=webstr$,str$(invh.ordnum),fdel$
		webstr$=webstr$,str$(invh.invnum),fdel$
		let tmp$=""
		if invh.status=30 let tmp$="INV"
		if invh.status=31 let tmp$="C/M"
		Webstr$=webstr$,tmp$,fdel$
		webstr$=webstr$,rtrim$(invs.name$),fdel$
		webstr$=webstr$,rtrim$(invs.address$),fdel$
		webstr$=webstr$,rtrim$(invs.address2$),fdel$
		webstr$=webstr$,rtrim$(invs.city$),fdel$
		webstr$=webstr$,rtrim$(invs.state$),fdel$
		webstr$=webstr$,Rtrim$(invs.zipcode$),rtrim$(invs.zip4$),fdel$
		webstr$=webstr$,Rtrim$(invs.country$),fdel$
		list$[2]=webstr$
	 endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	clear list$[]
	List$[0] = bsdel$ + "InvHdrDetl" + fdel$ ! section name
	webstr$=""
	webstr$=webstr$,"Truck",fdel$
	webstr$=webstr$,"Zone",fdel$ ! zone
	! description of zone 
	webstr$=webstr$,"TaxCode",fdel$
	webstr$=webstr$,"TaxDesc",fdel$
	webstr$=webstr$,"TaxType",fdel$ 
	webstr$=webstr$,"TaxTypeDesc",fdel$
	! add to new
	webstr$=webstr$,"OrderDate",fdel$
	webstr$=webstr$,"BillToId",fdel$
	webstr$=webstr$,"PO",fdel$
	webstr$=webstr$,"Slsm",fdel$ ! sslsm
	! need slsm name
	webstr$=webstr$,"Terms",fdel$
	! need term desc
	webstr$=webstr$,"Attn",fdel$
	webstr$=webstr$,"ShipDate",fdel$
	webstr$=webstr$,"DEPT",fdel$
	webstr$=webstr$,"WH",fdel$
	webstr$=webstr$,"DueDate",fdel$
	webstr$=webstr$,"CMWeight",fdel$
	webstr$=webstr$,"ShipCMType",fdel$
	webstr$=webstr$,"Routing",fdel$
	webstr$=webstr$,"EnterBy",fdel$
	webstr$=webstr$,"StopNum",fdel$
	webstr$=webstr$,"OrdType",fdel$
	webstr$=webstr$,"Division",fdel$
	webstr$=webstr$,"Source",fdel$
	webstr$=webstr$,"SalesArea",fdel$
	webstr$=webstr$,"Dclvl",fdel$
	webstr$=webstr$,"OrgOrdNum",fdel$
	webstr$=webstr$,"InvCmDate",fdel$
	Webstr$=webstr$,"AcptDate",fdel$
	webstr$=webstr$,"ARMonth",fdel$
	webstr$=webstr$,"Journal",fdel$
	webstr$=webstr$,"GLJEFLAG",fdel$
	webstr$=webstr$,"TermsDesc",fdel$
	webstr$=webstr$,"SlsmName",fdel$
	webstr$=webstr$,"DeptName",fdel$
	webstr$=webstr$,"WhName",fdel$
	webstr$=webstr$,"ShipCMDesc",fdel$
	webstr$=webstr$,"EntByName",fdel$
	webstr$=webstr$,"ZoneName",fdel$
	webstr$=webstr$,"OrdTypeDesc",fdel$
	Webstr$=webstr$,"DivName",fdel$
	Webstr$=webstr$,"SourceName",fdel$
	Webstr$=webstr$,"SalesAreaName",fdel$
	Webstr$=webstr$,"LastPaidDate",fdel$
	webstr$=webstr$,"Picklist",fdel$
	webstr$=webstr$,"ORIGORDID",fdel$
	List$[1]=webstr$
	if returnstatus>0
		webstr$=""
		webstr$=webstr$,str$(invs.truck),fdel$
		webstr$=webstr$,rtrim$(invs.zone$),fdel$
		! description of zone
		webstr$=webstr$,str$(invh.taxcode),fdel$
		taxcoded$=gettaxcdd$(ch_tax,invh.TaxCode,intco)
		webstr$=webstr$,taxcoded$,fdel$
		webstr$=webstr$,str$(invs.shiptaxtype),fdel$ 
		custtaxtyped$=getcusttaxtyd$(ch_ctax,invs.shipTaxType,intco)
		webstr$=webstr$,custtaxtyped$,fdel$
		if invh.orddate<>0
			let xdate$=pdate$(invh.orddate)
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! order date 
		Webstr$=webstr$+invh.billto,fdel$
		WebStr$=WebStr$,RTrim$(invh.custpo$),fdel$ ! po#
		WebStr$=WebStr$,Str$(invh.slsmnum),fdel$ ! salesman number
		! slsm name
		Webstr$=webstr$,str$(invh.terms),fdel$ ! terms
		! terms desc	
		Webstr$=webstr$,(invh.contact$),fdel$ ! contact
		if invh.shipdate<>0
			if invh.shipdate<>999999
				let xdate$=pdate$(invh.shipdate)
			else
				let xdate$="999999"
			endif
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! ship date 
		Webstr$=WebStr$,str$(invh.dept),fdel$ ! department
		! dept name
		webstr$=webstr$,str$(invh.wh),fdel$ ! warehouse
		if invh.duedate
			let xdate$=pdate$(invh.duedate)
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! due date
		WebStr$=WebStr$,str$(invh.ActWgt),fdel$ ! act wgt
		webstr$=webstr$,str$(invh.ShipType),fdel$ ! as ship terms or cm type
		webstr$=webstr$,rtrim$(invh.shipvia$),fdel$
		webstr$=webstr$,str$(invh.EntBy),fdel$
		webstr$=webstr$,str$(invh.stopnum),fdel$
		webstr$=webstr$,str$(invh.OrdType),fdel$
		webstr$=webstr$,str$(invh.div),fdel$
		webstr$=webstr$,str$(invh.Source),fdel$
		webstr$=webstr$,str$(invh.salesarea),fdel$
		webstr$=webstr$,str$(invt.delivchrglvl),fdel$
		!WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! cm/inv date date	
		Webstr$=Webstr$,(invh.orgord1 using "########"),fdel$
		if invh.InvDate<>0
			let xdate$=pdate$(invh.InvDate)
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! cm/inv date date	
		LET tmp$=invt.acptdate USING "&&&&&&&&&" 
		let x3=tmp$[2,7] ! YYMMDD
		if x3<>0 
				let xdate$=pdate$(x3)
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! acpt date
		let x3=tmp$[8,9]
		webstr$=webstr$,(x3 using "##"),fdel$ ! acpt month
		webstr$=webstr$,(invt.arjrnl using "########"),fdel$ ! jrnl
		Webstr$=webstr$+ua2$[42,42]+fdel$
		!webstr$=webstr$,"TermsDesc",fdel$
		artermd$ = ""                                      
		If invh.terms > 0 And invh.terms <= 99               
			artermd$ = getartermd$(ch_terms,invh.terms,intco) 
		End If                                             
		WebStr$ = WebStr$,RTrim$(artermd$),FDEL$           
		!webstr$=webstr$,"SlsmName",fdel$
		slsmname$=""
		if invh.slsmnum>0 and invh.slsmnum<=999
			slsmname$ = getslsmname$(ch_sslsm,invh.slsmnum,intco)
		endif
		Webstr$= Webstr$,rtrim$(slsmname$),fdel$
		!!! start here
		!webstr$=webstr$,"DeptName",fdel$
		clear dept.
		IF invh.Dept>0 and invh.Dept<10000
			READ rECORD #ch_dept,invh.dept;dept.;
		endif
		webstr$=webstr$,rtrim$(dept.desc$),fdel$
		!webstr$=webstr$,"WhName",fdel$
		clear wh.
		if invh.wh>0 and invh.wh<=99
			Read Record #ch_wh,((invh.wh)-1);wh.;
		endif
		webstr$=webstr$,rtrim$(wh.WhName$),fdel$
		
		let shiptyped$=""
		If invh.status=30! invoice
			if invh.ShipType>0 and invh.shiptYPE<=16
				read #ctlc,107,((invh.shiptype*16)-16);shiptyped$;
			endif
		endif
		If invh.status=31! credit memo
			Try
				CMTChan=Findchannel()
				ROpen #CMTChan,"2/cmtype" + Str$(Intco) ! sep cmtype file
				if invh.ShipType>0 and invh.shiptYPE<=CHF(CMTCHAN)-1
					Read #CMTChan,invh.shiptype,0;shiptyped$;  ! only 16 chars
				Endif
				Close #CMTChan
			Else
				if invh.ShipType>0 and invh.shiptYPE<=16
					read #ctlc,48,((invh.shiptype*16)-16);shiptyped$;
				Endif
			End try		
		endif
		webstr$=webstr$,rtrim$(shiptyped$),fdel$
		
		!webstr$=webstr$,"ShipCMDesc",fdel$ !!!!! need this one mtg

		!webstr$=webstr$,"EntByName",fdel$
		clear et.
		if invh.entby>0 and invh.entby<=999
			Read Record #ch_et,invh.entby;et.;
		endif
		webstr$=webstr$,rtrim$(et.desc$),fdel$
		dirno=1
		mode$="="
		zonerec = FileGetZonefle(e$,Ch_Zone,mode$,dirno,invs.zone$,zn.)
		If zonerec < 0                                                 
			zn.desc$ = "Zone Not On File"                                
		End If                                                         
		WebStr$ = WebStr$ + rtrim$(zn.desc$) + FDEL$
		!webstr$=webstr$,"OrdTypeDesc",fdel$
		let ordtyped$=""
		if invh.ordtype>0 and invh.ordtype<=38
			ordtyped$ = getordtypd$(ctlc,invh.ordtype,intco)
		endif
		webstr$=webstr$,rtrim$(ordtyped$),fdel$
		!Webstr$=webstr$,"DivName",fdel$
		clear div.
		if invh.div>0 and invh.div<=99
			read record #ch_div,invh.div;div.;
		endif
		webstr$=webstr$,rtrim$(div.desc$),fdel$
		
		!Webstr$=webstr$,"SourceName",fdel$
		Clear os.
		if invh.Source>0 and invh.Source<=99
			read record #Ch_src,invh.source;os.;
		endif
		webstr$=webstr$+rtrim$(os.desc$),fdel$
		!!! start here - mtg
		!Webstr$=webstr$,"SalesAreaName",fdel$
		LET zndsc$="None"
		if invh.salesarea>0 and invh.salesarea<=10
			 ch_addon = OpenFile(-2832,intco) \ If ch_addon = -1 Error 42 ! delivery add on charge
			 let tmpkey$="     0"
			 search #ch_addon,2,1;tmpkey$,rec_tmp,e
			 if e<>0
				let zndsc$="Not on File"
			 else
				 read #ch_addon,(16+(invh.salesarea*10));zndsc$;
			endif
			try close #ch_addon  ELSE REM
		endif
		webstr$=webstr$,rtrim$(zndsc$),fdel$
		Let xdate$=""
		if invh.LastPayDate<>0 let xdate$=pdate$(invh.lastpaydate)
		!Webstr$=webstr$,"LastPaidDate",fdel$
		webstr$=webstr$+xdate$+fdel$
		let tmp$=""
		if invs.OnPickList$="2"
			let tmp$="On Picklist"
		endif
		webstr$=webstr$+tmp$+fdel$
		if invh.OrgOrd
			webstr$=webstr$,Str$(invh.OrgOrd),fdel$
		Else
			webstr$=webstr$,"",fdel$ ! None
		Endif
		!!! end here
		let list$[2]=webstr$
	endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
else
	include "src/callsuberr.inc"! ERROR 
end try
end sub !  getinvhdr
!-----------------------------------------------------------------------
Sub GetInvHMsg()
  Try
	! do not set returnstatus
	! load values into a section for the invoice 
	! invoice and customer info should have been
	Clear List$[]                                                         
	List$[0]=bsdel$,"InvoiceMessages",fdel$
	WebStr$="Message",fdel$
	WebStr$=Webstr$,"MessageTypeID",fdel$
	Webstr$=Webstr$,"MessageTypeDesc",fdel$
	List$[1]=WebStr$
	let ctr=2
	if returnstatus<>0
		let keyinvm$=" ",keyinvm$
		x3=invh.invnum \ if invh.status=31 let x3=invh.ordnum
		let keyinvm$=x3 using "##########"
		dir=1
		mode$=">"
		DO	! removes existing message lines
			rec_invm=filegetinvm(e$,ch_invm,mode$,dir,keyinvm$,invm.)
			if rec_invm<=0 exit do
			let tmp3=keyinvm$[1,10]\if tmp3<>x3 exit do
	                let msgtype=0 ! invoice
			if invm.messageline>200 and invm.messageline<401
				let msgtype=2 ! order
			endif
			if invm.messageline>400 and invm.messageline<601
				let msgtype=4 ! invoice/order
			endif
			if invm.messageline>600 and invm.messageline<801
				let msgtype=6 ! Bill of Lading
			endif
			if invm.messageline>800 and invm.messageline<1001
				let msgtype=8 ! Internal
			endif
			tmp$=clrtxtc$(e$,invm.message$) ! check/clear control chars
			WebStr$=RTrim$(tmp$),fdel$ ! invm.message$,fdel$
			WebStr$=Webstr$+str$(msgtype),fdel$
			let tmp$=rtrim$(msglist$[((msgtype*16)+1),((msgtype*16)+16)])
			Webstr$=Webstr$,tmp$,fdel$
			List$[ctr]=WebStr$
			let ctr=ctr+1
		loop
	endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	
else
	include "src/callsuberr.inc"! ERROR 
end try
end sub !  getinvmsg
!-----------------------------------------------------------------------
Sub GetInvHTot()
  Try
	! do not set returnstatus
	! load values into a section for the invoice 
	! invoice and customer info should have been
	Clear List$[]                                                         
	clear list$[]
	List$[0]=bsdel$,"InvoiceTotalDisp",fdel$
	WebStr$="InvoiceId",fdel$
	WebStr$=webstr$,"TotUnitsOrd",fdel$
	WebStr$=webstr$,"TotUnitsSell",fdel$
	WebStr$=webstr$,"TotWeight",fdel$
	WebStr$=Webstr$,"TotCubes",fdel$
	Webstr$=Webstr$,"Totcharge4prof",fdel$
	Webstr$=Webstr$,"Totcost4prof",fdel$
	Webstr$=webstr$,"HoldStatus",fdel$
	Webstr$=webstr$,"ShipDate",fdel$
	Webstr$=webstr$,"Zone",fdel$
	webstr$=webstr$,"ZoneDesc",fdel$
	webstr$=webstr$,"Subtotal",fdel$
	webstr$=webstr$,"TaxableMerch",fdel$
	webstr$=webstr$,"TaxableTotCharges",fdel$
	webstr$=webstr$,"TaxPct",Fdel$
	webstr$=webstr$,"TaxAmt",fdel$
	webstr$=webstr$,"TotShipMerchCost",fdel$
	webstr$=webstr$,"TotFrgtCost",fdel$
	webstr$=webstr$,"TotMiscCost",fdel$
	webstr$=webstr$,"TotFrgtAdd",fdel$
	webstr$=webstr$,"DelivChrgLvl",fdel$
	webstr$=webstr$,"LineTax",fdel$
	webstr$=webstr$,"TotInvAmt",fdel$
	webstr$=webstr$,"GPAmt",fdel$
	webstr$=webstr$,"GPPct",fdel$
	webstr$=webstr$,"DepositAmt",fdel$
	webstr$=webstr$,"TotGLMerchCost",fdel$
	List$[1]=WebStr$
	WebStr$=str$(invh.invnum),fdel$
	Webstr$=webstr$+RTrim$(invt.totordqty Using "----------.##") + fdel$   
	Webstr$=webstr$+RTrim$(invh.totsellunits Using "----------.##") + fdel$ 
	Webstr$=webstr$+RTrim$(invt.totwgt Using "----------.##") + fdel$ 
	Webstr$=webstr$+RTrim$(invt.totcubes Using "----------.##") + fdel$ 
	let amount=invh.totdol4prof 
	if p61$[136,136]="Y" and invl.currfact<>0 and amount<>0
		factor=invl.currfact
		call currconvup(amount,factor)
		let amount=fnr(amount)
	endif
	Webstr$=webstr$+RTrim$(amount Using "----------.##") + fdel$ ! invh.totdol4prof
	let amount=invh.totcost4prof
	if p61$[136,136]="Y" and invl.currfact<>0 and amount<>0
		factor=invl.currfact
		call currconvup(amount,factor)
		let amount=fnr(amount)
	endif
	Webstr$=webstr$+RTrim$( amount Using "----------.##") + fdel$ ! invh.totcost4prof
	if credit let invt.holdcode=0 ! no holds on credit
	if invh.ordtype=16 let invt.holdcode=0 ! no holds on whs xfer
	if invh.ordtype=37 let invt.holdcode=0 ! no hold EVAP ship
	If invt.holdcode<>0
		Webstr$=webstr$+"On Hold",fdel$
	else
		Webstr$=webstr$+" "+fdel$
	endif
	If invh.shipdate <> 999999                          
	  xdate$ = pdate$(invh.shipdate)                    
	Else                                               
	  xdate$ = "999999"                                
	End If                                                              
	Webstr$ = Webstr$,RTrim$(xdate$),fdel$ ! ship date 
	Webstr$=webstr$+invs.zone$,fdel$! zone
	dirno=1
	mode$="="
	zonerec = FileGetZonefle(e$,Ch_Zone,mode$,dirno,invs.zone$,zn.)
	If zonerec < 0                                               
		let zn.desc$="Zone Not On File"
	endif
	webstr$=webstr$+zn.desc$+fdel$
	let amount=invt.subtot
	if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fnr(amount)
		endif
	Webstr$=webstr$+RTrim$((amount) Using "----------.##") + fdel$ ! invt.subtot
    let amount=invt.taxmdseamt
	if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fnr(amount)
		endif
	Webstr$=webstr$+RTrim$((amount) Using "----------.##") + fdel$ ! invt.taxmdseamt
	let amount=invt.taxable-invt.taxmdseamt
	if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fnr(amount)
		endif
	Webstr$=webstr$+RTrim$((amount) Using "----------.##") + fdel$ ! invt.taxable-invt.taxmdseamt
	! 
	Webstr$=webstr$+RTrim$((invt.taxpct) Using "---.####%") + fdel$
	let amount=invt.taxamt
	if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fnr(amount)
		endif
	Webstr$=webstr$+RTrim$((amount) Using "----------.##") + fdel$ ! invt.taxamt
	! total cost ! need to check security
	let amount=invt.totshipcost
	if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fnr(amount)
		endif
	webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! invt.totshipcost
	let amount=invt.frgtcost
	if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fnr(amount)
		endif
	webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! invt.frgtcost
	let amount=invt.totmisccost
	if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fnr(amount)
		endif
	webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! invt.totmisccost
	let amount=invh.totfrgtadd
	if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fnr(amount)
		endif
	webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! invh.totfrgtadd
	Webstr$=webstr$+RTrim$(invt.delivchrglvl using "##")+fdel$
	let linetax=0
	if P60$[42,42]="Y" and invt.subtot<>0  ! tax by line
		linetax=invt.taxamt-invt.totchrgtax
	endif
	let amount=linetax
	if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fnr(amount)
		endif
	webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! linetax
	let amount=invt.OrdTot
	if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fnr(amount)
		endif
	webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! invt.OrdTot
	! check cost_lev
	if cost_lev[1]>0
		tmp3=invh.TotDol4Prof-invh.TotCost4Prof
		let amount=tmp3
		if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fnr(amount)
		endif
		webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! invh.TotDol4Prof-invh.TotCost4Prof
		let tmp3=0
		if invh.TotDol4Prof<>0
			let tmp3=(((invh.TotDol4Prof-invh.TotCost4Prof)/invh.TotDol4Prof)*100)
		endif
		webstr$=webstr$+rtrim$(tmp3 using "-----.##") +fdel$
	else
		webstr$=webstr$+""+ fdel$ ! gp amt
		webstr$=webstr$+""+ fdel$ ! gp %
	endif
	let depamt=0
	if p61$[94,94]="Y" and invh.status<>31 ! credit
		 ch_invd=findchannel()
		 let filename$="4/SORDDEPH"+STR$(INTCO)
		  Ropen #ch_invd,filename$
		! need to open the deposit file
		let keyinvd$=" ",keyinvd$
		let keyinvd$[1,6]=invh.custnum using "######"
		let keyinvd$[7,16]=invh.invnum using "##########"
		do
			search #ch_invd,3,1;keyinvd$,rec_invd,e
			if e<>0 exit do
			let tmp3=keyinvd$[1,6]\if tmp3<>invh.custnum exit do
			let tmp3=keyinvd$[7,16]\if tmp3<>invh.invnum exit do
			read record #ch_invd, rec_invd;invd.;
			let depamt=depamt+invd.ChkAmt
		loop
	endif
	!!! check if deposits are used
	if depamt<>0
		let amount=depamt
		if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fnr(amount)
		endif
		webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$	! depamt
	else
		webstr$=webstr$+""+fdel$
	endif
	if cost_lev[0]<>0 and invh.TotGlCost<>0
		let amount=invh.TotGlCost
		if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fnr(amount)
		endif
		let webstr$=webstr$+Rtrim$( amount Using "------------.##") + fdel$ ! invh.TotGlCost
	else
		let webstr$=webstr$+""+fdel$
	endif
	LIST$[2]=Webstr$
	
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	! salesman section
	! new data added relating to commservcrhg
	let comm_gp_dollars=0
	let comm_gp_prc=0
	let adj_sales=0
	if p61$[79,79]="Y"
		if invh.COMMSVGCHG
			adj_sales=invh.TotDol4Prof-(invh.TotDol4Prof*(invh.COMMSVGCHG/100))
			let comm_gp_dollars=invh.TotDol4Prof-invh.TotCost4Prof
			let comm_gp_dollars=comm_gp_dollars-(invh.TotDol4Prof*(invh.COMMSVGCHG/100))
			If ADJ_SALES let comm_gp_prc=(comm_gp_dollars/adj_sales)*100
			let comm_gp_prc=int(comm_gp_prc)
		end if
	end if
	clear list$[]
	List$[0]=bsdel$,"InvTotSlsmComm",fdel$
	webstr$="SlsmID",fdel$
	webstr$=webstr$,"SlsmName",fdel$
	webstr$=webstr$,"SlsmCommPct",fdel$
	webstr$=webstr$,"SlsmCommAmt",fdel$
	!if p61$[79,79]="Y" ! native conditional - web always send header
		webstr$=webstr$,"SlsmCommGPDol",fdel$
		webstr$=webstr$,"SlsmCommGPPct",fdel$
	!Else
	!Endif
	list$[1]=webstr$
	let dispcomm$="Y"
	IF SOURCE=231 OR SOURCE=221 OR SOURCE=223 OR SOURCE=251
		IF P9$[31,31]="N" let dispcomm$="N" ! OR P9$[45,45]="N"  let dispcomm$="N"
	endif
	if source>200 and source<209 ! order entry
		IF P9$[31,31]="N" let dispcomm$="N"
		! if P9$[45,45]="N"  let dispcomm$="N"
	endif
	!IF P9$[14,14]="N" let dispcomm$="N"
	if invh.ordtype=19 and invh.Ot19Comp=1 let dispcomm$="N" ! no comm ot19 partial
	if roh.ordtype=36 or (not(credit) and roh.ordtype=37) or (credit and roh.shiptype=16 and (roh.ordtype=37 or roh.ordtype=36)) ! evap - no display orders/inv
		if source>200 and source<239 let dispcomm$="N" ! ord/inv
		if source>249 let dispcomm$="N" ! cash sales
		if credit and roh.ShipType=16 let dispcomm$="N" ! curr mo EVAP credit
	Endif
	if dispcomm$="Y"
		if rec_uac>0 ! check user cntrl
			UCC = OpenFile(-9988, intCo)
			if ucc>=0! open user cntrl file
				mat read #ucc,rec_uac,386;ua5;
				let dispcomm$="N"
				if ua5[4]>0 and ua5[4]<1000 ! verify the salesman
					if ua5[4]=invh.slsmnum let dispcomm$="Y"
				endif
				if ua5[4]=1000 let dispcomm$="Y"
			endif
			try close #UCC Else Rem
		endif
	endif
	!if dispcomm$="Y" ! only if display commission is yes
	let row=2
	If INVH.Ordtype=19 And invh.Ot19Comp=1 goto BPCommd ! only show when complete
	for ctr=0 to 4 ! salesperson code
		if invh.slsm[ctr]<>0
			webstr$=Rtrim$(invh.slsm[ctr] Using "###") + fdel$
			let slsmname$=""	
			if invh.slsm[ctr]>0 and invh.slsm[ctr]<=999
				let slsmname$=getslsmname$(ch_sslsm,invh.slsm[ctr],intco)	
			endif
			webstr$=webstr$+rtrim$(slsmname$)+fdel$
			webstr$=webstr$+Rtrim$(invh.slsmpct[ctr] Using "###.##%") + fdel$
			! if invh.status=31 let invh.slsmcomm[ctr]=(0-invh.slsmcomm[ctr])
			let amount=invh.slsmcomm[ctr]
			if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fnr(amount)
			endif
			webstr$=webstr$+Rtrim$(amount using "--------#.##")+fdel$ ! invh.slsmcomm[ctr]
			if p61$[79,79]="Y" and invh.COMMSVGCHG
				let amount=comm_gp_dollars
				if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
					let factor=invh.currfact
					call currconvup(amount,factor)
					let amount=fnr(amount)
				endif
				webstr$=webstr$,LTrim$(amount USING "-----#.##"),fdel$ ! (comm_gp_dollars
				webstr$=webstr$,LTrim$(comm_gp_prc USING " ---#%"),fdel$
			Else
				webstr$=webstr$,"",fdel$,"",fdel$
			Endif
			let list$[row]=webstr$
			let row=row+1
		endif
	next ctr
	!endif ! dispcomm$="Y"
	BPCommd: ! bypass commiss display
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	! end salesman section
	!call programdump("/tmp/ordh5!","")
	! section for edit fields
	clear list$[]
	List$[0]=bsdel$,"InvTotalCharges",fdel$
	WebStr$="TaxCode",fdel$
	WebStr$=webstr$,"TaxDesc",fdel$
	Webstr$=webstr$,"FrgtChrg",fdel$
	Webstr$=webstr$,"OrdDisc",fdel$	
	Webstr$=webstr$,"Other",fdel$
	Webstr$=webstr$,"PrepaidFrgt",fdel$
	Webstr$=webstr$,"FrgtCost",fdel$
	webstr$=webstr$,"DispComm",fdel$ ! display commission
	webstr$=webstr$,"MiscCostSec",fdel$
	webstr$=webstr$,"FrtCostSec",fdel$
	let list$[1]=webstr$
	! edits fields
	Webstr$=str$(invh.taxcode),fdel$
	taxcoded$=gettaxcdd$(ch_tax,invh.TaxCode,intco)
	webstr$=webstr$,taxcoded$,fdel$
	amount=invt.frgtChrg
	if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fnr(amount)
		endif
	webstr$=webstr$ + Rtrim$(amount Using "----------.##") + fdel$ ! invt.frgtChrg
	amount=invt.orddisc 
	if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fnr(amount)
		endif
	webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! invt.orddisc 
	amount=invt.othchrg
	if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
			let factor=invh.currfact
			call currconvup(amount,factor)
			let amount=fnr(amount)
	endif 
	webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! invt.othchrg
	amount=invt.prepaidfrgt
	if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fnr(amount)
	endif
	webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! invt.prepaidfrgt
	amount=invt.frgtcost
	if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fnr(amount)
		endif
	webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ !invt.frgtcost
	! display commission
	let dispcomm$="Y"
	IF SOURCE=231 OR SOURCE=221 OR SOURCE=223 OR SOURCE=251
		IF P9$[31,31]="N" let dispcomm$="N" ! OR P9$[45,45]="N"  let dispcomm$="N"
	endif
	if source>200 and source<209 ! order entry
		IF P9$[31,31]="N" let dispcomm$="N"
		! if P9$[45,45]="N"  let dispcomm$="N"
	endif
	if source=239 and p9$[31,31]="N" let dispcomm$="N"
	!IF P9$[14,14]="N" let dispcomm$="N" 
	if invh.ordtype=19 and invh.Ot19Comp=1 let dispcomm$="N" ! no comm ot19 partial
	if (not(credit) and (roh.ordtype=36 or roh.ordtype=37)) or (credit and roh.shiptype=16 and (roh.ordtype=36 or roh.ordtype=37)) ! evap - no display orders/inv
		if source>200 and source<239 let dispcomm$="N" ! ord/inv
		if source>249 let dispcomm$="N" ! cash sales
		if credit and roh.ShipType=16 let dispcomm$="N" ! curr mo EVAP credit
	Endif
	if dispcomm$="Y"
		if rec_uac>0 ! check user cntrl
			UCC = OpenFile(-9988, intCo)
			if ucc>=0! open user cntrl file
				mat read #ucc,rec_uac,386;ua5;
				let dispcomm$="N"
				if ua5[4]>0 and ua5[4]<1000 ! verify the salesman
					if ua5[4]=invh.slsmnum let dispcomm$="Y"
				endif
				if ua5[4]=1000 let dispcomm$="Y"
				if ua5[4]<>0 ! verify the salesman
					if ua5[4]=invh.slsmnum let dispcomm$="Y"
				endif
			endif
			Try Close #UCC  Else Rem
		endif
	endif
	Webstr$=webstr$,dispcomm$,fdel$ ! display commission yes or no
	! misc cost security
	let tmp3=ua2$[18,18]
	if tmp3<0 let tmp3=0
	if tmp3>2 let tmp3=2
	if rtrim$(ua2$[18,18])="" let tmp3=2
	Webstr$=webstr$,str$(tmp3),fdel$
	! freight cost security
	let tmp3=ua2$[17,17]
	if tmp3<0 let tmp3=0
	if tmp3>2 let tmp3=2
	if rtrim$(ua2$[17,17])="" let tmp3=2
	Webstr$=webstr$,str$(tmp3),fdel$
	
	LIST$[2]=Webstr$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	clear list$[]
	List$[0]=bsdel$,"InvTotalMiscChrg",fdel$
	webstr$=""
	webstr$=webstr$,"MiscId",fdel$
	webstr$=webstr$,"MiscDesc",fdel$
	webstr$=webstr$,"MiscChrg",fdel$
	webstr$=webstr$,"MiscCost",fdel$
	webstr$=webstr$,"MiscTax",fdel$
	webstr$=webstr$,"MiscGP",fdel$ ! not edittable
	webstr$=webstr$,"MiscDel",fdel$ ! not edittable
	list$[1]=Webstr$
	webstr$=""
	row=2
	for ctr=0 to 9
		if invt.miscchrgcode[ctr]>0
			webstr$=Rtrim$(invt.miscchrgcode[ctr] Using "###") + fdel$
			let tmp$=""
			read record #ch_misc,invt.miscchrgcode[ctr];misc.;
			let tmp$=misc.desc$
			webstr$=webstr$+Rtrim$(tmp$)+fdel$
			amount=invt.mcharge[ctr,0]
			if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fnr(amount)
		endif
			webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! invt.mcharge[ctr,0]
			amount=invt.mcharge[ctr,1]
			if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fnr(amount)
			endif
			webstr$=webstr$+ Rtrim$(amount Using "----------.##") + fdel$ ! invt.mcharge[ctr,1]
			let tmp$="N"
			if invt.mctxbl[ctr]<>0 let tmp$="Y"
			webstr$=webstr$+tmp$+fdel$ ! tax
			let tmp$="N"
			if int(fra(invt.MiscChrgCode[ctr])*10) let tmp$="Y"
			webstr$=webstr$+tmp$+fdel$ ! gp
			let tmp$="N"
			IF INT(FRA(invt.MiscChrgCode[ctr]*10)*10)=9 let tmp$="Y"
			IF INT(FRA(invt.MiscChrgCode[ctr]*10)*10)=8 let tmp$="A"
			webstr$=webstr$+tmp$+fdel$ ! del charge
			list$[row]=webstr$
			let row=row+1
		endif
	next ctr
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
else
	include "src/callsuberr.inc"! ERROR 
end try
end sub !  getinvhtot
!-----------------------------------------------------------------------
Sub GetInvHCash()
  Try
	dim 1%,ch_ccc,tmpcnt
	dim 3%,rec_ccc,rec_invc
	dim CCTYPE$[100],keyccc$[50],keyinvc$[50]
	dim paytype$[60]
	!ReturnStatus=1
	!Message$="OK"
	! section 3 -- droplist type
	let paytype$=" ",paytype$
	! Enter type:  1: Cash,  2: Check,  3: Credit Card,  4: Other
	let paytype$[1]= "None        " ! none is not used for 
	let paytype$[13]="Cash        "
	let paytype$[25]="Check       "
	let paytype$[37]="Credit Card "
	let paytype$[49]="Other       "
	MAT  READ #ctlc,49,0;CCTYPE$;
	clear list$[]
	List$[0] = bsdel$,"PAYMENT",fdel$
	Webstr$=""
	Webstr$="PAYTYPE1",fdel$
	Webstr$=webstr$,"PAYTYPE1DESC",fdel$
	Webstr$=webstr$,"PAYAMT1",fdel$
	Webstr$=webstr$,"PAYACCT1",fdel$
	Webstr$=webstr$,"PAYDESC1",fdel$
	Webstr$=webstr$,"CCNAME1",fdel$
	Webstr$=webstr$,"CCADDR1",fdel$
	Webstr$=webstr$,"CCZIP1",fdel$
	webstr$=webstr$,"CCEXP1",fdel$
	webstr$=webstr$,"CCTYPE1",fdel$
	webstr$=webstr$,"CCTYPE1DESC",fdel$
	webstr$=webstr$,"CCAPPR1",fdel$
	webstr$=webstr$,"CCSWIPE1",fdel$
	webstr$=webstr$,"CCVERIF1",fdel$
	Webstr$=webstr$,"PAYTYPE2",fdel$
	Webstr$=webstr$,"PAYTYPE2DESC",fdel$
	Webstr$=webstr$,"PAYAMT2",fdel$
	Webstr$=webstr$,"PAYACCT2",fdel$
	Webstr$=webstr$,"PAYDESC2",fdel$
	Webstr$=webstr$,"CCNAME2",fdel$
	Webstr$=webstr$,"CCADDR2",fdel$
	Webstr$=webstr$,"CCZIP2",fdel$
	webstr$=webstr$,"CCEXP2",fdel$
	webstr$=webstr$,"CCTYPE2",fdel$
	webstr$=webstr$,"CCTYPE2DESC",fdel$
	webstr$=webstr$,"CCAPPR2",fdel$
	webstr$=webstr$,"CCSWIPE2",fdel$
	webstr$=webstr$,"CCVERIF2",fdel$
	webstr$=webstr$,"SOCSEC",fdel$
	webstr$=webstr$,"LICENSE",fdel$
	webstr$=webstr$,"LICEXP",fdel$
	webstr$=webstr$,"PAYNAME",fdel$
	webstr$=webstr$,"TRANSID",FDEL$ ! was PAYEMP
	webstr$=webstr$,"INVOICEAMT",FDEL$
	webstr$=webstr$,"DEPOSITAMT",FDEL$
	webstr$=webstr$,"BALANCE",FDEL$
	webstr$=webstr$,"INVOICEID",FDEL$
	webstr$=webstr$,"TERMDESC",fdel$
	webstr$=webstr$,"DOB",fdel$
	webstr$=webstr$,"CCTRTYPE1",fdel$
	webstr$=webstr$,"CCTRTYPE2",fdel$
    list$[1]=webstr$                          
	if returnstatus=0 goto EndInvHCash:

	if not(ch_invc)
		ch_invc = OpenFile(2704,IntCo) 
		If ch_invc = -1 
			let returnstatus=1
			!Message$="Order Cash File Not Found"
			goto EndInvHCash:
		endif
	endif
	let keyinvc$=invh.invnum using "##########"
	rec_invc = filegetsordcashh(e$,Ch_invc,"=",1,keyinvc$,invc.)
	if rec_invc>=0 ! exist
		
		webstr$=""
		webstr$=str$(int(invc.Paytype1)),fdel$ !PAYTYPE1
		if invc.paytype1<0 or  invc.paytype1 > 4 let invc.paytype1=0 ! set to none
		let ctr=int(invc.paytype1)
		webstr$=webstr$,rtrim$(PAYTYPE$[ctr*12+1,ctr*12+12]),fdel$ !PAYTYPE1DESC
		amount=invc.PayAmt1
		if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fnr(amount)
			endif
		webstr$=webstr$,str$(amount),fdel$ !"PAYAMT1 invc.PayAmt1)
		let tmp$=rtrim$(invc.Payacct1$) !PAYACCT1
		IF INT(invc.paytype1)=3                                     
			let tmp$=rtrim$(invc.payacct1$)
			if len(tmp$)>4
				for ctr=1 to (len(tmp$)-4)
					let tmp$[ctr,ctr]="*"
				next ctr
			endif
		endif
		webstr$=webstr$,rtrim$(tmp$),fdel$ ! payacct
		webstr$=webstr$,rtrim$(invc.PayDesc1$),fdel$ !PAYDESC1
		webstr$=webstr$,rtrim$(invc.CcName1$),fdel$ !CCNAME1
		webstr$=webstr$,rtrim$(invc.CcAddress1$),fdel$ !CCADDR1
		Webstr$=webstr$,rtrim$(invc.CCZip1$),fdel$ !CCZIP1
		let tmp$=""
		if invc.ccexp1<>0
			let tmp$=invc.ccexp1 using "&&&&&&"
			webstr$=webstr$,tmp$[1,2],"/",tmp$[3,6],fdel$ !CCEXP1
		else
			webstr$=webstr$,tmp$,fdel$ 
		endif
		webstr$=webstr$,str$(invc.CCType1),fdel$ !!CCTYPE1
		let tmp$=""
		if invc.cctype1>0 and invc.cctype1<=9
			let ctr=invc.cctype1
			tmp$=CCTYPE$[ctr*10-9,ctr*10]
		else
			invc.cctype1=0
			let tmp$="None"
		endif
		webstr$=webstr$,rtrim$(tmp$),fdel$  !CCTYPE1DESC
		!webstr$=webstr$,str$(invc.ccappr1),fdel$ ! approval # !CCAPPR1
		webstr$=webstr$,rtrim$(invc.authcode1$),fdel$ ! approval was invc.ccappr1
		tmp$="N"
		if (invc.CardSwipe1) let tmp$="Y"
		webstr$=webstr$,rtrim$(tmp$),fdel$ ! CCSWIPE1
		webstr$=webstr$,str$(invc.CcVerif1),fdel$ !CCVERIF1
		webstr$=webstr$,str$(int(invc.Paytype2)),fdel$!
		if invc.paytype2<0 or  invc.paytype2 > 4 let invc.paytype2=0 ! set to none
		let ctr=int(invc.paytype2)
		webstr$=webstr$,rtrim$(PAYTYPE$[ctr*12+1,ctr*12+12]),fdel$ !PAYTYPE2DESC
		amount=invc.PayAmt2
		if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fns(amount)
		endif
		webstr$=webstr$,str$(amount),fdel$ !PAYAMT2 invc.PayAmt2
		let tmp$=invc.payacct2$
		IF INT(invc.paytype2)=3                                     
			let tmp$=rtrim$(invc.payacct2$)
			if len(tmp$)>4
				for ctr=1 to (len(tmp$)-4)
					let tmp$[ctr,ctr]="*"
				next ctr
			endif
		endif
		webstr$=webstr$,rtrim$(tmp$),fdel$ ! PAYACCT2
		webstr$=webstr$,rtrim$(invc.PayDesc2$),fdel$
		webstr$=webstr$,rtrim$(invc.CcName2$),fdel$
		webstr$=webstr$,rtrim$(invc.CcAddress2$),fdel$
		Webstr$=webstr$,rtrim$(invc.CCZip2$),fdel$
		let tmp$=""
		if invc.ccexp2<>0
			let tmp$=invc.ccexp2 using "&&&&&&"
			webstr$=webstr$,tmp$[1,2],"/",tmp$[3,6],fdel$
		else
			webstr$=webstr$,tmp$,fdel$
		endif
		webstr$=webstr$,str$(invc.CCType2),fdel$
		let tmp$=""
		if invc.cctype2>0 and invc.cctype2<=9
			let ctr=invc.cctype2
			tmp$=CCTYPE$[ctr*10-9,ctr*10]
		else
			invc.cctype2=0
			let tmp$="None"
		endif
		webstr$=webstr$,rtrim$(tmp$),fdel$
		!webstr$=webstr$,str$(invc.ccappr2),fdel$ ! approval #
		webstr$=webstr$,rtrim$(invc.authcode2$),fdel$ 
		tmp$="N"
		if (invc.CardSwipe2) let tmp$="Y"
		webstr$=webstr$,rtrim$(tmp$),fdel$
		webstr$=webstr$,str$(invc.CcVerif2),fdel$
		webstr$=webstr$,str$(invc.SocSec),fdel$                                       
  		webstr$=webstr$,rtrim$(invc.license$),fdel$
		webstr$=webstr$,rtrim$(invc.Expire$),fdel$
		webstr$=webstr$,rtrim$(invc.payorname$),fdel$
		webstr$=webstr$,rtrim$(invc.transid$),fdel$
		amount=invt.OrdTot
		if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fns(amount)
		endif
		webstr$=webstr$,str$(amount),fdel$ ! invoice total invt.OrdTot
		amount=invt.DepTot
		if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fns(amount)
		endif
		webstr$=webstr$,str$(amount),fdel$ ! deposit total invt.DepTot
		tmp3=(invt.ordtot-invt.deptot-invc.PayAmt1-invc.PayAmt2)
		amount=tmp3
		if p61$[136,136]="Y" and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fns(amount)
		endif
		webstr$=webstr$,str$(amount),fdel$ ! (invt.ordtot-invt.deptot-invc.PayAmt1-invc.PayAmt2)
		webstr$=webstr$,str$(invc.invnum),fdel$
		artermd$=""
		If roh.terms > 0 And roh.terms <= 99              
			artermd$ = getartermd$(ch_terms,roh.terms,intco) 
		endif
		webstr$=webstr$,rtrim$(artermd$),fdel$
		if invc.birthday
			let xdate$=pdate$(invc.birthday)
			if invc.birthday>currdate and xdate$[7,8]="20"
				let xdate$[7,8]="19"
			endif
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! order date
		webstr$=webstr$,invc.CCAuthType$[1,1],fdel$
		webstr$=webstr$,invc.CCAuthType$[2,2],fdel$
		list$[2]=webstr$
	endif
	EndInvhCash: ! end of section 4
	Call AddToStr(e$,rstr$,List$[])  
    Call AddToStr(e$,rstr$,esdel$) ! end of section   
else
	include "src/callsuberr.inc"! ERROR 
end try
end sub !  getinvhcash     
!----------------------------------------
Sub CheckImages()
Try 
	Dim keyvar$[50],itype$[2],image$[255]
	!
	clear list$[]
	List$[0]=bsdel$,"Images",fdel$
	List$[1]="keyvar",fdel$,"type",fdel$
	row=2
	!
	itype$="DR"	! scanned delivery receipt
	mode=0		! just check for existance
	keyvar$[1,8]=invh.ordnum using "DR######"
	keyvar$[9,14]=invh.custnum using "######"
	tmp$=invh.orddate using "&&&&&&"
	Call DatetoJulian(1,tmp$,xdate$,e)
	if not(e) keyvar$[15,20]=Val(xdate$) using "######"	! julian orddate
	!
	Call GetImage(e$, intCo, IType$, mode, keyvar$, image$)
	!
	if image$
		list$[row]=keyvar$,fdel$,"Del Recpt",fdel$
		row=row+1
	end if
	!
	! add additional doc type here and add to list$ if needed
	!
	itype$="PD"	! scanned Picking Documents
	mode=0		! just check for existance
	keyvar$[1,8]=invh.ordnum using "PD######"
	keyvar$[9,14]=invh.custnum using "######"
	tmp$=invh.orddate using "&&&&&&"
	Call DatetoJulian(1,tmp$,xdate$,e)
	if not(e) keyvar$[15,20]=Val(xdate$) using "######"	! julian orddate
	!
	Call GetImage(e$, intCo, IType$, mode, keyvar$, image$)
	!
	if image$
		list$[row]=keyvar$,fdel$,"Pick Docs",fdel$
		row=row+1
	end if
	!                                                 
	!                                                 
	itype$ = "OS" ! scanned order source              
	mode = 0 ! just check for existance               
	keyvar$[1,8] = invh.ordnum using "OS######"       
	keyvar$[9] = ""                                   
	!                                                 
	call getimage(e$,intco,itype$,mode,keyvar$,image$)
	!                                                 
	if image$                                         
	  list$[row] = keyvar$,fdel$,"Order Src",fdel$    
	  row = row + 1                                   
	end if                                            
	!                                                 
	!
	Call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
else
	include "src/callsuberr.inc"! ERROR 
end try
end sub !  checkimage
!----------------------------------------
!!!! 
Sub GetCustInvHList() ! search based upon customer code
Try
	dim keyinvh2$[50],StKey$[50],2%,startdate,enddate,tmpdate,3%
	call dxget("CUSTID",tmp$)! do not set returnstatus
	let custid=tmp$
	if custid<=0 or custid>999999
		let returnstatus=0
		let message$="Invalid Customer Id"
	endif
	If custid<>prt.CashSaleCustNum
		 Custsec[0]=custid;custsec[1]=1 ! id & NO ALERT
		 call "custsec.dl4",Custsec[],ctlc,userid$,e$,rstr$
		 if custsec[0]=-1 ! not allowed
			returnstatus=0
			message$="You do not have access this customer"
			!goto ??
		Endif
	Endif
	startdate=0
	enddate=0
	call dxget("STARTDATE",tmp$)! do not set returnstatus
	let tmp3=tmp$
	if tmp3<>0
		 XDATE$ = formatdate2$(tmp$) ! from MM/DD/YYYY to
		 tmp3 = XDATE$[3,8]                      
		! convert to julian                             
		 XDATE$ = tmp3 Using "&&&&&&"            
		Call DateToJulian(1,XDATE$,XDATE$,errflag)      
		If errflag                                      
			ReturnStatus = 0                              
			message$ = "Invalid Start Date Entered"
		else
			let startdate=xdate$ ! save in julian format                              
		End If
	endif
	If startdate<>0
		call dxget("ENDDATE",tmp$)! do not set returnstatus
		let tmp3=tmp$
		if not(tmp3)
			let returnstatus=0
			let message$="Invalid Ending Date Entered"
		endif
		if tmp3<>0
			XDATE$ = formatdate2$(tmp$) ! from MM/DD/YYYY to
			tmp3 = XDATE$[3,8]                      
			! convert to julian                             
			 XDATE$ = tmp3 Using "&&&&&&"            
			Call DateToJulian(1,XDATE$,XDATE$,errflag)      
			If errflag                                      
				ReturnStatus = 0                              
				message$ = "Invalid Start Date Entered"
			else
				let enddate=xdate$ ! save in julian format                              
			End If
		endif
	endif
	call dxget("CURKEY",tmp$) ! for the more option
	STKey$=RTrim$(tmp$) ! will have leading space stripped!!?
	if stkey$="" goto Startscan ! 1st time in?
	ChkLenSt: ! SEARCH KEY IS DIR 2: CCCCCCIIIIIIIIII
		if len(stkey$)<16 ! add back in to begin
		  tmp$=" "+stkey$ ! 1 is ALWAYS Customer
		  stkey$=tmp$
		  goto chklenst
		Endif
		! ok now 12 - see if spaces in middle gone?
		x3=stkey$[1,6];x3[1]=stkey$[7,16] ! default - cust 6 / inv 10
		for x=16 to 7 step -1
			if stkey$[x,x]=" " ! found 1st space from end
				x3=stkey$[1,x] ! first #
				x3[1]=stkey$[x+1] ! second
				x=0 ! end loop
			Endif
			! if none after 6 - it's a full 6 digit # ! use as is
		Next x
		let stkey$[1,6]=x3 using "######"
		if x3[1]>0 let x3[1]=x3[1]+1 ! as its mode 6 - add 1 to start at last one sent
		let stkey$[7,16]=x3[1] using "##########" 
 	Startscan: ! do it
	clear list$[]
	List$[0]=bsdel$,"GridType",fdel$
	List$[1]="Grid",fdel$
	list$[2]="Y",fdel$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! load values into a section for the invoice 
	! invoice and customer info should have been
	Clear InvList$[] 
	!call getinvhlisthdr()! mtg
	clear InvList$[]
	InvList$[0]=bsdel$,"InvoiceHistList",fdel$
	WebStr$="Id",fdel$
	WebStr$=webstr$,"Status",fdel$
	WebStr$=webstr$,"OrderId",fdel$
	WebStr$=webstr$,"Date",fdel$
	WebStr$=Webstr$,"CustPO",fdel$
	Webstr$=Webstr$,"OrigOrdId",fdel$
	Webstr$=Webstr$,"Whse",fdel$
	Webstr$=webstr$,"Type",fdel$
	Webstr$=webstr$,"Amount",fdel$
	Webstr$=webstr$,"ShipName",fdel$
	webstr$=webstr$,"CustCode",fdel$
	InvList$[1]=WebStr$
	Maxrow=2000
	if returnstatus<>0
		let row=2
		let keyinvh2$[1,6]=custid using "######"
		let keyinvh2$[7,7]="z"
		IF RTrim$(stkey$)<>"" let keyinvh2$=stkey$[1,16] ! pick up search
		do
			search #ch_invh,6,2;keyinvh2$,rec_invh,e ! search backwork
			if e<>0 exit do
			let tmp3=keyinvh2$[1,6]
			if tmp3<>custid exit do
			read record #ch_invh,rec_invh,0;invh.;
			read record #ch_invs,invh.shiprec,0;invs.;
			read record #ch_invt,invh.totrec,0;invt.;
			if startdate>0
				XDATE$ = invh.invdate Using "&&&&&&"            
				Call DateToJulian(1,XDATE$,XDATE$,errflag)
				if errflag goto getnxtcustinvh:
				let tmpdate=xdate$
				if tmpdate<startdate goto getnxtcustinvh:
				if tmpdate>enddate goto getnxtcustinvh:
			endif
			custid=invh.custnum
			refid=invh.invnum
			reftype=invh.status
			if reftype=31 let refid=invh.ordnum
			If custid<>prt.CashSaleCustNum
			 Custsec[0]=custid;custsec[1]=1 ! id & NO ALERT
			 call "custsec.dl4",Custsec[],ctlc,userid$,e$,rstr$
			 if custsec[0]=-1 ! not allowed
				!returnstatus=0
				!message$="You do not have access this customer"
				goto getnxtcustinvh
			 Endif
			Endif ! don't check on cash cust or cash sales
			!call getinvhlistdet()
			webstr$=""
			If invh.status<>31 ! not a credit memo
				webstr$=(invh.invnum using "##########")+fdel$
			else
				webstr$=(invh.ordnum using "##########")+fdel$
			endif
			tmp$=""
			if invh.status=30 let tmp$="INV"
			if invh.status=31 let tmp$="C/M"
			webstr$=webstr$+tmp$+fdel$
			if invh.status<>31 ! not a credit memo
				webstr$=webstr$+(invh.ordnum using "##########")+fdel$
			else
				webstr$=webstr$+(invh.invnum using "##########")+fdel$
			endif
			Xdate$=""
			iF invh.InvDate<>0     
				 xdate$ = pdate$(invh.InvDate)
			endif                         
			webstr$=webstr$+xdate$+fdel$
			webstr$=webstr$+rtrim$(invh.custpo$)+fdel$
			webstr$=webstr$+rtrim$(invh.orgord using "######")+fdel$
			webstr$=webstr$+rtrim$(invh.wh using "##")+fdel$
			ordtyped$ = getordtypd$(ctlc,invh.ordtype,intco)
			webstr$=webstr$+rtrim$(ordtyped$)+fdel$
			let amount=invt.ordtot
			if p61$[136,136]="Y"  and invh.currfact<>0 and amount<>0
				let factor=invh.currfact
				call currconvup(amount,factor)
				let amount=fns(amount)
			endif
			webstr$=webstr$+str$(amount)+fdel$ !invt.ordtot
			webstr$=webstr$+rtrim$(invs.name$)+fdel$
			webstr$=webstr$+str$(invh.custnum)+fdel$
			if row>maxrow+1 ! ALLOW FOR HEADER & this line
				returnstatus=5 ! special status to tell web MORE TO COME
				message$="CURKEY="+keyinvh2$+"&"
				exit do ! reached limit
			Endif
			let invlist$[row]=webstr$
			let row=row+1
			If row > tmpcnt Let tmpcnt = expandarray(e$,invList$[])
			getnxtcustinvh: ! 
		Loop
		if row=2
			let returnstatus=0
			let message$="No Transactions Found for Customer "+str$(custid)
		endif
	endif
	call AddToStr(e$,rstr$,Invlist$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section
else
	include "src/callsuberr.inc"! rem 
end try
end sub ! getcustinvhlist
!!!!
!!!---------------------------------------------------------------------------------------------------
Sub GetInvRefId()  ! 
! search option I - get based upon reference #
Try
	dim keyinvh1$[50]
	dim 3%,invctr
	call dxget("REFID",tmp$)! do not set returnstatus
	let refid=tmp$
	if refid<=0 or refid>99999999
		let returnstatus=0
		let message$="Invalid Reference Id"
	endif
	! load values into a section for the invoice 
	! invoice and customer info should have been
	Clear InvList$[] 
	invctr=0
	call getinvhlisthdr()! mtg

	if returnstatus<>0
		let row=2
		For ctr=30 to 31
			let keyinvh1$[1,2]=ctr using "##"
			LET kEYINVH1$[3]=refid USING "##########"
			search #ch_invh,2,1;keyinvh1$,rec_invh,e
			if not(e)
				read record #ch_invh,rec_invh,0;invh.;
				read record #ch_invs,invh.shiprec,0;invs.;
				read record #ch_invt,invh.totrec,0;invt.;
				custid=invh.custnum
				refid=invh.invnum
				reftype=invh.status
				if reftype=31 let refid=invh.Ordnum
				If custid<>prt.CashSaleCustNum
				 Custsec[0]=custid;custsec[1]=1 ! id & NO ALERT
				 call "custsec.dl4",Custsec[],ctlc,userid$,e$,rstr$
				 if custsec[0]=-1 ! not allowed
					returnstatus=0
					message$="You do not have access this customer"
					goto NICDone
				 Endif
				Endif ! don't check on cash cust or cash sales
				call getinvhlistdet()
				invctr=invctr+1
			NICDone: ! skip not accessible
			endif
		next ctr
		if row=2 ! and returnstatus<>0
			let returnstatus=0
			let message$="Transaction "+STR$(REFID)+" Not Found."
			if custsec[0]=-1 let message$="You do not have access this customer"
		endif
	endif
	clear list$[]
	List$[0]=bsdel$,"GridType",fdel$
	List$[1]="Grid",fdel$
	if invctr=1! 
		let list$[2]="N",FDEL$
	else
		list$[2]="Y",FDEL$
	endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	if invctr<>1
		call AddToStr(e$,rstr$,Invlist$[]) ! "add the list from subs to string
		Call AddToStr(e$,rstr$,esdel$) ! end of section
	else
		! start getting the invoice detail only 1 found
		call getinvhdr()   ! get the invoice header
		Call getinvhlines()! get the invoice lines
		Call getinvhmsg()  ! get the invoice message
		Call getinvhtot()  ! get the invoice total
		Call getinvhcash() ! get the invoice cash screen
	endif
else
	include "src/callsuberr.inc"! rem 
end try
End sub !GetInvRefId 
!!!---------------------------------------------------------------------------------------------------
Sub GetOrdRefId() ! search option O- get based upon order number #
Try
	dim keyinvk$[50]
	dim 3%,invctr
	call dxget("REFID",tmp$)! do not set returnstatus
	let refid=tmp$
	if refid<=0 or refid>999999
		let returnstatus=0
		let message$="Invalid Order Id"
	endif
		! load values into a section for the invoice 
	! invoice and customer info should have been
	Clear InvList$[]
	orderid=refid ! refid will get set to use for single item
	invctr=0
	call getinvhlisthdr()! mtg
	if returnstatus<>0
		let row=2
		let keyinvk$[1,6]=orderid using "######"
		Do
			Search #ch_invk,3,3;keyinvk$,rec_invh,e
			if e<>0 exit do
			tmp3=keyinvk$[1,6]\if tmp3<>orderid exit do
			read record #ch_invh,rec_invh,0;invh.;
			read record #ch_invs,invh.shiprec,0;invs.;
			read record #ch_invt,invh.totrec,0;invt.;
			custid=invh.custnum
			refid=invh.invnum
			reftype=invh.status
			if reftype=31 let refid=invh.ordnum
			If custid<>prt.CashSaleCustNum
			 Custsec[0]=custid;custsec[1]=1 ! id & NO ALERT
			 call "custsec.dl4",Custsec[],ctlc,userid$,e$,rstr$
			 if custsec[0]=-1 ! not allowed
				returnstatus=0
				message$="You do not have access this customer"
				goto SkpInv
			 Endif
			Endif ! don't check on cash cust or cash sales			
			call getinvhlistdet()
			invctr=invctr+1
			SkpInv: ! skip this one
		Loop
		if row=2
			let returnstatus=0
			let message$="Transaction for Order Number "+STR$(orderID)+" Not Found."
			if custsec[0]=-1 let message$="You do not have access this customer"
		endif
	endif
	clear list$[]
	List$[0]=bsdel$,"GridType",fdel$
	List$[1]="Grid",fdel$
	if invctr=1! 
		let list$[2]="N",FDEL$
	else
		list$[2]="Y",FDEL$
	endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	if invctr<>1
		call AddToStr(e$,rstr$,Invlist$[]) ! "add the list from subs to string
		Call AddToStr(e$,rstr$,esdel$) ! end of section
	else
		! start getting the invoice detail only one found
		call getinvhdr()   ! get the invoice header
		Call getinvhlines()! get the invoice lines
		Call getinvhmsg()  ! get the invoice message
		Call getinvhtot()  ! get the invoice total
		Call getinvhcash() ! get the invoice cash screen
	endif
else
	include "src/callsuberr.inc" ! rem 
end try
end sub !GetOrdRefId 
!!!---------------------------------------------------------------------------------------------------
Sub GetOrdOrgId() ! search option O- get based upon order number #
Try
	dim keyinvk$[50]
	dim 3%,invctr
	call dxget("REFID",tmp$)! do not set returnstatus
	let refid=tmp$
	if refid<=0 or refid>999999
		let returnstatus=0
		let message$="Invalid Order Id"
	endif
	orderid=refid ! refid will get set to use for single item
		! load values into a section for the invoice 
	! invoice and customer info should have been
	Clear InvList$[] 
	invctr=0
	call getinvhlisthdr()! mtg
	if returnstatus<>0
		let row=2
		let keyinvk$[1,10]=orderid using "##########"
		Do
			Search #ch_invk,3,4;keyinvk$,rec_invh,e
			if e<>0 exit do
			tmp3=keyinvk$[1,10]\if tmp3<>orderid exit do
			read record #ch_invh,rec_invh,0;invh.;
			read record #ch_invs,invh.shiprec,0;invs.;
			read record #ch_invt,invh.totrec,0;invt.;
			custid=invh.custnum
			refid=invh.invnum
			reftype=invh.status
			if reftype=31 let refid=invh.ordnum
			If custid<>prt.CashSaleCustNum
			 Custsec[0]=custid;custsec[1]=1 ! id & NO ALERT
			 call "custsec.dl4",Custsec[],ctlc,userid$,e$,rstr$
			 if custsec[0]=-1 ! not allowed
				returnstatus=0
				message$="You do not have access this customer"
				goto SkpInv2
			 Endif
			Endif ! don't check on cash cust or cash sales		
			call getinvhlistdet()
			invctr=invctr+1
			SkpInv2: ! skip it
		Loop
		if row=2
			let returnstatus=0
			let message$="Transaction for Original Order Number "+STR$(OrderID)+" Not Found."
		endif
	endif
	clear list$[]
	List$[0]=bsdel$,"GridType",fdel$
	List$[1]="Grid",fdel$
	if invctr=1! 
		let list$[2]="N",FDEL$
	else
		list$[2]="Y",FDEL$
	endif
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	if invctr<>1
		call AddToStr(e$,rstr$,Invlist$[]) ! "add the list from subs to string
		Call AddToStr(e$,rstr$,esdel$) ! end of section
	else
		! start getting the invoice detail only one found
		call getinvhdr()   ! get the invoice header
		Call getinvhlines()! get the invoice lines
		Call getinvhmsg()  ! get the invoice message
		Call getinvhtot()  ! get the invoice total
		Call getinvhcash() ! get the invoice cash screen
	endif
else
	include "src/callsuberr.inc" ! rem 
end try
end sub !GetOrdOrgId 
! ----------------------------------------------------------------------------------------
Sub getinvhlisthdr()
Try
	clear InvList$[]
	InvList$[0]=bsdel$,"InvoiceHistList",fdel$
	WebStr$="Id",fdel$
	WebStr$=webstr$,"Status",fdel$
	WebStr$=webstr$,"OrderId",fdel$
	WebStr$=webstr$,"Date",fdel$
	WebStr$=Webstr$,"CustPO",fdel$
	Webstr$=Webstr$,"OrigOrdId",fdel$
	Webstr$=Webstr$,"Whse",fdel$
	Webstr$=webstr$,"Type",fdel$
	Webstr$=webstr$,"Amount",fdel$
	Webstr$=webstr$,"ShipName",fdel$
	webstr$=webstr$,"CustCode",fdel$
	InvList$[1]=WebStr$
else
	include "src/callsuberr.inc" ! rem !
end try
end sub !exit sub
! -----------------------------------------------------------------------------------------
Sub getinvhlistdet()
Try
	webstr$=""
	If invh.status<>31 ! not a credit memo
		webstr$=(invh.invnum using "##########")+fdel$
	else
		webstr$=(invh.ordnum using "##########")+fdel$
	endif
	tmp$=""
	if invh.status=30 let tmp$="INV"
	if invh.status=31 let tmp$="C/M"
	webstr$=webstr$+tmp$+fdel$
	if invh.status<>31 ! not a credit memo
		webstr$=webstr$+(invh.ordnum using "##########")+fdel$
	else
		webstr$=webstr$+(invh.invnum using "##########")+fdel$
	endif
	Xdate$=""
	iF invh.InvDate<>0     
		 xdate$ = pdate$(invh.InvDate)
	endif                         
	webstr$=webstr$+xdate$+fdel$
	webstr$=webstr$+rtrim$(invh.custpo$)+fdel$
	webstr$=webstr$+rtrim$(invh.orgord using "######")+fdel$
	webstr$=webstr$+rtrim$(invh.wh using "##")+fdel$
	ordtyped$ = getordtypd$(ctlc,invh.ordtype,intco)
	webstr$=webstr$+rtrim$(ordtyped$)+fdel$
	let amount=invt.ordtot
	if p61$[136,136]="Y"  and invh.currfact<>0 and amount<>0
		let factor=invh.currfact
		call currconvup(amount,factor)
		let amount=fns(amount)
	endif
	webstr$=webstr$+str$(amount)+fdel$ ! invt.ordtot
	webstr$=webstr$+rtrim$(invs.name$)+fdel$
	webstr$=webstr$+str$(invh.custnum)+fdel$
	let invlist$[row]=webstr$
	let row=row+1
	If row > tmpcnt Let tmpcnt = expandarray(e$,invList$[])
else
	include "src/callsuberr.inc" !
end try
end sub ! GetInvhListdet
!------------------------------------------------------------------
Sub GetInvHLines()
Try
	dim kcm$[4],sum$[4],pum$[4],cum$[4]
	dim 3%,cmr,prr
	clear list$[]
	List$[0] = bsdel$,"LINEDETAIL",fdel$                                  
	WebStr$ = "ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$                  
	WebStr$ = WebStr$,"UnitPrice",fdel$,"PriceUpchrg",fdel$               
	WebStr$ = WebStr$,"PriceUpType",fdel$,"Whse",fdel$
	WebStr$ = WebStr$,"NetPrice",fdel$,"PriceUM",fdel$,"PriceUMID",fdel$  
	WebStr$ = WebStr$,"QtyOrder",fdel$,"QtyUM",fdel$,"QtyUMID",fdel$      
	WebStr$ = WebStr$,"UnitCost",fdel$,"CostSecurity",fdel$               
	WebStr$ = WebStr$,"CostUM",fdel$,"CostUMID",fdel$,"CostUpchrg",fdel$  
	WebStr$ = WebStr$,"CostUpType",fdel$,"ExtCost",fdel$                  
	WebStr$ = WebStr$,"ExtPrice",fdel$,"GP%",fdel$   
	WebStr$ = WebStr$,"Comm/Desc",fdel$,"QtyBO",fdel$                     
	WebStr$ = WebStr$,"PrevShip",fdel$,"QtyShip",fdel$ 
	WebStr$ = WebStr$,"Tax",fdel$                           
	WebStr$ = WebStr$,"SPPRContract",fdel$             
	WebStr$ = WebStr$,"RebateContract",fdel$,"Dept",fdel$                 
	WebStr$ = WebStr$,"Weight",fdel$,"WgtFactor",fdel$,"WgtUM",fdel$      
	WebStr$ = WebStr$,"ExtWgt",fdel$,"VendorItem",fdel$                   
	WebStr$ = WebStr$,"Cube",fdel$,"CubeFactor",fdel$,"CubeUM",fdel$      
	WebStr$ = WebStr$,"ExtCube",fdel$,"LineDisc%",fdel$                   
	WebStr$ = WebStr$,"LineNum",fdel$,"NewPermPrc",fdel$
	WebStr$ = WebStr$,"LTYPE",fdel$
	WebStr$ = WebStr$,"orgprodid",fdel$
	WebStr$ = WebStr$,"altsub",fdel$
	WebStr$ = WebStr$,"VendName",fdel$
	WebStr$ = WebStr$,"MSDS",fdel$
	WebStr$ = WebStr$,"WhseName",fdel$
	Webstr$ = Webstr$,"Pack",fdel$
	Webstr$ = Webstr$,"StckUpd",fdel$
	Webstr$ = Webstr$,"TaxRate",fdel$
	Webstr$ = Webstr$,"PrintFlag",fdel$
	Webstr$ = Webstr$,"PrintDate",fdel$
	Webstr$ = Webstr$,"Time",fdel$
	Webstr$ = Webstr$,"DeptName",fdel$
	Webstr$ = Webstr$,"SerialNo",fdel$
	webstr$=webstr$,"GLCOST",fdel$,"EXTGLCOST",fdel$
	webstr$=webstr$,"KIT",fdel$,"HILIGHTPID",fdel$
	webstr$=webstr$,"CURRBILL",fdel$,"PREVBILL",fdel$
	webstr$=webstr$,"POID",fdel$ ! task#22554
	webstr$=webstr$,"NOTES",fdel$ ! task#40331
	! Webstr$ = Webstr$,"NetCost",fdel$
	List$[1] = WebStr$                
	row = 2;tmpcnt = maxcnt
	If returnstatus<>0
		let keyinvl$=refid using "##########"
		Do
			Search #ch_invl,3,1;keyinvl$,rec_invl,e
			if e<>0 exit do
			let tmp3=keyinvl$[1,10]\if tmp3<>refid exit do
			Read Record #ch_invl,rec_invl,0;invl.;
			NonStk = invl.NStkItem                                   
			ZLine = 0 \ If invl.LineType = 3 And NonStk Let ZLine = 1
			clear pr.
			if custom_customer$<>"ZEPHYR" If Not(NonStk) ! it's a prod (zephyr may have deleted!)
				PRR = invl.PDRecNum   
				Read Record #Ch_prod,PRR,0;PR.;
			endif
			LineNo = invl.LineNum  
			Call setprtoinvl()  
			KCM$=" ",KCM$
			KCM$=invl.ComdtyCode$+Blank$[1,4];kcm$[5]=""
			CMR=filegetcommhead(e$, Ch_comcde,"=",1,KCM$,cmc.)
			If CMR<1 Clear cmc.
			If invl.LineType<>3 ! ZLINE
				SUM$=xunit$(invl.UMSell,ch_ccode) ! u/m
				PUM$=xunit$(invl.UMPrice,ch_ccode) ! u/m
				CUM$=xunit$(invl.UMCost,ch_ccode) ! u/m
			endif
			WebStr$=invl.ProdCode$,fdel$,RTrim$(invl.Desc1$),fdel$ ! prod code & desc 1
			WebStr$=WebStr$,RTrim$(invl.Desc2$),fdel$
			cnvtu[0]=0;cnvtu[1]=invl.UMPrice;cnvtu[2]=2
			Cnvta=invl.UnitPrice
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			if p61$[136,136]="Y"  and invl.currfact<>0 and amount<>0
				factor=invl.currfact
				let amount=x3
				call currconvup(amount,factor)
				let x3=fns(amount)
			endif
			WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! Unit price
			! send upcharge as amount & type
			tmp$="%" \ if invl.UpChrg<0 let tmp$="$"
			Let X3=invl.UpChrg
			If tmp$="$" ! need convert to price um
				cnvtu[0]=0;cnvtu[1]=invl.UMPrice;cnvtu[2]=2
				Cnvta=ABS(X3)
				X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				if p61$[136,136]="Y" and invl.currfact<>0 and amount<>0
					 factor=invl.currfact
					let amount=x3
					call currconvup(amount,factor)
					let x3=fns(amount)
				endif
			Endif
			WebStr$=WebStr$,Ltrim$(X3 Using PMask$),fdel$,tmp$,fdel$ ! upchrg & type
			WebStr$=WebStr$,Str$(invl.Whse),fdel$ ! warehouse
			cnvtu[0]=0;cnvtu[1]=invl.UMPrice;cnvtu[2]=2
			Cnvta=invl.NetPrice
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			if p61$[136,136]="Y"  and invl.currfact<>0 and amount<>0
				factor=invl.currfact
				let amount=x3
				call currconvup(amount,factor)
				let x3=fns(amount)
			endif
			WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! net price
			WebStr$=WebStr$,RTrim$(PUM$),fdel$,Str$(invl.UMPrice),fdel$ ! price um & id
			cnvtu[0]=0;cnvtu[1]=invl.UMSell;cnvtu[2]=1
			Cnvta=invl.QtyOrd
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! Qty Ord
			WebStr$=WebStr$,RTrim$(SUM$),fdel$,Str$(invl.UMSell),fdel$ ! sell um & id
			cnvtu[0]=0;cnvtu[1]=invl.UMCost;cnvtu[2]=2
			Cnvta=invl.UnitCost
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			if p61$[136,136]="Y" and invl.currfact<>0 and amount<>0
				factor=invl.currfact
				let amount=x3
				call currconvup(amount,factor)
				let x3=fns(amount)
			endif
			if cost_lev[1]
			WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! unit cost
			else
				WebStr$=WebStr$,fdel$
			Endif
			WebStr$=WebStr$,Str$(Cost_Lev[1]),fdel$ ! load cost security
			WebStr$=WebStr$,RTrim$(CUM$),fdel$,Str$(invl.UMCost),fdel$ ! Cost um & id
			! send upcharge as amount & type
			tmp$="%" \ if invl.LoadUpchrg<0 let tmp$="$"
			Let X3=invl.LoadUpchrg
			If tmp$="$" ! need convert to cost um
				cnvtu[0]=0;cnvtu[1]=invl.UMCost;cnvtu[2]=2
				Cnvta=ABS(X3)
				X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				if p61$[136,136]="Y" and invl.currfact<>0 and amount<>0
					factor=invl.currfact
					let amount=x3
					call currconvup(amount,factor)
					let x3=fns(amount)
				endif
			Endif
			if cost_lev[1]
			WebStr$=WebStr$,Ltrim$(X3 Using PMask$),fdel$,tmp$,fdel$ ! upchrg & type
			else
				WebStr$=WebStr$,fdel$,fdel$
			endif
			X3[3]=invl.UnitCost
			IF invl.LoadUpchrg ! has cost up
				IF invl.LoadUpchrg<0 ! $ amount
					X3[3]=invl.UnitCost+Abs(invl.LoadUpchrg)
				Else ! percent
					X3[3]=invl.UnitCost+(invl.UnitCost*(invl.LoadUpchrg/100))
				Endif
			Endif
			X3=round((invl.QtyShip*X3[3]),2) ! ext net cost
			if cost_lev[1]
				if p61$[136,136]="Y" and invl.currfact<>0 and amount<>0
					factor=invl.currfact
					let amount=x3
					call currconvup(amount,factor)
					let x3=fns(amount)
				endif
				WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! net cost exten
			else
				WebStr$=WebStr$,fdel$
			endif
			invl.ExtLoadShip=X3
			invl.ExtShipAmt=round((invl.QtyShip*invl.NetPrice),2) ! ext price
			Let X3=invl.ExtShipAmt
			if p61$[136,136]="Y" and invl.currfact<>0 and amount<>0
				factor=invl.currfact
				let amount=x3
				call currconvup(amount,factor)
				let x3=fns(amount)
			endif
			WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! net price exten
			x3=0
			if invl.NetPrice ! NEEDS A PRICE
				X3=round((((invl.NetPrice-x3[3])/invl.NetPrice)*100),2)
			Endif
			if cost_lev[1]
				if p61$[136,136]="Y" and invl.currfact<>0 and amount<>0
					factor=invl.currfact
					let amount=x3
					call currconvup(amount,factor)
					let x3=fns(amount)
				endif
				WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! GP
			else
				WebStr$=WebStr$,fdel$
			Endif
			WebStr$=WebStr$,invl.ComdtyCode$," ",RTRIM$(CMC.CodeDescription$),fdel$ ! commod & desc
			cnvtu[0]=0;cnvtu[1]=invl.UMSell;cnvtu[2]=1
			Cnvta=invl.QtyBO
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! Qty BO
			cnvtu[0]=0;cnvtu[1]=invl.UMSell;cnvtu[2]=1
			Cnvta=invl.PrevQtyShip
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! Qty Prev shipped
			cnvtu[0]=0;cnvtu[1]=invl.UMSell;cnvtu[2]=1
			Cnvta=invl.QtyShip
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! Qty Ship
			If P60$[42,42]<>"Y" ! NOT tax by line - so it's y/n only
				tmp$="N" \ if invl.TaxFlg let tmp$="Y"
				WebStr$=WebStr$,tmp$,fdel$ ! tax flag
			Else ! it's a tax code
				WebStr$=WebStr$,Str$(invl.TaxFlg),fdel$ ! tax code
			Endif
			WebStr$=WebStr$,Str$(invl.Contract),fdel$ ! sp contract
			WebStr$=WebStr$,Str$(invl.RebtContract),fdel$ ! rbt contract
			WebStr$=WebStr$,Str$(invl.Dept),fdel$ ! dept
			WebStr$=WebStr$,LTrim$(invl.LbsUnit Using PMask$),fdel$ ! wgt unit
			tmp$=Str$(invl.WgtFactor)
			call factorum(tmp$) ! get um for factor
			WebStr$=WebStr$,Str$(invl.WgtFactor),fdel$,Rtrim$(tmp$),fdel$ ! wgt factor & um
			WebStr$=WebStr$,LTrim$(invl.ExtNetWgt Using QMask$),fdel$ ! wgt ext
			WebStr$=WebStr$,RTrim$(invl.VendItemCode$),fdel$ ! vend item
			WebStr$=WebStr$,LTrim$(invl.CubeUnit Using PMask$),fdel$ ! cube unit
			tmp$=Str$(invl.CubeFactor)
			call factorum(tmp$) ! get um for factor
			WebStr$=WebStr$,Str$(invl.CubeFactor),fdel$,Rtrim$(tmp$),fdel$ ! cube factor & um
			X3=0
			If invl.CubeFactor let X3=round((invl.QtyShip*invl.CubeUnit/invl.CubeFactor),2)
			WebStr$=WebStr$,LTRim$(X3 Using QMask$),fdel$ ! cube ext (no invl. var)
			WebStr$=WebStr$,LTrim$(invl.LineDiscPct Using "###.##"),fdel$ ! line disc % (what of $?)
			WebStr$=WebStr$,Str$(invl.LineNum),fdel$ ! line Number (would be zero at first?)
			WebStr$=WebStr$,Str$(invl.NewPPFlg),fdel$ ! perm/1 time price
			tmp$="STK";X2=invl.LineType
			if invl.NStkItem LET TMP$="NSTK"
			if invl.NStkItem AND X2=3 LET TMP$="MSG"
			IF X2=1 OR X2=2 LET TMP$="CUT"
			WebStr$=WebStr$,RTRIM$(TMP$),FDEL$ ! line type
			!WebStr$ = WebStr$,"orgprodid",fdel$
			WebStr$=webstr$,RTrim$(invl.OrgProdCode$),fdel$
			!WebStr$ = WebStr$,"altsub",fdel$
			WebStr$=WebStr$,Str$(Int(invl.AltSupsd)),fdel$
			!WebStr$ = WebStr$,"VendName",fdel$
			X2=invl.Vendor \ if x2=0 let x2=pr.PrimVend
			tmp$=x2 using "######"
			vnc=OpenFile(-2400,IntCo)
			if vnc>0
				vnr=filegeta80vm(e$,vnc,"=",1,tmp$,Vend.)
				if vnr<=0 clear vend.
				Close #vnc
			Else
				Clear vend.
			Endif
			WebStr$=WebStr$,RTrim$(vend.Name$),fdel$ ! vend & name
			!WebStr$ = WebStr$,"MSDS",fdel$
			WebStr$=WebStr$,Str$(invl.MSDSNo),fdel$ ! msds
			!WebStr$ = WebStr$,"WhseName",fdel$
			clear wh.
			If invl.whse > 0 And invl.whse <= 99          
				Read Record #ch_wh,((invl.whse) - 1);wh.; 
			End If                                    
			webstr$ = webstr$,RTrim$(wh.WhName$),fdel$
			!Webstr$ = Webstr$,"Pack",fdel$
			Webstr$=webstr$,RTrim$(pr.PackSize$),fdel$
			!Webstr$ = Webstr$,"StckUpd",fdel$
			tmp$="N" \ if invl.UpdtStk let tmp$="Y"
			WebStr$=WebStr$,tmp$,fdel$ ! update stock flag
			!Webstr$ = Webstr$,"TaxRate",fdel$
			If P60$[42,42]<>"Y" ! has y/n only - get rate from header tax
				TaxNo=invh.TaxCode
				invl.TaxPct=invt.TaxPct ! use totals %
			Else ! is a code
				TaxNo=invl.TaxFlg
				If TaxNo>0
					Tcc=Openfile(-2176,IntCo) \ if Tcc = -1 Error 42
					Read record #tcc,taxno,0;tax.;
					Close #tcc
				Else ! no taxcode
					clear tax.
				Endif
				invl.TaxPct=tax.TaxRate
			Endif
			WebStr$=WebStr$,LTrim$(invl.TaxPct Using "###.####"),fdel$ ! tax rate
			!Webstr$ = Webstr$,"PrintFlag",fdel$
			!Webstr$ = Webstr$,"PrintDate"Time",fdel$
			tmp$="N" \ if invl.LinePrint let tmp$="Y"
			WebStr$=WebStr$,tmp$,fdel$ ! line printed
			tmp$="" 
			if invl.LinePrint let tmp$=JDate$(invl.PrintDate) ! print date = julian
			WebStr$=WebStr$,tmp$,fdel$ ! printed date
			if invl.LinePrint=0
				WebStr$=WebStr$,"",FDEL$
			Else
				tmp$=invl.PrintTime Using "&&&&&&"
				WebStr$=WebStr$," ",tmp$[1,2],":",tmp$[3,4],":",tmp$[5,6],fdel$ ! print time HH:MM:SS
			Endif
			clear dept.
			!Webstr$ = Webstr$,"DeptName",fdel$
			If invl.Dept > 0 And invl.Dept < 10000    
				Read Record #ch_dept,invl.Dept;dept.;   
			End If                                    
			webstr$ = webstr$,RTrim$(dept.desc$),fdel$
			tmp$="N" \ if pr.SerNoTrack$="Y" let tmp$="Y"
			if invl.linenum=0 and RTrim$(invl.RepairLine$)<>"" let tmp$="N" ! not on ot21/22
			! if invl.UpdtStk=0 let tmp$="N" ! no sn on directs / no stk update 
			! a question: show SN and tell them none required or NO SN at all - let's show & tell!
			webstr$=webstr$,tmp$,fdel$
			!Webstr$ = Webstr$,"GLCost",fdel$
			if invl.UnitGLCost=0 ! could happen   ! GL COST IS KEPT IN BASED
				x3=0
				if invl.QtyShip x3=invl.ExtGLCost/invl.QtyShip
				invl.UnitGLCost=x3
			Endif
			cnvtu[0]=0;cnvtu[1]=invl.UMCost;cnvtu[2]=2
			Cnvta=invl.UnitGLCost
			if cost_lev[0]=0  ! no avg cost security
				webstr$=webstr$,fdel$,fdel$ ! no show
			Else
			 X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			 WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! gl cost
			 webstr$=webstr$,LTrim$(invl.ExtGLCost using "##########.##"),fdel$ ! ext'd
			Endif
			tmp$="N" \ if invl.KitDesignation$="KIT" let tmp$="Y"
			webstr$=webstr$,tmp$,fdel$ ! kit Y/N
			tmp$="N" \ if custom_customer$="MORRISETTE" and Int(pr.UdNumeric)<>0 let tmp$="Y"
			webstr$=webstr$,tmp$,fdel$ ! hilight Y/N
			if invh.ordtype=4 or invh.ordtype=15
				cnvtu[0]=0;cnvtu[1]=invl.UMSell;cnvtu[2]=1
				Cnvta=invl.CurrBillQty
				X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! Qty Curr Bill
				cnvtu[0]=0;cnvtu[1]=invl.UMSell;cnvtu[2]=1
				Cnvta=invl.PrevQtyBill
				X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! Qty Prev Billed
			Else
				webstr$=webstr$,"",fdel$,"",fdel$
			Endif
			let webstr$=webstr$,str$(invl.PONum),fdel$
			tmp$=chktagfle$()
			webstr$=webstr$,tmp$,fdel$ ! notes flag
			List$[row]=WebStr$
			Let row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
		Loop
	Endif ! returnstatus
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	else
		include "src/callsuberr.inc"!
	End Try
End Sub
! ----- setprtoinvl 
Sub SetPRtoInvl()
! set up prod (PR.) with line values (stock & NonStock)
 Try
	Dim 1%,PFU1[20]
	Dim 3%,PFU2[6]
	IF ZLINE GOTO L30099:                                          
	LET pr.LbsUnit=invl.LbsUnit;pr.LbsFact=invl.WgtFactor
	IF NOT(pr.LbsUnit) LET pr.LbsUnit=1;invl.WgtFactor=1    
	LET pr.CubicFeet=invl.CubeUnit;pr.CubicFtFactor=invl.CubeFactor
	IF NOT(pr.CubicFtFactor) LET pr.CubicFtFactor=1;invl.CubeFactor=1
	LET pr.BaseUM=invl.UMBase;pr.UM2=invl.UMSell                     
	LET pr.UM3=invl.UMPrice;pr.UM4=invl.UMCost                               
	LET pr.UM5=invl.UMPurch                                          
	LET pr.UM6=0;pr.UM7=0;pr.UM8=0                               
	LET pr.UMStkDefault=invl.UMSell;Pr.UMSellDefault=invl.UMSell;pr.UMPurchDefault=invl.UMPurch             
	LET pr.UMCostDefault=invl.UMCost;pr.UMPriceDefault=invl.UMPrice                              
	IF NOT(NonSTK) GOTO L30060:                                   
	LET pr.UMPrdtnDefault=invl.UMSell;pr.UMUpChrg=invl.UMBase;pr.UMBrknQty=invl.UMBase              
	IF pr.UMCostDefault=-3 OR pr.UMPriceDefault=-3 ! "Catch Wgt Itm N/S              
		LET pr.CatchWgtItm=-3;invl.CatchWgtItem=pr.CatchWgtItm                                 
	ELSE                                                            
		LET pr.CatchWgtItm=0;invl.CatchWgtItem=0                                         
	ENDIF                                                           
	LET pr.UMPack=invl.UMSell;pr.UMSize=invl.UMSell                               
	L30060: LET pr.UM2Fact=invl.SellFactor;pr.UM3Fact=invl.PriceFactor                     
	LET pr.UM4Fact=invl.CostFactor;pr.UM5Fact=invl.PurchFactor                              
	LET pr.UM6Fact=0;pr.UM7Fact=0;pr.UM8Fact=0 
	! below gets rid of dupes - not easy with names - so load into pfu1,pfu2
	PFU1[0]=pr.BaseUM
	pfu1[1]=pr.UM2;PFU2[0]=pr.UM2Fact
	Pfu1[2]=pr.UM3;pfu2[1]=pr.UM3Fact
	pfu1[3]=pr.UM4;pfu2[2]=pr.UM4Fact
	pfu1[4]=pr.UM5;pfu2[3]=pr.UM5Fact
	FOR X1=1 TO 4                                                   
		FOR X2=0 TO X1-1                                              
			IF PFU1[X1]=PFU1[X2] LET PFU1[X1]=0;PFU2[X1-1]=0            
		NEXT X2                                                       
	NEXT X1 
	! now reload checked um's to names
	pr.BaseUM=PFU1[0]
	pr.UM2=pfu1[1];pr.UM2Fact=PFU2[0]
	pr.UM3=Pfu1[2];pr.UM3Fact=pfu2[1]
	pr.UM4=pfu1[3];pr.UM4Fact=pfu2[2]
	pr.UM5=pfu1[4];pr.UM5Fact=pfu2[3]
L30099: ! finito
 else
    include "src/callsuberr.inc"
 end try
end sub ! SetPRtoInvl
!--------------------------------------------------------------------
Sub Factorum(tmp$)
! from sent factor (in tmp$) - get um text for it
! if no match - send factor back as um
 Try
	dim um$[4]
	dim 1%,umrec
	dim 3%,factor
	let factor=tmp$
	if factor<=0 let factor=1
	umrec=0
	if factor=pr.UM2Fact let umrec=PR.UM2
	if factor=pr.UM3Fact let umrec=PR.UM3
	if factor=pr.UM4Fact let umrec=PR.UM4
	if factor=pr.UM5Fact let umrec=PR.UM5
	if factor=pr.UM6Fact let umrec=PR.UM6
	if factor=pr.UM7Fact let umrec=PR.UM7
	if factor=pr.UM8Fact let umrec=PR.UM8
	If factor=1 let umrec=pr.BaseUM
	if umrec>0
		Read record #ch_ccode,umrec,0;UMC.;
		let tmp$=umc.Code$ ! send back um attached
	Else
		if factor=1000 ! hardcode an "M"?
			tmp$="M" ! why not
		Else
			Let tmp$=Str$(Factor) ! send back w/no um (factor instead of um)
		Endif
	Endif
 else
    include "src/callsuberr.inc"
  end try
end sub ! Factorum
! 
!--------------------------------------------------------
! ------------------------------------------------------------------------
Sub InvHLabel()
  !
  ! Create order header Labels for .net
  !
try
  dim head$[10],keyprog$[30],retval$[512]
  dim 3%,ch_prgd,rec_prgd,e,ctr
 
   !get the specific order detail
     Call DXGet("STATUS",TMP$)
     let credit=0
     if ucase$(rtrim$(tmp$))="C/M" let credit=99
     returnstatus=1
     message$="OK"
   
 Clear List$[]                                                         
 List$[0] = bsdel$ + "InvHLabels" + fdel$ ! section name                 
 tmp$ = "Std Name" + fdel$                                            
 tmp$ = tmp$ + "Label" + fdel$ 
 tmp$ = tmp$ + "DescName" +fdel$

 List$[1] = tmp$ ! put header into rstr$                            
 row = 2 ! starting row for data   
  If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])                  

tmp$="OrderDate"+fdel$  !#1 ! INVOICEDETAIL
if not(credit)
	tmp$=tmp$+"ORDER DATE"+fdel$  !#1
Else
	let tmp$=tmp$+"C/M DATE",fdel$
endif
Tmp$=tmp$+"",fdel$
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

! invoice date #2
tmp$="InvCmDate"+fdel$
if not(credit)
	tmp$=tmp$+"INVOICE DATE"+fdel$
else
	tmp$=tmp$+""+fdel$
endif
Tmp$=tmp$+"",fdel$
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

! po #3
tmp$="PO"+fdel$	
tmp$=tmp$+"PO"+fdel$
Tmp$=tmp$+"",fdel$
list$[row]=tmp$

let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])


tmp$="Slsm"+fdel$	!#4
read #ctlc,18,60;head$; ! salesman name head
tmp$=tmp$+head$+fdel$	!#4
Tmp$=tmp$+"SlsmName",fdel$
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 


tmp$="Terms"+fdel$ !#5
tmp$=tmp$+"TERMS"+fdel$
Tmp$=tmp$+"TermsDesc",fdel$
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

tmp$="Attn"+fdel$	!#6
tmp$=tmp$+"ATTN"+fdel$
Tmp$=tmp$+"",fdel$
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])


tmp$="ShipDate"+fdel$ ! #7
tmp$=tmp$+"SHIP DATE"+fdel$ 
Tmp$=tmp$+"",fdel$
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

tmp$="DEPT"+fdel$      ! #8
tmp$=tmp$+"DEPT"+fdel$
Tmp$=tmp$+"DeptName",fdel$
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

tmp$="WH"+fdel$ ! #9
read #ctlc,18,30;head$;     ! warehouse name head 
tmp$=tmp$+head$+fdel$ 
Tmp$=tmp$+"WhName",fdel$
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

tmp$="DueDate"+fdel$  ! #10
tmp$=tmp$+"DUE DATE"+fdel$
Tmp$=tmp$+"",fdel$
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
	
tmp$="ShipCMType"+fdel$   ! #11
if not (credit)
	tmp$=tmp$+"SHIP #"+fdel$   
Else
	tmp$=tmp$+"CM TYPE"+fdel$
Endif
Tmp$=tmp$+"ShipCMDesc",fdel$
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

tmp$="Routing"+fdel$ ! #12
tmp$=tmp$+"ROUTING"+fdel$ 
Tmp$=tmp$+"",fdel$
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

tmp$="EnterBy"+fdel$ ! #13
read #ctlc,18,80;head$;
tmp$=tmp$+head$+fdel$
Tmp$=tmp$+"EntByName",fdel$
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

tmp$="Zone"+fdel$   ! #14
tmp$=tmp$+"ZONE"+fdel$   ! #14
Tmp$=tmp$+"ZoneName",fdel$
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])


tmp$="Truck"+fdel$  ! #15
tmp$=tmp$+"TRUCK"+fdel$  ! #15 
Tmp$=tmp$+"",fdel$
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])


tmp$="StopNum"+fdel$   ! #16
tmp$=tmp$+"STOP"+fdel$ 
Tmp$=tmp$+"",fdel$
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])

tmp$="OrdType"+fdel$   ! #17
tmp$=tmp$+"TYPE"+fdel$
Tmp$=tmp$+"OrdTypeDesc",fdel$
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])


tmp$="Division"+fdel$  ! #18
tmp$=tmp$+"DIVISION"+fdel$
Tmp$=tmp$+"DivName",fdel$
list$[row]=tmp$
let row=row+1
If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])


tmp$="Source"+fdel$ ! 19
tmp$=tmp$+"SOURCE"+fdel$ !
Tmp$=tmp$+"SourceName",fdel$
list$[row]=tmp$
Call AddToStr(e$,rstr$,List$[])  ! put header into rstr$  
Call AddToStr(e$,rstr$,esdel$) ! end of section


ELSE
include "src/callsuberr.inc"
END TRY

End sub ! INVhlabel
!=======================================================================================
Sub GetInvhSumm()
  Try
	Dim 3%,invhcost,invhgp,invhsale

	if custid<=0 or custid>999999
		let returnstatus=0
		let message$="Invalid Customer Code "
	Else
		let keycust$=custid using "######"
		search #ch_cust,2,1;keycust$,rec_cust,e
		if e<>0
			let returnstatus=0
			let message$="Customer Code "+str$(custid)+" Not On File"
		else
			read record #ch_cust,rec_cust,0;cust.;
			if refid<=0 or refid>99999999
				let returnstatus=0
				let message$="Invalid Reference Number"
			else
				let keyinvh$=" ",keyinvh$
				let keyinvh$[1,6]=custid using "######"
				let keyinvh$[7,16]=refid using "##########"
				Search #ch_invh,2,2;keyinvh$,rec_invh,e
				if e<>0
					returnstatus=0
					let message$="Reference Number "+str$(refid)+" For Customer "+str$(custid)+" Not On File"
				else
					read record #ch_invh,rec_invh,0;invh.;
					read record #ch_invs,invh.shiprec,0;invs.;
					read record #ch_invt,invh.totrec,0;invt.;
				endif
			endif
		endif
	endif

	Clear List$[]
	List$[0] = bsdel$ + "InvHSummary" + fdel$ ! section name 
	webstr$=""
	webstr$=webstr$,"Weight",fdel$
	webstr$=webstr$,"BilledTotal",fdel$ 
	webstr$=webstr$,"CostTotal",fdel$
	webstr$=webstr$,"GRPROFIT",fdel$
	webstr$=webstr$,"InvNumber",fdel$ 
	webstr$=webstr$,"InvDate",fdel$
	webstr$=webstr$,"Div",fdel$
	webstr$=webstr$,"BilledMerch",fdel$
	webstr$=webstr$,"CostMerch",fdel$ 
	webstr$=webstr$,"GP",fdel$
	webstr$=webstr$,"OrderNumber",fdel$
	webstr$=webstr$,"ShipDate",fdel$
	webstr$=webstr$,"Whse",fdel$
	webstr$=webstr$,"BilledFrgt",fdel$
	webstr$=webstr$,"CostFreight",fdel$
	webstr$=webstr$,"Com",fdel$
	webstr$=webstr$,"Type",fdel$
	webstr$=webstr$,"DueDate",fdel$
	webstr$=webstr$,"Lines",fdel$
	webstr$=webstr$,"BilledTMO",fdel$
	webstr$=webstr$,"CostTMO",fdel$
	webstr$=webstr$,"PO",fdel$
	webstr$=webstr$,"SLSM",fdel$
	Webstr$=webstr$,"ORIGORDID",fdel$
	Webstr$=webstr$,"PRINTINVHIST",fdel$
	
	List$[1]=webstr$
	if returnstatus>0
		Webstr$=""
		webstr$=(invt.TotWgt using "--------#.##"),fdel$
		webstr$=webstr$+(invt.OrdTot using "--------#.##"),fdel$         
		IF P9$[29,29]="Y" AND COST_LEV[1]<>0
			LET INVHSALE=invt.Subtot!T2[1];
			INVHCOST=invt.TotShipCost !T2[17]                                  
			IF P9$[35,35]="Y" LET INVHSALE=INVHSALE+invt.FrgtChrg ! T2[5]                       
			IF P9$[36,36]="Y" LET INVHSALE=INVHSALE-invt.OrdDisc !T2[3]                       
			IF P9$[37,37]="Y" LET INVHCOST=INVHCOST+invt.FrgtCost !T2[20]                      
			IF P9$[38,38]="Y"
				LET INVHSALE=INVHSALE+invt.MiscChrg4Prof ! TOT[1]
				LET INVHCOST=INVHCOST+invt.MiscCost4Prof !TOT[2]     
				LET INVHGP=INVHSALE-INVHCOST                                         
				LET INVHGPP=0                                                   
				IF INVHSALE<>0
					LET INVHGPP=FNR(INVHGP*100/INVHSALE)
				ENDIF
			endif
			webstr$=webstr$+(INVHcost using "--------#.##"),fdel$
			webstr$=webstr$+(INVHGP using "--------#.##"),fdel$
		else
			webstr$=webstr$+"",fdel$ ! cost
			webstr$=webstr$+"",fdel$ ! gp $
		endif
                Webstr$=webstr$+(invh.InvNum USING "########"),fdel$
		if invh.InvDate<>0
			let xdate$=pdate$(invh.InvDate)
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! cm/inv date date	
                !!!! Line #2
		webstr$=webstr$+(invh.Div using "##"),fdel$
		webstr$=webstr$+(INVT.Subtot using "--------#.##"),fdel$	
		webstr$=webstr$+(INVT.TotShipCost using "--------#.##"),fdel$
		
		IF P9$[29,29]="Y" AND COST_LEV[1]<>0
			webstr$=webstr$+rtrim$(invhgpp USING "----#.##"),fdel$
		else
			webstr$=webstr$+""+fdel$
		endif
		webstr$=webstr$,(invh.OrdNum using "######"),fdel$
		if invh.shipdate<>0
			if invh.shipdate<>999999
				let xdate$=pdate$(invh.shipdate)
			else
				let xdate$="999999"
			endif
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! ship date 
		!line #3
		webstr$=webstr$,str$(invh.wh),fdel$ ! warehouse webstr$=webstr$,"Whse",fdel$
		webstr$=webstr$,(invt.FrgtChrg using "--------#.##"),fdel$ ! "BilledFrgt",fdel$
		webstr$=webstr$,(invt.FrgtCost using "--------#.##"),fdel$ ! "CostFreight",fdel$
		! check the commission level
		if invh.ordtype=19 and invh.Ot19Comp=1 let invh.SlsmComm[0]=0 ! no comm ot19 partial
		webstr$=webstr$,(invh.SlsmComm[0] USING "------#.##"),fdel$ ! commission
		webstr$=webstr$,(INVH.OrdType USING "##"),fdel$ ! "Type",fdel$
		if invh.duedate
			let xdate$=pdate$(invh.duedate)
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! due date!webstr$=webstr$,"DueDate",fdel$ ! h5[1]
		         
		!line #4
		numlines=0
		let tmpkey$=" ",tmpkey$
		let tmpkey$[1,10]=refid using "##########"
		do
			search #ch_invl,3,1;tmpkey$,rec_invl,e
			if e<>0 exit do
			let tmp3=tmpkey$[1,10]\if tmp3<>refid exit do
			let numlines=numlines+1
		loop
		webstr$=webstr$,str$(numlines),fdel$ ! "Lines",fdel$ ! PRINT  USING "###";@6,7;NUMLINES; 
		webstr$=webstr$,((invt.MiscChrg+invt.OthChrg+ invt.TaxAmt) using "--------#.##"),fdel$ ! "BilledTMO",fdel$ !PRINT  USING MASK$;@20,7;T2[4]+T2[6]+T2[7];
		webstr$=webstr$,(invt.TotMiscCost using "--------#.##"),fdel$ ! "CostTMO",fdel$ !@33,7;TOT[0]
		WebStr$=WebStr$,RTrim$(invh.custpo$),fdel$ ! po#!webstr$=webstr$,"PO",fdel$
		WebStr$=WebStr$,Str$(invh.slsmnum),fdel$ ! salesman number!webstr$=webstr$,"SLSM",fdel$
		If invh.OrgOrd
			webstr$=webstr$,Str$(invh.OrgOrd),fdel$
		Else
			webstr$=webstr$,"",fdel$
		Endif
		webstr$ = webstr$,ucf$[3,3],fdel$
		list$[2]=webstr$
	endif
	Call AddToStr(e$,rstr$,List$[])                 
	Call AddToStr(e$,rstr$,esdel$) ! end of section
else
	include "src/callsuberr.inc"! ERROR 
end try
end sub !  getinvhsummary
!------------------------------------------------------------------------------------------------
Sub SrchInvhMsg() ! search based upon customer code - search special messages
Try
	dim 2%,startdate,3%
	dim keyinvm$[50],shipflag$[1],Search_method$[1],j4$[50]                               
	dim msgword1$[16],msgword2$[16],msgword3$[16],Strg$[60] 
	Dim Stkey$[60],Stkey2$[50]
	!call dxsave(0,"tmp/sihmsg.txt!")
	Call Dxget ("CUSTID",tmp$)! do not set returnstatus         
	let custid=tmp$                                             
	if custid<=0 or custid>999999                               
		let returnstatus=0                                  
		let message$="Invalid Customer Id" 
		!goto EndInvMsgSrch
	endif     
	If returnstatus<>0 and custid<>prt.CashSaleCustNum
		 Custsec[0]=custid;custsec[1]=1 ! id & NO ALERT
		 call "custsec.dl4",Custsec[],ctlc,userid$,e$,rstr$
		 if custsec[0]=-1 ! not allowed
			returnstatus=0
			message$="You do not have access this customer"
			!goto EndInvMsgSrch
		 Endif
	Endif ! don't check on cash cust or cash sales
	startdate=0                                                 
	call dxget("STARTDATE",tmp$)! do not set returnstatus       
	let tmp3=tmp$                                               
	if tmp3<>0                                                  
		XDATE$ = formatdate2$(tmp$) ! from MM/DD/YYYY to   
		tmp3 = XDATE$[3,8]                                 
		! convert to julian                                 
		 XDATE$ = tmp3 Using "&&&&&&"                       
		Call DateToJulian(1,XDATE$,XDATE$,errflag)          
		If errflag                                          
			ReturnStatus = 0                            
			message$ = "Invalid Start Date Entered"
			!goto EndInvMsgSrch    
		else                                                
			let startdate=xdate$ ! save in julian form
		End If                                          
	endif                                                   
	call dxget("WORD1",tmp$)                                
	let msgword1$=UCase$(RTRIM$(tmp$))
	call dxget("WORD2",tmp$)                                
	let msgword2$=UCase$(RTRIM$(tmp$))
	call dxget("WORD3",tmp$)                                
	let msgword3$=UCase$(RTrim$(tmp$))
	call dxget("SHOWSHIPTO",tmp$)                           
	let shipflag$="N"                                       
	if ucase$(rtrim$(TMP$))="Y" let shipflag$="Y"            
	let shiptocode=0                                        
	if shipflag$="Y"                                        
		call dxget("SHIPTOCODE",tmp$)                   
		let shiptocode=tmp$                             
	endif                                                   
	LET WORDS2MATCH=0                                       
	IF rtrim$(msgword1$)<>"" LET WORDS2MATCH=WORDS2MATCH+1        
	IF rtrim$(msgword2$)<>"" LET WORDS2MATCH=WORDS2MATCH+1        
	IF rtrim$(msgword3$)<>"" LET WORDS2MATCH=WORDS2MATCH+1
	call dxget("EXACT",tmp$)
	let exact=0
	if rtrim$(ucase$(tmp$))="Y" let exact=1
	call dxget("LOGIC",tmp$)
	let search_method$=rtrim$(ucase$(tmp$))
	IF Search_method$<>"A" AND Search_method$<>"O"
		let returnstatus=0
		let message$="Invalid Logic Selection Entered"
	endif
	!! added availability of sending multiple packets (no words?)
	call dxget("CURKEY1",tmp$) ! for the more option
	STKey$=RTrim$(tmp$) ! will have leading space stripped!!?
	if stkey$="" goto Startscan2 ! 1st time in?
	ChkLenSt2: ! SEARCH KEY IS DIR 2: CCCCCCIIIIIIIIII
		if len(stkey$)<16 ! add back in to begin
		  tmp$=" "+stkey$ ! 1 is ALWAYS Customer
		  stkey$=tmp$
		  goto chklenst2
		Endif
		! ok now 16 - see if spaces in middle gone?
		x3=stkey$[1,6];x3[1]=stkey$[7,16] ! default - cust 6 / inv 10
		for x=16 to 7 step -1
			if stkey$[x,x]=" " ! found 1st space from end
				x3=stkey$[1,x] ! first #
				x3[1]=stkey$[x+1] ! second
				x=0 ! end loop
			Endif
			! if none after 6 - it's a full 6 digit # ! use as is
		Next x
		let stkey$[1,6]=x3 using "######"
		if x3[1]>0 let x3[1]=x3[1]-1 ! as its mode 3 - minus 1 to start at last one sent
		let stkey$[7,16]=x3[1] using "##########" 
	call dxget("CURKEY2",tmp$) ! for the more option - need 2 keys cust/inv/msgline
	STKey2$=RTrim$(tmp$) ! will have leading space stripped!!?
	if stkey2$="" goto Startscan2 ! 1st time in?
	ChkLenSt3: ! SEARCH KEY IS DIR 1: IIIIIIIIIIMMMB
		if len(stkey2$)<13 ! add back in to begin
		  tmp$=" "+stkey2$ ! 1 is ALWAYS Customer
		  stkey2$=tmp$
		  goto chklenst3
		Endif
		! ok now 12 - see if spaces in middle gone?
		x3=stkey2$[1,10];x3[1]=stkey2$[11,14] ! default - Inv 10 / line 4
		for x=13 to 11 step -1
			if stkey2$[x,x]=" " ! found 1st space from end
				x3=stkey2$[1,x] ! first #
				x3[1]=stkey2$[x+1] ! second
				x=0 ! end loop
			Endif
			! if none after 10 - it's a full 10 digit # ! use as is
		Next x
		let stkey2$[1,10]=x3 using "##########"
		if x3[1]>0 let x3[1]=x3[1]-1 ! as its mode 3 - minus 1 to start at last one sent
		let stkey2$[11,13]=x3[1] using "###" 
		stkey2$[14]=" "
 	Startscan2: ! do it
	
	Maxrow=4000 ! as they're small
	Clear list$[]
	List$[0] = bsdel$,"InvoiceHistMessages",fdel$
	webstr$=""
	webstr$ = webstr$,"InvNum",fdel$   
	webstr$ = webstr$,"InvType",fdel$  
	webstr$=  webstr$,"InvDate",fdel$  
	webstr$=webstr$,"Line",fdel$
	webstr$=webstr$,"Message",fdel$
	!Tmp$=""
	!if shipflag$="Y"
		Tmp$="ShipInfo"
	!endif
	Webstr$=webstr$,tmp$,fdel$
	List$[1] = webstr$ 
	if not(returnstatus) goto EndInvMsgSrch:! MTG
	row = 2;tmpcnt = maxcnt 
	LET Keyinvh$=" ",Keyinvh$;Keyinvh$=custid using "######"
	if stkey$<>"" let keyinvh$=stkey$ ! resume of search
	do                                                      
		SEARCH #CH_INVH,3,2;Keyinvh$,rec_invh,E
		if e<>0 exit do                             
		let tmp3=keyinvh$[1,6]\if tmp3<>custid exit do                          
		read record #ch_invh,rec_invh,0;invh.;                                  
		read record #ch_invs,invh.ShipRec,0;invs.;                              
		if shipflag$="Y" and shiptocode<>0                                     
			if ros.ShipEdit<>2 goto getnextinvhm:                           
			if ros.ShipEdit=2 if shiptocode<>invs.shipcode goto getnextinvhm
		endif                                                                   
		if startdate<>0                                                         
			let xdate$=invh.InvDate using "&&&&&&"                                         
			Call DateToJulian(1,XDATE$,XDATE$,errflag)                      
			if errflag<>0                                                   
				goto getnextinvhm:      ! get next invoice              
			endif
			let tmp3=xdate$
			if tmp3<startdate goto getnextinvhm:                            
		endif                                                                   
		! check the date                                                        
		keyinvm$=" ",keyinvm$                                                   
		keyinvm$[1,10]=keyinvh$[7,16]                                           
		keyinvm$[11,13]="  0"   
		if stkey2$<>"" let keyinvm$=stkey2$ ! resume search
		do                                                                      
			SEARCH #CH_INVM,3,1;Keyinvm$,rec_invm,E                         
			if e<>0 exit do  
			if keyinvm$[1,10]<>keyinvh$[7,16] exit do  
			read record #ch_invm,rec_invm,0;invm.;     
			! LET STRG$=rtrim$(invm.Message$) ! 
			STRG$=UCase$(RTrim$(invm.message$)) ! compare in UPPER CASE!
			if strg$="" goto noinvmsg
			let chkctr=0                                  
			IF msgword1$="" AND msgword2$="" AND msgword3$=""              
				let chkctr=1                         
			else                                       
				if rtrim$(msgword1$)<>""                              
					let pass=0 
					if Exact<>0
						if STRG$=msgword1$ let pass=1
					else
						search STRG$[1],msgword1$,pass
					endif
					if pass<>0 let chkctr=chkctr+1   
				endif                              
				if rtrim$(msgword2$)<>""                              
					let pass=0                 
					if Exact<>0
						if STRG$=msgword2$ let pass=1
					else
						search STRG$[1],msgword2$,pass
					endif
					if pass<>0 let chkctr=chkctr+1   
				endif                              
				if rtrim$(msgword3$)<>""                              
					let pass=0                 
					if Exact<>0
						if STRG$=msgword3$ let pass=1
					else
						search STRG$[1],msgword3$,pass
					endif
					if pass<>0 let chkctr=chkctr+1   
				endif                           
				IF SeaRCH_METHOD$="A" ! all words must match 
					if chkctr<>WORDS2MATCH let chkctr=0      
				endif                                      
			endif  
			if chkctr<>0! print the webstr$
				webstr$=""
				webstr$ = webstr$,str$(invh.InvNum),fdel$ 
				let tmp$="INV"
				if invh.Status=31 let tmp$="C/M"
				webstr$ = webstr$,rtrim$(tmp$),fdel$ 
				If invh.InvDate <> 0                                     
					xdate$ = pdate$(invh.InvDate)                          
				Else                                                     
					xdate$ = " ",xdate$                                    
				End If                                                   
				webstr$ = webstr$,RTrim$(xdate$),fdel$ ! cm/inv date date  
				webstr$=webstr$,str$(invm.MessageLine),fdel$
				tmp$=clrtxtc$(e$,invm.Message$) ! chk/clr control chars
				webstr$=webstr$,rtrim$(tmp$),fdel$
				Tmp$=""
				if shipflag$="Y"
					IF invs.ShipEdit=0 tmp$="SAME"             
					IF invs.ShipEdit=1 tmp$="DEFAULT SHIPLIST" 
					IF invs.ShipEdit=2 tmp$="SHIPLIST # "+str$(invs.ShipCode)
					IF invs.ShipEdit=4 tmp$="CUSTOMER "+str$(invs.ShipCust)  
					IF invs.ShipEdit=5 tmp$="MANUAL ENTRY"     
				Endif
				Webstr$=webstr$,tmp$,fdel$
				if row>maxrow+1 ! ALLOW FOR HEADER & this line
					returnstatus=5 ! special status to tell web MORE TO COME
					message$="CURKEY1="+Keyinvh$+"&"+"CURKEY2="+keyinvm$+"&"
					exit do ! reached limit
				Endif
				List$[row] = webstr$                                              
				row = row + 1 \ If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
				
			Endif
			noinvmsg: ! no message entered - blank	
		loop ! for the msg file             
		If row>Maxrow+1 exit do ! we rearch the limit!
		getnextinvhm: ! get next invhm line                        
	loop ! loop for the invh file 
	EndInvMsgSrch:! 
	Call AddToStr(e$,rstr$,List$[])                 
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
else
	include "src/callsuberr.inc"! ERROR 
end try
End Sub ! SrchInvhMsg
!--------------------------------------------------------------------------------
Sub OTMSDTIN()
! for ot 4 & 15 & 24 - up to 24 shipping dates coming in
 Try
	clear roh.shipdatelist[] ! clear 0-23 (pm s3[1-24])
	if roh.ShipTerm<>0 exit sub ! only for zero
	if roh.OrdType<>4 and roh.OrdType<>15 and roh.OrdType<>24 exit sub
	dim SPDate$[10],RSTRG$[150],WStrg$[160]
	dim 2%,spos,dpos
	dim 3%
	! we are getting this as ???
	call dxget("MSDATENT",tmp$) ! one string? comma sep?
	if Len(tmp$)<5 exit sub ! nothing in there
	SPOS=0;x=0;x1=0
	do
		SPDate$=tmp$[spos+1] to ",":DPOS  ! for some reason dpos always zero?
		let dpos=spos+Len(spdate$)+1  ! ie: 0+10+1=11, 11+10+1=22
		if len(spdate$)>5 ! had better be mm/dd/yyyy
			tmp1$=chkDateFrmt$(SPDate$) ! chk/convert to mm/dd/yyyy
			if tmp1$[1,1]<"0" and tmp1$[1,1]>"9" let tmp1$=""
			x$=formatdate2$(tmp1$) ! from mm/dd/yyyy to yyyymmdd
			Call DateToJulian(5,x$,tmp1$,e) ! from yyyymmdd to jjjjj
			If not(e) ! date ok
				RStrg$[x+1]=tmp1$[1,5]+" " ! set julian date into rstr$
				x=x+6;x1=x1+1
			Endif
		Endif
		if dpos>len(tmp$) exit do
		spos=dpos
	Loop
	if x=0 exit sub ! no dates recv'd
	call sortinstring(e,x1,6,rstrg$,wstrg$) ! will sort string lowest first
	if not(e) ! no problems  (x1 fields at 6 chars each)
		x=0;x1=0
		do
			tmp$=rstrg$[x+1,x+5]
			x2=tmp$
			if x2>0
				x$=jdate$(x2) ! from julian to MM/dd/yyyy
				tmp1$=x$[9,10]+x$[1,2]+X$[4,5]
				x2=tmp1$
				if x2>100
					roh.shipdatelist[x1]=x2
					x1=x1+1
				endif
			Endif ! of has jdate
			x=x+6 ! next sorted date
			if x>=Len(rstrg$) exit do ! all done
		Loop
	Endif
 else
	include "src/callsuberr.inc"! ERROR 
end try
End Sub ! OTMSDTIN
!--------------------------------------------------------------------------------
Function chkDateFrmt$(DIn$)
! see if date in is MM/DD/YY or MM/DD/YYYY
! if not make it MM/DD/YYYY
Try
	Dim DOut$[10]
	Dim 1%,Mth,Day
	Dim 3%,Yr
	If DIn$[1,2]="00" or UCase$(DIn$[1,4])="NONE" or DIn$="0"
	  Let DOut$=UCase$(DIn$)
	  Exit Function DOut$ ! no reformat - send back as is
	Endif
	Mth=DIn$[1,2];Day=Din$[4,5];Yr=DIn$[7]
	if Din$[2,2]="/" or DIn$[2,2]="-" ! 1 digit month
	  Let Mth=DIn$[1,1]
	  If DIn$[4,4]="/" or DIn$[4,4]="-" ! 1 digit day
	     Let Day=DIn$[3,3]
		 Let Yr=DIn$[5]
	  Else
	     Let Day=Din$[3,4] ! try 2 digit
		 Let Yr=DIn$[6]
	  Endif
	Endif
	X$=Mth Using "&&"
	X$[3,4]=Day Using "&&"
	If Yr>1000 ! 4
		X$[5]=Yr Using "&&&&"
	Else ! 2 digit
		If YR<67 let yr=2000+yr Else Let Yr=yr+1900
		X$[5]=Yr Using "####"
	Endif
	Dout$=X$[1,2]+"/"+X$[3,4]+"/"+X$[5]
 else
    include "src/callsuberr.inc"
  end try
end Function DOut$ ! chkDateFrmt$
!--------------------------------------------------------------------------------
Sub TrkDel()
 ! record lost inv # in delete tracker
 Try
	DIM 1%,DL1
	DIM 2%,DL[12]
	DIM 3%,DL3,DLT,R1
	DIM K1$[20],DL$[20],DL1$[20]
	REM ================================== WRITE OUT 
	DLT=ROT.OrdTot
	LET K1$=" ",K1$                                          
	LET K1$[1,2]=" 6" \ LET K1$[3]=roh.InvNum USING "##########"
	LET DL[0]=6 \ LET DL[1]=roh.custnum
	LET DL3=roh.invnum \ LET DL[3]=roh.ordnum
	LET DL[4]=roh.invdate \ LET DL[5]=roh.orddate
	LET DL[6]=roh.slsmnum \ LET DL[7]=roh.Dept
	LET DL[8]=roh.wh \ LET DL[9]=roh.Div
	LET DL[10]=roh.Terms \ LET DL[11]=roh.EntBy
	LET DL[12]=0
	X2=spc(6)
	if x2<8000 LET DL1=X2 ! avoid be 15
	DL1$=DELMSG$
	DL$=UserID$+Blank$
	chan=OpenFile(1248,IntCo) \ if chan=-1 goto dltrkdone
	LET E=2
	SEARCH #chan,1,0;K1$,R1,E
	IF E goto dltrkdone
	MAT  WRITE #chan,R1;DL;
	WRITE #chan,R1,52;DLT;
	WRITE #chan,R1,58;DL1;                                     
	MAT  WRITE #chan,R1,60;DL$;
	MAT  WRITE #chan,R1,80;DL1$;
	MAT  WRITE #chan,R1,100;DL3;
	SEARCH #chan,4,1;K1$,R1,E
	! IF E GOSUB ERR_SEARCH:
	DlTrkDone: ! done
	Try	close #Chan  Else Rem
 else
    include "src/callsuberr.inc"
  end try
end Sub ! TrkDel
!--------------------------------------------------------------------------------
Sub edttrk()
! pm records header access in edittrack
! Have etr.etaction & etr.prodcode$ SET UP ALREADY
! etr.prodcode$ = source prog or reason
  Try
	If etr.EtAction=0 EXIT SUB ! no action
	etr.OrdNum=roh.OrdNum
	etr.Status=roh.OrgStatus
	if etr.status<=0 let etr.status=roh.Status
	! etr.ProdCode$=whatever reason here
	etr.AccessCode$=Userid$+Blank$
	!	etr.EtAction=  10=delete, 14=access
	etr.InvNum=roh.InvNum
	etr.CustNum=roh.CustNum
	etr.Slsm=roh.SlsmNum
	etr.OrgOrdTot=rot.OrdTot
	etr.SpareNU$=blank$
	X1[0]=-1;X1[1]=-1 ! no files open - etrack/usercntrl
	Call MakeEdittrack(e$,IntCo,X1[],etr.)
  else
    include "src/callsuberr.inc"
  end try
end Sub ! edttrk
!--------------------------------------------------------------------------------
function getnteflgs$(webstr$)
! add flags on whether notes exist
  Try
	dim HMDir$[128]
	snote=1
	chan=openfile(-1680,Intco) \ if chan=-1 let snote=0
	if ua2$[31,31]="Y" ! user wants popupnotes
		if snote ! file found
			tmp$=" ",tmp$
			tmp$=custid using "######"
			search #chan,2,1;tmp$,R,E
			if e let snote=0
		Endif
		tmp1$="N" \ if snote let tmp1$="Y"
		let webstr$=webstr$,tmp1$,fdel$ ! has suppt note
		! now the window notes - not on backend - only web!
		!LET tmp1$="HOME" \ SYSTEM 28,tmp1$
		!if tmp1$[1,4]<>"HOME" and tmp1$<>"" ! got it?
		!	HMDir$=tmp1$+"/" ! add trailing /
		!Endif
		!tmp$=HMDir$+"files/notes/C"+Str$(IntCo)+custid using "&&&&&&"+".txt"
		!Call FindF(TMP$,H) ! needs full path for the "C"
		!let wnote=h
		!tmp1$="N" \ if wnote let tmp1$="Y" ! tmp$  ! tmp$=FULL PATH NAME
		tmp1$="N" \ if ua2$[31,31]="Y" let tmp1$="Y" ! just flag - file on web!
		webstr$=webstr$,tmp1$,fdel$
	Else ! no popupnotes wanted/avail
		webstr$=webstr$,"N",fdel$,"N",fdel$
	Endif
	try close #chan Else Rem
  else
    include "src/callsuberr.inc"
  end try
end Function webstr$ ! getnteflgs$
!--------------------------------------------------------------------------------
!! CASHNOSALE
Sub CASHNOSALE()
!-------------------------------------------------------------------
! defaults for cash sales
 try
	dim 1%,ch_ccc,tmpcnt
	dim 3%,rec_ccc
	dim CCTYPE$[100],keyccc$[50],keyroc$[50]
	dim paytype$[60]
	ReturnStatus=1
	Message$="OK"
	! section 1 -- droplist warehouse
	call FileDropListWhinfoz(e$,whList$[],100,ch_wh)
	call AddToStr(e$,rstr$,whList$[])
	
		
	! section 2 -- droplist enterby
	call FileDropListEntdby(e$,etList$[],100,ch_et)
	call AddToStr(e$,rstr$,etList$[])

	! section 3 -- droplist type
	let paytype$=" ",paytype$
	! Enter type:  1: Cash,  2: Check,  3: Credit Card,  4: Other
	let paytype$[1]= "None        " ! none is not used for 
	let paytype$[13]="Cash        "
	let paytype$[25]="Check       "
	let paytype$[37]="Credit Card "
	let paytype$[49]="Other       "
	tmpcnt=maxcnt
	MAT  READ #ctlc,49,0;CCTYPE$;
	clear ccc.
	clear list$[]
	List$[0] = bsdel$,"CASHPAYTYPE",fdel$
	Webstr$="Id",fdel$,"Desc",fdel$
	List$[1]=webstr$
	let row=2
	for ctr=1 to 4 ! none it not used 
		webstr$=Str$(ctr),fdel$
		webstr$=WEBSTR$,rtrim$(PAYTYPE$[ctr*12+1,ctr*12+12]),fdel$
		list$[row]=webstr$
		row=row+1
	next ctr
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	! section 4 -- Credit Card Types
	clear list$[]
	List$[0] = bsdel$,"CREDCARDTYPE",fdel$
	Webstr$="Id",fdel$,"Desc",fdel$
	list$[1] = webstr$
	!webstr$="0",fdel$,"None",fdel$
	!list$[2]=webstr$
	row=2
	for ctr=1 to 9
		tmp$=cctype$[ctr*10-9,ctr*10]
		if rtrim$(tmp$)<>""
			webstr$=str$(ctr),fdel$
			webstr$=webstr$,rtrim$(CCTYPE$[ctr*10-9,ctr*10]),fdel$
			list$[row]=webstr$
			row=row+1
		endif
	next ctr
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	!
	! section 5 - users defaults
	clear list$[]
	List$[0] = bsdel$,"USERDEFAULT",fdel$
	Webstr$="Whse",fdel$,"EntBy",fdel$
	List$[1]=Webstr$
	if prt.wh<1 or prt.wh>99 
		let prt.wh=1
	endif
	if prt.entby<1
		let prt.entby=1
	endif
	Webstr$=str$(prt.wh),fdel$
	webstr$=webstr$+str$(prt.entby),fdel$
	list$[2]=webstr$

	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! call SetOutPut(e$,rstr$)
 else
	include "src/callsuberr.inc" ! 
 end try
End sub !CashNoSale

!======================== SubCashNoSale======================================================
Sub SUBCASHNOSALE()
!-------------------------------------------------------------------
! defaults for cash sales
 try
	! For the drawer file
	Dim 1%,drw1[2],drw4,ch_cshdr
	dim 2%,drw2
	dim 3%,drw3[1],rec_cshdr
	dim drw1$[20]
	Dim filename$[50]
	! WAREHOUSE  -		1%,drw1[0],0               
	! ENTERED BY		1%,drw1[1],2                         
	! TYPE TRANS		1%,drw1[2],4    (1-4)              
	! DATE TRANS		2%,drw2   ,6           
	! CREDIT CARD TYPE	3%,drw3[0],10   (Type 2/type 3 1-9)
	! TRANSACTION AMOUNT    3%,drw3[1],16               
	! DESC/REASON           drw1$[20] ,22               
	!BANK NUMBER            1%,drw4   ,42  CCT#165927 
	Read #ctlc,0,112;drw2; ! transaction date
	ReturnStatus=1
	Message$="OK"
	Call dxget("WHSE",tmp$)                                   
	let drw1[0]=tmp$
	if drw1[0]<1 or drw1[0]>99
		Message$ = "Invalid Warehouse ID Submitted"                               
		ReturnStatus = 0                                           
		Goto EndCashNoSale:
	End If
	Call dxget("ENTBY",tmp$)                                   
	drw1[1]= tmp$ 
	if drw1[1]<1 or drw1[1]>999
		Message$ = "Invalid Entered By ID Submitted"                               
		ReturnStatus = 0                                           
		Goto EndCashNoSale:
	End If
	call dxget ("TYPE",tmp$)
	drw1[2]=tmp$
	if drw1[2]<1 or drw1[2]>4
		Message$ = "Invalid Payment Type Submitted"                               
		ReturnStatus = 0                                           
		Goto EndCashNoSale
	endif
	let drw3[0]=0
	if drw1[2]=2 or drw1[2]=3 ! check or credit card
		call dxget ("CHKCARD",tmp$)
		let drw3[0]=tmp$
		if drw1[2]=2 ! check
			if drw3[0]<=0 or drw3[0]>9999999999
				Message$ = "Invalid Check Number Submitted"                               
				ReturnStatus = 0                                           
				Goto EndCashNoSale
			endif
		endif
		if drw1[2]=3 ! credit card
			if drw3[0]<=0 or drw3[0]>9
				Message$ = "Invalid Credit Card Type Submitted"                               
				ReturnStatus = 0                                           
				Goto EndCashNoSale
			endif
		endif
	endif	
	call dxget ("AMOUNT",tmp$)
	IF rtrim$(tmp$)=""
		Message$ = "Invalid Amount Submitted"                               
		ReturnStatus = 0                                           
		Goto EndCashNoSale
	endif
	drw3[1]=tmp$
	call dxget ("REASON",tmp$)
	DRW1$=rtrim$(tmp$)+BLANK$
	! set the bank
	drw4=prt.CRBankNum 
	if drw1[2]=3 let drw4=prt.CashSlsBankNum            
	if drw4<1 or drw4>99 let drw4=1
	Ch_cshdr=findchannel()
	read #ctlc,88,800;filename$;
	filename$=rtrim$(filename$)
	tmp$=drw1[0] using "&&"
	filename$=filename$+tmp$
        Call FindF(filename$,fileflag)
	if not(fileflag) ! build a file
		tmp$ = "<666> files/",filename$         
		Build #ch_cshdr,tmp$                  
		rec_cshdr = 0                             
		WRITE #ch_cshdr,rec_cshdr;drw1[0],drw1[1],drw1[2],drw2,drw3[0],drw3[1],drw1$,drw4;
		tmp$ = "files/",filename$," <666>"                      
		Modify tmp$                                             
		Try                                                     
			Close #ch_cshdr                                    
		Else                                                    
			ReturnStatus = 0                                      
			Message$ = "Error Creating Cash Drawer File "  
			Goto EndCashNoSale                                  
		End Try                                                 			 
	endif
	Try ! for the open

		Open #ch_cshdr,filename$
	Else
		let Message$="Error Trying to Open Cash Drawer File "
		let returnstatus=0
		goto EndCashNoSale
	end try
	let rec_cshdr=chf(ch_cshdr)
        WRITE #ch_cshdr,rec_cshdr;drw1[0],drw1[1],drw1[2],drw2,drw3[0],drw3[1],drw1$,drw4;
	Try Close #ch_cshdr Else Rem
	call OpenDrawer()
	               
	EndCashNoSale: ! end of section 
	
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! call SetOutPut(e$,rstr$)
 else
	include "src/callsuberr.inc"
 end try
End sub !savecash

!====================== SubCashNoSale ==========================================================

Sub CountILines()
! count # lines in inv copied
 Try
	Dim ILK$[50],1%,S2[1],3%,L7[12]
	Ch_Invl = openfile(-1184,intCo) \ If Ch_InvL = -1 Error 42     !"Invoice lines file
	NumILines=0
	if invnum<=0 or invnum=orderid goto CILDone
	ILK$=" ",ILK$
	ILK$[1,10]=invnum Using "##########" ! 10
	do
		search #ch_invl,3,1;ilk$,R,E
		if e exit do
		x3[5]=ilk$[1,10] \ if x3[5]<>invnum exit do
		mat read #ch_invl,R,256;S2;
		mat read #ch_invl,R,168;L7;
		if S2[0]<>3 and L7[4]<>0 ! only count actual lines that ship
			NumILines=numilines+1
		Endif
	Loop
	CILDone: ! finished
	Try Close #Ch_Invl Else Rem
 else
	include "src/callsuberr.inc"
 end try
End sub !CountILines
! -----------------------------------------------------
Sub ChkcreateCust()
! check/send or create
 Try
	dim holds1$[118],s1$[118],K5$[50]
	dim holds2$[20],s2$[20],Phonenum$[10]
	Dim 2%,newcustnum,tcustnum,custnum,holdcustnum
	Dim 3%
	call dxget("DIV",tmp$)
	x2=tmp$
	if x2<0 or x2>chf(ch_div)-1 or fra(x2)
		message$="Invalid division"
		goto Schkcrtdone
	Endif
	Read #CH_Div,x2,198;TCUSTNUM;
	call dxget("RETAIL",tmp$)
	if custom_customer$="AMERICANOSMENT" and (tmp$="Y" or tmp$="N")
		! if we get any value for RETAIL, then its omni
		tcustnum=666666
	end if
	 If TCUSTNUM<=0
	   Message$ = "TEMPLATE CUST ACCT NOT SETUP IN Division File!!!"
	   returnstatus=0
	   Goto Schkcrtdone
	 End If 
	 K5$ = TCUSTNUM Using "######"
	 Search #Ch_Cust,2,1;K5$,R5,E
	 if e
		message$="TEMPLATE CUSTOMER NOT FOUND!"
		RETURNSTATUS=0
		Goto Schkcrtdone
	 End If
	 READ #CTLC,20,142;CUSTNUM;
 	 if custnum<=0 or custnum>999999 or fra(custnum)
		let newcustnum=1
	 Endif ! start with custnum that's in range!
	 NEWCUSTNUM = CUSTNUM
	 K5$ = " ",K5$
	 LOOP_FINDCUST: Rem find the new customer code
	 K5$ = NEWCUSTNUM Using "######"
	 Search #Ch_Cust,2,1;K5$,R5,E
	 If E > 2 ! Gosub ERR_SEARCH
		returnstatus=0
		message$="Search Error "+Str$(E)+" checking customer file"
		goto Schkcrtdone
	 Endif
	 If Not(E)
	   NEWCUSTNUM = NEWCUSTNUM + 1
	   Goto LOOP_FINDCUST
	 End If 
	 HOLDCUSTNUM = NEWCUSTNUM
	 CLFLAG = 0
	 SHIPFLAG = 0
	 HOLDS1$ = " ",HOLDS1$ ! as we don't know what's entered!
	 HOLDS2$ = " ",HOLDS2$
	 PHONENUM$=" ",PHONENUM$
	 If senddata ! send for entry
		! web retains current ship to address (as none on file!)
		clear list$[]
		List$[0]=bsdel$,"CREATECDATA",fdel$
		List$[1]="TPCUSTNUM",fdel$,"NEWCUSTNUM",fdel$,"UPDTSHIP",fdel$
		tmp$="N" \ if shipflag let tmp$="Y"
		list$[2]=Str$(TCUSTNUM),fdel$,Str$(NEWCUSTNUM),fdel$,tmp$,fdel$
		list$[3]=esdel$
		call addtostr(e$,rstr$,list$[])
	 Else ! we're updating
		 HOLDS1$ = S1$
		 HOLDS2$ = S2$
		 Call "createcust.dl4",S1$,S2$,TCUSTNUM,NEWCUSTNUM,CLFLAG,SHIPFLAG,Intco,phonenum$,returnstatus,message$
		 if returnstatus=0 or clflag<=0 ! failed
			if clflag=0 message$="New customer not created"
			goto schkcrtdone
		 Endif
		 If CLFLAG And NEWCUSTNUM = HOLDCUSTNUM
		   CUSTNUM = NEWCUSTNUM
		   Write #CTLC,20,142;CUSTNUM;
		 End If 
		 If CLFLAG ! successful cust create - update order fields
		   !H0[1] = NEWCUSTNUM \ H0[4] = NEWCUSTNUM
		   !C1[1] = NEWCUSTNUM
		   K5$ = NEWCUSTNUM Using "######"
		   Search #Ch_Cust,2,1;K5$,Q2,E
		   If E ! > 2 Gosub ERR_SEARCH
			returnstatus=0
			message$="Can not find new customer on file"
			goto schkcrtdone
		   Endif
		   !Mat Read #Ch_Cust,Q2,142;C1;
		   !Mat Read #Ch_Cust,Q2,194;C2;
		   !Mat Read #Ch_Cust,Q2,544;CFIN;
		   !Read #Ch_Cust,Q2,598;SZN;
		   !H0[12] = C2[0] \ H4 = C2[1] \ H4[1] = C7[4] \ H6[0] = C1[7]
		   !H0[11] = C1[2] \ H5[12] = SZN \ H5[8] = CFIN[4]
		   !SRN[2] = C1[1] \ SRN[4] = A0[3] \ DFLT_TAX_TYPE = A0[3]
		   !S9 = C1[1] \ S9[1] = Q2
		   ! web will reget all customer data using std calls
		 End If 
		 If Not(SHIPFLAG)
		   S1$ = HOLDS1$
		   S2$ = HOLDS2$
		 End If
		 clear list$[]
		 list$[0]=bsdel$,"NEWCUST",fdel$
		 webstr$="CUSTID",fdel$,"UPDTSHIP",fdel$
		 webstr$=webstr$,"ShipName",fdel$
		webstr$=webstr$,"ShipAddr1",fdel$
		webstr$=webstr$,"ShipAddr2",fdel$
		webstr$=webstr$,"ShipCity",fdel$
		webstr$=webstr$,"ShipState",fdel$
		webstr$=webstr$,"ShipZip",fdel$
		webstr$=webstr$,"Country",fdel$
		List$[1]=webstr$
		tmp$="N" \ if shipflag let tmp$="Y"
		webstr$=Str$(Newcustnum),fdel$,tmp$,fdel$
		webstr$=webstr$,S1$[1,30],fdel$
		webstr$=webstr$,s1$[31,60],fdel$
		webstr$=webstr$,s1$[61,90],fdel$
		webstr$=webstr$,S1$[91,105],fdel$
		webstr$=webstr$,S1$[106,107],fdel$
		webstr$=webstr$,S1$[108,117],fdel$
		webstr$=webstr$,S2$[1,15],fdel$
		list$[2]=webstr$
		list$[3]=esdel$
		call addtostr(e$,rstr$,list$[])
	Endif ! of send/create
	schkcrtdone: ! finished
	
 else
	include "src/callsuberr.inc"
 end try
End sub !ChkcreateCust
!--------------
sub ChkCreateshiplist()
 try
dim keyship$[50],tkcust$[50],Phonenum$[10]
dim 2%,custnum
CALL DXGET("CUSTNUM",tmp$)
let custnum=tmp$
if custnum=0
returnstatus=0
message$="customer ID is zero" 
goto Schkcshipdone
endif
tkcust$=custnum using "######"
search #ch_cust,2,1;tkcust$,tcustrec,e
if e
returnstatus=0
message$="Invalid customer ID" 
goto Schkcshipdone
endif

rem find unused shiplist code
let shipcode=1
loop_shipcode: ! look for an unused ship list code
if shipcode>999999
returnstatus=0
message$="Maximum number of ship lists exceded"
goto Schkcshipdone
endif

let keyship$=(custnum+(shipcode/10^6)) using "######.######"
shiprec=0
mode$="="
dirno=1
rem ShipRec=FileGetShiplist(e$,Ch_Ship,mode$,dirno,KeyShip$,sh.)
 search #ch_ship,2,1;keyship$,shiprec,e
if not(e)
let shipcode=shipcode+1 
goto loop_shipcode: ! 
endif
Call "createshiplist.dl4",custnum,shipcode,tcustrec,Intco,phonenum$,returnstatus,Message$
       if returnstatus=0  ! failed
		message$="Unknown error in shiplist create"
	if clflag=0 message$="New shiplist not created"
	goto Schkcshipdone
	else
	clear list$[]
	list$[0]=bsdel$,"NEWSHIPTO",fdel$
	 webstr$="CUSTID",fdel$,"SHIPTOID",fdel$
	 List$[1]=webstr$
     webstr$=Str$(CUSTNUM),fdel$
     webstr$=webstr$,shipcode using "&&&&&&",fdel$
     list$[2]=webstr$
     list$[3]=esdel$
     call addtostr(e$,rstr$,list$[])
	endif
Schkcshipdone:
Else 
  include "src/callsuberr.inc"
End Try 
End sub


!----------------------------------------------------------
Sub fut208()
! if future order type - get date (mx208fut)
 Try
	dim 1%,Weeks,L3[2]
	Dim 2%,L4[3],B[24],w2[9],H5[16]
	Dim 2%,J9[9]
	Dim 3%,S7[12],j1,r8
	Dim K1$[60],k2$[60],L1$[20],J9$[50]
	let r8=REC_ROH
	READ #Ctlc,60,20;WEEKS;
	!MAT  READ #8,R8,0;H0
	!MAT  READ #8,R8,78;H4
	MAT  READ #Ch_Roh,R8,104;H5 
	if roh.CmInvHist goto foDone ! already date
	if roh.ordtype<>5 goto fodone ! wrong ot
	LET MAXLEAD=0;WHSE=roh.Wh
	LET K1$=roh.OrdNum USING "######"
	L_2010: SEARCH #Ch_RoL,3,1;K1$,R1,E !  \ IF E>2 GOSUB ERR_SEARCH:
	IF E GOTO FOLDone:
	LET X2=K1$[1,6] \ IF X2<>roh.OrdNum GOTO FOLDONE
	MAT  READ #Ch_RoL,R1,16;L4;
	MAT  READ #Ch_RoL,R1,8;L3;
	MAT  READ #Ch_RoL,R1,168;S7;
	 MAT  READ #Ch_RoL,R1,140;L1$;
	 IF L3[0]=1 GOTO L_2010:
	 LET WHSE=L4[3] \ IF WHSE<=0 OR WHSE>99 LET WHSE=roh.Wh
	 MAT  READ #Ch_Prod,L4,156;B;
	 !GOSUB L_2500:
	 !L_2500: REM PRODUCT WAREHOUSE FILE
	 LET K2$=L1$[1,12]
	 LET K2$[13,14]=WHSE USING "##"
	SEARCH #CH_PRWH,2,1;K2$,R0,E !\ IF E>1 GOSUB ERR_SEARCH:
	IF Not(E)
		MAT  READ #CH_PRWH,R0,38;W2; 
	Else
		let w2[0]=0
	Endif
	IF MAXLEAD<W2[0] LET MAXLEAD=W2[0]
	GOTO L_2010: 
	FOLDONE: ! 
	LET D0=(MAXLEAD*30)+(WEEKS*7)
	LET X2=roh.ShipDate \  J9$=PDate$(X2) ! \ GOSUB L_7700:
	X$=J9$[1,6],J9$[9,10] ! no century
	L_8120: LET X9=0 \ LET J9$=X$[1,2],X$[4,5],X$[7,8]
	LET J9[0]=J9$[1,2] \ LET J9[1]=J9$[3,4] \ LET J9[2]=J9$[5,6]
	IF J9[2]<85 LET J9[2]=J9[2]+100
	LET X=J9[0]+1 \ LET X4=INT(1/X+.7) \ LET X2=J9[2]-X4 \ LET X3=X+12*X4
	LET X4=INT(X3*30.6001)+INT(X2*365.25)+J9[1] \ LET X3=X4-7*(INT(X4/7))
	LET J9[2]=J9$[5,6]
	LET J9[1]=J9[1]-D0 \ LET D0=0
	IF J9[1]<=0 LET J9=J9-1
	L_8202: IF J9<1 LET J9=12-ABS(J9) \ LET J9[2]=J9[2]-1
	IF J9[1]>0 GOTO L_8230:
	ON J9 GOTO L_8250:,L_8270:,L_8250:,L_8240:,L_8250:,L_8240:
	ON J9-6 GOTO L_8250:,L_8250:,L_8240:,L_8250:,L_8240:,L_8250:
	L_8230: IF J9>12 LET J9=J9-12 \ LET J9[2]=J9[2]+1 \ LET X9=1 \ GOTO L_8300

	L_8240: IF J9[1]<1 LET J9[1]=J9[1]+30 \ LET X9=1 \ GOTO L_8300:
	L_8250: IF J9[1]<1 LET J9[1]=J9[1]+31 \ LET X9=1 \ GOTO L_8300:
	GOTO L_8300:
	L_8270: IF NOT(FRA(J9[2]/4)) GOTO L_8290:
	IF J9[1]<1 LET J9[1]=J9[1]+28 \ LET X9=1 \ GOTO L_8300:
	IF NOT(FRA(J9[2]/4)) GOTO L_8300:
	L_8290: IF J9[1]<1 LET J9[1]=J9[1]+29 \ LET X9=1 \ GOTO L_8300:
	L_8300: IF J9[1]<1 LET J9=J9-1 \ GOTO L_8202:
	LET J1=J9[2]*10^4+J9*10^2+J9[1] \ LET X2=J1 !\ GOSUB L_7700:
	Let j9$=PDate$(X2) \ let x$=J9$[1,6],J9$[9,10] ! no century
	IF X9 GOTO L_8120:
	LET H5[10]=X2
	MAT  WRITE #ch_roh,R8,104;H5;
	let roh.CmInvHist=h5[10]
	FODONE: ! 
 else
	include "src/callsuberr.inc"
 end try
End sub ! fut208
!----------------------------------------------------------
Sub SrchInvhCPO() ! search based upon customer code - search Customer PO
Try
	dim 2%,startdate,3%
	dim keyinvm$[50],shipflag$[1],Search_method$[1],j4$[50]                               
	dim msgword1$[20],msgword2$[20],msgword3$[20],stkey$[60]   
	!Call dxsave(0,"tmp/sihcpo.txt!")
	Call Dxget ("CUSTID",tmp$)! do not set returnstatus         
	let custid=tmp$                                             
	if custid<=0 or custid>999999                               
		let returnstatus=0                                  
		let message$="Invalid Customer Id"
		!goto EndInvCPOSrch
	endif  
	If returnstatus<>0 and custid<>prt.CashSaleCustNum
		 Custsec[0]=custid;custsec[1]=1 ! id & NO ALERT
		 call "custsec.dl4",Custsec[],ctlc,userid$,e$,rstr$
		 if custsec[0]=-1 ! not allowed
			returnstatus=0
			message$="You do not have access this customer"
			! goto EndInvCPOSrch
		 Endif
	Endif ! don't check on cash cust or cash sales
	startdate=0                                                 
	call dxget("STARTDATE",tmp$)! do not set returnstatus       
	let tmp3=tmp$                                               
	if tmp3<>0 
		tmp1$=chkDteFrmt$(e$,tmp$)
		if tmp1$[1,1]<"0" and tmp1$[1,1]>"9" let tmp1$=""
		XDATE$ = formatdate2$(tmp1$) ! from MM/DD/YYYY to   
		tmp3 = XDATE$[3,8]                                 
		! convert to julian                                 
		 XDATE$ = tmp3 Using "&&&&&&"                       
		Call DateToJulian(1,XDATE$,XDATE$,errflag)          
		If errflag                                          
			ReturnStatus = 0                            
			message$ = "Invalid Start Date Entered"     
		else                                                
			let startdate=xdate$ ! save in julian form
		End If                                          
	endif                                                   
	call dxget("WORD1",tmp$)                                
	let msgword1$=UCASE$(RTRIM$(tmp$))
	call dxget("WORD2",tmp$)                                
	let msgword2$=UCASE$(RTRIM$(tmp$))
	call dxget("WORD3",tmp$)                                
	let msgword3$=UCASE$(RTRIM$(tmp$))
	call dxget("SHOWSHIPTO",tmp$)                           
	let shipflag$="N"                                       
	if ucase$(rtrim$(TMP$))="Y" let shipflag$="Y"            
	let shiptocode=0                                        
	if shipflag$="Y"                                        
		call dxget("SHIPTOCODE",tmp$)                   
		let shiptocode=tmp$                             
	endif                                                   
	LET WORDS2MATCH=0                                       
	IF rtrim$(msgword1$)<>"" LET WORDS2MATCH=WORDS2MATCH+1        
	IF rtrim$(msgword2$)<>"" LET WORDS2MATCH=WORDS2MATCH+1        
	IF rtrim$(msgword3$)<>"" LET WORDS2MATCH=WORDS2MATCH+1
	call dxget("EXACT",tmp$)
	let exact=0
	if rtrim$(ucase$(tmp$))="Y" let exact=1
	call dxget("LOGIC",tmp$)
	let search_method$=rtrim$(ucase$(tmp$))
	IF Search_method$<>"A" AND Search_method$<>"O"
		let returnstatus=0
		let message$="Invalid Logic Selection Entered"
	endif
	!! added availability of sending multiple packets (no words?)
	call dxget("CURKEY",tmp$) ! for the more option
	STKey$=RTrim$(tmp$) ! will have leading space stripped!!?
	if stkey$="" goto Startscan4 ! 1st time in?
	ChkLenSt4: ! SEARCH KEY IS DIR 2: CCCCCCIIIIIIIIII
		if len(stkey$)<16 ! add back in to begin
		  tmp$=" "+stkey$ ! 1 is ALWAYS Customer
		  stkey$=tmp$
		  goto chklenst4
		Endif
		! ok now 16 - see if spaces in middle gone?
		x3=stkey$[1,6];x3[1]=stkey$[7,16] ! default - cust 6 / inv 10
		for x=16 to 7 step -1
			if stkey$[x,x]=" " ! found 1st space from end
				x3=stkey$[1,x] ! first #
				x3[1]=stkey$[x+1] ! second
				x=0 ! end loop
			Endif
			! if none after 6 - it's a full 6 digit # ! use as is
		Next x
		let stkey$[1,6]=x3 using "######"
		if x3[1]>0 let x3[1]=x3[1]-1 ! as its mode 3 - minus 1 to start at last one sent
		let stkey$[7,16]=x3[1] using "##########" 
	StartScan4: ! do it
	Clear list$[]
	List$[0] = bsdel$,"InvoiceHistPOSearch",fdel$
	webstr$=""
	webstr$ = webstr$,"InvNum",fdel$   
	webstr$ = webstr$,"InvType",fdel$  
	webstr$=  webstr$,"InvDate",fdel$  
	! webstr$=webstr$,"Line",fdel$
	webstr$=webstr$,"CustPO",fdel$
	!Tmp$=""
	!if shipflag$="Y"
		Tmp$="ShipInfo"
	!endif
	Webstr$=webstr$,tmp$,fdel$
	List$[1] = webstr$ 
	if not(returnstatus) goto EndInvCPOSrch:! MTG
	MaxRow=4000 ! as they're small
	row = 2;tmpcnt = maxcnt 
	LET Keyinvh$=" ",Keyinvh$;Keyinvh$=custid using "######"
	if stkey$<>"" let keyinvh$=Stkey$ ! a resume of search
	do                                                      
		SEARCH #CH_INVH,3,2;Keyinvh$,rec_invh,E
		if e<>0 exit do                             
		let tmp3=keyinvh$[1,6]\if tmp3<>custid exit do                          
		read record #ch_invh,rec_invh,0;invh.;                                  
		read record #ch_invs,invh.ShipRec,0;invs.;                              
		if shipflag$="Y" and shiptocode<>0                                     
			if ros.ShipEdit<>2 goto getnextinvhr:                           
			if ros.ShipEdit=2 and shiptocode<>invs.shipcode goto getnextinvhr
		endif                                                                   
		if startdate<>0                                                         
			let xdate$=invh.InvDate using "&&&&&&"                                         
			Call DateToJulian(1,XDATE$,XDATE$,errflag)                      
			if errflag<>0                                                   
				goto getnextinvhr:      ! get next invoice              
			endif
			let tmp3=xdate$
			if tmp3<startdate goto getnextinvhr:                            
		endif                                                                   
		tmp1$=UCase$(RTRIM$(invh.CustPO$ )) ! compare in same case
			let chkctr=0                                  
			IF msgword1$="" AND msgword2$="" AND msgword3$=""              
				let chkctr=1                         
			else   
				if tmp1$="" goto getnextinvhr ! no po - no show
				if rtrim$(msgword1$)<>""                              
					let pass=0 
					if Exact<>0
						if Tmp1$=msgword1$ let pass=1
					else
						search tmp1$[1],msgword1$,pass
					endif
					if pass<>0 let chkctr=chkctr+1   
				endif                              
				if rtrim$(msgword2$)<>""                              
					let pass=0                 
					if Exact<>0
						if tmp1$=msgword2$ let pass=1
					else
						search tmp1$[1],msgword2$,pass
					endif
					if pass<>0 let chkctr=chkctr+1   
				endif                              
				if rtrim$(msgword3$)<>""                              
					let pass=0                 
					if Exact<>0
						if tmp1$=msgword3$ let pass=1
					else
						search tmp1$[1],msgword3$,pass
					endif
					if pass<>0 let chkctr=chkctr+1   
				endif                           
				IF SeaRCH_METHOD$="A" ! all words must match 
					if chkctr<>WORDS2MATCH let chkctr=0      
				endif                                      
			endif  
			if chkctr<>0! print the webstr$
				webstr$=""
				webstr$ = webstr$,str$(invh.InvNum),fdel$ 
				let tmp$="INV"
				if invh.Status=31 let tmp$="C/M"
				webstr$ = webstr$,rtrim$(tmp$),fdel$ 
				If invh.InvDate <> 0                                     
					xdate$ = pdate$(invh.InvDate)                          
				Else                                                     
					xdate$ = " ",xdate$                                    
				End If                                                   
				webstr$ = webstr$,RTrim$(xdate$),fdel$ ! cm/inv date date  
				!webstr$=webstr$,str$(invm.MessageLine),fdel$
				webstr$=webstr$,rtrim$(invh.CustPO$),fdel$
				Tmp$=""
				if shipflag$="Y"
					IF invs.ShipEdit=0 tmp$="SAME"             
					IF invs.ShipEdit=1 tmp$="DEFAULT SHIPLIST" 
					IF invs.ShipEdit=2 tmp$="SHIPLIST # "+str$(invs.ShipCode)
					IF invs.ShipEdit=4 tmp$="CUSTOMER "+str$(invs.ShipCust)  
					IF invs.ShipEdit=5 tmp$="MANUAL ENTRY"     
				Endif
				if row>maxrow+1 ! ALLOW FOR HEADER & this line
					returnstatus=5 ! special status to tell web MORE TO COME
					message$="CURKEY="+Keyinvh$+"&"
					exit do ! reached limit
				Endif
				Webstr$=webstr$,tmp$,fdel$
				List$[row] = webstr$                                              
				row = row + 1 \ If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])                                                                              
			Endif
				
		getnextinvhr: ! get next invhm line                        
	loop ! loop for the invh file 
	EndInvCPOSrch:! 
	Call AddToStr(e$,rstr$,List$[])                 
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
else
	include "src/callsuberr.inc"! ERROR 
end try
End Sub ! SrchInvhCPO
!--------------------------------------------------------------------------------
Sub gpsumm()
! send summary of g/p for lines
  Try
	
	Dim 2%,row,tmpcnt
	Dim 3%,tmp3,x3[9]
	tmpcnt=maxcnt
	ReturnStatus=1
	Message$="OK"
	call dxget("CUSTID",tmp$)
		let custid=tmp$
		call dxget("REFID",tmp$)
		let refid=tmp$
		call dxget("STATUS",tmp$)
		let reftype=0
		if rtrim$(ucase$(tmp$))="INV" let reftype=30
		if rtrim$(ucase$(tmp$))="C/M" let reftype=31
	if custid<=0 or custid>999999
		let returnstatus=0
		let message$="Invalid Customer Code "
	Else
		let keycust$=custid using "######"
		search #ch_cust,2,1;keycust$,rec_cust,e
		if e<>0
			let returnstatus=0
			let message$="Customer Code "+str$(custid)+" Not On File"
		else
			read record #ch_cust,rec_cust,0;cust.;
			if refid<=0 or refid>99999999
				let returnstatus=0
				let message$="Invalid Reference Number"
			else
				let keyinvh$=" ",keyinvh$
				let keyinvh$[1,6]=custid using "######"
				let keyinvh$[7,16]=refid using "##########"
				Search #ch_invh,2,2;keyinvh$,rec_invh,e
				if e<>0
					returnstatus=0
					let message$="Reference Number "+str$(refid)+" For Customer "+str$(custid)+" Not On File"
				else
					read record #ch_invh,rec_invh,0;invh.;
					read record #ch_invs,invh.shiprec,0;invs.;
					read record #ch_invt,invh.totrec,0;invt.;
				endif
			endif
		endif
	endif
	if returnstatus=0 goto GGPDone
	CREDIT=0 \ if invs.status=32 let credit=1
	if credit and invh.ShipType=3 let cost_lev[1]=0 ! no cost on cm price error
	Clear List$[]
		List$[0]=bsdel$,"GPREVIEW",fdel$
		WebStr$="LineNum",fdel$,"ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$
		webstr$=webstr$,"OrdCost",fdel$,"OrdPrice",fdel$,"OrdGPDol",fdel$,"OrdGPPct",fdel$
		webstr$=webstr$,"ShpCost",fdel$,"ShpPrice",fdel$
		webstr$=webstr$,"ShpGPDol",fdel$,"ShpGPPct",fdel$
		List$[1]=webstr$
		Row=2
	! okay - see if lines
	keyinvl$=" ",keyinvl$;NumLines=0
	keyinvl$=Refid Using "##########"
	! what if start with or only zlines on order??
	Do
		Search #ch_invl,3,1;keyinvl$,rec_invl,e
		if e<>0 exit do
		let tmp3=keyinvl$[1,10]\if tmp3<>refid exit do
		Read Record #ch_invl,rec_invl,0;invl.;
		if (invh.OrdType=21 or invh.OrdType=22) and keyinvl$[11,13]="   " goto bpgpdtl ! ot 21/22
		NonStk=invl.NStkItem
		ZLine=0 \ if invl.LineType=3 and NonStk let ZLine=1 ! need for later
		if zline goto bpgpdtl ! no data to send
		! load data - NO Conversions needed!
		webstr$=Str$(invl.LineNum),fdel$
		webstr$=webstr$,RTrim$(invl.ProdCode$),fdel$,RTrim$(invl.Desc1$),fdel$
		webstr$=webstr$,RTrim$(invl.Desc2$),fdel$
		! first ordered
		if cost_lev[1]
			webstr$=webstr$,LTrim$(invl.ExtLoadOrd using QMask$),fdel$
		Else
			webstr$=webstr$,"0",fdel$
		Endif
			webstr$=webstr$,LTrim$(invl.ExtOrdAmt using QMask$),fdel$
			X3=invl.ExtOrdAmt-invl.ExtLoadOrd ! ext'd gp
			X3[1]=0
			if invl.ExtOrdAmt
				let x3[1]=FNR((x3/invl.ExtOrdAmt)*100)
			Endif
		if cost_lev[1]=0 let x3=0;x3[1]=0 ! alt - no cost/gp$
			webstr$=webstr$,LTrim$(X3 using QMask$),fdel$
			webstr$=webstr$,LTrim$(X3[1] using QMask$),fdel$
		!Else ! no cost sec
		!	webstr$=fdel$,Ltrim$(rol.ExtOrdAmt using QMask$),fdel$
		!	webstr$=webstr$,fdel$,fdel$ ! no cost or gp
		!Endif
		! now shipping
		If cost_Lev[1]
			webstr$=webstr$,LTRim$(invl.ExtLoadShip using QMask$),fdel$
		Else
			webstr$=webstr$,"0",fdel$
		Endif
		webstr$=webstr$,LTrim$(invl.ExtShipAmt using QMask$),fdel$
		X3=invl.ExtShipAmt-invl.ExtLoadShip ! ext'd gp
		X3[1]=0
		if invl.ExtShipAmt
			let x3[1]=FNR((x3/invl.ExtShipAmt)*100)
		Endif
		if cost_lev[1]=0 let x3=0;x3[1]=0 ! alt - no cost/gp$
		webstr$=webstr$,LTrim$(X3 using QMask$),fdel$
		webstr$=webstr$,LTrim$(X3[1] using QMask$),fdel$
		!Else ! no cost sec
		!	webstr$=fdel$,Ltrim$(rol.ExtShipAmt using QMask$),fdel$
		!	webstr$=webstr$,fdel$,fdel$ ! no cost or gp
		!Endif
		List$[row]=WebStr$
		Let row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	BPGPDtl: ! zlines no gp
	Loop
	LIST$[ROW]=esdel$
	e$=""
	call addtostr(e$,rstr$,List$[])
	GGPDone: ! finished
	! status section
	e$=""
	!
	!  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	!  call AddToStr(e$,rstr$,WebStr$)
	!  call SetOutPut(e$,rstr$)
  else
    include "src/callsuberr.inc"
 end try
end sub ! gpsumm
! 
!--------------------------------------------------------------------
!--------------------------------------------------------------------------------
Sub verifystat()
! verify status on save data 
! header record needs to read first
  Try
	
	if returnstatus<>1
		goto endverifystat: ! already has error
	endif
	Call dxget("SOURCE",tmp$)
	let tmp3=tmp$
	if tmp3=207 goto endverifystat: ! inquiry
	
	if credit<>0
		if roh.status<>97
			let returnstatus=99
			let message$="Credit is no longer in an edit status. Data is not saved. "	
		endif
		goto endverifystat:
	endif
	if tmp3=251 or tmp3=231
		if roh.status<>94
			let returnstatus=99
			let message$="Invoice is not longer in an edit status. Data is not saved. "
		endif
		goto endverifystat:
	endif
	if tmp3=223 
		if roh.status<>96 and roh.status<>95 and roh.status<>94
			let returnstatus=99
			let message$="Invoice is no longer in an edit status. Data is not saved. "
		endif
		goto endverifystat:
	endif
	If not(tmp3) 
		if roh.status<94  or roh.status>96
			let returnstatus=99
			let message$="Order is no longer in an edit status. Data is not saved. "
		endif
		goto endverifystat:
	endif
	if roh.status<>95
		let returnstatus=99
		let message$="Order is no longer in an edit status. Data is not saved. "
	endif
	endverifystat: ! end the status check
		

	! status section
	e$=""
	!
	!  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	!  call AddToStr(e$,rstr$,WebStr$)
	!  call SetOutPut(e$,rstr$)
  else
    include "src/callsuberr.inc"
 end try
end sub ! verifystat
! 
!--------------------------------------------------------------------

Sub OnHoldChk()
	! does gp exceptions - returns flags set
	! roh/rot files should have already been read
	! holdcode flag should already have been read and set prior
Try
	Dim PrFlg$[10]
	if credit<>0 goto ONHChkDone  ! no holds on credit
	if roh.ordtype=16 or roh.ordtype=37 goto ONHChkDone ! no hold on warehouse transfer
    if roh.ordtype=20 goto ONHChkDone ! no hold on Future orders
	if roh.ordtype=8  goto ONHChkDone ! no hold on consignments
	if roh.holdover<>0 goto ONHChkDone ! hold override in effect
	clear holddesc$[]
	clear holdpswd$[]
	! clear holdcodeflag[]
	
	for ctr=1 to 12
		read #ctlc,65,((ctr*16)-16);holddesc$[ctr];
		read #ctlc,66,((ctr*16)-16);holdpswd$[ctr];
	next ctr
	clear ex[]
	overpswd$=""
	Ch_exlist = openfile(1760,intCo) \ If Ch_exlist = -1 Error 42     !"order lines file
	if ch_exlist>0
		mat read #ch_exlist,0,0;overpswd$;
		mat read #ch_exlist,roh.ordtype,0;ex;
		try close #ch_exlist  Else Rem
	endif
	! unpack the holdcode into flag from bit flag field
	tmp3=rot.holdcode 
	for ctr=1 to 12   
 		if ctr<>1 LET holdcodeflag[ctr]=SGN(FRA(tmp3/2))
		LET tmp3=INT(tmp3/2)
	next ctr   
 	! do gross profit check ! need ex variable
	if rtrim$(holdpswd$[2])<>"" ! has a password check for gp  
		let holdcodeflag[2]=0
		if rot.subtot>0                                   
			let tmp3=0 ! for setting gtm
			if rot.subtot let tmp3=(rot.subtot-rot.TotShipCost)/rot.subtot*100                            
			if ex[15]<>0 and  tmp3<ex[15] let holdcodeflag[2]=1
			if ex[16]<>0 and tmp3>ex[16] let holdcodeflag[2]=1                         
 			IF EX[1] and (rot.subtot-rot.totshipcost)<EX[1] LET holdcodeflag[2]=1                  
			IF EX[2] and (rot.subtot-rot.totshipcost)>EX[2] LET holdcodeflag[2]=1
		endif
	else
		let holdcodeflag[2]=0
	endif  
	let keyrol$=" ",keyrol$
	let keyrol$=orderid using "######"
	dir=1
	let merchamt=0
	mode$=">"
	DO	! get gp on lines
		rec_tmp=filegetrolz(e$,ch_rol,mode$,dir,keyrol$,rol.)
		if rec_tmp<=0 exit do
		let tmp3=keyrol$[1,6]\if tmp3<>orderid exit do
		if rol.QtyShip<=0 goto bpgpln ! no or neg shipping
		IF rol.LineType=3 goto bpgpln ! message
		if rol.NStkItem=0 ! product
			Mat read #CH_PROD,rol.PDRecNum,1056;prflg$;
		Else
			prflg$=" ",prflg$
		Endif
		let merchamt=merchamt+ROL.ExtOrdAmt
		if (roh.ordtype=21 or roh.ordtype=22) and keyrol$[7,9]="   " goto bpgpln
		let tmp3=rol.extshipamt-rol.extloadship
		If prflg$[2,2]="Y" Goto BPLNGP ! let holdcodeflag[2]=0;holdcodeflag[7]=0
		! gp amd gp%
		if ex[3]<>0 and tmp3<ex[3] let holdcodeflag[2]=1 ! gp
		if ex[4]<>0 and tmp3>ex[4] let holdcodeflag[2]=1 ! gp
		if ex[17]<>0 and rol.extshipamt=0 let holdcodeflag[2]=1
		if rol.extshipamt<>0
			if ex[17]<>0 and  fnr((tmp3/rol.extshipamt)*100)<ex[17] let holdcodeflag[2]=1
			if ex[18]<>0 and  fnr((tmp3/rol.extshipamt)*100)>ex[18] let holdcodeflag[2]=1
		endif
		if holdcodeflag[2]=0
			CALL LP1Chk()
		endif
		BPLNGP: ! flagged no check
		! for invoices only ! merchandise exception
		if source>=221 and source<241 ! invoice status only
			if rtrim$(holdpswd$[7])<>"" and prflg$[2,2]<>"Y" ! merchandise exception
				IF EX[9]<>0 and rol.ExtOrdAmt<EX[9] LET holdcodeflag[7]=1     
				IF EX[10]<>0 and rol.ExtOrdAmt>EX[10] LET holdcodeflag[7]=1
			endif
			if rtrim$(holdpswd$[8])<>"" ! cost exception
				IF EX[13]<>0 and rol.ExtLoadOrd<EX[13] LET holdcodeflag[8]=1  
				IF EX[14]<>0 and  rol.ExtLoadOrd>EX[14] LET holdcodeflag[8]=1
			endif
		endif
		
		! check roh.orgstatus for invoice/credit memo hold
		BPGPLN: ! BYPASS	
	LOOP
	if source>=221 and source<241 ! INVOICES ONL		
		if rtrim$(holdpswd$[7])<>"" ! has a password merchandise exception                            
			IF EX[7]<>0 and rot.subtot<EX[7] LET holdcodeflag[7]=1                           
			IF EX[8]<>0 and rot.subtot>EX[8] LET holdcodeflag[7]=1 
		else
			let holdcodeflag[7]=0
		endif
		if rtrim$(holdpswd$[8])<>"" ! has a password merchandise exception
			IF EX[11]<>0 and rot.TotShipCost<EX[11] LET holdcodeflag[8]=1                        
			IF EX[12]<>0 and rot.TotShipCost>EX[12] LET holdcodeflag[8]=1 
		else
			let holdcodeflag[8]=0
		endif
		if rtrim$(holdpswd$[4])<>"" ! freight exception
			IF EX[5]<>0 and rot.FrgtChrg+H6[6]<EX[5] LET holdcodeflag[4]=1                                               
			IF EX[6]<>0 and rot.FrgtChrg+H6[6]>EX[6] LET holdcodeflag[4]=1 
		else
			let holdcodeflag[4]=0
		endif
		if rtrim$(holdpswd$[2])<>"" ! gp exception
			LET tmp3=roh.TotDol4Prof - roh.TotCost4Prof ! H5[13]-H5[14]
			IF EX[15]<>0 and not(roh.TotDol4Prof) LET holdcodeflag[2]=1 
			IF roh.TotDol4Prof<>0 and EX[15]<>0 
				if FNR((tmp3/roh.TotDol4Prof)*100)<EX[15] LET holdcodeflag[2]=1
			endif
			IF roh.TotDol4Prof<>0 and EX[16]<>0
				if FNR((tmp3/roh.TotDol4Prof)*100)>EX[16] LET holdcodeflag[2]=1
			endif
		else
			let holdcodeflag[2]=0
		endif
	endif ! 
	if rtrim$(holdpswd$[2])="" let holdcodeflag[2]=0
	if rtrim$(holdpswd$[6])="" let holdcodeflag[6]=0
	if rtrim$(holdpswd$[7])="" let holdcodeflag[7]=0
	if rtrim$(holdpswd$[8])="" let holdcodeflag[8]=0
	ONHChkDone: ! finished
else
    include "src/callsuberr.inc"
end try
end sub ! onholdchk
! 
!--------------------------------------------------------------------

Sub dochalert()
! order put on credit hold - send alert
Try
	clear chan[]
	clear tmprec[]
	tmprec[0]=3 ! alert #3
	chan[1]=ctlc;chan[2]=ch_cust;chan[3]=Ch_sslsm
	chan[4]=ch_roh;chan[5]=ch_ros;chan[6]=ch_rot
	tmprec[1]=rec_cust;tmprec[2]=custid;tmprec[3]=roh.SlsmNum
	tmprec[4]=rec_roh
	clear tmp$
	call "libalertproc.lib",tmprec[],chan[],tmp$
	! done - tmp$ holds message
else
    include "src/callsuberr.inc"
end try
end sub ! dochalert
! 
!--------------------------------------------------------------------
SUB LP1CHK()
	! see if over % allowed
  Try
	Dim k1$[60],k2$[60]
	Dim 2%,disccap
	Dim 3%,A[33],w3[24],r[99]
	if rol.NStkItem goto LP1CDone ! no lp1 on nonstks!
	Spcl=1
	if rol.PriceOrigin<0 or rol.PriceOrigin=1 OR rol.PriceOrigin=4 OR rol.PriceOrigin=5 LET SPCL=0
	IF rol.PriceOrigin=9 OR rol.PriceOrigin=10 OR rol.PriceOrigin=14 LET SPCL=0
	IF spcl goto LP1CDone ! special/contract price - no check!
	! got prod already - during process_line (need to recalc list 1? - hope not)
	Mat read #Ch_Prod,rol.PDRecNum,256;a;
	k1$=" ",k1$;k1$=rol.ComdtyCode$
	search #ch_comcde,2,1;k1$,r[80],E
	if e Goto LP1CDone ! no commcode - no percent!
	read #ch_comcde,r[80],58;disccap;
	if disccap<=0 or disccap>100 goto LP1CDone ! no need to check further - no/invalid min %
	LPRc1=a[20] ! list 1
	if p9$[32,32]="Y" ! whse pricing
		let k2$=" ",k2$;k2$[1,12]=rol.ProdCode$;k2$[13]=rol.Whse using "##"
		Search #Ch_PrWh,2,1;k2$,r[81],e
		if not(e)
			mat read #ch_prwh,r[81],78;w3;
			if w3[19]>0 let LPRC1=w3[19] ! only if non-zero
		Endif
	Endif
	! got list 1 - check percent lowest price allowed
	let DLP1=LPRC1-(LPRC1*(DISCCAP/100)) ! min price allowed (lp1-(lp1*disc))
	if rol.NetPrice<DLP1 let holdcodeflag[2]=1 ! fail - put gp hold ! Net or unit? let's use NET
	LP1CDone: ! finished
  else
    include "src/callsuberr.inc"
end try
end sub ! lp1chk
! 
!--------------------------------------------------------------------
Sub ChkBPO()
  ! blanket po check/get
  ! bpflag[1]=1 on customer, bpflag[1]=9 on shiplist
  Dim tbpo$[20] ! just a dummy for call (along with x$)
  Try
	Let BPFlag[2]=0;BPFlag[4]=0;BPFlag[5]=0 ! "no errors
	Let X$=roh.OrdDate Using "&&&&&&"
	call DatetoJulian(1,x$,x$,E) \ if e let x$="00000"
	Let jdate[1]=x$
	If BPFlag[1]=1 or BPFlag[1]=9 ! "check ordering customer
	  Let X2=CUSTID;x2[1]=-1;BPFlag=1 ! "get info customer ONLY
	  Call "CSBUDGINFO.DL4",X2,X2[1],BPFlag,TBPO$,x$,x3[],Intco
	  If Trim$(cust.BlanketPo$)<>"" Let BPFlag[4]=1 ! has custbpo
	  If cust.BlktPoType$="B" OR cust.Budget>0 ! "budget needs checking
		If cust.Budget<=(cust.BudgetUsed+X3[2]) Let BPFlag[2]=1 \ Goto Ecbpchk: ! "Budget USED UP!
	  Endif
	  If cust.BlktPoType$="D" and cust.DateBPStart>0 ! "check date range
		Let X$=cust.DateBPEnd Using "&&&&&&"
		call DatetoJulian(1,X$,X$,E) \ if e Let X$="00000"
		Let JDate[2]=x$[1,5] ! "expire in julian
		Let X2=JDate[1]-JDate[2] ! "diff in days (order-expire)
		If roh.OrdDate<cust.DateBPStart or (roh.OrdDate>cust.DateBPEnd And X2>0) Let BPFlag[2]=0 \ Goto ecbpchk: ! "order date outta 
	  Endif
	  If Trim$(cust.BlanketPo$)="" Goto Ecbpchk:
	  Let BPo$=cust.BlanketPo$ ! "made it here, it's usable
	Ecbpchk: ! "done with customer
	Endif
	If BPFlag[1]=9 ! "now just shiplist (if no shiplist bpo used-still try customer)
	  If Trim$(sh.BlktPo$)<>"" Let BPFlag[5]=1 ! has shipbpo
	  Let X2=CUSTID;x2[1]=shipcode;BPFlag=1 ! "get info customer/ShipList
	  Call "CSBUDGINFO.DL4",X2,X2[1],BPFlag,TBPO$,X$,x3[],Intco
	  If X2[1]<0 Let X3[2]=0
	  If sh.BPExpireType$="B" OR sh.Budget>0 ! "check if over budget
		If Sh.Budget<=(Sh.BudgetUsed+X3[2]) Let BPFlag[2]=3 \ goto esbpchk: ! "budget used up!
	  Endif
	  If sh.BPExpireType$="D" and sh.BPDateStart>0 ! "check date range
		Let X$=Sh.BPDateEnd Using "&&&&&&"
		call DatetoJulian(1,X$,X$,E) \ if e Let X$="00000"
		Let JDate[2]=x$[1,5] ! "expire in julian
		Let X2=JDate[1]-JDate[2] ! "diff in days (order-expire)
		If roh.OrdDate<sh.BPDateStart or (roh.OrdDate>sh.BPDateEnd And X2>0) Let BPFlag[2]=0 \ goto esbpchk: ! "orddate outta range
	  Endif
	  If Trim$(sh.BlktPo$)="" goto Esbpchk:
	  Let BPo$=sh.BlktPo$ ! "it's here, it's usable
	Esbpchk: ! "done with shiplist
	Endif
	If BPFlag[2] and BPFlag[2]<>BPFlag[3] ! "something failed - how to handle on web??
	  !Qorbpo: ! "override failure
	  !If BPFlag[4] Or BPFlag[5] ! "has blanket po
	  ! Print @0,22;'rbce';"THE BLANKET PO # CANNOT BE USED BECAUSE OF"
	  !Else
	  ! Print @0,23;
	  !Endif
	  !If BPFlag[2]<3 Print "Customer File ";
	  !if BPFlag[2]>2 print "Shiplist File ";
	  !If BPFlag[2]=1 or BPFlag[2]=3 Print "is over Budget.";
	  !if BPFlag[2]=2 or BPflag[2]=4 Print "is out of date.";
	  !If BPFlag[4] or BPFlag[5] ! "one has blanket po
	!	Print " USE BLANKET PO ANYWAY? Y/N  ";
	  !Else
	!	Print " PRESS <CR> TO CONTINUE  ";
	  !Endif
	  !Input Len 16384+1;""X$ \ Call $String,1,X$
	  !If Not(BPFlag[4]) And Not(BPFlag[5]) Let X$="N"
	  !If X$<>"N" And X$<>"Y" Goto QORBPO:
	  !If X$="Y"
	!	If BPFlag[2]<3 and BPFlag[4] Let P0$=BPO$ ! "use customer
	!	If BPFlag[2]>2 and BPflag[5] Let p0$=SLBPO$ ! "use shiplist
	  !Endif
	Endif
	Let BPflag[3]=BPflag[2] ! "retain so doesn't ask again
	Let BPFlag[1]=0 ! "reset type check
  else
    include "src/callsuberr.inc"
  end try
end sub ! chkbpo
! 
!--------------------------------------------------------------------
function getmillitmflag$()
! see if any line on order has mill items
  Try
	Dim Key1$[60],k5$[60],l0$[20],k2$[60],k3$[60],F$[20]
	DIM 1%,ordl3[3],pgmlit,APMI,PRW1[2],miflag[9],flags[15]
	dim 2%,ordl4[3],prw2[9]
	Dim 3%,WHMISC2[7],ordl7[12],R[99]
	let miflag$="N" ! none = default
	clear miflag[]
	CH_PGP=OpenFile(-9965,IntCo) \ if ch_pgp=-1 error 42 ! prodgrp
	ch_sot=findchannel()
	F$="3/SORDTYPE"+Str$(IntCo) \ ROpen #ch_sot,F$
	if source<>201 and source<>208 goto MIDone ! Only orders
	! first the sordtype check
	LET X3=rot.HoldCode ! unpack hold flags
	FOR CTR=1 TO 12                          
		LET FLags[CTR]=SGN(FRA(X3/2));X3=INT(X3/2)
	NEXT CTR 
	! if flags[1] goto MIdone ! credit hold - still chk for any mill items anyway
	! 2,4,5,7,8,9,15,16,20,21,22 = ORDER TYPES TO EXCLUDE
	!IF H5[7]=2 OR H5[7]=4 OR H5[7]=5 OR H5[7]=7 GOTO MIDone
	!IF H5[7]=8 OR H5[7]=9 OR H5[7]=15 OR H5[7]=16 OR H5[7]=20 GOTO MIDone
	!IF H5[7]=21 OR H5[7]=22 GOTO MIDone
	! now in sordtype file
	Key1$=" ",Key1$
	Key1$=roh.OrdType using "##"
	search #ch_sot,2,1;Key1$,R[2],E
	if e goto MIdone ! not there - not allowed!
	read #ch_sot,r[2],48;APMI;
	IF APMI<>1 GOTO MIdone ! NOT A Y - no po for this ordtype
	LET K5$=" ",K5$
	K5$[1,6]=roh.ordnum USING "######"
	CHK_ROLLOOP: ! 
	SEARCH #CH_ROL,3,1;K5$,R[5],e 
	IF E GOTO MIdone
	X2=K5$[1,6] \ IF X2<>roh.ordnum GOTO MIdone
	MAT READ #CH_ROL,R[5],8;ORDL3;
	IF ORDL3[0]=1 GOTO CHK_ROLLOOP ! NO PRDGRP ON NON-STOCKS!!
	if ordl3[1]=1 goto chk_rolloop ! updates stock - that is not mill
	mat read #ch_rol,r[5],16;ordl4; ! rec/po/whse
	if ordl4[3]<1 or ordl4[3]>99 or fra(ordl4[3]) let ordl4[3]=roh.Wh ! whse check
	mat read #ch_rol,r[5],140;l0$; ! prodcode
	mat read #ch_rol,r[5],168;ordl7; ! quantity
	if ordl7[2]<=0 goto chk_rolloop ! no order qty - ignore
	let k2$=" ",k2$
	k2$[1,12]=l0$[1,12] ! prodwhse for prodgroup
	k2$[13]=ordl4[3] using "##"
	search #ch_prwh,2,1;k2$,r[3],e
	if e goto chk_rolloop ! not found = no prodgrp!
	mat read #ch_prwh,r[3],32;prw1;
	mat read #ch_prwh,r[3],38;prw2;
	mat read #ch_prwh,r[3],846;WHMISC2;
	pgmlit=0
	if whmisc2[0]>0 and whmisc2[0]<1000 ! if no prodgrp - it's not a millitem
		K3$=" ",k3$
		k3$=whmisc2[0] using "###" ! 3
		search #ch_pgp,2,1;k3$,r[4],e
		if not(e)
			read #ch_pgp,r[4],136;pgmlit;
		endif
	endif
	if pgmlit<>1 goto chk_rolloop ! not a mill item!
	miflag[0]=miflag[0]+1 ! number of mill items
	if ordl4[2]<>0 let miflag[1]=miflag[1]+1 ! already on po 
	miflag$="Y" ! there are mill items
	goto chk_rolloop
	MIdone:! done
	try close #ch_pgp else rem
	try close #ch_sot else rem
	if miflag$="Y" and flags[1] let miflag$="H" ! on hold with mill items
	if miflag$="Y" and miflag[0]>0 and miflag[0]=miflag[1] let miflag$="D" ! just display po's
  else
    include "src/callsuberr.inc"
  end try
end Function miflag$ ! getmillitmflag$
!--------------------------------------------------------------------------------
Sub showmillitems(miflag$)
! section in getordtot to show mill items on po already
  try
	Dim k2$[60],k3$[60]
	Dim 1%,PGMLit
	dim 3%,WHMisc2[7],R[99]
	clear list$[]
	list$[0]=bsdel$,"MILLITEMS",fdel$
	list$[1]="LINENO",fdel$,"PRODID",fdel$,"DESC",fdel$,"PONUM",fdel$
	let row=2;tmpcnt=maxcnt
	CH_PGP=OpenFile(-9965,IntCo) \ if ch_pgp=-1 error 42 ! prodgrp
	if miflag$="N" or miflag$="" goto smidone ! no mill items!
	let keyrol$=" ",keyrol$;keyrol$=roh.ordnum using "######"
	SMILoop: ! loop it
	search #ch_rol,3,1;keyrol$,rec_rol,e
	if e goto smidone
	x2=keyrol$[1,6] \ if x2<>roh.ordnum goto smidone
	read record #CH_ROl,rec_rol,0;rol.;
	if rol.NStkItem goto SMILoop ! no nonstocks
	if rol.UpdtStk goto SMILoop ! if update stk - not mill item
	if rol.QtyOrd<=0 goto SMILoop ! no order qty - not mill item
	if rol.Whse<1 or rol.Whse>99 or fra(rol.Whse) let rol.whse=roh.wh
	k2$=" ",k2$
	k2$=rol.ProdCode$+Blank$
	k2$[13]=rol.whse using "##"
	search #ch_prwh,2,1;k2$,rec_prwh,E
	if e goto SMILoop ! no prodwhse rec - no prodgroup - not mill item
	mat read #ch_prwh,rec_prwh,846;WHMISC2;
	pgmlit=0
	if whmisc2[0]>0 and whmisc2[0]<1000 ! if no prodgrp - it's not a millitem
		K3$=" ",k3$
		k3$=whmisc2[0] using "###" ! 3
		search #ch_pgp,2,1;k3$,r[4],e
		if not(e)
			read #ch_pgp,r[4],136;pgmlit;
		endif
	endif
	if pgmlit<>1 goto SMIloop ! not a mill item!
	! it's a mill item - send data
	webstr$=Str$(rol.LineNum),fdel$
	webstr$=webstr$,RTrim$(rol.ProdCode$),fdel$
	webstr$=webstr$,RTrim$(rol.Desc1$)," ",RTrim$(rol.Desc2$),fdel$
	if rol.PONum
		webstr$=webstr$,Str$(rol.PONum),fdel$
	Else
		webstr$=webstr$,"None yet",fdel$
	endif
	list$[row]=webstr$
	row=row+1 \ If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
	goto SMILoop ! next line
	SMIDone: ! finished
	list$[row]=esdel$
	try close #ch_pgp else rem
  else
    include "src/callsuberr.inc"
  end try
end Sub ! getmillitmflag$

Sub OpenDrawer()
!-------------------------------------------------------------------
! opens cash drawer
 try
	                                                      
	DIM SYS$[70],Z2$[50]                               
	if prt.CashDrawPort <>0                           
	    if prt.CashDrawPort = -1 or prt.CashDrawPort > 500 goto CASHDRAW2
		LET SYS$=" ",SYS$                                                 
		LET Z2$=rec_uac USING "/tmp/tt&&&&&&" ! "port #                        
		LET SYS$="portdev ",prt.CashDrawPort," > ",Z2$                              
		SYSTEM SYS$  
		ch_drawer=findchannel()
		OPEN #ch_drawer,Z2$                                                       
		READ #ch_drawer;Z2$                                                       
		CLOSE #ch_drawer                                                        
		LET SYS$="echo '",prt.DrawOpen$,"'>",Z2$ ! "pop drawer (system port)  
		SYSTEM SYS$                                                       
            CASHDRAW2: ! NETWORK CASH DRAWER
            !! NOTE 9100 PORT # IS HARDCODED, BUT ONLY LEFT IN FOR FORM
            !! ACTUAL SCRIPT WILL HAVE THE PORT HARDCODED IN IT-WMB 8/2017
            if prt.CashDrawPort = -1 or prt.CashDrawPort > 500 
              LET SYS$=" ",SYS$
              LET SYS$[1,38]="tput bel | /usr/ub/sys/opencashdrawer "
              LET SYS$[39,48]= prt.DrawOpen$[1,10] ! pop drawer  
              LET SYS$[49,49]=" "
              LET SYS$[50,53]=9100 USING "####"
              SYSTEM SYS$ 
            endif
	endif                                                       
 else
	include "src/callsuberr.inc"
 end try
End sub !opendrawer


!--------------------------------------------------------------------------------
Sub currconvup(amount,factor)
! 
  try
	if p61$[136,136]="Y" and factor<>0 and amount<>0! going for base to costing um
		let cnvcu[0]=1
		let cnvca[0]=amount
		let cnvca[1]=factor
		call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
		let amount=cnvca[0]
	endif
  else
    include "src/callsuberr.inc"
  end try
end Sub ! 

!--------------------------------------------------------------------------------
Sub currconvdown(amount,factor)
! 
  try
	if p61$[136,136]="Y" and factor<>0 and amount<>0! going from currency to base
		let cnvcu[0]=2
		let cnvca[0]=amount
		let cnvca[1]=factor
		call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
		let amount=cnvca[0]
	endif
  else
    include "src/callsuberr.inc"
  end try
end Sub ! 



!---------------------------------------------------------------------------
function getautowhtrans$()
! see if Auto wh trans are allowed on this OT
  Try
	Dim f$[20],AWTFlag$[1]
	Dim 1%,AWTR
	AWTFlag$="N" ! as default
	ch_sot=findchannel()
	F$="3/SORDTYPE"+Str$(IntCo) \ ROpen #ch_sot,F$
	if source<>201 and source<>208 goto AWTDone ! Only orders
	IF P61$[120,120]="N" OR RTRIM$(P61$[120,120])="" GOTO AWTDONE
	! now in sordtype file
	Key1$=" ",Key1$
	Key1$=roh.OrdType using "##"
	search #ch_sot,2,1;Key1$,R[2],E
	if e goto AWTDone ! not there - not allowed!
	read #ch_sot,r[2],50;Awtr;
	IF AWTR<>1 GOTO AWTDone ! NOT A Y - no AUTOBO for this ordtype
	AWTFlag$="Y" ! ALLOWED
	AWTDone: ! finito
	Try Close #ch_sot Else Rem
  else
    include "src/callsuberr.inc"
  end try
end Function AWTflag$ ! getmillitmflag$
!--------------------------------------------------------------------------------
Function chktagfle$()
! see if any data for any msglines in tagfile
! checks invltag file for each line
  Try
	Dim RTKey$[60],tflg$[1]
	Dim 3%,RTR,refno
	Dim RTG. as invltag
	tflg$="N"
	RTC=OpenFile(-9939,IntCo)
	if rtc=-1 goto ctfdone
	RTKey$=" ",rtkey$ ! same key as line
	rtkey$[1,10]=refid using "##########"
	rtkey$[11,13]=invl.LineNum using "###"
	rtkey$[15]="" ! cut at 15?
	RTR=filegetinvltag(e$,RTC,"=",1,RTKey$,rtg.) ! hist & ord same layout
	clear e$
	If RTR<=0 ! not found
		tflg$="N"
	Else
		if rtrim$(rtg.MSGLine1$)<>"" let tflg$="Y"
		if rtrim$(rtg.MSGLine2$)<>"" let tflg$="Y"
		if rtrim$(rtg.PONum$)<>"" let tflg$="Y"
		if rtrim$(rtg.JobNum$)<>"" let tflg$="Y"
		if rtrim$(rtg.PressNum$)<>"" let tflg$="Y"
		for x=1 to 25
			x1=(x-1)*30
			let tmp$=rtg.MSGS$[x1+1,x1+30]
			if rtrim$(tmp$)<>"" let tflg$="Y"
		Next X
	Endif
	e$=""
	try close #RTC Else Rem
	Ctfdone: ! finished
  else
    include "src/callsuberr.inc"
  end try
end Function tflg$ ! chktagfle$
! 
!--------------------------------------------------------------------
