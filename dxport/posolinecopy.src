!POSOLINECOPY -- Copies Sales Order Line and Sales ORder Messages Into Purchase Order
!! **** Originally From Rem PO361LC  PURCHASE ORDER SALES ORDER COPY *****
!
! loadsave -w -n 100,10 -o prog/dxport/posolinecopy.dl4 src/posolinecopy.src
!
include "src/copyright.inc"
Declare Intrinsic Sub DateToJulian,InpBuf,Logic,String,VerifyDate
Declare Intrinsic Sub dxopen,dxget,dxset,dxclose,dxsave,programdump,env
! Option Default Dialect IRIS1
External Lib "ubsfunc.dl4"
Declare External Sub getportdefault
Declare External Function OpenFile,PDate$,FormatDate2$,OpenMySQLMirror
Include "src/inc/sql_prod.inc"
External Lib "libprod.lib"
Declare External Sub ProdList,ProdGroup,UMDList,CompIList
Declare External Function getpravail,getumrec,getMSDS,ComplFlag,ChkPrdUM
External Lib "libprodwh.lib"
Declare External Function getmillflg
include "src/inc/filepoltag.inc" ! po line notes

Enter Chan[],spec[],msg$,errtype,userid$
! dxgets needed for # of order lines to copy, order line num, # order message line copy, order msg line #
!! call parameters are as follows
!spec[0] = purchase order record #
!spec[1] = Purchase order number
!spec[6]<>0 copy shiplist messages into purchase order messages
!spec[7] = <>0 copy all lines and messages
! spec[8]= user record #
!Spec[9] = Company #
! possible: spec[18]=# lines to copy, [19]=line# (sopocrte)

!chan[0] = cntrl file
!chan[1] = purchase order header  #60 	
!chan[2] = purchase order lines   #61
!chan[3] = order header #62
!chan[4] = product file #64
!chan[5] = product warehouse #65
!chan[6] = nonstock #66
!chan[7] = unit of measure file #67
!chan[8] = order lines #68
!chan[9] = po messages #69
!chan[10] = order message #70
!chan[11] = po gen work #72
!chan[12] = deals #19
!chan[13] = customer
!chan[14] = order total
!chan[15] = altvend
!chan[16] = nonstock
!chan[17] = shiplist
!chan[18] = order ship to file

!errtype = 0 = no errors copied ok, 1=error/warning has occurred
!msg$= message for error ""


!errtype=0
!msg$=""
r8=spec[0] ! set purchase order header record #
order=spec[1] ! set the sales order #
If Err 0 Gosub ERR_TRAP
dim 1%,plcurrid,phcurrid,olcurrid,ohcurrid
dim 3%,plcurrfact,phcurrfact,olcurrfact, ohcurrfact
dim 1%,cnvcu[10],3%,cnvca[10],keycurr$[10],3%,rec_curr,currfact
dim 1%,L1[5],NSD1[7],PFU1[20],CNVTU[9],SC,SR,Z9[9],COST_LEV[3],COPY_FLAG
dim 1%,FLAGS[11],SOURCE,COPY_SALES_ORD
dim 2%,L2[2],L9,NSD2[4],S9[9],ORDER,LINE_,ELINE,HA3
dim 3%,msglinenum,linenum,totmsgline,totordline
dim 3%,L3[6],NSD3[9],PFU2[6],CNVTA[4],A[33]
dim J4$[50],L1$[120],NSD$[96],PROD$[12],VEND$[50]
Dim 1%,C8[9,9],D1,E,J0,J2,J3,J4,J5,J6,J8,J9[5],T8[4],W1[2],X1[9],H4[3]
Dim 1%,WH0[3],WH8[47],OLL3[3],OLUN[2],OLS2[1],PL0[4],OLEUN[2],DL1[6]
Dim 1%,COPY_FLAG,POMISC[2],PR_PO[1],CTWT
Dim 1%,STAT[2],CH[10]
Dim 2%,B[24],B1,B2,C7[2],H0[5],H3[4],T1[4],T3[4],W2[9],X2[9],WHBLD[2],AV2[6]
Dim 2%,PC_DATE,DT3[1],JDATE[5],podisc[1]
Dim 2%,WH7[3],W7[1],OLL2[1],OLL4[3],OLL6[5],OLL9[1],SOPO,OH5[16],DL2[4],OH0[12]
Dim 3%,B0,J1,H8[9],R0,R8,R9,T9[9],Q1[4],Q9,W3[24],X3[9],PL[5],OLOLM[6],OLUNF[6]
Dim 3%,W5[25],WH9[23],TO_[3],M1[12],A1[7],OLL5[3],OLL7[12],OLS3[17],PL4[23]
Dim 3%,DL3[3],R24,PL5[9],PL6[10],DISP_COST,DISP_QTY,DISP_EXT
Dim 3%,REC[10],LBSFACTOR,LBSUNIT,WHMISC2[7],PARM[5]
dim 3%,polnum
Dim CNTKey$[60],Blank$[200]
Dim 3%,RTR,rec_cnt
Dim RTKey$[60],CN$[10],mode$[2]
dim hglcomm$[4]
dim shipmsg1$[30],shipmsg2$[30],shipmsg3$[30],shipmsg4$[30],3%,srn[5],rec_sl,keysl$[20],shipmsg$[30]
Dim J$[40],J0$[12],J1$[40],J2$[40],J5$[75],J7$[75],J9$[40],F$[16],e$[500]
Dim A$[156],M1$[14],P$[80],S$[20],S1$[10],U5$[50],W1$[32],X$[22]
Dim W2$[36],VEND$[50],I$[5],OLL6$[60],OLL1$[20],OLS3$[33],K12$[50]
Dim K20$[50],K21$[50],K22$[50],K23$[50],K24$[18],K25$[50],K26$[50],P9$[50]
Dim K26$[50],K27$[50],AV1$[32],CK$[20],K69$[9],POM$[60]
Dim P60$[50],WHPROD$[12],OM1$[40],K70$[50],Z$[50],TMP$[50]
Dim P61$[256],Custom_customer$[30],H$[82]
dim p8$[5]
dim 1%,OCCITEM,2%,milf,3%
dim keyrol$[50],keyrom$[50],3%,tmp3
dim rstr$[500],buttonlist$[5,50],nextlist$[5,100] !error handling variables
dim 3%,r21
Def FNR(H) = Int(Abs(H) * 100 + .5) * .01 * Sgn(H)
Def FNU(H) = Int(Abs(H)) + Sgn(Fra(Abs(H))) * Sgn(H)

Dim RTG. as poltag
Blank$=" ",Blank$
Z9[1] = 3 \ Z9[2] = 7
let intco=spec[9] ! set the company #
! openfiles 
if not (chan[0]) ! cntrl file
	ctlc = OpenFile(9999,intCo) \ If ctlc = -1 Error 42 !control 
else
	let ctlc=chan[0]
endif
if not (chan[1]) ! purchase order header  #60
	 Ch_Poh = openfile(2416,intCo) \ If Ch_Poh = -1 Error 42     !"po header file
else
	ch_poh=chan[1]
endif
if not (chan[2]) ! po lines #61
	Ch_PoL = openfile(2432,intCo) \ If Ch_Pol = -1 Error 42     !"po lines file
else
	let ch_pol=chan[2]
endif
if not (chan[3]) ! order header #62
	 Ch_Roh = openfile(1840,intCo) \ If Ch_Roh = -1 Error 42     !order  header file
else
	let ch_roh=chan[3]
endif
if not (chan[4]) ! product file #64
	 Ch_Prod = OpenFile(1792,intCo) \ If Ch_Prod = -1 Error 42  !product file 
else
	let ch_prod=chan[4]
endif
if not (chan[5]) ! product warehouse #65
	Ch_PrWh = OpenFile(1744,intCo) \ If Ch_PrWh = -1 Error 42  !"product warehouse file
else
	let ch_prwh=chan[5]
endif
if not (chan[6]) !  nonstock #66
	ch_nstk=OpenFile(2448,intCo) \ If Ch_nstk = -1 Error 42 ! nonstock product
else
	let ch_nstk=chan[6]
endif
if not (chan[7]) ! unit of measure file #67
	Ch_Ccode = OpenFile(-1728,intCo) \ If Ch_Ccode = -1 Error 42  !u/m codes file
else
	let ch_ccode=chan[7]
endif
if not (chan[8]) ! order lines #68
	ch_rol=OpenFile(1888,intCo) \ If Ch_rol = -1 Error 42 ! order line
else
	let ch_rol=chan[8]
endif
if not (chan[9]) ! po messages #69
	Ch_Pom = openfile(2464,intCo) \ If Ch_Pom = -1 Error 42     !"po message file
else
	let ch_pom=chan[9]
endif
if not (chan[10]) ! order message #70
	Ch_Rom = openfile(1968,intCo) \ If Ch_Rom = -1 Error 42     !order  message file
else
	let ch_rom=chan[10]
endif
if not (chan[11]) ! po gen work #72
	ch_pogen=OpenFile(2752,intCo) \ If Ch_pogen = -1 Error 42 ! ch_pogenwrk file
else
	ch_pogen=chan[11]
endif
If not (chan[12]) ! deals #19
	ch_deal=OpenFile(864,intCo) \ If Ch_deals = -1 Error 42 ! deals file
else
	let ch_deal=chan[12]
endif
If not (chan[13]) ! customer file
	ch_cust=OpenFile(1808,intCo) \ If Ch_cust = -1 Error 42 ! customer file
else
	let ch_cust=chan[13]
endif
If not (chan[14]) ! order total
	 Ch_Rot = openfile(1872,intCo) \ If Ch_Rot = -1 Error 42     !"order total file
else      
	let ch_rot=chan[14]
endif
If not (chan[15]) ! alt vend
	ch_alt=OpenFile(-1568,intCo) \ If Ch_alt = -1 Error 42 !alternate vendor code
else
	let ch_alt=chan[15]
endif
if not(chan[16])
	ch_prdesc = OpenFile(2128,IntCo) \ if ch_prdesc = -1 Error 42 ! non-stock lines ! Orders
else
	let ch_prdesc=chan[16]
endif
if not(chan[17])
	ch_shplist = OpenFile( 2112 ,IntCo) \ if ch_shplist = -1 Error 42 ! shiplist
else
	let ch_shplist=chan[17]
endif
if not(chan[18])
	ch_ros = OpenFile( 1856 ,IntCo) \ if ch_ros = -1 Error 42 ! shiplist
else
	let ch_ros=chan[18]
endif
sqlChan = OpenMySQLMirror(e$)
let r8=spec[0] ! purchase order record #
Mat Read #ctlc,3,172;PC_DATE;
X2 = PC_DATE \ Gosub L_7820 \ X2 = 0
If X2 Let JDATE[0] = X2 Else Let JDATE[0] = Tim(6)
Mat Read #ctlc,19,50;P9$;
Mat Read #ctlc,60,50;P60$;
Mat Read #ctlc,61,0;P61$;
mat read #ctlc,52,60;P8$;
MAT  READ #ctlc,115,60;CUSTOM_CUSTOMER$;
custom_customer$=UCase$(Trim$(custom_customer$))
MAT READ #ctlc,52,100;HGLCOMM$; ! HELD INVENTORY COMMODITY CODE
FOR CTR=1 TO 4
	IF HGLCOMM$[CTR,CTR]="" LET HGLCOMM$[CTR,CTR]=" "
NEXT CTR
!errtype=0
!msg$=""
r8=spec[0] ! set purchase order header record #
order=spec[1] ! set the sales order #
B1 = 1 \ B2 = 6 
For X = 0 To 11 \ FLAGS[X] = 0 \ Next X
Mat Read #ch_poh,R8;H0;
MAT  READ #ch_poh,R8,24;H$;  ! "cct90575 - custom for morrisette
Mat Read #ch_poh,R8,222;H3;
Mat Read #ch_poh,R8,242;H4;
Mat Read #ch_poh,R8,250;H8;
mat read #ch_poh,R8,598;PODISC;
Mat read #ch_poh,R8,612;PHCURRID;
Mat Read #ch_poh,R8,614;PHCURRFACT;

H8[0] = 0 \ H8[1] = 0
Gosub L_6500 ! last line on the purchase order
B1 = MAXLINE + 1
try ! as this can be called from sopocrte(copy 1 line)
	let x2=spec[18]
	if x2 let MAXOST=99 Else let MAXOST=59 ! else has [18] but not from sopocrte
else  ! calling from serpordh means status 91+
	let x2=0
	MAXOST=59
end try
For ST = 1 To MAXOST ! 59
  K22$[1,2] = ST Using "##"
  K22$[3] = ORDER Using "######"
  Search #ch_roh,2,1;K22$,R22,E 
  If E > 1 
	errtype=1
	let msg$=msg$+"SALES ORDER "+str$(order)+" NOT FOUND. "
	Goto OUTEND
  endif
  If Not(E) Goto L_2100
  If ST > 7 And ST < 57 Let ST = 57
Next ST
let errtype=1
let msg$=msg$+"SALES ORDER "+str$(order)+" NOT FOUND. "
Goto OUTEND
L_2100: Rem READ LINES
SOPO = H0[2]
 Write #ch_roh,R22,112;SOPO;
 Write #ch_roh,R22,428;H3[3];
Mat Read #ch_roh,R22,0;OH0;
Mat Read #ch_roh,R22,104;OH5;
if not(spec[7]) ! copy from po lines
	call dxget ("TTLORDLINE",tmp$)!
	try ! as this can be called from sopocrte(copy 1 line)
		let x2=spec[18]
	else  ! as using dxset in sopocrte not always working - pass 1 & line#
		let x2=0
	end try
	totordline=tmP$
	if x2>0 let totordline=x2
	if  (totordline)>0
 		for ctr=1 to totordline
			call dxget ("OrdLineNum"+str$(ctr),tmp$)
			let linenum=tmp$
			try
				let x2=spec[19]
				if x2>0 let linenum=x2 ! copy this 1 line
			else
				let x2=0
			end try
			if linenum>0 gosub getordline:
		next ctr
	endif
	call dxget("TTLMSGLINE",tmp$)
	totmsgline=tmp$
	if not(totmsgline) goto outend:
	if (totmsgline)>0
		for ctr=1 to totmsgline
			call dxget ("OrdMsgNum"+str$(ctr),tmp$)
			let msglinenum=tmp$
			if msglinenum>0 and msglinenum<601
				Gosub GET_SPECMSG
				if POMLINE > 99 goto outend: ! exceeded limit of lines
			endif
		next ctr
	endif
else
	! copy all po lines and messages
	let keyrol$=" ",keyrol$
	let keyrol$[1,6]=order using "######"
	Do
		search #ch_rol,3,1;keyrol$,r23,e
		if e<>0 exit do
		let tmp3=keyrol$[1,6]
		if tmp3<>order exit do
		let linenum=keyrol$[7,9]
		gosub getordline: 
	Loop
	let keyrom$=" ",keyrom$
	let keyrom$[1,6]=order using "######"
	Do
		Search #ch_rom,3,1;Keyrom$,R70,E 
		if e<>0 exit do
		let tmp3=keyrom$[1,6]
		if tmp3<>order exit do
		let msglinenum=keyrom$[7,9]
		if msglinenum>0 and msglinenum<601
			Gosub GET_SPECMSG
			if POMLINE > 99 goto outend: ! exceeded limit of lines
		endif
	Loop
endif
IF spec[6]<>0 ! copy shiplist messages
	let shipmsg1$=" ",shipmsg1$
	let shipmsg2$=" ",shipmsg2$
	let shipmsg3$=" ",shipmsg3$
	let shipmsg4$=" ",shipmsg4$
	mat read #ch_ros,oh0[2],154;SRN;
	let keysl$[1,6]=srn[2] using "######"
	let keysl$[7,7]="."
	let keysl$[8]=srn[1] using "&&&&&&"
	search #ch_shplist,2,1;keysl$,rec_sl,e
	if not(e)
		mat read #ch_shplist,rec_sl,204;shipmsg1$;
		mat read #ch_shplist,rec_sl,234;shipmsg2$;
		mat read #ch_shplist,rec_sl,264;shipmsg3$;
		mat read #ch_shplist,rec_sl,294;shipmsg4$;
	endif
	if rtrim$(shipmsg1$)<>""
		let shipmsg$=shipmsg1$
		gosub add_shipmsg:
	endif
	if rtrim$(shipmsg2$)<>""
		let shipmsg$=shipmsg2$
		gosub add_shipmsg:
	endif
	if rtrim$(shipmsg3$)<>""
		let shipmsg$=shipmsg3$
		gosub add_shipmsg:
	endif
	if rtrim$(shipmsg4$)<>""
		let shipmsg$=shipmsg4$
		gosub add_shipmsg:
	endif
endif
!!!!  
goto outend: 

getordline: ! send the line # over to 
K23$ = " ",K23$
K23$[1,6] = ORDER Using "######"
Let K23$[7,9] = LINENUM Using "###" 
L_2130: ! get the order line
Search #ch_rol,2,1;K23$,R23,E 
if e
	let errtype=2
	let msg$=msg$+" Line "+str$(linenum)+" For Order "+str$(order)=" Not Found."
	return
endif
For X = 0 To 11 \ FLAGS[X] = 0 \ Next X
Mat Read #ch_rol,R23;OLL2
Mat Read #ch_rol,R23,8;OLL3
Mat Read #ch_rol,R23,16;OLL4
Mat Read #ch_rol,R23,32;OLL5
Mat Read #ch_rol,R23,56;OLL6
Mat Read #ch_rol,R23,80;OLL6$
Mat Read #ch_rol,R23,140;OLL1$
Mat Read #ch_rol,R23,160;OLL9
Mat Read #ch_rol,R23,168;OLL7
Mat Read #ch_rol,R23,260;OLS3
Mat Read #ch_rol,R23,250;OLUN
Mat Read #ch_rol,R23,256;OLS2
Mat Read #ch_rol,R23,370;OLS3$
Mat Read #ch_rol,R23,404;OLOLM
Mat Read #ch_rol,R23,446;OLEUN
Mat Read #ch_rol,R23,452;OLUNF
Read #ch_rol,R23,514;CTWT
Mat Read #ch_rol,R23,624; OLCURRID;
Mat Read #ch_rol,R23,626;olcurrfact;
If OLS2[0] = 3 Let FLAGS[2] = 99
If OLL4[2]<>0 and OLL4[2]<>H0[2]  ! stock on another po line
	let errtype=2
    msg$=msg$+" Item On Line "+str$(OLL3[2])+" also on PO "+str$(OLL4[2])+". "
	! copy line anyway
endif
if OLL7[2]<0
	let errtype=2
	msg$=msg$+" Line # "+str$(oll3[2])+" Has Negative Qty. "
	return
endif
IF P61$[136,136]="Y" and olcurrfact<>0 and phcurrfact<>0 and olcurrfact<>phcurrfact
	if olcurrid<>0 and phcurrid<>0 and olcurrid=phcurrid
		If OLL7[7]<>0 ! GL Cost
			Cnvtu[0]=0;cnvtu[1]=OLun[2];cnvtu[2]=2
			CNVTA=OLL7[7] \ gosub L_20000 !  ! go from base to costing um 
			let cnvcu[0]=1; cnvcu[1]=1; cnvca[0]=amount ;cnvca[1]=ilcurrfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$ ! convert up  to original currency $
			let cnvcu[0]=2; cnvcu[1]=1; cnvca[0]=amount ;cnvca[1]=olcurrfact
			let amount=(cnvca[0])
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$ ! convert down  to current currency $
			let amount=(cnvca[0])
			CNVTU[0] = OLun[2];CNVTU[1] = 0;CNVTU[2] = 6 ! to base no round was =2
			CNVTA=amount \ gosub L_20000 
			let OLL7[7]=amount
		endif
		If OLL5[1]<>0 ! Load Cost
			Cnvtu[0]=0;cnvtu[1]=OLun[2];cnvtu[2]=2
			CNVTA=OLL5[1] \ gosub L_20000 !  ! go from base to costing um 
			let cnvcu[0]=1; cnvcu[1]=1; cnvca[0]=amount ;cnvca[1]=ilcurrfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$ ! convert up  to original currency $
			let cnvcu[0]=2; cnvcu[1]=1; cnvca[0]=amount ;cnvca[1]=olcurrfact
			let amount=(cnvca[0])
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$ ! convert down  to current currency $
			let amount=(cnvca[0])
			CNVTU[0] = OLun[2];CNVTU[1] = 0;CNVTU[2] = 6 ! to base no round was =2
			CNVTA=amount \ gosub L_20000 
			let OLL5[1]=amount
		endif
	endif
endif


Gosub L_3500 ! clear po line variables
let plcurrid=phcurrid
let plcurrfact=phcurrfact
PROD$ = OLL1$[1,12]
L1[1] = H4[1] !po head whse
IF P61$[130,130]="Y"  and OLL3[0] <>0 ! FLAG SET TO KEEP SALES ORDER WAREHOUSE AND NONSTOCK ITEM
	let l1[1]=OLL4[3]	! warehouse from sales order
endif
L1[0] = 1
L1[2] = B1
L2[2] = H0[4]
L1[3] = 0
PL0[2] = 1
IF OLL3[0] <>0 ! NON-STOCK APPLY FREIGHT FLAG
	LET PL0[2]=0 ! NONSTOCK APPLY FREIGHT FLAG IS SET TO N
	IF CUSTOM_CUSTOMER$="PIEDMONT" LET PL0[2]=1 ! SET APPLY FREIGHT TO y
ENDIF

POMISC[0] = OLL3[1]

! chk stk item and stkupd =N and ordtype=5future and potype=0whse
if not(oll3[0]) and not(oll3[1]) and oh5[7]=5 and h4[0]=0 ! 
	let pomisc[0]=1
endif
if oh5[7]=3 and h4[0]=0 and hglcomm$[1,4]=olL1$[17,20]  and oll3[1]=0! indirect so, whse po, heldinv comm code, and update stock=N
	let pomisc[0]=1
endif
PL4[10] = OLL2[1];PL4[11] = OLL3[2]
if custom_customer$="MORRISETTE"
	IF H$[49,52]="MILL" LET PL0[2]=1	! "cct90575 - custom for morris
	IF H$[49,52]="DELD" LET PL0[2]=0	! "cct90575 - custom for morris 
Endif
LET MILF=0;OCCITEM=0
if H4=1 let POMISC[0]=0 ! update stock on directs
if H4[0]=2 and P60$[22,22]<>"Y" let POMISC[0]=0 ! indirects
if H4[0]=5 let POMISC[0]=0 ! import directs
if H4[0]=6 and P60$[22,22]<>"Y" let POMISC[0]=0 ! import ind
If Not(OLL3[0]) ! stock items
	Mat Read #ch_prod,OLL4[0];A$
	Mat Read #ch_prod,OLL4[0],156;B
	Mat Read #ch_prod,OLL4[0],256;A
	Mat Read #ch_prod,OLL4[0],460;A1
	Mat Read #ch_prod,OLL4[0],512;PFU1
	Mat Read #ch_prod,OLL4[0],554;PFU2
	Mat Read #ch_prod,OLL4[0],624;PR_PO
	Mat Read #ch_prod,OLL4[0],834;HA3
	Gosub GET_PRODWHSE_INFO
	
	PRODGROUP: Rem
	PARM[0] = - (H4[0] + 1)
	PARM[1] = WHMISC2[0]
	PARM[5] = 0
!	Call "mxprodgrp5",PARM[]
	Call ProdGroup(e$,intco,Parm[])
   

	If PARM[2] = 0 ! item not allowed on this po type
		let errtype=2
		msg$=msg$+" Item "+OLL1$[1,12]+" Not Allowed on this PO Type. "
		return
	End If 
	If ((H0[0] < 7 Or H0[0] >= 90) And POMISC[0]) Let A[2] = A[2] + OLL7[2]
	Mat Write #ch_prod,OLL4[0],256;A;
	if sqlChan >= 0 ! MySQL enabled and channel opened
		e = prod_UpdateSQLFromDL4(e$, intCo, a$[140,151], sqlChan, ch_prod)
		if e <> 1 ! returns the number of records add/updated/deleted
			error 11000
		end if
	end if
	If P9$[33,33] = "Y" Gosub L_4000 ! update warehouse
	If P9$[32,32] = "Y"  ! warehouse pricing
		If W3[16]<>0
			Let L2[0] = W3[16]
		Else 
			Let L2[0] = B[10]
		endif
	else
		let l2[0]=b[10]
	endif
	If P60$[46,46] = "Y" And H4[0] > 3 Let POMISC[1] = PR_PO[0];POMISC[2] = PR_PO[1]
	Rem for setting cost
	Rem if product whse/product use last cost for prod/prodwhse file
	Rem            if direct/indirect&update inv=y use g/l cost
	Rem                               if no g/l cost use load cost to match ord
	Rem if nonstock item use g/l cost
	Rem                  if not g/l cost use load cost to match order cost
	If OH5[7] = 2 Or (OH5[7] = 3 And P60$[22,22] = "N") ! direct/indirect update stock N
		If OLL7[7] <> 0 Or L2[0] = 0 ! has a cost to use
			If OLL7[7]
				L2[0] = OLL7[7]
			Else 
				If Not(L2[0]) 
					IF P61$[95,95]<>"Y" Let L2[0] = OLL5[1]
				endif
			End If 
			If PFU1[11] <> OLUN[2] And (PFU1[11] = -2 Or OLUN[2] = -2) ! unit of measure lot
				If OLL7[2] ! has a qty
					If PFU1[11] = -2 ! purchase order has a lot cost
						L2[0] = L2[0] * OLL7[2]
					Else 
						L2[0] = L2[0] / OLL7[2]
					End If 
				End If 
			End If 
			If L2[0] <> 0 And (PFU1[11] = -1 Or PFU1[11] = -3) And (OLUN[2] = -1 Or OLUN[2] = -3) ! uom cwt/lb
				LBSUNIT = A[6];LBSFACTOR = A[5]
				A[6] = OLL6[4];A[5] = OLUNF[5]
				CNVTA = L2[0];CNTVU[0] = 0;CNVTU[1] = OLUN[2];CNVTU[2] = 2
				Gosub L_20000
				A[6] = LBSUNIT;A[5] = LBSFACTOR
				CNVTA = AMOUNT;CNVTU[0] = OLUN[2];CNVTU[1] = 0;CNVTU[2] = 2
				Gosub L_20000
				L2[0] = AMOUNT
			End If 
		End If 
	End If 
	Gosub L_8200 ! Rem ========check for alt vendor
	If Not(E)
		If H3[3] = AV2[0] Let L2[0] = AV2[2]
	endif
	L1[5] = PFU1[11]
	CNVTA = L2[0] \ CNVTU[0] = 0 \ CNVTU[1] = L1[5] \ CNVTU[2] = 2
	Gosub L_20000
	CNVTU[0] = L1[5] \ CNVTU[1] = 0 \ CNVTU[2] = 2 \ Gosub L_20000
	L2[0] = CNVTA
	L3[1] = OLL4[0]
	L1[4] = OLEUN[1]
	L3[2] = OLL7[2];PL4[5] = OLL7[2]
	If L1[5] <> -2
		DISP_QTY = PL4[5];DISP_COST = L2[0] \ Gosub CALC_DISP_EXT
		PL4[6] = DISP_EXT
		GOSUB L_11000: ! need deals 1st! before extend!
		PL4[0] = L2[0] - (L2[0] * (PL4[2] / 100)) - PL4[3]
		CNVTA = PL4[0] \ CNVTU[0] = 0 \ CNVTU[1] = L1[5] \ CNVTU[2] = 2
		Gosub L_20000
		CNVTU[0] = L1[5] \ CNVTU[1] = 0 \ CNVTU[2] = 2 \ Gosub L_20000
		PL4[0] = CNVTA
		DISP_QTY = PL4[5];DISP_COST = PL4[0] \ Gosub CALC_DISP_EXT
		PL4[7] = DISP_EXT
	Else 
		PL4[6] = FNR(L2[0]) \ PL4[0] = L2[0] \ PL4[7] = FNR(PL4[0])
	End If 
	PL4[12] = OLL6[4];PL4[13] = OLUNF[5]
	PL4[14] = OLL6[2];PL4[15] = OLUNF[4]
	L3[5] = 0 \ If PL4[13] Let L3[5] = PL4[12] * PL4[5] / PL4[13]
	L3[6] = 0 \ If PL4[15] Let L3[6] = PL4[14] * PL4[5] / PL4[15]
	L1$[1,60] = OLL6$[1,60]
	If OLS2[1] > 1 Let L1$[1,30] = A$[9,38] \ L1$[31,60] = A$[63,92]
	L1$[61,80] = A$[93,112]
	L1$[81,92] = OLL1$[1,12]
	Gosub L_11000
	if ha3<>0 let pl0[3]=1 
	! gosub CopyCost:
End If 
If OLL3[0] ! non-stock item
  Gosub CHECK_POGENWRK  ! ! CHECK IF NON-STOCK IS IN AUTO PROCESSING MODE 
  mat read #ch_prdesc,olL4[0],120;ha3;
  if ha3<>0 let pl0[3]=1 
  OLS3[14] = H3[3]
  If OLL7[7]<>0
	Let L2[0] = OLL7[7]
  Else
	IF P61$[95,95]<>"Y"
		Let L2[0] = OLL5[1]
	endif
  endif
  PL4[0] = L2[0]
  
  A[6] = OLL6[4];A[5] = OLUNF[5] \ If Not(A[5]) Let A[5] = 1;OLUNF[5] = 1
  B[23] = OLL6[2];A1[3] = OLUNF[4] \ If Not(A1[3]) Let A1[3] = 1;OLUNF[4] = 1
  PFU1[0] = OLEUN[0];PFU1[1] = OLUN[0]
  PFU1[2] = OLUN[1];PFU1[3] = OLUN[2]
  PFU1[4] = OLEUN[1]
  PFU1[5] = 0;PFU1[6] = 0;PFU1[7] = 0
  PFU1[8] = OLUN[0];PFU1[9] = OLUN[0];PFU1[10] = OLEUN[1]
  PFU1[11] = OLUN[2];PFU1[12] = OLUN[1]
  PFU1[13] = OLUN[0];PFU1[16] = OLEUN[0];PFU1[17] = OLEUN[0]
  PFU1[15] = CTWT
  PFU1[18] = OLUN[0];PFU1[19] = OLUN[0]
  PFU2[0] = OLUNF[0];PFU2[1] = OLUNF[1]
  PFU2[2] = OLUNF[2];PFU2[3] = OLUNF[3]
  PFU2[4] = 0;PFU2[5] = 0;PFU2[6] = 0
  For K = 1 To 4
    For X2 = 0 To K - 1
      If PFU1[K] = PFU1[X2] Let PFU1[K] = 0;PFU2[K - 1] = 0
    Next X2
  Next K
  L1[5] = OLUN[2]
  CNVTA = L2[0] \ CNVTU[0] = 0 \ CNVTU[1] = L1[5] \ CNVTU[2] = 2
  Gosub L_20000
  CNVTU[0] = L1[5] \ CNVTU[1] = 0 \ CNVTU[2] = 2 \ Gosub L_20000
  L2[0] = CNVTA
  L1[4] = OLEUN[1]
  L3[2] = OLL7[2];PL4[5] = OLL7[2]
  PL4[12] = OLL6[4];PL4[13] = OLUNF[5]
  PL4[14] = OLL6[2];PL4[15] = OLUNF[4]
  If OLUNF[5] Let L3[5] = OLL7[2] * OLL6[4] / OLUNF[5]
  If OLUNF[4] Let L3[6] = OLL7[2] * OLL6[2] / OLUNF[4]
  If OLUN[2] = -2 ! " cost u/m = lot
    PL4[6] = OLL5[1];PL4[7] = OLL5[1];PL4[0] = OLL5[1]
  Else 
    DISP_QTY = OLL7[2];DISP_COST = L2[0] \ Gosub CALC_DISP_EXT
    PL4[6] = DISP_EXT
    DISP_QTY = OLL7[2];DISP_COST = PL4[0] \ Gosub CALC_DISP_EXT
    PL4[7] = DISP_EXT
	IF PODISC[0]=1 or PODISC[0]=2                                                          
	   		IF PODISC[0]=1 LET PL4[2]=PODISC[1]                               
		 	IF PODISC[0]=2                                            
			   LET CNVTA=podisc[1];CNVTU[0]=pfu1[10];CNVTU[1]=0;CNVTU[2]=2    
               GOSUB L_20000:                                                   
			   LET PL4[3]=AMOUNT                                             
			ENDIF 
	ENDIF        
    PL4[0] = L2[0] - (L2[0] * (PL4[2] / 100)) - PL4[3]
    CNVTA = PL4[0] \ CNVTU[0] = 0 \ CNVTU[1] = L1[5] \ CNVTU[2] = 2
    Gosub L_20000
    CNVTU[0] = L1[5] \ CNVTU[1] = 0 \ CNVTU[2] = 2 \ Gosub L_20000
    PL4[0] = CNVTA
    DISP_QTY = PL4[5];DISP_COST = PL4[0] \ Gosub CALC_DISP_EXT
    PL4[7] = DISP_EXT
  End If 
  L1$[1,60] = OLL6$[1,60]
  L1$[61,80] = OLS3$[1,20]
  L1$[81,92] = OLL1$[1,12]
  For X = 0 To 6 \ W3[X] = 0 \ Next X
  NSD$[1,12] = OLL1$[1,12] \ NSD$[13,42] = OLL6$[1,30]
  NSD$[43,72] = OLL6$[31,60] \ NSD$[73,92] = OLS3$[1,20]
  NSD$[93,96] = OLL1$[17,20]	
  NSD3[6] = OLL6[4] \ NSD3[7] = OLUNF[5] \ NSD3[8] = OLUNF[4]
  NSD1[1] = OLL3[3] \ NSD2[0] = H0[2] \ NSD2[1] = OLS3[14]
  NSD2[3] = OLL5[1] \ NSD2[4] = R23 \ NSD1[7] = CTWT
  NSD3[2] = OLL6[2]
  For X = 2 To 5
    If X = 2 Let NSD1[X] = OLEUN[0]
    If X = 3 Let NSD3[X] = OLUNF[2];NSD1[X] = OLUN[2]
    If X = 4 Let NSD3[X] = OLUNF[3];NSD1[X] = OLEUN[1]
    If X = 5 Let NSD3[X] = OLUNF[0];NSD1[X] = OLUN[0]
  Next X
  If Fra(OLL7[2]) > 0
    Gosub L_3700
    If R27 Gosub L_3800
  End If 
  If OLS2 = 3 Goto L_2915
  X1 = 0 \ FLAGS[0] = 1
L_2790: K26$ = NSD$[1,12] \ K26$[13] = X1 Using "##"
  Search #ch_nstk,2,1;K26$,L3[1],E 
  If E > 1 
	errtype=1
	let msg$=msg$+"Error in Adding Non-Stock Line to Purchase Order. "
	return
  endif
  If Not(E)
    X1 = X1 + 1 
    if x1>99
	errtype=1
	let msg$=msg$+"Purchase Order Has Reached Maximum Non-Stock Lines. "
	return
     endif
    Goto L_2790
  End If 
  E = 2 \ Search #ch_nstk,1,0;K26$,L3[1],E
  If E 
	errtype=1
	let msg$=msg$+"Error in Adding Non-Stock Line to Purchase Order. "
	return
  endif
  Search #ch_nstk,4,1;K26$,L3[1],E 
  If E 
	errtype=1
	let msg$=msg$+"Error in Adding Non-Stock Line to Purchase Order. "
  endif
  NSD1[6]=X1 ! need to set tie breaker
  NSD1[0]=L1[2] ! po line #
  NSD2[2]=H0[3] ! Po date
  Mat Write #ch_nstk,L3[1];NSD$
  Mat Write #ch_nstk,L3[1],96;NSD1
  Mat Write #ch_nstk,L3[1],112;NSD2
  Mat Write #ch_nstk,L3[1],132;NSD3;
End If 
L_2915: OLL4[2] = H0[2]
Mat Write #ch_rol,R23,16;OLL4
Mat Write #ch_rol,R23,260;OLS3;
Gosub L_5840 ! set up flags
Gosub L_6100 ! write new pol
If OLUN[2] = -2 And OLL3[0] ! "cost u/m = lot and non stock
  H8[0] = H8[0] + PL4[6]
Else 
  DISP_QTY = L3[2];DISP_COST = L2[0] \ Gosub CALC_DISP_EXT
  H8[0] = H8[0] + DISP_EXT
End If 
H8[1] = H8[1] + L3[5]
Mat Write #ch_poh,R8,250;H8;
B1 = B1 + 1
gosub copycost: ! 
gosub copy_tagfile ! copy roltag to poltag
gosub premiernotes ! see if premier and add note if is
Return ! end of line copy

CopyCost: ! check cost for sales order lines
If P61$[2,2] = "Y" Or P61$[2,2] = "G" Or P61$[2,2] = "L"
		LET UPDTOK=0
		let costchg=0
		if l2[0]<>oll7[7] LET costchg=99
		if not(oll5[1]) let costchg=99
		if not (oll7[7]) let costchg=99
		if costchg<>0
			if OLL3[0]<>0 LET UPDTOK=99 ! NONSTOCK ITEM
			IF OH5[7]=2 let updtok=99
			IF OH5[7]=3 AND P60$[22,22]="N" let updtok=99
		endif
		if not(oll3[0]) ! stock item
			if costchg=99
				if Oh5[7]=1 and milf<>0 and p8$[4,4]="Y" and oll3[1]=0 let updtok=99 ! check if mill item
				if p61$[112,112]="Y" and occitem=2
					if not(oll5[1]) let updtok=99 ! occassional items! check if mill item
				endif
			endif
		endif
		IF UPDTOK<>0 and r22>0
			UPDORDERCOST: Rem --------------------------------------------
			CH[0] = CTLC ! CONTROL FILE
			CH[1] = ch_poh;REC[1] = R8
			CH[2] = ch_pol;REC[2] = R21
			CH[3] = ch_roh;REC[3] = r22 ! sales order record #- PL4[10] ! SALES ORDER #
			CH[4] = ch_rol;REC[4] = - PL4[11] ! SALES ORDER LINE #
			CH[5] = ch_prod;REC[5] = 0
			CH[6] = cH_prwh;REC[6] = 0
			ch[7] = ch_cust;rec[7]=0
			ch[8] = ch_rot; rec[8]=0
			rec[10]=spec[8]
			STAT[0] = 0;STAT[1] = 0
			stat[2]=intco ! need to pass comp #
			Call "poupsocost.dl4",CH[],REC[],STAT[],userid$
		End If 
End If 
return

L_3500: Rem CLEAR LINE VARS
let polnum=h0[2]
For X = 0 To 23
  If X < 6 Let L1[X] = 0
  If X < 3 Let L2[X] = 0;POMISC[X] = 0
  If X < 7 Let L3[X] = 0
  If X < 5 Let NSD2[X] = 0
  If X < 8 Let NSD1[X] = 0
  If X < 10 Let NSD3[X] = 0;PL5[X] = 0
  If X < 11 Let PL6[X] = 0
  If X < 24 Let PL4[X] = 0
Next X
L1$ = " ",L1$
NSD$ = " ",NSD$
E = 2
Search #ch_poL,1,0;K21$,R21,E
If E 
	errtype=1
	let msg$=msg$+"Error in Adding Line to Purchase Order. "
endif
L3[0] = R8
L1[0] = 1
Return 
L_3700: Rem FIND EAH U/M FOR FRA NON STOCKS
R27 = 0
K27$ = " ",K27$
K27$ = "EA  "
Search #ch_ccode,2,1;K27$,R27,E
If E
  K27$ = "EACH"
  Search #ch_ccode,2,1;K27$,R27,E
  If E Let R27 = 0 \ Return 
End If 
Return 
L_3800: Rem SET UP FRA
NSD1[2] = R27
NSD3[3] = 100
NSD3[4] = 100
NSD3[5] = 100
If OLL7[7] <>0
	Let L2[0] = (OLL7[7] / 100)
Else
	if p61$[95,95]<>"Y"
		Let L2[0] = (OLL5[1] / 100)
	endif
endif
CNVTA = L2[0] \ CNVTU[0] = 0 \ CNVTU[1] = L1[5] \ CNVTU[2] = 2
Gosub L_20000
CNVTU[0] = L1[5] \ CNVTU[1] = 0 \ CNVTU[2] = 2 \ Gosub L_20000
L2[0] = CNVTA
L3[2] = OLL7[2] * 100
NSD3[7] = 100
NSD3[8] = 100
Return 
GET_PRODWHSE_INFO: Rem get info, mostly for prodgrp
U5$ = OLL1$[1,12] \ U5$[13] = H4[1] Using "##"
Search #ch_prwh,2,1;U5$,R25,E \ If E > 1 return
If Not(E) Goto FOUND1

WHPROD$[1,12] = OLL1$[1,12];WHBLD[0] = ch_prwh;WHBLD[1] = H4[1];WHBLD[2] = B[24]
Call "MXWHCREATE",WHPROD$,WHBLD[]
R25 = WHBLD[2];E = 0;WHBLD[2] = 0
FOUND1: Gosub L_4270
milf=getmillflg(e$,intco,ch_prwh,oll1$[1,12],h4[1],oh5[7])
Unlock #ch_prwh
Return 
L_4000: Rem UPDATE WAREHOUSE FILE
U5$ = OLL1$[1,12] \ U5$[13] = H4[1] Using "##"
Search #ch_prwh,2,1;U5$,R25,E \ If E > 1 Return
If Not(E) Goto L_4230
WHPROD$[1,12] = OLL1$[1,12];WHBLD[0] = ch_prwh;WHBLD[1] = H4[1];WHBLD[2] = B[24]
Call "MXWHCREATE",WHPROD$,WHBLD[]
R25 = WHBLD[2];E = 0;WHBLD[2] = 0
L_4230: Gosub L_4270
If ((H0[0] < 7 Or H0[0] >= 90) And POMISC[0]) Let W3[1] = W3[1] + OLL7[2]
Gosub L_4400
Return 
L_4270: Rem READ WHPR FILE
Mat Read #ch_prwh,R25,0;W1$
Mat Read #ch_prwh,R25,32;W1
Mat Read #ch_prwh,R25,38;W2
Mat Read #ch_prwh,R25,78;W3
Mat Read #ch_prwh,R25,228;W5
Mat Read #ch_prwh,R25,384;W2$
Mat Read #ch_prwh,R25,420;WH0
Mat Read #ch_prwh,R25,428;WH7
Mat Read #ch_prwh,R25,444;WH8
Mat Read #ch_prwh,R25,540;WH9
Mat Read #ch_prwh,R25,696;W7
Mat Read #ch_prwh,R25,846;WHMISC2
mat read #ch_prwh,r25,420;OCCITEM;
Return 
L_4400: Rem WRITE WHPR FILE
Mat Write #ch_prwh,R25,0;W1$
Mat Write #ch_prwh,R25,32;W1
Mat Write #ch_prwh,R25,38;W2
Mat Write #ch_prwh,R25,78;W3
Mat Write #ch_prwh,R25,228;W5
Mat Write #ch_prwh,R25,384;W2$
Mat Write #ch_prwh,R25,420;WH0
Mat Write #ch_prwh,R25,428;WH7
Mat Write #ch_prwh,R25,444;WH8
Mat Write #ch_prwh,R25,540;WH9
Mat Write #ch_prwh,R25,696;W7;
Return 
L_4600: Rem EXTEND COST
L3[5] = 0 \ If PL4[13] Let L3[5] = PL4[12] * PL4[5] / PL4[13]
L3[6] = 0 \ If PL4[15] Let L3[6] = PL4[14] * PL4[5] / PL4[15]
Return 
CALC_DISP_EXT: Rem convert qty and cost to cost um, then calc ext cost
CNVTA[0] = DISP_QTY;CNVTU[0] = 0;CNVTU[1] = L1[5];CNVTU[2] = 1 \ Gosub L_20000
DISP_QTY = AMOUNT
CNVTA[0] = DISP_COST;CNVTU[0] = 0;CNVTU[1] = L1[5];CNVTU[2] = 2 \ Gosub L_20000
DISP_COST = AMOUNT
DISP_EXT = FNR(DISP_QTY * DISP_COST)
If L1[5] = -1 Or L1[5] = -3
  If PL4[12]
    LBSUNIT = PL4[12];LBSFACTOR = PL4[13]
  Else 
    LBSUNIT = OLL6[4];LBSFACTOR = OLUNF[5]
  End If 
  If LBSFACTOR <= 0 Let LBSFACTOR = 1
  If L1[5] = -1 Let DISP_EXT = FNR(DISP_COST * (LBSUNIT * DISP_QTY) / LBSFACTOR / 100)
  If L1[5] = -3 Let DISP_EXT = FNR(DISP_COST * (LBSUNIT * DISP_QTY) / LBSFACTOR)
End If 
If L1[5] = -2 Let DISP_EXT = DISP_COST
Return 

X2 = L1[3] \ For K = 0 To 11
  FLAGS[K] = Sgn(Fra(X2 / 2)) \ X2 = Int(X2 / 2)
Next K \ Return 
L_5840: Rem PACK CHAIN TYPE FROM FLAGS[]
X2 = 0 \ For K = 0 To 11
  If FLAGS[K] Let X2 = X2 + 2 ^ K
Next K \ L1[3] = X2 \ Return 
L_6100: Rem WRITE LINE REC
Mat Write #ch_pol,R21;L1
Mat Write #ch_pol,R21,12;L2
Mat Write #ch_pol,R21,24;L3
Mat Write #ch_pol,R21,66;L1$
Mat Write #ch_pol,R21,186;PL
Mat Write #ch_pol,R21,222;PL0
Mat Write #ch_pol,R21,232;PL4
Mat Write #ch_pol,R21,376;POMISC
Mat Write #ch_pol,R21,382;PL5
Mat Write #ch_pol,R21,442;PL6
mat  write #ch_pol,r21,542;polnum;
mat write #ch_pol,r21,548;plcurrid;
mat write #ch_pol,r21,550;plcurrfact;
K21$ = H0[2] Using "######"
K21$[7] = L1[2] Using "###"
Search #ch_pol,4,1;K21$,R21,E
If E 
	errtype=1
	let msg$=msg$+"Error in Adding Line to Purchase Order. "
endif
Call Logic(1,2 ^ 2,L1[3],X2) \ If X2 Goto L_6235
K21$ = L3[1] Using "######"
K21$[7] = H0[2] Using "######"
K21$[13] = L1[2] Using "###"
Search #ch_pol,4,2;K21$,R21,E 
If E 
	errtype=1
	let msg$=msg$+"Error in Adding Line to Purchase Order. "
endif
L_6235: COPY_FLAG = 1
Return 
L_6500: Rem FIND LAST LINE ON THE PO
K21$ = " ",K21$
K21$[1,6] = H0[2] Using "######"
L_6530: Search #ch_pol,3,1;K21$,R21,E

If E Return 
X2 = K21$[1,6]
If X2 <> H0[2] Return 
MAXLINE = K21$[7,9]
Goto L_6530
X$ = " ",X$ \ X$[10] = ""
X$[1,3] = Int(X2 / 10 ^ 2 - Int(X2 / 10 ^ 4) * 10 ^ 2) + 10 ^ 2 Using "###"
X$[4,6] = Fra(X2 / 10 ^ 2) * 10 ^ 2 + 10 ^ 2 Using "###"
X$[7,9] = Int(X2 / 10 ^ 4) + 10 ^ 2 Using "###"
X$[4,4] = "/" \ X$[7,7] = "/" \ X$ = X$[2]
Return 
DT3[0] = X2;FLAG = 1;X$ = " "
Call "JULIANUTIL",DT3[],X$,FLAG
Return 
Call VerifyDate(X$,X$,E) \ If E Let X$ = "    "
X2 = X$[1,6] \ Return 
L_7820: Rem  CONVERT YYMMDD TO JULIAN (RETURN=NOGOOD, +1=OKAY)
X$ = X2 Using "&&&&&&"
Call DateToJulian(1,X$,X$,E) \ If E Return 
X2 = X$[1,5] \ Return 1
DT3[0] = X2;DT3[1] = X2;FLAG = 0
Call "JULIANUTIL",DT3[],X$,FLAG
Return 
X$ = X2 Using "&&&&"
DT3[0] = X$[1,2];DT3[1] = X$[3,4]
If DT3[0] > 67 Let DT3[0] = 1900 + DT3[0]
If DT3[0] < 68 Let DT3[0] = 2000 + DT3[0]
X$[1,4] = DT3[0] Using "&&&&";X$[5,6] = DT3[1] Using "&&"
X2 = X$[1,6] \ Return 
L_8200: Rem ========check for alt vendor
K24$ = " ",K24$;E = 1
If P61$[51,51] = "N" Return 
K24$[1,12] = PROD$;K24$[13,18] = VEND$;E = 0
Search #ch_alt,2,1;K24$,R24,E 
If E  Return 
Mat Read #ch_alt,R24,0;AV1$;
Mat Read #ch_alt,R24,32;AV2;
If P9$[32,32] = "Y"
  If W2[3] = AV2[0] Let E = 1
Else 
  If (B[24] = AV2[0]) Or (W2[3] = AV2[0]) Let E = 1
End If 
Return 
DISP_WINDOW: Rem
NOCOPY = 0
Window Open @4,5; Size 70,10; Using "SPECIAL MESSAGE COPY FROM 001-600"
START_MSGLINE: Rem
Print 'CS'
Print @0,2;"ENTER STARTING SPECIAL MESSAGE LINE NUMBER,  0: ALL, OR  E: EXIT ";
Input ""Z$
If Z$ = "E" Let NOCOPY = 1 \ Goto END_DISPWINDOW
If Z$ = "0"
  SMLINE = 1
  EMLINE = 600
  Goto END_DISPWINDOW
End If 
SMLINE = Z$ \ If Not(SMLINE) Goto START_MSGLINE
If SMLINE > 600
  Print @5,5;"CAN'T COPY THE MESSAGE LINE NUMBER OVER 600"
  Signal 3,20
  Print @5,5;'CL'
  Goto START_MSGLINE
End If 
END_MSGLINE: Rem
Print @0,4;"ENTER ENDING SPECIAL MESSAGE LINE NUMBER, OR  E: EXIT ";
Input ""Z$
If Z$ = "E" Let NOCOPY = 1 \ Goto END_DISPWINDOW
EMLINE = Z$ \ If Not(EMLINE) Goto END_MSGLINE
If EMLINE > 600
  Print @5,5;"CAN'T COPY THE MESSAGE LINE NUMBER OVER 600"
  Signal 3,20
  Print @5,5;'CL'
  Goto END_MSGLINE
End If 
If SMLINE > EMLINE
  Print @5,5;"ENDING VALUE MUST BE GREATER THAN OR EQUAL TO STARTING VALUE!"
  Signal 3,20
  Goto START_MSGLINE
End If 
If SMLINE = EMLINE
  K70$ = " ",K70$
  K70$[1,6] = OH0[7] Using "######"
  K70$[7] = SMLINE Using "###"
  Search #ch_rom,2,1;K70$,R70,E
	If E 
		let errtype=1
		msg$=msg$+" Special Message Line "+str$(msglinenum)+" From Order "+str$(OH0[7])+"Not On File."
		Goto START_MSGLINE
	endif  
End If 
END_DISPWINDOW: Rem
Window Close 
Return 
GET_SPECMSG: Rem"if the sales order's o/t=2 and po's type is "D" or "ID",copy it
!If OH5[7] = 2 And (H4[0] = 1 Or H4[0] = 2)
! find the last line for the ponum
lastline=0
K69$ = " ",K69$
K69$ = H0[2] + 2 * 10 ^ 6 Using "#######"
POMSG_LOOP: Search #ch_pom,3,1;K69$,R69,E 
If E Goto END_POMSG
PONUM = K69$[2,7]
If PONUM <> H0[2] Goto END_POMSG
LASTLINE = K69$[8,9]
Goto POMSG_LOOP
END_POMSG: Rem
POMLINE = LASTLINE
K70$ = " ",K70$;K70$[1,6] = OH0[7] Using "######"
K70$[7,9] = MsgLINEnum Using "###";K70$[10,10] = ""
Search #ch_rom,2,1;K70$,R70,E 
if e
	let errtype=1
	msg$=msg$+" Message Line "+str$(msglinenum)+" For Order "+str$(OH0[7])+" Not Found."
	return
endif
Mat Read #ch_rom,R70;OM1$;
POMLINE = POMLINE + 1
If POMLINE > 99
	errtype=1
	msg$=msg$+"Message Lines have exceeded maximum allowed"
	return
endif
POM$ = " ",POM$
POM$[1,40] = OM1$[1,40]
E = 2
Search #ch_pom,1,0;K69$,R69,E
If E 
	let errtype=1
	msg$=msg$+" Error in Adding Message Line "+str$(msglinenum)+" From Order "+str$(OH0[7])+"."
	return
endif
K69$ = H0[2] + 2 * 10 ^ 6 Using "#######"
K69$[8] = POMLINE Using "##"
POM$[51,59] = K69$[1,9]
Mat Write #ch_pom,R69;POM$;
Search #ch_pom,4,1;K69$,R69,E 
If E 
	let errtype=1
	msg$=msg$+" Error in Adding Message Line "+str$(msglinenum)+" From Order "+str$(OH0[7])+"."
	return
endif
Return

copy_tagfile: ! copy zline tag file
RTC=OpenFile(9950,IntCo) \ if RTC=-1 Return ! no file - no copy
QTC=OpenFile(9936,IntCo)
if QTC=-1 ! no file
	Try Close #RTC Else Rem ! close ordtag before exit
	RETURN ! no file - no copy
Endif
chanfrom=RTC;chanto=QTC;ordfrom=Order;linefrom=oll3[2]
ordto=H0[2];lineto=l1[2]
Call "mxordtagcp.dl4",chanfrom,chanto,ordfrom,linefrom,ordto,lineto,L1[0],IntCo
Try Close #RTC Else Rem
Try Close #QTC Else Rem
Return

premiernotes: ! ADD A NOTE LINE! ADD'L NOTE!! - messages copied above from ord to pol
! add notes if copied and customer is a premier (A or S)
	blank$=" ",blank$ ! jic
	RTC=OpenFile(9936,IntCo)
	if RTC=-1 goto PMCN_done ! no po tag file
	CNC=OpenFile(-720,IntCo)
	if CNC=-1 goto PMCN_done ! custnotes missing!
	CNTKey$=" ",CNTKey$
	CNTKey$=oh0[4] using "######"
	search #cnc,2,1;CNTKey$,rec_cnt,e
	if e goto PMCN_done ! NOT PREMIER as no flag!
	mat read #cnc,rec_cnt,436;CN$;
	if CN$[1,1]<>"A" and CN$[1,1]<>"S" goto PMCN_done ! Not Premier
	let rtkey$=" ",rtkey$
	let rtkey$[1,6]=H0[2] using "######"
	let rtkey$[7,9]=l1[2] using "###"
	
	search #rtc,2,1;rtkey$,rtr,e
	if not(e) ! has message lines ALREADY (was copied above!?)
		read record #rtc,rtr,0;rtg.;
		newrtrec=0 ! exist
	Else ! no existing - add one
		if e<>1 goto PMCN_done ! file is f'd
		clear rtg.
		newrtrec=1 ! added
		rtg.Status=L1[0] ! POL.STATUS
		rtg.OrdNum=h0[2] ! pol.ponum
		rtg.LineNum=l1[2] ! pol.itemno
		rtg.Blankforkey$=" "   
		rtg.JobNum$=" ",rtg.JobNum$ 
		rtg.PONum$=" ",rtg.PONum$
		rtg.PressNum$=" ",rtg.pressnum$  
		rtg.MSGLine1$=" ",rtg.MSGLine1$
		rtg.MSGLine2$=" ",rtg.MSGLine2$
		rtg.MSGS$=" ",rtg.MSGS$ ! 1-60 IS CPI - per specs after cpi
	Endif
	! try to find a blank line (try 4 times)  starting at message 8
	! per specs after CPI notes so there is not conflict with CPI Control Notes
	! CPI notes are notes 1 - 7 per serppol
	if rtg.msgs$[61,66]=blank$[1,6] 
		let rtg.msgs$[61,90]="**PREMIER CUSTOMER**"+Blank$
	Else ! used 1
		if rtg.msgs$[91,96]=blank$[1,6] 
			let rtg.msgs$[91,120]="**PREMIER CUSTOMER**"+Blank$
		else ! used 2
			if rtg.msgs$[121,126]=blank$[1,6] 
				let rtg.msgs$[121,150]="**PREMIER CUSTOMER**"+Blank$
			else ! used 3
				if rtg.msgs$[151,156]=blank$[1,6] 
					let rtg.msgs$[151,180]="**PREMIER CUSTOMER**"+Blank$
				endif ! used 4 times - no message!
			endif ! of try 3
		endif ! of try 2
	endif ! of try 1
	rtg.Blankforkey$=" " ! always!!
	let mode$="a"
	if newrtrec let rtr=0 ! is no rec yet!
	if not(newrtrec) let mode$="c" ! update/change existing
	rec_tmp=fileupdatepoltag(e$,RTC,mode$,RTR,rtg.)
	if rec_tmp<0 ! problem
		let errtype=1
		msg$=msg$+"Search Error "+Str$(rec_tmp)+" updating poltag file"
	Endif
	PMCN_done: ! close and out
	Try close #rtc Else Rem ! we open - we close
	TRY CLOSE #CNC ELSE REM
	!	call dxsave(0,"tmp/pcnte.txt!")
	!if UCase$(userid$[1,4])="JIMS"
	!	call programdump("tmp/prcnote.txt!","")
	!	STOP ! for testing!!!
	!endif
RETURN ! premiernotes  task 62459
!--------------------------------------------------------------------------------


add_shipmsg: ! add shiplist message to purchase order lines
! find next message line
lastline=0
K69$ = " ",K69$
K69$ = H0[2] + 2 * 10 ^ 6 Using "#######"
POMSG_LOOP1: Search #ch_pom,3,1;K69$,R69,E 
If E Goto END_POMSG1
PONUM = K69$[2,7]
If PONUM <> H0[2] Goto END_POMSG1
LASTLINE = K69$[8,9]
Goto POMSG_LOOP1

END_POMSG1: Rem
POMLINE = LASTLINE
POMLINE = POMLINE + 1
If POMLINE > 99
	errtype=1
	msg$=msg$+"Message Lines have exceeded maximum allowed"
	return
endif
POM$ = " ",POM$
POM$[1,30] = shipmsg$[1,30]
E = 2
Search #ch_pom,1,0;K69$,R69,E
If E 
	let errtype=1
	msg$=msg$+" Error in Adding Message Line "+str$(msglinenum)+" From Shiplist for Order "+str$(OH0[7])+"."
	return
endif
K69$ = H0[2] + 2 * 10 ^ 6 Using "#######"
K69$[8] = POMLINE Using "##"
POM$[51,59] = K69$[1,9]
Mat Write #ch_pom,R69;POM$;
Search #ch_pom,4,1;K69$,R69,E 
If E 
	let errtype=1
	msg$=msg$+" Error in Adding Message Line "+str$(msglinenum)+" From Shiplist for Order "+str$(OH0[7])+"."
	return
endif
Return


OUTEND: Rem EXIT

If Err 0 Rem
! close files opened in the prog
if not (chan[0]) and ctlc<>1 close #ctlc ! cntrl file
if not (chan[1]) close #ch_poh ! purchase order header  #60
if not (chan[2]) close #ch_pol ! po lines #61
if not (chan[3]) close #ch_roh ! order header #62
if not (chan[4]) close #ch_prod ! product file #64
if not (chan[5]) close #ch_prwh! product warehouse #65
if not (chan[6]) close #ch_nstk!  nonstock #66
if not (chan[7]) close #ch_ccode! unit of measure file #67
if not (chan[8]) close #ch_rol ! order lines #68
if not (chan[9]) close #ch_pom! po messages #69
if not (chan[10]) close #ch_rom ! order message #70
if not (chan[11]) close #ch_pogen ! po gen work #72
If not (chan[12]) close #ch_deal ! deals #19
If not (chan[13]) close #ch_cust ! customer file
If not (chan[14]) close #ch_rot ! order total
if not (chan[15]) close #ch_alt ! alternate vendor
if not (chan[16]) close #ch_prdesc! order nonstock line
if not (chan[17]) close #ch_shplist ! shiplist
if not (chan[18]) close #ch_ros! order ship to file
if sqlChan >= 0 close #sqlChan
If Err 0 Gosub ERR_TRAP
End 

L_11000: Rem LOOK FOR DEALS
IF PODISC[0]=1 or podisc[0]=2                       
	IF PODISC[0]=1 LET PL4[2]=PODISC[1]             
	IF PODISC[0]=2       
		LET CNVTA=podisc[1];CNVTU[0]=pfu1[10];CNVTU[1]=0;CNVTU[2]=2           
		GOSUB L_20000:                                                  
		LET PL4[3]=AMOUNT                                           
		rem LET PL4[3]=PODISC[1]                          
	ENDIF                                           
	RETURN                                          
ENDIF    
K12$ = " ",K12$
K12$[1,6] = H3[3] Using "######"
K12$[7,18] = L1$[81,92]
K12$[19,27] = 999999999 - (L3[2] + 1) Using "#########"
L_11070: Search #ch_deal,3,1;K12$,R12,E
If E Goto L_11320
X2 = K12$[1,6] \ If X2 <> H3[3] Goto L_11320
If K12$[7,18] <> L1$[81,92] Goto L_11320
Mat Read #ch_deal,R12,0;DL2;
Mat Read #ch_deal,R12,20;DL1;
Mat Read #ch_deal,R12,34;DL3;
X2 = DL2[1] \ Gosub L_7820 \ X2 = 0
JDATE[1] = X2
X2 = DL2[4] \ Gosub L_7820 \ X2 = 0
JDATE[2] = X2
If JDATE[0] < JDATE[1] Or (DL2[4] And JDATE[0] > JDATE[2]) Goto L_11070
If DL1[1] = 1
  PL4[2] = DL3[0]
  PL4[0] = FNR(L2[0] - (L2[0] * (PL4[2] / 100)) - PL4[3])
  If L1[5] <> -2
    DISP_QTY = PL4[5];DISP_COST = L2[0] - (L2[0] * (PL4[2] / 100))
    Gosub CALC_DISP_EXT
    PL4[6] = DISP_EXT
    DISP_QTY = PL4[5];DISP_COST = PL4[0] \ Gosub CALC_DISP_EXT
    PL4[7] = DISP_EXT
  Else 
    PL4[6] = L2[0]
    PL4[7] = PL4[0]
  End If 
End If 
If DL1[1] = 2
  PL4[3] = DL3[0]
  PL4[0] = PL4[0] - DL3[0]
  If L1[5] <> -2
    DISP_QTY = PL4[5];DISP_COST = L2[0] \ Gosub CALC_DISP_EXT
    PL4[6] = (DISP_EXT - DL3[0])
    DISP_QTY = PL4[5];DISP_COST = PL4[0] \ Gosub CALC_DISP_EXT
    PL4[7] = DISP_EXT
  Else 
    PL4[6] = L2[0]
    PL4[7] = PL4[0]
  End If 
End If 
If DL1[1] = 3
  If DL3[2]
    PL4[1] = Int(L3[2] / DL3[2]) * DL3[0]
  End If 
End If 
L_11320: Return 
L_20000: Rem UNIT CONVERSION RETURNS AMOUNT  (rev 01/07/1992)   ! 20040
If Not(CNVTA) Let AMOUNT = 0 \ Goto L_20160
If CNVTU[2] = 3 Or CNVTU[2] = 4 Goto L_20050
If CNVTU[2] = 1 And CNVTU[1] = CNVTU[0] Let AMOUNT = CNVTA \ Goto L_20160
If CNVTU[0] = -2 Or CNVTU[1] = -2 Let AMOUNT = CNVTA \ Goto L_20160
If CNVTU[2] = 0 Goto L_20050
L_20050: Call "MXPRCONV5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
If CNVTU[2] = 0 Goto L_20160
If FLAG Let E = FLAG !\ Gosub ERR_SEARCH
AMOUNT = CNVTA
L_20160: Return 
CHECK_POGENWRK: Rem check if in process for 365-367, nonstocks
K70$ = OLL4[3] Using "##"
POGEN_LOOP: Search #ch_pogen,3,1;K70$,R70,E
If E Return 
ORDERNUM = K70$[1,2]
If ORDERNUM <> OLL4[3] Let E = 1 \ Return 
If K70$[17,28] = OLL1$[1,12]
  ! moving warning to the serppoh 
  !LET ERRTYPE=1
  !MSG$=MSG$+" NONSTOCK ITEM "+OLL1$[1,12]+" is being considered by auto PO processing."
  ! Need to delete from auto gen file since it is being copied
  search #ch_pogen,5,1;k70$,r70,e
  if not(e)
	let e=3\search #ch_pogen,1,0;k70$,r70,e
  endif
  RETURN
End If 
Goto POGEN_LOOP
Return 
Rem {begin rtn.error.s}
ERR_TRAP: Rem *Error routine (escape trap)   V3.1 8/94 G.DOSCHER/REK
include "src/callmainerrnet_call.inc"
End
