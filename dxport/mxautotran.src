! >>> Program mxautotran
!
! description automatically create Wh Trans orders
!
! loadsave -w -n 100,10 -o prog/dxport/mxautotran.dl4 src/mxautotran.src
!
! 1.0 mm/dd/yyyy change??
!
Rem BEDIT Version: 2.5 OBJECT CODE     Created: AUG  1, 2014  13:24:04
Rem /x/w2/pm/r2005//x/usracct/becky/work/custom/redd.r10/mxautotran.src (synergyux.synergy.n) [rjs] {24999}
Rem  Copyright (c) 2014 Universal Business Systems, Inc.
Rem    **** ALL CHANGES MUST BE MADE IN SOURCE!!! ****
Rem
include "src/copyright.inc"
include "src/inc/fileedittrack.inc" ! edit tracking
External Lib "libedittrack.lib"
Declare External Sub MakeEdittrack
External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus
Declare External Function getmsg$,expandarray
External Lib "ubsfunc.dl4"
Declare External Function openfile,PDate$
Declare Intrinsic Sub DateToJulian,InpBuf,String,Time
Declare Intrinsic Function findchannel
!Option Default Dialect IRIS1
if err 0 gosub err_trap
Rem  mxautotran- Create whse transfer from mxline
! ONLY CREATE AN ORDER TYPE 16 Order
! THERE ARE NO PRICES/COSTS ON OT 16 ORDERS! - so no commission, totals etc
! The TRANCUST MUST EXIST IN THE "TO" (orig order) WHSE (WHINFO)
! Enter FROMORDER,LINEREC,WHSETO,PRODREC,SELLUM
Rem {begin src/inc/dim.getchan.i}
Dim 1%,CHNL
Dim 3%,CHNLSCR,CHNLFREE
Rem {end dim.getchan.i}
Dim P61$[256],J$[75],U5$[50],Key0$[50],KEY1$[50],KEY2$[50],KEYSHIP$[50]
Dim K1$[50],ANS$[20],FLE$[20],N1$[4],SUM$[4],PRODA$[156]
Dim 1%,N1[6],REC_WHINFO,PFU1[20],CNVTU[2],OHREGION,X,X1,OPEN_CHAN[10]
Dim 1%,CH_WHINFO,CH_PROD,CH_PRWH,CH_CCODES,PD1[2],SCR,CH[99]
Dim 2%,B[24],N0,CWH,SDAY,CUTTIME,D8,D9[20],DT3[1],PD2[19],S9[19],ORDERNUM
Dim 2%,PASSINFO[20],SlsmSplt[4],ORDCOUNT,CommBase[4]
Dim 1%,FChan[59],AKFlag[1],SplitFlag,Awtr,3%,PHUP,MDCust[1],totbcost
Dim 3%,VDATE,PARAM[5],CSZONE$[2],ARTERM$[16],AOLoc$[8],EML$[50]
Dim 3%,TRANCUST,CUST,R[100],A4,AVAIL[2],COMMSVGCHG
Dim 3%,PFU2[6],A[33],W3[24],AMOUNT,CNVTA,REC_PROD,REC_PRWH,J4
Dim 4%,J1
Dim A3$[22],BT$[20],U2$[60],A2$[30],A1$[142],B4k$[2],MSGS$[750]
Dim 2%,A0[3],C1[12],REC,C13[0],FromOrder
Dim 1%,S0[20],SUB_,SZN,C7[4],C0,C2[2],C8,C11[2],DWH,SHDWH
Dim 3%,C4[6],C10[5],CFIN[8],U1,C9,C5[5],C6[9],C12[1]
Dim 1%,H3[1],H4[2],TH4[2],LOCKPORT,OWHT[1],PICKBY[1],DMFLAG
Dim 2%,H0[12],TH0[12],H5[16],TH5[16],ST3[24],SLSM[9],H6[8],TH6[8],HFAX[1]
Dim 2%,HSTI[1],H2[0],OWHT1[1],TROrdNum
Dim 3%,TOT_SELL,SCOM[4],SMER[4],SCST[4],TOTGL,OREF[5]
Dim V0$[12],H0$[20],H1$[6],HMAT$[2],P0$[20]
Dim 1%,L3[3],OL3[3],PL[1],UN[2],S2[1],EUN[2],OWHS,LPRINTED,CTWT[1]
Dim 2%,L2[1],OL2[1],L4[3],L6[5],OL6[5],L9[1],LCO[1],LTAX2,LP_DATE,LP_TIME,WHSEFROM
Dim 3%,L5[3],L7[12],OL7[12],S3[17],OS3[17],OLM[6],UNF[6],CST[0],LTAX1,INVNO,QPB,ROL0
Dim L6$[60],L1$[20],MT$[2],S3$[33]
Dim 1%,S6[1]
Dim 2%,S1[1],S5,SL2[4]
Dim 3%,SRN[5],INVNO
Dim S1$[118],S2$[20],TS2$[20],TS1$[30]
Dim 1%,DCLVL,MCTXBL[9]
Dim 2%,MCODE[9],T1[1],JRNL
Dim 3%,MCHARGE[9,1],T2[25],TOT[4],INVNO
Dim 4%,C111,SCUST
Dim A$[45],C1$[117],C2$[22],C5$[20],D$[8],D1$[8],D2$[8],D3$[8],D4$[8]
Dim P$[10],P2$[15],SHIPVIA$[12],WINNOTE$[128],UNOTEDIR$[64]
Dim N1$[4],N2$[118],BLANK$[118]
Dim D6$[24],U9$[50],M1$[30],K7$[50],K6$[50],2%,L1,L0,X7,X6,R6,HMAT$[2]
Dim D9$[10],J0$[15],J1$[50],J2$[20],J4$[50],J5$[80],J6$[30],D5$[28]
Dim J7$[50],J9$[50],N$[30],P0$[20],P9$[50],R$[34],R1$[142],S1$[118]
Dim T$[20],V0$[12],X$[10],2%,RR$[200],R2$[200],R3$[10],F1$[16]
Dim P60$[50],SZONE$[10],KC$[40],K75$[50],F$[16],Z1$[50],RETVAL$[30]
Dim S$[20],SHIP$[14],CMD$[256],WNOTEDIR$[120],UNAME$[64],HOMEDIR$[64]
Dim AA2$[50],K18$[50],SHCONTACT$[20],AWTFlag$[1]
Dim SPACE$[80]
Dim 1%,LINENUM
Dim 3%,TL2[1],WHS[99,99],WHORD[99]
Dim LPONUM$[30],LJOBNUM$[30],PSNUM$[30],MSG1$[30],MSG2$[30]
Dim e$[500],buttonlist$[5,50],nextlist$[5,100] ! dx error handling variables
dim tmp$[800],tmp1$[800],tmp2$[800],Message$[600],msg$[100],rstr$[2000],webstr$[2000]
dim action$[30],options$[30],userid$[8],3%,fdel$[10],bsdel$[10],esdel$[10],rdel$[10],action1$[30],action2$[30]
Dim List$[50,1000],List2$[60,1000]
! Call dxopen() ! for stand-alone
Call getsession(e$,CTLC,options$,action$,userid$,intCO,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$,Action1$,Action2$)
BOTRANSFER = 1 ! allo transfer to be back ordered
COID = IntCO ! Int((Spc(5) - Int(Spc(5) / 16384) * 16384) / 64)
Def FNR(H) = Int(Abs(H) * 100 + .5) * .01 * Sgn(H) ! "round to penny
Dim etr. as edittrack
Open #77,"cntrl/PRTDFLT" \ Open #78,"cntrl/USERPORT" \ Open #79,"cntrl/usercntrl"
tmp$=" ",tmp$;tmp$=Ucase$(userid$)+"     "
Search #79,2,1;tmp$,R[79],e
if not(e)
	read #79,r[79],300;a4;
endif
if A4>0
	Mat Read #77,A4,0;PD1; \ Mat Read #77,A4,20;PD2;
endif
Close #77,#78,#79
tmp$="cntrl/cntrl"+str$(intco)
Close #1 ! close the read-only
Open #1,tmp$ ! reopen as read/write
action$=UCase$(action$)
 action$=RTrim$(Action$) ! "trim spaces from end
 action1$=UCase$(action1$)
 action1$=RTrim$(Action1$) ! "trim spaces from end
 action2$=UCase$(action2$)
 action2$=RTrim$(Action2$) ! "trim spaces from end
Mat Read #1,19,50;P9$; \ Mat Read #1,60,16;CWH;
Mat Read #1,61,0;P61$;
Mat Read #1,182,32;SDAY; !"#days for searching the customer po#
Mat Read #1,182,84;CUTTIME;
If Not(SDAY) Let SDAY = 7 !"default to 7 days cct#140285
Mat Read #1,60,50;P60$;
B4k$=" ",B4k$ ! serp blank for(4) key
Read #1,18,210;SZONE$; ! "sales zone desc
Blank$=" ",Blank$
clear whs[]
clear whord[]
if p61$[120,120]<>"Y" and p61$[120,120]<>"E" ! only 2 valid options
	returnstatus=0
	message$="System flag says this is not used"
	goto ATCDone
Endif
  Returnstatus=0
  Message$="ACTION NOT FOUND"
  gosub Openfiles ! open all needed files
Select Case action1$
	case "GETBOLIST"	!							doc=OrdH.GetBOList.doc
	! get a list of backorders and whse availables
		Returnstatus=1
		Message$="OK"
		! a 2 list system - 1=order lines, 2=avail for the lines
		clear list$[]
		clear list2$[]
		Gosub fndorgorder
		gosub BOIList
		CALL addtostr(e$,rstr$,List$[])
		call addtostr(e$,rstr$,List2$[])
	!end of getbolist
	case "SENDLIST"		!							doc=OrdH.SendBOList.doc
	! user selected lines/whses - start it
		Returnstatus=1
		Message$="OK"
		gosub fndorgorder
		gosub AutoTRStart
		if returnstatus=1 ! send orders created/used?
		  message$=message$+" Orders "
		  for x=1 to 99
			if whord[x] let message$=message$+Str$(whord[x])+" "
		  next x
		endif
	! end of sendlist
 End Select
	!
   ATCDone: ! finished
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
!
	Call SetOutput(e$,rstr$)
goto OutEnd
! start of routines
OpenFiles: ! this is not a called program - so open all order files
CH_WHINFO = OpenFile(-2768,Intco) \ if ch_Whinfo=-1 error 42 ! CHNL
CH_SHIP = OpenFile(-2112,Intco) \ if ch_ship=-1 error 42 ! CHNL
CH_ZONE = OpenFile(-1920,Intco) \ if ch_zone=-1 error 42 ! CHNL
CH_TAG = OpenFile(9950,Intco) \ if ch_tag=-1 error 42 ! CHNL
! CH_PROD = 3;CH_PRWH = 30;CH_CCODES = 26
CH_prod=OpenFile(1792,Intco) \ if ch_prod=-1 error 42
CH_PRWH=OpenFile(1744,Intco) \ if ch_prwh=-1 error 42
ch_CCodes=Openfile(-1728,Intco) \ if ch_ccodes=-1 error 42
Ch_cust=OpenFile(1808,Intco) \ if ch_cust=-1 error 42
CH_ROH=Openfile(1840,Intco) \ if ch_roh=-1 error 42
CH_ROS=OpenFile(1856,Intco) \ if ch_ros=-1 error 42
CH_ROT=OpenFile(1872,Intco) \ if ch_rot=-1 error 42
CH_ROL=OpenFile(1888,Intco) \ if ch_rol=-1 error 42
Return
FNDOrgOrder: ! get the order we're working on
call dxget("CUSTID",tmp$)
CUSTID=tmp$
Call dxget("ORDERID",tmp$)
OrdNo=tmp$
key0$=" ",key0$
key0$=Custid using "######"
Key0$[7]=OrdNo Using "######"
Search #ch_roh,2,2;Key0$,R[8],E
if e 
	returnstatus=0
	message$="Order not found"
	goto atcdone
endif
gosub READ_HEADER
! also get other message fields NOW
OSHPDATE=H0[10] ! ORDER ship date
mat read #ch_ros,H0[2],8;ts1$; ! ship name
mat read #ch_ros,h0[2],126;ts2$; ! zone
AWTFlag$="N" ! as default
	ch_sot=findchannel()
	F$="3/SORDTYPE"+Str$(IntCo) \ ROpen #ch_sot,F$
	IF P61$[120,120]="N" OR RTRIM$(P61$[120,120])="" GOTO AWTDONE
	! now in sordtype file
	Key1$=" ",Key1$
	Key1$=H5[7] using "##"
	search #ch_sot,2,1;Key1$,R[2],E
	if e goto AWTDone ! not there - not allowed!
	read #ch_sot,r[2],50;Awtr;
	IF AWTR<>1 GOTO AWTDone ! NOT A Y - no AUTOBO for this ordtype
	AWTFlag$="Y" ! ALLOWED
	AWTDone: ! finito
	if ch_sot try close #ch_sot else rem
if h5[7]=1 AND (P61$[120,120]="Y" OR P61$[120,120]="E") let AWTFlag$="Y" ! ALWAYS ALLOWED!!
if AWTFlag$<>"Y"
	returnstatus=0
	message$="Auto Transfer not allowed on this order type"
	goto atcdone
endif
! Enter FROMORDER,LINEREC,WHSETO,PRODREC,SELLUM
FromOrder=OrdNo
Return
BOIList: ! list BO lines with avail
! now go thru lines
List$[0]=bsdel$,"BOLINES",fdel$
tmp$="LINK",fdel$ ! - the line record
tmp$=tmp$,"LINENO",fdel$,"PRODID",fdel$
tmp$=tmp$,"DESC1",fdel$,"BOQTY",fdel$,"UM",fdel$,"WHSE",fdel$
list$[1]=tmp$
maxcnt1=50;lcnt=2
List2$[0]=bsdel$,"AVAIL",fdel$
tmp$="LINK",fdel$ ! line rec #
tmp$=tmp$,"WH",fdel$,"REGION",fdel$,"WHNAME",fdel$,"AVAILABLE",fdel$
list2$[1]=tmp$
maxcnt2=60;lcnt2=2
key1$=" ",key1$
Key1$=h0[7] using "######"
ROLOLoop: ! 
search #ch_rol,3,1;key1$,R[11],E
if e goto rolodone
x2=key1$[1,6] \ if x2<>h0[7] goto ROLODone
Gosub READ_ROLNEW
if OL2[0]<>11 goto ROLOLoop ! not an order!
If OL3[0]<>0 goto ROLOLoop ! non-stk
if OL3[1]<>1 goto ROLOLoop ! non-update
if L4[2]<>0 goto ROLOLoop ! already on A PO
if OL7[3]<=0 goto ROLOLoop ! NO BO!
If S2[0]<>0 goto ROLOLoop ! NO CUTS/Messages!!
if TROrdNum<>0 goto ROLOLoop ! Already on a transfer
Whseto=L4[3] \ if whseto<1 or whseto>99 or fra(whseto) let whseto=h4[2]
Mat Read #CH_WHINFO,WHSETO-1,3032;TRANCUST; ! or WHSEFROM??
! if trancust<=0 or trancust>999999 or fra(trancust) goto ROLOLoop ! NO CUST NO WAY
Key2$ = " ",Key2$
Key2$ = TRANCUST Using "######"
Search #CH_Cust,2,1;Key2$,R[5],E \ If E goto ROLOLoop ! will bomb if ng when creating
REC_PROD = L4[0] ! PRODREC
Gosub READ_PROD ! for conversions
! send to list$
tmp$=Str$(r[11]),fdel$
tmp$=tmp$,Str$(OL3[2]),fdel$,RTrim$(L1$[1,12]),fdel$
tmp$=tmp$,RTrim$(L6$[1,30]),fdel$
cnvtu[0]=0;cnvtu[1]=UN[0];cnvtu[2]=1
cnvta=OL7[3] \ gosub convert
tmp$=tmp$,LTrim$(amount using "----,---,--#.##"),fdel$
SellUM=Un[0]
SUM$ = " ",SUM$
If SELLUM = -2 Let SUM$ = "LOT "
If SELLUM = -1 Let SUM$ = "CWT "
If SELLUM = -3 Let SUM$ = "LB  "
If SELLUM > 0 Read #CH_CCODES,SELLUM,10;SUM$;
tmp$=tmp$,SUM$,fdel$,Str$(Whseto),fdel$
list$[lcnt]=tmp$
LCNT=LCNT+1
if lcnt>maxcnt1 let maxcnt1=expandarray(e$,List$[])
if trancust<=0 or trancust>999999 or fra(trancust) goto ROLOLoop ! NO CUST NO TRANS
gosub LOOK_UP_AVAIL ! adds to List2$ in there
goto ROLOLoop
RolODone: ! 
List$[lcnt]=esdel$
List2$[lcnt2]=esdel$
Return
AutoTRStart: ! start the transfer
F1 = PD1[0] \ If F1 <= 0 Or F1 > 999 Let F1 = 999 ! "entered by number
Read #1,0,112;D8; \ Mat Read #1,115;D9;
Gosub L_7900 \ Gosub L_7800 \ D8 = X2
If D8 = 888888 Or D8 = 999999 Goto OUTEND
SPACE$ = " ",SPACE$ !  " used to space fill input areas, boxes, etc.
X2 = D8 \ Gosub L_7700 \ D$ = X$ ! "program control
AXC[7] = 8;AXC[8] = 11;AXC[9] = 12;AXC[10] = 22 ! "axcess field x-ref.
H0[9] = D8;H0[10] = D8;H0[8] = 0;H5[9] = 1
J1$ = "" \ Call Time(J1$)
CURHH = J1$[15,16]
CURMM = J1$[18,19]
CURSS = J1$[21,22]
CURTIME = CURHH * 10000 + CURMM * 100 + CURSS
If CURTIME > CUTTIME
  X$ = D8 Using "&&&&&&"
  Call DateToJulian(1,X$,X$,E)
  X2 = X$[1,5]
  X2 = X2 + 1
  DT3[0] = X2 \ DT3[1] = X2 \ FLAG = 0
  Call "JULIANUTIL",DT3[],X$,FLAG
  X2 = X$
  H0[10] = X2
  VDATE = X2;STAT = 1;WARN = 0;PARAM[0] = H4[2];PARAM[1] = H5[8]
  Call "validdate",VDATE,STAT,WARN,PARAM[]
  H0[10] = VDATE
End If 
HMAT$ = " ",HMAT$;SHIPVIA$ = " ",SHIPVIA$
DMFLAG = 0;AZD = 0;PICKBY = 0;PICKBY[1] = 0
If AXCESS Let H5[9] = 99 ! "source
H5[0] = F1 \ F1 = 0 \ H5[1] = D8
! get the line data
call dxget("NUMLINES",tmp$)
let numlines=tmp$
if numlines<=0
	returnstatus=0
	message$="Number of lines to transfer was not sent"
	goto ATCDone
Endif
for bolno=1 to numlines
	call dxget("LINK"+Str$(Bolno),tmp$)
	x3=tmp$
	if x3<=0 goto nxtbol
	R[11]=X3
	! gosub READ_ROLNEW
	call dxget("WHSE"+Str$(Bolno),tmp$)
	WHSE=tmp$
	if whse<1 or whse>99 or fra(whse) goto nxtbol ! no good - bypass
	! Enter FROMORDER,LINEREC,WHSETO,PRODREC,SELLUM
	
	whs[whse,0]=whs[whse,0]+1 ! # lines for the whse
	X1=Whs[whse,0] ! s/b 1,2,3,etc (99 MAX)
	Whs[whse,x1]=R[11] ! line rec#
	!gosub do_autoc ! wait to end
nxtbol: ! 
next bolno
! ok - back thru doing all lines for a whse at one time
for whln=1 to 99
	if whs[whln,0] ! has at least 1
		bwhln=Whs[whln,0] ! # of bo lines for the whse
		for booln=1 to bwhln
			R[11]=whs[whln,booln]
			gosub READ_ROLNEW
			LineRec=R[11];whseto=L4[3];prodrec=L4[0];SellUM=Un[0]
			if whseto<1 or whseto>99 or fra(whseto) let whseto=h4[2]
			Whse=whln ! whse from
			gosub do_autoc
		next booln
		if p61$[120,120]="Y" gosub outend_reset ! reset the 1 order
	endif ! whse has a bo assigned
next whln
! done
Goto AtcDone ! finished
Do_Autoc: ! do it now!
SUM$ = " ",SUM$
If SELLUM = -2 Let SUM$ = "LOT "
If SELLUM = -1 Let SUM$ = "CWT "
If SELLUM = -3 Let SUM$ = "LB  "
If SELLUM > 0 Read #CH_CCODES,SELLUM,10;SUM$;
WHSEFROM = WHSE
Mat Read #CH_WHINFO,WHSETO-1,3032;TRANCUST; ! or WHSEFROM??
! Gosub LOOK_UP_AVAIL
Gosub GET_CUST ! trans cust
DFLT_TAX_TYPE = A0[3]
DCLVL = C11[0]
WHSEFROM = WHSE
If Not(WHSEFROM) Goto ATCDOne
REC_PROD = L4[0] ! PRODREC
Gosub READ_PROD
Gosub TRANSFER_HEADER ! are there any other out there?
Gosub READ_HEADER ! re-read info
Gosub TRANSFER_LINE ! do detail
Gosub UPDATE_LOTS_AND_STUFF
Gosub SET_ROLTAG
Gosub TOTAL_ORDER ! write order total
if p61$[120,120]<>"Y"
	gosub outend_reset ! reset inproc for new/existing order
endif
RETURN ! Goto OUTEND_RESET

LOOK_UP_AVAIL: Rem
REC_WHINFO = WHSETO - 1
Mat Read #CH_WHINFO,REC_WHINFO,122;N1;
Mat Read #CH_WHINFO,REC_WHINFO,3032;TRANCUST;

OHREGION = N1[3]
! Window Open @2,4; Size 55,19; Using " WAREHOUSE AVAILABLE "

STARTHERE: Rem "relist start here
CLN = 2
!For X = 0 To 99 \ WHS[X] = 0 \ Next X
!Print @1,0;'CE';"PRODUCT: ";PRODA$[140,151];@22,0;PRODA$[9,38];
!Print @2,1;"WH";@6,1;"RGN";@11,1;"NAME";@36,1;"AVAILABLE"
WX = 1
For REC_WHINFO = 0 To 98
  Mat Read #CH_WHINFO,REC_WHINFO,0;N1$;
  Mat Read #CH_WHINFO,REC_WHINFO,4;N2$;
  If N1$[1,1] = "" Or N1$[1,4] = "    " Goto NXTWHSE
  Mat Read #CH_WHINFO,REC_WHINFO,122;N1;
  If OHREGION ! "only if got one
    If N1[3] ! "otherwise ALL
      If N1[3] <> OHREGION Goto NXTWHSE
    End If 
  End If 
  WH = REC_WHINFO + 1 ! "back to real whse.
  if WH>=CWH goto QWDone ! NO CONSIGNS!!
  If WHSETO = WH Goto NXTWHSE
  K1$ = " ",K1$;K1$ = PRODA$[140,151];K1$[13,14] = WH Using "##"
  Search #CH_PRWH,2,1;K1$,REC_PRWH,E
  If E >= 1 Goto NXTWHSE
  Gosub READ_PRWH
  AVAIL = W3[0] - W3[2]
  If AVAIL <= 0 Goto NXTWHSE
  ! WHS[WX] = WH \ WX = WX + 1
  CNVTU[0] = 0;CNVTU[1] = SELLUM;CNVTU[2] = 1
  CNVTA = AVAIL \ Gosub CONVERT
  tmp$=Str$(r[11]),fdel$ ! link (Order Line Rec)
  tmp$=tmp$,Str$(WH),fdel$,Str$(N1[3]),fdel$,Rtrim$(N2$[1,20]),fdel$
  tmp$=tmp$,LTrim$(Amount using "----,---,--#.##")," ",SUM$,fdel$
  !Print Using "##";@2,CLN;WH;@6,CLN;N1[3];@11,CLN;N2$[1,20];
  !Print Using "----,---,--#.##";@30,CLN;AMOUNT;
  !Print @46,CLN;"/";SUM$
  !CLN = CLN + 2 ! "skip a line after each?
  List2$[Lcnt2]=tmp$
  lcnt2=lcnt2+1 \ if lcnt2>maxcnt2 let maxcnt2=expandarray(e$,List2$[])
NXTWHSE: Rem "next
Next REC_WHINFO
QWDONE: Rem "
RETURN ! for next order Line

TRANSFER_HEADER: Rem is there one already out there?
If p61$[120,120]="Y" ! want new order only - first check if this is 1st for whse
  if booln=1 goto L_500 ! first for whse - get new order #
  ! not first - get the order we're on (all same whses at one time)
	Key0$ = " ",Key0$
	Key0$ = TRANCUST Using "######"
	key0$[7]=Whord[whln] USING "######"
	search #ch_roh,2,2;key0$,R[8],E
	if e>1 gosub err_search
	if not(e) ! found it
		OrderNum=key0$[7,12]
		goto done_header_search
	Endif
	! fall thru? bomb? - let's treat as normal & find ANY EXISTING STAT 1
endif
Key0$ = " ",Key0$
Key0$ = TRANCUST Using "######"
ORDERNUM = 0
CHECK_FOR_TRANS: Rem are there any already out there?
Search #CH_Roh,3,2;Key0$,R[8],E \ If E If E <> 2 Gosub ERR_SEARCH
If E = 2 Goto DONE_HEADER_SEARCH
CUST = Key0$[1,6]
If TRANCUST = CUST
  Mat Read #CH_ROH,R[8];TH0
  Mat Read #CH_Roh,R[8],78;TH4
  Mat Read #CH_Roh,R[8],104;TH5
  Mat Read #CH_Roh,R[8],408;TH6
  If TH0[0] <> 1 Goto CHECK_FOR_TRANS ! only entered - no printed
  If TH0[5] Goto CHECK_FOR_TRANS ! bo counter - no good
  If TH5[7] <> 16 Goto CHECK_FOR_TRANS ! not xfer
  If TH4[2] <> WHSEFROM Goto CHECK_FOR_TRANS ! diff whse
  ORDERNUM = TH0[7]
  TH6[2] = TH0[0]
  A$ = " ",A$
  A$[1,2] = TH0[0] Using "##"
  A$[3] = TH0[7] Using "######"
  Search #CH_Roh,2,1;A$,R8,E \ If E Gosub ERR_SEARCH
  Search #CH_Roh,5,1;A$,R8,E \ If E Gosub ERR_SEARCH
  TH0[0] = 90 ! put in edit process
  A$ = " ",A$
  A$[1,2] = TH0[0] Using "##"
  A$[3] = TH0[7] Using "######"
  Search #CH_Roh,4,1;A$,R8,E \ If E Gosub ERR_SEARCH
  Mat Write #CH_Roh,R[8];TH0
  Mat Write #CH_Roh,R[8],408;TH6
  Whord[whln]=TH0[7] ! Goto DONE_HEADER_SEARCH
End If 
DONE_HEADER_SEARCH: Rem done with looking
If ORDERNUM Return ! there is an existing
L_500: Rem "==================== get record #'s for all files, var inits
J0 = ch_roh \ Gosub L_5000 ! "order header
H1 = V1 \ R[8] = V1
Read #1,20,86;N0
NEXT_NUM: N0 = N0 + 1
If N0 > 999998 Goto OUTEND
Gosub CHK_ORDER_NUM \ If Not(E) Goto NEXT_NUM ! if order# found try next #
Write #1,20,86;N0;
H0[7] = N0 ! "order #
Whord[whln]=N0 ! record ord# for the whse
LOCKPORT = Spc(6)
A$ = " ",A$ \ A$[1,2] = "90"
A$[3,8] = H0[7] Using "######" ! "order #
J0 = ch_roh;D = 1;V1 = R[8] \ Gosub L_5050 ! "insert dir #1, header
A$ = " ",A$ \ A$ = C1[1] Using "######" ! "cust code
A$[7] = H0[7] Using "######" ! "order #
J0 = ch_roh;D = 2;V1 = R[8] \ Gosub L_5050 ! "insert dir #2, header
A$ = " ",A$ \ A$ = C1[2] Using "###" ! "slsm
A$[4] = H0[7] Using "###### " ! "order #
J0 = ch_roh;D = 3;V1 = R[8] \ Gosub L_5050 ! "inser dir #3, header
J0 = ch_ros \ Gosub L_5000 ! "order ship to
R[9] = V1 \ H0[2] = V1
J0 = ch_rot \ Gosub L_5000 ! "order totals
R[10] = V1 \ H0[3] = V1
H0[0] = 90;H6[2] = 1;S1[0] = 31;T1[0] = 21;H3[1] = 1 ! "statuses, ship terms
J1$ = "" \ Call Time(J1$)
X2 = J1$[15,16] \ H5[16] = X2
X2 = J1$[18,19] \ H5[16] = H5[16] + (X2 / 100) ! "time entered
Gosub L_1300 ! "current date (from $TIME)
Gosub L_7800 \ H5[15] = X2 ! "date entered
S1[1] = H0[7];T1[1] = H0[7] ! "order #'s
S1$ = " ",S1$;S1$ = C1$;S2$ = " ",S2$;H1$ = " ",H1$
SRN[2] = C1[1];SRN[1] = 0;SRN[3] = 0;SRN[4] = DFLT_TAX_TYPE
S2$[1,15] = C2$[7,21] ! "country
H4[1] = C7[4];S2$[19,20] = R$[32,33] ! "stop, zone
Gosub L_8100 ! zone/ship date
Gosub L_8900 ! "write totals
Gosub L_8940 ! "write ship to
P0$ = "VERBAL              ";OREF[4] = 0;OREF[5] = 0;ORGSLSM = C1[2]
H2[0] = 0;OWHT[0] = 0;OWHT[1] = 0;OWHT1[0] = 0;OREF[1] = 0;OREF[2] = 0;OREF[3] = 0
If P61$[54,54] = "N" Let OWHT[0] = 1;OWHT[1] = -1;OWHT1[0] = D8
H0[4] = C1[1];H0[11] = C1[2];H4[2] = 0;H5[12] = SZN
If AXCESS Let H4[2] = 1 ! SET DEFAULT WHSE FOR AXECESS OTHERS MUST COME FROM WHSEDFLT
If PD1[2] Let H4[2] = PD1[2]
If A0[1] = DWH And H5[7] = 16 Let DWH = 0
If DWH Let H4[2] = DWH
If H4[2] = 0 Let H4[2] = 1 !  if no wh from access defaults, use wh 1
h0[5]=0 ! FIRST ORDER
H4[2] = WHSEFROM ! above NOT USED - ALWAYS WHSEFROM
H0[12] = C2[0];H4 = C2[1];H6[0] = C1[7]
H5[7] = 1 ! DEFAULT ORDER TYPE 1
H5[8] = PD1[1] \ If Not(H5[8]) Let H5[8] = CFIN[4]
If H5[8] < 1 Or H5[8] > 99 Let H5[8] = 1 ! "check division
If A0[1] If A0[1] < CWH Let H5[7] = 16;H5[11] = A0[1] ! transfer
If (Not(A0[1]) Or A0[1] >= CWH) And C13[0] Let H5[7] = C13[0]
H5[7]=16 ! ignore above - ALWAYS WHSE TRANSFER
H5[11] = WHSETO ! ignore above - ALWAYS WHSETO
slsmsplt[0]=100 ! no comm split
if p61$[109,109]="Y"
MDCust[0]=H0[4];MDCust[1]=srn[1]
Endif
Gosub L_8000 \ Goto OUTEND ! "check bill to
Gosub L_8800 ! "write header
ORDERNUM = H0[7]
Return 
TRANSFER_LINE: Rem set up lines
K1$ = " ",K1$;K1$ = PRODA$[140,151];K1$[13,14] = WHSEFROM Using "##"
Search #CH_PRWH,2,1;K1$,REC_PRWH,E \ If E Gosub ERR_SEARCH
Gosub READ_PRWH
AVAIL = W3[0] - W3[2] ! get avaL
R[11] = LINEREC
Gosub L_2000 ! clear fields
Gosub READ_ROLNEW ! get the order that it's transfered from
Key0$ = " ",Key0$
Key0$ = L2[1] Using "######"
Key0$[7] = L3[2] Using "###"
LOOP_ROLNEW: Rem get next available
Search #CH_Rol,3,1;Key0$,R[11],E \ If E If E <> 2 Gosub ERR_SEARCH
If E = 2 Goto GOT_LINE
WK = Key0$[1,6]
If WK = H0[7]
  L3[2] = Key0$[7] ! hold on to
  Goto LOOP_ROLNEW
End If 
GOT_LINE: If P61$[54,54] <> "Y" ! AUTHORIZATION feature us off
	Let L3[1] = 1
else
	If OWHT[0]=0 
		let L3[1]=0 ! not authorized yet - no stk update
	else
		let L3[1]=1 ! transfer order has been authorized
	endif
endif
L3[2] = L3[2] + 1
J0 = ch_rol \ Gosub L_5000
R[11] = V1 ! new rec #
L3[3] = OL3[3]
L4[3] = WHSEFROM
L6[2] = OL6[2]
L7[2] = OL7[3]
L7[3] = 0 !just cover our ass
L7[5] = L7[2]
iF l3[1]=0 ! NO STK UPDATE
	L7[4]=L7[2]
ELSE
	If AVAIL >= L7[2] Let L7[4] = L7[2] ! enough to cover
	If AVAIL < L7[2]
	  If BOTRANSFER ! can b/o on transfer
		L7[4] = AVAIL ! move what we can in to shipped
		L7[3] = L7[2] - AVAIL
	  Else 
		L7[4] = L7[2]
	  End If 
	End If 
END IF
S3[3] = OS3[3]
Gosub READ_PROD
L6[4] = A[6]
If Not(A[5]) Let A[5] = 1
S3[4] = FNR(Abs((L6[4] * L7[4]) / A[5]))
S3[14] = OS3[14]
Gosub WRITE_ROLNEW
J0 = ch_rol;V1 = R[11];D = 1
A$ = " ",A$
A$[1,6] = L2[1] Using "######"
A$[7,9] = L3[2] Using "###"
Gosub L_5050
D = 2
A$ = " ",A$
A$[1,6] = L4[0] Using "######"
A$[7,12] = L2[1] Using "######"
A$[13,15] = L3[2] Using "###"
Gosub L_5050
Write #CH_Rol,LINEREC,610;ORDERNUM; ! orig ord line 
If p60$[44,44]="Y"
	clear etr.
	etr.EtAction=11 ! add new line
	gosub doedttrk:
endif
Return 
UPDATE_LOTS_AND_STUFF: Rem update avail
if L3[1]=0 RETURN ! NO STK UPDATE
K1$ = " ",K1$;K1$ = PRODA$[140,151];K1$[13,14] = WHSEFROM Using "##"
Search #CH_PRWH,2,1;K1$,REC_PRWH,E \ If E Gosub ERR_SEARCH
Gosub READ_PRWH
W3[2] = W3[2] + L7[4]
Gosub WRITE_PRWH
Gosub READ_PROD
A[3] = A[3] + L7[4]
Gosub WRITE_PROD
S9[2] = R[8] ! header record
S9[4] = 201
!S9[2]=OHR;S9[3]=0;S9[4]=source ! determine program #?
!If credit let S9[3]=4;S9[4]=243 ! credit
!			if s9[4]<=0 let s9[4]=208 ! send something!
S9[12]=R[11] ! PASS THE LINE JUST UPDATED (new single line mxrasl5)?
FChan[0]=1;FChan[1]=ch_PRod;FCHan[2]=CH_ROH;FChan[3]=CH_ROL
FChan[4]=0;FChan[5]=CH_ccodes;FChan[6]=0;FChan[7]=0
FChan[8]=0;FChan[9]=0
! Call dxsave(0,"tmp/jcs.txt!")
Call "MXRASL5.DL4",intco,Ctlc,S9[],FChan[]
! Call "MX201LOTS",S9[]
Return 
SET_ROLTAG: Rem set tag for from and to
LPONUM$ = " ",LPONUM$
LJOBNUM$ = " ",LJOBNUM$
PSNUM$ = " ",PSNUM$
MSG1$ = " ",MSG1$
MSG2$ = " ",MSG2$
MSGS$=" ",MSGS$
TL2[0] = 11
TL2[1] = ORDERNUM
LINENUM = L3[2]
A$ = " ",A$
A$ = TL2[1] Using "######"
A$[7,9] = LINENUM Using "###"
Gosub CHECK_ROLTAG
LJOBNUM$ = "From Order "+Str$(FromOrder)+" Line "+Str$(OL3[2])+Blank$
Mat Write #CH_TAG,REC_TAG,44;LJOBNUM$;
! per spec a total of 4 lines on transfer
x2=oshpdate \ if x2<=0 let x2=th0[9]
x$=pdate$(x2)
LPONUM$=x$+" "+Str$(CUSTID)+" "+Ts1$[1,30]+Blank$
!message line 2 <00/00/00 customer # and customer name from copied sales order>
Mat Write #CH_TAG,REC_TAG,14;LPONUM$;
cnvtu[0]=0;cnvtu[1]=un[0];cnvtu[2]=1
cnvta=l7[2] \ gosub convert
PSNUM$="QTY ORDERED "+STR$(AMOUNT)+BLANK$
!message line 3 <QTY ORDERED XXXXX>
Mat Write #CH_TAG,REC_TAG,74;PSNUM$;
GOSUB GET_ZNDESC
MSG1$=TS2$[19,20]+" "+D5$+BLANK$
!message line 4 <Zone # and Name>
Mat Write #CH_TAG,REC_TAG,104;MSG1$;
! ************* add message to original order **********
LPONUM$ = " ",LPONUM$
LJOBNUM$ = " ",LJOBNUM$
PSNUM$ = " ",PSNUM$
MSG1$ = " ",MSG1$
MSG2$ = " ",MSG2$
MSGS$=" ",MSGS$
TL2[1] = FROMORDER
LINENUM = OL3[2]
A$ = " ",A$
A$ = TL2[1] Using "######"
A$[7,9] = LINENUM Using "###"
Gosub CHECK_ROLTAG
! task 42425 - move to last 2 mesg lines possible
MSGS$[691,714]=ORDERNUM Using "On Transfer Order ######"
MSGS$[721]="From Whse "+Str$(WHSEFROM)+Blank$
MAT WRITE #CH_TAG,REC_TAG,164;MSGS$;
!LJOBNUM$[1,24] = ORDERNUM Using "On Transfer Order ######"
!Mat Write #CH_TAG,REC_TAG,44;LJOBNUM$;
!LPONUM$="From Whse "+Str$(WHSEFROM)+Blank$
!Mat Write #CH_TAG,REC_TAG,14;LPONUM$; ! This is line 2 for some reason!?
Return 
CHECK_ROLTAG: Rem
Search #CH_TAG,2,1;A$,REC_TAG,E
If Not(E)
  Mat Read #CH_TAG,REC_TAG,14;LPONUM$
  Mat Read #CH_TAG,REC_TAG,44;LJOBNUM$
  Mat Read #CH_TAG,REC_TAG,74;PSNUM$
  Mat Read #CH_TAG,REC_TAG,104;MSG1$
  Mat Read #CH_TAG,REC_TAG,134;MSG2$
  mat read #ch_tag,rec_tag,164;MSGS$
  Return 
End If 
E = 2
Search #CH_TAG,1,0;A$,REC_TAG,E \ If E Gosub ERR_SEARCH
Mat Write #CH_TAG,REC_TAG;TL2
Mat Write #CH_TAG,REC_TAG,12;LINENUM
Mat Write #CH_TAG,REC_TAG,14;LPONUM$
Mat Write #CH_TAG,REC_TAG,44;LJOBNUM$
Mat Write #CH_TAG,REC_TAG,74;PSNUM$
Mat Write #CH_TAG,REC_TAG,104;MSG1$
Mat Write #CH_TAG,REC_TAG,134;MSG2$
mat write #ch_tag,Rec_tag,164;MSGS$;
A$ = " ",A$
A$[1,6] = TL2[1] Using "######"
A$[7,9] = LINENUM Using "###"
Search #CH_TAG,4,1;A$,REC_TAG,E \ If E Gosub ERR_SEARCH
Return 
TOTAL_ORDER: Rem call out to order total
PASSINFO[3] = 1 !write total out
PASSINFO[4] = 1 !recalc on order amount
PASSINFO[5] = 1 !clear man
PASSINFO[6] = 1 !clear pos
PASSINFO[10] = 99! ar term misc cost charge   - bypass 
CH[2] = CH_Zone ! 24 zone
CH[3] = CH_Prod !3 prod
CH[4] = 0 ! 4 ! comcode
CH[5] = CH_Cust ! 5 !cust
CH[6] = ch_prwh ! 30 !prwh
CH[7] = ch_ros ! 9 ! ros
CH[8] = CH_roh ! 8 ! roh
CH[9] = ch_rot ! 10 ! rot
CH[10] = ch_rol ! 11 ! rol
CH[11] = 0 ! 12 ! sproddesc
CH[12] = 0 ! 31 ! custtax
CH[13] = 0 ! 14 ! slsm
CH[14] = 0 ! 15 !tax code
CH[15] = 0 ! 16 !sprodlot
CH[16] = 0 ! 17 !sordlot
CH[17] = ch_ccodes ! 26 ! ccodes
S9[2] = R[8]
S9[4] = 201
Call "ordertotal",S9[],R[8],PASSINFO[],CH[],T1[],T2[],MCODE[],MCHARGE[],TOT[],MCTXBL[],DCLVL,R[5],V1,CFIN[]
!Call "ORDERTOTAL",S9[],H1,PARAM[],ch[],T1[],T2[],MCODE[],MCHARGE[],TOT[],MCTXBL[],DCLVL,R5,V1,CFIN[]

Return 
L_1300: Rem GET CURRENT DATE
J4$ = "JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC"
For K1 = 1 To 12
  If J1$[1,3] = J4$[K1 * 3 - 2,K1 * 3] Goto L_1360
Next K1
E = 0 \ Gosub ERR_SEARCH
L_1360: X$ = "/",X$
X$[1,2] = K1 Using "##"
X$[4,5] = J1$[5,6]
X$[7,8] = J1$[11,12]
For K1 = 1 To 8
  If X$[K1,K1] = " " Let X$[K1,K1] = "0"
Next K1
Return 
L_2000: Rem ===== clear variables (for new line)
L2[1] = H0[7] ! "department & order
L2[0] = 11
LTAX1 = 0;LTAX2 = 0 ! cct104965
For CTR = 0 To 100
  If CTR < 2 Let S2[CTR] = 0;WHLM[CTR] = 0
  If CTR < 3 Let C3[CTR] = 0;EUN[CTR] = 0
  If CTR < 3 Let LPEUN[CTR] = 0
  If CTR < 3 Let UN[CTR] = 0
  If CTR < 4 Let L4[CTR] = 0;L5[CTR] = 0
  If CTR < 4 Let L3[CTR] = 0
  If CTR < 6 Let L6[CTR] = 0
  If CTR < 7 Let OLM[CTR] = 0;PFU2[CTR] = 0;UNF[CTR] = 0
  If CTR < 8 Let A1[CTR] = 0
  If CTR < 13 Let L7[CTR] = 0
  If CTR < 18 Let S3[CTR] = 0
L_2060: If CTR < 21 Let PFU1[CTR] = 0
  If CTR < 25 Let B[CTR] = 0;W3[CTR] = 0
  If CTR < 34 Let A[CTR] = 0
L_2075: Next CTR
BASE = 0;BUYER = 0;DELFLAG = 0;DISPLAY = 0;JUMP_ = 0;L9[0] = 0;LPQTY = 0
LCO = 0;LCO[1] = 0;CST[0] = 0;QPB = 0;LPRINTED = 0;LP_DATE = 0;LP_TIME = 0;ROL0 = 0
VALVEND = 0;VENDOR = 0;WTEDIT = 0;X2 = 0;X3 = 0;ZLINE = 0
A2$ = " ",A2$;L1$ = " ",L1$;L6$ = " ",L6$
MT$ = " ",MT$;U5$ = " ",U5$
A$ = " ",A$
S3$ = " ",S3$
FLAG = 0;L4[0] = PRODREC;L4[1] = H0[11];CTWT[1] = H5[0];L4[3] = WHSEFROM
Return 
L_5000: Rem "========================== standard search (get new record #)
E = 2 \ V1 = 0
Search #J0,1,0;J2$,V1,E \ If E Gosub ERR_SEARCH
Return 
L_5050: Rem "========================== standard search (insert keys)
Search #J0,4,D;A$,V1,E \ If E Gosub ERR_SEARCH
Return 
CHK_ORDER_NUM: Rem check to see if there is a record in ROH with this order#
A$ = " ",A$ \ A$[3,8] = N0 Using "######"
For I = 1 To 99
  A$[1,2] = I Using "##"
  Search #J0,2,1;A$,V1,E \ If E > 1 Gosub ERR_SEARCH
  If Not(E) Return 
Next I
Return 
L_6500: Rem DEFAULT SHIPLIST
A$ = " ",A$;A$ = X3 / 10 ^ 6 + SCUST Using "######.######"
Search #CH_SHIP,2,1;A$,V1,E \ If E > 1 Gosub ERR_SEARCH
If E Goto L_6550
SRN[1] = X3 \ If X3 = 0 Let SRN[3] = 1 Else Let SRN[3] = 2
SHPFND = 99
Gosub L_6140 ! "shiplist exists; get info
L_6550: Rem "no record
If P61$[34,34] = "Y" And SHPFND = 0 ! "got this one even if no record
  Gosub CSMZONE ! "check default shiplist
  H5[1] = H0[10] ! "from multiZone
End If 
Return 
L_6140: Rem FOUND
R[13] = V1 \ Gosub L_8600 ! "read shiplist
F1 = 0
DCLVL = SL2[4]
L_6185: If R$[1,2] = "  " Let R$ = V0$
If R$[1,2] = "  " Let R$ = "OUR TRUCK   "
If P61$[34,34] = "Y" Gosub CSMZONE
V0$ = R$[1,12] \ S2$[19,20] = R$[32,33]
L_6198: Return 
CSMZONE: Rem "Cust/Shipto MultiZone
!For X1 = 1 To 9
!  If X1 <> 1 And X1 <> 5 And MANCHGD[X1] = 9 Return ! "made changes manually - no recalc
!Next X1
If Not(SRN[2]) Let SRN[2] = SCUST
If Not(H0[9]) Let H0[9] = D8
Call "MXOHCSZONE",SRN[2],SRN[1],H0[9],H5[8],H4[2],H0[10],CSZONE$,H4[1],IntCo
R$[32,33] = CSZONE$
S2$[19,20] = R$[32,33] ! "zone
Return 
L_7700: Rem  *UNPACK DATE  X2 TO X$      V1.0  4/04/84  G.DOSCHER
X$[4,6] = Fra(X2 / 10 ^ 2) * 10 ^ 2 + 10 ^ 2 Using "###"
X$[7,9] = Int(X2 / 10 ^ 4) + 10 ^ 2 Using "###"
X$[4,4] = "/" \ X$[7,7] = "/" \ X$ = X$[2]
If Not(X2) Let X$ = "        "
Return 
L_7800: Rem  *PACK DATE    X$ TO X2      V1.0  4/04/84  G.DOSCHER
X2 = X$[4,5] \ X1 = X$[1,2] \ X2 = X2 + X1 * 10 ^ 2
X1 = X$[7,8] \ X2 = X2 + X1 * 10 ^ 4
Return 
L_7900: Rem GET CURRENT DATE
U5$ = ""
J4$ = "JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC"
Call Time(U5$)
For K1 = 1 To 12
  If U5$[1,3] = J4$[K1 * 3 - 2,K1 * 3] Goto L_7940
Next K1
Return ! Print "\15\DATE ERROR - STOP AT 7935" \ Stop 
L_7940: X$ = "/",X$
X$[1,2] = K1 Using "##"
X$[4,5] = U5$[5,6]
X$[7,8] = U5$[11,12]
For K1 = 1 To 8
  If X$[K1,K1] = " " Let X$[K1,K1] = "0"
Next K1
Return 
L_8000: Rem "============================== check bill-to
A$ = " ",A$ \ A$ = C1[4] Using "######"
Search #CH_Cust,2,1;A$,V1,E \ If E > 1 Gosub ERR_SEARCH
If E Goto L_8070
Mat Read #CH_Cust,V1,30;C1$;
Read #CH_Cust,V1,348;C1$[108,117];
Read #CH_Cust,V1,394;C2$[7,21];
H0[1] = C1[4]
SRN[5] = 0
If P61$[24,24] = "Y" And H0[1] <> H0[4]
  Mat Read #CH_Cust,V1,498;BILLTAXTYPE;
  If BILLTAXTYPE
    SRN[4] = BILLTAXTYPE
    DFLT_TAX_TYPE = BILLTAXTYPE
  End If 
End If 
Return 1
L_8070: Return 
Get_ZNDesc: ! for message
A$ = " ",A$ \ A$ = TS2$[19,20]
Search #CH_ZONE,2,1;A$,V1,E \ If E > 1 Gosub ERR_SEARCH
if not(e)
	Mat Read #CH_ZONE,V1,0;D5$; ! "zone desc
else
	d5$="ZONE "+TS2$[19,20]+BLANK$
ENDIF
RETURN
L_8100: Rem "============================= zone
SHIPVIA$ = V0$
A$ = " ",A$ \ A$ = S2$[19,20]
Search #CH_ZONE,2,1;A$,V1,E \ If E > 1 Gosub ERR_SEARCH
If E Let D0 = 0 \ Goto L_8125
Read #CH_ZONE,V1,32;S5; ! only if editing zone
Read #CH_ZONE,V1,28;D0;
Mat Read #CH_ZONE,V1,0;D5$; ! "zone desc
Mat Read #CH_ZONE,V1,76;V0$; ! "ship via
L_8125: If V0$ = "            " Or V0$ = "" Let V0$ = SHIPVIA$
If V0$ = "            " Or V0$ = "" Let V0$[1,12] = "OUR TRUCK   " ! still blank
X2 = H0[9]
If P61$[34,34] = "Y" ! "cust/shiplist multi-zone
  VDATE = H0[10] ! "already calculated
  Goto BYPDCALC
End If 
!If AZD ! "manually changed date - ask if recalc
!  Gosub ZNCHGDATE \ Return ! "return=NO, +1=YES
!  AZD = 0 ! "if yes once - always yes
!End If 
X$ = X2 Using "&&&&&&"
Call DateToJulian(1,X$,X$,E)
X2 = X$[1,5]
X2 = X2 + D0
DT3[0] = X2 \ DT3[1] = X2 \ FLAG = 0
Call "JULIANUTIL",DT3[],X$,FLAG
X2 = X$
H0[10] = X2;H5[1] = X2
VDATE = X2;STAT = 1;WARN = 0;PARAM[0] = H4[2];PARAM[1] = H5[8]
Call "validdate",VDATE,STAT,WARN,PARAM[]
BYPDCALC: Rem "Bypass Date Calc
H0[10] = VDATE;H5[1] = VDATE
J1$ = "" \ Call Time(J1$)
CURHH = J1$[15,16]
CURMM = J1$[18,19]
CURSS = J1$[21,22]
CURTIME = CURHH * 10000 + CURMM * 100 + CURSS
If CURTIME > CUTTIME
  X$ = H0[10] Using "&&&&&&"
  Call DateToJulian(1,X$,X$,E)
  X2 = X$[1,5]
  X2 = X2 + 1
  DT3[0] = X2 \ DT3[1] = X2 \ FLAG = 0
  Call "JULIANUTIL",DT3[],X$,FLAG
  X2 = X$
  H0[10] = X2
  VDATE = X2;STAT = 1;WARN = 0;PARAM[0] = H4[2];PARAM[1] = H5[8]
  Call "validdate",VDATE,STAT,WARN,PARAM[]
  H0[10] = VDATE
End If 
X2 = VDATE \ Gosub L_7700
!If AXCESS Print @14,11;X$ Else Print @68,11;X$ ! "ship date
!If Not(AXCESS) Print @68,12;X$; ! "due date
Return 

L_8600: Rem "================================ read shiplist
TAXCODE = 0;TAXTYPE = 0
CUS = A$[1,6]
Read #CH_SHIP,R[13],0;S1$[1,117];
Read #CH_SHIP,R[13],117;SHCONTACT$;
If SHCONTACT$[1,20] <> "                    " Let C5$[1,20] = SHCONTACT$[1,20]
If P61$[34,34] <> "Y"
  Mat Read #CH_SHIP,R[13],150;R$;
  H4[1] = R$[28,31];S2$[19,20] = R$[32,33] ! Stop, Zone
Else 
  Read #CH_SHIP,R[13],150;R$[1,25];
End If 
Mat Read #CH_SHIP,R[13],184;SL2;
S2$[1,15] = R$[13,25] + "  "
If CUS <> C1[1] If R$[32,33] = " 0" Or R$[32,33] = "  " Let S5 = 0
If SL2[1] Let H5[12] = SL2[1] Else If CUS <> C1[1] Let H5[12] = 0 ! "default sales area
TAXCODE = SL2[0]
TAXTYPE = SL2[3]
If P61$[24,24] = "Y" Let TAXTYPE = SRN[4]
If TAXTYPE <> 0 And TAXCODE <> 0 Goto FOUNDTAX
If SRN[1] <> 0 ! look in default shipping info
  KEYSHIP$ = SRN[2] Using "######.######"
  Search #CH_SHIP,2,1;KEYSHIP$,REC,E \ If E > 1 Gosub ERR_SEARCH
  If Not(E)
    If Not(TAXTYPE)
      Read #CH_SHIP,REC,196;TAXTYPE;
    End If 
    If Not(TAXCODE)
      Read #CH_SHIP,REC,184;TAXCODE;
    End If 
    If TAXTYPE <> 0 And TAXCODE <> 0 Goto FOUNDTAX
  End If 
End If 
KEYSHIP$ = SRN[2] Using "######" ! look in customer master file
Search #CH_Cust,2,1;KEYSHIP$,REC,E \ If E > 1 Gosub ERR_SEARCH
If Not(E)
  If Not(TAXTYPE)
    Read #CH_Cust,REC,498;TAXTYPE;
  End If 
  If Not(TAXCODE)
    Read #CH_Cust,REC,196;STAXCODE;
    TAXCODE = STAXCODE
  End If 
End If 
FOUNDTAX: Rem taxcode & tax type found
If TAXCODE
  H4[0] = TAXCODE
End If 
If TAXTYPE Let SRN[4] = TAXTYPE Else Let SRN[4] = DFLT_TAX_TYPE
Return 
L_8800: Rem "================================ write header
Mat Write #CH_Roh,R[8],0;H0
Mat Write #CH_Roh,R[8],52;H3
Write #CH_Roh,R[8],56;TOT_SELL
Mat Write #CH_Roh,R[8],62;DMFLAG
Mat Write #CH_Roh,R[8],64;LOCKPORT
Mat Write #CH_Roh,R[8],66;V0$
Mat Write #CH_Roh,R[8],78;H4
Mat Write #CH_Roh,R[8],84;C5$
Mat Write #CH_Roh,R[8],104;H5
Mat Write #CH_Roh,R[8],172;S3
Mat Write #CH_Roh,R[8],272;H1$
Mat Write #CH_Roh,R[8],278;SLSM
Mat Write #CH_Roh,R[8],408;H6
Mat Write #CH_Roh,R[8],444;HMAT$
Mat Write #CH_Roh,R[8],446;P0$
Mat Write #CH_Roh,R[8],466;HFAX
Write #CH_Roh,R[8],482;H2
Mat Write #CH_Roh,R[8],486;OWHT
Mat Write #CH_Roh,R[8],490;OWHT1
Mat Write #CH_Roh,R[8],504;PICKBY
Mat Write #CH_Roh,R[8],512;OREF;
Mat Write #ch_roh,R[8],548;SlsmSplt;
Mat Write #ch_roh,R[8],568;COMMSVGCHG;
Mat Write #ch_roh,R[8],574;AOLoc$;
Mat Write #ch_roh,R[8],582;ORDCOUNT;
Mat Write #ch_roh,R[8],586;PHUP;
Mat Write #ch_roh,R[8],592;AKFlag;
Mat Write #ch_roh,R[8],596;B4k$;
Mat Write #ch_roh,R[8],598;SplitFlag;
Mat Write #ch_roh,R[8],600;CommBase;
Return 
L_8900: Rem "================================ write totals
Mat Write #CH_Rot,R[10];T1
Mat Write #CH_Rot,R[10],8;T2
Mat Write #CH_Rot,R[10],168;MCODE
Mat Write #CH_Rot,R[10],208;MCHARGE
Mat Write #CH_Rot,R[10],328;TOT;
Write #CH_Rot,R[10],400;INVNO; ! "clear it
Mat Write #ch_ROt,r[10],406;totbcost;
mat write #ch_rot,R[10],412;EML$;
Return 
L_8940: Rem "================================ write ship to
Mat Write #CH_Ros,R[9];S1
Mat Write #CH_Ros,R[9],8;S1$
Mat Write #CH_Ros,R[9],126;S2$
Mat Write #CH_Ros,R[9],146;S5 ! "truck #
Mat Write #CH_Ros,R[9],150;S6
Mat Write #CH_Ros,R[9],154;SRN
Write #CH_Ros,R[9],190;INVNO; ! "clear it
Mat Write #ch_Ros,R[9],196;MDCust;
Return 
GET_CUST: Rem gind the customer
Key0$ = " ",Key0$
Key0$ = TRANCUST Using "######"
Search #CH_Cust,2,1;Key0$,R[5],E \ If E Gosub ERR_SEARCH
Mat Read #CH_Cust,R[5],0;C5$;
Mat Read #CH_Cust,R[5],19;P$;
Mat Read #CH_Cust,R[5],30;C1$;
Mat Read #CH_Cust,R[5],142;C1;
Mat Read #CH_Cust,R[5],194;C2;
Read #CH_Cust,R[5],348;C1$[108,117];
Read #CH_Cust,R[5],376;R$[32,33];
Mat Read #CH_Cust,R[5],378;C7;
Mat Read #CH_Cust,R[5],388;C2$;
Mat Read #CH_Cust,R[5],660;C11;
Mat Read #CH_Cust,R[5],486;A0;
Mat Read #CH_Cust,R[5],544;CFIN;
Read #CH_Cust,R[5],598;SZN;
Mat Read #CH_Cust,R[5],692;C13;
Mat Read #CH_Cust,R[5],696;DWH;
Return 
READ_PROD: Rem "Read Prod info
Mat Read #CH_PROD,REC_PROD,0;PRODA$;
Mat Read #CH_PROD,REC_PROD,156;B;
Mat Read #CH_PROD,REC_PROD,256;A;
Mat Read #CH_PROD,REC_PROD,512;PFU1;
Mat Read #CH_PROD,REC_PROD,554;PFU2;
Return 
WRITE_PROD: Rem "write Prod info
Mat Write #CH_PROD,REC_PROD,256;A;
Return 
READ_PRWH: Rem "prod whse Info
Mat Read #CH_PRWH,REC_PRWH,78;W3;
Return 
WRITE_PRWH: Rem "prod whse Info
Mat Write #CH_PRWH,REC_PRWH,78;W3;
Return 
READ_HEADER: Rem get the info for current header
Mat Read #CH_Roh,R[8];H0
Mat Read #ch_roh,r[8],52;H3 
Mat Read #CH_Roh,R[8],78;H4
Mat Read #CH_Roh,R[8],104;H5
Mat Read #CH_Roh,R[8],408;H6
Mat Read #CH_Roh,R[8],486;OWHT;
Return 
READ_ROLNEW: Rem read order
Mat Read #CH_Rol,R[11],0;OL2
Mat Read #CH_Rol,R[11],8;OL3
Mat Read #CH_Rol,R[11],16;L4
Mat Read #CH_Rol,R[11],56;OL6
Mat Read #CH_Rol,R[11],80;L6$
Mat Read #CH_Rol,R[11],140;L1$
Mat Read #CH_Rol,R[11],168;OL7
Mat Read #CH_Rol,R[11],250;UN
Mat Read #CH_Rol,R[11],256;S2
Mat Read #CH_Rol,R[11],260;OS3
Mat Read #CH_Rol,R[11],368;MT$
Mat Read #CH_Rol,R[11],370;S3$
Mat Read #CH_Rol,R[11],446;EUN
Mat Read #CH_Rol,R[11],452;UNF;
Mat Read #CH_Rol,R[11],610;TROrdNum;
Return 
WRITE_ROLNEW: Rem this should be the new transfer
Mat Write #CH_Rol,R[11],0;L2
Mat Write #CH_Rol,R[11],8;L3
Mat Write #CH_Rol,R[11],16;L4
Mat Write #CH_Rol,R[11],32;L5
Mat Write #CH_Rol,R[11],56;L6
Mat Write #CH_Rol,R[11],80;L6$
Mat Write #CH_Rol,R[11],140;L1$
Mat Write #CH_Rol,R[11],160;L9
Mat Write #CH_Rol,R[11],168;L7
Mat Write #CH_Rol,R[11],246;PL
Mat Write #CH_Rol,R[11],250;UN
Mat Write #CH_Rol,R[11],256;S2
Mat Write #CH_Rol,R[11],260;S3
Mat Write #CH_Rol,R[11],368;MT$
Mat Write #CH_Rol,R[11],370;S3$
Mat Write #CH_Rol,R[11],404;OLM
Mat Write #CH_Rol,R[11],446;EUN
Mat Write #CH_Rol,R[11],452;UNF
Mat Write #CH_Rol,R[11],494;LCO
Mat Write #CH_Rol,R[11],502;CST
Mat Write #CH_Rol,R[11],508;LTAX1
Mat Write #CH_Rol,R[11],538;LTAX2
Mat Write #CH_Rol,R[11],514;CTWT
Mat Write #CH_Rol,R[11],542;QPB
Write #CH_Rol,R[11],548;LPRINTED
Write #CH_Rol,R[11],550;OWHS
Write #CH_Rol,R[11],552;LP_DATE
Write #CH_Rol,R[11],556;LP_TIME
Write #CH_Rol,R[11],564;ROL0;
Write #CH_Rol,R[11],610;FROMORDER;
Write #ch_Rol,R[11],614;B4K$;
Return 
OUTEND_RESET: Rem "
If H0[0]<9 return ! already reset
A$ = " ",A$
A$[1,2] = H0[0] Using "##"
A$[3] = H0[7] Using "######"
Search #CH_Roh,2,1;A$,R8,E \ If E Gosub ERR_SEARCH
Search #CH_Roh,5,1;A$,R8,E \ If E Gosub ERR_SEARCH
H0[0] = H6[2] ! put in edit process
A$ = " ",A$
A$[1,2] = H0[0] Using "##"
A$[3] = H0[7] Using "######"
Search #CH_Roh,4,1;A$,R8,E \ If E Gosub ERR_SEARCH
Mat Write #CH_Roh,R8;H0;
Mat Write #CH_Rol,LINEREC,610;ORDERNUM;
Return
DoEdttrk: ! edit track (add new line)
clear fchan[]
fChan[0]=-1;fchan[1]=-1 ! no files open - etrack/usercntrl
	etr.OrdNum=L2[1]
	etr.LineNum=L3[2]
	etr.Status=H6[2] \ IF etr.Status<=0 let etr.Status=H0[0]
	etr.ProdCode$=L1$[1,12]
	etr.OrgQtyOrd=0;etr.NewQtyOrd=L7[2]
	etr.OrgQtyShip=0;etr.NewQtyShip=L7[4]
	etr.OrgQtyBO=0;etr.NewQtyBO=L7[3]
	e$=""
	! date,time,port,access gotten in call
	etr.AccessCode$=Userid$+Blank$
	etr.UMSell=UN[0]
	etr.NstkFlag=L3[0]
	etr.OrgOrdTot=t2[0] ! would be zero
	etr.CustNum=H0[4]
	etr.InvNum=OREF[1]
	etr.Slsm=H0[11]
	etr.OrgUnitPrice=0 ! oorl.NETPRICE ! UnitPrice (actually net price)
	etr.NewUnitPrice=olm[3] ! corl.netprice ! UnitPrice
	etr.UMPrice=un[1] ! corl.UMPrice
	etr.UMCost=UN[2] ! corl.UMCost
	etr.OrgLoadCost=0 ! oorl.UnitCost
	etr.NewLoadCost=L5[1] ! corl.UnitCost
	etr.UnitNetWgt=l6[4] ! corl.LbsUnit
	etr.NetWgtFact=UNF[5] ! corl.WgtFactor
	etr.SpareNU$=Blank$
	if etr.etaction=11 or etr.etaction=2 ! add SET ORIG=NEW/cURR on ADD or DELETE
		etr.OrgQtyOrd=etr.NewQtyOrd
		etr.OrgQtyShip=etr.NewQtyShip
		etr.OrgQtyBO=etr.NewQtyBO
		etr.OrgUnitPrice=etr.NewUnitPrice
		etr.OrgLoadCost=etr.NewLoadCost
	Endif	
	Call MakeEdittrack(e$,IntCo,fchan[],etr.)
return

Rem {begin rtn.convert.s}
CONVERT: Rem "UNIT CONVERSION RETURNS AMOUNT  (rev 01/07/1992)   ! 20040 REM
If CNVTU[2] = 3 Or CNVTU[2] = 4 Goto CVTSTARTA ! "um window
If CNVTU[2] = 1 And CNVTU[1] = CNVTU[0] Let AMOUNT = CNVTA \ Goto CVTDONE ! "going to same units
If CNVTU[0] = -2 Or CNVTU[1] = -2 Let AMOUNT = CNVTA \ Goto CVTDONE ! "lot
If CNVTU[2] = 0 Goto CVTSTARTA !!THIS TESTS IF VALID CONVERSION
If Not(CNVTA) Let AMOUNT = 0 \ Goto CVTDONE ! "none there
CVTSTARTA: !
CVTSTARTB: Rem "====== unibasic 5+ logic
Call "MXPRCONV5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
If CNVTU[2] = 0 Goto CVTDONE !!TEST IF VALID CONVERSION
If FLAG Let E = FLAG \ Gosub ERR_SEARCH
AMOUNT = CNVTA
CVTDONE: Return 
Rem {end rtn.convert.s}
Rem {begin rtn.input.s}
ISINPUT: Rem  INPUT SUBROUTINE  V2.2  4/84  1/91  CHAR ATTRB  G.DOSCHER
Return 
ISERRMSG:  Return 
ISDUNPACK: Rem  *UNPACK DATE  X2 TO X$      V1.0  4/04/84  G.DOSCHER
X$ = " ",X$ \ X$[10] = ""
X$[1,3] = Int(X2 / 10 ^ 2 - Int(X2 / 10 ^ 4) * 10 ^ 2) + 10 ^ 2 Using "###"
X$[4,6] = Fra(X2 / 10 ^ 2) * 10 ^ 2 + 10 ^ 2 Using "###"
X$[7,9] = Int(X2 / 10 ^ 4) + 10 ^ 2 Using "###"
X$[4,4] = "/" \ X$[7,7] = "/" \ X$ = X$[2]
If Not(X2) Let X$ = "        "
Return 
ISDPACK: Rem  *PACK DATE    X$ TO X2      V1.0  4/04/84  G.DOSCHER
X2 = X$[4,5] \ X1 = X$[1,2] \ X2 = X2 + X1 * 10 ^ 2
X1 = X$[7,8] \ X2 = X2 + X1 * 10 ^ 4
Return 
Rem {end rtn.input.s}
OUTEND: Rem "
! Window Close 
if ch_whinfo TRY Close #CH_WHINFO ELSE REM
IF CH_SHIP TRY Close #CH_SHIP ELSE REM
IF CH_ZONE TRY Close #CH_ZONE ELSE REM
IF CH_TAG TRY Close #CH_TAG ELSE REM
End 
ERR_SEARCH: Rem
ENUM = E ;ELINE = Spc(16);CTERR = 0
If E = 5 Let CTERR = Err(8)
e$ = "RETURN STATUS",(E + (CTERR * .001))
e$ = e$,"/ STATEMENT",ELINE," IN PROGRAM "+msc$(4)
Error 11000
End
Rem {begin rtn.error.s}
ERR_TRAP: Rem *Error routine (escape trap)   V3.1 8/94 G.DOSCHER/REK
! dx replace entire error routine
include "src/callmainerrnet.inc"
End 