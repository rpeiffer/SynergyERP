! >>> Program acl.IMAGE.in
!
! description Airclic Event Printed receipt PDF in / process
! loadsave -w -n 100,10 -o prog/dxport/acl.image.in.dl4 src/acl.image.in.src
!
! 1.0 mm/dd/yyyy change??
!
include "src/copyright.inc"

Rem ACL.IMAGE.IN.src - Receive back event file
Rem 18552
Rem file name passed in - generated by sending perl script/program that creates it
! THIS PROGRAM TAKES THE .tifs GENERATED FROM AirClic printed receipt numbers
! and adds them to the imaging system - code repurposed from im472
! coming in is partial file name, orderid, customer, orderdate
! as we don't know how many pages were created from the pdf
! we need to search the directory were the files reside for the same name
! that ends in .tif
! example: incoming filename = tmp/aclevents/336814_130513_pr (order 336814, on 05/13/13)
!  a full path to file!
!  scan the path sent in the name (tmp/aclevents/) for the name 336814_130513_pr*
!  the .tifs always have a 4 digit number and .tif appended (0000.tif) so look 
!  for them in the directory.
!  then using imaging code - generate the key and file name preferred by imaging,
!  and move the .tif files to the current directory used by imaging.
!  
Rem BEDIT Version: 2.3 OBJECT CODE     Created: MAY 24, 2013  11:32:15
Rem /w2/papermaster/r2005//usr/acct/jcs/work/custom/xrev9/acl.image.in.src (univ2) [jcs] {56157}
Rem  Copyright (c) 2013 Universal Business Systems, Inc.
Rem    **** ALL CHANGES MUST BE MADE IN SOURCE!!! ****
Rem
Declare Intrinsic Sub DateToJulian,FileInfo,FindF,InpBuf,String
! Option Default Dialect IRIS1

If Err 0 Gosub ERR_TRAP
Rem
Enter INXMLFLE$,ORDID,CUSTID,ORDDATE,intco
Dim e$[500],buttonlist$[5,50],nextlist$[5,100],rstr$[500] ! dx error handling variables
Rem {begin src/inc/dim.getchan.i}
Dim 1%,CHNL
Dim 3%,CHNLSCR,CHNLFREE
Rem {end dim.getchan.i}
Rem {begin src/inc/dim.imtype.i}
Dim 1%,IMROT,IMINIT,3%,IMSEQ[2],2%,IMBCODE[5]
Rem {end dim.imtype.i}
Rem {begin src/inc/dim.imsettype.i}
Dim 1%,SEQDISPL
Dim DTDESCRIPTION$[20],DTINDEX1$[20],DTINDEX2$[20],DTIMODE$[6]
Dim DTLOOKUP$[16],DTREFFILE$[4],PREFIX$[2]
Rem {end dim.imsettype.i}
Rem {begin src/inc/dim.ImIdx.i}
Dim IMI$[66]
Dim 3%,IMI1,1%,IMI2[3],2%,IMI3[2]
Rem {end dim.ImIdx.i}
Rem {begin src/inc/dim.ImSto.i}
Dim IMSTO$[44]
Dim 3%,IMSTO[4]
Rem {end dim.ImSto.i}
Rem {begin src/inc/dim.roh.i}
Dim 1%,H3[1],H4[2],LOCKPORT,OWHT[1],PICKBY[1]
Dim 2%,H0[12],H5[16],ST3[24],SLSM[9],H6[8],HFAX[1]
Dim 2%,HSTI[1],H2[0],OWHT1[1]
Dim 3%,TOT_SELL,SCOM[4],SMER[4],SCST[4],TOTGL,OREF[5]
Dim V0$[12],H0$[20],H1$[6],HMAT$[2],P0$[20]
Rem {end dim.roh.i}
Dim J$[40],J4$[75],HOME$[128]
Dim SAVEIMAGE$[90],DOSIMAGE$[90],LISTTMP$[40],IMGSITE$[50]
Dim SCANDIR$[30],SAVEDIR$[20],CMD$[200],COMMAND$[400],SPACES$[100]
Dim KEY_IMIDX$[64],KEY_IMLIDX$[128],DIRTO$[128]
Dim PART1$[16],PART2$[16],WORK$[100],EXT$[4],COMMENT$[30]
Dim OUTPUT$[90],FORMREQ$[40],FORMTYPE$[2]
Dim MODNAME$[18],MODPATH$[60],P60$[50]
Dim KEY1_VEND$[60],KEY1_PROD$[60],KEY1_CUST$[60],KEY1_ROH$[60],KEY1_ROHH$[64]
Dim KEY1_INVWRK$[60],KEY_LOOKUP$[60],LOOKUPLAST$[60]
Dim KEY1_ROHHIDX$[60],KEY1_IMMISC$[60],IMMISC$[52]
Dim 1%,COID
Dim 2%,TYPEARRAY[99],FARRAY[25]
Dim 2%,JDATE,FCHAN[2],STAT,CVCODE
Dim 3%,LAST_IMIDX,X2
Dim INDEXMODE$[1],PAGE$[4],P176$[256],CUSTOM_CUSTOMER$[30]
Dim JDATE$[10]
FALSE = 0;TRUE = Not(FALSE)
SPACES$ = " ",SPACES$
If INXMLFLE$ = "" Goto OUTEND ! no file name sent
For X = 2 To 99
  If Err 0 Rem
  Close #X
  If Err 0 Gosub ERR_TRAP
Next X
COID = Intco ! Int((Spc(5) - Int(Spc(5) / 16384) * 16384) / 64)
CH_CNTRL = 1
If Err 0 Let X2 = Spc(8)
X2 = 0
X3 = Chf(CH_CNTRL)
If Err 0 Gosub ERR_TRAP
If X2 ! cntrl not open
  Open #1,"cntrl/cntrl" + Str$(COID)
End If 
CH_CNTRL = 1
Mat Read #CH_CNTRL,176,0;P176$;
CH_IMLIDX = 2
CH_IMIDX = 3
CH_IMSTO = 4
CH_DEBUG = 5
CH_ROH = 6
CH_ROHH = 7
CH_CUST = 8
CH_VEND = 9
CH_INVWRK = 10
CH_PROD = 11
CH_PDESC = 12
CH_IMTYPE = 13
CH_IMMISC = 14
CH_ROHHIDX = 15
HOME$ = "HOME" \ System 28,HOME$
WORK$ = RTrim$(HOME$)
 Gosub RTRIM_
HOME$ = WORK$ ! trimmed
Open #CH_IMIDX,"6/IMIndex" + Str$(COID)
Open #CH_IMSTO,"6/IMStore" + Str$(COID)
Open #CH_IMTYPE,"6/IMType" + Str$(COID)
Ropen #CH_IMMISC,"6/IMMiscDoc" + Str$(COID)
Read #CH_CNTRL,88,1792;WORK$[1,16]; \ Ropen #CH_PROD,WORK$[1,16]
Read #CH_CNTRL,88,1808;WORK$[1,16]; \ Ropen #CH_CUST,WORK$[1,16]
Read #CH_CNTRL,88,2400;WORK$[1,16]; \ Ropen #CH_VEND,WORK$[1,16]
Read #CH_CNTRL,88,3056;WORK$[1,16]; \ Open #CH_INVWRK,WORK$[1,16]
Read #CH_CNTRL,88,1104;WORK$[1,16]; \ Ropen #CH_PDESC,WORK$[1,16]
Read #CH_CNTRL,88,1840;WORK$[1,16]; \ Ropen #CH_ROH,WORK$[1,16]
Read #CH_CNTRL,88,1136;WORK$[1,16]; \ Ropen #CH_ROHH,WORK$[1,16]
Open #CH_ROHHIDX,"4/sordflehhkey" + Str$(COID)
EXT$ = ".tif";IAGE = 180
If P176$[2,2] = "Y" Let EXT$ = ".imd"
If P176$[3,3] = "Y" Let EXT$ = ".tif"
REC_IMSTO = 0
Gosub READIMSTO
Unlock #CH_IMSTO
WORK$ = RTrim$(IMSTO$[21,40])
Gosub RTRIM_
SCANDIR$ = INXMLFLE$ ! WORK$+"/"+STR(IMGSITENUM)
DIRTO$ = INXMLFLE$ ! IF SCANDIR$[LEN(SCANDIR$)]<>"/" LET SCANDIR$[LEN(SCANDIR$)+1]="/"
CHNL = 97 \ Gosub GETCHAN
If Err 0 Gosub ERR_TRAP ! getchan changes to err_escape:?
CH_ACLIDX = CHNL
WORK$ = "$$/bin/ls -1 " + DIRTO$ + "[0-9]*.tif"
Open #CH_ACLIDX,WORK$ ! directory list in a pipe
FORMLOOP: Rem ------ Start a new form type ---------------------------
KEY_IMIDX$[1,2] = "DR";FORMTYPE$ = "dr" ! may pass in eventually
For TYPE = 0 To MAXTYPE
  Gosub SETTYPE
  If PREFIX$ = FORMTYPE$ Goto GTCONT
Next TYPE
GTCONT: Rem TYPE=0;PREFIX$="dr" ! manually set?
DTIMODE$ = "M"
INDEXMODE$ = "M" ! manual - not from barcode/system
Read #CH_IMTYPE,TYPE,44;IMINIT; ! storage for dr type
IMLINE = 0
IMAGELOOP: Rem LOOP thru images for this specific order
Read #CH_ACLIDX;KEY_IMLIDX$;
If KEY_IMLIDX$ = "" Goto OUTEND
If KEY_IMLIDX$[1,Len(DIRTO$)] <> DIRTO$ Let E = 2
STRPCCHAR: Rem "remove cr/lf etc
If Len(KEY_IMLIDX$) > 1 ! not >= as a couple lines of \15 only!
 if KEY_IMLIDX$[Len(KEY_IMLIDX$)] < " "
  KEY_IMLIDX$[Len(KEY_IMLIDX$)] = "" ! Strip control chars
  Goto STRPCCHAR
 endif
End If 
If Not(E)
  DOSIMAGE$ = KEY_IMLIDX$ ! SCANDIR$+KEY_IMLIDX$
  IMLINE = IMLINE + 1
  If IMLINE > 1 Let J$ = "!ADDPAGE" ! just add page - index already known
INDEXLOOP: Rem
MORELIST: Rem
  If J$[1,8] = "!ADDPAGE" ! add pages
    REC_IMIDX = LAST_IMIDX
    Gosub READIMIDX
    Goto IMAGESAVE
  End If 
  If INDEXMODE$ = "M"
    J$ = ORDID Using "######"
    WORK$ = RTrim$(J$) \ PART1$ = WORK$
    If LOGGING Print #CH_DEBUG;"Get second part of key"
    J$ = "" ! GOSUB GETINPUT:
    WORK$ = RTrim$(J$) \ PART2$ = WORK$
    If LOGGING Print #CH_DEBUG;"Get comment"
    J$ = "Airclic document" ! GOSUB GETINPUT:
    COMMENT$ = J$,SPACES$
    If LOGGING Print #CH_DEBUG;"Get rotation"
    J$ = "" ! GOSUB GETINPUT:
    IMI2[2] = J$
    If LOGGING Print #CH_DEBUG;"Validating entry"
    If PREFIX$ = "dr" Or PREFIX$ = "pd" Or PREFIX$ = "os"
      Gosub FND_ORDER
      If Not(FOUNDFLAG)
        H0[4] = CUSTID ! LET J4$="Specified order does not exist"
        H0[9] = ORDDATE ! GOSUB BADINDEX:
        If H0[9] < 0 Let H0[9] = 0 ! DATE nogood
        If H0[4] <> 0 Let FOUNDFLAG = 1 ! GOTO FORMLOOP:
      End If 
    End If 
  End If ! manual index
  If J$[1,8] = "!ADDPAGE" ! add pages
    REC_IMIDX = LAST_IMIDX
    Gosub READIMIDX
    Goto IMAGESAVE
  End If 
  Rem {begin src/inc/immakekey.i}
  KEY_IMIDX$ = PREFIX$
  Call String(1,KEY_IMIDX$)
  If KEY_IMIDX$[1,2] = "DR"
    X2 = PART1$;PART1$ = Str$(X2)
    KEY_IMIDX$[3] = Val(PART1$) Using "######"
    KEY_IMIDX$[9] = SPACES$
    KEY_IMIDX$[31] = ""
  End If 
  If KEY_IMIDX$[1,2] = "VI"
    X2 = PART1$;PART1$ = Str$(X2)
    KEY_IMIDX$[3] = Val(PART1$) Using "######"
    KEY_IMIDX$[9] = PART2$,SPACES$
    KEY_IMIDX$[29] = SPACES$
    KEY_IMIDX$[31] = ""
  End If 
  If KEY_IMIDX$[1,2] = "VD"
    X2 = PART1$;PART1$ = Str$(X2)
    KEY_IMIDX$[3] = Val(PART1$) Using "######"
    KEY_IMIDX$[9] = PART2$,SPACES$
    KEY_IMIDX$[29] = SPACES$
    KEY_IMIDX$[31] = ""
  End If 
  If KEY_IMIDX$[1,2] = "VS"
    X2 = PART1$;PART1$ = Str$(X2)
    KEY_IMIDX$[3] = Val(PART1$) Using "######"
    X2 = PART2$ \ PART2$ = X2 Using "&&&&&&"
    KEY_IMIDX$[9] = PART2$
    KEY_IMIDX$[15] = SPACES$
    KEY_IMIDX$[31] = ""
  End If 
  If KEY_IMIDX$[1,2] = "PL"
    KEY_IMIDX$[3] = PART1$ + SPACES$[1,12]
    KEY_IMIDX$[15] = PART2$ + SPACES$
    KEY_IMIDX$[31] = ""
  End If 
  If KEY_IMIDX$[1,2] = "CD"
    X2 = PART1$;PART1$ = Str$(X2)
    KEY_IMIDX$[3] = Val(PART1$) Using "######"
    KEY_IMIDX$[9] = PART2$,SPACES$
    KEY_IMIDX$[29] = SPACES$
    KEY_IMIDX$[31] = ""
  End If 
  If KEY_IMIDX$[1,2] = "MD"
    KEY_IMIDX$[3] = PART1$ + SPACES$
    KEY_IMIDX$[31] = ""
  End If 
  If KEY_IMIDX$[1,2] = "PD"
    X2 = PART1$;PART1$ = Str$(X2)
    KEY_IMIDX$[3] = Val(PART1$) Using "######"
    KEY_IMIDX$[9] = SPACES$
    KEY_IMIDX$[31] = ""
  End If 
  If KEY_IMIDX$[1,2] = "MI"
    KEY_IMIDX$[3,6] = PART1$ + SPACES$
    KEY_IMIDX$[7] = PART2$ + SPACES$
    KEY_IMIDX$[31] = ""
  End If 
  If KEY_IMIDX$[1,2] = "CT"
    X2 = PART1$;PART1$ = Str$(X2)
    KEY_IMIDX$[3] = Val(PART1$) Using "&&&&&&"
    KEY_IMIDX$[9] = Val(PART2$) Using "########"
    KEY_IMIDX$[17] = SPACES$
    KEY_IMIDX$[31] = ""
  End If 
  If KEY_IMIDX$[1,2] = "OS"
    X2 = PART1$;PART1$ = Str$(X2)
    KEY_IMIDX$[3] = Val(PART1$) Using "######"
    KEY_IMIDX$[9] = SPACES$
    KEY_IMIDX$[31] = ""
  End If 
  Call String(1,KEY_IMIDX$)
  Rem {end immakekey.i}
  If KEY_IMIDX$[1,2] = "DR" And Not(FOUNDFLAG)
    X2 = PART1$;PART1$ = Str$(X2)
    KEY_IMIDX$[3] = Val(PART1$) Using "######"
    KEY_IMIDX$[9] = SPACES$
    KEY_IMIDX$[31] = ""
  End If 
  If KEY_IMIDX$[1,2] = "DR" And FOUNDFLAG
    JDATE$ = " ",JDATE$;JDATE$ = H0[9] Using "&&&&&&"
    Call DateToJulian(1,JDATE$,JDATE$,E)
    If E Let JDATE$ = Str$(Tim(6)) ! GOSUB ERR_SEARCH:
    JDATE = JDATE$
    X2 = PART1$;PART1$ = Str$(X2)
    KEY_IMIDX$[3] = Val(PART1$) Using "######" ! order
    KEY_IMIDX$[9] = H0[4] Using "######"
    KEY_IMIDX$[15] = JDATE Using "######"
    KEY_IMIDX$[21] = SPACES$
    KEY_IMIDX$[31] = ""
  End If 
  Call String(1,KEY_IMIDX$)
  Search #CH_IMIDX,2,1;KEY_IMIDX$,REC_IMIDX,E \ If E > 1 Gosub ERR_SEARCH
  If E Let EXIST = FALSE Else Let EXIST = TRUE
  If EXIST And INDEXMODE$ = "M"
    If LOGGING Print #CH_DEBUG;"Duplicate key"
    If LOGGING Print #CH_DEBUG;"Ask user what to do with duplicate"
    Gosub READIMIDX
    If Tim(6) - IMI3[0] < IAGE ! current - last stored
      J$ = "!ADD" ! current - add it
    Else 
      J$ = "!OWRITE" ! old - overwrite
    End If 
    If J$ = "!REDO"
      If LOGGING Print #CH_DEBUG;"Try again..."
      Goto FORMLOOP
    End If 
    If J$ = "!OWRITE"
      If LOGGING Print #CH_DEBUG;"Delete & overwrite"
      Search #CH_IMIDX,5,1;KEY_IMIDX$,REC_TEMP,E
      If E Gosub ERR_SEARCH
      E = 3 \ Search #CH_IMIDX,1,0;KEY_IMIDX$,REC_TEMP,E
      If E Gosub ERR_SEARCH
      EXIST = FALSE
    Else 
      If J$ <> "!ADD" Gosub ERR_SEARCH
    End If 
    If LOGGING Print #CH_DEBUG;"Add to existing document"
  End If 
  If Not(EXIST)
    E = 2 \ Search #CH_IMIDX,1,0;KEY_IMIDX$,REC_IMIDX,E \ If E Gosub ERR_SEARCH
    Read #CH_IMTYPE,TYPE,0;IMI1
    IMI1 = IMI1 + 1
    Write #CH_IMTYPE,TYPE,0;IMI1;
    IMI$[1,30] = KEY_IMIDX$,SPACES$
    IMI$[31,60] = COMMENT$
    IMI2[0] = IMINIT
    IMI2[1] = 0
    Gosub WRITEIMIDX
    Search #CH_IMIDX,4,1;KEY_IMIDX$,REC_IMIDX,E \ If E Gosub ERR_SEARCH
  Else 
    Gosub READIMIDX
  End If 
IMAGESAVE: Rem
  If IMI2[1] >= 9999 Gosub ERR_SEARCH
  IMI2[1] = IMI2[1] + 1
  IMI3[0] = Tim(6)
  IMI3[1] = Tim(6)
  Gosub WRITEIMIDX
  LAST_IMIDX = REC_IMIDX
  REC_IMSTO = IMI2[0]
  Gosub READIMSTO
  WORK$ = IMSTO$[21,40]
  Gosub RTRIM_
  SAVEDIR$ = WORK$
  If P176$[6,6] = "Y"
    PAGE$ = IMI2[1] Using "&&&&"
  Else 
    PAGE$ = IMI2[1] Using "&&"
  End If 
  SAVEIMAGE$ = SAVEDIR$ + "/" + PREFIX$ + "/" + Str$(IMI1) + PAGE$ + EXT$
  Call FindF(SAVEIMAGE$,E)
  If E
    Kill SAVEIMAGE$
  End If 
  If KEY_IMLIDX$[1,1] <> "/" ! not given full path
    COMMAND$ = HOME$ + "/" + KEY_IMLIDX$
  Else 
    COMMAND$ = KEY_IMLIDX$ ! given full
  End If 
  Modify COMMAND$ + " " + SAVEIMAGE$ ! MOVE FROM ORIGINAL TO FINAL LOCATION
  If IMI2[1] = 1 Let IMSTO[2] = IMSTO[2] + 1
  IMSTO[3] = IMSTO[3] + 1
  Call FileInfo(WORK$,FARRAY[],SAVEIMAGE$,1)
  IMSTO[4] = IMSTO[4] + FARRAY[6]
  Gosub WRITEIMSTO
End If ! found an entry
Goto FORMLOOP ! until no more
Goto OUTEND !
BADINDEX: Rem cannot find reference?
Return 
FND_ORDER: Rem==================================================
If PREFIX$ <> "dr" And PREFIX$ <> "pd" And PREFIX$ <> "os" Return 
X2 = PART1$ \ If Not(X2) Let PART1$ = "0"
H0[0] = 0;FOUNDFLAG = FALSE
KEY1_ROH$ = X2 Using "  ######"
For X1 = 1 To 99
  If X1 = 20 Let X1 = 30
  KEY1_ROH$[1,2] = X1 Using "##"
  Search #CH_ROH,2,1;KEY1_ROH$,REC_ROH,E \ If E > 1 Gosub ERR_SEARCH
  If Not(E)
    Rem {begin src/inc/read.roh.i}
    Mat Read #CH_ROH,REC_ROH,0;H0
    Mat Read #CH_ROH,REC_ROH,52;H3
    Mat Read #CH_ROH,REC_ROH,56;TOT_SELL
    Mat Read #CH_ROH,REC_ROH,64;LOCKPORT
    Mat Read #CH_ROH,REC_ROH,66;V0$
    Mat Read #CH_ROH,REC_ROH,78;H4
    Mat Read #CH_ROH,REC_ROH,84;H0$
    Mat Read #CH_ROH,REC_ROH,104;H5
    Mat Read #CH_ROH,REC_ROH,172;ST3
    Mat Read #CH_ROH,REC_ROH,272;H1$
    Mat Read #CH_ROH,REC_ROH,278;SLSM
    Mat Read #CH_ROH,REC_ROH,318;SCOM
    Mat Read #CH_ROH,REC_ROH,348;SMER
    Mat Read #CH_ROH,REC_ROH,378;SCST
    Mat Read #CH_ROH,REC_ROH,408;H6
    Mat Read #CH_ROH,REC_ROH,444;HMAT$
    Mat Read #CH_ROH,REC_ROH,446;P0$
    Mat Read #CH_ROH,REC_ROH,466;HFAX
    Mat Read #CH_ROH,REC_ROH,474;HSTI
    Mat Read #CH_ROH,REC_ROH,482;H2
    Mat Read #CH_ROH,REC_ROH,486;OWHT
    Mat Read #CH_ROH,REC_ROH,490;OWHT1
    Mat Read #CH_ROH,REC_ROH,498;TOTGL
    Mat Read #CH_ROH,REC_ROH,504;PICKBY
    Mat Read #CH_ROH,REC_ROH,512;OREF
    Rem {end read.roh.i}
    Unlock #CH_ROH
    FOUNDFLAG = TRUE;X1 = 100
  End If 
Next X1
If Not(FOUNDFLAG)
  KEY1_ROHHIDX$ = Val(PART1$) Using "######"
NEXT_ROHHIDX: Search #CH_ROHHIDX,3,3;KEY1_ROHHIDX$,REC_ROHH,E
  If Not(E) And Val(KEY1_ROHHIDX$[1,6]) = Val(PART1$[1,6])
    Mat Read #CH_ROHH,REC_ROHH,0;H0
    Mat Read #CH_ROHH,REC_ROHH,512;OREF;
    JDATE$ = " ",JDATE$;JDATE$ = H0[9] Using "&&&&&&"
    Call DateToJulian(1,JDATE$,JDATE$,E)
    If E Let JDATE$ = Str$(Tim(6)) ! GOSUB ERR_SEARCH:
    JDATE = JDATE$;TODAY = Tim(6)
    If Abs(TODAY - JDATE) <= IAGE
      FOUNDFLAG = TRUE
      Goto FND_ORDER_EXIT
    Else 
      JDATE$ = " ",JDATE$;JDATE$ = H0[8] Using "&&&&&&"
      Call DateToJulian(1,JDATE$,JDATE$,E)
      If E = 0
        JDATE = JDATE$;TODAY = Tim(6)
        If Abs(TODAY - JDATE) <= IAGE
          FOUNDFLAG = TRUE
          Goto FND_ORDER_EXIT
        End If 
      End If 
    End If 
    Goto NEXT_ROHHIDX
  End If 
End If 
FND_ORDER_EXIT: Return 
RTRIM_: ! 
Work$=RTrim$(Work$)
Return 
READIMSTO: Rem
Rem {begin src/inc/read.imsto.i}
Mat Read #CH_IMSTO,REC_IMSTO,0;IMSTO$
Mat Read #CH_IMSTO,REC_IMSTO,44;IMSTO
Rem {end src/inc/read.imsto.i}
Return 
WRITEIMSTO: Rem
Rem {begin src/inc/write.imsto.i}
Mat Write #CH_IMSTO,REC_IMSTO,0;IMSTO$
Mat Write #CH_IMSTO,REC_IMSTO,44;IMSTO;
Rem {end write.imsto.i}
Mat Write #CH_IMSTO,REC_IMSTO,0;IMSTO$
Mat Write #CH_IMSTO,REC_IMSTO,44;IMSTO;
Return 
READIMIDX: Rem
Rem {begin src/inc/read.ImIdx.i}
Mat Read #CH_IMIDX,REC_IMIDX,0;IMI$
Mat Read #CH_IMIDX,REC_IMIDX,66;IMI1
Mat Read #CH_IMIDX,REC_IMIDX,72;IMI2
Mat Read #CH_IMIDX,REC_IMIDX,80;IMI3
Rem {end read.ImIdx.i}
Return 
WRITEIMIDX: Rem
Rem {begin src/inc/write.ImIdx.i}
Mat Write #CH_IMIDX,REC_IMIDX,0;IMI$
Mat Write #CH_IMIDX,REC_IMIDX,66;IMI1
Mat Write #CH_IMIDX,REC_IMIDX,72;IMI2
Mat Write #CH_IMIDX,REC_IMIDX,80;IMI3;
Rem {end write.ImIdx.i}
Return 
READIMMISC: Rem
Mat Read #CH_IMMISC,RECIMMISC,0;IMMISC$;
Return 
Rem {begin src/inc/imsettype.i}
SETTYPE: Rem Hard-coded paramaters for recognized form types
DTDESCRIPTION$ = ""
If TYPE = 0
  DTDESCRIPTION$ = "Delivery receipt"
  PREFIX$ = "dr"
  DTINDEX1$ = "Order number"
  DTINDEX2$ = ""
  DTIMODE$ = "B" ! default to barcode indexing - Bxx - xx=rotation
  DTLOOKUP$ = "" ! No lookup field
  DTREFFILE$ = ""
End If 
If TYPE = 1
  DTDESCRIPTION$ = "Product literature"
  PREFIX$ = "pl"
  DTINDEX1$ = "Item code"
  DTINDEX2$ = "Reference code"
  DTIMODE$ = "M" ! default to manual indexing
  DTLOOKUP$ = "Product description"
  DTREFFILE$ = "PROD"
End If 
If TYPE = 2
  DTDESCRIPTION$ = "Customer document"
  PREFIX$ = "cd"
  DTINDEX1$ = "Customer#"
  DTINDEX2$ = "Reference code"
  DTIMODE$ = "M" ! default to manual indexing
  DTLOOKUP$ = "Customer name"
  DTREFFILE$ = "CUST"
End If 
If TYPE = 3
  DTDESCRIPTION$ = "Vendor invoice"
  PREFIX$ = "vi"
  DTINDEX1$ = "Vendor code"
  DTINDEX2$ = "Vendor invoice no."
  DTIMODE$ = "M" ! default to manual indexing
  DTLOOKUP$ = "Vendor name"
  DTREFFILE$ = "VEND"
End If 
If TYPE = 4
  DTDESCRIPTION$ = "Vendor statement"
  PREFIX$ = "vs"
  DTINDEX1$ = "Vendor code"
  DTINDEX2$ = "Date (yymmdd)"
  DTIMODE$ = "M" ! default to manual indexing
  DTLOOKUP$ = "Vendor name"
  DTREFFILE$ = "VEND"
End If 
If TYPE = 5
  DTDESCRIPTION$ = "Vendor document"
  PREFIX$ = "vd"
  DTINDEX1$ = "Vendor code"
  DTINDEX2$ = "Reference code"
  DTIMODE$ = "M" ! default to manual indexing
  DTLOOKUP$ = "Vendor name"
  DTREFFILE$ = "VEND"
End If 
If TYPE = 6
  DTDESCRIPTION$ = "MSDS Sheet"
  PREFIX$ = "md"
  DTINDEX1$ = "MSDS Number"
  DTINDEX2$ = ""
  DTIMODE$ = "M" ! default to manual indexing
  DTLOOKUP$ = ""
  DTREFFILE$ = ""
End If 
If TYPE = 7
  DTDESCRIPTION$ = "Picking document"
  PREFIX$ = "pd"
  DTINDEX1$ = "Order number"
  DTINDEX2$ = ""
  DTIMODE$ = "B" ! default to barcode indexing - Bxx - xx=rotation
  DTLOOKUP$ = "" ! No lookup field
  DTREFFILE$ = ""
End If 
If TYPE = 8
  DTDESCRIPTION$ = "Misc. document"
  PREFIX$ = "mi"
  DTINDEX1$ = "+subtype"
  DTINDEX2$ = "Key"
  DTIMODE$ = "M" ! default to manual indexing
  DTLOOKUP$ = ""
  DTREFFILE$ = ""
End If 
If TYPE = 10
  DTDESCRIPTION$ = "Concrete ticket"
  PREFIX$ = "ct"
  DTINDEX1$ = "Date (yymmdd)"
  DTINDEX2$ = "Concrete ticket#"
  DTIMODE$ = "B" ! default to barcode indexing - Bxx - xx=rotation
  DTLOOKUP$ = "" ! No lookup field
  DTREFFILE$ = ""
End If 
If TYPE = 11
  DTDESCRIPTION$ = "Order source"
  PREFIX$ = "os"
  DTINDEX1$ = "Order number"
  DTINDEX2$ = ""
  DTIMODE$ = "M" ! default to manual indexing
  DTLOOKUP$ = "" ! No lookup field
  DTREFFILE$ = ""
End If 
Return 
Rem {end imsettype.i}
OUTDONE: Rem finished
If Err 0 Rem
For X = 2 To 20
  Close #X1
Next X
If Err 0 Gosub ERR_TRAP
OUTEND: Rem outta here
End 
Rem {begin src/inc/rtn.getchan.i}
GETCHAN: Rem search for open channel (counts down from supplied chnl #)
For SCR = CHNL To 1 Step -1
  CHNL = SCR
  Gosub CHNLFREE
  If CHNLFREE
    SCR = 1
  Else 
    CHNL = 0
  End If 
Next SCR
Return 
CHNLFREE: Rem check to see if a channel is being used
If Err 0 Let CHNLFREE = Spc(8)
CHNLFREE = 0
CHNLSCR = Chf(CHNL)
If Err 0 Gosub ERR_Trap
If CHNLFREE And CHNLFREE <> 49 Gosub ERR_TRAP
END_CHNLFREE: Rem
Return 
Rem {end rtn.getchan.i}
ERR_SEARCH: Rem                                            
ENUM = E;ELINE = Spc(16);CTERR = 0                         
If E = 5 Let CTERR = Err(8)                                
e$ = "RETURN STATUS",(E + (CTERR * .001))                  
e$ = e$,"/ STATEMENT",ELINE," IN PROGRAM " + Msc$(4)       
Error 11000                                 
End
Rem {begin rtn.error.s}
ERR_TRAP: Rem *Error routine (escape trap)   V3.1 8/94 G.DOSCHER/REK
include "src/callmainerrnet_call.inc"
End