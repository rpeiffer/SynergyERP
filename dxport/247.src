! >>> Program 247
!
! description Credit ACCEPT PART 1
!
! loadsave -w -n 100,10 -o prog/dxport/247.dl4 src/247.src
!
! 1.0 mm/dd/yyyy change??
!
include "src/copyright.inc" ! dx
Rem MX247  CREDIT MEMO ACCEPT
Rem
Rem last update:  B.Swet 3/24/92 swap to credit print
! LAST UPDATE: 5/92 - ADD SERIAL NUMBER UPDATE
! Last Update:  3/92 (rek) - back out freight addons
! Last Update: Nate 9/29/94 EDI (810's -- currently 812's not supported)
! Last Update: Nate 10/18/95 - track cost in edi rebate tag file
! Last Update: RJS 02/15/96 update messages lines into history
! Last Update: Nate 4/12/96fix line 1316 where it used #11 instead of #5
! Last Update: Nate 9/17/96 fix EDI bugs @ lines 5482 and 5470.
!              Judy 02/02/97 s/e on serial number - cct 98636
!              tc 5/21/97 cct100365 pass tax type to history
!              Nate 2/16/98. CCT#109213: Modify EDI to look at ediloc. 
! jliu 6/1/99 cct122724 default all fields as same as the whse is coming
!     from when order type is 7 or 8
! zyc 05/28/99 cct122949 do not allow user to run 247 and 246 twice
! jliu 6/9/99 cct115070 initialize the variable WHBLD[2]
! jliu 10/19/99 cct127881 copy the material code from roh into invh
! zyc 11/30/00 cct142171 remmed out signal after calling mx227lp   
! zyc 07/02/01 cct148226 if c/m type is 3, not to put serial number on hold
! cct151597 kag 11/9/01 assign vendor code from prod file to WHBLD[2] before
! call to MXWHCREATE.                                 
! cct162137 jliu 11/05/02 write the lp_date and lp_time to INVL
! cct210803 jliu 3/14/07 build the key into 6/ictrack file
! cct226292 jliu 6/10/08 copy the order tag file to the inv line tag file
! cct237209 jliu 12/08/09  initialize the PHUP
! ------------------  notes for upgrade to xrev9 for H T Berry  ----------------
! 08/01/07 rjs cct210769 - change so if flag set, the gp$ is reduced by the cust
!                           commission service charge before looking in the grid
!                           for commission %
! 01/28/08 jcs cct221505 - CCH Tax Calculation
! ------------------------------------------------------------------------------
! ADD INVCOST FILE 04/2012
! add status channel for myreports run
!
Rem BEDIT Version: 2.2 OBJECT CODE     Created: NOV  3, 2008  13:07:44
Rem /w2/papermaster/r2005//usr/acct/custom/xrev9/mx247.src (univ2) 
Rem  Copyright (c) 2008 Universal Business Systems, Inc.
Rem    **** ALL CHANGES MUST BE MADE IN SOURCE!!! ****
Rem
!  Restart instructions:  NO SUPERUSER - RESTART REQUIRES CHANGES/BYPASSES AT THIS TIME!!
!	1. RUN THIS WITH SETUP THROUGH DXTEST.DL4 - no more details
!	2. UnRem call dxopen()
!	3. Change SuperUser = 1
!
Include "src/inc/fileinvtrans.inc"
Include "src/inc/sql_prod.inc"
External Lib "invttrans.dl4"
Declare External Sub Maketrans
External Lib "libprodwh.lib"
Declare External Sub mxwhcreate
Declare Intrinsic Sub DateToJulian,FindF,InpBuf,String,Time,VerifyDate
Declare Intrinsic Sub getglobals
Declare Intrinsic sub programdump,env
Declare Intrinsic function findchannel
! external libs for subs/functions
External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus
Declare External Function AddToMYReports
External Lib "ubsfunc.dl4"
Declare External Function getuidrec,getuidinfo$,OpenMySQLMirror
External Lib "librebates.lib"
Declare External Sub rebates
! Option Default Dialect IRIS1
Try
Com 1%,CREDIT,IntCo,icflag,statchan
Com 3%,HEADREC,E$[500],Rstr$[2000]
Dim 1%,ohcurrid,olcurrid,3%,ohcurrfact,olcurrfact
REM dim sordroll/sordrollh                                          
DIM KEYORL1$[50],KEYORL2$[50],SOR$[32],1%,SOR1[1],3%,SOR2[3]        
DIM KEYORLH1$[50],3%,SORH2[3]                                       
REM dim prodroll                                                    
DIM KEYRL1$[50],KEYRL2$[50],RL0$[62],2%,RL1[5],3%,RL2[2],RLUSER$[20]
DIM NKEYRL1$[50],NKEYRL2$[50]                                       
DIM PRFLG$[10],BREAK$[50]        
Dim A$[60],A1$[60],F$[20],M$[20],P$[60],V1$[30],P9$[50],P60$[50],K3$[50]
Dim K1$[50],A2$[60],S0$[36],K9$[180],L1$[56],L2$[20],P1$[156],P0$[20]
Dim W1$[32],W2$[24],K26$[50],K27$[50],K30$[60],RP$[132],K51$[48],K63$[16]
Dim M1$[40],K34$[50],K35$[50],MT$[2],IAIP$[16],HMAT$[2],K2$[50],P61$[256]
Dim MESS$[80],USR$[20],SCRATCH$[50],CRIP$[40]
Dim 1%,EUN[2],C,D,L3[3],P0[1023],H4[2],I,L1[3],M,H3[1],S,CH_WT,CH_WTH
Dim 1%,C$[138],C1$[20],C0[3],C1[2],FLAG,OWHT[1],2%,DT3[1],JIDATE,OWHT1[1]
Dim 1%,UN[2],EDII,S6[1],WHPROD$[12],CH_INVTR,PL[1],LWHSE,HWHSE,LPRINTED
Dim 1%,USERPORTINFO[1],DCLVL,OWHS,Eflg[5],linenum,TCB,SplitFlag,armonth
Dim 1%,CommissionSource
Dim 2%,A2[5],H,H0[12],L4[3],N0,N1,V4,D5,D8,E9,TR[8],SLSM[9],LTAX2,SHIPDATE
Dim 2%,H6[8],W2[9],WH7[3],W7[14],RP1[3],C2[12],C4[5],C5[3],WHBLD[2],S5,H2[0]
Dim SNK$[50],SNK1$[50],SNKE$[50],SNKE1$[50],SN$[224],SN1$[54]
Dim 2%,SN0[1],SN2[9],L6[5],KL2[1],W2[9],H5[16],B[24],V7,JRNL,LCO[1],H5_2[16]
Dim 2%,ACCEPTPORT,SS1,SS2,CSPLT[4],CommBaseRate[4]
Dim 2%,LP_DATE,LP_TIME,rb1[5],E,NumberPieces
Dim 1%,OSN,PFU1,SN1[2],RP0[2],MCTXBL[9],2%,MCODE[9],CTNWT[1]
Dim 2%,ARDATE,ARYEAR,PR_C4[10],PLC[3],ACPT_DATE,CHG_DATE,VENDOR,MH1
Dim 1%,K28$[40],K29$[40],KL$[58],KL1[5],K33$[60],ACPT_DATE$[10],CHG_DATE$[10]
Dim 1%,S2[1],W1[2],W0[3],WH8[47],K11$[50],K14$[50],OL$[60],K67$[50],EDILTP$[8]
Dim 3%,tl2[1],MH2,MH2$[1],lp1
Dim 3%,INVBAL[1],T3,PLV[1],WHLV[2],H1[1],PRPARC[3],WHLBS[1],LBSHIP,T12[1]
Dim 3%,UNF[6],A3[5],L5[3],L7[12],L8[4],A9,L2[5],P3[4],S3[4],T2[25],CST,X1[9]
Dim 3%,TP[999],L0[1],C3[25],SRN[5],W3[24],W5[25],WH9[25],TOT_SELL,R1[5]
Dim 3%,RP2[2],SN3[6],KL3[1],A[33],R[99],MCHARGE[9,1],TOT[4],CTNWGT,X2[9]
Dim 4%,D3,J
Dim 3%,OLM[6],S4[17],T9[5],Q1,SCOM[14],J1,J2,V1,V3,LINEREC,LTAX1,TR1[8]
Dim 3%,TR2[1],M1[17],PF_LOAD2,TOTGL,ROL0,OREF[5],INVNO,REFNO,TOT_ORD,phup 
DIM 3%,commsrvchg
! non-stock line vars
dim nsl$[30], nsl1$[30], nsl2$[18], ha1$[50]
Dim NSUDA$[120],NSB4k$[2],k31$[60],K12$[60]
dim 2%, nsl7[2], ha3[2]
dim 3%, nsl8[4],NSINVNO
dim 3%,nsfrt1[2]
Dim STOCK$[22],OL2$[16],LTL2$[6],CAIP$[16],Z1$[50],S1$[118],FLG$[4]
Dim U5$[50],J4$[50],X$[10],K32$[50],ARDATE$[8],TRUM$[4],TRVI$[20],TRCT$[2]
Dim KCWT$[40],KCWTH$[40],K69$[50],LPONUM$[30],LJOBNUM$[30],K43$[14],K44$[14] 
DIM PSNUM$[30],MSG1$[30],MSG2$[30],TIDNo$[20],custom_customer$[30]
Dim K_INV_COST$[50],PWK6$[50],MSGS$[750]
dim 3%,INVCST$[22],INVCST[13],REBATE_ARGS[10,4],WHMISC[6],LRNCOST,PFN[1],STATUS
DIM 3%,PW3[24],PWHMISC[6],PLRNCOST,REC_PW
Dim buttonlist$[5,50],nextlist$[5,100] ! dx error handling variables
Dim tmp$[800],tmp1$[200],nextblockid$[8],Message$[600],WebStr$[600],blockid$[100]
Dim action$[30],options$[30],userid$[8],b$[200],3%,fdel$[10],bsdel$[10],esdel$[10],rdel$[10]
Dim ReportDir$[128],BaseName1$[128],Statusfile$[128]
B$=" ",B$
PHUP=0
!Try 
!call dxopen() ! may not need this! NEEDS FOR DXTEST/RESTART RUN!!
!Else
	Rem
!End try
Call getsession(e$,CTLC,options$,action$,userid$,intCO,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$)
! must be passed otherwise wipes out info if chained from 226agl
dim ITR. as invtrans
COID=IntCo ! E = Spc(5) \ COID = Int((E - Int(E / 16384) * 16384) / 64)
F$ = "cntrl/CNTRL"+Str$(COID) ! for restart
! get session opens a READYONLY Cntrl#
Close #1
Open #1,F$
Try Close #9 Else Rem ! dxblock sends sort file on #9 
S = 11
! E9 = Spc(5) \ COID = Int((E9 - Int(E9 / 16384) * 16384) / 64)
Def FNR(H) = Sgn(H) * (Int(Abs(H) * 100 + .5) * .01)
Def FND(H) = FNR(H - (H * D3))
Mat Read #1,19,50;P9$;
Mat Read #1,60,50;P60$;
MAT  READ #1,61,0;P61$;
mat read #1,115,60;custom_customer$;
custom_customer$=UCase$(Trim$(custom_customer$))
tptc=0 \ if custom_customer$="HTBERRY" let tptc=1
if p61$[140,140]="Y" let tptc=2 ! third party tax calc custom_customer$="PIEDMONT"
Mat Read #1,60,6;FLG$;
EDII = (FLG$[2,2] = "T" Or FLG$[2,2] = "H")
!
LET DOCFLAG=0                       
IF P61$[96,96]="Y" LET DOCFLAG=1    
IF NOT(DOCFLAG)                      
   LET ICFLAG=0                        
   GOTO SKIP_DOC                      
ENDIF                               
!"cct#210803
LET F$="6/ictrack"+Str$(COID)
Call FindF(F$,found)          
if not(found)                  
   let icflag=0               
else     
   icflag = (FLG$[4,4]="Y") ! tracks invoices for auto dcs printing
   if icflag
      OPEN #69,"6/ictrack"+Str$(COID)       
   endif
endif
!
SKIP_DOC: !
Read #1,0,108;ARDATE; \ ARDATE$ = ARDATE Using "&&&&&&" \ ARYEAR = ARDATE$[1,2]
M$ = "#",M$
Read #1,3,188;SHIPDATE;
Read #1,0,120;M; \ Read #1,0,112;D8;
Let armonth=M ! "for INVCOST
Read #1,0,182;D5;
Mat Read #1,52,32;SS1;
Mat Read #1,52,20;SS2;
If M = SS1
  E$="CASH RECEIPTS HAS BEEN ACCEPTED(320/306) FOR THE MONTH"
  !Print 'CL';"PRESS <CR> TO RETURN TO THE MENU";
  !Input ""Z1$
  Goto L_9120
End If 
If M = SS2 And P9$[17,17] = "Y"
  E$="ACCOUNTS RECEIVABLE HAS BEEN ACCEPTED(405) FOR THE MONTH"
  !Print 'CL';"PRESS <CR> TO RETURN TO THE MENU";
  !Input ""Z1$
  Goto L_9120
End If 
If P9$[17,17] <> "M" Goto L_200
L_200: For X1 = 2 To 39
  Read J
  If J = -1 Goto L_250
  J2 = Abs(Fra(J) * 1000) \ If J2 < 88 Or J2 > Chf(1) - 1 Let J2 = 88
  J1 = Abs(Int(J))
  Read #1,J2,J1;F$;
  If J < 0 Ropen #X1,F$ Else Open #X1,F$
L_250: Next X1
Data "1136","1152","1168","1184","-1","1504","1840","1856","1872","1888","2128","1376"
Data "1792","2320","2528","2512","-1","-1","-1","-1","-1","1248","2944","2960","416"
Data "1744","1312","1328","2992","-1","-1","1120","1968","-1","-1","-1","-1","2176"
Open #31,"4/SPRDDESCH"+STR$(COID) ! HIST FOR 2128(#12)
Open #32,"4/SORDFLEHHKEY" + Str$(COID)
Open #35,"4/SORDFLEMH" + Str$(COID)
F$ = "3/CTWTQTY" + Str$(COID)
Call FindF(F$,FOUND)
If FOUND
  CH_WT = 36
  F$ = "4/CTWTQTYH" + Str$(COID)
  Call FindF(F$,FOUND)
  If FOUND
    CH_WTH = 37
  Else 
    CH_WTH = 0
  End If 
Else 
  CH_WT = 0;CH_WTH = 0
End If 
If P9$[8,8] <> "Y" Let CH_WTH = 0
If CH_WT Open #CH_WT,"3/CTWTQTY" + Str$(COID)
If CH_WTH Open #CH_WTH,"4/CTWTQTYH" + Str$(COID)
if p61$[104,104]="Y"
	OPEN #40,"2/PRODROLL"+STR$(COID) 
	OPEN #41,"3/SORDROLL"+STR$(COID) 
	OPEN #42,"4/SORDROLLH"+STR$(COID)
endif
LET ROLTAGFLAG=0                           
LET F$="3/SORDROLTAG"+STR$(COID)            
CALL FINDF(F$,ROLTAGFLAG)
IF ROLTAGFLAG                              
   OPEN #43,"3/SORDROLTAG"+STR$(COID)        
   OPEN #44,"4/SORDINVLTAG"+STR$(COID)       
ENDIF 
f$="4/INVCOST"+STR$(COID)
call FindF(f$,invcostflag)
if invcostflag ! no bomb if file missing
	Read #1,88,304;f$;
	Open #45,f$
	read #1,88,320;f$;
	Open #46,f$
	OPEN #47,"4/INVCOST"+STR$(COID)    
	LET CH_INVCOST=47
Endif
If P9$[17,17] <> "Y" Goto L_340
Read #1,88,80;F$;
Open #18,F$
Read #1,88,464;F$; \ Open #22,F$
L_340: If EDII
  Open #51,"cntrl/EDICNTRL" + Str$(COID)
  Open #63,"4/EDITRANS" + Str$(COID)
  Ropen #67,"2/EDILOC" + Str$(COID)
End If 
Call DXGet("RN247",tmp$) \ tmp$=UCase$(Trim$(tmp$))
if tmp$="" let tmp$="N" ! unchecked it?
If tmp$="N"  ! DO NOT WANT TO RUN!
	E$="USER SELECTED NO ACCEPT RUN - OK"
	goto L_9100
Endif
!Call "getuidrec",R[99]
R[99]=getuidrec(e$,IntCo,Userid$)
Mat Read #1,120;P0;
if p0[247] <> 0
	E=3  ! CHECK with time check
	scratch$=" "
	call "proglock.dl4","247",e,scratch$  
	if not(e)  !! no proglock entry
		unlock #1
		call "flagreset","247.DL4",e
		if e
			Mat Read #1,120,0;P0 ! reset done, relock record
		endif
	endif
endif
If P0[246] <> 0 Goto L_540
If P0[247] <> 0 Goto L_550
!P0[247] = R[99]
!Mat Write #1,120;P0;
S = 11 \ A9 = 0 \ M$ = "#",M$
Goto L_565
L_540: Rem cm journal ip
R = P0[246]
If R let M1$=GetUIDInfo$(e$,IntCo,R) ! Call "getuidinfo",R,M1$
USR$ = RTrim$(M1$[21])
E$=" CREDIT REGISTER BEING RUN BY USER "+USR$+"RUN ACCEPT WHEN DONE."
Goto L_560
L_550: Rem cm accept ip
R = P0[247]
If R let M1$=GetUIDInfo$(e$,IntCo,R) ! Call "getuidinfo",R,M1$
USR$ = RTrim$(M1$[21])
E$=" CREDIT ACCEPT BEING RUN BY USER "+USR$+"RUN ACCEPT WHEN DONE."
L_560: Goto L_9100 ! Signal 3,20 \ Goto L_9110
L_565: Goto L_8200 ! check ip files
L_570: Gosub L_8000 ! check/set glcmtemp
Goto L_9100 ! reset po[]/clr glcm
Gosub L_8500 ! check roh
Goto L_9100 ! reset p0[]/clr glcm
L_620: ! Print 'CR';"DO YOU WANT TO ACCEPT CREDITS? (Y/N) ";
if tptc ! 3rd party tax calc
!! test the internet to see if we connect to cch/avalara
 if tptc=1 Call "cch.testconn.dl4",X1
 if tptc=2 call "ava.testconn.dl4",x1
 If Not(x1) ! "no connect/wrong response
	E$=" No internet connection was made - Please try later"
	Goto L_9100: ! treat like user said "N"
 Endif
 if x1=9 let TPTC=0 ! not set up - do not use tptc
Endif
! as accept make take >2 mins - use a status file
if not(restart)
	ReportDir$ = "REPORTDIR" \ System 28,ReportDir$
	BaseName1$ = "credit_accept_"+dateusing$(Tim#(0),"YYMMDDHHNNSS")
	StatusFile$ = ReportDir$ + "/"+BaseName1$
	Call FindF(StatusFile$,tmp)
	If tmp Kill StatusFile$
	StatChan = 88 ! FindChannel() ! channel to build text file need fixed channel
	Try Close #88 Else Rem
	Try
		Build #StatChan,StatusFile$ As "TEXT"
	Else
		returnstatus=1
		let e$="Error in Building Status File "
		goto L_9100
	end TRY
	Try Close #StatChan Else Rem
	Try
		Open #StatChan,StatusFile$
	else
		returnstatus=1
		let e$="Error in Opening Status File "
		goto L_9100
	end TRY
	Print #StatChan;"Accept Process Started..."
	! PAUSE 20
	e = AddToMYReports(BaseName1$) 
	if e<0
		e$="Error adding to my reports!" 
		returnstatus=1
		goto L_9100
	endif
	returnstatus=0 ! or is it 1?
	message$="Please check under My Reports "+basename1$+" for status and completion"
	Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)     
	Call AddToStr(e$,rstr$,WebStr$)                            
	Call SetOutPut(e$,rstr$)
Endif ! of not a restart
Mat Read #1,120;P0;
P0[247] = R[99]
Mat Write #1,120;P0;
Eflg[1]=1 ! set po[]
F$ = " ",F$
L_890: Gosub L_6000 ! clr tracdel
CAIP$ = "cntrl/caip"+Str$(COID) 
!Print @0,23;'CL';"Updating ......";
!System "cp /dev/null " + CAIP$
!Open #99,CAIP$
R = R[99]
Chan=Findchannel()
tmp$="<00> "+CAip$+"!"
  ! tmp$=CAip$+"!"
Build #CHan,+tmp$
! Open #Chan,CAIP$
! OK - all opens are above this one and the last open (DBChan) used a
! call to find an open channel number and open, so I can assume from
! here forward, no more conflicts with channel #s
sqlChan = OpenMySQLMirror(e$)

Print #Chan;"credit memo accept started ";Msc$(3)
Print #Chan;"user ";R[99];" SPC 5= ";Spc(5)
Close #Chan
tmp$="chmod go+rw files/"+CAIP$
System tmp$
let eflg[2]=1 ! set caip
K1$ = " ",K1$ \ K1$ = S Using "##"
TRUM$ = " ",TRUM$;TRVI$ = " ",TRVI$;TRCT$ = " ",TRCT$
L_1000: Rem *
! Gosub L_8700 ! file size (not used)
! Gosub L_8600 ! more file sizes (not used)
scratch$="doing a lock"
call "proglock.dl4","247",1,scratch$
V1$ = " ",V1$
V1$[1,2] = S Using "##"
L_1005: Search #8,3,1;K1$,V1,E
If E Goto OUTEND
If K1$[1,2] <> V1$[1,2] Goto OUTEND
Mat Read #8,V1;H0;
Mat Read #8,V1,104;H5;
Mat Read #8,V1,512;OREF;
! if h5[7]=36 or h5[7]=37 goto L_1005 ! EVAP NOT READY
REFNO = H0[7];INVNO = OREF[1]
If P9$[8,8] <> "Y" Goto L_1065
H1[1] = 30; TCB=0
L_1050: V1$ = " ",V1$ \ V1$[1,2] = H1[1] Using "##"
V1$[3] = REFNO Using "##########"
Gosub L_7600
Search #2,2,1;V1$,H1,E
If Not(E) Gosub L_8300 \ Goto L_1000
If H1[1] < 35 Let H1[1] = H1[1] + 1 \ Goto L_1050
L_1065: H1 = V1 \ H1[1] = 0
If P9$[8,8] <> "Y" Goto L_1080
C = 2 \ Gosub L_5020
L_1080: H1[1] = V3 \ N0 = 0 \ N1 = 0
Mat Read #8,H1;H0;
Mat Read #8,H1,78;H4;
Mat Read #8,H1,408;H6; \ Mat Read #8,H1,444;HMAT$;
Mat Read #8,H1,104;H5;
Mat Read #8,H1,52;H3;
Mat Read #8,H1,512;OREF;
REFNO = H0[7];INVNO = OREF[1]
Mat Read #10,H0[3],8;T2;
T2[1] = T2[1] - H6[6];T2[5] = T2[5] + H6[6]
T2[13] = 0 \ T9[2] = T2[0]
Mat Read #9,H0[2],8;S1$;
N0 = H0[7] \ N1 = H0[7] \ HWHSE = H4[2]
if tptc Read #39,H4[0],412;TCB; ! "tax calc'd by
D3 = 0 \ If T2[1] Let D3 = T2[3] / T2[1]
Gosub L_7600
A$ = " ",A$ \ T9[1] = 0
A$[1,6] = N0 Using M$[1,6]
A1$ = A$
L_1120: Search #11,3,1;A$,V1,E
If E Goto L_1500
If A$[1,6] <> A1$[1,6] Goto L_1500
A1$ = A$;K11$ = A$
L0 = V1;R[11] = V1
if statchan Print #statchan;"Doing...";K11$
Mat Read #11,L0,8;L3;
Mat Read #11,L0,16;L4; \ Mat Read #11,L0,168;L7;
Mat Read #11,L0,32;L5;
Mat Read #11,L0,508;LTAX1; \ Mat Read #11,L0,538;LTAX2;
Mat Read #11,L0,56;L6; \ Mat Read #11,L0,256;S2;
Mat Read #11,L0,80;OL$; \ Mat Read #11,L0,260;S4;
Mat Read #11,L0,140;L2$; \ Mat Read #11,L0,404;OLM;
Mat Read #11,L0,446;EUN; \ Mat Read #11,L0,452;UNF; \ Mat Read #11,L0,494;LCO; \ Mat Read #11,L0,502;CST;
Mat Read #11,L0,564;ROL0;
Mat Read #11,L0,616;lp1;
Mat Read #11,L0,622;CommissionSource;
If H3[1] = 3 Let L3[1] = 0
L5[2] = L5[2] - S4[15];OLM[3] = OLM[3] - S4[15];L5[3] = L5[3] - OLM[1]
LWHSE = L4[3] \ If LWHSE <= 0 Or LWHSE > 99 Let LWHSE = HWHSE
If P9$[8,8] <> "Y" Goto L_1200
A$ = " ",A$;A$[1,10] = REFNO Using "##########"
A$[11] = A1$[7]
Search #5,2,1;A$,V7,E
If Not(E) Goto L_1410
C = 5 \ Gosub L_5020
L0[1] = V3
L_1200: If (H5[7] = 21 Or H5[7] = 22) And A1$[7,9] = "   " Gosub L_4200 \ Goto L_1260
If L3 Goto L_1250
KIT = 0;MKIT = 0 \ Gosub L_3200
INVBAL[0] = 0;INVBAL[1] = 0 \ Gosub L_10000
A9 = 0 \ Gosub L_2000
IF NOT(L3[0]) GOSUB UPDATE_INVCOST: ! "ACME
If MKIT = 1 If H5[7] = 8 Let MKIT = 9
If H5[7] = 8 Let INVBAL[0] = INVBAL[1] \ Gosub L_11000
If Not(L7[4]) Goto L_1250
L_1250: Rem.
Gosub L_6300
Gosub L_4500
if p61$[104,104]="Y" GOSUB UPDATEROLLINV: ! roll inventory
CREDIT = 1;LINEREC = L0
! Call "MX227LP",H0[],H5[],CREDIT,LINEREC,H4[],OREF[]
Call "227lp.dl4",H0[],H5[],CREDIT,LINEREC,H4[],OREF[],e$,IntCo,rstr$,statchan
L_1260: A9 = 0
If P9$[8,8] <> "Y" Goto L_1400
A$ = A1$
Dim 1%,C0[3],C7$[6],S3$[33],L6$[60]
Dim 2%,C2[1],C5[3],C4[5],C6[1],LTX2
Dim 3%,C3[3],C7[9],S4[17],LTX1
Mat Read #11,L0,0;C2; \ Mat Read #11,L0,8;C0; \ Mat Read #11,L0,246;PL; \ Mat Read #11,L0,368;MT$;
Mat Read #11,L0,16;C5; \ Mat Read #11,L0,32;C3;
Mat Read #11,L0,56;C4; \ Mat Read #11,L0,80;L6$; \ Mat Read #11,L0,404;OLM;
Mat Read #11,L0,140;L2$; \ Mat Read #11,L0,508;LTX1; \ Mat Read #11,L0,538;LTX2
Mat Read #11,L0,160;C6; \ Mat Read #11,L0,168;C7; \ Mat Read #11,L0,250;UN;
Mat Read #11,L0,256;S2; \ Mat Read #11,L0,260;S4; \ Mat Read #11,L0,370;S3$;
Mat Read #11,L0,564;ROL0;
Mat Read #11,L0,616;lP1;
Mat Read #11,L0,622;CommissionSource;
mat read #11,l0,624;olcurrid;
mat read #11,l0,626;olcurrfact; 
Mat Write #5,L0[1],0;C2; \ Mat Write #5,L0[1],8;C0;
Mat Write #5,L0[1],16;C5; \ Mat Write #5,L0[1],32;C3;
Mat Write #5,L0[1],246;PL; \ Mat Write #5,L0[1],368;MT$;
Mat Write #5,L0[1],56;C4; \ Mat Write #5,L0[1],80;L6$; \ Mat Write #5,L0[1],140;L2$;
Mat Write #5,L0[1],160;C6; \ Mat Write #5,L0[1],168;C7; \ Mat Write #5,L0[1],250;UN;
Mat Write #5,L0[1],256;S2; \ Mat Write #5,L0[1],260;S4; \ Mat Write #5,L0[1],370;S3$;
Write #5,L0[1],4;N1; \ Mat Write #5,L0[1],404;OLM;
Mat Write #5,L0[1],446;EUN \ Mat Write #5,L0[1],452;UNF \ Mat Write #5,L0[1],494;LCO; \ Mat Write #5,L0[1],502;CST;
If L3 Write #5,L0[1],16;L4;
Mat Write #5,L0[1],508;LTX1; \ Mat Write #5,L0[1],538;LTX2;
Mat Write #5,L0[1],518;REFNO;
Mat Write #5,L0[1],548;LPRINTED;
Mat Write #5,L0[1],550;OWHS;
Mat Write #5,L0[1],552;LP_DATE;
Mat Write #5,L0[1],556;LP_TIME;
Mat Write #5,L0[1],564;ROL0;
Mat Write #5,L0[1],616;lp1;
Mat Write #5,L0[1],622;CommissionSource;
if p61$[136,136]="Y"
	if olcurrid<=0 or olcurrid>9999
		let olcurrid=0
		let olcurrfact=0 ! invalid currency id
	endif
	if olcurrfact<0 let olcurrfact=0 ! invalid currency factor
else
	let olcurrid=0
	let olcurrfact=0
endif
mat write #5,l0[1],624;olcurrid;
mat write #5,l0[1],626;olcurrfact; 
V1 = L0[1] \ C = 5 \ D = 1
A$[1,10] = REFNO Using "##########"
A$[11] = A1$[7]
E = 0 \ Gosub L_5050
error 11000
If L3 Goto L_1400
A$ = " ",A$ \ A$ = L4 Using "######"
A$[7] = REFNO Using "##########";A$[17] = A1$[7,10]
E = 0 \ V1 = L0[1] \ D = 2
Gosub L_5050
If E error 11000
L_1400: Rem COMPLETE LINE
If (H5[7] = 21 Or H5[7] = 22) And A1$[7,9] = "   " Goto L_1430
L_1410: Gosub L_3000 ! deposit
If L3[0] GOSUB NSTKHist ! new nonstk history
Gosub L_3300
Gosub CTNWGT
L_1430: A$ = A1$;KIT = 0;MKIT = 0
If EDII Gosub L_5400
Goto L_1120
L_1500: Rem ============================= update messages
If P9$[8,8] <> "Y" Goto L_1600
K34$ = N0 Using "######"
A1$ = K34$
L_1520: Search #34,3,1;K34$,R[34],E \ If E > 2 error 11000
If E Goto L_1600
If K34$[1,6] <> A1$[1,6] Goto L_1600
Mat Read #34,R[34];M1$
Read #34,R[34],40;MH1
Mat Read #34,R[34],44;MH2;
Mat Read #34,R[34],50;MH2$;
MH2$ = " ",MH2$;MH2 = REFNO
E = 2
Search #35,1,0;K35$,R[35],E \ If E error 11000
Mat Write #35,R[35];M1$
Write #35,R[35],40;MH1
Mat Write #35,R[35],44;MH2;
Mat Write #35,R[35],50;MH2$;
K35$ = " ",K35$;K35$[1,10] = REFNO Using "##########"
K35$[11] = K34$[7]
Search #35,4,1;K35$,R[35],E \ if e error 11000
Goto L_1520
L_1600: REM ================= update order line tag          
IF NOT(ROLTAGFLAG) GOTO L_1700:                               
LET K43$=N0 USING "######"                                   
LET A1$=K43$                                                 
L_1620: SEARCH #43,3,1;K43$,R43,E \ IF E>2 error 11000 
IF E GOTO L_1700:                                            
IF K43$[1,6]<>A1$[1,6] GOTO L_1700:                          
MAT  READ #43,R43,0;TL2;                                     
READ #43,R43,12;LINENUM;                                     
READ #43,R43,14;LPONUM$;                                     
READ #43,R43,44;LJOBNUM$;                                    
READ #43,R43,74;PSNUM$;                                      
READ #43,R43,104;MSG1$;                                      
READ #43,R43,134;MSG2$; 
MAT READ #43,R43,164;MSGS$;
LET K44$=" ",K44$                                            
LET K44$[1,10]=REFNO USING "##########"                      
LET K44$[11,13]=K43$[7,9] 
K44$[15]="" ! cut to length
SEARCH #44,2,1;K44$,R44,E \ IF NOT(E) GOTO L_1620:            
LET E=2                                                      
SEARCH #44,1,0;K44$,R44,E \ IF E error 11000
let tl2[1]=refno ! SET TO REFNO!
MAT  WRITE #44,R44,0;TL2;                                    
WRITE #44,R44,12;LINENUM;                                    
WRITE #44,R44,14;LPONUM$;           
WRITE #44,R44,44;LJOBNUM$;          
WRITE #44,R44,74;PSNUM$;            
WRITE #44,R44,104;MSG1$;            
WRITE #44,R44,134;MSG2$;
MAT WRITE #44,R44,164;MSGS$;
X$=" ",x$
write #44,r44,998;x$[1,1]; ! BLANK FOR KEY!
SEARCH #44,4,1;K44$,R44,E \ IF E error 11000
GOTO L_1620:
L_1700: ! ============== see if cch calc'd tax and add histmessg if did
If TCB<1 or tcb>2 goto L_1800: ! no - pm or other calc'd it
! TCB=1 cch did - so get & record their TIDNo$
! TCB-2 avatax - just post the accepted $$ - get TIDNO$
Let TIDNo$="CREDIT"  ! signal that we're doing a credit
x1[0]=0;x1[1]=0;x1[2]=8;x1[3]=9;x1[4]=10;x1[5]=11;x1[6]=39;x1[7]=0 ! chans
if tcb=1 Call "cch.commcrdt.out.dl4",H1,X1[],TIDNo$,intco,rstr$ ! it passes back the tid committed
if tcb=2 call "ava.posttaxout.dl4",H0[7],H1,TIDNo$,intco,rstr$ ! uses same as invoices
If TIDNo$[1,1]="" OR TIDNo$[1,3]="   " ! some kind of issue
	Let TIDNo$="UNKNOWN/NOT FOUND" ! "if tcb=1 ALWAYS have TID even none
Endif
! got it - record in messages 801+
	Let X2=801
	HMTNxt: ! "try until open # found
	Let k35$=" ",k35$;K35$[1,10]=RefNo USING "##########"
	Let k35$[11]=X2 Using "###"
	Search #35,2,1;K35$,R[35],e \ if e>1 error 11000
	If Not(e) ! found - try next
		Let X2=X2+1 \ if x2>=999 goto l_1800: ! give up
		goto HMTNxt:
	Endif
	Let U5$=" ",U5$;m1$=" ",m1$;MH1=X2 ! can only hold line # not invno
	if tcb=1 Let m1$="CCH TID: "+TIDNO$+U5$ ! "space fill to max
	if tcb=2 let m1$="AVALARA ID: "+TIDNO$+U5$ ! "space fill to max
	LET E=2;R[35]=0
	SEARCH #35,1,0;K35$,R[35],E \ IF E error 11000
	MAT  WRITE #35,R[35];M1$
	WRITE #35,R[35],40;MH1;
	MH2$ = " ",MH2$;MH2 = REFNO
	Mat Write #35,R[35],44;MH2;
	Mat Write #35,R[35],50;MH2$;
	k35$=k35$+U5$ ! "SPACE FILL TO END
	SEARCH #35,4,1;K35$,R[35],E \ if e error 11000
! finished with cch
L_1800: Rem NOLNS
T2[13] = T9[1]
Write #10,H0[3],86;T2[13];
if custom_customer$="SOUTHJERSEY"
	call "obtrakr.dl4",H0[4],0,refno,0,e$,IntCo,rstr$,statchan ! don't know custrec or custchannel
Endif
If P9$[8,8] <> "Y" Gosub L_1900 \ Goto L_1000
Gosub L_4000
Gosub L_1900 \ Goto L_1000
L_1900: Rem "================================= edi interface
If Not(EDII) Goto L_1995
K67$ = SRN[2] Using "######" + "." + SRN[1] Using "&&&&&&"
Search #67,2,1;K67$,R[67],E \ If E > 2 error 11000
If Not(E)
  Mat Read #67,R[67],8;EDILTP$; \ K51$ = EDILTP$
Else 
  K51$ = H0[1] Using "CN######"
End If 
Search #51,2,1;K51$,R[51],E \ If E > 1 error 11000
If E Goto L_1995
Mat Read #51,R[51],8;TP;
If Not(Int(Abs(TP[810]))) Goto L_1995
K63$ = " ",K63$;K63$[1,12] = H0[7] Using "31##########"
Search #63,2,1;K63$,R[63],E \ If E > 1 error 11000
For X1 = 0 To 8 \ TR[X1] = 0;TR1[X1] = 0 \ Next X1
TR2[0] = 0;TR2[1] = REFNO
If Not(E) Goto L_1960
E = 2 \ Search #63,1,0;K63$,R[63],E \ If E error 11000
Search #63,4,1;K63$,R[63],E \ If E error 11000
L_1960: Rem "write records
WHPROD$ = " ",WHPROD$
Write #63,R[63],0;WHPROD$[1,12];
Mat Write #63,R[63],12;TR
Mat Write #63,R[63],48;TR1
Mat Write #63,R[63],102;TRUM$
Mat Write #63,R[63],106;TRVI$
Mat Write #63,R[63],126;TRCT$
Mat Write #63,R[63],158;TR2;
Mat Write #63,R[63],170;K63$;
L_1995: Return 
L_2000: Rem DO LOT FILES
If L3 Return 
A$ = " ",A$ \ A$ = L2$[1,12]
Search #14,2,1;A$,L4,E
If E Return 
L_2030: Mat Read #14,L4;P1$;
Mat Read #14,L4,156;B;
WHSE = LWHSE \ Gosub L_3500
If H5[7] = 7 Let WHSE = H5[11] \ Gosub L_3500
A$ = " ",A$ \ A$ = N0 Using "######"
A$[7] = L3[2] Using "###" \ A$[10] = WHSE Using "##"
A2$ = A$
Search #15,2,3;A$,V1,E
If Not(E) Goto L_2100
L_2090: Search #15,3,3;A$,V1,E
If E Return 
L_2100: If A$[1,11] <> A2$[1,11] Return 
If Not(KIT) If A$[30,32] = "KIT" Goto L_2090
If KIT If A$[30,32] <> "KIT" Goto L_2090
LN = A$[33,35] \ If KIT If LN <> KL1[1] Goto L_2090
If A$[40,40] = "4" Goto L_2090
A2$ = A$ \ R1 = V1
Mat Read #15,R1;S0$;
Q1 = 0
Mat Read #15,R1,60;S3;
Mat Read #15,R1,96;OL2$;
If P9$[1,1] = "N" If S3[0] <> (L7[4] + L7[3]) Let S3[0] = (L7[4] + L7[3])
If P9$[1,1] = "N" If S3[1] <> L7[4] Let S3[1] = L7[4]
Q1 = S3[1]
STOCK$ = " ",STOCK$ \ STOCK$[1,12] = S0$[13,24] \ STOCK$[13,22] = OL2$[1,10]
A$ = " ",A$;A$[1,2] = WHSE Using "##";A$[3,8] = OL2$[11,16];A$[9,32] = S0$[1,24]
If KIT Let A$[33,42] = "          "
Search #16,2,3;A$,V1,E
If E Goto L_2220
Mat Read #16,V1,82;P3
If Not(L3[1]) Goto L_2190
P3[1] = P3[1] - Q1;INVBAL[0] = INVBAL[0] + Q1
If MKIT = 9 Let P3[0] = P3[0] - Q1;INVBAL[0] = INVBAL[0] - Q1
L_2190: Rem LET P3[3]=P3[3]+S3[0]
A9 = A9 + (P3[2] * Q1)
Mat Write #16,V1,82;P3
Write #16,V1,74;H0[8];
L_2220: L4[2] = 0
If Not(L4[2]) Goto L_2310
L4[2] = 0
Mat Write #16,V1,82;P3;
Write #15,R1,48;H0[8];
Mat Write #15,R1,60;S3;
Goto L_2400
L_2310: Rem DELETE SORDLOT
P$ = " ",P$ \ P$[1,22] = STOCK$[1,22] \ P$[23,39] = A2$[1,17]
P$[40,51] = S0$[1,12] \ V1 = R1 \ A$ = A2$
Search #15,5,3;A$,V1,E
If E error 11000
Search #15,5,2;P$,V1,E
If E error 11000
P$ = " ",P$ \ P$ = S0$[1,12] \ P$[13,51] = A2$[1,39]
P$[52,52] = " "
Search #15,5,1;P$,V1,E
If E error 11000
V1 = R1 \ E = 3
Search #15,1,0;P$,V1,E
If E error 11000
L_2400: Rem WRITE LOTTRANS FILE
If P9$[9,9] <> "Y" Goto L_2620
If Not(L3[1]) Goto L_2620
Gosub L_3500 \ Gosub L_6450
Unlock #27
clear itr. 
itr.sOpen$=B$;itr.srccode$=B$;itr.comment$=B$
Itr.ProdCode$ = S0$[1,12]+B$
ITR.LotNum$=S0$[13,24]+B$
itr.SrcCode$ = REFNO Using "########"
itr.SrcCode$[9,9] = "-" \ itr.SrcCode$[10,12] = L3[2] Using "###"
ITR.Comment$[1,5] = "CUST#" \ ITR.Comment$[6,12] = H0[4] Using " ######"
ITR.Comment$[13] = B$
itr.TrnsType = 3;itr.Whse = WHSE;itr.EntBy = H5;itr.Tiebrkr = 0
itr.Loc$ = OL2$[11,16]+B$
If H5[7] = 8 Let itr.TrnsType = 9
If MKIT = 9 Let itr.TrnsType = 21
If KIT Let itr.TrnsType = 12
itr.TrnsDate = H0[8] \ itr.Qty = Q1 \ itr.CostAvg = B[21]
If P9$[32,32] = "Y" If W3[15] Let itr.CostAvg = W3[15]
itr.CostLoad = L5[1];itr.NetPrice = OLM[3];CH_INVTR = 17
itr.RunInvt = INVBAL[0]
itr.Wgt = (S4[4]*Sgn(L7[4])) ! "lbs
Gosub L_2800
L_2620: Rem
If MKIT = 9 Let MKIT = 1 \ Goto L_2400
A$ = A2$ \ If Not(KIT) If MKIT = 1 Let MKIT = 9
Goto L_2090
L_2800: Rem LOTTRANS GET REC#,SETUP KEYS, INSERT THEM & WRITE IT OUT
! Call "MAKETRANS",L1$,L1[],L2[],LTL2$,CH_INVTR
Call MakeTrans(e$,IntCo,CH_INVTR,Status,ITR.) !  as invtrans)
! This program ONLY takes care of adding a record and finding a unique (non-
! duplicated) key.  The calling program must still set all variables needed
! and send over via the "call" with the proper File Structure.
! The NSInvtrans & Invtrans Files should be exactly the same
! Variables In
! e$		Error Message
! IntCo		Company #
! ITC		Invtrans Channel #
! Status	Status of call (0=NG, 1+=Record added)
! ITR.		File Structure
Return 
L_3000: Rem DEPOSIT
If L3[2] < 900 Return 
A$ = " ",A$ \ A$ = H0[1] Using "######"
A$[7] = (H0[7] * 10) + (L3[2] - 990) Using "######" \ A$[13] = "7"
Search #7,2,1;A$,V1,E
If E = 1 Goto L_3085
If E error 11000
Mat Read #7,V1,0;A2;
H = Int(Fra(A2[3]) * 100)
If H <> 7 Return 
A2[3] = A2[3] + .001
Mat Write #7,V1,0;A2;
Mat Read #7,V1,24;A3;
T9[0] = (A3[0] - A3[1] - A3[2])
If T2[0] < 0 Goto L_3065
If T9[2] < T9[0] Let T9[0] = T9[2] \ Gosub L_3900
L_3065: T9[1] = T9[1] + T9[0]
T9[2] = T9[2] - T9[0]
A3[2] = A3[2] + T9
Mat Write #7,V1,24;A3;
L_3085: Return 
L_3200: Rem "=============== check if valid kit
K28$ = " ",K28$;K28$ = K11$[1,9]
Search #28,2,1;K28$,R[28],E \ If E Goto L_3800
If K28$[1,9] <> K11$[1,9] Goto L_3800
If P9$[22,22] <> "Y" Goto L_3800
If L7[4] = 0 Goto L_3800
If L3[0] = 1 Goto L_3800
Mat Read #28,R[28],0;KL$;
If KL$[1,12] <> L2$[1,12] Goto L_3800
If L2$[14,16] <> "KIT" Goto L_3800
If S2[0] <> 0 Goto L_3800
MKIT = 9
Return 
L_3300: Rem "============ do kit lines
If MKIT = 9 Let MKIT = 1
K28$ = " ",K28$;K28$[1,9] = K11$[1,9]
L_3310: Search #28,3,1;K28$,R[28],E \ If E Return 
If K28$[1,9] <> K11$[1,9] Return 
INVBAL[0] = 0;INVBAL[1] = 0
If Not(MKIT) Goto L_3850
Mat Read #28,R[28],0;KL$;
If L2$[14,16] <> "KIT" Goto L_3850
If KL$[1,12] <> L2$[1,12] Goto L_3850
Mat Read #28,R[28],58;KL1;
If H3[1] = 3 Let KL1[3] = 1
Mat Read #28,R[28],70;KL2;
Mat Read #28,R[28],78;KL3;
If P9$[8,8] <> "Y" Goto L_3370
K29$ = " ",K29$;K29$ = K28$;K29$[1,6] = H0[7] Using "######"
Search #29,2,1;K29$,R[29],E \ If Not(E) Goto L_3850
L_3370: K14$ = " ",K14$;K14$ = KL$[13,24]
If KL1[5] = -2 Goto L_3700
Search #14,2,1;K14$,R[14],E \ If E Goto L_3700
Gosub L_6400
If P1$[152,155] = "MACH" Or P1$[152,155] = "TIME" Or P1$[152,155] = "LABR" Let KL1[3] = 1
If KL1[3] = 1 Goto L_3410
If H5[7] = 8 Goto L_3395
A[0] = A[0] + KL3[1]
L_3395: A[1] = A[1] - KL3[1] \ If A[1] < 0 Let A[1] = 0
A[13] = A[13] - KL3[1];A[14] = A[14] - KL3[1]
A[15] = A[15] - FNR(KL3[0] * KL3[1]);A[16] = A[16] - FNR(KL3[0] * KL3[1])
B[13] = H0[8]
L_3410: Mat Write #14,R[14],256;A
Mat Write #14,R[14],156;B;
if sqlChan >= 0 ! MySQL enabled and channel opened
	e = prod_UpdateSQLFromDL4(e$, intCo, K14$, sqlChan, 14)
	if e <> 1 ! returns the number of records add/updated/deleted
		error 11000
	end if
end if
WHSE = LWHSE;PASS = 1
Gosub L_3610
If H5[7] = 7 Or H5[7] = 8 Let WHSE = H5[11];PASS = 2 \ Gosub L_3610
KIT = 9;MKIT = 1;L3[0] = 0;L5[1] = KL3[0]
L7[0] = 0;L7[1] = 0;L7[2] = KL3[1];L7[3] = 0;L7[4] = KL3[1]
L5[2] = 0;OLM[3] = 0;L3[1] = 1
If KL1[3] = 1 Let L3[1] = 0
If H3[1] = 3 Let L3[1] = 0
WHSE = LWHSE \ If H5[7] = 7 Let WHSE = H5[11]
L4[0] = R[14];OL$[1,30] = P1$[9,38];OL$[31,60] = P1$[63,92]
Gosub L_2030
If H5[7] = 8 Let WHSE = H5[11];INVBAL[0] = INVBAL[1] \ Gosub L_11060
Gosub L_4500
if p61$[104,104]="Y" GOSUB UPDATEROLLINV: ! roll inventory
Goto L_3700
L_3500: Rem "========================= check for prodwhse record
K27$ = " ",K27$;K27$[1,12] = P1$[140,151];K27$[13,14] = WHSE Using "##"
Search #27,2,1;K27$,R[27],E \ If E > 1 error 11000
If Not(E) Goto L_3605
If H5[7] = 7 Or H5[7] = 8
  DEFWHNUM = LWHSE / 100
  WHSE = WHSE + DEFWHNUM
End If 
WHPROD$[1,12] = P1$[140,151];WHBLD[0] = 27;WHBLD[1] = WHSE;WHBLD[2] = B[24]
! Call "MXWHCREATE",WHPROD$,WHBLD[]
call mxwhcreate(e$,IntCo,WHPROD$,WHBLD[])
! e$=error messages
! intco=Company ID #
! WHPROD$[1,12]=ITEM CODE
! WHBLD[0]=WHSE CHANNEL, WHBLD[1]=WHSE #, WHBLD[2]=RECNO TO SEND BACK
! ALSO: seems whbld[1] can have a fractional # - the default whse to copy
! ENTER DIMS:  WHPROD$[12],3%,WHBLD[2]
R[27] = WHBLD[2];E = 0;WHBLD[2] = 0 \ Goto L_3605
W1$ = " ",W1$;W1$[1,12] = K27$[1,12];W1$[13,32] = P1$[93,112]
For I = 0 To 47
  If I < 3 Let W1[I] = 0
  If I < 10 Let W2[I] = 0
  If I < 25 Let W3[I] = 0
  If I < 26 Let W5[I] = 0
  If I < 4 Let W0[I] = 0;WH7[I] = 0
  If I < 48 Let WH8[I] = 0
  If I < 25 Let WH9[I] = 0
  If I < 8 Let W7[I] = 0
Next I
W2$ = " ",W2$;WHLBS[0] = 0;WHLBS[1] = 0
W1[0] = WHSE
E = 2 \ Search #27,1,0;K27$,R[27],E \ If E error 11000
Gosub L_6950
Search #27,4,1;K27$,R[27],E \ If E error 11000
L_3605: Return 
L_3610: Rem "======= kit update prodwhse file
If KL1[3] = 1 Return 
Gosub L_3500
Mat Read #27,R[27],32;W2
Mat Read #27,R[27],78;W3
Mat Read #27,R[27],228;W5
If PASS = 1 Let INVBAL[0] = W3[0]
If PASS = 2 And H5[7] = 7 Let INVBAL[0] = W3[0]
If PASS = 2 And H5[7] = 8 Let INVBAL[1] = W3[0]
If PASS = 1 If H5[7] = 7 Goto L_3670
If PASS = 1 Goto L_3650
If PASS = 2 If H5[7] = 7 Goto L_3650
W3[0] = W3[0] - KL3[1] \ Goto L_3655
L_3650: W3[0] = W3[0] + KL3[1]
L_3655: W3[2] = W3[2] - KL3[1] \ If W3[2] < 0 Let W3[2] = 0
W2[7] = H0[8]
If H5[7] = 8 Goto L_3670
W5[0] = W5[0] - KL3[1];W5[M] = W5[M] - KL3[1]
L_3670: Mat Write #27,R[27],32;W2
Mat Write #27,R[27],78;W3
Mat Write #27,R[27],228;W5;
Return 
L_3700: Rem "========= xfer to kit history
If P9$[8,8] <> "Y" Goto L_3850
K29$ = " ",K29$;K29$ = K28$;K29$[1,6] = H0[7] Using "######"
Search #29,2,1;K29$,R[29],E \ If Not(E) Goto L_3790
R[29] = 0;E = 2
Search #29,1,0;K29$,R[29],E \ If E error 11000
Search #29,4,1;K29$,R[29],E \ If E error 11000
KL2[0] = H0[7];KL2[1] = H0[4]
Mat Write #29,R[29],0;KL$;
Mat Write #29,R[29],58;KL1;
Mat Write #29,R[29],70;KL2;
Mat Write #29,R[29],78;KL3;
L_3790: Goto L_3850
L_3800: Rem INVALID KIT
L2$[14,16] = "   "
Mat Write #11,R[11],140;L2$;
MKIT = 0 \ Goto L_3850
L_3850: Rem DEL KIT
Goto L_3890
K29$ = K28$
Search #28,5,1;K29$,V1,E
If E = 1 Goto L_3890
If E error 11000
V1 = R[28];E = 3
Search #28,1,0;K29$,V1,E \ If E error 11000
L_3890: Goto L_3310
L_3900: Rem <TTL
L5[2] = L5[2] - T9
L4[2] = 1
Write #11,L0,24;L4[2];
Write #11,L0,44;L5[2];
Return 
L_4000: Rem GET SHIP,TOTAL,&HEADER
C = 3 \ Gosub L_5020
Dim 2%,C5[1]
Mat Read #9,H0[2],0;C5;
Mat Read #9,H0[2],8;C$;
Read #9,H0[2],146;S5 \ Mat Read #9,H0[2],150;S6
Mat Read #9,H0[2],154;SRN;
OREF[4] = V3
Mat Write #3,OREF[4],0;C5;
Mat Write #3,OREF[4],8;C$;
Write #3,OREF[4],146;S5 \ Mat Write #3,OREF[4],150;S6
Mat Write #3,OREF[4],154;SRN;
Write #3,OREF[4],190;REFNO;
C = 4 \ Gosub L_5020
Dim 2%,C5[1]
Dim 3%,C3[25]
Mat Read #10,H0[3],0;C5;
Mat Read #10,H0[3],8;C3;
Read #10,H0[3],164;JRNL;
Mat Read #10,H0[3],168;MCODE; \ Mat Read #10,H0[3],358;MCTXBL;
Mat Read #10,H0[3],208;MCHARGE; \ Mat Read #10,H0[3],328;TOT;
Mat Read #10,H0[3],378;DCLVL;
Mat Read #10,H0[3],380;TOT_ORD;
OREF[5] = V3
Gosub L_7900 \ Gosub L_7800
C3[25] = (X2 * 100) + M
Mat Write #4,OREF[5],0;C5;
Mat Write #4,OREF[5],8;C3;
Write #4,OREF[5],164;JRNL;
Mat Write #4,OREF[5],168;MCODE; \ Mat Write #4,OREF[5],358;MCTXBL;
Mat Write #4,OREF[5],208;MCHARGE; \ Mat Write #4,OREF[5],328;TOT;
Mat Write #4,OREF[5],378;DCLVL;
Mat Write #4,OREF[5],380;TOT_ORD;
Write #4,OREF[5],400;REFNO;
Dim 1%,C0[1],C1[2]
Dim 2%,CLSM[9],C2[12],THISCRAPBLOWS[16]
Dim 3%,COM_[4]
Mat Read #8,H1,0;C2; \ Mat Read #8,H1,52;C0;
Read #8,H1,56;TOT_SELL; \ Read #8,H1,66;C$[1,12]; \ Mat Read #8,H1,78;C1;
Mat Read #8,H1,84;C1$; \ Mat Read #8,H1,104;THISCRAPBLOWS;
Mat Read #8,H1,278;CLSM; \ Mat Read #8,H1,318;SCOM;
Mat Read #8,H1,446;P0$;
Read #8,H1,482;H2;
Mat Read #8,H1,486;OWHT;
Mat Read #8,H1,490;OWHT1;
Mat Read #8,H1,548;CSPLT;
!if custom_customer$="HTBERRY" ! no longer custom
	Mat Read #8,H1,568;commsrvchg;
!Endif
Mat Read #8,H1,598;SplitFlag;
Mat Read #8,H1,600;CommBaseRate;
Mat Read #8,H1,620;NumberPieces;
mat read #8,h1,624;ohcurrid;
mat read #8,h1,626;ohcurrfact !
If Not(OREF[3])
  OREF[3] = H0[7]
  If OREF[1] <> H0[7]
    K2$ = "30",OREF[1] Using "##########"
    Search #2,2,1;K2$,R2,E \ If E > 1 error 11000
    If Not(E)
      Mat Read #2,R2,104;H5_2;
      If H5_2[7] = 20 And H5_2[6] > 0
        K2$ = "30",H5_2[6] Using "######"
        Search #2,2,1;K2$,R2,E
        If E > 1 error 11000
      End If 
      Read #2,R2,524;OREF[3];
      If Not(OREF[3])
        Read #2,R2,28;H2[0];
        OREF[3] = H2[0]
      End If 
    End If 
  End If 
End If 
Mat Write #2,H1[1],0;C2; \ Mat Write #2,H1[1],52;C0;
Write #2,H1[1],56;TOT_SELL; \ Write #2,H1[1],66;C$[1,12]; \ Mat Write #2,H1[1],78;C1;
Mat Write #2,H1[1],84;C1$; \ Mat Write #2,H1[1],104;THISCRAPBLOWS;
Mat Write #2,H1[1],278;CLSM; \ Mat Write #2,H1[1],318;SCOM;
Mat Write #2,H1[1],408;H6; \ Mat Write #2,H1[1],446;P0$;
Mat Write #2,H1[1],444;HMAT$;
Mat Write #2,H1[1],498;TOTGL;
Write #2,H1[1],482;H2;
Mat Write #2,H1[1],486;OWHT;
Mat Write #2,H1[1],490;OWHT1;
Mat Write #2,H1[1],512;OREF;
Mat Write #2,H1[1],548;CSPLT;
!if custom_customer$="HTBERRY" ! no longer custom
	Mat Write #2,H1[1],568;commsrvchg;
!Endif
write #2,h1[1],586;phup;
Mat Write #2,H1[1],598;SplitFlag;
Mat Write #2,H1[1],600;CommBaseRate;
Mat Write #2,H1[1],620;NumberPieces;
if p61$[136,136]="Y"
	if ohcurrid<=0 or ohcurrid>9999
		let ohcurrfact=0 ! invalid currency id
		let ohcurrid=0
	endif
	if ohcurrfact<0 let ohcurrfact=0 ! invalid currency factor
else
	let ohcurrid=0
	let ohcurrfact=0
endif
mat write #2,h1[1],624;ohcurrid;
mat write #2,h1[1],626;ohcurrfact;
H0 = 31
Mat Write #2,H1[1];H0;
A$ = " ",A$ \ V1 = H1[1]
A$ = H0 Using "##"
A$[3] = REFNO Using "########## "
C = 2 \ D = 1 \ V1 = H1[1]
Gosub L_5050
error 11000
A$ = " ",A$ \ V1 = H1[1]
A$ = H0[4] Using "######"
A$[7] = REFNO Using "##########"
C = 2 \ D = 2
Gosub L_5050
error 11000
A$ = " ",A$ \ V1 = H1[1]
A$[1,3] = H0[11] Using "###"
A$[4,13] = REFNO Using "##########"
C = 2 \ D = 3 \ E = 0
Gosub L_5050
error 11000
Gosub L_5300
Return 
L_4200: Rem "====================================== repair transactions
If P60$[25,25] <> "Y" Return 
If REPAIR = 1 Return 
If K11$[10,10] <> "A" Goto L_4376
If L3[0] = 1 Goto L_4376
RP$ = " ",RP$;Z1$ = K11$
For I = 0 To 3
  If I <= 2 Let RP0[I] = 0
  RP1[I] = 0
  If I <= 1 Let RP2[I] = 0
Next I
RP$[1,12] = L2$[1,12]
RP0[1] = HWHSE;RP1[0] = H0[9];RP1[1] = H0[7];RP2[2] = OREF[1];RP1[3] = H0[4]
RP2[0] = 0 - T2[0];RP2[1] = 0 - T2[17]
If H5[7] = 21 Let RP0[0] = 1
K11$[10,10] = "B"
Search #11,2,1;K11$,V1,E \ If E > 1 error 11000
If E = 1 Goto L_4372
Mat Read #11,V1,80;OL$; \ Mat Read #11,V1,260;S4;
RP$[13,42] = OL$[1,30]
RP$[103,132] = S1$[1,30]
K11$[10,10] = "C"
Search #11,2,1;K11$,V1,E \ If E > 1 error 11000
If E = 1 Goto L_4304
Mat Read #11,V1,80;OL$;
RP$[43,102] = OL$[1,60]
L_4304: Rem UPDATE SERIAL NO FILE
Gosub L_6300
Gosub L_4400
Goto L_4372
K30$ = " ",K30$;K30$[1,42] = RP$[1,42]
K30$[43] = RP1[1] Using "######"
Search #30,2,1;K30$,R[30],E \ If E = 0 Goto L_4372
If E > 1 error 11000
E = 2;R[30] = 0
Search #30,1,0;K30$,R[30],E \ If E error 11000
Search #30,4,1;K30$,R[30],E \ If E error 11000
Mat Write #30,R[30],0;RP$; \ Mat Write #30,R[30],132;RP0;
Mat Write #30,R[30],138;RP1; \ Mat Write #30,R[30],154;RP2;
K30$ = " ",K30$;K30$[1,30] = RP$[13,42];K30$[31,42] = RP$[1,12]
K30$[43] = RP1[1] Using "######"
Search #30,4,2;K30$,R[30],E \ If E error 11000
L_4372: K11$ = Z1$
L_4376: REPAIR = 1
Return 
L_4400: Rem "====================== repair serial number update
K26$ = " ",K26$;K26$ = RP$[13,42]
Search #26,2,1;K26$,R[26],E \ If E > 1 error 11000
If E = 1 Return 
L_4420: Mat Read #26,R[26],0;SN$;
If SN$[1,12] = RP$[1,12] Goto L_4450
Search #26,3,1;K26$,R[26],E \ If E = 2 Goto L_4490
If E error 11000
If K26$[1,30] <> RP$[13,42] Goto L_4490
Goto L_4420
L_4450: Rem UPDATE REPAIR INFO IN SERIAL FILE
Mat Read #26,R[26],298;SN2 \ Mat Read #26,R[26],342;SN3
If H5[7] = 21 Let SN3[5] = SN3[5] + RP2[1]
If H5[7] = 22 Let SN3[3] = SN3[3] + RP2[1]
Mat Write #26,R[26],298;SN2 \ Mat Write #26,R[26],342;SN3;
Return 1
L_4490: Return 
L_4500: Rem "=================================== serial numbers
P1$ = " ",P1$ \ If Not(L3) Mat Read #14,L4,0;P1$; \ Read #14,L4,512;PFU1;
LOTCNT = 0 \ If P9$[1,1] = "Y" Let LOTCNT = 1
If P9$[1,1] = "B" And P1$[113,113] = "Y" Let LOTCNT = 1
SNKE1$ = " ",SNKE1$;SNKE1$[1,6] = N0 Using "######";SNKE1$[7,9] = L3[2] Using "###"
L_4520: Search #24,3,1;SNKE1$,R7,E \ If E > 2 error 11000
If E Goto L_4990
PO = SNKE1$[1,6] \ LN = SNKE1$[7,9]
If PO <> N0 Or LN <> L3[2] Goto L_4990
Mat Read #24,R7,0;SN1$;
If SN1$[1,12] <> P1$[140,151] Goto L_4520
Mat Read #24,R7,54;SN0;
Read #24,R7,62;OSN;
If L7[4] = 0 Goto L_4955
If L3 <> 0 Goto L_4955
If P1$[8,8] <> "Y" Goto L_4955
If OSN <> 1 Goto L_4955
If Not(LOTCNT) Let SN1$[13,24] = "STOCK        "
If SN1$[13,17] = "STOCK" Let SN1$[13,24] = HWHSE Using "STOCK&&      "
If OSN = 1 Goto L_4900
L_4630: SN$ = " ",SN$;SN$[1,24] = SN1$[1,24];SN$[35,64] = SN1$[25,54]
SN$[85,144] = OL$[1,60]
SN$[145,174] = S1$[1,30]
L_4660: SN1[0] = HWHSE;SN1[1] = PFU1
If H3[1] <> 3 Let SN1[2] = 2
If OSN = 1 Goto L_4765
SN2[6] = H0[8];SN2[3] = N1;SN2[4] = N0;SN2[5] = H0[4];SN3[1] = OLM[3]
SN3[2] = L5[1]
Read #14,L4,632;SN$[65,84];
Read #14,L4,656;SN2[7];
SNK$ = " ",SNK$;SNK$[1,30] = SN$[35,64]
SNK1$ = " ",SNK1$;SNK1$[1,24] = SN$[1,24]
E = 2;R8 = 0
Search #26,1,0;SNK$,R8,E \ If E error 11000
SNK$[31] = R8 Using "##########";SNK1$[25] = SNK$[31]
Search #26,4,1;SNK$,R8,E \ If E error 11000
Search #26,4,2;SNK1$,R8,E \ If E error 11000
L_4765: SN$[25,34] = R8 Using "##########"
Mat Write #26,R8,0;SN$;
Write #26,R8,284;REFNO;
Mat Write #26,R8,290;SN1;
Mat Write #26,R8,298;SN2;
Mat Write #26,R8,342;SN3;
If P9$[8,8] <> "Y" Goto L_4870
SNK$ = " ",SNK$;SNK$[1,10] = REFNO Using "##########"
SNK$[11] = SNKE1$[7]
Search #25,2,1;SNK$,R25,E \ If Not(E) Goto L_4870
If E > 1 error 11000
E = 2;R25 = 0
Search #25,1,0;SNK$,R25,E \ If E error 11000
Search #25,4,1;SNK$,R25,E \ If E error 11000
SN0[0] = N1;SN0[1] = R8
Mat Write #25,R25,0;SN1$;
Mat Write #25,R25,54;SN0;
Write #25,R25,62;OSN;
Write #25,R25,64;REFNO;
L_4870: For I = 0 To 9
  If I <= 2 Let SN1[I] = 0
  SN2[I] = 0
  If I <= 6 Let SN3[I] = 0
Next I
SN$ = " ",SN$
Goto L_4955
L_4900: Rem FLAG SAYS EXISTING (USE SN0[1])
R8 = SN0[1] \ If R8 <= 0 Let OSN = 0 \ Goto L_4630
Mat Read #26,R8,0;SN$;
If SN$[1,12] <> SN1$[1,12] Let OSN = 0 \ Goto L_4630
Mat Read #26,R8,290;SN1
Mat Read #26,R8,298;SN2
Mat Read #26,R8,342;SN3
If SN$[13,24] = SN1$[13,24] Goto L_4660
SNK1$ = " ",SNK1$;SNK1$[1,34] = SN$[1,34]
Search #26,5,2;SNK1$,R8,E \ If E error 11000
SNK1$[13,24] = SN1$[13,24]
Search #26,4,2;SNK1$,R8,E \ If E error 11000
Goto L_4630
L_4955: Rem DEL
SNKE$ = " ",SNKE$;SNKE$[1,30] = SN1$[25,54];SNKE$[31] = L4 Using "######"
Search #24,5,1;SNKE1$,R7,E \ If E error 11000
Search #24,5,2;SNKE$,R7,E \ If E error 11000
E = 3 \ Search #24,1,0;SNKE$,R7,E \ If E error 11000
Goto L_4520
L_4990: Return 

UPDATEROLLINV: REM update roll  inventory file
if p61$[104,104]<>"Y" return
LET KEYORL1$=" ",KEYORL1$;KEYORL1$[1,6]=N0 USING "######";KEYORL1$[7,9]=L3[2] USING "###"
LET BREAK$=KEYORL1$
SRCHORDRL: SEARCH #41,3,1;KEYORL1$,R[41],E \ IF E=2 RETURN 
IF E error 11000
IF KEYORL1$[1,9]<>BREAK$[1,9] RETURN 
MAT  READ #41,R[41],0;SOR$;
MAT  READ #41,R[41],62;SOR1;
MAT  READ #41,R[41],86;SOR2
IF NOT(L7[4]) GOTO DELIROLL:
IF L3[1]=0 GOTO DELIROLL:
IF L3[0] GOTO DELIROLL:
IF PRFLG$[6,6]<>"Y" GOTO DELIROLL:
LET KEYORLH1$=" ",KEYORLH1$
FOR X=0 TO 3 \ LET SORH2[X]=SOR2[X] \ NEXT X
LET SORH2[1]=N0
LET KEYORLH1$[1,8]=SORH2[1] USING "########"
LET KEYORLH1$[9,11]=SOR1[1] USING "###"
LET KEYORLH1$[13,32]=SOR$[13,32]
SEARCH #42,2,1;KEYORLH1$,R[42],E \ IF E>1 error 11000
IF (E) ! new record
  LET E=2 \ SEARCH #42,1,0;KEYORLH1$,R[42],E \ IF E error 11000
  SEARCH #42,4,1;KEYORLH1$,R[42],E \ IF E error 11000
ENDIF 
MAT  WRITE #42,R[42],0;SOR$
MAT  WRITE #42,R[42],62;SOR1
MAT  WRITE #42,R[42],86;SORH2;
LET RL0$=" ",RL0$;RLUSER$=" ",RLUSER$
FOR X=0 TO 5 \ LET RL1[X]=0 \ NEXT X
FOR X=0 TO 2 \ LET RL2[X]=0 \ NEXT X
LET RL0$[1,12]=SOR$[1,12]
LET RL0$[13,32]=SOR$[13,32]
LET RL1[0]=SOR1[0]
LET RL1[1]=H0[8]
LET RL1[2]=247
LET RL1[3]=SOR1[1]
LET RL1[4]=SOR2[0]
LET RL2[0]=SOR2[2]
LET RL2[1]=N0
REM set dir 1
LET KEYRL1$=" ",KEYRL1$
LET KEYRL1$[1,12]=RL0$[1,12]
LET KEYRL1$[13,14]=RL1[0] USING "##"
LET KEYRL1$[15,34]=RL0$[13,32]
LET KEYRL2$=" ",KEYRL2$
LET KEYRL2$[1,20]=RL0$[13,32]
LET KEYRL2$[21,32]=RL0$[1,12]
LET KEYRL2$[33,34]=RL1[0] USING "##"
SEARCH #40,2,1;KEYRL1$,R[40],E \ IF E>1 error 11000
IF E=1 ! set roll
  LET E=2 \ SEARCH #40,1,0;KEYRL1$,R[40],E \ IF E error 11000
  SEARCH #40,4,1;KEYRL1$,R[40],E \ IF E error 11000
  SEARCH #40,4,2;KEYRL2$,R[40],E \ IF E error 11000
ENDIF 
MAT  WRITE #40,R[40],0;RL0$
MAT  WRITE #40,R[40],62;RL1
MAT  WRITE #40,R[40],102;RL2
MAT  WRITE #40,R[40],150;RLUSER$
DELIROLL: REM delete order roll item
LET KEYORL2$=" ",KEYORL2$
LET KEYORL2$[1,20]=SOR$[13,32]
LET KEYORL2$[21,26]=SOR2[3] USING "######"
LET KEYORL2$[27,32]=SOR2[1] USING "######"
LET KEYORL2$[33,35]=SOR1[1] USING "###"
SEARCH #41,5,2;KEYORL2$,R[41],E \ IF E error 11000
SEARCH #41,5,1;KEYORL1$,R[41],E \ IF E error 11000
LET E=3 \ SEARCH #41,1,0;KEYORL1$,R[41],E \ IF E error 11000
GOTO SRCHORDRL:
RETURN 

L_5020: Rem
V1 = 0 \ E = 2
Search #C,1,0;A$,V1,E
If E error 11000
V3 = V1
Return 
L_5050: Rem
V4 = 0
L_5060: Search #C,4,D;A$,V1,E
If Not(E) Return 1
!If E = 1 Print 'RB';"  ALREADY IN FILE!!"
If E = 2 Goto L_5170
L_5080: Return 
E = 3
Search #C,1,0;A$,V1,E
If E error 11000
Return 
L_5170: Rem SRCH.7
If Not(V4) Goto L_5190
!Print 'RB';"  DIRECTORY FULL!!"
Goto L_5080
L_5190: V4 = 99

Goto L_5060
L_5300: Rem ============= CREATE INVHKEY KEYS
R[2] = H1[1]
K32$ = " ",K32$
K32$[1,2] = ARYEAR Using "&&"
K32$[3,4] = M Using "&&"
X2 = K32$[1,4] \ Gosub L_7860
K32$[1,6] = X2 Using "&&&&&&"
K32$[7,8] = H0 Using "##"
K32$[9,18] = REFNO Using "##########"
Search #32,4,1;K32$,R[2],E \ If E error 11000
K32$ = " ",K32$
K32$[1,6] = JIDATE Using "######"
K32$[7,8] = H0 Using "##"
K32$[9,18] = REFNO Using "##########"
Search #32,4,2;K32$,R[2],E \ If E error 11000
K32$ = " ",K32$
K32$[1,6] = H0[7] Using "######"
K32$[7,16] = OREF[1] Using "##########"
Search #32,4,3;K32$,R[2],E \ If E error 11000
K32$ = " ",K32$
K32$[1,10] = OREF[3] Using "##########"
K32$[11,25] = JIDATE Using "#####",REFNO Using "##########"
Search #32,4,4;K32$,R[2],E \ If E error 11000
K32$ = " ",K32$
K32$[1,6] = H0[4] Using "######"
K32$[7,21] = OREF[3] Using "##########",JIDATE Using "#####"
K32$[22,31] = REFNO Using "##########"
Search #32,4,5;K32$,R[2],E \ If E error 11000
!"cct#210803
if icflag   !"build the key on 6/ictrack file
   let k69$=" ",k69$
   let k69$[1,2]=0 using "&&"
   let k69$[3,4]=31 using "##"
   let k69$[5,14]=h0[6] using "##########"
   let k69$[15,20]=h0[7] using "######"
   let k69$[21,26]=h0[4] using "######"
   let k69$[27,32]=0 using "&&&&&&"
   SEARCH #69,4,1;K69$,r[2],E \ IF E error 11000 	
   let k69$=" ",k69$                         
   let k69$[1,2]=0 using "&&"                
   let k69$[3,4]=31 using "##" 
   let k69$[5,10]=0 using "&&&&&&"   
   let k69$[11,20]=h0[6] using "##########"       
   let k69$[21,26]=h0[7] using "######"      
   let k69$[27,32]=h0[4] using "######"      
   SEARCH #69,4,2;K69$,r[2],E \ IF E error 11000    
endif
Return 
!
L_5400: Rem PROCESS EDI REBATE CREDIT CLAIMS
If EDII And Not(L3[0]) !"tag invoices for rebate claims to be processed later
  K27$ = " ",K27$;K27$[1,12] = P1$[140,151];K27$[13,14] = L4[3] Using "##"
  Search #27,2,1;K27$,R[27],E \ If E > 2 error 11000
  If Not(E) Read #27,R[27],50;VENDOR;
  If E Or Not(VENDOR) Let VENDOR = B[24]
  K51$ = " ",K51$;K51$[1,8] = VENDOR Using "VN######"
  Search #51,2,1;K51$,R[51],E \ If E > 1 error 11000
  If Not(E) !"this vendor is an edi trading partner
    Mat Read #51,R[51],8;TP;
    If Int(Abs(TP[867])) !"this vendor is set up to send rebate claims
      K63$ = " ",K63$;K63$[1,12] = H0[7] Using "RB##########"
      K63$[13,15] = L3[2] Using "###"
      Search #63,2,1;K63$,R[63],E \ If E > 1 error 11000
      If Not(E) Goto L_5525
      For X1 = 0 To 8 \ TR[X1] = 0;TR1[X1] = 0 \ Next X1
      Gosub L_5600
      TR[1] = L3[2]
      TR[2] = VENDOR
      TR[7] = 31
      TR[3] = ARDATE;TR[4] = H0[1];TR[5] = D5
      TR2[1] = REFNO
      TR1[8] = Tim(8) + M * 10 ^ 2
      E = 2 \ Search #63,1,0;K63$,R[63],E \ If E error 11000
      Search #63,4,1;K63$,R[63],E \ If E error 11000
      WHPROD$ = " ",WHPROD$
      Write #63,R[63],0;WHPROD$[1,12];
      Mat Write #63,R[63],12;TR
      Mat Write #63,R[63],48;TR1
      Mat Write #63,R[63],102;TRUM$
      Mat Write #63,R[63],106;TRVI$
      Mat Write #63,R[63],126;TRCT$
      Mat Write #63,R[63],158;TR2;
      Mat Write #63,R[63],170;K63$;
L_5525: End If 
  End If 
End If 
Return 
L_5600: Rem Get system cost as determined by rebate cost type from screen2 of vend
K33$ = VENDOR Using "######"
Search #33,2,1;K33$,R[33],E \ If E > 2 error 11000
If Not(E)
  Mat Read #33,R[33],206;M1;
Else 
  Mat M1 = Zer \ M1 = 0
End If 
If M1[17] < 1 Or M1[17] > 6 Let M1[17] = 4
If P9$[32,32] = "Y"
  K27$ = " ",K27$;K27$[1,12] = P1$[140,151];K27$[13,14] = L4[3] Using "##"
  Search #27,2,1;K27$,R[27],E \ If E > 1 error 11000
  If Not(E) Gosub L_6450 \ Unlock #27
  If E Mat W3 = Zer \ Mat W7 = Zer \ Mat WHLV = Zer
  If M1[17] = 1 Let TR2[0] = W3[17]
  If M1[17] = 2 Let TR2[0] = W3[14]
  If M1[17] = 3 Let TR2[0] = W3[15]
  If M1[17] = 4
    TR2[0] = W3[16]
    If W7[14] And WHLV[2] !"does old last cost and date of change exist?
      CHG_DATE$ = WHLV[2] Using "&&&&&&"
      Call DateToJulian(1,CHG_DATE$,CHG_DATE$,E1)
      ACPT_DATE$ = Tim(8) * 10 ^ 4 + Tim(9) * 10 ^ 2 + Tim(10) Using "&&&&&&"
      Call DateToJulian(1,ACPT_DATE$,ACPT_DATE$,E2)
      If Not(E1) And Not(E2)
        CHG_DATE = CHG_DATE$;ACPT_DATE = ACPT_DATE$
        If ACPT_DATE - CHG_DATE <= 14 Let TR2[0] = W7[14]
      End If 
    End If 
  End If 
  If M1[17] = 5 Let TR2[0] = W3[18]
  if m1[17] = 6 let TR2[0] = WHMISC[2]
End If 
L_5750: If P9$[32,32] <> "Y" Or TR2[0] = 0
  If M1[17] = 1 Let TR2[0] = B[8]
  If M1[17] = 2 Let TR2[0] = PF_LOAD2
  If M1[17] = 3 Let TR2[0] = B[21]
  If M1[17] = 4
    TR2[0] = B[10]
    If PLC[2] And PLC[3] !"does old last cost and date of change exist?
      CHG_DATE$ = PLC[3] Using "&&&&&&"
      Call DateToJulian(1,CHG_DATE$,CHG_DATE$,E1)
      ACPT_DATE$ = Tim(8) * 10 ^ 4 + Tim(9) * 10 ^ 2 + Tim(10) Using "&&&&&&"
      Call DateToJulian(1,ACPT_DATE$,ACPT_DATE$,E2)
      If Not(E1) And Not(E2)
        CHG_DATE = CHG_DATE$;ACPT_DATE = ACPT_DATE$
        If ACPT_DATE - CHG_DATE <= 14 Let TR2[0] = PLC[2]
      End If 
    End If 
  End If 
  If M1[17] = 5 Let TR2[0] = PR_C4[4]
  if m1[17] = 6 let TR2[0] = PRPARC[2]
End If 
If Not(TR2[0]) And M1[17] <> 4 Let M1[17] = 4 \ Goto L_5750
Return 
L_6000: Rem =============== CELAR TRACDEL0
K3$ = " ",K3$
K3$ = "11"
L_6030: Search #23,3,1;K3$,R1,E
If E = 2 Goto L_6130
If E error 11000
If K3$[1,2] > "11" Goto L_6130
Search #23,5,1;K3$,R1,E
If E error 11000
E = 3
Search #23,1,0;K3$,R1,E
If E error 11000
Goto L_6030
L_6130: Return 
L_6300: Rem READ LINE
Mat Read #11,R[11],8;L3;
Mat Read #11,R[11],16;L4; \ Mat Read #11,R[11],168;L7;
Mat Read #11,R[11],32;L5;
Mat Read #11,R[11],56;L6; \ Mat Read #11,R[11],256;S2;
Mat Read #11,R[11],80;OL$; \ Mat Read #11,R[11],260;S4;
Mat Read #11,R[11],140;L2$; \ Mat Read #11,R[11],404;OLM;
Mat Read #11,R[11],446;EUN; \ Mat Read #11,R[11],452;UNF; \ Mat Read #11,R[11],494;LCO; \ Mat Read #11,R[11],502;CST;
Mat Read #11,R[11],508;LTAX1; \ Mat Read #11,R[11],538;LTAX2;
Mat Read #11,R[11],548;LPRINTED;
Mat Read #11,R[11],550;OWHS;
Mat Read #11,R[11],552;LP_DATE;
Mat Read #11,R[11],556;LP_TIME;
Return 
L_6400: Rem READ PROD
Mat Read #14,R[14],0;P1$
Mat Read #14,R[14],156;B
Mat Read #14,R[14],256;A
Mat Read #14,R[14],596;PRPARC
Mat Read #14,R[14],894;PR_C4
Mat Read #14,R[14],938;PF_LOAD2
Mat Read #14,R[14],990;PLV
Mat Read #14,R[14],1002;PLC
MAT  READ #14,R[14],1018;PFN
MAT  READ #14,R[14],1056;PRFLG$
Return 
L_6450: Rem "======================== read product warehouse record
Mat Read #27,R[27],0;W1$
Mat Read #27,R[27],32;W1
Mat Read #27,R[27],38;W2
Mat Read #27,R[27],78;W3
Mat Read #27,R[27],228;W5
Mat Read #27,R[27],396;W2$
Mat Read #27,R[27],420;W0
Mat Read #27,R[27],428;WH7
Mat Read #27,R[27],444;WH8
Mat Read #27,R[27],540;WH9
Mat Read #27,R[27],696;W7
Mat Read #27,R[27],780;WHLV
Mat Read #27,R[27],980;WHLBS
MAT  READ #27,R[27],800;WHMISC   
MAT  READ #27,R[27],992;LRNCOST
Return 
L_6950: Rem "======================== write product warehouse record
Mat Write #27,R[27],0;W1$
Mat Write #27,R[27],32;W1
Mat Write #27,R[27],38;W2
Mat Write #27,R[27],78;W3
Mat Write #27,R[27],228;W5
Mat Write #27,R[27],396;W2$
Mat Write #27,R[27],420;W0
Mat Write #27,R[27],428;WH7
Mat Write #27,R[27],444;WH8
Mat Write #27,R[27],540;WH9
Mat Write #27,R[27],696;W7;
Mat Write #27,R[27],980;WHLBS;
Return 

NSTKHist: ! added - read/write Non-Stock History
IF P9$[8,8]<>"Y" Return ! "no invoice history
! uses channels 12 =2128, 31 = desch
k12$=K11$ ! record (L4[0]) is unreliable - use keys ONLY
let k12$[10]="" ! trim last space just in case not there
Search #12,2,1;k12$,r[12],e \ if e>1 error 11000
if e return ! not found - cannot xfer
mat read #12, r[12],   0;nsl7
mat read #12, r[12],  12;nsl$
mat read #12, r[12],  42;nsl1$
mat read #12, r[12],  72;nsl8
mat read #12, r[12], 102;nsl2$
mat read #12, r[12], 120;ha3
mat read #12, r[12], 132;ha1$
mat read #12, r[12], 182;NSinvno
mat read #12, r[12], 190;nsfrt1
mat read #12, r[12], 208;NSUDA$;
k31$=" ",k31$
k31$[1,10]=RefNo using "##########" ! credits keep c/m number
k31$[11,13]=k12$[7,9]
search #31,2,1;k31$,R[31],E \ if e>1 error 11000
if not(e) return ! already there - bypass (restart?)
let e=2;r=0
search #31,1,0;k31$,r,E \ if e error 11000
let r[31]=r[0]
search #31,4,1;k31$,R[31],e \ if e error 11000
NSB4k$="  " ! must have spaces for auto keygen
NSInvno=Refno ! curr c/m - SB only change for history?
mat Write #31, R[31],   0;nsl7
mat Write #31, R[31],  12;nsl$
mat Write #31, R[31],  42;nsl1$
mat Write #31, R[31],  72;nsl8
mat Write #31, R[31], 102;nsl2$
mat Write #31, R[31], 120;ha3
mat Write #31, R[31], 132;ha1$
mat Write #31, R[31], 182;NSinvno
mat Write #31, R[31], 188;NSB4k$
mat Write #31, R[31], 190;nsfrt1
mat write #31, R[31], 208;NSUDA$;
Return

L_7600: Rem CONVERT H0[8] TO JULIAN JIDATE
X2 = H0[8] \ Gosub L_7820 \ X2 = 0
If X2 = 0 ! "BAD DATE?
  X2 = ARDATE \ Gosub L_7820 \ X2 = 0
  If X2 = 0 ! "ARDATE BAD?
    U5$ = "" \ Call Time(U5$)
    Call VerifyDate(U5$,X$,E) \ If E error 11000
    Gosub L_7820 \ error 11000
  End If 
End If 
JIDATE = X2
Return 

L_7800: Rem DATE X$ TO X2
Call VerifyDate(X$,X$,E) \ If E Let X$ = "    "
X2 = X$[1,6] \ Return 
L_7820: Rem  CONVERT YYMMDD TO JULIAN (RETURN=NOGOOD, +1=OKAY)
if x2<=0 return
X$ = X2 Using "&&&&&&"
Call DateToJulian(1,X$,X$,E) \ If E Return 
X2 = X$[1,5] \ Return 1

L_7860: Rem CONVERT YYMM TO YYYYMM
X$ = X2 Using "&&&&"
DT3[0] = X$[1,2];DT3[1] = X$[3,4]
If DT3[0] > 67 Let DT3[0] = 1900 + DT3[0]
If DT3[0] < 68 Let DT3[0] = 2000 + DT3[0]
X$[1,4] = DT3[0] Using "&&&&";X$[5,6] = DT3[1] Using "&&"
X2 = X$[1,6] \ Return 
L_7900: Rem GET CURRENT DATE
U5$ = ""
J4$ = "JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC"
Call Time(U5$)
For K1 = 1 To 12
  If U5$[1,3] = J4$[K1 * 3 - 2,K1 * 3] Goto L_7940
Next K1
E$="DATE ERROR " \ error 10000
L_7940: X$ = "/",X$
X$[1,2] = K1 Using "##"
X$[4,5] = U5$[5,6]
X$[7,8] = U5$[11,12]
For K1 = 1 To 8
  If X$[K1,K1] = " " Let X$[K1,K1] = "0"
Next K1
Return 
L_8000: Rem CHK GLCMTMP
If P9$[17,17] <> "Y" Return 1
F$ = " ",F$ \ F$[1,6] = "DFAULT"
Search #22,2,1;F$,V1,E \ If Not(E) Goto L_8030
E$="G/L - A/R INTERFACE CONTROL NOT SETUP PROPERLY "
Return 
L_8030: F$ = " ",F$
Search #18,2,1;F$,V1,E
If E Goto L_8055
E$=" CREDIT REGISTER/ACCEPT IN PROGRESS (G/L)..TRY AGAIN LATER"
Return 
L_8055: E = 2 \ Search #18,1,0;F$,V1,E
If E error 11000
Search #18,4,1;F$,V1,E
If E error 11000
let eflg[3]=1
Return 1
L_8100: Rem CLR GLCMTMP
If P9$[17,17] <> "Y" Return 
F$ = " ",F$
Search #18,2,1;F$,V1,E
If E Return 
Search #18,5,1;F$,V1,E
If E error 11000
E = 3 \ Search #18,1,0;F$,V1,E
If E error 11000
Return 
L_8200: Rem CHECK CAIP AND IAIP
CAIP$ = "cntrl/caip"+Str$(COID) 
E = 0 \ Call FindF(CAIP$,E) \ If Not(E) Goto L_8250
e$="CREDIT ACCEPT BOMB DETECTED! CANNOT RE-START."
SCRATCH$ = CAIP$
USERPORTINFO[1] = 247
! System "cat " + CAIP$
Gosub MESSAGE
Goto L_8258
L_8250: Rem new - check crip$
CRIP$ = "cntrl/crip"+Str$(COID) 
E = 0 \ Call FindF(CRIP$,E) \ If Not(E) Goto L_8255
E$="CREDIT JOURNAL BOMB DETECTED! CANNOT RE-START."
SCRATCH$ = CRIP$
USERPORTINFO[1] = 246
!System "cat " + CAIP$
Gosub MESSAGE
Goto L_8258
L_8255: IAIP$ = "cntrl/iaip"+Str$(COID) 
E = 0 \ Call FindF(IAIP$,E) \ If Not(E) Goto L_570
E$="INVOICE ACCEPT BOMB DETECTED! CANNOT RE-START."
SCRATCH$ = IAIP$
! System "cat " + IAIP$
USERPORTINFO[1] = 227
Gosub MESSAGE
L_8258: Mat Read #1,120,0;P0
X1 = 247;P0[X1] = 0
Mat Write #1,120,0;P0;
Goto L_8360
MESSAGE: Rem ADD INFO ON ACCEPT BOMB IF IT COULD BE IN PROGRESS
Chan=findchannel()
Open #Chan,SCRATCH$
MESS1: Read #Chan;MESS$;
If MESS$ = "" Close #Chan \ Return 
If MESS$[1,4] <> "user" Goto MESS1
Close #Chan
For K1 = 6 To 22
  If MESS$[K1,K1 + 2] = "SPC" Goto MESS2
Next K1
Return 
MESS2: R = MESS$[6,K1 - 1]
Rem REM NOW DETERMINE IF THEY MIGHT STILL BE IN THERE
USR$ = " ",USR$
Chan=findchannel()
Ropen #Chan,"cntrl/USERCNTRL"
If R[0] > 0 If R[0] < Chf(Chan) Mat Read #Chan,R[0],280;USR$;
Close #Chan
! Print "*******************************************"
E$="NOTE: SOMEONE MAY CURRENTLY BE RUNNING THE "
If USERPORTINFO[1] = 227 E$=E$+"INVOICE ACCEPT. "
If USERPORTINFO[1] = 246 E$=E$+"CREDIT MEMO JOURNAL. "
If USERPORTINFO[1] = 247 E$=E$+"CREDIT MEMO ACCEPT. "
K1 = 20 \ If USR$[16,20] = "     " Let K1 = 15 \ If USR$[11,15] = "     " Let K1 = 10
E$=E$+"PLEASE CHECK " \ If USR$[1,5] <> "     " E$=E$+"WITH "+USR$[1,K1]
E$=E$+" TO SEE IF THIS IS TRUE."
!Print "IF THIS IS THE CASE, AND THERE HAVE BEEN NO ERRORS ON THE OTHER PORT,"
!Print "PLEASE WAIT UNTIL THEY ARE FINISHED. THEN YOU CAN RUN THIS ACCEPT AGAIN."
E$=E$+"OTHERWISE, IF THERE IS A PROBLEM, PLEASE CONTACT UNIVERSAL."
Return 
L_8300: Rem CHK DUP
If H1[1] <> 31 Goto L_8340
Mat Read #2,H1,16;H5;
If H5[0] <> H0[4] Goto L_8350
If H5[3] <> H0[7] Goto L_8350
If H5[4] <> H0[8] Goto L_8350
Return 
L_8340: E$="CREDIT #'S ARE OVERLAPPING TYPE "+Str$(H1[1])+" NUMBERS!"
Goto L_8360
L_8350: Rem DIFF INV
E$="CREDIT "+Str$(H0[7])+" IS ALREADY IN FILE FOR ANOTHER ORDER!"
L_8360: E$=e$+" ACCEPT STOPPED." !  PRESS <CR> TO EXIT  ";
! Input ""V1$
Goto L_9100 ! exit with reset
L_8500: Rem TST STAT
F$ = S Using "##"
Search #8,3,1;F$,V1,E
If E Goto L_8580
V1$[1,2] = S Using "##"
If F$[1,2] = V1$[1,2] Return 1
L_8580: E$="NO CREDITS TO BE ACCEPTED"
Return ! Signal 3,20 \ Return 
 

L_10000: Rem UPDATE INVENTORY (except kit components)
T3 = L7[4]
LBSHIP = S4[4]
If T3 < 0 Let LBSHIP = 0 - LBSHIP
If H5[7] = 15
  T3 = L7[2]
  If H0[5] <> 0 Let T3 = 0;LBSHIP = 0
End If 
If L3[1] And Not(L3[0]) ! "update stock
  R[14] = L4[0] \ Gosub L_6400
  If P1$[127,127] <> "Y" Let LBSHIP = 0
  If H5[7] <> 8 ! "consign/don't do
    If L2$[14,16] = "KIT" Let A[0] = A[0] - T3;PRPARC[3] = PRPARC[3] - LBSHIP
    A[0] = A[0] + T3
    PRPARC[3] = PRPARC[3] + LBSHIP
  End If 
  Mat Write #14,R[14],256;A
  Mat Write #14,R[14],596;PRPARC
if sqlChan >= 0 ! MySQL enabled and channel opened
	e = prod_UpdateSQLFromDL4(e$, intCo, P1$[140,151], sqlChan, 14)
	if e <> 1 ! returns the number of records add/updated/deleted
		error 11000
	end if
end if
  Gosub L_10100
  Unlock #14
End If 
Return 
L_10100: Rem NOW DO WAREHOUSE
WHSE = LWHSE \ Gosub L_3500
Gosub L_6450
INVBAL[0] = W3[0]
If H5[7] <> 7 ! "don't update/billing control
  If L2$[14,16] = "KIT" Let W3[0] = W3[0] - T3;WHLBS[0] = WHLBS[0] - LBSHIP
  W3[0] = W3[0] + T3
  WHLBS[0] = WHLBS[0] + LBSHIP
End If 
Mat Write #27,R[27],78;W3;
Mat Write #27,R[27],980;WHLBS;
If H5[7] = 7 Or H5[7] = 8 ! "consigns
  WHSE = H5[11] \ Gosub L_3500
  Gosub L_6450
  If H5[7] = 7 Let INVBAL[0] = W3[0] Else Let INVBAL[1] = W3[0]
  If H5[7] = 8 Let W3[0] = W3[0] - T3;WHLBS[0] = WHLBS[0] - LBSHIP
  If H5[7] = 7 Let W3[0] = W3[0] + T3;WHLBS[0] = WHLBS[0] + LBSHIP
  Mat Write #27,R[27],78;W3;
  Mat Write #27,R[27],980;WHLBS;
End If 
Return 
L_11000: Rem DO LOT FILES
If L3 Return 
A$ = " ",A$ \ A$ = L2$[1,12]
Search #14,2,1;A$,L4,E
If E Return 
L_11060: Mat Read #14,L4,0;P1$;
Mat Read #14,L4,156;B;
A$ = " ",A$ \ A$ = N0 Using "######"
A$[7] = L3[2] Using "###" \ A$[10] = H5[11] Using "##"
A2$ = A$
Search #15,2,3;A$,V1,E
If Not(E) Goto L_11160
L_11140: Search #15,3,3;A$,V1,E
If E Return 
L_11160: If A$[1,11] <> A2$[1,11] Return 
If Not(KIT) If A$[30,32] = "KIT" Goto L_11140
If KIT If A$[30,32] <> "KIT" Goto L_11140
LN = A$[33,35] \ If KIT If LN <> KL1[1] Goto L_11140
If A$[40,40] = "4" Goto L_11140
A2$ = A$ \ R1 = V1
Mat Read #15,R1;S0$;
Q1 = 0
Mat Read #15,R1,60;S3;
Mat Read #15,R1,96;OL2$;
Q1 = S3[4]
STOCK$ = " ",STOCK$ \ STOCK$[1,12] = S0$[13,24] \ STOCK$[13,22] = OL2$[1,10]
If Not(L3[1]) Goto L_11400
A$ = " ",A$ \ A$[1,2] = H5[11] Using "##" \ A$[3,8] = OL2$[11,16] \ A$[9,32] = S0$[1,24]
If KIT Let A$[33,42] = "          "
Search #16,2,3;A$,V1,E
If E Goto L_11400
Mat Read #16,V1,82;P3
P3[0] = P3[0] - Q1;INVBAL[0] = INVBAL[0] - Q1
If MKIT = 9 Let P3[1] = P3[1] - Q1;INVBAL[0] = INVBAL[0] + Q1
A9 = A9 + (P3[2] * Q1)
Mat Write #16,V1,82;P3
Write #16,V1,74;H0[8]
L_11400: If Not(L7[3]) Goto L_11500
S3[0] = L7[3]
S3[4] = 0
Mat Write #16,V1,82;P3
Write #15,R1,48;H0[8]
Mat Write #15,R1,60;S3;
Goto L_11640
L_11500: Rem DELETE SORDLOT
P$ = " ",P$ \ P$[1,22] = STOCK$[1,22] \ P$[23,39] = A2$[1,17]
P$[40,51] = S0$[1,12] \ V1 = R1 \ A$ = A2$
Search #15,5,3;A$,V1,E
If E error 11000
Search #15,5,2;P$,V1,E
If E error 11000
P$ = " ",P$ \ P$ = S0$[1,12] \ P$[13,51] = A2$[1,39]
P$[52,52] = " "
Search #15,5,1;P$,V1,E
If E error 11000
V1 = R1 \ E = 3
Search #15,1,0;P$,V1,E
If E error 11000
L_11640: Rem "========================================= lottrans
If P9$[9,9] <> "Y" Goto L_11785
If Not(L3[1]) Goto L_11785
clear itr. 
itr.sOpen$=B$;itr.srccode$=B$;itr.comment$=B$
Itr.ProdCode$ = S0$[1,12]+B$
ITR.LotNum$=S0$[13,24]+B$
itr.SrcCode$ = REFNO Using "########"
itr.SrcCode$[9,9] = "-" \ itr.SrcCode$[10,12] = L3[2] Using "###"
ITR.Comment$[1,5] = "CUST#" \ ITR.Comment$[6,12] = H0[4] Using " ######"
ITR.Comment$[13] = B$
itr.TrnsType = 22;itr.Whse = H5[11];itr.EntBy = H5;itr.Tiebrkr = 0
itr.Loc$ = OL2$[11,16]+B$
If MKIT = 9 Let itr.TrnsType = 12
If KIT Let itr.TrnsType = 21
itr.TrnsDate = H0[8];itr.Qty = Q1;itr.CostLoad = P3[2];itr.NetPrice = OLM[3]
itr.RunInvt = INVBAL[0]
itr.CostAvg = OLM[3]
If L7[4] Let itr.CostAvg = (FND(L5[3]) / L7[4])
itr.Wgt = (S4[4]*Sgn(L7[4])) ! "lbs
CH_INVTR = 17
Gosub L_2800
L_11785: If MKIT = 9 Let MKIT = 1 \ Goto L_11640
A$ = A2$ \ If Not(KIT) If MKIT = 1 Let MKIT = 9
Goto L_11140
CTNWGT: Rem "Delete/Xfer Carton Weight Tally
If Not(CH_WT) Return 
KCWT$ = " ",KCWT$;KCWT$[1,6] = N0 Using "######"
KCWT$[7,9] = L3[2] Using "###"
CNW_LOOP: Rem "
Search #CH_WT,3,1;KCWT$,R[36],E \ If E = 2 Return 
If E error 11000
X2[1] = KCWT$[1,6] \ If X2[1] <> N0 Return 
X2[2] = KCWT$[7,9] \ If X2[2] <> L3[2] Return 
If CH_WTH ! "history file Xfer
  KCWTH$ = " ",KCWTH$;KCWTH$[1,10] = REFNO Using "##########"
  KCWTH$[11] = KCWT$[7]
  E = 2;R[37] = 0
  Search #CH_WTH,1,0;KCWTH$,R[37],E \ If E error 11000
  Search #CH_WTH,4,1;KCWTH$,R[37],E \ If E error 11000
  Mat Read #CH_WT,R[36],0;CTNWT;
  Mat Read #CH_WT,R[36],8;CTNWGT;
  CTNWT[0] = N1
  Mat Write #CH_WTH,R[37],0;CTNWT;
  Mat Write #CH_WTH,R[37],8;CTNWGT;
  Write #CH_WTH,R[37],14;REFNO;
End If 
Search #CH_WT,5,1;KCWT$,R[36],E \ If E error 11000
E = 3
Search #CH_WT,1,0;KCWT$,R[36],E \ If E error 11000
Goto CNW_LOOP
UPDATE_INVCOST: REM write out invcost file
if not(invcostflag) return ! no file - no update
LET R[14]=L4[0] \ GOSUB L_6400: \ UNLOCK #14 
FOR IC=0 TO 13
	LET INVCST[IC]=0
	NEXT IC
	LET INVCST$=" ",INVCST$
	LET INVCST$[1,12]=L2$[1,12]
	IF P9$[32,32]="Y" ! WHSE PRICING IS ON
		LET pwK6$=" ",pwK6$;pwK6$[1,12]=P1$[140,151];pwK6$[13,14]=LWhse USING "##"
		SEARCH #27,2,1;pwK6$,Rec_pw,E \ IF E error 11000
		rem get currret prodwhse costs read new vars dont use ones from inv update 
		MAT  READ #27,rec_pw,78;pW3
		MAT  READ #27,rec_pw,800;pwhmisc 
		MAT  READ #27,rec_pw,992;plrncost 
		IF pW3[17] LET INVCST[0]=pW3[17] ELSE  LET INVCST[0]=B[8]
		IF pW3[14] LET INVCST[1]=pW3[14] ELSE  LET INVCST[1]=PF_LOAD2
		IF pW3[15] LET INVCST[2]=pW3[15] ELSE  LET INVCST[2]=B[21]
		IF pW3[16] LET INVCST[3]=pW3[16] ELSE  LET INVCST[3]=B[10]
		IF pW3[18] LET INVCST[5]=pW3[18] ELSE  LET INVCST[5]=PR_C4[4]
		IF pWHMISC[2] LET INVCST[4]=pWHMISC[2] ELSE  LET INVCST[4]=PRPARC[2]

	ENDIF 
	IF P9$[32,32]="N" ! WHSE PROCING IS OFF
		LET INVCST[0]=B[8]
		LET INVCST[1]=PF_LOAD2
		LET INVCST[2]=B[21]
		LET INVCST[3]=B[10]
		LET INVCST[5]=PR_C4[4]
		LET INVCST[4]=PRPARC[2]
	ENDIF 

LET INVCST[8]=H0[7]
LET INVCST[9]=L3[2]
LET INVCST[11]=H0[4]
LET INVCST[12]=l0[1]
LET CH_REBATEDTL=46 ! 40
MAT REBATE_ARGS=ZER
LET REBATE_ARGS[1,0]=14
LET REBATE_ARGS[2,0]=27
LET REBATE_ARGS[3,0]=33
LET REBATE_ARGS[4,0]=45 ! 39
LET REBATE_ARGS[5,0]=46 ! 40
LET REBATE_ARGS[1,1]=R[14]
LET REBATE_ARGS[2,1]=R[27]
IF L4[3] LET REBATE_ARGS[1,2]=L4[3] ELSE  LET REBATE_ARGS[1,2]=H4[2]
LET REBATE_ARGS[2,2]=H0[4]
LET REBATE_ARGS[3,2]=0
LET REBATE_ARGS[4,2]=H0[8]
LET REBATE_ARGS[5,2]=H6[0]
! CALL "rebates",REBATE_ARGS[],P1$[140,151],STATUS
call rebates(e$,Rebate_args[],P1$[140,151],Status,0,"") ! new external sub
IF NOT(STATUS) !"indicates call was successful in finding rebate
	LET INVCST[6]=REBATE_ARGS[1,3]
	LET REC_REBATEDTL=REBATE_ARGS[5,1]
	MAT  READ #CH_REBATEDTL,REC_REBATEDTL,12;RB1
	LET INVCST[13]=RB1[0]
ENDIF 
k_inv_cost$=" ",k_inv_cost$
k_inv_cost$[1,10]=INVCST[8] USING "##########"
K_INV_COST$[11,13]=INVCST[9] USING "###"
K_INV_COST$[14,15]=ARYEAR USING "&#"
K_INV_COST$[16,17]=ARMONTH USING "&#"
SEARCH #CH_INVCOST,2,1;K_INV_COST$,REC_INVCOST,E  ! already there?
if not(e) ! and not(restart)   ! found it
   error 11000 ! key in there - no restart
endif
if e
	! now, if we didn't find it, build it.
	LET E=2
	SEARCH #CH_INVCOST,1,0;K_INV_COST$,REC_INVCOST,E \ IF E error 11000
	SEARCH #CH_INVCOST,4,1;K_INV_COST$,REC_INVCOST,E
	IF E error 11000
Endif
LET INVCST[10]=K_INV_COST$[14,17]
MAT  WRITE #CH_INVCOST,REC_INVCOST,0;INVCST$
MAT  WRITE #CH_INVCOST,REC_INVCOST,22;INVCST;
LET K_INV_COST$=" ",K_INV_COST$
LET K_INV_COST$[1,12]=INVCST$[1,12]
LET K_INV_COST$[13,14]=ARYEAR USING "&#"
LET K_INV_COST$[15,16]=ARMONTH USING "&#"
LET K_INV_COST$[17,26]=INVCST[8] USING "##########"
LET K_INV_COST$[27,29]=INVCST[9] USING "###"
SEARCH #CH_INVCOST,4,2;K_INV_COST$,REC_INVCOST,E
IF E error 11000
LET K_INV_COST$=" ",K_INV_COST$
LET K_INV_COST$[1,6]=INVCST[11] USING "######"
LET K_INV_COST$[7,8]=ARYEAR USING "&#"
LET K_INV_COST$[9,10]=ARMONTH USING "&#"
LET K_INV_COST$[11,20]=INVCST[8] USING "##########"
LET K_INV_COST$[21,23]=INVCST[9] USING "###"
SEARCH #CH_INVCOST,4,3;K_INV_COST$,REC_INVCOST,E
IF E error 11000
RETURN
!
ERR_MSG: ! send message
ReturnStatus=1 ! 0 ! no good (ONLY DISPLAYS IF =1 ??)
Message$=E$
if statchan
	print #statchan;message$
	print #statchan;"The accept has ended in an error"
Else
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
Endif
End
L_9100: Rem EXIT ENTIRELY - check flags to clear
If eflg[3] Gosub L_8100 ! clear glcmtemp
If Eflg[1] ! set p0[] - so reset it
	Mat Read #1,120,0;P0
	X1 = 247;P0[X1] = 0
	Mat Write #1,120,0;P0;
Endif
If EFlg[2] ! set caip - so clear it
	Try Kill CAIP$ Else Rem
Endif
!L_9110: Rem exit no reset
!Print 'CS';
L_9120: !Close 
Goto Err_Msg: ! send 'em a message!
!Chain "MX000"
End
OUTEND: Rem END
!Print 'CR';"-- PART 1 COMPLETE --"
If statchan
	print #statchan;"PART 1 COMPLETE"
Endif
!Signal 3,5
!If Err 0 Rem
For X1 = 2 To 89
  if x1<>statchan Try Close #X1 Else Rem
Next X1
if sqlChan<>-1 try close #sqlChan else rem
Chain "247A.dl4"

End 
Rem {begin rtn.error.s}
Else
!
If statchan print #statchan;"Part 1 - Error... Please call Universal."
!
include "src/callmainerrnet.inc"
end try
End ! the whole program