! --- dxblock.dl4 
! Display/maintain Page Block Definitions 
!
! loadsave -w -n 100,10 -o dxblock.dl4 src/dxblock.src
!
! 1.0 12/6/2004 new 
!
!all rights reserved. (c)copyright 2005 by: Dynamic Concepts 
!
!
!
! *declare dl4 intrinsic subs & functions
declare intrinsic function findchannel,trim$,dateusing$,fmtof,replace$
declare intrinsic sub programdump,dxopen,dxget,dxset,dxclose,dxsave,getglobals
declare intrinsic sub convertcase
!
!
external lib "dxblockgeneral.lib" !general routines
declare external sub blocksuberr,blockmainerr,blockreadsystemfile,blockopenfiles
declare external function blockgetprogrampath$,blockcrc$,blockgetmsg$
!
external lib "dfgeneral.lib"
declare external function builddir  !builds help dir if needed for help text
!
declare sub collist,inplist,droplistlist,butlist
!
include "src/dffiles.bsh"
include "src/dxblockfiles.bsh"
!
Dim BlockHdr. As BlockHdr, blockcol. as blockcol, blockinp. as blockinp
dim blockinplst. as blockinplst, blockbut. as blockbut
dim oldblockhdr. as blockhdr, oldblockcol. as blockcol, oldblockinp. as blockinp
dim oldblockinplst. as blockinplst, oldblockbut. as blockbut
!
!
! linked to df File Defs
external lib "dfgeneral.lib" !dfgeneral routines
declare external sub readsystemfile,openfiles
!
!
Dim filedefhdr. As filedefhdr, filedeffields. as filedeffields, filedefkey. as filedefkey
! end df File Defs
!
! any external subs included in this program file
!
external sub subname(e$,chan0)
!--------------------------------------------------------------------
! desc
 try
  !dims here
  !
 else
  if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !subname
!
!now any internal subs or functions for the program
!
!
sub fixinplist()
!--------------------------------------------------------------------
! sub to mass change something in input file
 try
 !
  seq=-2
  Try Search >= #c[2],1; Else Rem
  Do
  Try Read Record #c[2],seq;blockinp. Else Exit Do
  blockinp.required$="N"
  Write Record #c[2],-2;blockinp.;
  seq=-1
  loop
  ;"done"
 else
  if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !fixinplist
!
sub blocksearch()
!--------------------------------------------------------------------
! block search routine
 try
  !
  call dxget("keyvar",keyvar$)
  !call dxget("keyno",keyno$)
  keyno$="1"
  call dxget("keynext",keynext$)
  keys$=keyvar$
  if keynext$<>"" let keys$=keynext$
  if keys$<="        " let keys$="       !" !skip common prompts on list
  hdrkeyno=keyno$
  hdrseq=-2 
  Try Search >= #c[0],hdrkeyno;keys$ Else Rem
  Do
   Try Read Record #c[0],hdrseq;blockhdr. Else Exit Do
   if keyvar$<>"" if hdrkeyno=1 if blockhdr.id$[1,len(keyvar$)]<>keyvar$ exit do
   if cnt>maxcnt exit do
   idlist$[cnt]=blockhdr.id$
   desclist$[cnt]=blockhdr.desc$
   if desclist$[cnt]="" let desclist$[cnt]=" "
   titlelist$[cnt]=blockhdr.title$
   if titlelist$[cnt]="" let titlelist$[cnt]=" "
   filenamelist$[cnt]=blockhdr.filename$
   if filenamelist$[cnt]="" let filenamelist$[cnt]=" "
   cnt=cnt+1
   hdrseq=-1 !get next
  Loop
  !
  if cnt>maxcnt 
   if hdrkeyno=1 let tmp$=blockhdr.id$
   call dxset("keynext",tmp$)
  end if
  call dxset("blockid",idlist$[])
  call dxset("blockdesc",desclist$[])
  call dxset("blocktitle",titlelist$[])
  call dxset("blockfilename",filenamelist$[])
  !
 
  call dxset("output",mergedir$+"dxblockpr.html")
 else
  if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !blocksearch
!
sub loadinpcolumns(...)
!--------------------------------------------------------------------
! load inp columns for display (also used by getcommon
 try
 try enter flag else let flag=0
if blockinp.type$="LISTA" if blockinp.label$="" let blockinp.label$="Select"
   desclist$[cnt]='fx',"[label] ",blockinp.label$
   if flag let desclist$[cnt]=desclist$[cnt],"<br>[variable name] ",blockinp.varname$
   if flag=0 if blockinp.id$="" 
    let desclist$[cnt]='fx',"[common] ",blockinp.masterdesc$
	let desclist$[cnt]=desclist$[cnt],"<br>[label] ",blockinp.label$
   end if
   if blockinp.default$<>"" let desclist$[cnt]=desclist$[cnt],"<br>","[default] ",blockinp.default$
   if desclist$[cnt]="" let desclist$[cnt]=" "
   typelist$[cnt]=blockinp.type$
   if typelist$[cnt]="LIST" !show drop list selections under description (until destlist$ is full)
    if blockinp.listfilename$<>"" !show filename list is generated from
	 typelist$[cnt]=typelist$[cnt],"(from file ",blockinp.listfilename$,")"
	else
	cnt2=0
	seq2=-2
    Try Search >= #c[3],1;blockid$,blockinp.seq Else Rem
    Do
    Try Read Record #c[3],seq2;blockinplst. Else Exit Do
    if blockinplst.id$<>rtrim$(blockid$) or blockinplst.seq<>blockinp.seq exit do
    if blockinplst.active$="Y"
	 if cnt2=0  let   desclist$[cnt]=desclist$[cnt],"<br>[droplist values]"
	 cnt2=cnt2+1
	 tmp$="<br>",blockinplst.value$," ",blockinplst.label$
	 if len(desclist$[cnt])+len(tmp$) <= fmtof(desclist$) 
	  let desclist$[cnt]=desclist$[cnt],tmp$
	 else
	  exit do !desclist$ var is full
	 end if
	 seq2=-1 !get next inplst
	end if
	Loop
	end if !listfilename$
   end if
   if typelist$[cnt]="TEXT"
    tmp$=""
    if blockinp.minlength let tmp$="Min ",str$(blockinp.minlength)
	if blockinp.maxlength let tmp$=tmp$," Max ",str$(blockinp.maxlength)
	if tmp$<>"" let typelist$[cnt]=typelist$[cnt]," (",ltrim$(tmp$),")"
   end if 
   if typelist$[cnt]="NUMBER"
    tmp$=""
    if blockinp.minlength let tmp$="Min ",str$(blockinp.minlength)," "
	if blockinp.maxlength let tmp$=tmp$,"Max ",str$(blockinp.maxlength)," "
    let typelist$[cnt]=typelist$[cnt]," (",ltrim$(tmp$),blockinp.mask$,")"
   end if
   if typelist$[cnt]="CHECK"
    tmp$=""
    if blockinp.checkvalue$<>"" if blockinp.checkvalue$<>"                    "
	 let blockinp.checkvalue$=blockinp.checkvalue$,"                    "
	 tmp$=rtrim$(blockinp.checkvalue$[1,10])," ",rtrim$(blockinp.checkvalue$[11,20])
	end if
	if blockinp.default$="checked" let tmp$=tmp$," default on"
	if tmp$<>"" let typelist$[cnt]=typelist$[cnt]," (",ltrim$(tmp$),")"
   end if
   varnamelist$[cnt]=blockinp.varname$
   if varnamelist$[cnt]="" let varnamelist$[cnt]=" "
   tmp$="   "
   if blockinp.required$="Y" let tmp$="Required, "
   if blockinp.disabled$="Y" let tmp$=tmp$,"Disabled, "
   if blockinp.notab$="Y" let tmp$=tmp$,"NoTab, "
   if blockinp.focus$="Y" let tmp$=tmp$,"Focus, "
   ruleslist$[cnt]=tmp$[1,len(tmp$)-2] !remove ending ,
else
  if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !blocksearch
!
sub getfield()
!--------------------------------------------------------------------
! respond to ajax request to get field information from file definitions
 try
  call dxget("filename",filename$)
  call dxget("BLOCKVarname",tmp$)
  if tmp$="RecordNumber"
   ajax$="ID|NUMBER|0|"
   call dxset("xmlstring",ajax$)
  else
  keyno=1
  seq=-2
  Try Search >= #dfc[1],keyno;filename$ Else Rem
  Do
   Try Read Record #dfc[1],seq;filedeffields. Else Exit Do
   if filedeffields.filename$<>rtrim$(filename$) exit do
   if filedeffields.varname$=tmp$
   	call convertcase(6,filedeffields.shortdesc$) !convert to lower
	call convertcase(3,filedeffields.shortdesc$) !convert 1st char each word to upper
    ajax$=filedeffields.shortdesc$,"|"
	if filedeffields.precision > 0 
	 ajax$=ajax$,"TEXT|",str$(filedeffields.precision),"|"
	else
     ajax$=ajax$,"NUMBER|0|"
	end if
    call dxset("xmlstring",ajax$)
	exit do
   end if
   seq=-1
  Loop
  end if !recordno
  !
  call dxset("output",mergedir$+"ajax.html")
 else
  if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !getfield
!
!
sub getcommon()
!--------------------------------------------------------------------
! respond to ajax request to get common prompt information
 try
  call dxget("seq",blockseq$)
  blockseq=blockseq$
  blockid$="        "
  keyno=1
  Try Search = #c[2],keyno;blockid$,blockseq Else Rem
  Try Read Record #c[2],-2;blockinp. Else rem
  !
  call loadinpcolumns(1)
  ajax$='fx',"Common Definition:<br>",typelist$[0],"<br>",desclist$[0],"<br>",ruleslist$[0]
  !
  call dxset("xmlstring",ajax$)
  !
  call dxset("output",mergedir$+"ajax.html")
 else
  if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !getcommon
!
sub commonlist()
!--------------------------------------------------------------------
! common list routine, show where used
 try
 !
  call dxget("seq",blockseq$)
  blockseq=blockseq$
  blockid$="        "
  try Search = #c[2],1;blockid$,blockseq else rem
  try read record #c[2],-2;blockinp.; else rem
  call dxset("masterseq",blockseq$)
  call dxset("masterdesc",blockinp.masterdesc$)
  cnt=0
  blockid$="       !"
  seq=-2
  Try Search >= #c[2],1;blockid$ Else Rem
  Do
  Try Read Record #c[2],seq;blockinp. Else Exit Do
   if blockinp.masterseq=blockseq
    if cnt>ubound(idlist$[],1)
     dim idlist$[ubound(idlist$[],1)+50,fmtof(idlist$)]
     dim seqlist$[ubound(seqlist$[],1)+50,fmtof(seqlist$)]
     dim desclist$[ubound(desclist$[],1)+50,fmtof(desclist$)]
     dim actlist$[ubound(actlist$[],1)+50,fmtof(actlist$)]
    end if
	idlist$[cnt]=blockinp.id$
    seqlist$[cnt]=str$(blockinp.seq)
    if blockinp.active$="Y" let actlist$[cnt]="Active" else let actlist$[cnt]=" "
    tmp$='fx'
	if blockinp.label$<>"" let tmp$=tmp$,"[label] ",blockinp.label$,"<br>"
	if blockinp.varname$<>"" let tmp$=tmp$,"[variable] ",blockinp.varname$,"<br>"
	if blockinp.helppage$<>"" let tmp$=tmp$,"[help] ",blockinp.helppage$,"<br>"
	if blockinp.default$<>"" let tmp$=tmp$,"[default] ",blockinp.default$,"<br>"
	if len(tmp$)>1 let tmp$=tmp$[1,len(tmp$)-4] else let tmp$=" "
	desclist$[cnt]=tmp$
	cnt=cnt+1
   end if !seq
   seq=-1 !get next
  Loop
  !
 
  if cnt
   idlist$[cnt]=""
   seqlist$[cnt]=""
   desclist$[cnt]=""
   actlist$[cnt]=""
   call dxset("inpblock",idlist$[])
  call dxset("inpseq",seqlist$[])
   call dxset("inpactive",actlist$[])
   call dxset("inpoverrides",desclist$[])
  end if
  !
    call dxset("output",mergedir$+"dxblockcommonview.html")
  !
else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !commonlist
!
sub droplistfilenames()
!--------------------------------------------------------------------
! create drop list of all the filenames from file definitions 
! used by blockhdr maintenance to select a filename
 try
  Dim value$[80]
 !
  cnt=0
	FileName$="sfdroplists.txt"
	Chan=FindChannel()
	ropen #Chan,"prog/dxport/"+FileName$ as "profile"
	!droplists for dxblock definitions
	try
		search #Chan;"blockdroplists" !search for blockdroplists section, case insensitive
		mode=-2
		Do
			read #chan,mode;value$
			mode=-1
			if len(value$)>1 and value$[len(value$)]="\15\" let value$=value$[1,len(value$)-1]
			! add to list here
			if value$ desclist$[cnt]=value$ \cnt=cnt+1 !ubs hardcoded, ship via desc are in rcd 130 of cntrl file
		Loop
	else
		! if spc(8)<>52
		! include "src/callsuberr.inc"
		! end if
	end try
	close #chan  
  ! desclist$[cnt]="shipvia" \cnt=cnt+1 !ubs hardcoded, ship via desc are in rcd 130 of cntrl file
  keyno=1
  seq=-2
  Try Search >= #dfc[0],keyno; Else Rem
  Do
  Try Read Record #dfc[0],seq;filedefhdr. Else Exit Do
   if ucase$(filedefhdr.active$)="A" !active
   desclist$[cnt]=filedefhdr.filename$
   cnt=cnt+1
   if cnt>ubound(desclist$[],1)
     dim desclist$[ubound(desclist$[],1)+50,fmtof(desclist$)]
   end if
   end if
   seq=-1 !get next
  Loop
  !
 if cnt
  desclist$[cnt]=""
  call dxset("filenames",desclist$[])
 end if
 else
  if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !droplistfilenames
!
sub droplistvarnames()
!--------------------------------------------------------------------
! create drop list of all the varnames from file definitions 
! used by blockinp maintenance to select a varname
 try
 !
  call dxset("filename",blockhdr.filename$)
  desclist$[0]="RecordNumber"
  cnt=1 
  keyno=1
  seq=-2
  Try Search >= #dfc[1],keyno;blockhdr.filename$ Else Rem
  Do
   Try Read Record #dfc[1],seq;filedeffields. Else Exit Do
   if filedeffields.filename$<>rtrim$(blockhdr.filename$) exit do

   desclist$[cnt]=filedeffields.varname$
   cnt=cnt+1
   if cnt>ubound(desclist$[],1)
     dim desclist$[ubound(desclist$[],1)+50,fmtof(desclist$)]
   end if
   seq=-1 !get next
  Loop
  !
 if cnt
  desclist$[cnt]=""
  call dxset("varnames",desclist$[])
 end if
 else
  if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !droplistfieldnames
!
sub droplistmasternames()
!--------------------------------------------------------------------
! create drop list of all the common prompts 
! used by blockinp maintenance to select a common prompt
 try
 !
  cnt=0 
  keyno=1
  seq=-2
  keyvar$="        "
  Try Search >= #c[5],keyno;keyvar$ Else Rem
  Do
   Try Read Record #c[5],seq;blockinp. Else Exit Do
   if blockinp.id$<>"" exit do
   if blockinp.active$="Y"
   seqlist$[cnt]=str$(blockinp.seq)
   desclist$[cnt]=blockinp.masterdesc$
   cnt=cnt+1
   if cnt>ubound(seqlist$[],1)
     dim seqlist$[ubound(seqlist$[],1)+50,fmtof(seqlist$)]
   end if
   if cnt>ubound(desclist$[],1)
     dim desclist$[ubound(desclist$[],1)+50,fmtof(desclist$)]
   end if
   end if !active
   seq=-1 !get next
  Loop
  !
 if cnt
  seqlist$[cnt]=""
  desclist$[cnt]=""
  call dxset("masterseqs",seqlist$[])
  call dxset("masternames",desclist$[])
 end if
 else
  if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !droplistmasternames
!
sub blockhdradd()
!--------------------------------------------------------------------
! add hdr routine,verify id not in use or assign id
 try
 !
  call dxget("keyvar",keyvar$)
  if keyvar$<>"" if rtrim$(keyvar$)="" !reserved for commons
    e$="Block ID ",keyvar$," is reserved for Common Prompts!"
    error 10000
  end if
  if keyvar$=""  !assign an id
   keyvar$="99999999"
   try search <= #c[0],1;keyvar$ else let keyvar$="0"     
   keyvar=keyvar$
   keyvar=keyvar+1
   if keyvar>0 and keyvar<=99999999 
    keyvar$=keyvar using "&&&&&&&&"
   else
    e$="Could not generate next Block ID!"
    error 10000
   end if
  else !verify not in use
   Try 
    if len(keyvar$)<8 let keyvar$=keyvar$,b$[1,8-len(keyvar$)] !space fill
    Search = #c[0],1;keyvar$
    e$="Block ID ",keyvar$," is already on file!"
    error 10000
   Else
   End Try
  end if
  !
  call dxset("newkeyvar",keyvar$)
  call dxset("u_blockid","")
  call droplistfilenames()
  call dxset("output",mergedir$+"dxblock.html")
 else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !blockhdradd
!
sub blockhdrchg()
!--------------------------------------------------------------------
! change hdr routine, get/display record
!
 try
  if blockid$="" let blockid$="        "
  keyvar$=blockid$
  Try
    Search = #c[0],1;keyvar$
  Else
    if blockid$="        " !common, go ahead and add it
	 blockhdr.id$=blockid$
	 blockhdr.desc$="Common Prompts"
     Add Record #c[0];blockhdr.
	 Search = #c[0],1;keyvar$
	else
     e$="Block ID ",keyvar$," is not on file!"
     error 10000
	end if
  End Try
  !
  Read Record #c[0],-2;blockhdr.
  !
  if blockid$="        " call dxset("u_blockid","        ")
  call dxset("newkeyvar",keyvar$)
  call dxset("blockdesc",blockhdr.desc$)
  call dxset("blockfilename",blockhdr.filename$)
  call dxset("blockprogramname",blockhdr.programname$)
  call dxset("blocktitle",blockhdr.title$)
  call dxset("blocksubtitle",blockhdr.subtitle$)
  call dxset("blockinclude1",blockhdr.include1$)
  call dxset("blockinclude2",blockhdr.include2$)
  call dxset("blockrowlink",blockhdr.rowlink$)
  call dxset("blockcustom1",blockhdr.custom1$)
  call dxset("blockcustom2",blockhdr.custom2$)
  call dxset("blockcustom3",blockhdr.custom3$)
  call dxset("blockconditions",blockhdr.conditions$)
  if blockhdr.evenodd$ = "Y"
   call dxset("blockevenoddy","select")
  else
   call dxset("blockevenoddn","select")
  end if
  call dxset("addedby",blockhdr.addedby$)
  call dxset("updatedby",blockhdr.updatedby$)
  call dxset("addeddate",blockhdr.addeddate$)
  call dxset("updateddate",blockhdr.updateddate$)
  !
  !get other tables to display
  !
   call collist()
   call inplist()
   call butlist()
   call droplistfilenames()
   call dxset("output",mergedir$+"dxblock.html")
   if action$="print" call dxset("output",mergedir$+"dxblockview.html")
 else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !blockhdrchg
!
sub blockhdrdel()
!--------------------------------------------------------------------
! delete hdr routine, delete hdr and all it's components
 try
 !
 call dxget("u_blockid",keyvar$)
 try
  Search = #c[0],1;keyvar$
 Else
  e$="Block ID ",keyvar$," is not on file!"
  error 10000
 End Try
 !??delete in other files also
 !col file
   seq=-2
   Try Search >= #c[1],1;keyvar$ Else Rem
  Do
   Try Read Record #c[1],seq;blockcol. Else Exit Do
   if blockcol.id$<>rtrim$(keyvar$) exit do
   Delete Record #c[1]
   seq=-1
  Loop
 !inp file
   seq=-2
   Try Search >= #c[2],1;keyvar$ Else Rem
  Do
   Try Read Record #c[2],seq;blockinp. Else Exit Do
   if blockinp.id$<>rtrim$(keyvar$) exit do
   Delete Record #c[2]
   seq=-1
  Loop
 !inplst file
   seq=-2
   Try Search >= #c[3],1;keyvar$ Else Rem
  Do
   Try Read Record #c[3],seq;blockinplst. Else Exit Do
   if blockinplst.id$<>rtrim$(keyvar$) exit do
   Delete Record #c[3]
   seq=-1
  Loop
 !but file
   seq=-2
   Try Search >= #c[4],1;keyvar$ Else Rem
  Do
   Try Read Record #c[4],seq;blockbut. Else Exit Do
   if blockbut.id$<>rtrim$(keyvar$) exit do
   Delete Record #c[4]
   seq=-1
  Loop
  Delete Record #c[0]
  e$="Block ID ",keyvar$," has been deleted!"
  error 10000
 else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !blockhdrdel
!
sub blockhdrsave()
!--------------------------------------------------------------------
! save hdr routine
 try
 !
  call dxget("u_blockid",keyvar$)
  call dxget("newkeyvar",blockhdr.id$)
  call dxget("blockdesc",blockhdr.desc$)
  call dxget("blockfilename",blockhdr.filename$)
  call dxget("blockprogramname",blockhdr.programname$)
  call dxget("blocktitle",blockhdr.title$)
  call dxget("blocksubtitle",blockhdr.subtitle$)
  call dxget("blockinclude1",blockhdr.include1$)
  call dxget("blockinclude2",blockhdr.include2$)
  call dxget("blockrowlink",blockhdr.rowlink$)
  call dxget("blockevenodd",blockhdr.evenodd$)
  call dxget("blockcustom1",blockhdr.custom1$)
  call dxget("blockcustom2",blockhdr.custom2$)
  call dxget("blockcustom3",blockhdr.custom3$)
  call dxget("blockconditions",blockhdr.conditions$)
  !
  if keyvar$=""  !it's an add
   Try
    blockhdr.addeddate$=dateusing$(tim#(0),"MM/DD/YYYY HH:NN")
    call dxget("s_user.id",blockhdr.addedby$)
    Add Record #c[0];blockhdr.
   Else
    e$="Could not add new record, try again!"
    error 10000
   end try
   tmp$="Block ID ",blockhdr.id$," added!"
   call dxset("msg",tmp$)
   blockid$=blockhdr.id$
   call dxset("u_blockid",blockid$)
   !
   !if AutoGen option requested, generate Input Field Definitions from file def
   call dxget("blockautogen",tmp$)
   if tmp$="Y"
    !defaults
    blockinp.ID$ = blockhdr.ID$
	blockinp.active$ = "Y"
	blockinp.required$ = "Y"
	blockinp.disabled$ = "N"
    blockinp.notab$ = "N"
    blockinp.focus$ = "Y" !first one
    !loop through filedef and gen input fields
	seq=-2
	keyno=1
	!??alert/warning doesn't deal with version #'s (maybe find last one?)
    Try Search >= #dfc[1],keyno;blockhdr.filename$ Else Rem
    Do
     Try Read Record #dfc[1],seq;filedeffields. Else Exit Do
     if filedeffields.filename$<>rtrim$(blockhdr.filename$) exit do
	 if ucase$(filedeffields.shortdesc$) <> "SPARE"
	 blockinp.seq = blockinp.seq + 10
	 call convertcase(6,filedeffields.shortdesc$) !convert to lower
	 call convertcase(3,filedeffields.shortdesc$) !convert 1st char each word to upper
	 blockinp.label$ = filedeffields.shortdesc$
     blockinp.varname$ = filedeffields.varname$
	 if filedeffields.precision > 0 !string
	  blockinp.type$ = "TEXT"
	  blockinp.maxlength = filedeffields.precision
	 else
	  blockinp.type$ = "NUMBER"
	  blockinp.maxlength = 0
	 end if
	 !
	 Add Record #c[2];blockinp.
	 blockinp.focus$ = "N" !rest
	 end if !SPARE
     seq=-1 !get next
	loop
   end if !autogen
   !
  else !change
   try
    search = #c[0],1;keyvar$
    read record #c[0],-2;oldblockhdr.
    !compate crc's
    !??
	blockhdr.addeddate$=oldblockhdr.addeddate$
	blockhdr.addedby$=oldblockhdr.addedby$
	blockhdr.updateddate$=dateusing$(tim#(0),"MM/DD/YYYY HH:NN")
    call dxget("s_user.id",blockhdr.updatedby$)
    write record #c[0],-2;blockhdr.;
   else
    e$="Could not update record, try again!"
    error 10000
   end try
   tmp$="Block ID ",blockhdr.id$," is updated!"
   call dxset("msg",tmp$)
   blockid$=keyvar$
  end if

  !
  call blockhdrchg() !redisplay updated page
 else
  if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !blockhdrsave
!
sub blockhdrcopy()
!copy from one blockid to a new blockid
 try
 !
  call dxget("newblockid",newver$)
  keyvar$=blockid$
  !
   Try
   search = #c[0],1;keyvar$
   read record #c[0],-2;blockhdr.
   blockhdr.addeddate$=dateusing$(tim#(0),"MM/DD/YYYY HH:NN")
   call dxget("s_user.id",blockhdr.addedby$)
   blockhdr.updateddate$=""
   blockhdr.updatedby$=""
   blockhdr.id$=newver$
   Add Record #c[0];blockhdr.
   Else
   e$="Could not add new header record, try again!"
    error 10000
   end try
 !copy col rcds
 seq=-2
 Try Search >= #c[1],1;keyvar$ Else Rem
 Do
  Try Read Record #c[1],seq;blockcol. Else Exit Do
  if blockcol.id$<>rtrim$(keyvar$) exit do
  blockcol.id$=newver$
  Add Record #c[1];blockcol.
  Try Search > #c[1],1;keyvar$,blockcol.seq Else Exit Do
 Loop
 !copy inp rcds
 seq=-2
 Try Search >= #c[2],1;keyvar$ Else Rem
 Do
  Try Read Record #c[2],seq;blockinp. Else Exit Do
  if blockinp.id$<>rtrim$(keyvar$) exit do
  blockinp.id$=newver$
  Add Record #c[2];blockinp.
 Try Search > #c[2],1;keyvar$,blockinp.seq Else Exit Do
 Loop
 !copy inplst rcds
 seq=-2
 Try Search >= #c[3],1;keyvar$ Else Rem
 Do
  Try Read Record #c[3],seq;blockinplst. Else Exit Do
  if blockinplst.id$<>rtrim$(keyvar$) exit do
  blockinplst.id$=newver$
  Add Record #c[3];blockinplst.
 Try Search > #c[3],1;keyvar$,blockinplst.seq,blockinplst.listseq Else Exit Do
 Loop
 !copy but rcds
 seq=-2
 Try Search >= #c[4],1;keyvar$ Else Rem
 Do
  Try Read Record #c[2],seq;blockbut. Else Exit Do
  if blockbut.id$<>rtrim$(keyvar$) exit do
  blockbut.id$=newver$
  Add Record #c[2];blockbut.
 Try Search > #c[2],1;keyvar$,blockbut.seq Else Exit Do
 Loop

   tmp$="Block Id ",newver$," added!"
   call dxset("msg",tmp$)
  !
 blockid$=blockhdr.ID$
 call dxset("u_blockid",blockid$)
 call blockhdrchg() !redisplay updated page
 else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !blockhdrcopy
!
sub collist()
!--------------------------------------------------------------------
! column list routine
 try
 !
  cnt=0
  keyno$="1"
  call dxget("keynext",keynext$)
  keys$=blockid$
  if keynext$<>"" let keys$=blockid$,keynext$
  keyno=keyno$
  seq=-2
  Try Search >= #c[1],keyno;keys$ Else Rem
  Do
  Try Read Record #c[1],seq;blockcol. Else Exit Do
   if blockcol.id$<>rtrim$(blockid$) exit do
   if cnt>maxcnt exit do
   idlist$[cnt]=str$(blockcol.seq)
   !if inpseq defined, use it as defaults/override
   defaultlist$[cnt]=" " !flag indicates if defaulting to an input seq
   if blockcol.inpseq
    Try
     Search = #c[2],1;blockid$,blockcol.inpseq
     Read Record #c[2],-2;blockinp.
	 !override the column definitions with the input definitions
	 blockcol.label$=blockinp.label$
	 blockcol.active$=blockinp.active$
	 blockcol.varname$=blockinp.varname$
	 blockcol.mask$=blockinp.mask$
	 defaultlist$[cnt]=str$(blockcol.inpseq)
    Else
     !shouldn't happen,but ignore if it does
    End Try
   end if
   !
   desclist$[cnt]=blockcol.label$
   if desclist$[cnt]="" let desclist$[cnt]=" "
   if blockcol.active$="Y" let actlist$[cnt]="Active" else let actlist$[cnt]=" "
   varnamelist$[cnt]=blockcol.varname$
   if varnamelist$[cnt]="" let varnamelist$[cnt]=" "
   typelist$[cnt]=blockcol.mask$ !mask
   if typelist$[cnt]="" let typelist$[cnt]=" "
   cnt=cnt+1
   seq=-1 !get next
  Loop
  !
  if cnt>maxcnt
   let tmp$=blockcol.seq
   call dxset("keynext",tmp$)
  end if
  if cnt
   idlist$[cnt]=""
   desclist$[cnt]=""
   actlist$[cnt]=""
   typelist$[cnt]=""
   varnamelist$[cnt]=""
   defaultlist$[cnt]=""
   call dxset("colseq",idlist$[])
   call dxset("collabel",desclist$[])
   call dxset("colactive",actlist$[])
   call dxset("coltype",typelist$[])  !mask
   call dxset("colvarname",varnamelist$[])
   call dxset("coldefault",defaultlist$[])
  end if
  !
 else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !collist
!
sub inplist()
!--------------------------------------------------------------------
! input list routine
 try
 !
  cnt=0 
  keyno$="1"
  keynext=0
  call dxget("keynext",keynext$)
  if keynext$<>"" let keynext=keynext$
  keyno=keyno$
  seq=-2
  Try Search >= #c[2],keyno;blockid$,keynext Else Rem
  Do
  Try Read Record #c[2],seq;blockinp. Else Exit Do
   if blockinp.id$<>rtrim$(blockid$) exit do
   if cnt>maxcnt exit do
   idlist$[cnt]=str$(blockinp.seq)
    if blockinp.active$="Y" let actlist$[cnt]="Active" else let actlist$[cnt]=" "

   if blockinp.masterseq !refers to common prompt,read its record
    oldblockinp.=blockinp.
    tmp$="        " !master blockid
	Try Search = #c[5],1;tmp$,blockinp.masterseq Else Rem
	Try Read Record #c[5],-2;blockinp. Else Rem
	!label,variable,shorthelp,default can be overridden at block inp level
	if oldblockinp.label$<>"" let blockinp.label$=oldblockinp.label$
	if oldblockinp.varname$<>"" let blockinp.varname$=oldblockinp.varname$
	if oldblockinp.helppage$<>"" let blockinp.helppage$=oldblockinp.helppage$
	if oldblockinp.default$<>"" let blockinp.default$=oldblockinp.default$
   end if
   !
   call loadinpcolumns()
   !
    
   cnt=cnt+1
   seq=-1 !get next
  Loop
  !
 if cnt>maxcnt
   let tmp$=blockinp.seq
   call dxset("keynext",tmp$)
  end if
  if cnt
   idlist$[cnt]=""
   desclist$[cnt]=""
   actlist$[cnt]=""
   typelist$[cnt]=""
   varnamelist$[cnt]=""
   ruleslist$[cnt]=""
   call dxset("inpseq",idlist$[])
   call dxset("inplabel",desclist$[])
   call dxset("inpactive",actlist$[])
   call dxset("inptype",typelist$[])
   call dxset("inpvarname",varnamelist$[])
   call dxset("inprules",ruleslist$[])
  end if
  !
else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !inplist
!
sub droplistlist()
!--------------------------------------------------------------------
! droplist list routine (for a particular inp seq)
 try
 !
  cnt=0 
  keyno$="1"
  keynext=0
  call dxget("keynext",keynext$)
  if keynext$<>"" let keynext=keynext$
  keyno=keyno$
  seq=-2
  Try Search >= #c[3],keyno;blockid$,blockinp.seq,keynext Else Rem
  Do
  Try Read Record #c[3],seq;blockinplst. Else Exit Do
   if blockinplst.id$<>rtrim$(blockid$) or blockinplst.seq<>blockinp.seq exit do
   if cnt>maxcnt exit do
   idlist$[cnt]=str$(blockinplst.listseq)
   desclist$[cnt]=blockinplst.label$
   !valuelist$[cnt]=blockinplst.value$
   if blockinplst.active$="Y" let actlist$[cnt]="Active" else let actlist$[cnt]=" "
   cnt=cnt+1
   seq=-1 !get next
  Loop
  !
 if cnt>maxcnt
   let tmp$=blockinplst.listseq
   call dxset("keynext",tmp$)
  end if
  if cnt
   idlist$[cnt]=""
   desclist$[cnt]=""
   !valuelist$[cnt]=""
   actlist$[cnt]=""
   call dxset("listseq",idlist$[])
   call dxset("listlabel",desclist$[])
   !call dxset("listvalue",valuelist$[])
   call dxset("listactive",actlist$[])
  end if
  !
else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !droplistlist
!
sub butlist()
!--------------------------------------------------------------------
! button list routine
 try
 !
  cnt=0 
  keyno$="1"
  call dxget("keynext",keynext$)
  keys$=blockid$
  if keynext$<>"" let keys$=blockid$,keynext$
  keyno=keyno$
  seq=-2
  Try Search >= #c[4],keyno;keys$ Else Rem
  Do
  Try Read Record #c[4],seq;blockbut. Else Exit Do
   if blockbut.id$<>blockid$ exit do
   if cnt>maxcnt exit do
   idlist$[cnt]=str$(blockbut.seq)
   desclist$[cnt]=blockbut.label$
   if blockbut.active$="Y" let actlist$[cnt]="Active" else let actlist$[cnt]=" "
   cnt=cnt+1
   seq=-1 !get next
  Loop
  !
 if cnt>maxcnt
   let tmp$=blockcol.seq
   call dxset("keynext",tmp$)
  end if
 if cnt
  idlist$[cnt]=""
  desclist$[cnt]=""
  actlist$[cnt]=""
  call dxset("butseq",idlist$[])
  call dxset("butlabel",desclist$[])
  call dxset("butactive",actlist$[])
 end if
  !
else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !butlist
!
sub droplistinp()
!--------------------------------------------------------------------
! create drop list of all the input definitions routine
! used by col definition to default to an input definition
 try
 !
  cnt=0 
  keyno$="1"
  keyno=keyno$
  seq=-2
  Try Search >= #c[2],keyno;blockid$ Else Rem
  Do
  Try Read Record #c[2],seq;blockinp. Else Exit Do
   if blockinp.id$<>rtrim$(blockid$) exit do
   if cnt>maxcnt exit do  !will only show 1st 100 fields
   idlist$[cnt]=str$(blockinp.seq)
   desclist$[cnt]=blockinp.label$
   if blockinp.active$<>"Y" let desclist$[cnt]=desclist$[cnt]," (Inactive)"
   cnt=cnt+1
   seq=-1 !get next
  Loop
  !
 if cnt
  idlist$[cnt]=""
  desclist$[cnt]=""
  call dxset("inpseqs",idlist$[])
  call dxset("inplabels",desclist$[])
 end if
  !
else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !droplistinp
!
sub blockcoladd()
!--------------------------------------------------------------------
! add col routine,assign default seq# 
 try
 !
  keyvar$=blockid$
  Try
    Search = #c[0],1;keyvar$
  Else
    e$="Block ID ",keyvar$," is not on file!"
    error 10000
  End Try
  !
  Read Record #c[0],-2;blockhdr.
   blockseq=7999
   try 
    search <= #c[1],1;blockid$,blockseq 
    read record #c[1],-2;blockcol.
    if blockcol.id$<>rtrim$(blockid$) error 10000
   else 
    let blockcol.seq=0
   End try
   keyvar=blockcol.seq+10
   if keyvar>0 and keyvar<=7999
    keyvar$=str$(keyvar)
   else
   e$="Could not generate next column #!"
    error 10000
   end if
  !
  call dxset("blockseq",keyvar$)
  call droplistinp() !create drop list of input field definitions can default to
  call droplistvarnames()
  call dxset("output",mergedir$+"dxblockcol.html")
 else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !blockcoladd
!
sub blockcolchg()
!--------------------------------------------------------------------
! change col routine, get/display record
!
try
  keyvar$=blockid$
  Try
    Search = #c[0],1;keyvar$
  Else
    e$="Block ID ",keyvar$," is not on file!"
    error 10000
  End Try
  !
  Read Record #c[0],-2;blockhdr.
 call dxget("blockseq",blockseq$)
 blockseq=blockseq$
  Try
   Search = #c[1],1;blockid$,blockseq
  Else
   e$="Block ID ",blockid$,", column# ",blockseq$," is not on file!"
    error 10000
  End Try
  !
 Read Record #c[1],-2;blockcol.
  !
  call dxset("keyvar",str$(blockcol.seq))
  call dxset("blockseq",str$(blockcol.seq))
  call dxset("blockinpseq",str$(blockcol.inpseq))
  call dxset("blocklabel",blockcol.label$)
  call dxset("blockvarname",blockcol.varname$)
  If blockcol.active$="Y" call dxset("blockactivey","selected") else call dxset("blockactiven","selected")
  call dxset("blocklink",blockcol.link$)
  call dxset("blockstyle",blockcol.style$)
  call dxset("blockwidth",blockcol.width$)
  call dxset("blockdbfieldname",blockcol.dbfieldname$)
  call dxset("blockdbposition",str$(blockcol.dbposition))
  call dxset("blockdbprecision",str$(blockcol.dbprecision))
  call dxset("blockdbtype",blockcol.dbtype$)
  !for numeric types
  call dxset("blockmask",blockcol.mask$)
  !
  call droplistinp() !create drop list of input field definitions can default to
  call droplistvarnames()
  call dxset("output",mergedir$+"dxblockcol.html")
 else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !blockcolchg
!
sub blockcoldel()
!--------------------------------------------------------------------
! delete col routine, delete col
 try
 !
call dxget("blockseq",blockseq$)
blockseq=blockseq$
 try
 Search = #c[1],1;blockid$,blockseq
 Else
 e$="Block ID ",blockid$,", column # ",blockseq$," is not on file!"
  error 10000
 End Try
  Delete Record #c[1]
  tmp$="Block ID ",blockid$," column # ",blockseq$," deleted!"
  call dxset("msg",tmp$)
  call blockhdrchg()
 else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !blockcoldel
!
sub blockcolsave()
!--------------------------------------------------------------------
! save col routine
 try
 !
 call dxget("keyvar",keyvar$)
  blockcol.id$=blockid$
  call dxget("blockseq",blockseq$)
  blockcol.seq=blockseq$
  call dxget("blockinpseq",tmp$) \ blockcol.inpseq =tmp$ !use this input seq# for defaults
  call dxget("blocklabel",blockcol.label$)
  call dxget("blockvarname",blockcol.varname$)
  call dxget("blockactive",blockcol.active$)
  call dxget("blocklink",blockcol.link$)
  call dxget("blockstyle",blockcol.style$)
  call dxget("blockwidth",blockcol.width$)
  call dxget("blockdbfieldname",blockcol.dbfieldname$)
  !??position,precision
  call dxget("blockdbtype",blockcol.dbtype$)
  !for numeric types
  call dxget("blockmask",blockcol.mask$) 
  !
 if keyvar$=""  !it's an add
   Try
   Add Record #c[1];blockcol.
   Else
   e$="Could not add new record, try again!"
    error 10000
   end try
   tmp$="Block ID ",blockid$," column # ",blockseq$," added!"
   call dxset("msg",tmp$)
  else
  try
  blockseq=keyvar$
   search = #c[1],1;blockid$,blockseq
    read record #c[1],-2;oldblockcol.
    !compate crc's
    !??
   write record #c[1],-2;blockcol.;
   else
   
   e$="Could not update record, try again!"
    error 10000
   end try
   tmp$="Block ID ",blockid$," column # ",blockseq$," is updated!"
   call dxset("msg",tmp$)
  end if
  !
 call blockhdrchg() !redisplay updated page
 else
  if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !blockcolsave
!
sub blockinpadd()
!--------------------------------------------------------------------
! add inp routine,assign default seq#
 try
 !
   if blockid$="" let blockid$="        "\call dxset("u_blockid",blockid$)
   keyvar$=blockid$
   Try
    Search = #c[0],1;keyvar$
   Else
    e$="Block ID ",keyvar$," is not on file!"
    error 10000
   End Try
   !
   Read Record #c[0],-2;blockhdr.
   blockseq=7999
   try
    search <= #c[2],1;blockid$,blockseq
    read record #c[2],-2;blockinp.
    if blockinp.id$<>rtrim$(blockid$) error 10000
   else
    let blockinp.seq=0
   End try
   keyvar=blockinp.seq+10
   if keyvar>0 and keyvar<=7999
    keyvar$=str$(keyvar)
   else
  e$="Could not generate next input #!"
    error 10000
   end if
  !
 call dxset("blockseq",keyvar$)
 !defaults
 call dxset("blocktype","TEXT")
 call dxset("blockactivey","selected")
 call dxset("blockrequiredn","selected")
 call dxset("blockdisabledn","selected")
 call dxset("blocktabn","selected")
 call dxset("blockfocusn","selected")
 call droplistvarnames()
 if blockid$<>"        " if blockhdr.filename$="" call droplistmasternames()
 call dxset("blockmasterseq","0")
 call droplistfilenames()
 call dxset("output",mergedir$+"dxblockinp.html")
else
if spc(8)<>10000
  call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
  !call programdump("")
 end if
 error 10000
end try
End sub !blockinpadd
!
Sub blockinpchg()
!--------------------------------------------------------------------
! change inp routine, get/display record
Try
  if blockid$="" let blockid$="        "\call dxset("u_blockid",blockid$)
  keyvar$=blockid$
  Try
    Search = #c[0],1;keyvar$
  Else
    e$="Block ID ",keyvar$," is not on file!"
    error 10000
  End Try
  !
  Read Record #c[0],-2;blockhdr.
call dxget("blockseq",blockseq$)
blockseq=blockseq$
 Try
  Search = #c[2],1;blockid$,blockseq
 Else
  e$="Block ID ",blockid$,", input # ",blockseq$," is not on file!"
    error 10000
  End Try
  !
Read Record #c[2],-2;blockinp.
  !
call dxset("keyvar",str$(blockinp.seq))
  call dxset("blockseq",str$(blockinp.seq))
  call dxset("blocklabel",blockinp.label$)
  call dxset("blockvarname",blockinp.varname$)
  call dxset("blockdefault",blockinp.default$)
  call dxset("blocktype",blockinp.type$)
  if blockinp.active$="Y" call dxset("blockActiveY","selected") else call dxset("blockActiveN","selected")
  if blockinp.required$="Y" call dxset("blockRequiredY","selected") else call dxset("blockRequiredN","selected")
  if blockinp.disabled$="Y" call dxset("blockDisabledY","selected") else call dxset("blockDisabledN","selected")
  if blockinp.notab$="Y" call dxset("blockTabY","selected") else call dxset("blockTabN","selected")
  if blockinp.focus$="Y" call dxset("blockFocusY","selected") else call dxset("blockFocusN","selected")
  call dxset("blockshorthelp",blockinp.helppage$)
  call dxset("blocklookup",blockinp.lookuplink$)
  call dxset("blockuserdef1",blockinp.userdef1$)
  call dxset("blockuserdef2",blockinp.userdef2$)
  call dxset("blockuserdef3",blockinp.userdef3$)
  call dxset("blockuserdef4",blockinp.userdef4$)
  call dxset("blockuserdef5",blockinp.userdef5$)
  call dxset("blockmasterdesc",blockinp.masterdesc$) !will only be on common prompts block
  call dxset("blockmasterseq",str$(blockinp.masterseq))
  !for text types and numeric types
  call dxset("blockminlength",str$(blockinp.minlength))
  call dxset("blockmaxlength",str$(blockinp.maxlength))
  !for numeric types
  call dxset("blockmask",blockinp.mask$)
  !for check types
  tmp$=blockinp.checkvalue$,"                    "
  call dxset("blockcheckvalue",rtrim$(tmp$[1,10]))
  call dxset("blockcheckvaluen",rtrim$(tmp$[11]))
  if blockinp.type$="CHECK" 
   call dxset("blockcheckdefault",blockinp.default$)
   call dxset("blockdefault","")
  end if
  !for list types
  call dxset("blockmaxselected",str$(blockinp.maxselected))
  !for list:text types
  call dxset("blockmaxlisted",str$(blockinp.maxlisted))
  !for list and list:text types
  call dxset("blocklistfilename",blockinp.listfilename$)
  !
  call dxset("blockconditions",blockinp.conditions$)
  !
  if blockinp.type$="LIST" or blockinp.type$="RADIO" !show droplist definitions
   call droplistlist()
  end if
  !
  call droplistvarnames()
  if blockid$<>"        " if blockhdr.filename$="" call droplistmasternames()
  call droplistfilenames()
  !
  !see if there is a help text file for this seq, if so read it and dxset
  call getglobals("dfsystem",7,tmp$) !helpdir$
  helpname$=tmp$,"block",blockid$,"_",str$(blockseq),".hlp"
  helpchan=findchannel()
  try
   ropen #helpchan,helpname$
   do
            Read#helpchan;tmp$
            if NOT(tmp$) exit do
            helpstr$ = helpstr$,tmp$
   loop
   call dxset("blocklonghelp",helpstr$)
  else
  end try
  !
  call dxset("output",mergedir$+"dxblockinp.html")
 else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !blockinpchg
!
sub blockinpdel()
!--------------------------------------------------------------------
! delete inp routine, delete inp
 try
 !
   if blockid$="" let blockid$="        "\call dxset("u_blockid",blockid$)
call dxget("blockseq",blockseq$)
blockseq=blockseq$
 try
  Search = #c[2],1;blockid$,blockseq
 Else
  e$="Block ID ",blockid$,", input # ",blockseq$," is not on file!"
  error 10000
 End Try
 !col file, check to make sure no col file records pointing to this inpseq as default
   keyvar$=blockid$
   seq=-2
   Try Search >= #c[1],1;keyvar$ Else Rem
  Do
   Try Read Record #c[1],seq;blockcol. Else Exit Do
   if blockcol.id$<>rtrim$(keyvar$) exit do
   if blockcol.inpseq = blockseq 
    e$="Block ID ",blockid$,", input # ",blockseq$," can not be deleted, referenced by Column Definition #",str$(blockcol.seq)
	error 10000
   end if
   seq=-1
  Loop
  !if common prompt, check to make sure no inp file records pointing to this inpseq as default
  if blockid$="        "
   keyvar$="       !"
   seq=-2
   Try Search >= #c[5],1;keyvar$ Else Rem
  Do
   Try Read Record #c[5],seq;blockinp. Else Exit Do
   if blockinp.masterseq = blockseq 
    e$="Common prompt input # ",blockseq$," can not be deleted, referenced by Block ID ",blockinp.id$," Input Definition #",str$(blockinp.seq)
	error 10000
   end if
   seq=-1
  Loop
  end if !common
  !inplst file - delete if there first
   seq=-2
   Try Search >= #c[3],1;blockid$,blockseq Else Rem
  Do
   Try Read Record #c[3],seq;blockinplst. Else Exit Do
   if blockinplst.id$<>rtrim$(blockid$) or blockinplst.seq<>blockseq exit do
   Delete Record #c[3]
   seq=-1
  Loop
  Delete Record #c[2]
  !
  !delete long help text file if there
  call getglobals("dfsystem",7,tmp$) !helpdir$
  helpname$=tmp$,"block",blockid$,"_",str$(blockinp.seq),".hlp"
  try kill helpname$ else rem
  !
  tmp$="Block ID ",blockid$," input # ",blockseq$," deleted!"
  call dxset("msg",tmp$)
 call blockhdrchg()
 else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
end try
End sub !blockinpdel
!
Sub blockinpsave()
!--------------------------------------------------------------------
! save inp routine
try
   if blockid$="" let blockid$="        "\call dxset("u_blockid",blockid$)

!
call dxget("keyvar",keyvar$)
 call dxget("blockseq",blockseq$)
 blockseq=blockseq$
 call dxget("blockactive",blockinp.active$)
 !
 !if common prompt, check to make sure no inp file records pointing to this inpseq as default
 if keyvar$<>"" if blockid$="        " if blockinp.active$<>"Y"
   keyvar$="       !"
   seq=-2
   Try Search >= #c[5],1;keyvar$ Else Rem
  Do
   Try Read Record #c[5],seq;blockinp. Else Exit Do
   if blockinp.masterseq = blockseq 
    e$="Common prompt input # ",blockseq$," can not be inactivated, referenced by Block ID ",blockinp.id$," Input Definition #",str$(blockinp.seq)
	error 10000
   end if
   seq=-1
  Loop
  end if !common
 !
 call dxget("keyvar",keyvar$)
 blockinp.id$=blockid$
 blockinp.seq=blockseq$
 call dxget("blocklabel",blockinp.label$)
 call dxget("blockvarname",blockinp.varname$)
 call dxget("blockdefault",blockinp.default$)
 call dxget("blocktype",blockinp.type$)
 call dxget("blockactive",blockinp.active$)
 call dxget("blockrequired",blockinp.required$)
 call dxget("blockdisabled",blockinp.disabled$)
 call dxget("blocknotab",blockinp.notab$)
 call dxget("blockfocus",blockinp.focus$)
 call dxget("blockshorthelp",blockinp.helppage$)
 call dxget("blocklookup",blockinp.lookuplink$)
 call dxget("blockuserdef1",blockinp.userdef1$)
 call dxget("blockuserdef2",blockinp.userdef2$)
 call dxget("blockuserdef3",blockinp.userdef3$)
 call dxget("blockuserdef4",blockinp.userdef4$)
 call dxget("blockuserdef5",blockinp.userdef5$)
 call dxget("blockmasterdesc",blockinp.masterdesc$)
 call dxget("blockmasterseq",tmp$) \ blockinp.masterseq =tmp$
 !for text types and numeric types
  call dxget("blockminlength",tmp$) \ blockinp.minlength =tmp$
  call dxget("blockmaxlength",tmp$) \ blockinp.maxlength =tmp$
  if blockinp.type$="TEXT"
   call dxget("blockmintextlength",tmp$) \ blockinp.minlength=tmp$
   call dxget("blockmaxtextlength",tmp$) \ blockinp.maxlength=tmp$
  end if
  !for numeric types
  call dxget("blockmask",blockinp.mask$) 
  !for check types
  call dxget("blockcheckvalue",blockinp.checkvalue$) !field actually holds check on value 1,10, off value 11,20
  call dxget("blockcheckvaluen",tmp$)
  blockinp.checkvalue$=blockinp.checkvalue$,"          "
  blockinp.checkvalue$=blockinp.checkvalue$[1,10],tmp$,"          "
  if blockinp.type$="CHECK" 
   call dxget("blockcheckdefault",blockinp.default$)
  end if
  !for list types
  call dxget("blockmaxselected",tmp$) \ blockinp.maxselected =tmp$
  if blockinp.maxselected = 0 let blockinp.maxselected = 1
  !for list:text types
  call dxget("blockmaxlisted",tmp$) \ blockinp.maxlisted =tmp$
  !for list and list:text types
  call dxget("blocklistfilename",blockinp.listfilename$)
  call dxget("blocklistfilename2",tmp$)
  if tmp$<>"" let blockinp.listfilename$=tmp$   !typed in override filename (libfilehandler.lib is hardcoded to look for this filename and call appropriate libfile*z.lib routine)
  !
  call dxget("blockconditions",blockinp.conditions$)
if keyvar$=""  !it's an add
  Try
  Add Record #c[2];blockinp.
  Else
  e$="Could not add new record, try again!"
    error 10000
   end try
   tmp$="Block ID ",blockid$," input # ",blockseq$," added!"
   call dxset("msg",tmp$)
  else
  try
 blockseq=keyvar$
  search = #c[2],1;blockid$,blockseq
    read record #c[2],-2;oldblockinp.
    !compate crc's
    !??
  write record #c[2],-2;blockinp.;
  !
  if oldblockinp.seq<>blockinp.seq !may need to change seq in inplst table also
  !inplst file - delete if there first
  Do
   seq=-2
   Try Search >= #c[3],1;blockid$,blockseq Else Rem
   Try Read Record #c[3],seq;blockinplst. Else Exit Do
   if blockinplst.id$<>rtrim$(blockid$) or blockinplst.seq<>blockseq exit do
   blockinplst.seq=blockinp.seq
   write record #c[3],-2;blockinplst.;
  Loop
  end if !inplst
   else
  e$="Could not update record, try again!"
    error 10000
   end try
   tmp$="Block ID ",blockid$," input # ",blockseq$," is updated!"
   call dxset("msg",tmp$)
  end if !add/chg
  !
  !long help text file
  call dxget("blocklonghelp",helpstr$)
  helpstr$ = Trim$(helpstr$)
  helpstr$ = replace$(helpstr$,"\12\","")
  call getglobals("dfsystem",7,tmp$) !helpdir$
  helpname$=tmp$,"block",blockid$,"_",str$(blockinp.seq),".hlp"
  if helpstr$=""
   !delete long help text file if there
   try kill helpname$ else rem
  else
   !create/rewrite help file
   helpchan=findchannel()
   try
    open #helpchan,helpname$
   else
    !build helpdir if not there
	try
	 x=builddir(tmp$)
	 !build help file
	  build #helpchan,helpname$ as "text"
	else
	 e$="Problem building help text file, ",helpname$,"!"
	 error 10000
	end try
   end try
   write #helpchan;helpstr$;
   close #helpchan
  end if !helpstr$
  !
call blockhdrchg() !redisplay updated page
 else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !blockinpsave
!
sub blockinplstadd()
!--------------------------------------------------------------------
! add inp routine,assign default seq#
 try
 !
    if blockid$="" let blockid$="        "\call dxset("u_blockid",blockid$)
   call dxget("u_blockseq",blockseq$)
   blockseq=blockseq$
   blocklistseq=7999
   try
    search <= #c[3],1;blockid$,blockseq,blocklistseq
    read record #c[3],-2;blockinplst.
    if blockinplst.id$<>rtrim$(blockid$) or blockinplst.seq<>blockseq error 10000
   else
    let blockinplst.listseq=0
   End try
   keyvar=blockinplst.listseq+10
   if keyvar>0 and keyvar<=7999
    keyvar$=str$(keyvar)
   else
  e$="Could not generate next input #!"
    error 10000
   end if
  !
 call dxset("blocklistseq",keyvar$)
 !defaults
 call dxset("blockactivey","selected")
 
 call dxset("output",mergedir$+"dxblockinplst.html")
else
if spc(8)<>10000
  call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
  !call programdump("")
 end if
 error 10000
end try
End sub !blockinplstadd
!
Sub blockinplstchg()
!--------------------------------------------------------------------
! change inp droplist routine, get/display record
 Try
    if blockid$="" let blockid$="        "\call dxset("u_blockid",blockid$)
  call dxget("u_blockseq",blockseq$)
  blockseq=blockseq$
  call dxget("blocklistseq",blocklistseq$)
  blocklistseq=blocklistseq$
  Try
   Search = #c[3],1;blockid$,blockseq,blocklistseq
  Else
   e$="Block ID ",blockid$,", input # ",blockseq$," droplist # ",blocklistseq$," is not on file!"
   error 10000
  End Try
  !
  Read Record #c[3],-2;blockinplst.
  !
  call dxset("keyvar",str$(blockinplst.listseq))
  call dxset("blocklistseq",str$(blockinplst.listseq))
  call dxset("blocklabel",blockinplst.label$)
  call dxset("blockvalue",blockinplst.value$)
  if blockinplst.active$="Y" call dxset("blockActiveY","selected") else call dxset("blockActiveN","selected")
  !
  call dxset("output",mergedir$+"dxblockinplst.html")
 else
  if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !blockinplstchg
!
sub blockinplstdel()
!--------------------------------------------------------------------
! delete inp routine, delete inp
 try
 !
    if blockid$="" let blockid$="        "\call dxset("u_blockid",blockid$)
 call dxget("u_blockseq",blockseq$)
 blockseq=blockseq$
 call dxset(0,"blockseq",blockseq$)
 call dxget("blocklistseq",blocklistseq$)
 blocklistseq=blocklistseq$
 try
 Search = #c[3],1;blockid$,blockseq,blocklistseq
 Else
 e$="Block ID ",blockid$,", input # ",blockseq$," droplist # ",blocklistseq$," is not on file!"
  error 10000
 End Try
  Delete Record #c[3]
  tmp$="Block ID ",blockid$," input # ",blockseq$," droplist # ",blocklistseq$," deleted!"
  call dxset("msg",tmp$)
 call blockinpchg()
 else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
end try
End sub !blockinplstdel
!
Sub blockinplstsave()
!--------------------------------------------------------------------
! save inp routine
try
!
   if blockid$="" let blockid$="        "\call dxset("u_blockid",blockid$)

 call dxget("u_blockseq",blockseq$)
 blockseq=blockseq$
 call dxset(0,"blockseq",blockseq$)
 call dxget("blocklistseq",blocklistseq$)
 blocklistseq=blocklistseq$
 call dxget("keyvar",keyvar$)
 blockinplst.id$=blockid$
 blockinplst.seq=blockseq
 blockinplst.listseq=blocklistseq$
 call dxget("blocklabel",blockinplst.label$)
 call dxget("blockvalue",blockinplst.value$)
 call dxget("blockactive",blockinplst.active$)
 !
if keyvar$=""  !it's an add
  Try
  Add Record #c[3];blockinplst.
  Else
  e$="Could not add new record, try again!"
    error 10000
   end try
   tmp$="Block ID ",blockid$," input # ",blockseq$," droplist # ",blocklistseq$," added!"
   call dxset("msg",tmp$)
  else
   try
    blocklistseq=keyvar$
    search = #c[3],1;blockid$,blockseq,blocklistseq
    read record #c[3],-2;oldblockinplst.
    !compate crc's
    !??
    write record #c[3],-2;blockinplst.;
   else
    e$="Could not update record, try again!"
    error 10000
   end try
   tmp$="Block ID ",blockid$," input # ",blockseq$," droplist # ",blocklistseq$, " is updated!"
   call dxset("msg",tmp$)
  end if
  !
  call blockinpchg() !redisplay updated page
 else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !blockinplstsave
!
sub blockbutadd()
!--------------------------------------------------------------------
! add button routine,assign default seq#
 try
 !
  blockseq=7999
   try
   search <= #c[4],1;blockid$,blockseq
    read record #c[4],-2;blockbut.
    if blockbut.id$<>blockid$ error 10000
   else
   let blockbut.seq=0
   End try
   keyvar=blockcol.seq+10
   if keyvar>0 and keyvar<=7999
    keyvar$=str$(keyvar)
   else
  e$="Could not generate next button #!"
    error 10000
   end if
  !
call dxset("blockseq",keyvar$)
  call dxset("output",mergedir$+"dxblockbut.html")
 else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !blockbutadd
!
sub blockbutchg()
!--------------------------------------------------------------------
! change but routine, get/display record
!
try
call dxget("blockseq",blockseq$)
 blockseq=blockseq$
  Try
  Search = #c[4],1;blockid$,blockseq
  Else
  e$="Block ID ",blockid$,", button # ",blockseq$," is not on file!"
    error 10000
  End Try
  !
Read Record #c[4],-2;blockbut.
  !
call dxset("keyvar",str$(blockbut.seq))
  call dxset("blockseq",str$(blockbut.seq))
  call dxset("blocklabel",blockbut.label$)
  call dxset("blocklink",blockbut.link$)
  call dxset("output",mergedir$+"dxblockbut.html")
 else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !blockbutchg
!
sub blockbutdel()
!--------------------------------------------------------------------
! delete button routine, delete but
 try
 !
call dxget("blockseq",blockseq$)
blockseq=blockseq$
 try
 Search = #c[4],1;blockid$,blockseq
 Else
 e$="Block ID ",blockid$,", button # ",blockseq$," is not on file!"
  error 10000
 End Try
  Delete Record #c[4]
  tmp$="Block ID ",blockid$," button # ",blockseq$," deleted!"
  call dxset("msg",tmp$)
 call blockhdrchg()
 else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !blockbutdel
!
sub blockbutsave()
!--------------------------------------------------------------------
! save button routine
 try
 !
call dxget("keyvar",keyvar$)
  blockbut.id$=blockid$
  call dxget("blockseq",blockseq$)
  blockbut.seq=blockseq$
  call dxget("blocklabel",blockbut.label$)
  call dxget("blocklink",blockbut.link$)
  !
if keyvar$=""  !it's an add
   Try
  Add Record #c[4];blockbut.
   Else
  e$="Could not add new record, try again!"
    error 10000
   end try
   tmp$="Block ID ",blockid$," button # ",blockseq$," added!"
   call dxset("msg",tmp$)
  else
  try
 blockseq=keyvar$
  search = #c[4],1;blockid$,blockseq
    read record #c[4],-2;oldblockbut.
    !compate crc's
    !??
  write record #c[4],-2;blockbut.;
   else
  e$="Could not update record, try again!"
    error 10000
   end try
   tmp$="Block ID ",blockid$," button # ",blockseq$," is updated!"
   call dxset("msg",tmp$)
  end if
  !
call blockhdrchg() !redisplay updated page
 else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !blockbutsave
!
!
! **main procedure
!
!
! dim variables used by program
!
dim e$[500],buttonlist$[5,50],nextlist$[5,100] !error handling variables
try
 call dxopen() 
 ! call dxsave(0,"/x1/xslspro/dx.in!")
 !
 !e$="got here"\error 10000
 !
 maxcnt=100
 dim mergedir$[60],action$[30],options$[30],b$[200],1%,c[20],z0[31],3%
 dim type$[30]
 dim keys$[120],keyvar$[120],keynext$[120],keyno$[1],tmp$[120]
 dim idlist$[maxcnt,8],desclist$[maxcnt,668],titlelist$[maxcnt,60],actlist$[maxcnt,6],filenamelist$[maxcnt,20]
 dim defaultlist$[maxcnt,4],seqlist$[maxcnt,5]
 dim typelist$[maxcnt,50],varnamelist$[maxcnt,40],ruleslist$[maxcnt,32]
 dim blockid$[8],1%,blockseq$[4],blockseq,blocklistseq$[4],blocklistseq,3%
 dim newver$[8],filename$[20],ajax$[200]
 dim helpname$[80],helpstr$[5000]
 b$=" ",b$
 !
 Dim blockconfig. as blockconfig
 ! need to get filenames from dxsystem.txt
 !
 !read system file parameters
 Call blockReadSystemFile(e$,blockconfig.)
 !
 ! open files
 !
 Call blockopenfiles(e$,blockconfig.,c[])
 !
 ! linked to df File Defs
   Dim 1%,dfc[20],3%
   Dim config. as config
   ! need to get filenames from dxsystem.txt
   !
   !read dfsystem file parameters
   Call ReadSystemFile(e$,config.)
   !
   ! open dffiles
   !
   Call openfiles(e$,config.,dfc[])
 ! end df File Defs
 !
 mergedir$="admin/"
 call dxget("action",action$)
 action$ = lcase$(action$)
 call dxget("type",type$)
 type$ = lcase$(type$)
 call dxget("u_blockid",blockid$)
 !
 if action$="input"   !initial action
   call blocksearch() 
 else if action$="search"
   call blocksearch()
 else if action$="add"
   if type$="hdr" call blockhdradd()
   if type$="col" call blockcoladd()
   if type$="inp" call blockinpadd()
   if type$="inplst" call blockinplstadd()
 else if action$="change" or action$="edit"
   if type$="hdr" call blockhdrchg()
   if type$="col" call blockcolchg()
   if type$="inp" call blockinpchg()
   if type$="inplst" call blockinplstchg()
 else if action$="delete"
   if type$="hdr" call blockhdrdel()
   if type$="col" call blockcoldel()
   if type$="inp" call blockinpdel()
   if type$="inplst" call blockinplstdel()
 else if action$="save"
   if type$="hdr" call blockhdrsave()
   if type$="col" call blockcolsave()
   if type$="inp" call blockinpsave()
   if type$="inplst" call blockinplstsave()
 else if action$="copy"
   call blockhdrcopy()
 else if action$="print"
   call blockhdrchg()
 else if action$="getfield" !ajax
   call getfield()
 else if action$="commonlist"
   call commonlist()
 else if action$="getcommon"
   call getcommon()
 Else If action$ = "gencode"
    Chain "dxblockcreatemaint.dl4"
 else if action$="fixinplist"
   !!!call fixinplist()
 end if
 !
 call dxclose()
else
  ! error routine
  if spc(8)<>10000 
   call blocksuberr(e$,spc(8),spc(10),msc$(2))
   !call programdump("")
  end if
  call blockmainerr(e$,spc(8),buttonlist$[],nextlist$[])
end try
end
