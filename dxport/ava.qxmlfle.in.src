Rem AVA.QXMLFLE.IN
!
! loadsave -w -n 100,10 -o prog/dxport/ava.qxmlfle.in.dl4 src/ava.qxmlfle.in.src
!
Rem  Copyright (c) 2016 Universal Business Systems, Inc.
Rem    **** ALL CHANGES MUST BE MADE IN SOURCE!!! ****
Rem
!
include "src/copyright.inc" ! dx
!
External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus
!
Declare Intrinsic Sub FindF,InpBuf,String
Declare Intrinsic Function FindChannel
! Option Default Dialect IRIS1
Rem AVA.XMLFLE.IN.src - Receive back tax calc file
Rem 53250
Rem file name passed in - generated by sending perl script/program that creates it
! We are only getting back an order summary file from Avalara because if we include the line
! details - the result could be truly gigantic! (their sample was 3 full pdf pages long for 3 lines)
! I would estimate each line on the order adds another 1000+ chars as each line also breaks down the
! jurisdiction amounts (and CA has 4 or 5 jurisdictions)
! ie: State rate, County Rate, a City rate and a couple different special rates
If Err 0 Gosub ERR_TRAP
Rem file for storing order & ava transid: 7/AVAQTETRANS#
Rem directory = OOOOOOTT-24-TT (ttl-30 char)
Enter ORDERNO,INXMLFLE$,Intco,rstr$
Rem {begin src/inc/dim.getchan.i}
Dim 1%,CHNL
Dim 3%,CHNLSCR,CHNLFREE
Rem {end dim.getchan.i}
Dim WRKLINE$[4000],TMPLINE$[4000],VAR$[10],WORK$[4000],TEMP$[4000]
Dim FLE$[30],RETVAL$[512],AVAACCTNO$[20],AVALCKEY$[16],DIRTO$[64]
Dim AVAOID$[20],S1$[118],S2$[20],A1$[142],A2$[30],A3$[22],L1$[20]
Dim S3$[33],K1$[64],K2$[64],K3$[64],K4$[64],XMLFLE$[80],TMPFLE$[30]
Dim X$[20],VARNM$[60],AVAPC$[10],LOGFNM$[40],SPACES$[200],TEXNO$[20]
Dim FAULTSTRING$[256],DocType$[60]
Dim 1%,X,X1[9],COID,CH_CNTRL,CH_CUST,CH_ROL,CH_ROS,CH_ROT,CH_ROL,CH_INFLE
Dim 1%,L3[3],S2[1],H4[2],TCB,CH_ROH,CH_TAX,POS0,POS1,POS2,POS3,CH_DTL
Dim 1%,CH_AVATRNS,TTLLNS,LDLN,LNNO,SCR,CREDIT,RTAX,FLEFND,CCHAN[10]
Dim 1%,FOUND,BADDATA,RCOMMIT,RCANCEL,RESPFAULT,BADORD,RLINE
Dim 2%,X2[9],H0[12],MCODE[9],L4[3],H6[8],H5[16],PMORDNO
Dim 3%,X3[9],SRN[5],T2[25],MCHARGE[9,1],L5[3],L7[12]
Dim 3%,ORDREC,R[99],TAXAMT,E,H
Dim e$[500],buttonlist$[5,50],nextlist$[5,100] ! dx error handling variables
Dim WebStr$[256],msg$[100],message$[300] ! ,RSTR$[500]
SPACES$ = " ",SPACES$;SCOMMIT = 0
If ORDERNO < 0 ! if <0 it's a commit
  ORDERNO = Abs(ORDERNO);SCOMMIT = 1
End If 
If ORDERNO <= 0 Goto OUTEND ! no order # sent
If INXMLFLE$ = "" Goto OUTEND ! no response file sent
returnstatus=1;message$="OK"
COID = Intco ! Int((Spc(5) - Int(Spc(5) / 16384) * 16384) / 64)
CH_CNTRL = 1
If Err 0 Let X2 = Spc(8)
X2 = 0
X3 = Chf(CH_CNTRL)
If Err 0 Gosub ERR_TRAP
If X2 ! cntrl not open
  Open #1,"cntrl/cntrl" + Str$(COID)
End If 
If CCHAN[1] <= 0 ! No cust
  CHNL = 97 \ Gosub GETCHAN
  If CHNL > 1 Let CCHAN[1] = CHNL
  Read #CH_CNTRL,88,1808;FLE$[1,16];
  Open #CCHAN[1],FLE$
  CCHAN[1] = 0 - CCHAN[1] ! "show we opened
End If 
CH_CUST = Abs(CCHAN[1])
If CCHAN[2] <= 0 ! no roh
  CHNL = 97 \ Gosub GETCHAN
  If CHNL > 1 Let CCHAN[2] = CHNL
  Read #CH_CNTRL,88,1280;FLE$[1,16];
  Open #CCHAN[2],FLE$
  CCHAN[2] = 0 - CCHAN[2] ! "show we opened
End If 
CH_ROH = Abs(CCHAN[2])
If CCHAN[3] <= 0 ! no ros
  CHNL = 97 \ Gosub GETCHAN
  If CHNL > 1 Let CCHAN[3] = CHNL
  Read #CH_CNTRL,88,1392;FLE$[1,16];
  Open #CCHAN[3],FLE$
  CCHAN[3] = 0 - CCHAN[3] ! "show we opened
End If 
CH_ROS = Abs(CCHAN[3])
If CCHAN[4] <= 0 ! no rot
  CHNL = 97 \ Gosub GETCHAN
  If CHNL > 1 Let CCHAN[4] = CHNL
  Read #CH_CNTRL,88,2656;FLE$[1,16];
  Open #CCHAN[4],FLE$
  CCHAN[4] = 0 - CCHAN[4] ! "show we opened
End If 
CH_ROT = Abs(CCHAN[4])
If CCHAN[5] <= 0 ! no rol
  CHNL = 97 \ Gosub GETCHAN
  If CHNL > 1 Let CCHAN[5] = CHNL
  Read #CH_CNTRL,88,1344;FLE$[1,16];
  Open #CCHAN[5],FLE$
  CCHAN[5] = 0 - CCHAN[5] ! "show we opened
End If 
CH_ROL = Abs(CCHAN[5])
If CCHAN[6] <= 0 ! no TAX
  CHNL = 97 \ Gosub GETCHAN
  If CHNL > 1 Let CCHAN[6] = CHNL
  Read #CH_CNTRL,88,2176;FLE$[1,16];
  Open #CCHAN[6],FLE$
  CCHAN[6] = 0 - CCHAN[6] ! "show we opened
End If 
CH_TAX = Abs(CCHAN[6])
CHNL = 97 \ Gosub GETCHAN
If Err 0 Gosub ERR_TRAP ! getchan changes to err_escape:?
If CHNL > 1 ! valid channel
  Call "progdflt","AVA","",CHNL,RETVAL$
  If RETVAL$[1,5] = "@@@@@" Let RETVAL$ = " ",RETVAL$
  AVAACCTNO$ = RETVAL$[1,20] ! "customer id
  AVALCKEY$ = RETVAL$[21,36] ! "licensekey
  DIRTO$ = RETVAL$[37,101] ! "send file to
  LOGFNM$ = RETVAL$[102,139] ! "log file name
Else ! "NO DEFAULTS!?
  returnstatus=0;message$="NO DEFAULTS DEFINED!"
  ! Signal 3,30
  Goto OUTDONE
End If 
AVAACCTNO$=Trim$(AVAACCTNO$)
AVALCKEY$=Trim$(AVALCKEY$)
DIRTO$=Trim$(DIRTO$)
If AVAACCTNO$ = "" Or DIRTO$ = "" ! "NEED THESE!! Or AVADPC$="" OR
  returnstatus=0;message$="MISSING DEFAULT VALUES!"
  ! Signal 3,30
  Goto OUTDONE
End If 
LOGFNM$=Trim$(LOGFNM$)
If LOGFNM$ = "" ! no name defined - hardcode default name
  LOGFNM$ = "files/1/avataxout.log"
Else ! see if set for dl4
  IF Logfnm$[1,1]<>"/" and LOGFNM$[1,6]<>"files/" ! NEEDS THIS ON DL4!!
	TEMP$="files/"+logfnm$
	logfnm$=temp$ ! MUST START WITH files/ if to a directory!
  Endif
End If 
If DIRTO$ = "" Or DIRTO$[1,10] = SPACES$[1,10] Let DIRTO$ = "/tmp/" ! Have IT SOMEWHERE!
RCFAIL = 0
RESTARTHERE: Rem retry receiving
XMLFLE$ = INXMLFLE$ ! "passed the full name of file
CH_INFLE = CHNL ! "reuse progdflt channel
WORK$ = XMLFLE$ ! full file name
FLEFND = 0
CHK4FLE: Rem "wait and try again loop
Call FindF(WORK$,FOUND)
If FOUND ! it's there - open it
  Open #CH_INFLE,WORK$
Else 
  If FLEFND <= 4 ! not there yet? try 4 times(0,1,2,3)(=12 seconds), then give up
    FLEFND = FLEFND + 1
    !Print @40,22;'CL';"NO FILE YET..";Str$(FLEFND);
    Signal 3,30 ! wait 3 seconds
    Goto CHK4FLE
  End If 
  returnstatus=0;message$="RESPONSE FILE MISSING!"
  !Signal 3,30
  Goto OUTDONE
End If 
FLE$ = "7/AVAQTETRANS" + Str$(COID)
CHNL = 97 \ Gosub GETCHAN
If Err 0 Gosub ERR_TRAP ! getchan changes to err_escape:?
Call FindF(FLE$,H)
If Not(H) ! not found exit
  returnstatus=0;message$="TRANSACTION FILE NOT FOUND"
  ! Signal 3,30
  Goto OUTDONE
End If 
If CHNL > 1 ! valid
  CH_AVATRNS = CHNL
  Open #CH_AVATRNS,FLE$
Else 
  returnstatus=0;message$="TRANSACTION FILE NOT OPENED"
  !Signal 3,30
  Goto OUTDONE
End If 
BADDATA = 0;RCOMMIT = 0;RCANCEL = 0;CREDIT = 0
INFLE_LOOP: Rem until done or EOF
WRKLINE$ = ""
Gosub READ_TEMPLATE
If WRKLINE$ = "" Goto FLEDONE
Rem the only way I see it is do hardcode literal search
VARNM$ = "POSTTAX" ! RESPONSE"
Gosub CHK_LINE
If POS1 ! yes it's a commit response
  RCOMMIT = 1
  H0[7]=Orderno;pmordno=orderno ! as no details returned!!
  ! just result,transid and docid
End If 
VARNM$ = "CANCELTAX" ! RESPONSE"
Gosub CHK_LINE
If POS1 ! yes it's an abandon response
  RCANCEL = 1
  Goto DELPTRNS ! NODATAGET ! still need to delete transid!!
End If 
VARNM$ = "GETTAX" ! RESULT ! TAX CALC - ALL TYPES
Gosub CHK_LINE
If POS1 ! yes it's an Taxcalc
  RTAX = 1
End If 
VarNm$="<DOCTYPE" ! See what type of tax calc
gosub chk_Line:
If POS1 ! yes it's an Taxcalc
	Gosub Pars_Data:
	Let DocType$=temp$
	call String(1,DocType$)
	invoice=0;credit=0
	!if DocType$="SALESINVOICE" let invoice=1
	!if doctype$="RETURNINVOICE" let Credit=1
Endif
VARNM$ = "<DOCCODE"
Gosub CHK_LINE
If POS1 ! Yes, this is the one
  Gosub PARS_DATA
  X3 = TEMP$ ! would have Q at end!!
  PMORDNO = Abs(X3) ! in case credit
  if pmordno<=0 let pmordno=orderno ! as passed (sometimes no order in result?)
End If 
VARNM$ = "<DOCID"
Gosub CHK_LINE
If POS1 ! Yes, this is the one
  Gosub PARS_DATA
  AVAOID$ = TEMP$
  AVAOID$=Trim$(AVAOID$)
End If 
if doctype$="SALESORDER"
 ! get the trans id instead of docid (as it is not sent!!)
	Varnm$="<TRANSACTIONID"
	Gosub Chk_Line:
	If POS1 ! Yes, this is the one (only on order?!)
		Gosub Pars_Data:
		Let AVAOID$=temp$
		AVAOID$=Trim$(AVAOID$)
	Endif
Endif
VARNM$ = "<TOTALTAX>" ! as several start with 'totaltax'
Gosub CHK_LINE
If POS1 ! Yes, this is the one
  Gosub PARS_DATA
  X3 = TEMP$
  TAXAMT = Abs(X3) ! in case credit
End If 
TAXPRCT=0;TaxRate=0
if TAXAMT<>0 ! Piedmont wants the percent also - if tax $ - get taxable and calc the rate
	! alts are going thru response and finding certain <Rate> fields (out of multiple) to add them
	VARNM$ = "<TOTALTAXABLE>" ! as several start with 'totaltax'
	Gosub CHK_LINE
	If POS1 ! Yes, this is the one
	  Gosub PARS_DATA
	  X3 = TEMP$
	  TAXABLE = Abs(X3) ! in case credit
	End If 
	if taxable
		let taxrate=taxamt/taxable
	endif
	let taxprct=taxrate*100 ! to give percent!  and it always calculates back to tax $! LET's USE IT!!
Endif
VARNM$ = "<RESULTCODE" ! see if right result
Gosub CHK_LINE
If POS1 ! Yes, this is the one
  Gosub PARS_DATA
  TEMP$=UCase$(Trim$(TEMP$))
  If TEMP$ = "" Let BADDATA = 1 \ Goto ORDFINISH ! no serial number
  If TEMP$ <> "SUCCESS" Let BADDATA = 1 \ Goto ORDFINISH ! diff customer?
End If 
VARNM$ = "<MESSAGE" ! reason for resultcode<>"success"
Gosub CHK_LINE
If POS1 ! Yes, this is the one
  Gosub PARS_DATA
  FAULTSTRING$ = TEMP$
  FAULTSTRING$=Trim$(FAULTSTRING$)
End If 
VARNM$ = "FAULT"
Gosub CHK_LINE
If POS1 ! ava found a problem
  RESPFAULT = 1
End If 
VARNM$ = "<FAULTSTRING" ! don't include ">" as parse uses it
Gosub CHK_LINE
If POS1 ! see if we can grab why it's a 'fault'
  Gosub PARS_DATA
  FAULTSTRING$ = TEMP$ ! now get actual fault sentence
  WORK$ = TEMP$ ! as it includes 'bad' data (ie: ; &gt) get after that point
  POS0 = 1;POS2 = 0
  Search WORK$[POS0],";",POS2
  If POS2 ! okay all after semicolon is what we want
    POS1 = POS2 + 1
GETALLSC: Rem until no more found
    POS0 = POS1
    Search WORK$[POS0],";",POS2
    If POS2 ! found another - see if another
      POS1 = POS0 + POS2 ! retain
      Goto GETALLSC
    End If 
    FAULTSTRING$ = " ",FAULTSTRING$
    FAULTSTRING$ = WORK$[POS1 + 1] ! all to end
    Gosub STRPCHARS ! strip out any chars Unix cat doesn't like
  End If 
End If 
Goto INFLE_LOOP ! next line
READ_TEMPLATE: Rem read (needs any processing?)
Read #CH_INFLE;WRKLINE$;
STRPCCHAR: Rem "remove cr/lf etc
If Len(WRKLINE$) > 1 
  if WRKLINE$[Len(WRKLINE$)] < " "
	WRKLINE$[Len(WRKLINE$)] = "" ! Strip control chars
	Goto STRPCCHAR
  Endif
End If 
Return 
CHK_LINE: Rem See if line holds what we're looking for
WORK$ = WRKLINE$
Call String(1,WORK$) ! "ALL UPPERCASE
POS0 = 1;POS1 = 0;POS2 = 0
Search WORK$[POS0],VARNM$,POS1
Return 
PARS_DATA: Rem get the data from the line
WORK$ = "";TEMP$ = "" ! clear working vars
Search WRKLINE$[POS0 + POS1],">",POS2
If POS2 ! got it
  WORK$ = "";TEMP$ = ""
  X = POS2 + POS0 + POS1
  Let WORK$ = WRKLINE$[X] To "<" : POS2
  For X1 = 1 To Len(WORK$) ! "now strip any possible < or >
    If WORK$[X1,X1] <> ">" And WORK$[X1,X1] <> "<" And WORK$[X1,X1] <> ""
      TEMP$ = TEMP$ + WORK$[X1,X1]
    End If 
  Next X1
End If 
Return 
FLEDONE: Rem file reading is done - write order files
If AVAOID$ = "" Let BADDATA = 2 ! SHOULD HAVE THIS
If ORDERNO <> PMORDNO Let BADORD = 1 \ Goto ORDFINISH ! DIFF ORDER THAN SENT??
If ORDERNO <= 0 Let BADORD = 1 \ Goto ORDFINISH ! NEED AN ORDER NUMBER!
If SCOMMIT Goto ORDFINISH ! should not be here! EVER
if rcommit Goto DELPTRNS ! NODATAGET
If Not(RTAX) Let BADDATA = 3 ! not a recognized type
If RESPFAULT Let H0[7] = ORDERNO \ Goto ORDERFIN
If BADDATA Or RESPFAULT Goto ORDERFIN ! DO NOT UPDATE ANYTHING!

K1$ = " ",K1$;K1$[3] = ORDERNO Using "######"
For X = 1 To 99
  If X < 20 Or X > 22 ! no deleted search
    K1$[1,2] = X Using "##"
    Search #CH_ROH,2,1;K1$,R[2],E \ If E > 1 Gosub ERR_SEARCH
    If Not(E) Goto GOTORDER
  End If 
Next X
BADORD = 1
Goto ORDERFIN
GOTORDER: Rem found our target
ORDREC = R[2]
BADORD = 0 ! flag
If RCOMMIT Or RCANCEL Goto ORDERFIN ! NO UPDATE - We sent the values on file
Mat Read #CH_ROH,R[2],0;H0;
Mat Read #CH_ROH,R[2],104;H5;
R[3] = H0[3] ! rot record
Mat Read #CH_ROT,R[3],8;T2 ! read & LOCK
T2[2] = Taxprct ! calc'd from tax$ and taxable$
T2[7] = TAXAMT ! from return data
If H5[7] = 10 Or H5[7] = 6 Let T2[6] = 0 - T2[7] ! sample/donation credit back tax
T2[0] = T2[1] - T2[3] + T2[4] + T2[5] + T2[6] + T2[7] ! RETOTAL ORDER/INV TOTAL
Mat Write #CH_ROT,R[3],8;T2; ! UNLOCK
ORDERFIN: Rem "finish up
DELPTRNS: Rem delete any/all entries for this order
If H0[7] <= 0 Goto ORDFINISH ! just in case
K1$ = " ",K1$;K1$ = H0[7] Using "######"
Search #CH_AVATRNS,2,1;K1$,R,E \ If E > 1 Gosub ERR_SEARCH
If Not(E) ! found previous DELETE IT! (to prevent old or bad info accumulation)
  Search #CH_AVATRNS,5,1;K1$,R,E \ If E Gosub ERR_SEARCH
  Goto DELPTRNS
End If 
! if it's a commit or abandon - DO NOT ADD BACK KEY!
if RCANCEL goto Ordfinish: ! need doc id - not trans id!!
if baddata or badord goto OrdFinish: ! DO NOT RECORD IF NOT SUCCESS!!
If AVAOID$[1,1] <> "" And AVAOID$[1,10] <> SPACES$[1,10] ! don't record blank (out program handles it)
  K1$ = " ",K1$;K1$[1,6] = H0[7] Using "######"
  K1$[7] = AVAOID$ + SPACES$;R = ORDREC ! record ava transid #
  Search #CH_AVATRNS,4,1;K1$,R,E \ If E > 1 Gosub ERR_SEARCH ! "ALLOW DUPE!!
End If 
Goto ORDFINISH
NODATAGET: Rem no data in file - just a response
RESPFAULT = 0;RLINE = 1;H0[7] = ORDERNO
RFLE_LOOP: Rem look to see if fault was sent
If RLINE > 1 ! in case a 1 line response - don't read next line yet
  WRKLINE$ = ""
  Gosub READ_TEMPLATE
End If 
If WRKLINE$ = "" Goto ORDFINISH
VARNM$ = "FAULT"
Gosub CHK_LINE
If POS1 ! ava found a problem
  RESPFAULT = 1
End If 
VARNM$ = "<FAULTSTRING" ! don't include ">" as parse uses it
Gosub CHK_LINE
If POS1 ! see if we can grab why it's a 'fault'
  Gosub PARS_DATA
  FAULTSTRING$ = TEMP$ ! now get actual fault sentence
  WORK$ = TEMP$ ! as it includes 'bad' data (ie: ; &gt) get after that point
  POS0 = 1;POS2 = 0
  Search WORK$[POS0],";",POS2
  If POS2 ! okay all after semicolon is what we want
    POS1 = POS2 + 1
GETALLSC2: Rem until no more found
    POS0 = POS1
    Search WORK$[POS0],";",POS2
    If POS2 ! found another - see if another
      POS1 = POS0 + POS2 ! retain
      Goto GETALLSC2
    End If 
    FAULTSTRING$ = " ",FAULTSTRING$
    FAULTSTRING$ = WORK$[POS1 + 1] ! all to end
    Gosub STRPCHARS ! strip out any chars Unix cat doesn't like
  End If 
End If 
RLINE = RLINE + 1
Goto RFLE_LOOP
STRPCHARS: Rem as we use cat - we need to strip 'invalid' chars
WORK$ = FAULTSTRING$
If Len(WORK$) = 0 Return 
For X = 1 To Len(WORK$)
  If WORK$[X,X] = ")" Let WORK$[X,X] = " "
  If WORK$[X,X] = "(" Let WORK$[X,X] = " "
Next X
FAULTSTRING$ = " ",FAULTSTRING$
FAULTSTRING$ = WORK$
Return 
ORDFINISH: Rem finish
!If Not(CREDIT) Print @0,23;'CL';"ORDER ";
!If CREDIT Print @0,23;'CL';"CREDIT ";
!Print H0[7]; ! show order/cm #
!If Not(RCOMMIT) And Not(RCANCEL) Print "TAX ";
!If RCOMMIT Print "COMMIT ";
!If RCANCEL Print "CANCEL ";
!Print "RECEIVED. ";
!If BADORD Or BADDATA Or RESPFAULT Print "DATA ERROR"; Else Print "NO PROBLEMS";
!If RESPFAULT Print FAULTSTRING$;
!If BADORD Or BADDATA Or RESPFAULT Signal 3,20
RFLEDONE: Rem close & audit
Close #CH_INFLE
Close #CH_AVATRNS
If Not(CREDIT) Let TEMP$ = "QUOTE: " + H0[7] Using "######"
! If CREDIT Let TEMP$ = "CREDIT: " + H0[7] Using "######"
TEMP$ = TEMP$ + "  " + Msc$(3) ! +"\215\"
If RESPFAULT !
  TEMP$ = TEMP$ + " AVALARA REPORTED A XML DATA FAULT: "
  TEMP$ = TEMP$ + FAULTSTRING$
Else 
  If Not(RCOMMIT) And Not(RCANCEL) Let TEMP$ = TEMP$ + " AVATID: " + AVAOID$
End If 
If RCOMMIT Let TEMP$ = TEMP$ + " COMMIT"
If RCANCEL Let TEMP$ = TEMP$ + " CANCEL"
If Not(BADDATA) And Not(BADORD) Let TEMP$ = TEMP$ + " RECV AS: " + INXMLFLE$
If BADORD Let TEMP$ = TEMP$ + " DATA ERROR: NO ORDER NUMBER"
If BADDATA = 1 Let TEMP$ = TEMP$ + " DATA ERROR: RESULT NOT SUCCESS"
If BADDATA = 2 Let TEMP$ = TEMP$ + " DATA ERROR: NO TRANS ID RECEIVED"
If BADDATA = 3 And Not(RESPFAULT) Let TEMP$ = TEMP$ + " DATA ERROR: UNRECOGNIZED RESPONSE"
if baddata and RTrim$(Faultstring$)<>"" let temp$=temp$+RTrim$(Faultstring$) ! add message!!
WORK$ = "echo " + TEMP$ + " >> " + LOGFNM$ ! append to logfile
System WORK$
WORK$ = INXMLFLE$ ! "full file name in
POS0 = 1;POS1 = 0
Search WORK$[POS0],"in.txt",POS1
If Not(POS1) Goto OUTDONE ! can't do the rest if not found!
XMLFLE$ = WORK$[1,POS1 - 1] ! all up to in.txt
Rem as 'commits' seem to fail quite often - try a resend
If RCOMMIT And RESPFAULT And RCFAIL < 2 ! see type of fault (fail if failed 2x)
  POS0 = 1;POS1 = 0
  Search FAULTSTRING$[POS0],"try again later",POS1
  If POS1 ! "we'll try again
    WORK$ = XMLFLE$ + ".pl " + INXMLFLE$
    ! Print @0,22;'CL';"RESENDING ";H0[7];" COMMIT REQUEST NOW - RETRY ";Str$(RCFAIL + 1);
    System WORK$ ! "execute - results to inxmlfle$
    RCFAIL = RCFAIL + 1 ! retain fail attempt
    Goto RESTARTHERE ! give her another try
  End If 
End If 
If SCOMMIT And (BADDATA = 3 Or RCOMMIT = 0) And RCFAIL < 2 ! commit got no response - try again
  WORK$ = XMLFLE$ + ".pl " + INXMLFLE$
  ! Print @0,22;'CL';"RESENDING ";H0[7];" COMMIT REQUEST NOW - RETRY ";Str$(RCFAIL + 1);
  System WORK$ ! "execute - results to inxmlfle$
  RCFAIL = RCFAIL + 1 ! retain fail attempt
  Goto RESTARTHERE ! give her another try
End If 
If Not(BADORD) And Not(BADDATA) And Not(RESPFAULT) ! "all ok - delete files
  Rem all trans(except faults) are saved on ava system
  if tim(6)>=17700 ! save for first 85+ days then normal (in case of questions!)
	WORK$ = "rm -f " + XMLFLE$ + "* >/dev/null 2>&1"
	System WORK$
  Endif
End If 
OUTDONE: Rem finished
If Err 0 Rem
For X = 1 To 10
  If CCHAN[X] <= 0 ! we opened
    X1 = Abs(CCHAN[X]) ! stored as 0-chan
    If X1 > 0 Close #X1
  End If 
Next X
If Err 0 Gosub ERR_TRAP
OUTEND: Rem outta here
End 
Rem {begin src/inc/rtn.getchan.i}
GETCHAN: Rem search for open channel (counts down from supplied chnl #)
CHNL=FindChannel()
Return 
OutErr: ! something amiss
call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
call AddToStr(e$,rstr$,WebStr$)
call SetOutPut(e$,rstr$)
End
Rem {end rtn.getchan.i}
ERR_SEARCH: Rem
ENUM = E + 1000;ELINE = Spc(16);CTERR = 0
If E = 5 Let CTERR = Err(8)
msg$ = "RETURN STATUS",(E + (CTERR * .001))
msg$ = msg$,"/ STATEMENT",ELINE," IN PROGRAM "+MSC$(4)
Call programdump("tmp/ava.qxmlfleinse!","")
returnstatus=0
message$=msg$
goto OutErr ! alt - send user info
Rem {begin rtn.error.s}
ERR_TRAP: Rem *Error routine (escape trap)   V3.1 8/94 G.DOSCHER/REK
!
include "src/callmainerrnet.inc"
End 
