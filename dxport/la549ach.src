! >>> Program la549ach
!
! description Accounts Payable Positive Pay/ach
! loadsave -w -n 100,10 -o prog/dxport/la549ach.dl4 src/la549ach.src
! 
! 1.0 mm/dd/yyyy change??
!
include "src/copyright.inc"
Rem BEDIT Version: 2.3 OBJECT CODE     Created: OCT  1, 2012  16:10:22
Rem /w2/papermaster/r2005//usr/acct/mary/work/custom/xrev9/la549ach.src (univ2) [mary] {29174}
Rem  Copyright (c) 2012 Universal Business Systems, Inc.
Rem    **** ALL CHANGES MUST BE MADE IN SOURCE!!! ****
Rem
!!!
Declare Intrinsic Sub Date,FileInfo,FindF,InpBuf,String,Time,VerifyDate,DateToJulian
! external libs for subs/functions
External Lib "libgeneral.lib"
Declare External Sub suberr,mainerr,GetSession,AddToStr,SetOutput,CreateNetStatus
External Lib "ubsfunc.dl4"
Declare External Function OpenFile
External Lib "dxblockgeneral.lib"
Declare External Function blockbuildsort
Declare Intrinsic Sub DateToJulian,FindF,InpBuf,String,VerifyDate,Time,Logic
Declare Intrinsic Sub dxopen,dxget,dxset,dxclose,dxsave,getglobals
!Option Default Dialect IRIS1
Declare Intrinsic Sub DateToJulian
Declare Intrinsic sub programdump,env
Declare Intrinsic function findchannel
! external libs for subs/functions
External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus
Declare External Function getmsg$,expandarray

!!!
Rem LA549ach A/P Check Extraction Process
Rem LAST UPDATE: Burke/Imperial
Rem

Try
Com 2%,CHKDATE,PBANKCODE$[4],companyid$[10]
dim 1%,wellsfargoflag,ediflag,paymodex
dim e$[500],buttonlist$[5,50],nextlist$[5,100],msg$[100],TMP$[800],rstr$[2000] ! error 
dim xdate$[50]
Rem {begin dim.rtn.input}
Dim J$[70],J0$[18],J1$[70],J2$[20],J3$[40],J4$[60],J5$[80],J7$[80],J9$[70]
Dim X$[100],1%,J0,J2,J3,J4,J5,J7[2],J8,X1[9]
Dim 2%,J9[9],X2[9],4%,J1
Rem {end dim.rtn.input}
Dim KEYVOID$[50],3%,REC_VOID
Dim 1%,B8[1],B9,C0[6],E,G9,I,R9,L,L9,P,X,X1,Y0,URECFLAG
Dim 2%,A1,B1,C[1],C1,C2,C3[2],C9,D0,H[3],R1,W,X2,CREATEDATE
Dim 2%,ISSDATE,EXDATE,CURDATE,EFTDATE
Dim 3%,TMP3
Dim 4%,BANKACC,CHECKAMT,CHKTOT
Dim 3%,A9,K4,T1[4],X3
Dim C$[10],F$[16],G$[2],P61$[256]
Dim I$[30],K$[20],K1$[50],K4$[30],K5$[30],N$[40],P$[8],R$[63],Z2$[2]
Dim R2$[4],U5$[50],V$[20],V1$[20],NAME$[30],RETVAL$[512],XFER$[20]
Dim VW3$[181],KEYVBNK$[50],VW2$[90]
Dim EFTDATE$[6]
Dim KEYVTAG$[50],PAYOR$[112],VENDINFO$[264]
Dim ACPER$[4],DATE$[6],BANKACC$[16],DATE1$[8],PTRNM$[170],BANKABA$[12]
DIM BANKROUTE$[12]
DIM ORGBANKACC$[16],ORGBANKROUTE$[12]
dim emailword1$[50],emailword2$[50]
Dim 2%,H[3],1%,H1[1],H$[30],H1$[12],3%,H2[2],1%,N3[1],2%,N5
Dim 1%,A5,A5$[30],3%,A6[2],2%,A7[1],BANKCODE$[4],TSTR$[1],KEYCHK$[50],KEYCHK1$[50],CBANKCODE$[4]
Dim 1%,M[1],M$[12],2%,M1[8],3%,M2[4]
Dim CMD$[500],FTMPNAME$[120],NEWFILENAME$[120]
dim keyapm$[50],APM3$[50],3%,rec_apm
Dim FNAME$[50],BLANK$[316],2%,APDATE
Dim 1%,TMPMTH,TMPYR
Dim SOURCEDIRNAME$[50],TEXTDIRNAME$[50],TMPFILE$[180],TXTFILE$[180]
DIM CNAME$[30]
Dim VENDABA$[10],VENDACCT$[14]
Dim 2%,VB1,1%,VB2[1],VBROUTING$[8],VBROUTEDIGIT$[2],VBID$[16],VBNAME$[30],VBACCT$[20]
Dim 3%,R[50],COMP
Dim 3%,LINECOUNT
dIM GROUPID$[1]
Dim fname$[50],groupid$[1],2%,apdate,WFREC$[94]
Dim 1%,tmpmth,tmpyr
Dim DEV$[20],HM$[30],nextblockid$[8],Message$[600],WebStr$[600]
Dim tmp1$[200],blockid$[100]
Dim action$[30],options$[30],userid$[8],3%,fdel$[10],bsdel$[10],esdel$[10],rdel$[10]
DIM SOURCEDIRNAME$[50],TEXTDIRNAME$[50]
dim SYS$[3500] ! expand out for longer email address
dim 1%,emailflag
dim keyaph$[30],2%,ponum,aphm1[8],3%,rec_aph
Dim keyacf$[20],clientdata$[140],3%,rec_acf
dim 3%,totemail,r1,vtot[2],remitfilename$[50],phone$[14],keyamcr$[30],keyamchk$[30],bankemail$[50],vbemail$[194]
dim email1$[194],email2$[194],email$[194],wk1$[50],field$[50],wk$[50]
dim 3%,rec_pvb,keypvb$[20],pvbemail$[194],pvbacct$[20],acctdigit$[4],pvbemail1$[194]
dim custom_customer$[30]
! call dxopen() ! needed?
! Call getsession(e$,CTLC,options$,action$,userid$,intCO,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$)
Call getglobals("blockx",0,blockid$,CTLC,options$,action$,userid$,intCO,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$)
COID=intCO
COMP=intCO
Def FNR(X) = Sgn(X) * (Abs(Int((Abs(X) + .005) * 100) / 100))
let companyid$="1"
fname$="cntrl/companyid.ini"
Call FindF(fname$,X2)                                 
IF X2<>0                                                      
	try                                                                                                              
		open #90,"cntrl/companyid.ini"
		read #90;tmp$
		let companyid$=rtrim$(tmp$)
		let companyid$=companyid$ TO "\15\"
		LET companyid$=companyid$ TO "\215\"                                            
		LET companyid$=companyid$ TO "\212\"                                                                                       
		LET companyid$=companyid$ TO "\211\"
		if companyid$="" let companyid$="1"	
		close #90
	else
		let companyid$="1"
	end TRY
endif              
F$ = COMP Using "3/VENDWHSE#"
Ropen #10,F$
TSTR$ = "*"
mat read #1,61,0;p61$;
Mat Read #1,3,0;PAYOR$;
mat read #1,115,60;custom_customer$;
custom_customer$ = rtrim$(custom_customer$)
! need acf for phone # 
mat read #1,88,688;fname$; ! DIV FILE
CHAN = Findchannel()
let div=1
ropen #chan,fname$
let phone$=" ",phone$
mat read #chan,div,168;phone$;
try
	close #chan
else
	!!
end try

! custom_customer$="HATHAWAY" !!!!!!! FOR TESTING -
! let custom_customer$="JACKSON" !!!!!!!!!!! remove after testing is complete
let boaflag=0;wfflag=0;jpmflag=0;ediflag=0;peopleflag=0

let xflag=99
if custom_customer$="BUTLER"
	let peopleflag=1
endif
if custom_customer$="HATHAWAY" or custom_customer$="MAYFIELD"
	LET wfflag=1
endif
if custom_customer$="LEONARD" 
	let wfflag=1 
	let ediflag=1
	xflag=0
endif
if custom_customer$="JACKSON"
	let paymodex=1
	let fdel$="|"
endif
if custom_customer$="BURKE" let jpmflag=1
if custom_customer$="JPAPER" let provflag=1 ! for provident bank
if provflag=1
	dim text$[94]
	xflag=0
endif
if wfflag=1 
	dim text$[94]
	xflag=0
endif
if jpmflag=1
	dim text$[94]
	xflag=0
endif
if peopleflag=1
	dim text$[94]
	xflag=0
endif	
if xflag<>0 ! default
	dim text$[316]
endif
EMAILFLAG = 0
EMCH = -1
If P61$[30,30] = "Y" 
	Call DXGet("EMAIL",tmp$) 
	if rtrim$(tmp$)<>"" let emailflag=99
endif

EFTDATE$=" ",EFTDATE$
Goto STARTPROC
STARTPROC: Rem
C = 0 \ C[1] = 0
If rtrim$(PBANKCODE$)= ""
	let returnstatus=0
	message$="Bank Code Must Be Entered " 
    Goto OUTEND
End If 
CHECKPROC: Rem
Mat Read #1,61,0;P61$;
BLANK$ = " ",BLANK$
fname$="cntrl/la549ach.ini"
Call FindF(fname$,X2)                                 
IF NOT (X2)                                                       
	eflag=eflag+1
	ReturnStatus = 1                           
	Message$ = "The initialization file was not found!"                                            
	GOTO outend:                                                     
ENDIF                                                              
open #90,"cntrl/la549ach.ini"
read #90;sourcedirname$
LET SOURCEDIRNAME$=RTRIM$(SOURCEDIRNAME$)                                                    
LET sourcedirname$=sourcedirname$ TO "\215\" !"strip off <CR> 
let sourcedirname$=sourcedirname$ to "\211\" !"strip off [tab]
LET sourcedirname$=sourcedirname$ TO "#" !"strip off remarks 
LET sourcedirname$=sourcedirname$  TO "!" !"strip off remarks
if sourcedirname$="" or sourcedirname$="!"
	eflag=eflag+1
	ReturnStatus = 1                           
	Message$ = "Source Directory Not Set Up Properly!"                                            
	goto outend: 
endif
let x=len(sourcedirname$)
if sourcedirname$[x,x]<>"/" let sourcedirname$[x,x]=""
call findf(sourcedirname$,x2)
if not(x2)
	eflag=eflag+1
	ReturnStatus = 1                           
	Message$ = "Source Directory Does Not Exist!"                                            
	goto outend:
endif
Call FindF(SOURCEDIRNAME$,A9)                      
IF NOT (a9)                 
   LET CMD$="mkdir "+SOURCEDIRNAME$
   SYSTEM CMD$
endif
!SOURCEDIRNAME$ = "files/transfer/"
!Call FindF(SOURCEDIRNAME$,A9)
!If Not(A9)
!  CMD$ = "mkdir " + SOURCEDIRNAME$
! System CMD$
!End If 
B8 = 0 \ B8[1] = 99
CURDATE = ((Tim(8) * 10000) + (Tim(9) * 100) + Tim(10))
CREATEDATE = CURDATE
If EFLAG <> 0 Goto OUTEND
TMPFILE$ = (CREATEDATE Using "&&&&&&")
TMPFILE$ = TMPFILE$ + (Tim(11) Using "&&")
TMPFILE$ = TMPFILE$ + (Tim(12) Using "&&")
TMPFILE$ = TMPFILE$ + (Tim(13) Using "&&")
if not(paymodex)
	TMPFILE$ = TMPFILE$ + (CHKDATE Using "&&&&&&")
endif
TXTFILE$ = TMPFILE$
PTRNM$ = SOURCEDIRNAME$ + TMPFILE$
FILECHK = 0
CREATEFILE: Rem check if file exists
Call FindF(PTRNM$,A9)
If A9 <> 0
  FILECHK = FILECHK + 1
  If FILECHK > 999
	let returnstatus=0
    message$="Transfer File May Not Be Created"
    Goto OUTEND
  End If 
  TXTFILE$ = TMPFILE$ + "."
  TXTFILE$ = TXTFILE$ + (FILECHK Using "&&&")
  PTRNM$ = SOURCEDIRNAME$ + TXTFILE$
  Goto CREATEFILE
End If 
Build #0, + PTRNM$
Try
	Close #0
else
	rem
end try

Open #0,PTRNM$
! Print @0,23;'CL';"Processing....Please Wait...";
TEXT$ = " ",TEXT$
CHECKPROC = 0;CHKTOT = 0
REMPROC=0;TOTCHKS=0
L_1960: NAME$ = ""
! If Err 0 Gosub ERR_ESCAPE
B9 = 0 \ C = 0 \ G9 = 0
K4$ = " ",K4$
SRCHBANK: Rem search bank file
Search #5,3,1;K4$,R[5],E \ If E = 2 Goto L_9100
READBANK: Rem read apcash file
Mat Read #5,R[5],74;CBANKCODE$;
If PBANKCODE$[1,4] <> CBANKCODE$[1,4] Goto SRCHBANK
Mat Read #5,R[5],0;A5;
Mat Read #5,R[5],2;A5$;
Mat Read #5,R[5],32;A6;
Mat Read #5,R[5],50;A7;
Mat Read #5,R[5],58;BANKACC$;
Mat Read #5,R[5],74;BANKCODE$;
MAT  READ #5,R[5],104;BANKROUTE$;
MAT READ #5,R[5],150;BANKEMAIL$;
If PBANKCODE$[1,4] <> BANKCODE$[1,4] Goto SRCHBANK
BANKACC = BANKACC$
Rem! check bank code
If Not(BANKACC) and RTRIM$(BANKACC$)=""
	let returnstatus=0
	let message$="Bank Account needs to be set-up "
	goto outend:
  !Print @0,19;'CE RB';"***** \11\WARNING:  BANK # ";K4$;
  !Print @0,20;'CE RB';"This bank does not have a bank account #";
  !Print @0,21;'CL RB';"If you would like to process check number extraction";
  !Print @0,22;'CL RB';"Please enter account number in 571 bank account maintenance";
  !Print @0,23;'CL RB';"Press <CR> to continue with the next bank ";
  !Input Len (16384 + 1);""J$
  !Goto SRCHBANK
End If 
if emailflag<>0
	if rtrim$(bankemail$)=""
		let returnstatus=0
		let message$="Email option selected. AP Bank needs a from email address for remittance"
		goto outend:
	endif
	Call "mxvaleaddr.dl4",BANKEMAIL$,X1,e$
	If Not(X1) 
		let returnstatus=0
		let message$="Email option selected. AP Bank has an invalid from email address for remittance"
		goto outend:	
	End If 
endif
ORGBANKACC$=BANKACC$
ORGBANKROUTE$=BANKROUTE$
If paymodex<>0 goto startproc1: 
if wfflag<>0 or peopleflag<>0 or provflag<>0
	if custom_customer$="MAYFIELD"
		let text$=" ",text$
		text$[1,9]="$$ADD ID=" ! request id
		text$[10,17]="CSKFY5F6" ! remove id
		text$[18,18]=" "
		text$[19,22]="BID="! batch parameter id
		text$[23,23]="’"
		text$[24,29]="NWFACH" ! file type
		text$[30,37]="27511087" ! application id
		text$[38,38]="’"
		LET TEXT$=" ",TEXT$
		LET TEXT$[1,38]="$$ADD ID=CSKFY5F6 BID='NWFACH27511087'" 
		Print #0;TEXT$
		LINECOUNT = LINECOUNT + 1
	endif
	! file header record
	Text$=" ",text$
	text$=""
	Text$[1,1]="1" ! 1. Record Type Code The code identifying the File Header Record is 1.  
	Text$[2,3]="01"! 2. Priority Code The lower the number, the higher processing priority. Currently, only 01 is used.  
	Text$[4,4]=" "
	text$[5,13]=RTRIM$(bankroute$[1,9])+blank$!3. Immediate Destination  Bank’s transit routing number preceded by a blank. 
	text$[14,23]=rtrim$(bankacc$[1,10])+blank$ ! 4. Immediate Origin Your 10-digit company number. The use of an IRS Federal Tax Identification Number as a company identification is recommended. Otherwise, ABN AMRO will create a unique number for your company  
	!5. File Creation Date The date you created the input file.  
	TMP$ = Tim(4) Using "&&&&&&"
	TEXT$[24,25] = TMP$[5,6]
	TEXT$[26,29] = TMP$[1,4]
	!6. File Creation Time Time of day you created the input file. This field is used to distinguish between input files if you submit more than one per day.  
	EFTDATE$ = TEXT$[24,29]
	IF CHKDATE<>0
		LET EFTDATE$=CHKDATE USING "&&&&&&" ! YYMMDD
	ENDIF
	TEXT$[30,31] = Tim(11) Using "&&"
	TEXT$[32,33] = Tim(12) Using "&&"
	Text$[34,34] = "A"	! 7. File ID Modifier Code to distinguish among multiple input files. Label the first (or only) file “A”, and continue in sequence (A-Z). If more than one file is delivered, they must have different modifiers. 
	TEXT$[35,37] = "094" ! 8. Record Size 94 
	TEXT$[38,39] = "10" ! 9. Blocking Factor Block at 10. ) 
	TEXT$[40,40] = "1"	! 10. Format code Currently there is only one code. Enter 1. 
	If wfflag<>0
		TEXT$[41,51] = "WELLS FARGO" ! 11. Immediate Destination Name Enter LaSalle Bank or Standard Federal Bank 
		text$[52,63] =blank$ ! " 
	endif
	if peopleflag<>0
		let text$[41,63] = "People's Bank"+bankacc$[1,10]
	endif
	if provflag<>0
		let text$[41,63]= "Provident "+bankacc$[1,10]+blank$
	endif                  
	TEXT$[64,86] = rtrim$(PAYOR$[1,23])+blank$ ! 12. Immediate Origin Name Your company’s name, up to 23 characters Company Name from Control File
	TEXT$[87,94] = blank$ ! "        "
	! TEXT$[94,94]=""
	! Note - 13. Reference Code Optional field you may use to describe input file for internal accounting purposes. 
else
  ! this is jp morgan format
	! File Header 
	TEXT$ = " ",TEXT$
	text$=""
	TEXT$[1,1] = "1"
	TEXT$[2,3] = "01"
	!TEXT$[4,13] = " 021000021"
	TEXT$[4,13] = " 012012012"
	!TEXT$[14,23] = "1838186530"
	TEXT$[14,23] = "1850018500"
	TMP$ = Tim(4) Using "&&&&&&"
	TEXT$[24,25] = TMP$[5,6]
	TEXT$[26,29] = TMP$[1,4]
	EFTDATE$ = TEXT$[24,29]
	TEXT$[30,31] = Tim(11) Using "&&"
	TEXT$[32,33] = Tim(12) Using "&&"
	TEXT$[34,34] = "I"
	!TEXT$[35,37] = "094"
	TEXT$[35,37] = "185"
	TEXT$[38,39] = "10"
	TEXT$[40,40] = "1"
	! TEXT$[41,54] = "JPMORGAN CHASE"
	TEXT$[41,54] = "BANKING BY UBS"
	! TEXT$[64,86] = "IMPERIAL BAG AND PAPER "
	TEXT$[64,86] = "Universal Business Sys "
	text$[87,94]="        "
endif

Print #0;TEXT$
LINECOUNT = LINECOUNT + 1
if ediflag=0
if wfflag<>0 or peopleflag<>0 or provflag<>0
	TEXT$ =" ",TEXT$
	text$=""
	TEXT$[1,1] = "5" !1. Record Type Code The code identifying the Batch Header record is 5
	TEXT$[2,4] = "200" !2. Service Class Code Identifies the type of entries in the batch: 200-ACH Entries Mixed Debits andCredits. 220-ACH Credits Only 225-ACH Debits Only 
	TEXT$[5,20] = rtrim$(Payor$[1,16])+blank$  ! 3. Company Name Your company name, up to 16 characters. This name may appear on the receivers’ statements prepared by the Receiving Financial Institution.  
	!TEXT$[21,40] =not used 4. Discretionary Data For your company’s internal use, if desired. No specific format is required. 
	text$[21,40]=blank$ ! "                    "
	TEXT$[41,50] = rtrim$(bankacc$[1,10])+blank$ !5. Company Identification Your 10-digit company number. Identical to the number in field 4 of the File Header Record, unless multiple companies/divisions are provided in one transmission. 
	iF CUSTOM_CUSTOMER$="HATHAWAY"
		TEXT$[41,50]="1541155590"
	endif
	if custom_customer$="BUTLER"
		TEXT$[41,50]="041138830 " ! 
		! 
	ENDIF
	if custom_customer$="JPAPER"
		let text$[41,50]=""   ! need comp id
	endif
	iF CUSTOM_CUSTOMER$="MAYFIELD"
		TEXT$[41,50]="2751108799"
	endif
	TEXT$[51,53] = "CCD" !6. Standard Entry Class Identifies the entries in the batch. Common standard entry class codes are PPD (Prearranged Payments and Deposit entries) for consumer items, CCD (Cash Concentration and Disbursement entries), CTX (Corporate Trade Exchange entries) for corporate transacti 
	TEXT$[54,63] = "PAYMENT   " !7. Company Entry Description Your description of the transaction. This may be printed on the receivers’ bank statement by the Receiving Financial Institution. (i.e. Payroll) 
	if peopleflag<>0
		let text$[64,69]=blank$
	else
		TEXT$[64,69] = Tim(5) Using "&&&&&&" !8.Company Descriptive Date The date you choose to identify the transactions. This date may be printed on the participants’ bank statement by the Receiving Financial Institution.
	endif
	TEXT$[70,75] = EFTDATE$ !9. Effective Entry Date Date transactions are to be posted to the participants’ 
	!TEXT$[76,78] 10. Reserved Leave this field blank.
	TEXT$[76,78]=blank$ ! "   "
	TEXT$[79,79] = "1" !11. Originator Status Code Enter “1”. This identifies LaSalle/Standard Federal as a depository financial institution, which is bound by the rules of the ACH.
	TEXT$[80,87] = rtrim$(bankroute$[1,8])+blank$! 12. Originating Financial Institution Enter LaSalle’s routing transit number 07100050, or Standard Federal’s transit routing number of 07200080. 
	TEXT$[88,94] = "0000001" !13. Batch Number Number batches sequentially. 
	Print #0;TEXT$
	LINECOUNT = LINECOUNT + 1
else
	TEXT$ = " ",TEXT$
	TEXT$[1,1] = "5"
	TEXT$[2,4] = "200"
	!TEXT$[5,20] = "IMPERIAL BAG    "
	TEXT$[5,20] =  "Universal Busine"
	!TEXT$[41,60] = "1838186530"
	TEXT$[41,60] =  "1850018500"
	TEXT$[51,53] = "CCD"
	TEXT$[54,63] = "PAYMENT   "
	TEXT$[64,69] = Tim(5) Using "&&&&&&"
	TEXT$[70,75] = EFTDATE$
	TEXT$[79,79] = "1"
	!TEXT$[80,87] = "02100002"
	TEXT$[80,87] = "012012012"
	TEXT$[88,94] = "0000001"
	Print #0;TEXT$
	LINECOUNT = LINECOUNT + 1
endif
endif ! (for ediflag)
STARTPROC1: ! 
Rem!!!! ********* Batch Header Record (5) ************
For CH = 2 To 4
  K1$ = " ",K1$;K1$[1,2] = A5 Using "##"
L_2000: Search #CH,3,1;K1$,R[2],E
  If E = 2
    If C <> 0
      CHECKAMT = T1[2]
      Gosub L_3000
      NAME$ = "";C = 0
    End If 
    Goto GETNEXTCH
  End If 
  If E Gosub ERR_SEARCH
  BANKNUM = K1$[1,2]
  If BANKNUM <> A5
    If C <> 0
      CHECKAMT = T1[2]
      Gosub L_3000
      NAME$ = "";C = 0
    End If 
    Goto GETNEXTCH
  End If 
  Mat Read #CH,R[2],0;H;
  If CHKDATE <> 0
    If H[2] <> CHKDATE Goto L_2000
  End If 
  If Not(H[1]) Goto L_2000
  Mat Read #CH,R[2],16;H1;
  If H1[1] > 7
    TMP3 = K1$[3,8]
    TMP3 = TMP3 + 1
    If TMP3 > 999999 Goto GETNEXTCH
    K1$ = " ",K1$;K1$[1,2] = A5 Using "##"
    K1$[3,8] = TMP3 Using "######"
	K1$[9]="                        "
    Goto L_2000
  End If 
  VOIDCHK = K1$[3,8]
  If C <> VOIDCHK !
    KEYVOID$ = K1$
LOOPVOID: Rem
    Search #CH,3,1;KEYVOID$,REC_VOID,E
    If E = 2 Goto ENDLOOPVOID
    If E <> 0 Gosub ERR_SEARCH
    TMP3 = KEYVOID$[3,8] \ If TMP3 <> VOIDCHK Goto ENDLOOPVOID
    Mat Read #CH,REC_VOID,16;H1;
    If H1[1] < 8 Goto LOOPVOID
    TMP3 = TMP3 + 1
    If TMP3 > 999999 Goto GETNEXTCH
    K1$ = " ",K1$;K1$[1,2] = A5 Using "##"
    K1$[3,8] = TMP3 Using "######"
	K1$[9]="                        "
    Goto L_2000
ENDLOOPVOID: Rem
  End If 
  Mat Read #CH,R[2],94;EXDATE;
  If Not(CHKDATE)
    If EXDATE
      If Not(H1[1])
        K1$[3] = (H[0] + 1) Using "######"
		K1$[9]="                        "
      End If 
      Goto L_2000
    End If 
  End If 
  KEYVBNK$ = " ",KEYVBNK$
  KEYVBNK$[1,6] = H[1] Using "######"
  Search #12,2,1;KEYVBNK$,R[12],E \ If E > 1 Gosub ERR_SEARCH
  If E = 1
	let pflag=pflag+1
	Let message$=Message$+"Error Vendor "+str$(h[1])+" Bank Acct" 
    !Print @0,22;'CL';"Bank Acct Info Not Set Up for Vendor ";H[1];" transacion bypass"
    !Print @0,23;'CL';"Press <CR> to continue ";
    !Input ""J$
    K1$[3] = (H[0] + 1) Using "######"
    K1$[9,12] = "    "
    Goto L_2000
  End If 
  Mat Read #12,R[12],0;VB1;
  Mat Read #12,R[12],4;VB2;
  If VB2[1] <> BANKNUM	
	let pflag=pflag+1
	Let message$=Message$+"Error Vendor "+str$(h[1])+" Ach Bank" 
    !Print @0,22;'CL';"Ach Bank Number Does Not Match Vendor ";H[1];" transacion bypass"
    !Print @0,23;'CL';"Press <CR> to continue ";
    !Input ""J$
    K1$[3] = (H[0] + 1) Using "######"
    K1$[9,12] = "    "
    Goto L_2000
  End If 
  Mat Read #12,R[12],8;VBROUTING$;
  Mat Read #12,R[12],16;VBROUTEDIGIT$;
  Mat Read #12,R[12],18;VBID$;
  Mat Read #12,R[12],34;VBNAME$;
  Mat Read #12,R[12],64;VBACCT$;
  mat read #12,r[12],104;vbemail$;
  if paymodex<>0
	if rtrim$(vbid$)="" and rtrim$(vbname$)=""
		goto L_2000:
	endif 
  endif
  If RTRIM$(VBACCT$)= ""
	pflag=pflag+1
    Message$=Message$+"Vend "+str$(h1[1])+"Bank Acct Error"
    K1$[3] = (H[0] + 1) Using "######"
    K1$[9,12] = "    "
    Goto L_2000
  End If 
  If rtrim$(VBROUTING$) = "   " Or VBROUTING$ = ""
    pflag=pflag+1
	Message$=Message$+"Vend "+str$(h1[1])+"Bank Route Error"
    K1$[3] = (H[0] + 1) Using "######"
    K1$[9,12] = "    "
    Goto L_2000
  End If 
  endvendchk: ! 
  Mat Read #CH,R[2],20;H$;
  Mat Read #CH,R[2],50;H1$;
  Mat Read #CH,R[2],62;H2;
  Mat Read #CH,R[2],80;N3; \ Mat Read #CH,R[2],86;N5;
  Mat Read #CH,R[2],94;EXDATE;
  If Not(CHKDATE)
    If EXDATE
      If Not(H1[1])
        K1$[3] = (H[0] + 1) Using "######"
		K1$[9]="                        "
      End If 
      Goto L_2000
    End If 
  End If 
  Mat Read #CH,R[2],94;EXDATE
  EXDATE = CURDATE
  Mat Write #CH,R[2],94;EXDATE;
  ISSDATE = H[2]
  If N3 <> A5 Goto L_2000
  If C <> 0
    If C <> H
      CHECKAMT = T1[2]
      Gosub L_3000
      NAME$ = ""
      C = 0
    End If 
  End If 
  If NAME$ <> "" If NAME$[1,30] <> H$[1,30]
    CHECKAMT = T1[2]
    Gosub L_3000
    NAME$ = ""
    C = 0
  End If 
  If Not(H1[1]) ! ap transaction
    K5$ = " ",K5$;K5$[1,6] = N5 Using "######"
    K5$[7,12] = H[0] Using "######"
    K5$[20,20] = "9"
    Search #6,2,1;K5$,R[6],E \ If E > 1 Gosub ERR_SEARCH
    If E = 1
      K5$[20,20] = "8"
      Search #6,2,1;K5$,R[6],E \ If E > 1 Gosub ERR_SEARCH
    End If 
    If Not(E)
      Mat Read #6,R[6],0;M;
      Mat Read #6,R[6],4;M$;
      Mat Read #6,R[6],16;M1;
      Mat Read #6,R[6],52;M2;
      C = H[0]
      ISSDATE = H[2];CHECKAMT = (M2[2] - M2[3])
      NAME$ = H$[1,30]
      If K5$[20,20] = "8"
        CHECKAMT = - (Abs(CHECKAMT))
      End If 
      Gosub L_3000
    End If 
    K1$[3] = H[0] + 1 Using "######"
	K1$[9]="                        "
    C = 0;NAME$ = ""
    Goto L_2000
  End If 
  C = H
  NAME$[1,30] = H$[1,30]
  Gosub L_5000
  Goto L_2000
GETNEXTCH: Rem get next month file
  If C
    CHECKAMT = T1[2]
    Gosub L_3000
    C = 0;NAME$ = ""
  End If 
  For X = 0 To 2 \ T1[X] = 0 \ Next X
Next CH
Goto SRCHBANK

L_3000: Rem PRINT CHECK TOTAL - BPR
If Not(C) Goto L_3050
CHECKPROC = CHECKPROC + 1
If Not(Fra(CHECKPROC / 50))
  ! Print Using "######";@0,23;'CL';"Current Number of Checks Processed ";CHECKPROC;
End If 

KEYVBNK$ = " ",KEYVBNK$
KEYVBNK$[1,6] = H[1] Using "######"
Search #12,2,1;KEYVBNK$,R[12],E \ If E <> 0 Gosub ERR_SEARCH
Mat Read #12,R[12],8;VBROUTING$;
Mat Read #12,R[12],16;VBROUTEDIGIT$;
Mat Read #12,R[12],18;VBID$;
Mat Read #12,R[12],34;VBNAME$;
Mat Read #12,R[12],64;VBACCT$;
Mat read #12,r[12],104;vbemail$;
Rem!!!! ********* Entry Detail Record (6) ************
IF PAYMODEX<>0
	GOTO Paymodexchk: 
endif
If wfflag<>0 or peopleflag<>0 or provflag<>0
	TEXT$ = " ",TEXT$
	text$=""
	TEXT$[1,1] = "6" ! 1. Record Type Code The code identifying an Entry Detail Record is 6.
	TEXT$[2,3] = "22"! 2. Transaction Code Two digit code identifying the account type at the receiving financial institution: 22 - Deposit destined for a Checking Account 23 - Prenotification for a checking credit 24 - Zero dollar with remittance into Checking         Account 27 - Debit destined for a Checking Account 28 - Prenotification for a checking debit 29 - Zero dollar with remittance into Checking         Account 32 - Deposit destined for a Savings Account 33 - Prenotification for a savings credit 34 - Zero dollar with remittance into Savings         Account 37 - Debit destined for a Savings Account 38 - Prenotification for a Savings debit 39 - Zero dollar with remittance into Savings         Account  
	iF CHECKAMT=0 LET TEXT$[2,3]="24"
	IF CHECKAMT<0 LET TEXT$[2,3]="23"
	TEXT$[4,11] = rtrim$(VBROUTING$)+blank$! 3. Receiving DFI Identification Transit routing number of the receiver’s financial institution. 
	TEXT$[12,12] = rtrim$(VBROUTEDIGIT$)+blank$  !4. Check Digit The ninth digits of the receiving financial institutions transit routing number.
	TEXT$[13,29] = rtrim$(VBACCT$)+blank$ ! 5. DFI Account Number Receiver’s account number at their financial institution. Left justify. 
	TEXT$[30,39] = (CHECKAMT * 100) Using "&&&&&&&&&&"
	! 6. Amount Transaction amount in dollars with no decimal places. Left zero fill if necessary. Enter 10 zeros for prenotes.
	! If CHECKAMT < 0 Let TEXT$[30,30] = "-"
	TEXT$[40,54] = rtrim$(VBID$)+blank$   ! 7. Individual Identification Number 
	TEXT$[55,75] = rtrim$(VBNAME$)+blank$ ! 8. Individual Name 
	text$[76,78] = blank$[76,78]
	TEXT$[79,79] = "0" ! 9. Discretionary Data  -- if If there is no addenda accompanying this transaction enter “0”. If addenda is accompanying the transaction enter “1”
	TEXT$[80,87] =  rtrim$(bankroute$[1,8])+blank$ ! using the bank route as the identifier
	TEXT$[88,94] = CHECKPROC Using "&&&&&&&"
	LINECOUNT = LINECOUNT + 1
	Print #0;TEXT$
	
	TMP3 = VBROUTING$
	ENTRYHASH = ENTRYHASH + TMP3
else
	TEXT$ = " ",TEXT$
	TEXT$[1,1] = "6"
	TEXT$[2,3] = "22"
	TEXT$[4,11] = VBROUTING$
	TEXT$[12,12] = VBROUTEDIGIT$
	TEXT$[13,29] = VBACCT$
	TEXT$[30,39] = (CHECKAMT * 100) Using "&&&&&&&&&&"
	If CHECKAMT < 0 Let TEXT$[30,30] = "-"
	TEXT$[40,54] = VBID$
	TEXT$[55,75] = VBNAME$
	TEXT$[79,79] = "0"
	!TEXT$[80,87] = "02100002"
	TEXT$[80,87] =  "01201201"
	TEXT$[88,94] = CHECKPROC Using "&&&&&&&"
	Print #0;TEXT$
	LINECOUNT = LINECOUNT + 1
	TMP3 = VBROUTING$
	ENTRYHASH = ENTRYHASH + TMP3
endif
! if addedum is needed put in here for type 7 - see routine 3200
TEXT$ = " ",TEXT$
if emailflag<>0
	if rtrim$(vbemail$)<>"" gosub createemail: ! 
endif
!! createemail#
L_3050: For I = 0 To 4
  T1[I] = 0
Next I
If CHECKAMT <> 0
  CHKTOT = CHKTOT + CHECKAMT
  If CHECKAMT < 0 Let DEBITTOT = DEBITTOT + CHECKAMT
  If CHECKAMT > 0 Let CREDITTOT = CREDITTOT + CHECKAMT
End If 
Return 

Paymodexchk: ! print - Record type "P" for payment
let text$=""
let text$="P",fdel$
let text$=text$,"ACH",fdel$
let text$=text$,RTRIM$(A5$),fdel$ ! use bank description for disbursing bank id
let text$=text$,rtrim$(BANKROUTE$),FDEL$ ! bank route
let text$=text$,rtrim$(BANKACC$),fdel$ ! vend bank acct
let text$=text$,rtrim$(vbname$),fdel$ ! vendor bank name
let text$=text$,str$(c),fdel$ ! check #
let text$=text$, checkamt using "#######.##",fdel$
let text$=text$,str$(h[1]),fdeL$
let text$=text$+str$(h[1])+"-"+rtrim$(companyid$)+fdel$ ! additional vendor code
let text$=text$,rtrim$(name$),fdel$
! per paymodex discussion 09/16/15 do not need debit date or currency/do not need place holders
!let text$=text$,"USD",fdel$
!let tmp$=h[2] using "&&&&&&"  
!let text$=text$,"20"+tmp$[1,6],fdel$ ! yyyymmdd format 
print #0;text$
let totpay=totpay+1
let totpayamt=totpayamt+checkamt

KEYCHK$ = " ",KEYCHK$;KEYCHK$[1,2] = A5 Using "##"
KEYCHK$[3,8] = C Using "######"
KEYCHK1$ = KEYCHK$[1,8]
do ! Rem search detail for check info
	Search #CH,3,1;KEYCHK$,R[0],E
	If E = 2 exit do
	If KEYCHK$[1,8] <> KEYCHK1$[1,8] exit do
	Mat Read #CH,R[0],16;H1;
	If H1[1] = 9 exit do
	mat read #ch,r[0],0;h;
	Mat Read #CH,R[0],20;H$;
	Mat Read #CH,R[0],50;H1$;
	Mat Read #CH,R[0],62;H2;
	Mat Read #CH,R[0],80;N3; \ Mat Read #CH,R[2],86;N5;
	Mat Read #CH,R[0],94;EXDATE;
	let keyapm$=" ",keyapm$
	let keyapm$[1,6]= H[1] using "######"
	let keyapm$[7,18]=H1$[1,12] 
	let keyapm$[19,20]=h1[0] using "##"
	let tmp$=keyapm$[1,20]
	let apm3$=" ",apm3$
	search #14,3,1;keyapm$,rec_apm,e
	if not(e) and tmp$[1,20]=keyapm$[1,20]
		mat read #14,rec_apm,98;apm3$;
	endif
	K5$ = " ",K5$;K5$[1,6] = h[1] Using "######"
    K5$[7,18] = H1$[1,12]
    K5$[19,20] = h1[0] using "##"
	M1[7]=0
    Search #6,2,1;K5$,R[6],E 
    If Not(E)
      Mat Read #6,R[6],0;M;
      Mat Read #6,R[6],4;M$;
      Mat Read #6,R[6],16;M1;
      Mat Read #6,R[6],52;M2;
	ENDIF
	! remittance section !paymodex
	let text$=""
	let text$="R",fdel$
	let text$=text$,str$(C),fdel$ ! PAYMENT REF/CHECK #
	let text$=text$,rtrim$(H1$[1,12]),fdel$ ! invoice number
	let tmp$=h[3] using "&&&&&&"
	let text$=text$,"20"+tmp$[1,6],fdel$ ! invoice date yyyymmdd
	let text$=text$,h2[2] using "--------.##",fdel$ ! payment amount
	let text$=text$,h2[0] using "--------.##",fdel$ ! orginal amount
	let text$=text$,h2[1] using "--------.##",fdel$ !  discount amount
	let text$=text$,"",fdel$ ! discount %
	let text$=text$,h[1] using "######"  ,fdel$! buyer account
	let text$=text$,rtrim$(apm3$),fdel$! comment
	let text$=text$,"",fdel$ ! voucher #
	let text$=text$,M1[7] using "######",fdel$! po number 
	let text$=text$,"",fdel$ ! contract
	let text$=text$,"",fdel$ ! tax amount
	let text$=text$,"",fdel$ ! tax rate
	print #0;text$
	let totremit=totremit+1
loop


return ! end of paymode x 

L_3200: Rem RMR LOOP ! loop of transactions
if wfflag<>0 and ediflag<>0
	Print #0;TSTR$;"3FW1"
	KEYCHK$ = " ",KEYCHK$;KEYCHK$[1,2] = A5 Using "##"
	KEYCHK$[3,8] = C Using "######"
	KEYCHK1$ = KEYCHK$[1,8]
	SRCHRMR: Rem search detail for check info
	Search #CH,3,1;KEYCHK$,R[0],E
	If E = 2 Return 
	If KEYCHK$[1,8] <> KEYCHK1$[1,8] Return 
	Mat Read #CH,R[0],16;H1;
	If H1[1] = 9 Goto L_2000
	Mat Read #CH,R[0],20;H$;
	Mat Read #CH,R[0],50;H1$;
	Mat Read #CH,R[0],62;H2;
	Mat Read #CH,R[0],80;N3; \ Mat Read #CH,R[2],86;N5;
	Mat Read #CH,R[0],94;EXDATE;
	TMP$ = "IV"
	If H1[0] = 2 Let TMP$ = "CM"
	Print #0;TSTR$;"3FH";TMP$
	Print #0;TSTR$;"3F7";H1$[1,12]
	Print #0;TSTR$;"3F8";
	Print #0; Using "----------.##";H2[2]
	Print #0;TSTR$;"3FK";
	Print #0; Using "----------.##";H2[0]
	Print #0;TSTR$;"3F9";
	Print #0; Using "----------.##";H2[1]
	Print #0;TSTR$;"AMK";
	Print #0;"INV"
	Print #0;TSTR$;"AM9";
	If H1[0] = 2
		Print #0;"Credit No. ";
	Else 
		Print #0;"Invoice No. ";
	End If 
	Print #0;H1$[1,12]
	Print #0;TSTR$;"0EP";"003"
	Print #0;TSTR$;"0EQ";
	Print #0;"20";
	X$ = H[3] Using "&&&&&&"
	Print #0;X$
	Goto SRCHRMR
else
	text$=" ",text$
	let addnum=1 ! start with 1
	let entseq=1 ! start with 1
	KEYCHK$ = " ",KEYCHK$;KEYCHK$[1,2] = A5 Using "##"
	KEYCHK$[3,8] = C Using "######"
	KEYCHK1$ = KEYCHK$[1,8]
	SRCHMCR: Rem search detail for check info
	Search #CH,3,1;KEYCHK$,R[0],E
	If E = 2 Return 
	If KEYCHK$[1,8] <> KEYCHK1$[1,8] Return 
	Mat Read #CH,R[0],16;H1;
	If H1[1] = 9 Goto L_2000
	Mat Read #CH,R[0],20;H$;
	Mat Read #CH,R[0],50;H1$;
	Mat Read #CH,R[0],62;H2;
	Mat Read #CH,R[0],80;N3; \ Mat Read #CH,R[2],86;N5;
	Mat Read #CH,R[0],94;EXDATE;
	Text$=" ",text$
	text$[1,1]="7" ! 1. Record Type Code The code identifying an Addenda Record is 7. 
	text$[2,3]="05"! 2. Addenda Type Code Two digit code identifying the type of information contained in the addenda record: 02 - Used for the POS, MTE and SHR standard entry classes. The Addenda information is used for terminal location information. 05 - Used for CCD, CTX and PPD standard entry classes. The Addenda information contains additional payment related information. 98 - Used for Notification of Change entries. The addenda record contains the correct information. 99 - Used for Return Entries. 
	! 3. Payment Related Information This field contains additional information associated with the payment. The information can be human readable or in ANSI format. 
	text$[4,4]=tstr$[1,1] 
	TMP$ = "IV"
	If H1[0] = 2 Let TMP$ = "CM"
	text$[5,6]=tmp$[1,2] ! type
	text$[7,7]=tstr$
	text$[8,19]=h1$[1,12]! transaction number
	text$[20,20]=tstr$
	text$[21,33]=h2[2] Using "----------.##" ! NET PAYMENT AMOUNT
	text$[34,34]=tstr$
	text$[35,47]=h2[0] Using "----------.##" ! GROSS AMOUNT
	text$[48,48]=tstr$
	text$[49,61]=h2[1] Using "----------.##" ! DISCOUNT AMOUNT
	text$[62,62]=tstr$
	X$ = H[3] Using "&&&&&&"
	text$[63,68]=X$ ! invoice date YYMMDD
	text$[69,69]="*"
	! end type 3
	text$[84,87]=addnum using "&&&&" !4. Addenda Sequence Number    
	text$[88,94]=entseq using "&&&&&&" ! 5. Entry Detail Sequence Number 
	let entseq=1
	Goto SRCHMCR
else
endif
Return 
DISPSCREEN: Rem display screen
!Print @0,0;'CS'; Tab 20;"A/P Check Number Extraction Process";
!Print @0,5;"1> Bank Code ";
!Print @0,8;"2> Check Date ";
Return 
DISPDATA: Rem display data
!Print @15,5;PBANKCODE$[1,4];
!If CHKDATE ! YYMMDD
 ! J2$ = CHKDATE Using "&&&&&&"
 ! I$ = J2$[3,4],"/",J2$[5,6],"/",J2$[1,2]
 ! Print @25,15;I$[1,8];
 ! I1$ = I$[7,8],I$[1,2],I$[4,5] \ DATE = I1$
 ! X2 = DATE \ Gosub L_7820 \ JDATE = 0
 ! JDATE = X2
!Else 
!  Print Using "&";@15,8;CHKDATE;
!  JDATE = 0
!End If 
Return 
L_5000: Rem PRINT LINE
For I = 0 To 2
  T1[I] = T1[I] + H2[I]
Next I
Return 
L_8900: Rem PUT DATE FROM X2 INTO P$
P$ = " ",P$
If Not(X2) Return 
U5$ = X2 Using "&&&&&&"
P$[1,2] = U5$[3,4]
P$[3,3] = "/"
P$[4,5] = U5$[5,6]
P$[6,6] = "/"
P$[7,8] = U5$[1,2]
P$ = U5$[3,6],U5$[1,2]
Return 
L_7820: Rem  CONVERT YYMMDD TO JULIAN (RETURN=NOGOOD, +1=OKAY)
X$ = X2 Using "&&&&&&"
Call DateToJulian(1,X$,X$,E) \ If E Return 
X2 = X$[1,5] \ Return 1

L_9100: Rem END OF RANGE
if paymodex<>0
	if totpay=0 and totpayamt=0 and totremit=0
		goto outend: ! no file created 
	endif
	let text$="C",fdel$
	let text$=text$+ltrim$(totpayamt using "##########.##"),fdel$
	let text$=text$+ltrim$(totpay using "##########"),fdel$
	let text$=text$+ltrim$(totremit using "###########"),fdel$
	print #0;text$
	goto endfilecreate: !
endif
if ediflag=0
If custom_customer$="BUTLER" and (ABS(CREDITTOT)<>0) ! need a debit adjustment
	KEYVBNK$ = " ",KEYVBNK$
	KEYVBNK$[1,6] = "999999"
	Search #12,2,1;KEYVBNK$,R[12],E \ If E > 1 Gosub ERR_SEARCH
	If E = 1
		let pflag=pflag+1
		Let message$=Message$+"Error Vendor "+str$(h[1])+" Bank Acct" 
		goto endbut:    
	End If 
	Mat Read #12,R[12],0;VB1;
	Mat Read #12,R[12],4;VB2;
	If VB2[1] <> 10 ! bank # 10 for ach info	
		let pflag=pflag+1
		Let message$=Message$+"Error Vendor "+str$(h[1])+" Ach Bank" 
		goto endbut:
	End If 
	Mat Read #12,R[12],8;VBROUTING$;
	Mat Read #12,R[12],16;VBROUTEDIGIT$;
	Mat Read #12,R[12],18;VBID$;
	Mat Read #12,R[12],34;VBNAME$;
	Mat Read #12,R[12],64;VBACCT$;
	TEXT$ = " ",TEXT$
	text$=""
	TEXT$[1,1] = "6" ! 1. Record Type Code The code identifying an Entry Detail Record is 6.
	TEXT$[2,3] = "27"! 2. Transaction Code Two digit code identifying the account type at the receiving financial institution: 27 - Debit adj
	TEXT$[4,11] = rtrim$(VBROUTING$)+blank$! 3. Receiving DFI Identification Transit routing number of the receiver’s financial institution. 
	TEXT$[12,12] = rtrim$(VBROUTEDIGIT$)+blank$  !4. Check Digit The ninth digits of the receiving financial institutions transit routing number.
	TEXT$[13,29] = rtrim$(VBACCT$)+blank$ ! 5. DFI Account Number Receiver’s account number at their financial institution. Left justify. 
	TEXT$[30,39] = (ABS(CREDITTOT) * 100) Using "&&&&&&&&&&"
	TEXT$[40,54] = rtrim$(VBID$)+blank$   ! 7. Individual Identification Number 
	TEXT$[55,75] = rtrim$(VBNAME$)+blank$ ! 8. Individual Name 
	text$[76,78] = blank$[76,78]
	TEXT$[79,79] = "0" ! 9. Discretionary Data  -- if If there is no addenda accompanying this transaction enter “0”. If addenda is accompanying the transaction enter “1”
	TEXT$[80,87] = rtrim$(orgbankroute$[1,8])+blank$ ! rtrim$($[1,8])+blank$ ! using the bank route as the identifier
	Text$[88,88] = VBROUTEDIGIT$[1,1] !TEXT$[88,94] = CHECKPROC Using "&&&&&&&" ! SYSTEM DATE
	!Text$[89,90]= (Tim(9) Using "##")
	!Text$[91,92]= (Tim(10) Using "&&")
	!text$[93,94]= (Tim(8) Using "&&")
	LET CHECKPROC=CHECKPROC+1
	LINECOUNT = LINECOUNT + 1
	TEXT$[88,94] = CHECKPROC Using "&&&&&&&"
	Print #0;TEXT$
	TMP3 = VBROUTING$
	ENTRYHASH = ENTRYHASH + TMP3
	let debittot=debittot+abs(credittot)
	endbut: ! 
endif
if wfflag<>0 or peopleflag<>0 or provflag<>0
	TEXT$ = " ",TEXT$
	text$=""
	TEXT$[1,1] = "8" ! 1. Record Type Code The code identifying the Batch Control Record is 8.
	TEXT$[2,4] = "200" ! 2. Service Class Code Identifies the type of entries in the batch: 200 - ACH Entries Mixed Debits and Credits 220 - ACH Credits Only 225 - ACH Debits Only  
	TEXT$[5,10] = checkproc Using "&&&&&&" ! 3. Entry / Addenda Count Total # of entry detail and addenda records processed within the batch. This field requires six positions; right justify and use leading zero
	TEXT$[11,20] = ENTRYHASH Using "&&&&&&&&&&" ! 4. Entry Hash Total of all positions 4-11 on each 6 record (Detail). Only use the final 10 positions in the entry.
	TEXT$[21,32] = (DEBITTOT * 100) Using "&&&&&&&&&&&&" ! 5. Total Debit Entry Dollar Amount Dollar totals of debit entries within the batch. If none, zero fill the field. 
	TEXT$[33,44] = Abs(CREDITTOT * 100) Using "&&&&&&&&&&&&" ! 6. Total Credit Entry Dollar Amount Dollar totals of credit entries within the batch. If none, zero fill the field. 
	TEXT$[45,54]  = rtrim$(orgbankacc$[1,10])+blank$ !7. Company Identification. This should match the company identification number used in the corresponding batch header record, field 5.	 
	! text$[55,73] !8. Message Authentication Code This is an optional field. Please leave this field blank.	 
	! text$[74,79] !9. Reserved  This field is reserved for Federal Reserve use. Please leave this field blank.
	if custom_customer$="BUTLER"
		LET TEXT$[45,54]="041138830"+BLANK$
	endif
	Text$[55,79]=blank$[55,79]
	TEXT$[80,87] = rtrim$(orgbankroute$[1,8])+blank$ ! 10. Originating Financial Institution ID Enter LaSalle’s routing number 07100050, or Standard Federal’s transit routing number of 07200080.	
	TEXT$[88,94] = "0000001" !11. Batch Number Number of the batch associated with this control record.
	Print #0;TEXT$
	LINECOUNT = LINECOUNT + 1
	TEXT$ = " ",TEXT$
	text$=""
	TEXT$[1,1] = "9" ! 1. Record Type Code The code for the File Control Record is 9.
	TEXT$[2,7] = "000001" ! 2. Batch Count The total number of batch header records in the file.
	TMP3 = Int(CHECKPROC / 10)
	If Fra((CHECKPROC / 10)) > 0 Let TMP3 = TMP3 + 1
	If TMP3 <= 0 Let TMP3 = 1
	TEXT$[8,13] = TMP3 Using "&&&&&&" ! 3. Block Count The total number of physical blocks on the file, including the File Header and File Control records.
	TEXT$[14,21] = CHECKPROC Using "&&&&&&&&" ! 4. Entry / Addenda Count Total number of entry detail and addenda records on the file. 
	TEXT$[22,31] = ENTRYHASH Using "&&&&&&&&&&" ! 5. Entry Hash Total of all positions 4-11 on each 6 record (Detail). Only use the final 10 positions in the entry.
	TEXT$[32,43] = (DEBITTOT * 100) Using "&&&&&&&&&&&&" !6. Total Debit Entry Dollar Amount in File-Dollar totals of debit entries within the file. If none, zero fill the field. 
	TEXT$[44,55] = Abs(CREDITTOT * 100) Using "&&&&&&&&&&&&" !7. Total Credit Entry Dollar Amount in File-Dollar totals of credit entries within the file. If none, zero fill the field.
	! text$[56,94] = ! 8. Reserved Leave this field blank. 
	text$[56,94]=blank$[56,94]
	Print #0;TEXT$
else
	TEXT$ = " ",TEXT$
	TEXT$[1,1] = "8"
	TEXT$[2,4] = "200"
	TEXT$[5,10] = CHECKPROC Using "&&&&&&"
	TEXT$[11,20] = ENTRYHASH Using "&&&&&&&&&&"
	TEXT$[21,32] = (DEBITTOT * 100) Using "&&&&&&&&&&&&"
	TEXT$[33,44] = Abs(CREDITTOT * 100) Using "&&&&&&&&&&&&"
	!TEXT$[45,54] = "1838186530"
	TEXT$[45,54]  = "1850018500"
	!TEXT$[80,87] = "02100002"
	TEXT$[80,87] = "01201201"
	TEXT$[88,94] = "0000001"
	Print #0;TEXT$
	LINECOUNT = LINECOUNT + 1
	TEXT$ = " ",TEXT$
	TEXT$[1,1] = "9"
	TEXT$[2,7] = "000001"
	TMP3 = Int(CHECKPROC / 10)
	If Fra((CHECKPROC / 10)) > 0 Let TMP3 = TMP3 + 1
	If TMP3 <= 0 Let TMP3 = 1
	TEXT$[8,13] = TMP3 Using "&&&&&&"
	TEXT$[14,21] = CHECKPROC Using "&&&&&&&&"
	TEXT$[22,31] = ENTRYHASH Using "&&&&&&&&&&"
	TEXT$[32,43] = (DEBITTOT * 100) Using "&&&&&&&&&&&&"
	TEXT$[44,55] = Abs(CREDITTOT * 100) Using "&&&&&&&&&&&&"
	Print #0;TEXT$
endif
endif
endfilecreate: ! 
FTMPNAME$ = "/tmp/549tmp.txt"
!CMD$ = "xtod ",PTRNM$," > ",FTMPNAME$
if paymodex<>0
	if custom_customer$="JACKSON"
		let newfilename$=sourcedirname$+"jacksonnewell_payments_"+rtrim$(companyid$)+txtfile$
	endif
	goto submitfile:
endif
!System CMD$
NEWFILENAME$ = sourcedirname$ + "ACH.NASCA" + TXTFILE$
if custom_customer$="HATHAWAY"
	LET NEWFILENAME$=NEWFILENAME$+".txt"
endif
submitfile:! 
CMD$ = "mv ",PTRNM$," ",NEWFILENAME$
System CMD$
!Print @0,21;'CE RB';"End Process...  ";
!Print Using "######";@0,22;'CE RB';"Total Check(s) Processed ";CHECKPROC;
!Print Using "$#,###,###,###.##";" For the amount of ";CHKTOT;
!Print @0,23;'CL';"Press <CR> to return to menu ";
!Input Len (16384 + 1);""J$
!If J$ <> "" Goto L_9100
Goto OUTEND

createemail: !!!!!
if rtrim$(bankemail$)="" return ! build the file
Let keyamcr$=" ",keyamcr$
let keyamcr$[1,2]=a5 using "##"
let keyamcr$[3,8]=c using "######"
let keyamchk$=keyamcr$[1,8]
search #ch,3,1;keyamcr$,r1,e
if e<>0 return
if keyamcr$[1,8]<>keyamchk$[1,8] return                             
Mat Read #CH,R1,0;h;
Mat Read #CH,R1,86;N5;
if n5<=0 let n5=h[1]
let keypvb$=" ",keypvb$
let keypvb$[1,6]=n5 using "######"
search #12,2,1;keypvb$,rec_pvb,e
if e<>0 return
Mat Read #12,rec_pvb,64;pVBACCT$;
mat read #12,rec_pvb,104;pvbemail$;
if rtrim$(pvbemail$)="" return ! no email address for this vendor
if rtrim$(pvbemail$[50,50])="" and rtrim$(pvbemail$[51,194])<>""
	let pvbemail$[50,50]="," ! parse with a comma
endif
let pvbemail1$=""
for ctr=1 to 194 ! strip out spaces and null
	if rtrim$(pvbemail$[ctr,ctr])<>""
		let pvbemail1$=pvbemail1$+rtrim$(pvbemail$[ctr,ctr])
	endif
next ctr
let pvbemail$=pvbemail1$ 
let email1$=" ",email1$
let email2$=" ",email2$
CT = 0;POS_ = 1
gosub L_8000: ! parse email address
If rtrim$(field$)<>""
	let email1$=field$
else
	let email1$=trim$(pvbemail$)
endif
if trim$(email1$)=trim$(pvbemail$)
	let email2$=""
else
	if pos_>0 let email2$=trim$(pvbemail$[pos_])
	! let email2$=field$
endif
let email$=email1$
startemail: ! 
if emch>0
	Try 
		close #emch
	else 
		x=x ! rem this
	End Try
endif
let acctdigit$=" ",acctdigit$
for ctr=16 to 5 step -1
	if pvbacct$[ctr,ctr]<>" " goto endchkacc:
next ctr
endchkacc: !
if ctr>3 let acctdigit$=pvbacct$[(ctr-3),ctr] ! last 4 digits
Call "mxvaleaddr.dl4",emaIL$,X1,e$
If Not(X1)
	if trim$(email2$)="" return 
	let email$=trim$(email2$)
	let email2$=""
	goto startemail:
endif
SYS$ = "$/usr/ub/sys/email.report -f ''",bankemail$,"''"," -t ''",eMAIL$,"''"," -s ''","ACH Payment Remit","''"
SYS$ = SYS$," -c ''","Attached is your ACH Payment Remittance.","''"
if custom_customer$<>"BUTLER"
	SYS$ = SYS$," -C ''",bankemail$,"''"
endif
! -C {second email address}
CHAN = Findchannel() ! 99 \ Call "utchan5",CHAN
!Signal 2,X1,CHAN,E \ If E Gosub ERR_SEARCH
EMCH = CHAN
Open #EMCH,SYS$


!let remitfilename$="/tmp/achremit.txt"
!build #99,+"/tmp/achremit!"
!close #99
! open #99;remitfilename$
let emailword1$="deposit"
let emailword2$="credited"
if checkamt<0
	let emailword1$="withdrawal"
	let emailword2$="debited"
endif
if checkamt>=0
	Print #emch;"A payment from ";
else
	Print #emch;"A transaction from ";
endif
print #emch; rtrim$(payor$[1,30]);" in the amount of $";
Print #emch; trim$(checkamt using "##########.##")
Print #emch; "has been submitted to your bank account number ending ";acctdigit$;"." 
Print #emch; "The ";rtrim$(emailword1$);" should be ";rtrim$(emailword2$);" to this bank account within 3 business days."
Print #emch; "Please review your bank activity to confirm that this ";rtrim$(emailword1$);" is received."
Print #emch;"" 
Print #emch;"If this ";rtrim$(emailword1$);" is not ";rtrim$(emailword2$);" to your account within 3 business days, contact"
print #emch;"the ";rtrim$(payor$[1,30]);" Accounting department by e-mail or phone"
print #emch;""
Print #emch;"Additionally, if you have questions about the amount of the ";rtrim$(emailword1$);", the supporting"
print #emch;"documentation, or if your bank or contact information has changed please contact";
Print #emch;" the Accounting Department by e-mail or phone"
Print #emch;""
Print #emch;"Accounting Department E-Mail: ";rtrim$(bankemail$)
if rtrim$(phone$)<>"" 
	Print #emch;""
	Print #emch;"Accounting Department Telephone: "; ! add phone number to client file
	Print #emch;rtrim$(phone$)
endif
Print #emch;""
print #emch;""
Print #emch;" ----------------------  Remittance Advice  -----------------------"
Print #emch;"Invoice";tab 14;"P.O. #";tab 24;"Inv Date";tab 38;"Cash Amt";tab 53;"A/P Amt";tab 63;"Disc Amt" 
Print #emch;"------------";tab 14;"---------";tab 24;"--------";
Print #emch;tab 33;"-------------";tab 47;"-------------";tab 61;"----------"
! search by bank and check number
let keyamcr$=" ",keyamcr$
for ctr=0 to 2\let vtot[ctr]=0\next ctr
let keyamcr$[1,2]=a5 using "##"
let keyamcr$[3,8]=c using "######"
let keyamchk$=keyamcr$[1,8]
do
	search #ch,3,1;keyamcr$,r1,e
	if e<>0 exit do
	if keyamcr$[1,8]<>keyamchk$[1,8] exit do
	Mat Read #CH,R1,16;H1;                             
	Mat Read #CH,R1,0;h;                               
	Mat Read #CH,R1,20;H$;                             
	Mat Read #CH,R1,50;h1$;                            
	Mat Read #CH,R1,62;H2;                             
	Mat Read #CH,R1,80;N3; \ Mat Read #CH,R1,86;N5;  
	Mat Read #CH,R1,94;EXDATE; 
	let ponum=0
	let keyaph$=" ",keyaph$
	let keyaph$[1,6]=H[1] USING "######"
	LET keyaph$[7,18]=h1$[1,12]
	let keyaph$[19,20]=h1[0] using "##"
	search #6,2,1;keyaph$,rec_aph,e
	if not(e)
		mat read #6,rec_aph,16;aphm1;
		let ponum=aphm1[7]
	endif
	Print #emch;H1$[1,12];
	if ponum>0 Print #emch;using "######";tab 14;ponum;
	let x$=H[3] using "&&&&&&"
	Print #emch;tab 24;x$[3,4];"/";x$[5,6];"/";x$[1,2];
	Print #emch; using "----------.##";tab 33;h2[2]; ! payment amount
	Print #emch; using "----------.##";tab 47;h2[0]; ! ap amount
	Print #emch; using "-------.##";tab 61;h2[1]; ! discount
	Print #emch;""
	let vtot[0]=vtot[0]+h2[2]
	let vtot[1]=vtot[1]+h2[0]
	let vtot[2]=vtot[2]+h2[1]
loop
Print #emch;tab 33;"-------------";tab 47;"-------------";tab 61;"----------"
Print #emch; using "----------.##";tab 33;vtot[0]; ! payment amount
Print #emch; using "----------.##";tab 47;vtot[1]; ! ap amount
Print #emch; using "-------.##";tab 61;vtot[2]; ! discount	
Print #emch;" TOTAL"
Print #emch;tab 33;"-------------";tab 47;"-------------";tab 61;"----------"
! NOW LET SEND AN EMAIL
Try
	Close #emch
	let ch_emch=-1
	let totemail=totemail+1
else
	! rem
end try
if rtrim$(email2$)<>""
	let email$=trim$(email2$)
	let email2$=""
	goto startemail:
endif
RETURN

L_8000: Rem find string
field$=""
WK1$ = " ",WK1$
If pvbemail$[POS_,POS_] = "''"
  POS_ = POS_ + 1
  WK1$ = pvbemail$[POS_]
  Search WK1$,"''",CT
Else 
  WK1$ = pvbemail$[POS_]
  Search WK1$,",",CT
  IF CT> 0 If WK1$[CT,CT] = "," Let CT = CT - 1
End If 
WK$ = " ",WK$
IF CT>0
	WK$[1,CT] = WK1$[1,CT]
	If WK$[CT,CT] = "''" Let WK$[CT,CT] = ""
ENDIF
If POS_ = 1 If WK$[1,1] = "''" Let WK$[1,1] = " "
POS_ = POS_ + (CT + 1)
IF CT>0 FIELD$ = WK$[1,CT]
Return 

ISDUNPACK: Rem  *UNPACK DATE  X2 TO X$      V1.0  4/04/84  G.DOSCHER
X$ = " ",X$ \ X$[10] = ""
X$[1,3] = Int(X2 / 10 ^ 2 - Int(X2 / 10 ^ 4) * 10 ^ 2) + 10 ^ 2 Using "###"
X$[4,6] = Fra(X2 / 10 ^ 2) * 10 ^ 2 + 10 ^ 2 Using "###"
X$[7,9] = Int(X2 / 10 ^ 4) + 10 ^ 2 Using "###"
X$[4,4] = "/" \ X$[7,7] = "/" \ X$ = X$[2]
If Not(X2) Let X$ = "        "
Return 
ISDPACK: Rem  *PACK DATE    X$ TO X2      V1.0  4/04/84  G.DOSCHER
X2 = X$[4,5] \ X1 = X$[1,2] \ X2 = X2 + X1 * 10 ^ 2
X1 = X$[7,8] \ X2 = X2 + X1 * 10 ^ 4
Return 

ERR_SEARCH: Rem                         
ENUM = E;ELINE = Spc(16);CTERR = 0           
If E = 5 Let CTERR = Err(8)                  
msg$ = "RETURN STATUS",(E + (CTERR * .001))  
msg$ = msg$,"/ STATEMENT",ELINE," IN PROGRAM "
e$ = msg$ \ Error 10000                      
Return ! End                                 
If Msg$<>"" let e$=msg$ !  Error 10000 ! sent reason
ENUM = E ;ELINE = Spc(16);CTERR = 0

If E = 5 Let CTERR = Err(8)
e$ = "RETURN STATUS",(E + (CTERR * .001))
e$ = e$,"/ STATEMENT",ELINE," IN PROGRAM "
call programdump("tmp/549!","")
! goto err_msg ! Error 10000
Error 10000
Return ! End

ERR_MSG: ! send message
ReturnStatus=0! need report to print still
Message$=E$
!Call addtostr(e$,rstr$,esdel$) !end section -- DXBLOCK 
!call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
!call AddToStr(e$,rstr$,WebStr$)
!call SetOutPut(e$,rstr$)

OUTEND: Rem EXIT PROGRAM

L_9060: Rem end reset flag

if eflag<>0 let returnstatus=1 ! error

!Chain "MX000"
Call addtostr(e$,rstr$,esdel$) !end section -- DXBLOCK 
let returnstatus=0
If Eflag>0
	ReturnStatus=1 ! ALWAYS - OTHERWISE NO DISPLAY 1=issues
	tmp$=""
Endif
if not(eflag)
	if paymodex<>0
		if totpay=0 and totpayamt=0 and totremit=0
			let returnstatus=1 
			let message$=message$+" There are no checks to process. No file created. "
			Try
				close #0
				Kill ptrnm$
			else
				rem 
			end try
			goto endall:
		endif
	endif
	if not(CHECKPROC)
		returnstatus=1
		let message$=message$+"There are no checks available to process. No file created. "
		message$=message$+"."
		Try
				close #0
				Kill ptrnm$
			else
				rem 
			end try
			goto endall:
	else
		Let message$=message$+" "+str$(checkproc)+" Check(s) "
		if emailflag<>0
			if totemail<>0 let message$=message$+" "+str$(totemail)+ " Email(s) sent. "
		endif
		let message$=message$+" File Created: "+tmpfile$
		
	endif
endif
endall: ! end all here
call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
call AddToStr(e$,rstr$,WebStr$)
call SetOutPut(e$,rstr$)
try Call dxclose() else rem
Else
!
	include "src/callmainerrnet.inc"
	end try
End ! the whole program
