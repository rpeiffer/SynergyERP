! -- dxblockcallsx.lib
! library of page block routines called by custom applications
!
! loadsave -w -n 100,10 -o prog/dxport/dxblockcallsx.lib src/dxblockcallsx.src
!
! 1.0 01/19/2005 new
! x version for .net
!
!all rights reserved. (c)copyright 2005 by: dynamicconcepts
!
declare intrinsic function findchannel,dateusing$,replace$,fmtof
declare intrinsic sub dxget,dxset,dxsave,env,setglobals,getglobals,JulianToDate,DateToJulian
!
!
external lib "dxblockgeneral.lib" !general routines

declare external sub blocksuberr,blockmainerr,blockreadsystemfile,blockopenfiles

declare external function blockgetprogrampath$,blockcrc$,blockgetmsg$
!
external lib "dxblockcustom.lib"
declare external sub blockprintersdroplist,blockstatesdroplist
!
external lib "libgeneral.lib"
declare external sub addtostr
!
external lib "libfilehandler.lib"
declare external sub filehandler
!
include "src/dxblockfiles.bsh"
!
External Function blockDTconvert$(e$,value$,from$,too$)
  ! converts date in value$   from from$ format to too$ format
  ! returns e$ as error message if value$ is invalid date
  ! currently only MM DD YY YYYY options available in from format
  ! to format can be any DATEUSING$ format
 Try
  dim mask$[40],fromdate$[40],fromformat$[40],newvalue$[40],tmpdate$[8]
  dim 3%,date#,4%
  mask$="&",mask$
  e$="" !no error
  if value$="" or value$="0" exit function ""
  fromdate=value$
  fromdate$=fromdate using mask$[1,len(from$)] !in case no leading 0
  fromformat$=ucase$(from$)
  !arrange it to MMDDYYYY in tmpdate$
		xpos=pos(fromformat$,="M")
		if xpos=0 error 10001
		if xpos+1 > len(fromdate$) error 10000
		tmpdate$=fromdate$[xpos,xpos+1] !mm
		if xpos=0 error 10001
		xpos=pos(fromformat$,="D")
		if xpos+1 > len(fromdate$) error 10000
		tmpdate$=tmpdate$,fromdate$[xpos,xpos+1] !dd
        xpos=pos(fromformat$,="YYYY",-1)
		if xpos
		 if xpos+3 > len(fromdate$) error 10000
		 tmpdate$=tmpdate$,fromdate$[xpos,xpos+3] !yyyy
		else
		 xpos=pos(fromformat$,="YY",-1)
		 if xpos=0 error 10001
		 if xpos+1 > len(fromdate$) error 10000
		 tmpdate$=tmpdate$,"20",fromdate$[xpos,xpos+1] !yy
		 if val(tmpdate$[7,8])>50 let tmpdate$[5,6]="19" !assume
		end if
 mm=tmpdate$[1,2]\dd=tmpdate$[3,4]\yyyy=tmpdate$[5,8]
 try
  date#=dat#(yyyy,mm,dd)  
  newvalue$=dateusing$(date#,too$)
 else
  error 10000
 end try
Else
  if spc(8) = 10000 let e$="Invalid date!" \exit function ""
  if spc(8) = 10001 let e$="Invalid date from mask!"
  if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000 
 End Try
end function newvalue$ !blockDTconvert$
!
External Function eom$(...)
  ! returns last day of the month in mmddyy
  ! pass cnt to position forward or backward x months from today
  Dim date$[10]
  Try Enter cnt Else Let cnt = 0
  mm = Tim(9)
  yy = Tim(8)
  Do 
    If cnt = 0 Exit Do 
    If cnt < 0 Let mm = mm - 1 \ cnt = cnt + 1
    If cnt > 0 Let mm = mm + 1 \ cnt = cnt - 1
    If mm = 0 Let mm = 12 \ yy = yy - 1
    If mm = 13 Let mm = 1 \ yy = yy + 1
  Loop 
  For dd = 31 To 28 Step -1
    date$ = mm Using "&&",dd Using "&&",yy Using "&&"
    try
	 date#=dat#(yy,mm,dd)
     Exit For
	else
	end try
  Next dd
End Function date$ !eom$
!
External Sub replacetext(textstr$)
 !searches textstr$ for dl4v's and replaces with call dxsget value 
 do
  dim value$[100]
  xpos=pos(textstr$,="dl4v(")
  if xpos=0 exit do
  ypos=pos(textstr$[xpos],=")")
  if ypos=0 exit do
  call dxget(textstr$[xpos+5,xpos+ypos-2],value$)
  
  textstr$=replace$(textstr$,textstr$[xpos,xpos+ypos-1],value$)
 loop
end sub !replacetext
!
External Sub setproperties(e$,fields$[],rstr$)
!-----------------------------------------------------------------
 Try
  !put this in setproperties call for generated code to access for each field
  !call setproperties(e$,fields$[],rstr$)
   dim tmp$[1000]
   dim fdel$[10],rdel$[10],type$[20],type2$[20]
   dim helpname$[80],helpstr$[80],helpstr2$[5000],blockid$[8]
   call env(1,"FDEL",fdel$)
   call env(1,"RDEL",rdel$)
    type$=fields$[7]
	if len(type$)>=4 if type$[1,4]="LIST" let type$="LIST"
	if len(type$)>5 if type$[1,5]="RADIO" let type$="RADIO"
	type2$=type$
	if type$="LIST" let type2$="DROPDOWN" !conversion for .net
    tmp$="<control>Type",fdel$,type2$,fdel$,rdel$,"<property>Property",fdel$,"Value",fdel$,rdel$
    call addtostr(e$,rstr$,tmp$)  !for .net
	!
    if fields$[7]="DATE"
	 call getglobals("dfsystem",0,tmp$) !date format from dfsystem.txt file
	 fields$[22]=tmp$
	 tmp$="" !will become mmddyy
	 If UCase$(fields$[9]) = "T" Let tmp$ = Tim(4) Using "&&&&&&" !mmddyy
     If UCase$(fields$[9]) = "B" !beg of month
      If Tim(10) <= 15 Let tmp$ = eom$(-1) Else Let tmp$ = eom$()
      tmp$[3,4] = "01"
     End If 
     If UCase$(fields$[9]) = "E" !end of month
      If Tim(10) <= 15 Let tmp$ = eom$(-1) Else Let tmp$ = eom$()
     End If 
	 if tmp$<>"" let mm=tmp$[1,2]\dd=tmp$[3,4]\yy=tmp$[5,6]\date#=dat#(yy,mm,dd) \ let fields$[9]=dateusing$(date#,fields$[22]) !sets default to date using dateformat 
	end if !DATE
	!
    for i=0 to ubound(fields$[],1) !all the properties
     tmp$=""
     !if i=0 let tmp$="CtrlID",fdel$
	 if i=2 let tmp$="CtrlLbl",fdel$
	 if i=4 let tmp$="CtrlName",fdel$
	 !f i=7 let tmp$="Type",fdel$
	 if i=8 let tmp$="Required",fdel$
	 if i=9 let tmp$="Default",fdel$
	 if i=10 let tmp$="HelpText",fdel$
	 if i=16 let tmp$="IsReadOnly",fdel$
	 if i=17 let tmp$="NoTab",fdel$
	 if i=18 let tmp$="Focus",fdel$
	 if i=2 or i=9 or i=10 call replacetext(fields$[i])
     if tmp$<>"" call addtostr(e$,rstr$,tmp$,fields$[i]+fdel$+rdel$)  !for .net
    next i
    if fields$[19]<>""
	  call addtostr(e$,rstr$,"Link"+fdel$+fields$[19]+fdel$+rdel$)
	end if
    if fields$[7]="TEXT" if val(fields$[20])
	  call addtostr(e$,rstr$,"MinLength"+fdel$+fields$[20]+fdel$+rdel$)
	end if
	if fields$[7]="TEXT" if val(fields$[21])
	  call addtostr(e$,rstr$,"MaxLength"+fdel$+fields$[21]+fdel$+rdel$)
	end if
	if fields$[7]="NUMBER" if val(fields$[20])
	  call addtostr(e$,rstr$,"MinValue"+fdel$+fields$[20]+fdel$+rdel$)
	end if
	if fields$[7]="NUMBER" if val(fields$[21])
	  call addtostr(e$,rstr$,"MaxValue"+fdel$+fields$[21]+fdel$+rdel$)
	end if
	if fields$[7]="NUMBER" or fields$[7]="DATE" if fields$[22]<>""
	  call addtostr(e$,rstr$,"Mask"+fdel$+fields$[22]+fdel$+rdel$)
	end if
	if fields$[7]="CHECK" if rtrim$(fields$[23])<>""
	  tmp$=fields$[23],"          "
	  call addtostr(e$,rstr$,"Value"+fdel$+rtrim$(tmp$[1,10])+fdel$+rdel$)
	end if
	if type$="LIST" or type$="STATE"
	 tmp=fields$[24]\tmp$="N"\if tmp>1 let tmp$="Y"
	 call addtostr(e$,rstr$,"Multiple"+fdel$+tmp$+fdel$+rdel$)
    end if
    !
	!send field level long help text if file there
	call dxget(10,"blockid",blockid$) !in tmp table 
    call getglobals("dfsystem",7,tmp$) !helpdir$
    helpname$=tmp$,"block",blockid$,"_",fields$[1],".hlp"   !blockid_seq#
    helpchan=findchannel()
	helpstr2$=""
    try
     ropen #helpchan,helpname$
	 do
      read #helpchan;helpstr$;
	  if helpstr$="" exit do
	  call replacetext(helpstr$)
	  helpstr2$=helpstr2$,rtrim$(helpstr$)
	 loop
	 call addtostr(e$,rstr$,"LongHelpText"+fdel$+helpstr2$+fdel$+rdel$)
    else
    end try
    call addtostr(e$,rstr$,"</property>") !add to string, but don't put eor at end
	!end setproperties
 Else
  if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000 
 End Try
end sub !setproperties
!
!
External Sub setdata(e$,chaninplst,blockid$,fields2$[],rstr$)
!-----------------------------------------------------------------
 Try
  !put this in setdata call for generated code to access for each field
  !call setdata(e$,chaninplist,blockid$,fields2$[],rstr$)	!
    dim tmp$[3000],tmpblockid$[8]
	dim array$[100,100]  !for U_ defaults to be read in, up to 100, 100char fields
    dim fdel$[10],rdel$[10],type2$[20],holdfield$[120],holdlabel$[120]
	dim blockinplst. as blockinplst
    call env(1,"FDEL",fdel$)
    call env(1,"RDEL",rdel$)
	type2$=fields2$[7]
	if len(type2$)>=4 if type2$[1,4]="LIST" let type2$="LIST"
	if type2$="STATE" let type2$="LIST"
	if len(type2$)>5 if type2$[1,5]="RADIO" let type2$="RADIO"
	!start setdata
	if fields2$[7]="PRINTER" !create printer drop list data
	 tmp$="<data>Text",fdel$,"Value",fdel$,"IsDefault",fdel$,rdel$
	 call addtostr(e$,rstr$,tmp$)
	 !printer list
	 call blockprintersdroplist(rstr$)
     call addtostr(e$,rstr$,"</data>")
	else if fields2$[7]="LISTA" !special lista
	 tmp$="<data>Text",fdel$,"Value",fdel$,"IsDefault",fdel$,rdel$
	 call addtostr(e$,rstr$,tmp$)
	 tmp$="Active",fdel$,"1",fdel$,"Y",fdel$,rdel$
	 call addtostr(e$,rstr$,tmp$)
	 tmp$="Inactive",fdel$,"2",fdel$,"",fdel$,rdel$
	 call addtostr(e$,rstr$,tmp$)
	 tmp$="All",fdel$,"3",fdel$,"",fdel$,rdel$
	 call addtostr(e$,rstr$,tmp$)
     call addtostr(e$,rstr$,"</data>")
	else if fields2$[7]="STATE" !stateslit
	 tmp$="<data>Text",fdel$,"Value",fdel$,"IsDefault",fdel$,rdel$
	 call addtostr(e$,rstr$,tmp$)
	 call blockstatesdroplist(rstr$)
	 call addtostr(e$,rstr$,"</data>")
	else if type2$="LIST" or type2$="RADIO"
	 if type2$=fields2$[7] !std list or radio, read inplst file c[3]
	   tmp$="<data>Text",fdel$,"Value",fdel$,"IsDefault",fdel$,rdel$
	   call addtostr(e$,rstr$,tmp$)
	   if len(fields2$[29])>0 if fields2$[29,1,1]="R" or fields2$[29]="U" or fields2$[29]="UC" !if userdef1 is U  means read U_ variable of same field name to get defaults (set by a previous blockid)
	    !U_ defaults for drop lists not done yet, basically replicate code below for other control types (checkboxes)
	    !for drop lists it is coded such that it repeats drop list based on U_ or R  all the drop lists are the same
		call dxget("U_"+fields2$[4],array$[])
	    if fields2$[29]="UC" or fields2$[29]="R"  call dxset("U_"+fields2$[4],"")
	    holdfield$=fields2$[4]
	    holdlabel$=fields2$[2]
	    for cnt=0 to ubound(array$[],1)
	     if cnt>0  !have to create a separate control for each one in the array!
	      if array$[cnt]="" exit for
	      tmp$=tmp$,"</control>"
	      call addtostr(e$,rstr$,tmp$)
		  fields2$[4]=holdfield$,str$(cnt)    !first one, field name is as specified, rest are seq numbered, 1 thru x
          let fields2$[2]=holdlabel$," ",array$[cnt] 
		  call setproperties(e$,fields2$[],rstr$)
		  tmp$="<data>Text",fdel$,"Value",fdel$,"IsDefault",fdel$,rdel$
	      call addtostr(e$,rstr$,tmp$)
	     end if !cnt>0
	     if fields2$[28]<>"" and fields2$[28]<>" "!create droplist from file
	      call filehandler(e$,fields2$[28],rstr$,fields2$[30])
	     else
	      seq=-2
	      tmpblockid$=blockid$
	      blockseq=fields2$[1]
	      if fields2$[27]<>"0" !get drop list from common prompts
	       tmpblockid$="        "
		   blockseq=fields2$[27]
	      end if
          Try Search >= #chaninplst,1;tmpblockid$,blockseq Else Rem
          Do
           Try Read Record #chaninplst,seq;blockinplst. Else Exit Do
           if blockinplst.id$<>rtrim$(tmpblockid$) or blockinplst.seq<>blockseq exit do
		   call replacetext(blockinplst.label$)
		   call replacetext(blockinplst.value$)
           tmp$=blockinplst.label$,fdel$,blockinplst.value$,fdel$,"",fdel$,rdel$
   	       call addtostr(e$,rstr$,tmp$)
           seq=-1 !get next
          Loop
	     end if !from file or inplst
         call addtostr(e$,rstr$,"</data>")
	    next cnt
		!
		!end U_ and R for drop lists,radios
		!
	   else if fields2$[28]<>"" and fields2$[28]<>" "!create droplist from file
	    call filehandler(e$,fields2$[28],rstr$,fields2$[30])
	   else
	   seq=-2
	   tmpblockid$=blockid$
	   blockseq=fields2$[1]
	   if fields2$[27]<>"0" !get drop list from common prompts
	    tmpblockid$="        "
		blockseq=fields2$[27]
	   end if
       Try Search >= #chaninplst,1;tmpblockid$,blockseq Else Rem
       Do
        Try Read Record #chaninplst,seq;blockinplst. Else Exit Do
        if blockinplst.id$<>rtrim$(tmpblockid$) or blockinplst.seq<>blockseq exit do
		call replacetext(blockinplst.label$)
		call replacetext(blockinplst.value$)
        tmp$=blockinplst.label$,fdel$,blockinplst.value$,fdel$,"",fdel$,rdel$
   	    call addtostr(e$,rstr$,tmp$)
        seq=-1 !get next
       Loop
	   end if !from file or inplst
       call addtostr(e$,rstr$,"</data>")
	 end if
	else
	  if len(fields2$[29])>0 if fields2$[29,1,1]="R" or fields2$[29]="U" or fields2$[29]="UC" !if userdef1 is U  means read U_ variable of same field name to get defaults (set by a previous blockid)
	  !if its an array of data, send as an array of data, front end to generate multiples of the control for each default, and sequentially number them (ie multiple checkboxes)
      !UC indicates option to clear the U_field after getting it
	  call dxget("U_"+fields2$[4],array$[])
	   if fields2$[29]="UC" or fields2$[29]="R"  call dxset("U_"+fields2$[4],"")
	  holdfield$=fields2$[4]
	  holdlabel$=fields2$[2]
	  for cnt=0 to ubound(array$[],1)
	   if cnt>0  !have to create a separate control for each one in the array!
	    if array$[cnt]="" exit for
	    tmp$=tmp$,"</control>"
	    call addtostr(e$,rstr$,tmp$)
		fields2$[4]=holdfield$,str$(cnt)    !first one, field name is as specified, rest are seq numbered, 1 thru x
        let fields2$[2]=holdlabel$," ",array$[cnt] 
		if type2$="CHECK" let fields2$[23]=array$[cnt] !CHECKBOX, U_ controls # of checkboxes,concats the label and determines value sent
		call setproperties(e$,fields2$[],rstr$)
	   end if !cnt>0
	   tmp$="<data>",array$[cnt],fdel$,rdel$,"</data>"
	  next cnt
	 else
	  tmp$="<data>",fields2$[9],fdel$,rdel$,"</data>" !default
	 end if
	 call addtostr(e$,rstr$,tmp$)
	end if !control type data section
	!end setdata
 Else
  if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000 
 End Try
end sub !setdata
!
!
external sub setblock(e$,blockid$,action$,programname$,...)
!--------------------------------------------------------------------
! reads page definition for passed blockid and sets xport values for template
! acton passsed to help determine block type, table,edit or prompt
! if optional rstr$ sent, no dxset's, populate rstr$ instead
!
!
Dim BlockHdr. As BlockHdr, blockcol. as blockcol, blockinp. as blockinp
dim blockinplst. as blockinplst, blockbut. as blockbut
dim oldblockinp. as blockinp
Dim blockdefaults. As blockdefaults
dim blockdefaultskey. as blockdefaultskey
!
sub saveuserdefault(e$)
!--------------------------------------------------------------------
! saves an input default for a user,  called by hdrlist
 Try
	   blockdefaults.id$=blockinp.id$
	   blockdefaults.seq=blockinp.seq
	   blockdefaults.default$=blockinp.default$
	   blockdefaults.userid$=userid$
	   blockdefaultskey.id$=blockinp.id$,b$
	   blockdefaultskey.seq=blockinp.seq
	   blockdefaultskey.userid$=userid$,b$
	   !overwrite or add record to user defaults file #c[9]
	   Try
	    Search = #c[9],1;blockdefaultskey.
	    Write Record #c[9],-2;blockdefaults.;
	   Else
	    Add Record #c[9];blockdefaults.;
	   End Try
 else
  if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !saveuserdefault
!
function getuserdefault$(e$)
!--------------------------------------------------------------------
! gets an input default for a user,  called by inplist
 Try
	   blockdefaultskey.id$=blockinp.id$,b$
	   blockdefaultskey.seq=blockinp.seq
	   blockdefaultskey.userid$=userid$,b$
	   !read record from user defaults file #c[9]
	   Try
	    Search = #c[9],1;blockdefaultskey.
	    Read Record #c[9],-2;blockdefaults.;
	   Else
	    blockdefaults.default$="" !no default on file yet
	   End Try
 else
  if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end function blockdefaults.default$ !getuserdefault
!
sub hdrlist(e$,blockid$,rstr$)
!--------------------------------------------------------------------
! header routine
! dxset's block header parameters
! called by setblock!
 try
 !
  keys$=blockid$
  Try
   Search = #c[0],1;keys$ 
  Else 
   e$="Blockid ",blockid$," not in hdr"
   error 10000 
  End Try
  Read Record #c[0],-2;blockhdr.;
  !
  call dxset(10,"blockid",blockid$) !in tmp table for other programs to retrieve
  !
  if rtrim$(blockhdr.filename$)<>""
   type$=action$ !for SAVE and DELETE
   if action$="INPUT" or action$="SEARCH" let type$="TABLE" !else type$="EDIT"
   action$=type$
   programname$="block",replace$(blockhdr.filename$,".",""),".dl4"
   	if rtrim$(blockhdr.programname$)<>"" let programname$=rtrim$(blockhdr.programname$) !override
	if programname$[len(programname$)-3]<>".dl4" let programname$=programname$,".dl4"

   if action$="VERIFY" let programname$="libfile",blockhdr.filename$,".lib"
  else
   if action$="SAVE" let action$="PRINT"
   if action$="PRINT"
    !maybe save defaults
	call dxget("promptdefaults",tmp$)
	if tmp$<>""
		!loop thru prompts and save defaults
		keys$=blockid$
		seq=-2
		Try Search >= #c[2],1;keys$ Else Rem
		Do
			Try Read Record #c[2],seq;blockinp. Else Exit Do
			if blockinp.id$<>blockid$ exit do
			if blockinp.active$="Y"
				if rtrim$(blockinp.varname$)="" if blockinp.masterseq
					tmp$ = "        " !master blockid
					Try Search = #c[5],1;tmp$,blockinp.masterseq Else Rem
					Try Read Record #c[5],-2;oldblockinp. Else Rem
					blockinp.varname$=oldblockinp.varname$
				end if
				call dxget(blockinp.varname$,tmp$)
				if blockinp.type$="CHECK" and pos(blockinp.default$,="dl4v(")=0
					if tmp$<>"" let blockinp.default$="CHECKED" else let blockinp.default$="~"
				else
					if blockinp.type$="DATE" and (blockinp.default$="T" or blockinp.default$="B" or blockinp.default$="E")
						!don't overwrite
					else
						If blockinp.type$="DATE" and ucase$(rtrim$(blockinp.default$))="TODAY"
							! don't overwrite
						else
							If blockinp.type$="DATE" and ucase$(rtrim$(blockinp.default$))="DL4V(U_ARDATE)"
								! don't overwrite
							else
								blockinp.default$=tmp$
								IF rtrim$(blockinp.type$)="TEXT" and rtrim$(tmp$)="" let blockinp.default$=" ",blockinp.default$
							endif
						endif
					end if
				end if
				!!2/23/10 don't overwrite main defaults Write Record #c[2],-2;blockinp.;
				call saveuserdefault(e$) !new 2/12/10
			end if !active
			seq=-1
		loop
	end if !programdefaults
	!
    programname$=blockid$
	if rtrim$(blockhdr.programname$)<>"" let programname$=rtrim$(blockhdr.programname$) !override
    if len(programname$)<5  let programname$=programname$,".dl4"
	if programname$[len(programname$)-3]<>".dl4" let programname$=programname$,".dl4"
	exit sub  !!!!!!!!!!!!!!move on to print program
   else
    type$="PROMPT" !printprompts
   end if
  end if
  !
  call replacetext(blockhdr.title$)
  call replacetext(blockhdr.subtitle$)
  !
  if rstr$="" !not used at UBS
  call dxset("blockid",blockid$)
  call dxset("description",blockhdr.desc$)
  Call dxset("filename",blockhdr.filename$)
  Call dxset("programname",blockhdr.programname$)
  Call dxset("title",blockhdr.title$)
  call dxset("subtitle",blockhdr.subtitle$)
  call dxset("include1",blockhdr.include1$)
  call dxset("include2",blockhdr.include2$)
  call dxset("custom1",blockhdr.custom1$)
  call dxset("custom2",blockhdr.custom2$)
  call dxset("custom3",blockhdr.custom3$)
  call dxset("rowlink",blockhdr.rowlink$)
  call dxset("evenodd",blockhdr.evenodd$)
  else
   !populate rstr$
   !?? or xml ??
   tmp$="<block>BLOCKID",fdel$,"TYPE",fdel$,"TITLE",fdel$,"SUBTITLE",fdel$
   !optionals  ADD,EDIT,ORIGID
   flag=0
   if type$="TABLE"  !see if inplists defined, if so, it is maintenance page (not inquiry table) show add button and edit links
    keys$=blockid$
	flag=1 !on file
    Try Search >= #c[2],1;keys$ Else let flag=0
    Try Read Record #c[2],-2;blockinp.; Else let flag=0
    if blockinp.id$<>blockid$ let flag=0
	if flag=1 let tmp$=tmp$,"ADD",fdel$,"EDIT",fdel$
   end if !table
   call dxget("ID",id$) !change mode,not add mode
   if id$<>"" let tmp$=tmp$,"ORIGID",fdel$
   tmp$=tmp$,rdel$ 
   call addtostr(e$,rstr$,tmp$) !blockid headers row
   tmp$=blockid$,fdel$,type$,fdel$,blockhdr.title$,fdel$,blockhdr.subtitle$,fdel$
   !optionals  ADD,EDIT,ORIGID
   if id$<>"" let tmp$=tmp$,id$,fdel$
   if flag let tmp$=tmp$,"Y",fdel$,"Y",fdel$
   tmp$=tmp$,rdel$ 
   !tmp$=tmp$,blockhdr.desc$,fdel$,blockhdr.filename$,fdel$,blockhdr.title$,fdel$
   !tmp$=tmp$,blockhdr.subtitle$,fdel$,blockhdr.include1$,fdel$,blockhdr.include2$,fdel$
   !tmp$=tmp$,blockhdr.custom1$,fdel$,blockhdr.custom2$,fdel$,blockhdr.custom3$,fdel$
   !tmp$=tmp$,blockhdr.rowlink$,fdel$,fdel$,blockhdr.evenodd$,fdel$
   call addtostr(e$,rstr$,tmp$) !blockid data row
  end if !rstr$
  !
  if type$="PROMPT" let type$=type$,blockhdr.custom1$  !if custom1="1" no printer prompt, or list of any printers to exclude from droplist
  !
else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !hdrlist
!
sub collist(e$,blockid$,rstr$)  !8/09 is used.....not used, in each file's code generated program
!--------------------------------------------------------------------
! columns routine
! dxset's block column parameters
! called by setblock!
 try
 !
  fieldcnt=11
  maxrowcnt=50
  free fields$
  dim fields$[maxrowcnt,fieldcnt,120] !#cols,#rows,maxfieldlength
  keys$=blockid$
  seq=-2
  Try Search >= #c[1],1;keys$ Else Rem
  Do
   Try Read Record #c[1],seq;blockcol.; Else Exit Do
   if blockcol.id$<>blockid$ exit do
   if cnt>maxrowcnt exit do
   !
   !if inpseq defined, use it as defaults/override
   if blockcol.inpseq
    Try
     Search = #c[2],1;blockid$,blockcol.inpseq
     Read Record #c[2],-2;blockinp.
	 !override the column definitions with the input definitions
	 blockcol.label$=blockinp.label$
	 blockcol.active$=blockinp.active$
	 blockcol.varname$=blockinp.varname$
	 blockcol.mask$=blockinp.mask$
    Else
     !shouldn't happen,but ignore if it does
    End Try
   end if
   !
   fields$[cnt,0]=blockcol.id$
   fields$[cnt,1]=str$(blockcol.seq)
   fields$[cnt,2]=blockcol.label$
   fields$[cnt,3]=blockcol.active$
   fields$[cnt,4]=blockcol.link$
   fields$[cnt,5]=blockcol.style$
   fields$[cnt,6]=blockcol.width$
   fields$[cnt,7]=str$(blockcol.dbposition)
   fields$[cnt,8]=str$(blockcol.dbprecision)
   fields$[cnt,9]=blockcol.dbtype$
   fields$[cnt,10]=blockcol.varname$
   if len(blockcol.varname$)>1 if blockcol.varname$[len(blockcol.varname$)]="$" let fields$[cnt,10]=blockcol.varname$[1,len(blockcol.varname$)-1],"qqq" !.net patch 3/20/08
   if blockcol.mask$="" let blockcol.mask$="#"
   fields$[cnt,11]=blockcol.mask$
   !
   cnt=cnt+1
   seq=-1 !get next
 Loop
 !
 if cnt>0 let cnt=cnt-1
 call dxset("colcnt",str$(cnt)) !# of columns in table
 !
 if rstr$=""
  For i=0 to cnt
   call dxset("coldef"+str$(i),fields$[i][])  !for template
  Next i
 else
 
 

  tmp$="<header>HEADING",fdel$,"LINK",fdel$,"ALIGN",fdel$,rdel$
  tmp$=tmp$,"ID",fdel$,fdel$,fdel$,rdel$ !always pass key/record # as first column
  call addtostr(e$,rstr$,tmp$)
  for control=0 to cnt !# of columns
   if fields$[control,3]="Y" !active
    tmp$=fields$[control,2],fdel$,fields$[control,4],fdel$
	if len(fields$[control,10])>3 if fields$[control,10,len(fields$[control,10])-2] = "qqq" let tmp$=tmp$,"LEFT" else let tmp$=tmp$,"RIGHT"
	tmp$=tmp$,fdel$,rdel$
    call addtostr(e$,rstr$,tmp$)  !for .net
   end if !active
  next control
 end if
 !
 for i=0 to cnt
  call dxset(10,"coldefvarname"+str$(i),fields$[i][10]) !tmp table
  call dxset(10,"coldeflabel"+str$(i),fields$[i][2])
  call dxset(10,"coldefmask"+str$(i),fields$[i][11])
 next i
 !
 call addtostr(e$,rstr$,"</header>")
 !
  !search parameters
  if blockid$<>"148" goto skipsearch !temp
  tmp$="<search>COLSEQ",fdel$,"Description",fdel$,rdel$
  tmp$=tmp$,"",fdel$,"Same as sort by",fdel$,rdel$
  call addtostr(e$,rstr$,tmp$)
  for control=0 to cnt !can search on any column
   if fields$[control,3]="Y" !active
    tmp$=str$(control),fdel$,fields$[control,2],fdel$,rdel$
	call addtostr(e$,rstr$,tmp$)
   end if !active
  next control
  call addtostr(e$,rstr$,"</search>")
  skipsearch:
 !
 !
 else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !collist
!
sub inplist(e$,blockid$,rstr$)
!--------------------------------------------------------------------
! inputs routine
! dxset's block inputs (printer prompt page) parameters
! called by setblock!
 try
 !
  !!custom for ubs checking of optional prompts based on system flags
  call getglobals("blockx",1,CTLC) !control file
  dim 1%,mhlpflag,archhist
  dim ubsp9$[50],ubsp8$[7],ubsp61$[256],1%,ubsc0[8],ubsc1[4],ubss9[5],3%,ubsp60$[50],costlevels$[4]
  dim testdefault$[fmtof(blockinp.default$)]
  dim custom_customer$[30]
  mat read #ctlc,19,50;ubsp9$;
  mat read #ctlc,52,60;ubsp8$;
  mat read #ctlc,61,0;ubsp61$;
  mat read #ctlc,51,18;ubsc0;
  mat read #ctlc,51,72;ubsc1;
  mat read #ctlc,51,94;archhist;
  mat read #ctlc,51,6;ubss9;
  mat read #ctlc,60,50;ubsp60$;
  mat read #ctlc,115,60;custom_customer$;
  let custom_customer$=rtrim$(ucase$(custom_customer$))
  call dxget("u_costlevels",costlevels$)
  !!custom end for ubs
  cnt=0
  fieldcnt=33
  rowcnt=50
  free fields$
  dim fields$[rowcnt,fieldcnt,120],fields2$[fieldcnt,120] !#cols,#rows,maxfieldlength
  keys$=blockid$
  seq=-2
  Try Search >= #c[2],1;keys$ Else Rem
  Do
 Try Read Record #c[2],seq;blockinp.; Else Exit Do
   if blockinp.id$<>blockid$ exit do
   if cnt>rowcnt exit do
   checkit=0 !include flag
   !!custom for ubs  ! using number uppercase and lower case
   if blockinp.userdef1$="1" if ubsc0[6]=0 let checkit=1 !no divisions
   if blockinp.userdef1$="2" if ubsp61$[64,64]<>"Y" let checkit=1 !no ship list
   if blockinp.userdef1$="3" if ubsp9$[50,50]<>"D" let checkit=1 !day
   if blockinp.userdef1$="4" if ubsp9$[50,50]<>"M" let checkit=1 !month
   if blockinp.userdef1$="5" if ubsp9$[32,32]<>"Y" let checkit=1 !warehouse pricing
   if blockinp.userdef1$="6" if ubss9[0]=0 let checkit=1 !no client id
   if blockinp.userdef1$="7" if ubss9[2]=0 let checkit=1 !no department
   if blockinp.userdef1$="8" if ubss9[3]=0 let checkit=1 !no profit center
   if blockinp.userdef1$="9" if ubsc0[0]=0 let checkit=1 !no bank
   if blockinp.userdef1$="0" if ubsc1[4]=0 let checkit=1 !no multiple budget flag (last 4 chars of budget filename
   if blockinp.userdef1$="A" if ubsp8$[1,1]="N" let checkit=1 !no division update
   if blockinp.userdef1$="B" if ubsp8$[2,2]="N" let checkit=1 !no order type update
   if blockinp.userdef1$="C" if ubsp8$[3,3]="N" let checkit=1 !no Product sales category
   if blockinp.userdef1$="D" ! gl interface - maintenance and yes
		checkit=1
		if ubsp9$[17,17]="M" let checkit=0 !
		if ubsp9$[17,17]="Y" let checkit=0  ! if 
   endif
   if blockinp.userdef1$="E" if ubsp9$[17,17]<>"Y" let checkit=1 !
   if blockinp.userdef1$="F" if ubsp61$[34,34]<>"Y" let checkit=1 !no cust/shpto mzone
   if blockinp.userdef1$="G" if ubsp60$[11,11]<>"Y" let checkit=1 !no private label mfg/minqty
   if blockinp.userdef1$="GL" if ubsp60$[11,11]="Y" let blockinp.label$="Private Label Code"
   if blockinp.userdef1$="H" if ubsp60$[26,26]<>"Y" let checkit=1 !no inventory levels
   if blockinp.userdef1$="I" if costlevels$[3,3]="0" let checkit=1 !no last/purchase order cost access by user control
   if blockinp.userdef1$="J" if ubsc0[8]=0 let checkit=1 !vendor by bank
   if blockinp.userdef1$="K" if ubsp61$[69,69]<>"Y" let checkit=1 !no template customer #
   if blockinp.userdef1$="L" if ubsp61$[34,34]="Y" let checkit=1 !cust/shpto mzone
   if blockinp.userdef1$="M" 
		if ubsp60$[49,49]="N"
			let checkit=1
		else
			let checkit=0
		endif
	endif !"Y" let checkit=1 ! include charges
   if blockinp.userdef1$="N" if ubsp60$[46,46]<>"Y" let checkit=1 ! import
   if blockinp.userdef1$="O" if ubss9[1]=0 let checkit=1 !no budgets
   if blockinp.userdef1$="P" ! non-rasl flag
	if ubsp9$[41,41]="Y" let checkit=1 ! do not include  ! ITS RASL PROMPT
   endif
   if blockinp.userdef1$="Q" ! rasl flag
	if ubsp9$[41,41]="N" let checkit=1 ! do not include  ! ITS NOT RASL PROMPT
   endif
   if blockinp.userdef1$="R" ! phys inv - add alloc
	if ubsp61$[45,45]="Y"
		if ubsp9$[41,41]="N" let checkit=1 ! do not include  ! ITS NOT RASL PROMPT
	endif
   endif
   if blockinp.userdef1$="S"	   ! MATERIAL HANDLING LISCENE PLATE
		checkit=0
		if ubsp61$[32,32]<>"Y" let checkit=1 ! do not include
		if ubsp9$[41,41]="N"   let checkit=1 ! ! RASL PROMPT
		mat read #ctlc,7,61;mhlpflag;
		if not(mhlpflag) let checkit=1 ! material handling flag	
   endif
   
   if blockinp.userdef1$="T"	   ! ap positive pay and ach
		checkit=0
		if ubsp61$[99,99]<>"Y" and ubsp61$[99,99]<>"P" let checkit=1 ! do not include
   endif
   if blockinp.userdef1$="t"	   ! ap ach only
		checkit=0
		if ubsp61$[99,99]<>"Y" let checkit=1 ! do not include
   endif
   if blockinp.userdef1$="V"  ! frozen month a/r
		checkit=0
		if ubsp61$[20,20]<>"Y" let checkit=1 ! no file
   endif
   if blockinp.userdef1$="W"	   ! roll inventory
		checkit=0
		if ubsp61$[104,104]<>"Y" let checkit=1 ! do not include
   endif
   if blockinp.userdef1$="X"	   ! multiclient gl interface by division
		checkit=0
		if ubss9[0]<>0
			if ubsp8$[7,7]<>"D" let checkit=1 ! do not include
		else
			let checkit=1 ! do not include no multi client
		endif
   endif
   if blockinp.userdef1$="Y"	   ! electronic cash receipts
		checkit=0
		if ubsp9$[49,49]<>"Y" let checkit=1 ! do not include
   endif
   if blockinp.userdef1$="Z"	   ! archive gl hist
		checkit=0
		if not(archhist) let checkit=1 ! do not include
   endif
   if blockinp.userdef1$="a" ! multi-currency
		let checkit=1
		if ubsp61$[136,136]="Y" let checkit=0
   endif
   if blockinp.userdef1$="b" ! a/r term misc cost code Task# 62368
		let checkit=1
		if ubsp61$[138,138]="Y" let checkit=0
   endif
  
   ! custom_customer$ check
   if checkit=0 ! include prompt
		if rtrim$(blockinp.userdef5$)<>""
			let checkit=1 ! do not include
			if rtrim$(ucase$(blockinp.userdef5$))=custom_customer$
				let checkit=0 ! include matches custom_customer$
			endif
		endif
	endif
   !!custom end for ubs
   if checkit=0 !ok to include flag
   !
   ! mod 02/19/10 - check to make sure it returns a user based
   ! default, otherwise just leave the default as is
   !
   testdefault$=getuserdefault$(e$) !new 2/12/10 substitute default by user
   if testdefault$ <> "" blockinp.default$=testdefault$
   if testdefault$="~" let blockinp.default$="" !unchecked checkbox default stored as ~
   fields$[cnt,0]=blockinp.id$
   fields$[cnt,1]=str$(blockinp.seq)
   fields$[cnt,27]=str$(blockinp.masterseq) !common seq to copy
   !if masterseq, read in common prompt fields for the rest
   if blockinp.masterseq
    oldblockinp. = blockinp.
    tmp$="        " !master blockid
	Try Search = #c[5],1;tmp$,blockinp.masterseq Else Rem
	Try Read Record #c[5],-2;blockinp. Else Rem
	!label,variable,shorthelp,default can be overridden at block inp level
	if oldblockinp.label$<>"" let blockinp.label$=oldblockinp.label$
	if oldblockinp.varname$<>"" let blockinp.varname$=oldblockinp.varname$
	if oldblockinp.helppage$<>"" let blockinp.helppage$=oldblockinp.helppage$
	if oldblockinp.default$<>"" let blockinp.default$=oldblockinp.default$
   end if
   if blockinp.type$="LISTA" if blockinp.label$="" let blockinp.label$="Select"
   fields$[cnt,2]=blockinp.label$
   fields$[cnt,3]=blockinp.active$
   fields$[cnt,4]=blockinp.varname$
   if len(blockinp.varname$)>1 if blockinp.varname$[len(blockinp.varname$)]="$" let fields$[cnt,4]=blockinp.varname$[1,len(blockinp.varname$)-1],"qqq" !.net patch 3/7/08
   fields$[cnt,5]=str$(blockinp.row)
   fields$[cnt,6]=str$(blockinp.column)
   fields$[cnt,7]=blockinp.type$
   fields$[cnt,8]=blockinp.required$
   fields$[cnt,9]=blockinp.default$
   if blockinp.type$ = "DATE"
	if UCase$(blockinp.default$[1,5])="TODAY"
		tmp=Tim(6) ! today in Julian
		if blockinp.default$[6,6]="+" let tmp=tmp+val(blockinp.default$[7])
		if blockinp.default$[6,6]="-" let tmp=tmp-val(blockinp.default$[7])
		tmp$=tmp \ Call JulianToDate(1,tmp$,tmp$,e)
		if not(e) fields$[cnt,9]=tmp$ 
	end if
   end if
   if blockinp.userdef1$[1,1]="U"
	call dxget("U_"+blockinp.varname$,tmp$)
	if tmp$ if blockinp.type$<>"CHECK" let fields$[cnt,9]=tmp$   ! default
	if blockinp.userdef1$[2,2]="C"  ! clear the variable
		tmp$="" \ call dxset("U_"+blockinp.varname$,tmp$)
	end if
   end if
   fields$[cnt,10]=blockinp.helppage$
   fields$[cnt,11]=blockinp.onfocus$
   fields$[cnt,12]=blockinp.onchange$
   fields$[cnt,13]=str$(blockinp.dbposition)
   fields$[cnt,14]=str$(blockinp.dbprecision)
   fields$[cnt,15]=blockinp.dbtype$
   fields$[cnt,16]=blockinp.disabled$
   if type$="EDIT" if id$="" let fields$[cnt,16]="N" !no fields disabled if add mode
   fields$[cnt,17]=blockinp.notab$
   fields$[cnt,18]=blockinp.focus$
   fields$[cnt,19]=blockinp.lookuplink$
   !text type or numeric type
   fields$[cnt,20]=str$(blockinp.minlength)
   fields$[cnt,21]=str$(blockinp.maxlength)
   !numeric type
   !if blockinp.mask$="" let blockinp.mask$="#" moved to blockartermcode.src
   fields$[cnt,22]=blockinp.mask$
   !check type
   fields$[cnt,23]=blockinp.checkvalue$
   !list type
   fields$[cnt,24]=str$(blockinp.maxselected)
   !list or text type
   fields$[cnt,25]=str$(blockinp.maxlisted) !beyond this,switches to text
   !
   fields$[cnt,26]=blockinp.helppage$ !short help text
   fields$[cnt,28]=blockinp.listfilename$ !filename to gen drop list from
   fields$[cnt,29]=blockinp.userdef1$
   fields$[cnt,30]=blockinp.userdef2$
   fields$[cnt,31]=blockinp.userdef3$
   fields$[cnt,32]=blockinp.userdef4$
   fields$[cnt,33]=blockinp.userdef5$
   !note 34 reserved for blockgui element #, skip it here
   !
   if len(blockinp.userdef1$)>1 if blockinp.userdef1$[1,1]="R" !set U_fieldname to array to repeat this field
     cnt2=blockinp.userdef1$[2]
	 for i=0 to cnt2-1
	  array$[i]=str$(i+1)
	 next i
	 call dxset(0,"U_"+fields$[cnt,4],array$[])
   end if
   !
   !
   for i=0 to fieldcnt
    if fields$[cnt,i]="" let fields$[cnt,i]=" "
   next i
   !
  cnt=cnt+1
  end if !checkit=0 include it
  !
   seq=-1 !get next
 Loop
 if cnt>0 let cnt=cnt-1
 call dxset("inpcnt",str$(cnt)) !# of columns in table  read by blockartermcode
 !
 !not used UBS if rstr$="" 
  !For i=0 to fieldcnt
   !call dxset("inpdef"+str$(i),fields$[i][])  !for template
  !Next i
 if id$<>"" or action$="SAVE" !means file maintenance, edit mode of existing record, so have to put all control parameters in a dx tmp table for blockartermcode to read to create xml of control with the record's defaults
 !SAVE mode, this is needed to replace record values in blockartermcode
  For i=0 to cnt
   call dxset(10,"inpdef"+str$(i),fields$[i][])  !for generated block programs
  Next i
 else
  for control=0 to cnt !# of fields               
   if fields$[control,3]="Y" !active
    for i=0 to fieldcnt 
	 fields2$[i]=fields$[control,i] 
	next i !move from 3 dim array to 2
	type2$=fields2$[7]
	if len(type2$)>=4 if type2$[1,4]="LIST" let type2$="LIST"
	if len(type2$)>5 if type2$[1,5]="RADIO" let type2$="RADIO"
	!deal with multiple generated controls and/or U checkbox
	if type2$<>"PRINTER" if type2$<>"LIST" if type2$<>"RADIO"
	 if len(fields2$[29])>0 if fields2$[29,1,1]="R" or fields2$[29]="U" or fields2$[29]="UC"
	  call dxget("U_"+fields2$[4],array$[])
      if ubound(array$[],1) > 0 let fields2$[4]=fields2$[4],"0" !first one concat seq 0,  if more than 1 U set
	  if type2$="CHECK" let fields2$[2]=fields2$[2]," ",array$[0] \fields2$[23]=array$[0] !if CHECKbox, concat value to the label and set value to send if checked
     end if
	end if
    call setproperties(e$,fields2$[],rstr$)
    fields2$[4]=fields$[control,4]
	fields2$[2]=fields$[control,2]
    call setdata(e$,c[3],blockid$,fields2$[],rstr$)
 

    call addtostr(e$,rstr$,"</control>") !add to string, but don't put eor at end
   end if !active control
  next control
  !
  if len(type$)>=6 if type$[1,6]="PROMPT" if type$<>"PROMPT1"   !printer prompt unless, page block hdr custom1="1" then no printer prompt on this page
  !by default always send printer prompt control if type PROMPT
     tmp$="<control>Type",fdel$,"DROPDOWN",fdel$,rdel$,"<property>Property",fdel$,"Value",fdel$,rdel$
     call addtostr(e$,rstr$,tmp$)  !for .net
	 tmp$="CtrlLbl",fdel$,"Select Printer",fdel$,rdel$
	 tmp$=tmp$,"CtrlName",fdel$,"printer",fdel$,rdel$
	 tmp$=tmp$,"Required",fdel$,"Y",fdel$,rdel$
	 tmp$=tmp$,"IsReadOnly",fdel$,"N",fdel$,rdel$
     call addtostr(e$,rstr$,tmp$)  !for .net
  	 tmp$="</property><data>Text",fdel$,"Value",fdel$,"IsDefault",fdel$,rdel$
	 call addtostr(e$,rstr$,tmp$)
	 !printer list
	 xmloption=1\pdfoption=1 !yes
	 if len(type$)>6  !if X or P exclude them
	  if type$[7,7]="X" let xmloption=0
	  if type$[7,7]="P" let pdfoption=0
	  if len(type$)>7
	   if type$[8,8]="X" let xmloption=0
	   if type$[8,8]="P" let pdfoption=0
	  end if
	 end if
	 call blockPrintersDropList(rstr$,xmloption,pdfoption) ! creates printer drop list
     call addtostr(e$,rstr$,"</data></control>")
  end if
  if len(type$)>=6 if type$[1,6]="PROMPT" !any prompt type
   !by default, if u_promptdefaults = "Y" send Save Defaults checkbox control
   call dxget("u_promptdefaults",tmp$)
   if ucase$(tmp$)="Y"
    tmp$="<control>Type",fdel$,"CHECK",fdel$,rdel$,"<property>Property",fdel$,"Value",fdel$,rdel$
    call addtostr(e$,rstr$,tmp$)  !for .net
	tmp$="CtrlLbl",fdel$,"Save Defaults",fdel$,rdel$
	tmp$=tmp$,"CtrlName",fdel$,"promptdefaults",fdel$,rdel$
	tmp$=tmp$,"Required",fdel$,"N",fdel$,rdel$
	tmp$=tmp$,"IsReadOnly",fdel$,"N",fdel$,rdel$
    call addtostr(e$,rstr$,tmp$)  !for .net
    tmp$="</property><data>",fdel$,rdel$,"</data></control>" !default
	call addtostr(e$,rstr$,tmp$)
   end if
  end if !type any PROMPT
 end if
 !
 for i=0 to cnt !# of fields
  call dxset(10,"inpdefvarname"+str$(i),fields$[i][4])  !fieldnames used by?
 next i
 
 !
!
!
  !
else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !inplist
!
sub butlist(e$,blockid$,rstr$)
!--------------------------------------------------------------------
! buttons routine
! dxset's block huttons parameters
! called by setblock!
 try
 !
  colcnt=4
  rowcnt=50
  free fields$
  dim fields$[colcnt,rowcnt,120] !#cols,#rows,maxfieldlength
  keys$=blockid$
  seq=-2
  Try Search >= #c[4],1;keys$ Else Rem
  Do
 Try Read Record #c[4],seq;blockbut.; Else Exit Do
   if blockbut.id$<>blockid$ exit do
   if cnt>rowcnt exit do
   !
   fields$[0,cnt]=blockbut.id$
   fields$[1,cnt]=str$(blockbut.seq)
   fields$[2,cnt]=blockbut.label$
   fields$[3,cnt]=blockbut.active$
   fields$[4,cnt]=blockbut.link$
  !
 cnt=cnt+1
   seq=-1 !get next
 Loop
 !
 if rstr$=""
 For i=0 to 4
  call dxset("butdef"+str$(i),fields$[i][])  !for template
 Next i
  else
   tmp1$="<type>button"
   call addtostr(e$,rstr$,tmp1$,fields$[])  !for .net
   rstr$=rstr$,"</type>"
 end if
 !
!
!
  !
else
 if spc(8)<>10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
   !call programdump("")
  end if
  error 10000
 end try
end sub !butlist
!
! **main setblock  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !
 try
  try enter rstr$,... else dim rstr$[1]
 !
 Dim blockconfig. as blockconfig
 Dim 1%,c[20],3%,keys$[120],id$[100]
 dim tmp$[1000],tmp1$[100],tmp2$[100]
 dim fdel$[10],rdel$[10],type$[20],type2$[20],array$[100,100]
 dim userid$[8],b$[100] !for user defaults
 b$=" ",b$
 call env(1,"FDEL",fdel$)
 call env(1,"RDEL",rdel$)
 ! need to get filenames from dxsystem.txt
 !
 !read system file parameters
 Call blockReadSystemFile(e$,blockconfig.)
 !
 ! open files
 !
 Call blockopenfiles(e$,blockconfig.,c[])
 call setglobals("blockxchan",0,c[3])  !channel # blockinplst is open on, for blockartermcode setdata drop list values

 !
 call getglobals("blockx",4,userid$) !for user defaults
 Call hdrlist(e$,blockid$,rstr$)
 !
 if type$="TABLE"  !maintentance table, put headings in rstr, put varname and mask in tmp dxset table or blockartermcode to access
  Call collist(e$,blockid$,rstr$)
 end if
 !
 if type$="EDIT"
  call dxget("ID",id$) !change mode,not add mode
  call inplist(e$,blockid$,rstr$) 
  !if change (ID<>"") puts edit prompts in tmp dxset table for blockartermcode to read and create control with default data from record
  !if add, works just like printer prompts, everything is done here.
  if id$="" call addtostr(e$,rstr$,"</block>") \action$=""\programname$="" !add mode
 end if
 !
 if type$="SAVE"
  call dxget("ID",id$) !change mode,not add mode
  call inplist(e$,blockid$,rstr$)
 end if
 !
 if len(type$)>=6 if type$[1,6]="PROMPT" 
  Call inplist(e$,blockid$,rstr$) !print prompts,other prompts
  call addtostr(e$,rstr$,"</block>")
 end if
 !
 ! no buttons right now Call butlist(e$,blockid$,rstr$)
 !
 else
 if spc(8) <> 10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
  end if
  error 10000
 end try
end sub !setblock
!
!
external sub loadcols(e$,fields$[],cnt,a$,...)
!UBS NOT USED using structures so needs to be in calling program!!!
! reads a$,a1,a2,a3,a4 and populates fields$[] for row=cnt based on 
! column definitions for blockid lasted loaded by setblock
! pass fields$[] 3-dim array being populated by loadcols
! pass cnt, which is row in fields$[] array to populate 
! pass a$ string, and optionally numeric arrays 1%,2%,3%,4% in any order
 !
try 
   try
    enter a1[],...
    enter a2[],...
    enter a3[],...
    enter a4[]
   else
   end try
else
 if spc(8) <> 10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
  end if
  error 10000
 end try
end sub !loadcols
!
!
external sub setcols(e$,blockno,fields$[])
! dxsets column arrays in fields$[] to output to xport
! column definitions from blockid lasted loaded by setblock
! pass blockno to use on web page 0=none, <0 = blockid
! pass fields$[] array previously loaded by loadcols
try
 dim tmp$[30],blockid$[8]
 for i=0 to ubound(fields$[],1)
 tmp$="col"+str$(i)
 if blockno>0 let tmp$=str$(blockno)+"col"+str$(i)
 !get blockid from setblock if blockno<0
 if blockno<0 call dxget(10,"blockid",blockid$) \ let tmp$=blockid$ +"col"+str$(i)
  call dxset(tmp$,fields$[i])
 next i
else
 if spc(8) <> 10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
  end if
  error 10000
 end try
end sub !setcols
!
!
external sub setvalues(e$,blockno,a$,...)
! reads a$,a1,a2,a3,a4 and dxsets default value array to output to xport
! field definitions from blockid lasted loaded by setblock
! pass blockno to use on web page 0=none, <0 = blockid
! pass a$ string, and optionally numeric arrays 1%,2%,3%,4% in any order
 !
try
else
 if spc(8) <> 10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
  end if
  error 10000
 end try
end sub !setvalues
!
!
external sub getvalues(e$,blockid$,blockno,a$,...)
! reads in xport values from blockno, based on field definitions in blockid$
! and populates a$ string, and optional numeric arrays
! pass blockid$ for field definitions
! pass blockno that matches blockno section of web page
! pass a$ string, and optionally numeric arrays 1%,2%,3%,4% in any orde 
 !
try
else
 if spc(8) <> 10000
   call blocksuberr(e$,Spc(8),Spc(10),Msc$(2))
  end if
  error 10000
 end try
end sub !getvalues
