! libfilespoflenz.lib
!
! loadsave -w -n 100,10 -o prog/dxport/libfilespoflenz.lib src/libfilespoflenz.src
!
! supporting library of file maintenance routines for browser
!
! 1.0 generated by dfcreatestruct on 02/16/09 new
!
include "src/copyright.inc"
!
! file maintenance sub routines for spoflen File
!
!  function  filegetspoflenz
!  function  fileupdatespoflenz
!  function  filedroplistspoflenz
!
Declare Intrinsic Sub env,getglobals
Declare Intrinsic Function crc32,callstat$,trim$,findchannel
External Lib "ubsfunc.dl4"
Declare External Function OpenFile
!
!Include src/inc/filespoflen.inc
Def Struct spoflenz ! PO LINE SERIAL#  generated by dfcreatestruct on 02/16/09
  Member ProductCode$[12] : Item 0 ! SN1$[1,12]
  Member LotCode$[12] : Item 12 ! SN1$[13,24]
  Member Serial$[30] : Item 24 ! SN1$[25,54]
  Member 2%,Po : Item 54 ! SN0           SN REC# (321)
  Member 1%,PoLine : Item 58 ! SN1[0]        RTS REC# (321)
  Member 1%,Whse : Item 60 ! SN1[1]
  Member 1%,TypeBy321 : Item 62 ! SN1[2]        0=ADD,-1=DELETE
End Def 
!
! ----------------------------------------
!
! external lib statements
!
External Lib "libfilespoflenz.lib"
Declare External Function filegetspoflenz,fileupdatespoflenz
Declare External Sub filedroplistspoflenz
!
! ----------------------------------------
External Function filegetspoflenz(e$,chan,Mode$,keyno,keyval$,spoflen. As spoflenz,...)
  !
  ! get a spoflen record
  !
  ! pass e$ to return error msg if any
  ! pass chan channel # of file
  ! pass mode$ =,>,>=,<,<=,next,prev
  ! pass keyno for key number to search on
  ! pass keyval$ populated with key to search for
  ! pass structure to return record in
  ! optionals
  !     pass lockflag<>0 to lock record
  !     pass timeout period
  !     pass CrcValue for crc value to be calculated and returned
  !
  ! returns record # and record structure if found
  ! returns a negative number on an error, e$=routine error, -123=record locked
  !
  Try 
    !
	Try Enter prr,... Else Let prr = 0
	Try Enter lockflag,... Else Let lockflag = 0
    Try Enter timeout,... Else Let timeout = 100000
    Try Enter CrcValue Else Let CrcValue = -1
    !
    Dim hold$[80],tmp$[80],errmsg$[200],3%
    !
    If Mode$ = "=" Or Mode$ = ">=" Or Mode$ = "<=" Let mode = 2
    If Mode$ = ">" Or LCase$(Mode$) = "next" Let mode = 3
    If Mode$ = "<" Or LCase$(Mode$) = "prev" Let mode = 6
    !
	If e$="321" let mrtsflag=1 else mrtsflag=0 \ e$ = ""
	!
    hold$ = keyval$
    Search #chan,mode,keyno;keyval$,r1,e2
    If Mode$ = "="
      If RTrim$(keyval$) <> RTrim$(hold$) Let e2 = 1
    End If 
    If e2 If mode = 2 If Mode$ <> "="
      If Mode$ = ">=" Let mode = 3 Else Let mode = 6
      Search #chan,mode,keyno;keyval$,r1,e2
    End If 
    If e2 = 0
      If lockflag = 0 Read Record #chan,r1,0,timeout;spoflen.; Else Read Record #chan,r1,0,timeout;spoflen.
      CrcValue = crc32(Hex$(spoflen.))
    Else 
      r1 = e2 * -1 ! <0 error
      e$ = "msgspoflenNOF"
    End If 
Else 
  if spc(8) = 123 exit function -123 ! record locked
  dim msc4$[100] \ msc4$=msc$(4)
  if Pos(msc4$, = "/",-1) let msc4$=msc4$[pos(msc4$,="/",-1)+1]
  select case spc(8)
    case 10000
      ! this is default "message" error
      ! e$ should be set with message to display
    case 11000
      ! search error
      call env(2,"PROGNAME",msc4$)
      call programdump()
      call searcherr(e$, e, Spc(10), e$)
    case else
      e$ = "filegetspoflen mode=",mode," keyno=",keyno," r1=",r1," e2=",e2," keyval$=",keyval$
      if spc(8) <> 0 if spc(8) < 10000
        call env(2,"PROGNAME",msc4$)
        call programdump()
        call suberr(e$,Spc(8),Spc(10),Msc$(2))
      end if
  end select
  error 10000
End Try 
End Function r1 ! filegetspoflen
!
! ----------------------------------------
External Function fileupdatespoflenz(e$,chan,Mode$,rcdno,spoflen. As spoflenz,...)
  !
  ! adds, changes or deletes a spoflen record
  !
  ! pass e$     : to return error msg if any
  ! pass chan   : channel # of file
  ! pass mode$  : a = add, c = change, d = delete
  ! pass rcdno  : on change or delete,
  !      if -4 is passed routine will get record (index 1 can't change on change)
  ! pass record : structure
  ! optionally pass lockflag to keep record locked
  ! optionally pass timeout period
  ! returns 0 or negative # if error, -9=already on file, -123=record locked
  ! returns rcdno added on add
  !
  ! search used in update call
  !
  Declare Sub DoSearch,AddKeys,DeleteKeys,ChangeKeys
  !
  Try 
    !
	Try Enter prr,... Else Let prr = 0
    Try Enter lockflag,... Else Let lockflag = 0
    Try Enter timeout Else Let timeout = 100000
    !
    Dim k$[64],K1$[64],K2$[64],K3$[64],K4$[64],K5$[64]
    Dim 3%,K6$[64],K7$[64],K8$[64],K9$[64]
    Dim Dir1$[300],Dir2$[300],Dir3$[300],Dir4$[300],Dir5$[300]
    Dim Dir6$[300],Dir7$[300],Dir8$[300],Dir9$[300]
    Dim OldDir1$[300],OldDir2$[300],OldDir3$[300],OldDir4$[300],OldDir5$[300]
    Dim OldDir6$[300],OldDir7$[300],OldDir8$[300],OldDir9$[300]
    Dim errmsg$[200],Lmode$[1],3%
    Dim Blank$[100] \ Blank$ = " ",Blank$
    !
    Lmode$ = LCase$(Mode$[1,1]) ! convert mode to lower case,just in case
	If e$="321" let mrtsflag=1 else mrtsflag=0 \ e$ = ""
    !
    If Lmode$ = "a" ! add: set defaults, check not on file, get free record
      k$ = spoflen.Po Using "######",spoflen.PoLine Using "###",spoflen.Serial$
	  if mrtsflag k$="R",spoflen.PoLine Using "########",spoflen.Serial$ ! misc rts
      Call DoSearch(k$,2,1,1) ! search mode=2 dir=1 errflag
      If e = 0 ! record already on file, can't add error
        e$ = "msgspoflenOnFile" ! set to already on file msg # in dxmsg.txt file
        Exit Function -9 ! -9 indicates already on file!
      End If 
      !
      e = 2
      Call DoSearch("",1,0) ! get record #
      !
      Write Record #chan,r,0,timeout;spoflen.
      !
      Call AddKeys(1,2) ! add keys, all directories
      !
      e = r !return record # added
    End If 
    !
    If Lmode$ = "c" Or Lmode$ = "d" ! change or delete, verify record
      Dim oldspoflen. As spoflenz
      If rcdno = -4 ! need to get the record first
        r = rcdno \ oldr = rcdno ! if record # is used in the key
        k$ = spoflen.Po Using "######",spoflen.PoLine Using "###",spoflen.Serial$
		if mrtsflag K$="R",spoflen.PoLine Using "########",spoflen.Serial$ ! misc rts
        Call DoSearch(k$,2,1,1) ! mode 2, dir 1, errflag 1 never trap as hard error
        If e
          ! Customer not on file!
          e$ = "msgspoflenNOF" ! set to not on file msg # in dxmsg.txt file
          Exit Function e * -1
        End If 
      Else 
        r = rcdno \ oldr = rcdno
      End If 
      Read Record #chan,r,0,timeout;oldspoflen.
    End If 
    !
    If Lmode$ = "d" ! deletes keys and record #
      !
      read record #chan,r,0,timeout;spoflen.;
      Call DeleteKeys(1,2) ! delete keys, all directories
      !
      e = 3
      Call DoSearch("",1,0) ! releases record #
    End If 
    !
    If Lmode$ = "c" ! change record and keys
      !
      If lockflag = 0 Write Record #chan,r,0,timeout;spoflen.; Else Write Record #chan,r,0,timeout;spoflen.
      !
      Call ChangeKeys() ! deletes old keys & add new keys
    End If 
    !
Else 
  if spc(8) = 123 exit function -123 ! record locked
  dim msc4$[100] \ msc4$=msc$(4)
  if Pos(msc4$, = "/",-1) let msc4$=msc4$[pos(msc4$,="/",-1)+1]
  select case spc(8)
    case 10000
      ! this is default "message" error
      ! e$ should be set with message to display
    case 11000
      ! search error
      call env(2,"PROGNAME",msc4$)
      call programdump()
      call searcherr(e$, e, Spc(10))
    case else
      if spc(8) < 10000
        call env(2,"PROGNAME",msc4$)
        call programdump()
        call suberr(e$,Spc(8),Spc(10),Msc$(2))
      end if
  end select
  error 10000
End Try 
  !
  !----------------------------------------
  Sub DoSearch(k$,m,k,...)
    !
    !pass k$=keyvalue, m=mode, k=keyno, optionally errflag <>0 return e, don't err
    !
    Try Enter errflag Else Let errflag = 0
    Search #chan,m,k;k$,r,e
    If e If errflag = 0 Let e$ = "syserrorfile fileupdatespoflen mode (m)=",m," keyno (k)=",k," r=",r," e=",e," keyval (k$)=",k$
    If e If errflag = 0 Error 11000 !hard error
  End Sub ! dosearch
  !
  !----------------------------------------
  Sub AddKeys(BegDir,EndDir)
    !
    ! BegDir = Beginning Directory
    ! EndDir = Ending Directory
    !
    Try 
      Dim Curkey$[64],3%,CurRec
      !
      For CurDir = BegDir To EndDir
        Curkey$ = ""
        If CurDir = 1 Let Curkey$ = spoflen.Po Using "######",spoflen.PoLine Using "###",spoflen.Serial$
		If mrtsflag Curkey$="R",spoflen.PoLine Using "########",spoflen.Serial$ ! misc rts
        If CurDir = 2 Let Curkey$ = spoflen.Serial$,PRR Using "######"
        Call DoSearch(Curkey$,4,CurDir) ! add key to directory
      Next CurDir
Else 
  dim msc4$[100] \ msc4$=msc$(4)
  if Pos(msc4$, = "/",-1) let msc4$=msc4$[pos(msc4$,="/",-1)+1]
  select case spc(8)
    case 10000
      ! this is default "message" error
      ! e$ should be set with message to display
    case 11000
      ! search error
      call env(2,"PROGNAME",msc4$)
      call programdump()
      call searcherr(e$, e, Spc(10))
    case else
      if spc(8) < 10000
        call env(2,"PROGNAME",msc4$)
        call programdump()
        call suberr(e$,Spc(8),Spc(10),Msc$(2))
      end if
  end select
  error 10000
End Try 
End Sub ! AddKeys
  !
  !----------------------------------------
  Sub DeleteKeys(BegDir,EndDir)
    !
    ! BegDir = Beginning Directory
    ! EndDir = Ending Directory
    !
    Try 
      Dim Curkey$[64],3%,CurRec
      !
      For CurDir = EndDir To BegDir Step -1
        Curkey$ = ""
        If CurDir = 1 Let Curkey$ = oldspoflen.Po Using "######",oldspoflen.PoLine Using "###",oldspoflen.Serial$
		If mrtsflag Curkey$="R",oldspoflen.PoLine Using "########",oldspoflen.Serial$ ! misc rts
        If CurDir = 2 Let Curkey$ = oldspoflen.Serial$,PRR Using "######"
        Call DoSearch(Curkey$,5,CurDir) ! add key to directory
      Next CurDir
Else 
  dim msc4$[100] \ msc4$=msc$(4)
  if Pos(msc4$, = "/",-1) let msc4$=msc4$[pos(msc4$,="/",-1)+1]
  select case spc(8)
    case 10000
      ! this is default "message" error
      ! e$ should be set with message to display
    case 11000
      ! search error
      call env(2,"PROGNAME",msc4$)
      call programdump()
      call searcherr(e$, e, Spc(10))
    case else
      if spc(8) < 10000
        call env(2,"PROGNAME",msc4$)
        call programdump()
        call suberr(e$,Spc(8),Spc(10),Msc$(2))
      end if
  end select
  error 10000
End Try 
End Sub ! DeleteKeys
  !
  !----------------------------------------
  Sub ChangeKeys()
    !
    Try 
      Dim Curkey$[64],OldKey$[64],3%
      !
      ! Directory #2
      OldKey$ = oldspoflen.Serial$,PRR Using "######"
      Curkey$ = spoflen.Serial$,PRR Using "######"
      If Curkey$ <> OldKey$
        Call DoSearch(OldKey$,5,2)
        Call DoSearch(Curkey$,4,2)
      End If 
      !
      ! Directory #1
      OldKey$ = oldspoflen.Po Using "######",oldspoflen.PoLine Using "###",oldspoflen.Serial$
	  If mrtsflag Oldkey$="R",oldspoflen.PoLine Using "########",oldspoflen.Serial$  ! misc rts
      Curkey$ = spoflen.Po Using "######",spoflen.PoLine Using "###",spoflen.Serial$
	  If mrtsflag Curkey$="R",spoflen.PoLine Using "########",spoflen.Serial$  ! misc rts
      If Curkey$ <> OldKey$
        Call DoSearch(OldKey$,5,1)
        Call DoSearch(Curkey$,4,1)
      End If 
      !
Else 
  dim msc4$[100] \ msc4$=msc$(4)
  if Pos(msc4$, = "/",-1) let msc4$=msc4$[pos(msc4$,="/",-1)+1]
  select case spc(8)
    case 10000
      ! this is default "message" error
      ! e$ should be set with message to display
    case 11000
      ! search error
      call env(2,"PROGNAME",msc4$)
      call programdump()
      call searcherr(e$, e, Spc(10))
    case else
      if spc(8) < 10000
        call env(2,"PROGNAME",msc4$)
        call programdump()
        call suberr(e$,Spc(8),Spc(10),Msc$(2))
      end if
  end select
  error 10000
End Try 
End Sub ! ChangeKeys
  !
End Function e ! updatespoflen
!
! ----------------------------------------
External Sub filedroplistspoflenz(e$,List$[],maxcnt,chan,...)
  !
  ! creates a drop list
  !
  ! e$          : to return error msg if any
  ! List$[]     : the record created from the field array
  ! maxcnt      : maxmium # of lines for list array
  ! Chan        : the channel # of the file
  !
  ! Optional parameters
  ! Section$    : .net, the section to be created and sent to web
  ! Field$[]    : the fields being created in the drop down list
  !               in the order of being displayed
  ! KeyNo       : the directory # to search
  ! KeyVal$     : beginning key / compare to
  ! Others$     : list of flags to display other drop list options 0=None,A=All
  !
  Try 
    !
	Try Enter PRR,... Else Let PRR = 0
    Try Enter iSection$,... Else Dim iSection$[1]
    Try Enter iField$[],... Else Dim iField$[1,30]
    Try Enter keyno,... Else Let keyno = 1
    Try Enter keyval$,... Else Dim keyval$[64]
    Try Enter others$ Else Dim others$[1]
    !
    Option String ReDIM Is Legal
    !
    Dim tmp$[50],tmpfield$[50],tmpline$[500],calling$[14],errtype$[1],Section$[30],Field$[2,30]
    Dim bsdel$[20],esdel$[20],rdel$[20],fdel$[20]
    Dim searkey$[64],Mode$[5]
    Dim 2%,row
    Dim 2%,tmpcnt,3%
    !
    Dim spoflen. As spoflenz
	!
	If e$="321" let mrtsflag=1 else mrtsflag=0 \ e$ = ""
	!
    Section$ = iSection$
    For i = 0 To UBound(iField$[],1)
      Field$[i] = iField$[i]
    Next i
    calling$ = callstat$(1,errtype$)
    If calling$ = "libfilehandler" Let blockformat = 1 !dxblock <data> format
    !
    Call env(1,"BSDEL",bsdel$)
    Call env(1,"ESDEL",esdel$)
    Call env(1,"RDEL",rdel$)
    Call env(1,"FDEL",fdel$)
    !
    If Section$ = "" Let Section$ = "droplistspoflen"
    tmpcnt = UBound(List$[],1)
    row = 0
    !
    ! beginning section
    Clear List$[]
    List$[0] = bsdel$,Section$,fdel$ ! beginning section
    !
    ! heading section for .net
    cnt = 0
    If Field$ = ""
      tmpline$ = "ID",fdel$,"ProductCode",fdel$,"Serial",fdel$
      !
	  Field$[0]="ProductCode$"
	  Field$[1]="Serial$"
    Else 
      tmpline$ = "ID",fdel$
      While Field$[cnt]
        tmpline$ = tmpline$,trim$(Field$[cnt]),fdel$ ! field name
        cnt = cnt + 1
      Wend 
    End If 
    If blockformat = 0
      List$[1] = tmpline$
      row = 2
    End If 
    !
    !any other optional elements to include in drop list (defined in page block userdef2
    Sub tmpline(tmp$) !needed to put right # of fields in others
      tmpline$ = ""
      For fcnt = 0 To UBound(Field$[],1)
        If Field$[fcnt] = "" Exit For 
        tmpfield$ = " "
        If fcnt = 0 Let tmpfield$ = tmp$
        If blockformat
          tmpline$ = tmpline$,RTrim$(tmpfield$)," "
        Else 
          tmpline$ = tmpline$,RTrim$(tmpfield$),fdel$
        End If 
      Next fcnt
    End Sub 
    xpos = Pos(UCase$(others$), = "A")
    If xpos
      Call tmpline("All")
      If blockformat = 0 Let List$[row] = "A",fdel$,tmpline$
      If blockformat Let List$[row] = tmpline$,fdel$,"A",fdel$,fdel$
      row = row + 1
    End If 
    xpos = Pos(UCase$(others$), = "0")
    If xpos
      Call tmpline("None")
      If blockformat = 0 Let List$[row] = "0",fdel$,tmpline$
      If blockformat Let List$[row] = tmpline$,fdel$,"0",fdel$,fdel$
      row = row + 1
    End If 
    xpos = Pos(UCase$(others$), = "B") !blank
    If xpos
      Call tmpline("")
      If blockformat = 0 Let List$[row] = "",fdel$,tmpline$
      If blockformat Let List$[row] = tmpline$,fdel$,"",fdel$,fdel$
      row = row + 1
    End If 
    ! create data section
    searkey$ = keyval$
    Mode$ = ">"
    Do 
      recno = filegetspoflenz(e$,chan,Mode$,keyno,searkey$,spoflen.)
      If recno < 0 Exit Do 
      If keyval$ If searkey$[1,Len(keyval$)] <> keyval$ Exit Do 
      !
      If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
      !
      tmpline$ = ""
      For fcnt = 0 To UBound(Field$[],1)
        If Field$[fcnt] = "" Exit For 
        tmpfield$ = ""
		if Field$[fcnt]="ProductCode" let tmpfield$=spoflen.ProductCode$," "
		if Field$[fcnt]="Serial" let tmpfield$=spoflen.Serial$," "
        !
        If tmpfield$ <> "" Let tmpfield$ = RTrim$(tmpfield$) \ If tmpfield$ = "" Let tmpfield$ = " " !even if field all spaces, include it
        If tmpfield$
          If blockformat
            tmpline$ = tmpline$,RTrim$(tmpfield$)," "
          Else 
            tmpline$ = tmpline$,RTrim$(tmpfield$),fdel$
          End If 
        End If 
      Next fcnt
      !
      If tmpline$
        If blockformat = 0 Let List$[row] = searkey$,fdel$,tmpline$
        If blockformat Let List$[row] = tmpline$,fdel$,trim$(searkey$),fdel$,fdel$
        row = row + 1
        !if row > maxcnt+1 exit do !to limit # in drop list
      End If 
      !
    Loop 
    !
    If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
    If blockformat = 0 Let List$[row] = esdel$ ! end of section delimiter
    !
Else 
  dim msc4$[100] \ msc4$=msc$(4)
  if Pos(msc4$, = "/",-1) let msc4$=msc4$[pos(msc4$,="/",-1)+1]
  select case spc(8)
    case 10000
      ! this is default "message" error
      ! e$ should be set with message to display
    case 11000
      ! search error
      call env(2,"PROGNAME",msc4$)
      call programdump()
      call searcherr(e$, e, Spc(10),e$)
    case else
      e$ = "filedroplistspoflen mode=",mode," keyno=",keyno," error=",recno," keyval$=",keyval$
      if spc(8) = 123 let e$=" record locked"
      if spc(8)<10000 if spc(8)<>123
        call env(2,"PROGNAME",msc4$)
        call programdump()
        call suberr(e$,Spc(8),Spc(10),Msc$(2))
      end if
  end select
  error 10000
End Try 
End Sub ! filedroplistspoflen
!
! ----------------------------------------
!
! **main procedure
!
! dim variables used by program
!
Dim e$[500],buttonlist$[5,50],nextlist$[5,100] !error handling variables
Try 
  !
  Dim blockid$[8],tmp$[100],id$[100],readonly$[1]
  Dim action$[30],options$[30],userid$[8],3%,fdel$[10],rstr$[3000],bsdel$[10],esdel$[10],rdel$[10]
  Dim spoflen. As spoflenz
  !
  Call getglobals("blockx",0,blockid$,CTLC,options$,action$,userid$,intCo,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$)
  !open data file
  readonly$ = "R" !ropen
  chan = OpenFile("spoflen",intCo * -1,readonly$)
  If chan < 0 Error 10000
  !
  Call dxget("ID",id$) !record # or key
  !
  If action$ = "VERIFY"
    spoflen.Po = id$
    id$ = spoflen.Po Using "######",spoflen.PoLine Using "###",spoflen.Serial$
	if mrtsflag id$="R",spoflen.PoLine Using "########",spoflen.Serial$  ! misc rts
    r = filegetspoflenz(e$,chan,"=",1,id$,spoflen.)
    If r < 0
      e$ = "msgspoflenNOF"
      Error 10000 !not on file return error
    End If 
    tmp$ = "ID",fdel$,"Desc",fdel$,rdel$ !always going to return ID (key) and first droplist field
    tmp$ = tmp$,RTrim$(id$),fdel$
    tmp$ = tmp$,fdel$,rdel$
    Call addtostr(e$,rstr$,tmp$) !return formatted key and first required field
  End If 
  !
  Call addtostr(e$,rstr$,esdel$) !end section
  !!!!!!print rstr$
  Call setoutput(e$,rstr$,1,e$) !1 flag puts 0 status section in, puts </page> in, e$ is message
Else 
 ! error routine
  dim msc4$[100] \ msc4$=msc$(4)
  if Pos(msc4$, = "/",-1) let msc4$=msc4$[pos(msc4$,="/",-1)+1]
  select case spc(8)
    case 10000
      ! this is default "message" error
      ! e$ should be set with message to display
    case 11000
      ! search error
      call env(2,"PROGNAME",msc4$)
      call programdump()
      call searcherr(e$, e, Spc(10),e$)
    case else
      if spc(8) <> 10000
        call env(2,"PROGNAME",msc4$)
        call programdump()
        call suberr(e$,Spc(8),Spc(10),Msc$(2))
      end if
  end select
  call mainerr(e$,spc(8),buttonlist$[],nextlist$[],rstr$)
End Try 
End 
