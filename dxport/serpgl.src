!"serpgl" === description  synergy erp general ledger section
!
!loadsave -w -n 100,10 -o prog/dxport/serpgl.dl4 src/serpgl.src 
!
include "src/copyright.inc"
!
include "src/inc/filecust.inc" ! customer
include "src/inc/fileglacfz.inc" ! application control file
include "src/inc/fileglglmz.inc" ! general ledger master file
include "src/inc/fileglbdistz.inc" ! g/l budget distribution file
include "src/inc/fileglglt.inc" ! general ledger transaction file
include "src/inc/fileglardetl.inc" ! g/l a/r detail file
include "src/inc/fileglcrdetl.inc" ! g/l c/r detail file
include "src/inc/fileglcddetl.inc" ! g/l c/d detail file ! ap checks
include "src/inc/fileglapdetl.inc" ! g/l ap detail file ! ap transactions
include "src/inc/fileglmrdetl.inc" ! g/l misc rts detail file ! misc rts 
include "src/inc/fileglglstfle.inc" ! gl statement controls
include "src/inc/fileapa10vl.inc" ! ap validation file
include "src/inc/fileglgldept.inc" ! gl dept file
include "src/inc/fileglglpctr.inc" ! gl profit center

External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus

External Lib "getwhsename.lib"
Declare External Function Getwhsename$

External Lib "getrtsrsnd.lib"
Declare External Function Getrtsrsnd$

External Lib "getprodd.lib"
Declare External Function Getprodd$

External Lib "getglname.lib"        
Declare External Function getglname$

 External Lib "sffiles.lib"                                                

 Declare External Function getcurrentdate 
 

 

 
!
External Lib "libgeneralcode.lib"
Declare External Function ConvertDate
!
External Lib "ubsfunc.dl4"
Declare External Sub getportdefault,LogAccess
Declare External Function OpenFile,PDate$,FormatDate2$
Declare External Function getuidrec,getuidinfo$
Declare External Function CHKBADCHARS


Declare Intrinsic Function FindChannel
Declare Intrinsic Sub DateToJulian,JulianToDate,VerifyDate,CheckNumber,Time,FindF
Declare Intrinsic Sub String
!
!
Declare sub OpenFiles
Declare sub OpenGlmFile,OpenGlbFile
Declare sub GetGlAcctType,GetGlStatType
Declare sub GetGlRecType
Declare sub FindAcctPeriod
Declare sub Calcglbal
Declare sub OpenGltFIle
Declare sub GetGlData
Declare sub TRACKGLWRITE
Declare sub GetGlBatch,getglEndRec1,getglEndRec2,delGlbatch,subbudbatch,subglbatch,getbatchlist
Declare sub GetStdBatch,SubStdBatch,DelStdbatch,Start643Process,Start642Process,Start641Process
Declare sub GetStatType,SubStatType,StatAutoLoad,StatTypeLoad,SubStatGLLoad

!
!--------------------------------------------------------------------
!
!
! ** main procedure
!
!
try
  !
  dim e$[500],buttonlist$[5,50],nextlist$[5,100] ! error handling variables
  dim bsdel$[20],esdel$[20],rdel$[20],fdel$[20],rstr$[5000]
  dim Section$[30],Field$[20,30]
  dim mergedir$[60],action$[20],action1$[20],options$[20]
  dim Company$[2],UserID$[8]
  dim xdate$[10]
  dim 1%,deptflag,glcurrper,soyper,somper,glfye,glmo,glyr
  dim glaccttype$[10],filename$[20],groupid$[1],x$[100],glrectype$[20],jsccode$[2]
  dim keyacf$[8],keyglm$[12],tmpkey$[12],keyglt$[40],keyglar$[40],keychk$[40]
  dim keyglcr$[40],keyglcd$[50],keyglap$[50],keyglmr$[50],whsename$[30],rtsrsnd$[21],prodd$[60],glname$[22]
  dim 2%,apdate,acper,acptdate
  dim 3%,clientid,fileflag
  dim 3%,acfrec,glmrec,tmprec,gltrec,glarrec,glcrec,glcdrec,glaprec,glmrrec
  dim 4%,hdrbal[4],mtdbal[39],ytdbal[39],glper[39]
  dim artype$[50],filetype$[1]
  LET artype$="INVSVCNSFD/ALATC/MUN.C/APAY"  
  dim keyglst$[10],3%,rec_glst,1%,ch_glst
  dim custom_customer$[30]
  dim 1%,ordedit,nolines,newrecord,balexist
  dim 1%,tmp1,intCo,intSls,CTLC,errflag,WH,Div,portnum,chan[25],flag
  dim 2%,tmp2,maxcnt \ maxcnt=2000 ! max records in arrays
  dim 3%,tmp3,JDepositDate,DocNo,rec_uac
  dim keybdist$[50],3%,rec_bdist
  dim 3%,totamt
  dim 2%,conswh,maxwh,currdate
  
  dim 3%,tmprec[10]
  dim 4%,tmp4
  
  dim tmppo$[20],chkpo$[20],3%,rec_tmp
  dim WORK$[600]
 
  DIM TRACK$[80],TRACKB$[10],TRACKC$[64],TRACKD$[30],TRACKSCRIPT$[130] 
  DIM TRACKNAME$[20],TRACKFILENAME$[30] 
  DIM 1%,UREC,3%,TRACKSCRATCH[2] 
 
  dim userid$[8]
  dim p60$[50],p61$[256]
  dim List$[maxcnt,700],sdate$[50]
  dim SList$[maxcnt,700] ! for .net selector(drop down) list
  dim logfname$[50]
  dim CustNo$[6],SearKey$[64],BegKey$[64],mode$[3]
  dim Desc$[50],PayFlag$[1],RecType$[1],DocNo$[10],ARInvKey$[64],InvType$[3]
  dim tmp$[200],tmp1$[200],WebStr$[1000],Message$[200],artermd$[16],overpswd$[30]
  Dim keyacf1$[10],1%,batchnum,3%,rec_acf1
  dim keydept$[10],1%,ch_dept,3%,rec_dept
  dim keypc$[20],pcmask$[10],1%,ch_pc,pcflag,pcspos,pcepos,3%,rec_pc
  dim 1%,batchnum,2%,batchid
  dim 3%,rec_bth,seqnum,bthctrl$[64],bthctrl1$[64],3%,bthctrlamt,rec_uac
  dim bthdesc$[64],3%,bthamt
  DIM 1%,BUDFLAG,multclientflag
  Dim 3%,spec[50],spec1[30]
  dim updatetype$[1],1%,overwrite,2%,curryear,lastyear,1%,scurrper,ecurrper,slastper,elastper,keyglb$[50],3%,rec_glb
  dim blank$[200] \ blank$=" ",blank$
  dim M3$[3] \ M3$="###"
  dim M6$[6] \ M6$="######"
  dim M10$[10] \ M10$="##########"
  dim 3%
  let tmp$=tim(4) using "&&&&&&"
  let work$=tmp$[5,6],tmp$[1,2],tmp$[3,4]
  let currdate=work$
LET TRACKSCRATCH[0]=0  
LET TRACKSCRATCH[1]=0  
LET TRACKSCRATCH[2]=0   
 
  !!! define structures !!! 
  dim Cust. as cust ! customer
  dim acf. as glacf ! application control file
  dim glm. as glglm ! gl master file
  dim oglm. as glglm ! gl master/budget - original
  dim bdist. as glbdist ! gl budget distribution file
  dim glt. as glglt ! gl transaction file
  dim glar. as glardetl ! gl ar detail file
  dim glcr. as glcrdetl ! gl cr detail file
  dim glcd. as glcddetl ! gl cd detail file
  dim glap. as glapdetl ! gl ap detail file
  dim glmr. as glmrdetl ! gl misc rts detail file
  dim glst. as glglstfle! gl statement file
  dim apvl. as apa10vl ! ap validation file
  dim dept. as glgldept ! gl department file
  dim pc. as glglpctr ! gl profit center file

  Def FNR(H) = Int(Abs(H) * 100 + .5) * .01 * Sgn(H)
  !
  call dxopen()
  Call dxget("S_USER.AppID",tmp$) !company #               
                                                         
  Try Let intCo = Val(tmp$) Else Let intCo = 1 !company #  
  ctlc = OpenFile(9999,intCo) \ If ctlc = -1 Error 42 !control   ! openning with read/write
  call GetSession(e$,CTLC,options$,action$,UserID$,intCo,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$,action1$)
  call LogAccess(e$)
  ! call GetPortDefault(e$,IntCO,UserID$,portnum,rec_uac,prt.) ! get port default need prt. include
  mat read #ctlc,60,50;p60$; ! system flag variable
  mat read #ctlc,61,0;p61$;
  read #ctlc,51,10;deptflag;
  read #ctlc,0,134;apdate;
  mat read #ctlc,115,60;custom_customer$;
  let custom_customer$=UCase$(trim$(custom_customer$))
  !REC_UAC = GetUIDRec(e$,IntCo,Userid$)
  !
  call dxget("s_view.mergedir",mergedir$)
   Call DXGet("u_group",groupid$)
  if rtrim$(groupid$)="" let groupid$="0"
  !
  call OpenFiles()
  !
  select case action$

  case "GETCLIENT" !   DROPLIST OF CLIENT
	call FileDropListglacfz(e$,List$[],100,ch_acf) ! Acf file
	call AddToStr(e$,rstr$,List$[])
        call SetOutput(e$,rstr$)

  Case "GETCLIENTLIST"
	returnstatus=1
	message$="OK"
	!call FileDropListglacfz(e$,List$[],100,ch_acf) ! Acf file
	!call AddToStr(e$,rstr$,List$[])
	clear list$[]
	List$[0]=bsdel$,"Client",fdel$
	Webstr$="Id",fdel$
	Webstr$=webstr$,"ClientName",fdel$
	webstr$=webstr$,"Budget",fdel$
	List$[1]=webstr$
	read #ctlc,51,8;budflag;
	let keyacf$=" ",keyacf$
	row=2
	let tmpcnt=maxcnt
	do
		search #ch_acf,3,1;keyacf$,rec_acf,e
		if e<>0 exit do
		if keyacf$[7,8]="  "
			let webstr$=keyacf$[3,6],fdel$
			
			read record #ch_acf,rec_acf;acf.;
			let webstr$=webstr$,acf.clientname$,fdel$
			let tmp$="N"
			if budflag<>0
				let clientid=keyacf$[3,6]
				tmp = acf.DirNum$                                                                          
				filename$ = Str$(tmp) + "/GLB" + Str$(intco) + groupid$                                        
				tmp$ = clientid Using "####"                          
				For ctr = 1 To 4                                      
					if tmp$[ctr,ctr] = " " Let tmp$[ctr,ctr] = "."      
				Next ctr                                              
				filename$ = filename$ + tmp$                          
				Call FindF(filename$,fileflag)                        
				If Not(fileflag)
					let tmp$="N"
				else
					let tmp$="Y"
				endif
			endif
			let webstr$=webstr$+tmp$,fdel$
			list$[row]=webstr$
			let row=row+1
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
		endif
	loop
	list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])
	Call CreateNetStatus(e$,returnstatus,message$,webstr$) 
        Call AddToStr(e$,rstr$,webstr$)                        
        call SetOutput(e$,rstr$)
  case "GETDROPLIST" !   DROPLIST OF CLIENT
	returnstatus=1
	message$="OK"
	!call FileDropListglacfz(e$,List$[],100,ch_acf) ! Acf file
	!call AddToStr(e$,rstr$,List$[])
	clear list$[]
	List$[0]=bsdel$,"Client",fdel$
	Webstr$="Id",fdel$
	Webstr$=webstr$,"ClientName",fdel$
	webstr$=webstr$,"Budget",fdel$
	List$[1]=webstr$
	read #ctlc,51,8;budflag;
	let keyacf$=" ",keyacf$
	row=2
	let tmpcnt=maxcnt
	do
		search #ch_acf,3,1;keyacf$,rec_acf,e
		if e<>0 exit do
		if keyacf$[7,8]="  "
			let webstr$=keyacf$[3,6],fdel$
			
			read record #ch_acf,rec_acf;acf.;
			let webstr$=webstr$,acf.clientname$,fdel$
			let tmp$="N"
			if budflag<>0
				let clientid=keyacf$[3,6]
				tmp = acf.DirNum$                                                                          
				filename$ = Str$(tmp) + "/GLB" + Str$(intco) + groupid$                                        
				tmp$ = clientid Using "####"                          
				For ctr = 1 To 4                                      
					if tmp$[ctr,ctr] = " " Let tmp$[ctr,ctr] = "."      
				Next ctr                                              
				filename$ = filename$ + tmp$                          
				Call FindF(filename$,fileflag)                        
				If Not(fileflag)
					let tmp$="N"
				else
					let tmp$="Y"
				endif
			endif
			let webstr$=webstr$+tmp$,fdel$
			list$[row]=webstr$
			let row=row+1
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
		endif
	loop
	list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])
	Clear list$[]
	List$[0]=bsdel$,"GLRecType",fdel$
	Webstr$="Id",fdel$
	Webstr$=webstr$,"Description",fdel$
	List$[1]=webstr$! RECORD TYPE
	list$[2]="0",fdel$,"Normal",fdel$
	list$[3]="1",fdel$,"Memo",fdel$
	list$[4]="2",fdel$,"Non-Print Memo",fdel$
	list$[5]="3",fdel$,"Total",fdel$
	list$[6]="4",fdel$,"Non-Print Memo",fdel$
	list$[7]="5",fdel$,"Page Eject",fdel$
	list$[8]=esdel$
	call AddToStr(e$,rstr$,List$[])
	Clear list$[]
	List$[0]=bsdel$,"GLAcctType",fdel$
	Webstr$="Id",fdel$
	Webstr$=webstr$,"Description",fdel$
	List$[1]=webstr$! RECORD TYPE
	
	list$[2]="A",fdel$,"Asset",fdel$
	list$[3]="L",fdel$,"Liability",fdel$
	list$[4]="C",fdel$,"Capital",fdel$
	list$[5]="I",fdel$,"Income",fdel$
	list$[6]="E",fdel$,"Expense",fdel$
	list$[7]="R",fdel$,"Other Revenue",fdel$
	list$[8]="O",fdel$,"Other Expense",fdel$
	List$[9]=" ",fdel$,"No Record Type",fdel$
	list$[10]=esdel$
	call AddToStr(e$,rstr$,List$[])
	clear list$[]
	List$[0]=bsdel$,"GLStatType",fdel$
	Webstr$="Id",fdel$
	Webstr$=webstr$,"Description",fdel$
	List$[1]=webstr$
	list$[2]=" ",fdel$,"No Statement Type",fdel$
	let row=3
	let tmpcnt=maxcnt
	Try 
		Ch_glst = OpenFile(-192,Intco)
	else
		goto endglstattype:
	end Try
	let keyglst$=" ",keyglst$
	do
		search #ch_glst,3,1;keyglst$,rec_glst,e
		if e<>0 goto endglstattype:
		read record #ch_glst,rec_glst;glst.;
		webstr$=glst.StatementCode$,fdel$
		let tmp$=rtrim$(glst.StartingDescription$)
		if tmp$=""
			tmp$=rtrim$(glst.EndingDescription$)
		endif
		webstr$=webstr$,rtrim$(tmp$),fdel$
		list$[row]=webstr$
		row=row+1
		If row > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
	loop
	endglstattype: ! 
	let list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])
	Call CreateNetStatus(e$,returnstatus,message$,webstr$) 
        Call AddToStr(e$,rstr$,webstr$)                        
        call SetOutput(e$,rstr$)

 case "CLIENTDATA" ! -- get client, accounting periods, gl account droplist
	Try                                
		ch_glst = OpenFile(-192,intco)   
	Else                               
		ch_GLST=0
	End Try
	if deptflag<>0
		read #ctlc,88,128;filename$;                                   
		Call FindF(filename$,fileflag)                              
		if not(fileflag)                                            
			let deptflag=0                                
		else                                                      
			ch_dept= FindChannel()                                      
			Try                                                         
                open#ch_dept,filename$                              
			else                                                        
                let deptflag=0                                
			end try
		endif
	endif                                       
	call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(clientid)+" Not On File"
	endif
	if returnstatus>0
		call dxget ("FILETYPE",tmp$)
		if ucase$(TMP$)="M"
			call openglmfile()
		else
			if ucase$(tmp$)="B"
				call openglbfile()
			else
				let returnstatus=0
				let message$="Invalid File Type "
			endif
		endif
	endif
	! section 1 - send over acct periods
	clear list$[]
	List$[0]=bsdel$,"GLCLIENTHDR",fdel$
	Webstr$="ClientID",fdel$,"ClientName",fdel$
	Webstr$=Webstr$+"BegBal",fdel$
	webstr$=webstr$+"CurrPer",fdel$
	List$[1]=webstr$
	if returnstatus>0
		webstr$=str$(clientid),fdel$
		webstr$=webstr$,rtrim$(acf.ClientName$),fdel$
		webstr$=webstr$,"BEG BAL",fdel$
		let xdate$=apdate using "&&&&&&" ! yymmdd
		let tmp$=xdate$[3,4],"/",xdate$[1,2]
		webstr$=webstr$,tmp$,fdel$
		list$[2]=webstr$
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! section 2 - droplist for accounting periods
	List$[0]=bsdel$,"GLACCTPER",fdel$
	webstr$="ID",fdel$,"AcctPer",fdel$
	list$[1]=webstr$
	let row=2
	webstr$=""
	startper=1
	if returnstatus>0
		let row=2
		let tmpcnt=maxcnt ! 2000
		for ctr=startper to 39
			webstr$=(ctr using "##"),fdel$
			let tmp$=glm.currperbal[ctr] using "&&&&"
			let x$=tmp$[3,4],"/",tmp$[1,2]
			let webstr$=webstr$+rtrim$(x$)+fdel$
			list$[row]=webstr$
			let row=row+1
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
		next ctr
		
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! section 3 -- send over droplist
	Clear list$[]
	List$[0]=bsdel$,"GLMDroplist",fdel$
	Webstr$="Id",fdel$
	Webstr$=webstr$,"Description",fdel$
	Webstr$=webstr$,"AcctType",fdel$
	Webstr$=webstr$,"StatType",fdel$
	Webstr$=webstr$,"Dept",fdel$
	List$[1]=webstr$
	if returnstatus>0 ! no errors
		let row=2
		let tmpcnt=maxcnt ! 2000
		let keyglm$=" ",keyglm$
		do
			search #ch_glm,3,1;keyglm$,glmrec,e
			if e>0 exit do
			read record #ch_glm,glmrec;glm.;	
			! normal posting account
			let webstr$=keyglm$,fdel$
			let webstr$=webstr$,rtrim$(glm.Desc$),fdel$
			call getglaccttype()
			let webstr$=webstr$,rtrim$(glaccttype$),fdel$
			if rtrim$(glm.stattype$)<>""
				call getglstattype()
				tmp$=""
				If rtrim$(glst.StartingDescription$)<>"" 
					let tmp$=" "+rtrim$(glst.StartingDescription$)
				else 
					if rtrim$(glst.EndingDescription$)<>""
						tmp$=" "+rtrim$(glst.EndingDescription$)
					endif
				endif
					let webstr$=webstr$,glm.stattype$,tmp$,fdel$
			else
				let tmp$=""
				let webstr$=webstr$,tmp$,fdel$
			endif
			let tmp$=""
			!! check the dept flag from the control record
			if deptflag<>0
				let tmp$=keyglm$[8,9]
				let tmp3=tmp$
				let keydept$[1,4]=clientid using "####" 
				let keydept$[5,6]=tmp3 using "##"                                                       
				search #ch_dept,2,1;keydept$,rec_dept,e             
				if not (e)   
					read record #ch_dept,rec_dept;dept.;                
				else
					clear dept.
				endif
				let tmp$=tmp3 using "&&"
				if rtrim$(dept.name$)<>""
					let tmp$=tmp$+" - "+rtrim$(dept.name$)
				endif
			endif
			let webstr$=webstr$,rtrim$(tmp$),fdel$
			let list$[row]=webstr$
			let row=row+1
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
			!endif		
		loop ! for the do
	endif ! for returnstatus
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section		
	! section 5 - status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)

	
  case "GETGLM" ! -- get client, accounting periods, gl account droplist
	call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(clientid)+" Not On File"
	endif
	if returnstatus<>0
		call openglmfile()
	endif
	! section 1 - send over acct periods
	call dxget ("SOURCE",tmp$)
	let source=tmp$
	clear list$[]
	List$[0]=bsdel$,"GLCLIENTHDR",fdel$
	Webstr$="ClientID",fdel$,"ClientName",fdel$
	Webstr$=Webstr$+"BegBal",fdel$
	webstr$=webstr$+"CurrPer",fdel$
	List$[1]=webstr$
	if returnstatus>0
		webstr$=str$(clientid),fdel$
		webstr$=webstr$,rtrim$(acf.ClientName$),fdel$
		webstr$=webstr$,"BEG BAL",fdel$
		let xdate$=apdate using "&&&&&&" ! yymmdd
		let tmp$=xdate$[3,4],"/",xdate$[1,2]
		webstr$=webstr$,tmp$,fdel$
		list$[2]=webstr$
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! section 2 - droplist for accounting periods
	List$[0]=bsdel$,"GLACCTPER",fdel$
	webstr$="ID",fdel$,"AcctPer",fdel$
	list$[1]=webstr$
	let row=2
	webstr$=""
	startper=1
	if returnstatus>0
	if source=611
		let keyglm$=" ",keyglm$
		let keyglm$[1,2]="NN"
		search #ch_glm,2,1;keyglm$,glmrec,e
		if not(e)
			 read record #ch_glm,glmrec;glm.;
			if glm.currperbal[13]<>0
				let startper=14
			endif
			if glm.currperbal[26]<>0
				let startper=27
			endif
		endif
	Endif
	if source=615 
		let startper=1
	endif
	if source=611 or source=615
		let keyglm$=" ",keyglm$                                                  
		Search #ch_glm,2,1;keyglm$,glmrec,e                                       
		If e<>0                                                                      
			returnstatus = 0                                                        
			message$ = "G/L Master File Control Record for Client ",Str$(clientid),"Not On File"                                                                   
		Else                                                                      
			Read Record #ch_glm,glmrec;glm.;                                        
		End If 

	Endif
	Endif
	if returnstatus>0
		let row=2
		let tmpcnt=maxcnt ! 2000
		if source=615
			webstr$="0",fdel$ ! id
			webstr$=webstr$,"0",fdel$ ! all accounting periods
			list$[row]=webstr$
			row=row+1
		endif
		for ctr=startper to 39
			if source=611 or source=613 or source=612 or source=615 ! bypass end of year items
				if ctr=13 goto getpernextctr:
				if ctr=26 goto getpernextctr:
				if ctr=39 goto getpernextctr:
			endif
			webstr$=(ctr using "##"),fdel$
			let tmp$=glm.currperbal[ctr] using "&&&&"
			let x$=tmp$[3,4],"/",tmp$[1,2]
			let webstr$=webstr$+rtrim$(x$)+fdel$
			list$[row]=webstr$
			let row=row+1
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
			getpernextctr:
		next ctr
		
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! section 3 -- send over droplist
	Clear list$[]
	List$[0]=bsdel$,"GLMDroplist",fdel$
	Webstr$="Id",fdel$
	Webstr$=webstr$,"Description",fdel$
	Webstr$=webstr$,"AcctType",fdel$
	Webstr$=webstr$,"StatType",fdel$
	Webstr$=webstr$,"Dept",fdel$
	List$[1]=webstr$
	if returnstatus>0 ! no errors
		let row=2
		let tmpcnt=maxcnt ! 2000
		let keyglm$=" ",keyglm$
		do
			search #ch_glm,3,1;keyglm$,glmrec,e
			if e>0 exit do
			read record #ch_glm,glmrec;glm.;
			if source=612
				if glm.rectype$[1,1]<"1" or glm.rectype$[1,1]>"2" goto getnxtglacct:
			else
				if glm.rectype$[1,1]<>"0" goto getnxtglacct:
			endif
			if keyglm$[1,1]<>" " goto getnxtglacct:
			! normal posting account
				let webstr$=keyglm$,fdel$
				let webstr$=webstr$,rtrim$(glm.Desc$),fdel$
				call getglaccttype()
				let webstr$=webstr$,rtrim$(glaccttype$),fdel$
				let webstr$=webstr$,rtrim$(glm.stattype$),fdel$
				let tmp$=" "
				!! check the dept flag from the control record
				if deptflag
					let tmp$=keyglm$[8,9]
				endif
				let webstr$=webstr$,rtrim$(tmp$),fdel$
				let list$[row]=webstr$
				let row=row+1
				If row > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
			!endif
			getnxtglacct: ! getnxtglacct
		loop ! for the do
	endif ! for returnstatus
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section		
	! section 5 - status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)
!!!! START GETGLACCT !!!
case "GETGLACCT" ! get acct info and balances
	call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(clientid)+" Not On File"
	endif
	if returnstatus>0
		call dxget ("FILETYPE",tmp$)
		if rtrim$(tmp$)="" let tmp$="M"
		filetype$=ucase$(rtrim$(tmp$))
		if filetype$="M"
			call openglmfile()
		else
			if filetype$="B"
				call openglbfile()
				!let ch_glm=ch_glb
			else
				let returnstatus=0
				let message$="Invalid File Type "
			endif
		endif
	endif
	! MTG
	!if returnstatus>0
	!	call openglmfile()
	!endif
	if returnstatus>0
		call dxget ("glacctid",tmp$)
		let glacctid=tmp$
		let keyglm$=" ",keyglm$
		let keyglm$[2,9]=glacctid using "########"
		search #ch_glm,2,1;keyglm$,glmrec,e
		if e
			let returnstatus=0
			let Message$="G/L Account "+str$(glacctid)+" Not On File"
		endif
	endif
	if returnstatus>0
		read record #ch_glm,glmrec;glm.;
		call getglaccttype()
		call getglrectype()
		let work$=apdate using "&&&&&&"
		let acper=work$[1,4]
		call FindAcctPeriod()
		call Calcglbal ()
		
		
	endif
	! section 1 - send over info
	clear list$[]
	List$[0]=bsdel$,"GLACCTHDR",fdel$
	Webstr$="ClientID",fdel$,"ClientName",fdel$
	Webstr$=Webstr$,"GLAcctID",fdel$
	Webstr$=Webstr$+"RecType",fdel$ ! 
	Webstr$=Webstr$+"AcctType",fdel$ !
	Webstr$=Webstr$+"Desc",fdel$ !
	Webstr$=Webstr$+"StatType",fdel$ !
	Webstr$=Webstr$+"CurrAcctPer",fdel$
	Webstr$=Webstr$+"StartYrBal",fdel$
	Webstr$=Webstr$+"StartMoBal",fdel$
	Webstr$=Webstr$+"MoChgBal",fdel$
	Webstr$=Webstr$+"YrChgBal",fdel$
	Webstr$=Webstr$+"EndBal",fdel$
	list$[1]=webstr$
	if returnstatus>0
		webstr$=str$(clientid),fdel$
		webstr$=webstr$,rtrim$(acf.ClientName$),fdel$
		webstr$=webstr$,rtrim$(glm.glacct$),fdel$
		webstr$=webstr$,glm.rectype$," ",glrectype$,fdel$
		webstr$=webstr$,glm.accttype$," ",glaccttype$,fdel$
		webstr$=webstr$,rtrim$(glm.desc$),fdel$
		Webstr$=webstr$,rtrim$(glm.stattype$),fdel$
		let tmp$=apdate using "&&&&&&"
		Webstr$=webstr$,tmp$[3,4],"/",tmp$[1,2],fdel$
		Webstr$=webstr$,rtrim$(hdrbal[0] using "----,---,---,---.##"),fdel$ ! soybal
		Webstr$=webstr$,rtrim$(hdrbal[1] using "----,---,---,---.##"),fdel$ ! sombal
		Webstr$=webstr$,rtrim$(hdrbal[2] using "----,---,---,---.##"),fdel$ ! mochgbal
		Webstr$=webstr$,rtrim$(hdrbal[3] using "----,---,---,---.##"),fdel$ ! yrchgbal
		tmp3=hdrbal[0]+hdrbal[3]
		Webstr$=webstr$,rtrim$(tmp3 using "----,---,---,---.##"),fdel$ ! Endbal
		list$[2]=webstr$
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! section 2 -- gl mtd balances
	Clear list$[]
	List$[0]=bsdel$,"GLMTDBAL",fdel$
	Webstr$="PerId",fdel$,"MTDBal",fdel$
	list$[1]=webstr$
	if returnstatus>0 
		Webstr$="Beg Bal",fdel$
		Webstr$=webstr$,rtrim$(mtdbal[0] using "----,---,---,---.##"),fdel$ ! beginning bal
		list$[2]=webstr$
		row=3
		tmpcnt=maxcnt ! 2000
		for ctr=1 to 39
			webstr$=str$(ctr),fdel$
			Webstr$=webstr$,rtrim$(mtdbal[ctr] using "----,---,---,---.##"),fdel$
			list$[row]=webstr$
			let row=row+1
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
		next ctr
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 

	! section 3-- gl ytd balances
	Clear list$[]
	List$[0]=bsdel$,"GLYTDBAL",fdel$
	Webstr$="PerId",fdel$,"YTDBal",fdel$
	list$[1]=webstr$
	if returnstatus>0 
		Webstr$="Beg Bal",fdel$
		Webstr$=webstr$,rtrim$(ytdbal[0] using "----,---,---,---.##"),fdel$ ! beginning bal
		list$[2]=webstr$
		row=3
		tmpcnt=maxcnt ! 2000
		for ctr=1 to 39
			webstr$=str$(ctr),fdel$
			Webstr$=webstr$,rtrim$(ytdbal[ctr] using "----,---,---,---.##"),fdel$
			list$[row]=webstr$
			let row=row+1
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
		next ctr
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 

	
			
	! section 5 - status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)

	

!!! END GET GLACCT



case "GLACCTDATA" ! get acct info and balances
	call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(clientid)+" Not On File"
		goto endglacctdata
	endif
	call dxget ("FILETYPE",tmp$)
	filetype$=ucase$(rtrim$(tmp$))
	if filetype$="M"
		call openglmfile()
	else
		if filetype$="B"
			call openglbfile()
		else
			let returnstatus=0
			let message$="Invalid File Type "
			goto endglacctdata
		endif
	endif
	NEWRECORD=0
	let alphaacct=0
	call dxget ("glacctid",tmp$)
	if rtrim$(tmp$)=""
		let returnstatus=0
		let message$="Invalid GL Account Number"
		goto endglacctdata:
	endif
	let glacctid=tmp$
	if glacctid<>0
		if glacctid<=0 or glacctid>99999999
			let returnstatus=0
			let Message$="Invalid GL Account Id"
			goto endglacctdata:
		endif
		let keyglm$=" ",keyglm$
		let keyglm$[2,9]=glacctid using "########"
	else
		let tmp$=rtrim$(ucase$(tmp$))
		if tmp$="A" or tmp$="L" or tmp$="C" let alphaacct=99
		if tmp$="I" or tmp$="E" or tmp$="R" or tmp$="O" let alphaacct=99
		if tmp$="NN" or tmp$="N" let alphaacct=99
		if not(alphaacct)
			let returnstatus=0
			let message$="Invalid GL Alpha Account Number"
			goto endglacctdata:	
		Endif
		let keyglm$=rtrim$(tmp$)+blank$
	endif
	search #ch_glm,2,1;keyglm$,glmrec,e
	if e>1
			let returnstatus=0
			let Message$="Error in obtaining G/L Account Information For File"
	ELSE
	if e=1
		clear glm.
		glm.accttype$=" ",glm.accttype$
		glm.rectype$=" ",glm.rectype$
		glm.desc$=" ",glm.desc$
		glm.stattype$=" ",glm.stattype$
		let newrecord=99
		if alphaacct<>0
			let glm.ACCTTYPE$[1,1]=" "
			let glm.rectype$[1,1]="1"
			call getglaccttype()
			call getglrectype()
		endif
	else
		read record #ch_glm,glmrec;glm.;
		call getglaccttype()
		call getglrectype()
		endif
	endif
	balexist=0
	let work$=apdate using "&&&&&&"
	let acper=work$[1,4]
	call FindAcctPeriod()
	call Calcglbal ()
	if alphaacct<>0 let balexist=99
	endglacctdata: ! get headings
	! section 1 - send over info
	clear list$[]
	List$[0]=bsdel$,"GLACCTHDR",fdel$
	Webstr$="ClientID",fdel$,"ClientName",fdel$
	Webstr$=Webstr$,"GLAcctID",fdel$
	Webstr$=Webstr$+"RecType",fdel$ ! 
	Webstr$=Webstr$+"AcctType",fdel$ !
	Webstr$=Webstr$+"Desc",fdel$ !
	Webstr$=Webstr$+"StatType",fdel$ !
	Webstr$=Webstr$+"CurrAcctPer",fdel$
	Webstr$=Webstr$+"StartYrBal",fdel$
	Webstr$=Webstr$+"StartMoBal",fdel$
	Webstr$=Webstr$+"MoChgBal",fdel$
	Webstr$=Webstr$+"YrChgBal",fdel$
	Webstr$=Webstr$+"EndBal",fdel$
	Webstr$=webstr$+"NewRecord",fdel$
	Webstr$=webstr$+"BalanceExist",fdel$
	Webstr$=webstr$+"UpdateBud",fdel$
	Webstr$=webstr$+"UpdateAp",fdel$
	list$[1]=webstr$
	if returnstatus>0
		webstr$=str$(clientid),fdel$
		webstr$=webstr$,rtrim$(acf.ClientName$),fdel$
		webstr$=webstr$,rtrim$(glm.glacct$),fdel$
		webstr$=webstr$,glm.rectype$,fdel$
		webstr$=webstr$,glm.accttype$,fdel$
		webstr$=webstr$,rtrim$(glm.desc$),fdel$
		Webstr$=webstr$,rtrim$(glm.stattype$),fdel$
		let tmp$=apdate using "&&&&&&"
		Webstr$=webstr$,tmp$[3,4],"/",tmp$[1,2],fdel$
		Webstr$=webstr$,rtrim$(hdrbal[0] using "----,---,---,---.##"),fdel$ ! soybal
		Webstr$=webstr$,rtrim$(hdrbal[1] using "----,---,---,---.##"),fdel$ ! sombal
		Webstr$=webstr$,rtrim$(hdrbal[2] using "----,---,---,---.##"),fdel$ ! mochgbal
		Webstr$=webstr$,rtrim$(hdrbal[3] using "----,---,---,---.##"),fdel$ ! yrchgbal
		tmp3=hdrbal[0]+hdrbal[3]
		Webstr$=webstr$,rtrim$(tmp3 using "----,---,---,---.##"),fdel$ ! Endbal
		if newrecord<>0 let tmp$="Y" else let tmp$="N"
		if alphaacct<>0 let tmp$="N"
		Webstr$=webstr$+tmp$,fdel$
		if balexist<>0 let tmp$="Y" else let tmp$="N"
		Webstr$=webstr$+tmp$,fdel$
		let tmp$="N"
		if newrecord<>0
			if filetype$<>"B"
				read #ctlc,51,8;budflag;
				if budflag<>0                                                                         
					filename$ = "1/GLB" + Str$(intco) + groupid$                                        
					tmp$ = clientid Using "####"                          
					For ctr = 1 To 4                                      
						if tmp$[ctr,ctr] = " " Let tmp$[ctr,ctr] = "."      
					Next ctr                                              
					filename$ = filename$ + tmp$                          
					Call FindF(filename$,fileflag)                        
					If Not(fileflag)
						let tmp$="N"
					else
						let tmp$="Y"
					endif
				endif		
			endif
		endif
		Webstr$=webstr$+tmp$,fdel$
		let tmp$="N"
		if newrecord<>0
			read #ctlc,88,32;filename$;                    
			Call FindF(filename$,fileflag)                        
			If Not(fileflag)
				let tmp$="N"
			else
				let tmp$="Y"
			endif
			if alphaacct<>0 let tmp$="N" ! do not update 
			!let tmp$="Y" ! updateap
		endif
		Webstr$=webstr$+tmp$,fdel$ 

		!Webstr$=webstr$+"UpdateAp",fdel$
		list$[2]=webstr$
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! section 2 -- gl mtd balances
	Clear list$[]
	!List$[0]=bsdel$,"GLMTDBAL",fdel$
	List$[0]=bsdel$,"GLBAL",fdel$
	Webstr$="PerId",fdel$,"MTDBal",fdel$,"YTDBal",fdel$
	list$[1]=webstr$
	if returnstatus>0 
		Webstr$="Beg Bal",fdel$
		Webstr$=webstr$,rtrim$(mtdbal[0] using "----,---,---,---.##"),fdel$ ! beginning bal
		Webstr$=webstr$,rtrim$(ytdbal[0] using "----,---,---,---.##"),fdel$ ! beginning bal
		list$[2]=webstr$
		row=3
		tmpcnt=maxcnt ! 2000
		for ctr=1 to 39
			webstr$=str$(ctr),fdel$
			if filetype$<>"B"
				Webstr$=webstr$,rtrim$(mtdbal[ctr] using "----,---,---,---.##"),fdel$
			else
				Webstr$=webstr$,rtrim$(mtdbal[ctr] using "----------------.##"),fdel$	
			endif
			Webstr$=webstr$,rtrim$(ytdbal[ctr] using "----,---,---,---.##"),fdel$
			list$[row]=webstr$
			let row=row+1
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
		next ctr
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 

	! section 3-- gl ytd balances
	!Clear list$[]
	!List$[0]=bsdel$,"GLYTDBAL",fdel$
	!Webstr$="PerId",fdel$,"YTDBal",fdel$
	!list$[1]=webstr$
	!if returnstatus>0 
	!	Webstr$="Beg Bal",fdel$
	!	Webstr$=webstr$,rtrim$(ytdbal[0] using "----,---,---,---.##"),fdel$ ! beginning bal
	!	list$[2]=webstr$
	!	row=3
	!	for ctr=1 to 39
	!		webstr$=str$(ctr),fdel$
	!		Webstr$=webstr$,rtrim$(ytdbal[ctr] using "----,---,---,---.##"),fdel$
	!		list$[row]=webstr$
	!		let row=row+1
	!		If row > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
	!	next ctr
	!endif
	!call AddToStr(e$,rstr$,List$[])
	!Call AddToStr(e$,rstr$,esdel$) ! end of section 

	
			
	! section 5 - status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)

	

!!! END GET GLACCTDATA

!!! submit the gl acct data
case "SUBGLACCTDATA" ! get acct info and balances
	call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(clientid)+" Not On File"
		goto endsubglacctdata:
	endif
	call dxget ("FILETYPE",tmp$)
	filetype$=ucase$(rtrim$(tmp$))
	if filetype$="M"
		call openglmfile()
		IF not(returnstatus)
			goto endsubglacctdata:
		endif
	else
		if filetype$="B"
			call openglbfile()
			IF not(returnstatus)
				goto endsubglacctdata:
			endif
		else
			let returnstatus=0
			let message$="Invalid File Type "
			goto endsubglacctdata:
		endif
	endif
	call dxget ("NEWRECORD",tmp$)
	let newrecord=0
	if ucase$(rtrim$(tmp$))="Y" let newrecord=99
	let alphaacct=0		
	call dxget ("glacctid",tmp$)
	let glacctid=tmp$
	if glacctid<>0
		if glacctid<=0 or glacctid>99999999
			let returnstatus=0
			let Message$="Invalid G/l Account Id"
			goto endsubglacctdata:
		endif
		let keyglm$=" ",keyglm$
		let keyglm$[2,9]=glacctid using "########"
		let alphaacct=0
	else
		let tmp$=rtrim$(ucase$(tmp$))
		if tmp$="A" or tmp$="L" or tmp$="C" let alphaacct=99
		if tmp$="I" or tmp$="E" or tmp$="R" or tmp$="O" let alphaacct=99
		if tmp$="NN" or tmp$="N" let alphaacct=99
		if not(alphaacct)
			let returnstatus=0
			let message$="Invalid GL Account Number"
			goto endsubglacctdata:	
		Endif
		let keyglm$=rtrim$(tmp$)+blank$
	endif
	search #ch_glm,2,1;keyglm$,glmrec,e
	if e>1
		let returnstatus=0
		let Message$="Error in obtaining G/L Account Information For File"
		goto endsubglacctdata:
	endif
	if e=1
		if newrecord=0
			let returnstatus=0
			Message$="G/L Account "+str$(glacctid)+" Not on File "
			goto endsubglacctdata:
		endif
		if newrecord=99
			call dxget ("DELETEFLAG",tmp1$)
			if ucase$(rtrim$(tmp1$))="Y" ! DELETE RECORD
			
				let message$="G/L Account "+str$(glacctid)+" Not Added to File "
				goto endsubglacctdata:
			endif
		endif
		clear glm.
		let GLM.DESC$=" ",glm.desc$
		let GLM.StatType$=" ",glm.stattype$
		let glm.rectype$=" ",glrectype$
		let glm.accttype$=" ",glaccttype$
		let glm.GLAcct$=" ",glm.glacct$
		let glm.GlAcct$[2,9]=glacctid using "########"
		if alphaacct<>0
			let glm.glacct$=rtrim$(tmp$)+blank$
		endif
			
	else ! record exists
 		if newrecord=99
			call dxget ("DELETEFLAG",tmp$)
			if ucase$(rtrim$(tmp$))="Y" 
				let newrecord=0
			else! DELETE RECORD
				let returnstatus=0
				Message$="G/L Account "+str$(glacctid)+" Already on File "
				goto endsubglacctdata:
			endif
		endif
		read record #ch_glm,glmrec;glm.;
		call dxget ("DELETEFLAG",tmp$)
		if ucase$(rtrim$(tmp$))="Y" ! DELETE RECORD
			if newrecord=99
				let message$="G/L Account "+str$(glacctid)+" Not Added to File "
				goto endsubglacctdata:
			endif
			if filetype$="M" ! check balances
				for ctr=0 to 39
					if glm.currperbal[ctr]<>0
						returnstatus=0
						Message$="G/L Account "+str$(glacctid)+" Has Activity. May Not Delete "
						goto endsubglacctdata:
					endif
				next ctr
			endif
			search #ch_glm,5,1;keyglm$,glmrec,e
			if e<>0
				returnstatus=0
				Message$="Error Deleting Key for G/L Account "+str$(glacctid)
				goto endsubglacctdata:	
			endif
			let e=3\search #ch_glm,1,0;keyglm$,glmrec,e
			if e<>0
				returnstatus=0
				Message$="Search Error "+str$(e)+" Deleting Record for G/L Account "+str$(glacctid)
				goto endsubglacctdata:
			endif
			Message$="G/L Account "+str$(glacctid)+" Deleted "
			goto endsubglacctdata:
		endif ! delete section
	endif ! record exist
	
	Call Dxget ("RECTYPE",tmp$)
	LET TMP3=TMP$
	If tmp3<0 or tmp3>5
		returnstatus=0
		Message$="Invalid Record Type Submitted for G/L Account "+str$(glacctid)
		goto endsubglacctdata:
	endif
	let glm.RecType$=tmp3 using "&"
	if alphaacct<>0
		let glm.Rectype$="1"
		let glm.accttype$=" "
	endif
	if glm.Rectype$="0"
		Call Dxget ("ACCTTYPE",tmp$)
		let glm.AcctType$=ucase$(rtrim$(tmp$))
		if glm.accttype$="A" or glm.accttype$="L" or glm.Accttype$="C" ! balance sheet acct type
			goto okglacctype:
		endif
		if glm.accttype$="I" or glm.accttype$="E" or glm.accttype$="R" or glm.accttype$="O"
			goto okglacctype:
		endif
		if alphaacct<>0
			let glm.accttype$=" "
			goto okglacctype:
		endif
		returnstatus=0
		Message$="Invalid Account Type Submitted for G/L Account "+str$(glacctid)
		goto endsubglacctdata:
		okglacctype: ! 
	endif
	Call Dxget ("STATTYPE",tmp$)
	GLM.StatType$=(UCASE$(RTRIM$(TMP$)))+BLANK$
	Call Dxget ("DESC",tmp$)
	GLM.DESC$=RTRIM$(TMP$)+BLANK$
	strgok=CHKBADCHARS(e$,glm.desc$)
	if not(strgok) ! 
		let returnstatus=0
		let message$="Invalid Characters in Account Description"
		goto endsubglacctdata:
	Endif
	IF FILETYPE$="B" ! FOR BUDGET FILE ONLY
		FOR CTR=1 TO 39
			Call Dxget("MTDBAL" + Str$(ctr),tmp$)
			let glm.CurrPerBal[ctr]=tmp$
		next ctr
		let glm.CurrPerBal[13]=0
		let glm.CurrPerBal[26]=0
		let glm.CurrPerBal[39]=0
	ENDIF
	IF NEWRECORD<>0
		LET E=2\SEARCH #CH_GLM,1,0;KEYGLM$,glmrec,E
		if e<>0
			returnstatus=0
			Message$="Search Error "+str$(e)+" Adding Record for G/L Account "+str$(glacctid)
			goto endsubglacctdata:
		endif
		write record #ch_glm,glmrec;glm.;
		search #ch_glm,4,1;keyglm$,glmrec,e
		if e<>0
			returnstatus=0
			Message$="Error Adding Key for G/L Account "+str$(glacctid)
			goto endsubglacctdata:	
		endif
	Endif
	Write Record #ch_glm,glmrec;glm.;
	if filetype$="M"
		if newrecord<>0
			read #ctlc,51,8;budflag;
			if budflag=1
				Call Dxget("UPDATEBUD",tmp$)
				let updatebud=0
				if ucase$(rtrim$(tmp$))="Y" let updatebud=99
				if updatebud<>0
					! to make sure correct gl account is used
					! first get master file and g/l account data
					Try close #ch_glm Else Rem
					call openglmfile()
					IF not(returnstatus)
						let message$=message$+" trying to add budget acct "
						goto endsubglacctdata:
					endif
					let keyglm$=" ",keyglm$
					let keyglm$[2,9]=glacctid using "########"
					search #ch_glm,2,1;keyglm$,glmrec,e
					if e<>0
						let returnstatus=2
						Message$=" G/L Account "+str$(glacctid)+" Not Found in Master File to Update Budget"
						goto endsubglacctdata: 
					endif
					read record #ch_glm,glmrec;oglm.;
					Try close #ch_glm Else Rem  ! close out to get budget file
					!! now update budget file
					Call OpenGlbFile() ! get glb
					if not(returnstatus)
						let returnstatus=2
						Message$="G/L Budget File Not Found"
						goto chkupdateap:
					endif
					let keyglm$=" ",keyglm$
					let keyglm$[2,9]=glacctid using "########"
					search #ch_glm,2,1;keyglm$,glmrec,e
					if not(e)
						let returnstatus=2
						Message$=" G/L Account "+str$(glacctid)+" Already in Budget File "
						goto chkupdateap:
					endif
					LET E=2\SEARCH #CH_GLM,1,0;KEYGLM$,glmrec,E
					if e<>0
						returnstatus=2
						Message$="Search Error "+str$(e)+" Adding Budget Record for G/L Account "+str$(glacctid)
						goto chkupdateap: 
					endif
					write record #ch_glm,glmrec;oglm.;
					search #ch_glm,4,1;keyglm$,glmrec,e
					if e<>0
						returnstatus=2
						Message$="Error Adding Budget Key for G/L Account "+str$(glacctid)
						goto chkupdateap: ! 
					endif
				endif
			endif! update the budget file -- mtg
			chkupdateap: ! check
			Call Dxget("UPDATEAP",tmp$)
			let updateap=0
			if ucase$(rtrim$(tmp$))="Y" let updateap=99
			if updateap<>0
				! to make sure correct gl account is used
				! first get master file and g/l account data
				Try close #ch_glm Else Rem
				call openglmfile()
				IF not(returnstatus)
					let message$=message$+" trying to add budget acct "
					goto endsubglacctdata:
				endif
				let keyglm$=" ",keyglm$
				let keyglm$[2,9]=glacctid using "########"
				search #ch_glm,2,1;keyglm$,glmrec,e
				if e<>0
					let returnstatus=2
					Message$=" G/L Account "+str$(glacctid)+" Not Found in Master File to Update a/p"
					goto endsubglacctdata: 
				endif
				read record #ch_glm,glmrec;oglm.;
				read #ctlc,88,32;filename$;                    
				Call FindF(filename$,fileflag)                        
				If Not(fileflag)
					returnstatus=2
					let message$="A/P Validation File Not Found" 
				else
					ch_apvl=FindChannel()
					try 
						Open #ch_apvl,filename$
					else
						let returnstatus=2
						let message$="Unable to Open A/P Validation File"
						goto endsubglacctdata:
					end try
					let keyglm$=" ",keyglm$
					let keyglm$[2,9]=glacctid using "########"
					search #ch_apvl,2,1;keyglm$,rec_apvl,e
					if not(e)
						let returnstatus=2
						let message$="G/L Account "+str$(glacctid)+" Already in Validation File"
						goto endsubglacctdata:
					endif
					clear apvl. ! does not initialize with spaces
					apvl.desc$=" ",apvl.Desc$
					apvl.acctspare$=" ",apvl.acctspare$ ! for key
					apvl.acctid$=" ",apvl.acctid$
					apvl.acctSpare2$=" ",apvl.acctSpare2$ ! for key
					apvl.postgl$=" ",apvl.postgl$
					apvl.postdos$=" ",apvl.postdos$
					apvl.spare1$=" ",apvl.spare1$
					let apvl.desc$=rtrim$(oglm.desc$)+blank$          
					let apvl.AcctId$=glacctid using "########"            
					let apvl.postgl$="S" ! summary have gl drill down
					let apvl.postdos$="N" ! 
					let apvl.spare1$[5]="" ! set to null
					LET E=2\SEARCH #CH_apvl,1,0;KEYGLM$,REC_apvl,E
					if e<>0
						returnstatus=2
						Message$="Search Error "+str$(e)+" Adding Validation Record for G/L Account "+str$(glacctid)
						goto endsubglacctdata:
					endif
					write record #ch_apvl,rec_apvl;apvl.;
					search #ch_apvl,4,1;keyglm$,rec_apvl,e
					if e<>0
						returnstatus=2
						Message$="Error Adding Validation Key for G/L Account "+str$(glacctid)
						goto endsubglacctdata:
					endif          
				Endif ! file found
			endif! update validation file -- mtg
		endif
	endif
	endsubglacctdata: ! 		
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)

!!! End Submit Gl Acct Data	

case "GETGLDETL" ! get acct info and balances
	call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(client)+" Not On File"
	endif
	if returnstatus>0
		call openglmfile()
	endif
	if returnstatus>0
		call dxget ("glacctid",tmp$)
		let glacctid=tmp$
		let keyglm$=" ",keyglm$
		let keyglm$[2,9]=glacctid using "########"
		search #ch_glm,2,1;keyglm$,glmrec,e
		if e
			let returnstatus=0
			let Message$="G/L Account "+str$(glacctid)+" Not On File"
		endif
	endif
	if returnstatus>0
		read record #ch_glm,glmrec;glm.;
		call dxget ("acctper",tmp$)
		let acper=0
		if len(tmp$)=5
			let glmo=tmp$[1,2]
			let glyr=tmp$[4,5]
			let work$=glyr using "&&"
			let work$[3]=glmo using "&&"
			let acper=work$
		endif
		call FindAcctPeriod()
		if not(glcurrper)
			let returnstatus=0
			let work$=acper using "&&&&"
			let message$="Accounting Period ",work$[3,4],"/",work$[1,2]," Not Found"
		endif
	endif
	if returnstatus>0
		call opengltfile()
	endif
		
		
	
	! section 1 - send over info
	clear list$[]
	List$[0]=bsdel$,"GLDETL",fdel$
	Webstr$="JS",fdel$
	Webstr$=Webstr$,"REF #",fdel$
	Webstr$=Webstr$,"DATE",fdel$
	Webstr$=Webstr$,"BATCH",fdel$
	Webstr$=Webstr$,"DESCRIPTION",fdel$
	Webstr$=Webstr$,"AMOUNT",fdel$
	Webstr$=Webstr$,"REFREC",fdel$
	list$[1]=webstr$
	if returnstatus>0
		let keyglt$=" ",keyglt$
		let keyglt$[1,12]=glm.glacct$[1,12]
		let keyglt$[13,16]=acper using "&&&&"
		let dirno=1
		mode$=">"
		let row=2
		let tmpcnt=maxcnt ! 2000
		Do
			gltRec = FileGetGlGlt(e$,Ch_glt,mode$,dirno,keyglt$,glt.)
			if gltrec<0 exit do
			if keyglt$[1,12]<>glm.glacct$[1,12] exit do
			let tmp3=keyglt$[13,16]\if tmp3<>acper exit do
			let webstr$=glt.JrnlSrc$,fdel$
			let webstr$=webstr$,glt.RefNum$,fdel$
			work$=glt.postdate$[5,6] ! year
			work$[3]=glt.postdate$[1,2] ! month
			work$[5]=glt.postdate$[3,4] ! day
			let tmp3=work$ ! yymmdd format
			let xdate$=pdate$(tmp3)
			let webstr$=webstr$,xdate$,fdel$
			let webstr$=webstr$,glt.BatchNum$,fdel$
			let webstr$=webstr$,glt.Desc$,fdel$
			let webstr$=webstr$,(glt.amt using "--,---,---,---.##"),fdel$ 
			let webstr$=webstr$,(gltrec using "##########"),fdel$
			let list$[row]=webstr$
			let row=row+1
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
		Loop
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
			
	! section 2 - status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)

 ! end ---- getgldetl --------

case "GETGLARDETL" ! 
	call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(client)+" Not On File"
	endif
	if returnstatus>0
		call openglmfile()
	endif
	if returnstatus>0
		call dxget ("glacctid",tmp$)
		let glacctid=tmp$
		let keyglm$=" ",keyglm$
		let keyglm$[2,9]=glacctid using "########"
		search #ch_glm,2,1;keyglm$,glmrec,e
		if e
			let returnstatus=0
			let Message$="G/L Account "+str$(glacctid)+" Not On File"
		endif
	endif
	if returnstatus>0
		read record #ch_glm,glmrec;glm.;
		call dxget ("acctper",tmp$)
		let acper=0
		if len(tmp$)=5
			let glmo=tmp$[1,2]
			let glyr=tmp$[4,5]
			let work$=glyr using "&&"
			let work$[3]=glmo using "&&"
			let acper=work$
		endif
		call FindAcctPeriod()
		if not(glcurrper)
			let returnstatus=0
			let work$=acper using "&&&&"
			let message$="Accounting Period ",work$[3,4],"/",work$[1,2]," Not Found"
		endif
	endif
	if returnstatus>0
		call opengltfile()
	
	endif
	if returnstatus>0
		call dxget ("refrec",tmp$)
		let gltrec=tmp$
		if not (gltrec)
			let returnstatus=0
			let message$="Invalid Record Reference Number"
		endif
	endif
	if returnstatus>0
		read record #ch_glt,gltrec;glt.;
		if glt.jrnlsrc$<>" S" and glt.jrnlsrc$<>" E" and glt.jrnlsrc$<>" C"
			let returnstatus=0
			let message$="Invalid Journal Source Code"
		endif
	endif
	If returnstatus>0
		if not(glt.SrcCoid) and (glt.SrcCoid<>intco) let glt.SrcCoid=intco
		Ch_glar = OpenFile(-9701,glt.SrcCoid) 
		if ch_glar<0
			let returnstatus=0
			let message$="G/L A/R Detail File Is Not Available"
		endif
	endif
	! section 1 - send over info
	clear list$[]
	List$[0]=bsdel$,"GLARDETL",fdel$
	Webstr$="Trans ID",fdel$
	Webstr$=Webstr$,"Date",fdel$
	Webstr$=Webstr$,"CustId",fdel$
	Webstr$=Webstr$,"CustName",fdel$
	Webstr$=Webstr$,"Amount",fdel$
        Webstr$=Webstr$,"Type",fdel$
	Webstr$=Webstr$,"JSCode",fdel$
	list$[1]=webstr$
	if returnstatus>0
		let keyglar$=" ",keyglar$
		let keyglar$[1,4]=glt.postper$[1,4]
	        LET KEYGLAR$[5,16]=glt.glacct$[1,12]
		LET KEYGLAR$[17,22]=glt.srctran USING "######" 
		LET KEYCHK$=KEYGLAR$[1,22]                 
		let dirno=1
		mode$=">"
		let row=2
		let tmpcnt=maxcnt ! 2000
		Do
			glarRec = FileGetGlardetl(e$,Ch_glar,mode$,dirno,keyglar$,glar.)
			if glarrec<0 exit do
			if keyglar$[1,22]<>keychk$[1,22] exit do
			if glar.client=clientid and glt.jrnlsrc$=glar.JrnlSrc$
				Webstr$=(glar.TranNum using "##########"),fdel$
				let xdate$=pdate$(glar.TranDate)
				let webstr$=webstr$,xdate$,fdel$
				Webstr$=Webstr$,(glar.CustId using "######"),fdel$
				Webstr$=Webstr$,rtrim$(glar.custname$),fdel$
				let webstr$=webstr$,(glar.amt using "--,---,---,---.##"),fdel$
				let tmp$=(glar.histtype using "###")
				if glar.JrnlSrc$=" E"
					if glar.histtype>0 and glar.histtype<10
						tmp$=artype$[glar.histTYPE*3-2,glar.histTYPE*3]
					endif
				endif
				let webstr$=webstr$,tmp$,fdel$
				Webstr$=Webstr$,rtrim$(glar.JrnlSrc$),fdel$
	               		let list$[row]=webstr$
				let row=row+1
				If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
			endif
		Loop
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
			
	! section 2 - status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)

 ! end ---- getglardetl --------	
! STARTGETGLARJEDETAL -- This is coming from an invoice/credit memo inquiry
case "GETGLARJEDETL" ! 
	dim 1%,reftype
	dim 2%,custid,acper
	dim 3%,refnum,journal
	dim gldkey2$[50],KEYCUST$[50],reftype$[10]
	returnstatus=1
	Message$="OK"
	Ch_glar = OpenFile(-9701,intco) 
	if ch_glar<0
		let returnstatus=0
		let message$="G/L A/R Detail File Is Not Available"
		goto endgetglarjedetl:
	endif
	call dxget ("CUSTID",tmp$)
	let custid=tmp$
	if custid<=0 or custid>999999
		let returnstatus=0
		let message$="Invalid Customer Code "+str$(custid)
		goto endgetglarjedetl:
	endif
	call dxget("INVNO",tmp$)
	let refnum=tmp$
	if refnum<=0 or refnum>9999999999
		let returnstatus=0
		let message$="Invalid Reference Number "+str$(refnum)
		goto endgetglarjedetl:
	endif
	let reftype=0
	call dxget ("STATUS",tmp$) ! CHECK IF CREDIT MEMO OR DEBIT MEMO
	If rtrim$(ucase$(tmp$))="INV"	let reftype=30
	If rtrim$(ucase$(tmp$))="C/M" let reftype=31
	call dxget ("ACCTPER",tmp$)
	let acper=0
	if len(tmp$)=5
		let glmo=tmp$[1,2]
		let glyr=tmp$[4,5]
		let work$=glyr using "&&"
		let work$[3]=glmo using "&&"
		let acper=work$
	endif
	let journal=0
	call dxget ("JOURNAL",tmp$)
	let journal=tmp$
	LET GLDKEY2$=" ",GLDKEY2$
	Let GLDKEY2$[1,6]=CUSTID USING "######"
	LET GLDKEY2$[7,16]=REFNUM USING "##########"                 
	IF REFTYPE LET GLDKEY2$[17,18]=REFTYPE USING "##"            
	FIRSTSRCH: REM!!                                             
	SEARCH #CH_GLAR,3,2;GLDKEY2$,GLA_REC,E
	if e<>0
		let returnstatus=0
		let message$="Journal Entries for Customer "+str$(custid)+" Ref Number "+str$(refnum)+" Not Found"
		goto endgetglarjedetl:
	endif          
	LET tmp3=GLDKEY2$[1,6] 
	IF tmp3<>CUSTID
		let returnstatus=0
		let message$="Journal Entries for Customer "+str$(custid)+" Ref Number "+str$(refnum)+" Not Found"
		goto endgetglarjedetl:
	endif          
	LET tmp3=GLDKEY2$[7,16]
	IF TMP3<>REFNUM
		let returnstatus=0
		let message$="Journal Entries for Customer "+str$(custid)+" Ref Number "+str$(refnum)+" Not Found"
		goto endgetglarjedetl:
	endif 
	IF REFTYPE<>0                                              
		LET TMP3=GLDKEY2$[17,18] 
		if tmp3<>reftype
			let returnstatus=0
			let message$="Journal Entries for Customer "+str$(custid)+" Ref Number "+str$(refnum)+" Not Found"
			goto endgetglarjedetl:
		endif  
	ENDIF
	IF ACPER                                                
		LET TMP3=GLDKEY2$[31,34] \ IF TMP3<>ACPER GOTO FIRSTSRCH:   
	ENDIF
	
	IF Journal                                                 
		LET tmp3=GLDKEY2$[35,40] \ IF tmp3<>Journal GOTO FIRSTSRCH:    
	ENDIF                                                   
	read record #ch_glar,gla_rec,0;glar.; ! stop here on the lookup - mtg
	let keycust$=" ",keycust$
	Ch_Cust = OpenFile(1808,intco) \ If Ch_Cust = -1 Error 42 ! customer 
	clear cust.
	LET KEYCUST$=" ",KEYCUST$;KEYCUST$[1,6]=CUSTID USING "######"     
	SEARCH #CH_CUST,2,1;KEYCUST$,REC_CUST,E 
	if not (e)
		read record #ch_cust,rec_cust,0;cust.;
	else
		let cust.name$=glar.CustName$ 
	ENDIF 
	endgetglarjedetl: ! end checking for available list
	! section 1 - send heading list
	clear list$[]
	List$[0]=bsdel$,"GLJEARDETL",fdel$
	Webstr$="CustId",fdel$
	Webstr$=Webstr$,"SOLDNAME",fdel$
	Webstr$=webstr$,"SOLDADDR1",fdel$
	Webstr$=webstr$,"SOLDADDR2",fdel$
	Webstr$=webstr$,"SOLDADDR3",fdel$
	Webstr$=webstr$,"REFNUM" ,fdel$
	Webstr$=Webstr$,"STATUS",fdel$
	list$[1]=webstr$
	If returnstatus>0
		webstr$=""
		webstr$=str$(custid),fdel$
		webstr$=webstr$,rtrim$(cust.name$),fdel$
		webstr$=webstr$,rtrim$(cust.addr1$),fdel$
		webstr$=webstr$,rtrim$(cust.addr2$),fdel$
		let tmp$=rtrim$(cust.city$)
		if tmp$<>"" let tmp$=tmp$+", "
		let tmp$=tmp$+rtrim$(cust.state$)
		if tmp$<>"" let tmp$=tmp$+" "
		let tmp$=tmp$+rtrim$(cust.zip4$)
		webstr$=webstr$,tmp$,fdel$
		Webstr$=webstr$,str$(refnum),fdel$
		let tmp$=""
		IF REFTYPE=30 let tmp$="INVOICE"             
    		IF REFTYPE=31 let tmp$="CREDIT MEMO"
		webstr$=webstr$,tmp$,fdel$
		list$[2]=webstr$
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 

	! section 2 
	! gl dist list
	Ch_GLM = OpenFile(-176,intco) \ If Ch_GLM = -1 Error 42 ! GLM
	clear list$[]
	List$[0]=bsdel$,"GLJEARLIST",fdel$
	Webstr$="G/L Account",fdel$
	Webstr$=Webstr$,"G/L Name",fdel$
	Webstr$=webstr$,"Amount",fdel$
	list$[1]=webstr$
	row=2
	tmpcnt=maxcnt
	if returnstatus>0
		LET GLDKEY2$=" ",GLDKEY2$
		GLDKEY2$[1,6]=CUSTID USING "######"
		LET GLDKEY2$[7,16]=REFNUM USING "##########"                 
		IF REFTYPE LET GLDKEY2$[17,18]=REFTYPE USING "##" 
		do
			SEARCH #CH_GLAR,3,2;GLDKEY2$,GLA_REC,E   
			IF E<>0 exit do                                      
			LET tmp3=GLDKEY2$[1,6] 
			IF tmp3<>CUSTID exit do
			LET tmp3=GLDKEY2$[7,16]
			IF tmp3<>REFNUM exit do
			IF REFTYPE<>0                                              
				LET TMP3=GLDKEY2$[17,18] 
				if tmp3<>reftype exit do
			endif  
			IF ACPER                                                
				LET TMP3=GLDKEY2$[31,34] \ IF TMP3<>ACPER goto nextarjeitem:  
			ENDIF
			IF Journal                                                 
				LET tmp3=GLDKEY2$[35,40] \ IF tmp3<>Journal goto nextarjeitem:   
			ENDIF                                                   
			read record #ch_glar,gla_rec,0;glar.; ! stop here on the lookup - mtg
			webstr$=glar.AcctNum$,fdel$
			clear glm.
			search #ch_glm,2,1;glar.acctnum$,glmrec,e
			if not(e)
				read record #ch_glm,glmrec,0;glm.;
			else
				let glm.Desc$="Acct Not Found"
			endif
			WebStr$ = WebStr$,RTrim$(glm.Desc$),fdel$  ! gl account nmae
			webstr$=webstr$,str$(glar.amt),fdel$
       			let list$[row]=webstr$
			let row=row+1
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
			nextarjeitem: ! get next item
		Loop
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
			
	! section 3 - status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)

 ! end ---- getglardetl --------	

! end getglarjedetail 

 ! ------ Start getglcrdetl
case "GETGLCRDETL" ! 
	call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(client)+" Not On File"
	endif
	if returnstatus>0
		call openglmfile()
	endif
	if returnstatus>0
		call dxget ("glacctid",tmp$)
		let glacctid=tmp$
		let keyglm$=" ",keyglm$
		let keyglm$[2,9]=glacctid using "########"
		search #ch_glm,2,1;keyglm$,glmrec,e
		if e
			let returnstatus=0
			let Message$="G/L Account "+str$(glacctid)+" Not On File"
		endif
	endif
	if returnstatus>0
		read record #ch_glm,glmrec;glm.;
		call dxget ("acctper",tmp$)
		let acper=0
		if len(tmp$)=5
			let glmo=tmp$[1,2]
			let glyr=tmp$[4,5]
			let work$=glyr using "&&"
			let work$[3]=glmo using "&&"
			let acper=work$
		endif
		call FindAcctPeriod()
		if not(glcurrper)
			let returnstatus=0
			let work$=acper using "&&&&"
			let message$="Accounting Period ",work$[3,4],"/",work$[1,2]," Not Found"
		endif
	endif
	if returnstatus>0
		call opengltfile()
	
	endif
	if returnstatus>0
		call dxget ("refrec",tmp$)
		let gltrec=tmp$
		if not (gltrec)
			let returnstatus=0
			let message$="Invalid Record Reference Number"
		endif
	endif
	if returnstatus>0
		read record #ch_glt,gltrec;glt.;
		if glt.jrnlsrc$<>" R" 
			let returnstatus=0
			let message$="Invalid Journal Source Code"
		endif
	endif
	If returnstatus>0
		if not(glt.SrcCoid) and (glt.SrcCoid<>intco) let glt.SrcCoid=intco
		Ch_glcr = OpenFile(-9704,glt.SrcCoid) 
		if ch_glcr<0
			let returnstatus=0
			let message$="G/L C/R Detail File Is Not Available"
		endif
	endif
	! section 1 - send over info
	clear list$[]
	List$[0]=bsdel$,"GLCRDETL",fdel$
	Webstr$="Entry#",fdel$
	Webstr$=Webstr$,"Date",fdel$
	Webstr$=Webstr$,"CustId",fdel$
	Webstr$=Webstr$,"CustName",fdel$
	Webstr$=Webstr$,"Amount",fdel$
	Webstr$=Webstr$,"RefNum",fdel$
        Webstr$=Webstr$,"RefType",fdel$
	Webstr$=Webstr$,"JSCode",fdel$
	list$[1]=webstr$
	if returnstatus>0
	    	let keyglcr$=" ",keyglcr$
		let keyglcr$[1,4]=glt.postper$[1,4]
	        LET KEYglcr$[5,16]=glt.glacct$[1,12]
		LET KEYglcr$[17,22]=glt.srctran USING "######" 
		LET KEYCHK$=KEYglcr$[1,22]                 
		let dirno=1
		mode$=">"
		let row=2
		let tmpcnt=maxcnt ! 2000
		Do
			glcrRec = FileGetglcrdetl(e$,Ch_glcr,mode$,dirno,keyglcr$,glcr.)
			if glcrrec<0 exit do
			if keyglcr$[1,22]<>keychk$[1,22] exit do		
			if glcr.client=clientid
				if glt.desc$[25,28]="/BNK"
					let crbnk=glt.desc$[29,31]
					if crbnk<>0
						if crbnk<>glcr.bankid goto getnxtcrdet:
					endif
				endif
				Webstr$=(glcr.EntNum using "##########"),fdel$
				let xdate$=pdate$(glcr.TranDate)
				let webstr$=webstr$,xdate$,fdel$
				Webstr$=Webstr$,(glcr.CustId using "######"),fdel$
				! customer name/description
				let tmp$=rtrim$(glcr.custname$)
				if glcr.trantype<-6 ! deposits
					let tmp$=rtrim$(glcr.custname$[1,25])
					let tmp$=tmp$+" "+rtrim$(glcr.desc$)
				endif	
				Webstr$=Webstr$,rtrim$(tmp$),fdel$
				let webstr$=webstr$,(glcr.amt using "--,---,---,---.##"),fdel$
				let webstr$=Webstr$,(glcr.trannum using "##########"),fdel$
				let tmp$=(glcr.trantype using "###")
				if glcr.trantype>0 and glcr.trantype<10
						tmp$=artype$[glcr.tranTYPE*3-2,glcr.tranTYPE*3]
				endif
				If glcr.trantype=-7
					let tmp$="DEP"
				endif
				if glcr.trantype=-8
					let tmp$="ADP" ! applied deposit
				endif
				if glcr.trantype=-9
					let tmp$="DDP" ! deleted deposit
				endif
				Webstr$=Webstr$,rtrim$(tmp$),fdel$
				if glcr.JrnlSrc$<>" R" let glcr.jrnlsrc$=" R"
				Webstr$=Webstr$,rtrim$(glcr.JrnlSrc$),fdel$
	               		let list$[row]=webstr$
				let row=row+1
				If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
			endif
			getnxtcrdet: ! 
		Loop
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
			
	! section 2 - status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)

 ! ---- end get glcrdetl
 ! ---- start glapdetl -----

case "GETGLAPDETL" ! 
	call getgldata()
	if returnstatus>0
		if glt.jrnlsrc$<>" A" 
			let returnstatus=0
			let message$="Invalid Journal Source Code"
		endif
	endif
	If returnstatus>0
		if not(glt.SrcCoid) and (glt.SrcCoid<>intco) let glt.SrcCoid=intco
		Ch_GLAP = OpenFile(-9702,glt.SrcCoid) 
		if ch_GLAP<0
			let returnstatus=0
			let message$="G/L A/P Detail File Is Not Available"
		endif
	endif
	! section 1 - send over info
	clear list$[]
	List$[0]=bsdel$,"GLAPDETL",fdel$
	Webstr$="Transaction",fdel$
	Webstr$=Webstr$,"Type",fdel$
	Webstr$=Webstr$,"Date",fdel$
	Webstr$=Webstr$,"VendId",fdel$
	Webstr$=Webstr$,"VendName",fdel$
	Webstr$=Webstr$,"Amount",fdel$
	Webstr$=Webstr$,"JSCode",fdel$
	list$[1]=webstr$
	if returnstatus>0
	    	let keyGLAP$=" ",keyGLAP$
		let keyGLAP$[1,4]=glt.postper$[1,4]
	        LET KEYGLAP$[5,16]=glt.glacct$[1,12]
		LET KEYGLAP$[17,22]=glt.srctran USING "######" 
		LET KEYCHK$=KEYGLAP$[1,22]                 
		let dirno=1
		mode$=">"
		let row=2
		let tmpcnt=maxcnt ! 2000
		Do
			GLAPRec = FileGetGLAPdetl(e$,Ch_GLAP,mode$,dirno,keyGLAP$,GLAP.)
			if GLAPrec<0 exit do
			if keyGLAP$[1,22]<>keychk$[1,22] exit do
			if GLAP.client=clientid
				Webstr$=rtrim$(GLAP.TranCode$),fdel$
				let tmp$=""
				if glap.type=1
					let tmp$="INV"
				else
					if glap.type=2
						let tmp$="C/M"
					else
						if glap.type=3
							let tmp$="M/C"
						endif
					endif
				endif
				let webstr$=webstr$,tmp$,fdel$
				let xdate$=pdate$(GLAP.TranDate)
				let webstr$=webstr$,xdate$,fdel$
				Webstr$=Webstr$,(GLAP.VendId using "######"),fdel$
				Webstr$=Webstr$,rtrim$(GLAP.Vendname$),fdel$
				let webstr$=webstr$,(GLAP.amt using "--,---,---,---.##"),fdel$
				let tmp$="A" ! journal source code
				Webstr$=Webstr$,rtrim$(tmp$),fdel$
	               		let list$[row]=webstr$
				let row=row+1
				If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
			endif
		Loop
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
			
	! section 2 - status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)

 ! ---- end glapdetl 
 ! startglcd
case "GETGLCDDETL" ! 
	call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(client)+" Not On File"
	endif
	if returnstatus>0
		call openglmfile()
	endif
	if returnstatus>0
		call dxget ("glacctid",tmp$)
		let glacctid=tmp$
		let keyglm$=" ",keyglm$
		let keyglm$[2,9]=glacctid using "########"
		search #ch_glm,2,1;keyglm$,glmrec,e
		if e
			let returnstatus=0
			let Message$="G/L Account "+str$(glacctid)+" Not On File"
		endif
	endif
	if returnstatus>0
		read record #ch_glm,glmrec;glm.;
		call dxget ("acctper",tmp$)
		let acper=0
		if len(tmp$)=5
			let glmo=tmp$[1,2]
			let glyr=tmp$[4,5]
			let work$=glyr using "&&"
			let work$[3]=glmo using "&&"
			let acper=work$
		endif
		call FindAcctPeriod()
		if not(glcurrper)
			let returnstatus=0
			let work$=acper using "&&&&"
			let message$="Accounting Period ",work$[3,4],"/",work$[1,2]," Not Found"
		endif
	endif
	if returnstatus>0
		call opengltfile()
	
	endif
	if returnstatus>0
		call dxget ("refrec",tmp$)
		let gltrec=tmp$
		if not (gltrec)
			let returnstatus=0
			let message$="Invalid Record Reference Number"
		endif
	endif
	if returnstatus>0
		read record #ch_glt,gltrec;glt.;
		if glt.jrnlsrc$<>" D" 
			let returnstatus=0
			let message$="Invalid Journal Source Code"
		endif
	endif
	If returnstatus>0
		if not(glt.SrcCoid) and (glt.SrcCoid<>intco) let glt.SrcCoid=intco
		Ch_glcd = OpenFile(-9703,glt.SrcCoid) 
		if ch_glcd<0
			let returnstatus=0
			let message$="G/L C/D Detail File Is Not Available"
		endif
	endif
	! section 1 - send over info
	clear list$[]
	List$[0]=bsdel$,"glcdDETL",fdel$
	
	Webstr$="CheckId",fdel$
	Webstr$=Webstr$,"BankId",fdel$
	Webstr$=Webstr$,"Date",fdel$
	Webstr$=Webstr$,"VendId",fdel$
	Webstr$=Webstr$,"VendName",fdel$
	Webstr$=Webstr$,"Amount",fdel$
	Webstr$=Webstr$,"JSCode",fdel$
	list$[1]=webstr$
	if returnstatus>0
	    	let keyglcd$=" ",keyglcd$
		let keyglcd$[1,4]=glt.postper$[1,4]
	        LET KEYglcd$[5,16]=glt.glacct$[1,12]
		LET KEYglcd$[17,22]=glt.srctran USING "######" 
		LET KEYCHK$=KEYglcd$[1,22]                 
		let dirno=1
		mode$=">"
		let row=2
		let tmpcnt=maxcnt ! 2000
		Do
			glcdRec = FileGetglcddetl(e$,Ch_glcd,mode$,dirno,keyglcd$,glcd.)
			if glcdrec<0 exit do
			if keyglcd$[1,22]<>keychk$[1,22] exit do
			if glcd.client=clientid
				Webstr$=(glcd.ChkNum using "##########"),fdel$
				Webstr$=Webstr$,(glcd.bank using "###"),fdel$
				let xdate$=pdate$(glcd.ChkDate)
				let webstr$=webstr$,xdate$,fdel$
				Webstr$=Webstr$,(glcd.PayVendId using "######"),fdel$
				Webstr$=Webstr$,rtrim$(glcd.Vendname$),fdel$
				let webstr$=webstr$,(glcd.amt using "--,---,---,---.##"),fdel$
				let tmp$="D" ! journal source code
				Webstr$=Webstr$,rtrim$(tmp$),fdel$
	               		let list$[row]=webstr$
				let row=row+1
				If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
			endif
		Loop
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
			
	! section 2 - status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)

 ! ---- end get glcddetl

! ---- start glmrdetl --- Misc Rts Detail

case "GETGLMRDETL" ! 
	dim 2%,adate,rcode,whse
	call getgldata()
	if returnstatus>0
		if glt.jrnlsrc$<>" M" 
			let returnstatus=0
			let message$="Invalid Journal Source Code"
		endif
	endif
	If returnstatus>0
		if not(glt.SrcCoid) and (glt.SrcCoid<>intco) let glt.SrcCoid=intco
		Ch_glmr = OpenFile(-9706,glt.SrcCoid) 
		if ch_glmr<0
			let returnstatus=0
			let message$="G/L Misc RTS Detail File Is Not Available"
		endif
	endif
	let adate=glt.refnum$
	let whse=glt.desc$[7,8]
	let rcode=glt.desc$[24,27]
	clear list$[]
	List$[0]=bsdel$,"GLMRTSHDR",fdel$
	Webstr$="Journal",fdel$
	Webstr$=Webstr$,"Warehouse",fdel$
	Webstr$=Webstr$,"Warehouse Name",fdel$
	Webstr$=Webstr$,"ReasonCode",fdel$
	Webstr$=Webstr$,"ReasonDesc",fdel$
	list$[1]=webstr$
	if returnstatus>0
	    	let keyglmr$=" ",keyglmr$
		let keyglmr$[1,4]=glt.postper$[1,4]
	        LET KEYglmr$[5,16]=glt.glacct$[1,12]
		LET KEYglmr$[17,22]=glt.srctran USING "######" 
		LET KEYCHK$=KEYglmr$[1,22]                 
		let dirno=1
		mode$=">"
		let row=2
		let tmpcnt=maxcnt ! 2000
		Do
			glmrRec = FileGetglmrdetl(e$,Ch_glmr,mode$,dirno,keyglmr$,glmr.)
			if glmrrec<0 exit do
			if keyglmr$[1,22]<>keychk$[1,22] exit do
			if glmr.AcptDate<>adate goto getnextmrts:
			if glmr.whse<>whse goto getnextmrts:
			if glmr.reasonid<>rcode goto getnextmrts:
			if glmr.client=clientid
				! load the info
				Webstr$=(glmr.JrnlNum using "######"),fdel$
				Webstr$=webstr$,(glmr.whse using "##"),fdel$
				let tmpch=-1
				let whsename$=getwhsename$(tmpch,glmr.whse,intco)
				Webstr$=webstr$,whsename$,fdel$ ! 
				Webstr$=webstr$,(glmr.reasonid using "##"),fdel$
				tmpch=-1
				let rtsrsnd$=getrtsrsnd$(tmpch,glmr.reasonid,intco)
				Webstr$=Webstr$,rtsrsnd$,fdel$ ! reason code name
				list$[2]=webstr$
				exit do
							
			endif
			getnextmrts: ! 
		Loop
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 

	! section 2 - send over info
	clear list$[]
	List$[0]=bsdel$,"GLMRDETL",fdel$
	Webstr$="Entry",fdel$
	Webstr$=Webstr$,"Product",fdel$
	Webstr$=Webstr$,"Description",fdel$
	Webstr$=Webstr$,"Amount",fdel$
	Webstr$=webstr$,"RefMRec",fdel$
	Webstr$=Webstr$,"JSCode",fdel$
	list$[1]=webstr$
	if returnstatus>0
	    	let keyglmr$=" ",keyglmr$
		let keyglmr$[1,4]=glt.postper$[1,4]
	        LET KEYglmr$[5,16]=glt.glacct$[1,12]
		LET KEYglmr$[17,22]=glt.srctran USING "######" 
		LET KEYCHK$=KEYglmr$[1,22]                 
		let dirno=1
		mode$=">"
		let row=2
		let tmpcnt=maxcnt ! 2000
		Do
			glmrRec = FileGetglmrdetl(e$,Ch_glmr,mode$,dirno,keyglmr$,glmr.)
			if glmrrec<0 exit do
			if keyglmr$[1,22]<>keychk$[1,22] exit do
			if glmr.AcptDate<>adate goto getnextmrts1:
			if glmr.whse<>whse goto getnextmrts1:
			if glmr.reasonid<>rcode goto getnextmrts1:
			if glmr.client=clientid
				Webstr$=(glmr.EntNum using "#######"),fdel$
				webstr$=webstr$,glmr.prodid$,fdel$
				let tmpch=-1
				let prodd$=getprodd$(tmpch,glmr.prodid$,intco)
				webstr$=webstr$,rtrim$(prodd$[1,30]),fdel$
				! product description
				let webstr$=webstr$,(glmr.amt using "--,---,---,---.##"),fdel$
				Webstr$=webstr$,str$(glmrrec),fdel$
				let tmp$="M" ! journal source code
				Webstr$=Webstr$,rtrim$(tmp$),fdel$
				list$[row]=webstr$
				let row=row+1
				If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
			endif
			getnextmrts1: ! 
		Loop
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
			
	! section 2 - status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)

! ---- end glmrdetl 

! ------ getmiscrtsentry ----
case "GETMISCRTSENTRY" ! 
	call getgldata()
	if returnstatus>0
		if glt.jrnlsrc$<>" M" 
			let returnstatus=0
			let message$="Invalid Journal Source Code"
		endif
	endif
	if returnstatus>0
		if not(glt.SrcCoid) and (glt.SrcCoid<>intco) let glt.SrcCoid=intco
		Ch_glmr = OpenFile(-9706,glt.SrcCoid) 
		if ch_glmr<0
			let returnstatus=0
			let message$="G/L Misc RTS Detail File Is Not Available"
		endif
	endif
	call dxget ("refMrec",tmp$)
	let glmrrec=tmp$
	if not (glmrrec)
		let returnstatus=0
		let message$="Invalid Misc RTS Record Reference Number"
	endif
	read record #ch_glmr,glmrrec;glmr.;
	clear list$[]

	List$[0]=bsdel$,"MiscRtsEnt",fdel$
	Webstr$="Journal",fdel$
	Webstr$=Webstr$,"Entry #",fdel$
	Webstr$=Webstr$,"Warehouse",fdel$
	Webstr$=Webstr$,"Warehouse Name",fdel$
	Webstr$=Webstr$,"Product ID",fdel$
	Webstr$=webstr$,"Product Desc1",fdel$
	Webstr$=webstr$,"Product Desc2",fdel$
	webstr$=webstr$,"Quantity",fdel$
	Webstr$=webstr$,"Cost",fdel$
	Webstr$=Webstr$,"ReasonCode",fdel$
	Webstr$=Webstr$,"ReasonDesc",fdel$
	Webstr$=Webstr$,"G/L Merch Amt",fdel$
	list$[1]=webstr$
	if returnstatus>0
		Webstr$=(glmr.JrnlNum using "######"),fdel$
		Webstr$=Webstr$,(glmr.EntNum using "#######"),fdel$
		Webstr$=webstr$,(glmr.whse using "##"),fdel$
		let tmpch=-1
		let whsename$=getwhsename$(tmpch,glmr.whse,intco)
		Webstr$=webstr$,whsename$,fdel$ ! 
		webstr$=webstr$,glmr.prodid$,fdel$
		let tmpch=-1
		let prodd$=getprodd$(tmpch,glmr.prodid$,intco)
		webstr$=webstr$,rtrim$(prodd$[1,30]),fdel$
		webstr$=webstr$,rtrim$(prodd$[31,60]),fdel$
		webstr$=webstr$,(glmr.qty using "--,---,---,---.##"),"/",rtrim$(glmr.qtyum$),fdel$! quantity
		If glmr.cost<>0
			webstr$=webstr$,(glmr.cost using "--,---,---,---.##"),"/",rtrim$(glmr.costum$),fdel$! cost
		else
			webstr$=webstr$,"No Change",fdel$
		endif
		Webstr$=webstr$,(glmr.reasonid using "##"),fdel$
		tmpch=-1
		let rtsrsnd$=getrtsrsnd$(tmpch,glmr.reasonid,intco)
		Webstr$=Webstr$,rtsrsnd$,fdel$ ! reason code name
		let webstr$=webstr$,(glmr.glmerchcost using "--,---,---,---.##"),fdel$
		list$[2]=webstr$
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! section 2 - send over info
	clear list$[]
	List$[0]=bsdel$,"MISCRTSGL",fdel$
	Webstr$="Account",fdel$
	Webstr$=Webstr$,"Account Name",fdel$
	Webstr$=Webstr$,"Amount",fdel$
	
	list$[1]=webstr$
	if returnstatus>0
		let keyglmr$=" ",keyglmr$
		let keyglmr$[1,8]=glmr.EntNum USING "########"
	        LET KEYglmr$[9,10]=glmr.ReasonId using "##" 
		LET KEYglmr$[11,14]=glmr.AcctPer using "&&&&"
		LET KEYCHK$=KEYglmr$[1,14]                 
		let dirno=2
		mode$=">"
		let row=2
		let tmpcnt=maxcnt ! 2000
		Do
			glmrRec = FileGetglmrdetl(e$,Ch_glmr,mode$,dirno,keyglmr$,glmr.)
			if glmrrec<0 exit do
			if keyglmr$[1,14]<>keychk$[1,14] exit do
			let webstr$=glmr.AcctNum$,fdel$
			tmpch = ch_glm                             
     			glname$ = getglname$(tmpch,glmr.acctnum$,intCo)  
			Webstr$=Webstr$,rtrim$(glname$),fdel$ ! gl account description
			let webstr$=webstr$,(glmr.amt using "--,---,---,---.##"),fdel$
			
			list$[row]=webstr$
			let row=row+1
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
		Loop
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
			
	! section 2 - status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)

! ---- end ----- getmiscentry

! start gljedetl
case "GETGLJEDETL" ! 
	call getgldata()
	if returnstatus>0
		let jsccode$=glt.jrnlsrc$
		let tmp3=glt.jrnlsrc$
		if tmp3<0 or tmp3>9 
			let returnstatus=0
			let message$="Invalid Journal Source Code"
		endif
		let acptdate=glt.acptdate
	endif
	
	! section 1 - send over info
	clear list$[]
	List$[0]=bsdel$,"GLJEDETL",fdel$
 	Webstr$="Ref #",fdel$
	Webstr$=Webstr$,"Date",fdel$
	Webstr$=Webstr$,"Account",fdel$
	Webstr$=Webstr$,"Account Name",fdel$
	Webstr$=Webstr$,"Description",fdel$
	Webstr$=Webstr$,"Amount",fdel$
	Webstr$=Webstr$,"JSCode",fdel$
	list$[1]=webstr$
	if returnstatus>0
	    	let keyGLt$=" ",keyGLt$
		let keyGLT$[1,4]=glt.postper$[1,4]                                     
    		LET KEYGLT$[5]=GLT.BATCHnUM$[1,4]                            
		LET KEYCHK$=keyGLT$[1,8]                                       
		let dirno=3
		mode$=">"
		let row=2
		let tmpcnt=maxcnt ! 2000
		Do
			gltrec = FileGetGlGlt(e$,ch_glt,mode$,dirno,keyglt$,glt.) 
			
			if GLTrec<0 exit do
			if keyGLT$[1,8]<>keychk$[1,8] exit do
			if not(acptdate) let acptdate=glt.acptdate
			if jsccode$=glt.jrnlsrc$ and acptdate=glt.acptdate
				Webstr$=rtrim$(glt.RefNum$),fdel$
				let tmp$=glt.postdate$[5,6],glt.postdate$[1,4]
				let tmp3=tmp$
				let xdate$=pdate$(tmp3) ! (GLt.PostDate)
				let webstr$=webstr$,xdate$,fdel$
				Webstr$=Webstr$,GLt.GLAcct$,fdel$
				tmpch = ch_glm                             
     				glname$ = getglname$(tmpch,glt.glacct$,intCo)  
				Webstr$=Webstr$,rtrim$(glname$),fdel$ ! gl account description
			        Webstr$=Webstr$,rtrim$(glt.Desc$),fdel$
				let webstr$=webstr$,(GLt.amt using "--,---,---,---.##"),fdel$
				Webstr$=Webstr$,rtrim$(glt.JrnlSrc$),fdel$
	               		let list$[row]=webstr$
				let row=row+1
				If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
			endif
		Loop
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! section 2 - status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)
 ! ---- end gljedetl


case "GETGLBATCH" 
	call getglbatch()
	! done with it
	Try CLOSE #ch_glbatch Else Rem
        call SetOutPut(e$,rstr$)

case "GETGLMEMO"
	source=612
	call getglbatch()
	! done with it
	Try CLOSE #ch_glbatch Else Rem
        call SetOutPut(e$,rstr$)


 case "DELGLBATCH"  ! DELETE GL BATCH
	call DELglbatch()
	! done with it
        call SetOutPut(e$,rstr$)
	
case "SUBGLBATCH" 
	call subglbatch()
	Try CLOSE #ch_glbatch Else Rem
	! done with it
        call SetOutPut(e$,rstr$)

case "GETSTDBATCH" 
	call getstdbatch()
	Try CLOSE #ch_glbatch Else Rem
	! done with it
        call SetOutPut(e$,rstr$)

 case "DELSTDBATCH"  ! DELETE GL BATCH
	call DELSTDbatch()
	! done with it
        call SetOutPut(e$,rstr$)
	
case "SUBSTDBATCH" 
	call SubStdbatch()
	Try CLOSE #ch_glbatch Else Rem
	! done with it
        call SetOutPut(e$,rstr$)



! 613 for bdget batches
case "GETBUDBATCH" 
	SOURCE=613 ! prognum for gl
	call getglbatch()
	! done with it
	Try CLOSE #ch_glbatch Else Rem
        call SetOutPut(e$,rstr$)
	
case "SUBBUDBATCH" 
	source=613 ! prognum for gl budget
	call subbudbatch()
	Try CLOSE #ch_glbatch Else Rem
	! done with it
        call SetOutPut(e$,rstr$)

case "GETBATCHLIST"  ! GL 615
	call GETBATCHLIST()
	! done with it
        call SetOutPut(e$,rstr$)

!! 605 g/l statements types

case "STATDROPLIST" !   statement type file droplist                   
        let returnstatus=1                                        
        let message$="OK"  
	Try                                
		ch_glst = OpenFile(-192,intco)   
	Else                               
		let returnstatus=0
		let message$="General Statement Type File Not Found"              
	End Try
	if returnstatus<>0
		call FileDropListglglstfle(e$,List$[],100,ch_glst) ! statement type file droplist
	else
		clear list$[]
		list$[0]=bsdel$,"droplistglglstfle",fdel$
		list$[1]="Id",fdel$,"StartingDescription",fdel$
		list$[2]=esdel$
	endif
        call AddToStr(e$,rstr$,List$[])                                                            
        Call CreateNetStatus(e$,returnstatus,message$,webstr$)    
        Call AddToStr(e$,rstr$,webstr$)                           
        call SetOutput(e$,rstr$)   

case "GETSTATTYPE"
	call getstattype()
	call SetOutPut(e$,rstr$)

case "SUBSTATTYPE"
	call substattype()
	call SetOutPut(e$,rstr$)

case "STATAUTOLOAD"
	call StatAutoLoad()
	call SetOutPut(e$,rstr$)

case "STATTYPELOAD" ! 605
	call StatTypeLoad()
	call SetOutPut(e$,rstr$)

case "SUBSTATGLLOAD" ! 605
	call SubStatGLLoad()
	call SetOutPut(e$,rstr$)

!!!! 606 G/l Department Maintenance !!!!
case "GETDEPTCLIENT" !   DROPLIST OF CLIENT/                      
        let returnstatus=1                                        
        let message$="OK"                                         
        call FileDropListglacfz(e$,List$[],100,ch_acf) ! Acf file 
        call AddToStr(e$,rstr$,List$[])                           
        read #ctlc,51,10;deptflag;                                
        if not(deptflag)                                          
                let returnstatus=0                                
                let message$="Department Option Is Not Available" 
        endif                                                     
        Call CreateNetStatus(e$,returnstatus,message$,webstr$)    
        Call AddToStr(e$,rstr$,webstr$)                           
        call SetOutput(e$,rstr$)   
	
 case "GETDEPTLIST" ! DROPLIST OF DEPARTMENTS                          
        let returnstatus=1                                             
        let message$="OK"                                              
        read #ctlc,51,10;deptflag;                                     
        if not(deptflag)                                               
                let returnstatus=0                                     
                let message$="Department Option Is Not Available"      
                goto endgetdeptlist:                                   
        endif                                                          
        Call dxget("clientid",tmp$)                                    
                                                                       
        clientid = tmp$                                                
        keyacf$ = " ",keyacf$                                          
        keyacf$[1,6] = clientid Using "######"                         
        mode$ = "="                                                    
        dirno = 1                                                      
        AcfRec = FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)     
        If AcfRec = 0 ! record found                                   
                returnstatus = 0                                       
                message$ = "Client " + Str$(clientid) + " Not On File" 
                goto endgetdeptlist:                                   
        End If                                                         
        read #ctlc,88,128;filename$;                                   
	        Call FindF(filename$,fileflag)                              
        if not(fileflag)                                            
                let returnstatus=0                                  
                let message$="G/L Department File Is Not Available" 
                goto endgetdeptlist:                                
        endif                                                       
        ch_dept= FindChannel()                                      
        Try                                                         
                open#ch_dept,filename$                              
        else                                                        
                let returnstatus=0                                  
                let message$="Error Opening the G/L Department File"
                goto endgetdeptlist:                                
        end try                                                     
                                                                    
                                                                    
        Endgetdeptlist: !                                           
        clear list$[]                                               
        list$[0]=bsdel$,"GLDEPTLIST",fdel$                          
        List$[1]="DeptId",fdel$,"Name",fdel$                        
        row=2                                                       
        tmpcnt=maxcnt                                               
        if returnstatus> 0 
                let keydept$[1,4]=clientid using "####"                     
                do                                                          
                        search #ch_dept,3,1;keydept$,rec_dept,e             
                        if e>0 exit do                                      
                        let tmp3=keydept$[1,4]\if tmp3>clientid exit do     
                        read record #ch_dept,rec_dept;dept.;                
                        let webstr$=(dept.dept using "##"),fdel$            
                        let webstr$=webstr$,rtrim$(dept.name$),fdel$        
                        list$[row]=webstr$                                  
                        let row=row+1                                       
                        If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
                loop                                                        
        endif                                                               
        list$[row]=esdel$                                                     
        call AddToStr(e$,rstr$,List$[])                                     
        Call CreateNetStatus(e$,returnstatus,message$,webstr$)              
        Call AddToStr(e$,rstr$,webstr$)                                    
        call SetOutput(e$,rstr$)                                                                                   

 case "SUBMITDEPT" ! Submit Department                        
        let returnstatus=1                                             
        let message$="OK"                                              
        read #ctlc,51,10;deptflag;                                     
        if not(deptflag)                                               
                let returnstatus=0                                     
                let message$="Department Option Is Not Available"      
                goto endsubdept:                                   
        endif                                                          
        Call dxget("clientid",tmp$)                                                                                                
        clientid = tmp$                                                
        keyacf$ = " ",keyacf$                                          
        keyacf$[1,6] = clientid Using "######"                         
        mode$ = "="                                                    
        dirno = 1                                                      
        AcfRec = FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)     
        If AcfRec = 0 ! record found                                   
                returnstatus = 0                                       
                message$ = "Client " + Str$(clientid) + " Not On File" 
                goto endsubdept:                                   
        End If                                                         
        read #ctlc,88,128;filename$;                                   
	    Call FindF(filename$,fileflag)                              
        if not(fileflag)                                            
                let returnstatus=0                                  
                let message$="G/L Department File Is Not Available" 
                goto endsubdept:                                
        endif                                                       
        ch_dept= FindChannel()                                      
        Try                                                         
                open#ch_dept,filename$                              
        else                                                        
                let returnstatus=0                                  
                let message$="Error Opening the G/L Department File"
                goto endsubdept:                                
        end try                                                     
        Call dxget("DEPTID",tmp$)                                                            
        let dept.dept=tmp$
	if dept.dept<=0 or dept.dept>99
		let returnstatus=0                                  
                let message$="Invalid Department Submitted"
                goto endsubdept:
	endif
	Call dxget("DELETEFLAG",tmp$)
	let keydept$[1,4]=clientid using "####"
	let keydept$[5,6]=dept.dept using "##"                                                       
        search #ch_dept,2,1;keydept$,rec_dept,e 
	IF not(e)
		read record #ch_dept,rec_Dept;dept.;
		Call dxget("DELETEFLAG",tmp$)
		if Ucase$(rtrim$(tmp$))="Y"
			search #ch_Dept,5,1;keydept$,rec_dept,e
			if e<>0                                                               
				returnstatus = 0                                                        
				message$ = "Error Deleting Key for Department " + Str$(dept.dept)       
				Goto endsubdept:
			endif                                                                   
			e = 3 \ Search #ch_dept,1,0;keydept$,rec_dept,e                              
			If e <> 0                                                                 
				returnstatus = 0                                                        
				message$ = "Search Error " + Str$(e) + " Deleting Record for Department "+str$(dept.dept)                                                            
			endif                                                   
			message$ = "Department " + Str$(dept.dept) + " Deleted "
			goto endsubdept:
		endif
	else
		if e=1 ! new record
			Call dxget("DELETEFLAG",tmp$)
			if Ucase$(rtrim$(tmp$))="Y"
				message$ = "Department " + Str$(dept.dept) + " Deleted "
				goto endsubdept:
			endif
			let tmp3=dept.dept
			clear dept.
			let dept.dept=tmp3
			let dept.client=clientid
			e = 2 \ Search #ch_dept,1,0;keydept$,rec_dept,e                              
			If e <> 0                                                                 
				returnstatus = 0                                                        
				message$ = "Search Error " + Str$(e) + " Adding Record for Department "+str$(dept.dept)                                                            
				Goto endsubdept:
			endif
			write record #ch_dept,rec_dept;dept.;
			search #ch_Dept,4,1;keydept$,rec_dept,e
			if e<>0                                                               
				returnstatus = 0                                                        
				message$ = "Error Adding Key for Department " + Str$(dept.dept)       
				Goto endsubdept:
			endif                                                                   
		else
			returnstatus = 0                                                        
			message$ = "Search Error " + Str$(e) + " In Searching for Department "+str$(dept.dept)
			goto endsubdept:
		endif
	endif
	Call dxget("NAME",tmp$)
	dept.name$=tmp$+blank$
	write record #ch_dept,rec_dept;dept.;
        Endsubdept: !                                           
                                  
        Call CreateNetStatus(e$,returnstatus,message$,webstr$)              
        Call AddToStr(e$,rstr$,webstr$)                                    
        call SetOutput(e$,rstr$)        
! 607 - profit center

case "GETPROFCTRCLIENT" !   DROPLIST OF CLIENT/                      
        let returnstatus=1                                        
        let message$="OK"                                         
        call FileDropListglacfz(e$,List$[],100,ch_acf) ! Acf file 
        call AddToStr(e$,rstr$,List$[])                           
        read #ctlc,51,12;pcflag;                                
        if not(pcflag)                                          
                let returnstatus=0                                
                let message$="Profit Center Option Is Not Available" 
        endif                                                     
        Call CreateNetStatus(e$,returnstatus,message$,webstr$)    
        Call AddToStr(e$,rstr$,webstr$)                           
        call SetOutput(e$,rstr$)   
	
 case "GETPROFCTRLIST" ! DROPLIST OF PROFITCENTERS                         
        let returnstatus=1                                             
        let message$="OK"                                              
        read #ctlc,51,12;pcflag;                                     
        if not(pcflag)                                               
                let returnstatus=0                                     
                let message$="Profit Center Option Is Not Available"      
                goto endgetpclist:                                   
        endif 
	read #ctlc,51,14;pcspos;
	read #ctlc,51,16;pcepos;
	plen=(pcepos-pcspos)+1\if plen<=0 let plen=1
	LET pcMASK$[1,PLEN]="#",pcMASK$[1,PLEN]
	TMP$="9",TMP$
	let maxpc=tmp$[1,plen]
        Call dxget("clientid",tmp$)                                    
                                                                       
        clientid = tmp$                                                
        keyacf$ = " ",keyacf$                                          
        keyacf$[1,6] = clientid Using "######"                         
        mode$ = "="                                                    
        dirno = 1                                                      
        AcfRec = FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)     
        If AcfRec = 0 ! record found                                   
                returnstatus = 0                                       
                message$ = "Client " + Str$(clientid) + " Not On File" 
                goto endgetpclist:                                   
        End If                                                         
        filename$="1/GLPCTR"+STR$(INTCO)                                  
	Call FindF(filename$,fileflag)                              
        if not(fileflag)                                            
                let returnstatus=0                                  
                let message$="G/L Profit Center File Is Not Available" 
                goto endgetpclist:                                
        endif                                                       
        ch_pc= FindChannel()                                      
        Try                                                         
                open#ch_pc,filename$                              
        else                                                        
                let returnstatus=0                                  
                let message$="Error Opening the G/L Profit Center File"
                goto endgetpclist:                                
        end try                                                     
                                                                    
                                                                    
        Endgetpclist: !                                           
        clear list$[]                                               
        list$[0]=bsdel$,"GLPCLIST",fdel$                          
        List$[1]="pcId",fdel$,"Name",fdel$                        
        row=2                                                       
        tmpcnt=maxcnt                                               
        if returnstatus> 0 
		let keypc$=" ",keypc$
                let keypc$[1,4]=clientid using "####"                     
                do                                                          
                        search #ch_pc,3,1;keypc$,rec_pc,e             
                        if e>0 exit do                                      
                        let tmp3=keypc$[1,4]\if tmp3<>clientid exit do     
                        read record #ch_pc,rec_pc;pc.;                
                        let webstr$=(pc.ProfCtr using PCMASK$),fdel$            
                        let webstr$=webstr$,rtrim$(pc.name$),fdel$        
                        list$[row]=webstr$                                  
                        let row=row+1                                       
                        If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
                loop                                                        
        endif                                                               
        list$[row]=esdel$                                                     
        call AddToStr(e$,rstr$,List$[])                                     
        Call CreateNetStatus(e$,returnstatus,message$,webstr$)              
        Call AddToStr(e$,rstr$,webstr$)                                    
        call SetOutput(e$,rstr$)                                                                                   

 case "SUBMITPROFCTR" ! Submit Profit Center                        
        let returnstatus=1                                             
        let message$="OK"                                              
        read #ctlc,51,12;pcflag;                                     
        if not(pcflag)                                               
                let returnstatus=0                                     
                let message$="Profit Center Option Is Not Available"      
                goto endsubpc:                                   
        endif 
	read #ctlc,51,14;pcspos;
	read #ctlc,51,16;pcepos;

	plen=(pcepos-pcspos)+1\if plen<=0 let plen=1
	LET pcMASK$[1,PLEN]="#",pcMASK$[1,PLEN]
	TMP$="9",TMP$
	let maxpc=tmp$[1,plen]
        Call dxget("clientid",tmp$)                                                                                                
        clientid = tmp$                                                
        keyacf$ = " ",keyacf$                                          
        keyacf$[1,6] = clientid Using "######"                         
        mode$ = "="                                                    
        dirno = 1                                                      
        AcfRec = FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)     
        If AcfRec = 0 ! record found                                   
                returnstatus = 0                                       
                message$ = "Client " + Str$(clientid) + " Not On File" 
                goto endsubpc:                                   
        End If                                                         
        filename$="1/GLPCTR"+STR$(INTCO)                                  
	Call FindF(filename$,fileflag)                              
        if not(fileflag)                                            
                let returnstatus=0                                  
                let message$="G/L Profit Center File Is Not Available" 
                goto endsubpc:                                
        endif                                                       
        ch_pc= FindChannel()                                      
        Try                                                         
                open#ch_pc,filename$                              
        else                                                        
                let returnstatus=0                                  
                let message$="Error Opening the G/L Profit Center File"
                goto endsubpc:                                
        end try                                                     
        Call dxget("pcID",tmp$)                                                            
        let pc.ProfCtr=tmp$
	if pc.ProfCtr<=0 or pc.ProfCtr>maxpc
		let returnstatus=0                                  
                let message$="Invalid Profit Center Submitted. Must be between 1 and "+str$(maxpc)
                goto endsubpc:
	endif
	Call dxget("DELETEFLAG",tmp$)
	let keypc$=" ",keypc$
	let keypc$[1,4]=clientid using "####"
	let keypc$[5,4+plen]=pc.ProfCtr using pcmask$
	
        search #ch_pc,2,1;keypc$,rec_pc,e 
	IF not(e)
		read record #ch_pc,rec_pc;pc.;
		Call dxget("DELETEFLAG",tmp$)
		if Ucase$(rtrim$(tmp$))="Y"
			search #ch_pc,5,1;keypc$,rec_pc,e
			if e<>0                                                               
				returnstatus = 0                                                        
				message$ = "Error Deleting Key for Profit Center " + Str$(pc.ProfCtr)       
				Goto endsubpc:
			endif                                                                   
			e = 3 \ Search #ch_pc,1,0;keypc$,rec_pc,e                              
			If e <> 0                                                                 
				returnstatus = 0                                                        
				message$ = "Search Error " + Str$(e) + " Deleting Record for Profit Center "+str$(pc.ProfCtr)                                                            
			endif                                                   
			message$ = "Profit Center " + Str$(pc.ProfCtr) + " Deleted "
			goto endsubpc:
		endif
	else
		if e=1 ! new record
			Call dxget("DELETEFLAG",tmp$)
			if Ucase$(rtrim$(tmp$))="Y"
				message$ = "Profit Center " + Str$(pc.ProfCtr) + " Deleted "
				goto endsubpc:
			endif
			let tmp3=pc.ProfCtr
			clear pc.
			let pc.ProfCtr=tmp3
			let pc.client=clientid
			e = 2 \ Search #ch_pc,1,0;keypc$,rec_pc,e                              
			If e <> 0                                                                 
				returnstatus = 0                                                        
				message$ = "Search Error " + Str$(e) + " Adding Record for Profit Center "+str$(pc.ProfCtr)                                                            
				Goto endsubpc:
			endif
			write record #ch_pc,rec_pc;pc.;
			search #ch_pc,4,1;keypc$,rec_pc,e
			if e<>0                                                               
				returnstatus = 0                                                        
				message$ = "Error Adding Key for Profit Center " + Str$(pc.ProfCtr)       
				Goto endsubpc:
			endif                                                                   
		else
			returnstatus = 0                                                        
			message$ = "Search Error " + Str$(e) + " In Searching for Profit Center "+str$(pc.ProfCtr)
			goto endsubpc:
		endif
	endif
	Call dxget("NAME",tmp$)
	pc.name$=tmp$+blank$
	write record #ch_pc,rec_pc;pc.;
        Endsubpc: !                                           
                                  
        Call CreateNetStatus(e$,returnstatus,message$,webstr$)              
        Call AddToStr(e$,rstr$,webstr$)                                    
        call SetOutput(e$,rstr$)        



! end - 607 profit center

! 610 - g/l budget file maintenance
case "GETBUDCLIENT" !   DROPLIST OF CLIENT
	returnstatus=1
	message$="OK"
	!call FileDropListglacfz(e$,List$[],100,ch_acf) ! Acf file
	!call AddToStr(e$,rstr$,List$[])
	clear list$[]
	List$[0]=bsdel$,"Budget Client List",fdel$
	Webstr$="Id",fdel$
	Webstr$=webstr$,"ClientName",fdel$
	webstr$=webstr$,"FYE1",fdel$
	webstr$=webstr$,"FYE2",FDEL$
	webstr$=webstr$,"FYE3",fdel$
	List$[1]=webstr$
	read #ctlc,51,8;budflag;
	If not(budflag) 
		let returnstatus=0
		let message$="Budgets Are Not Available"
		endgetbudcleint:
	endif
	let keyacf$=" ",keyacf$
	row=2
	let tmpcnt=maxcnt
	totrec=0
	do
		search #ch_acf,3,1;keyacf$,rec_acf,e
		if e<>0 exit do
		if keyacf$[7,8]="  "
			let webstr$=keyacf$[3,6],fdel$
			read record #ch_acf,rec_acf;acf.;
			let webstr$=webstr$,acf.clientname$,fdel$
			let clientid=keyacf$[3,6]
			tmp = acf.DirNum$                                                                          
			filename$ = Str$(tmp) + "/GLB" + Str$(intco) + groupid$                                        
			tmp$ = clientid Using "####"                          
			For ctr = 1 To 4                                      
				if tmp$[ctr,ctr] = " " Let tmp$[ctr,ctr] = "."      
			Next ctr                                              
			filename$ = filename$ + tmp$                          
			Call FindF(filename$,fileflag)                        
			If Not(fileflag)
				goto getnextbudclient:
			endif
			ch_glm=findchannel()
			Try
				ropen #ch_glm,filename$
			else
				goto getnextbudclient:
			end try
			let keyglm$=" ",keyglm$
			search #ch_glm,2,1;keyglm$,rec_glm,e
			if e<>0 goto getnextbudclient:
			read record #ch_glm,rec_glm;glm.;
			tmp$ = glm.currperbal[13] Using "&&&&"
			webstr$=webstr$,tmp$[1,2],fdel$! fye 1
			tmp$ = glm.currperbal[26] Using "&&&&"
			webstr$=webstr$,tmp$[1,2],fdel$! fye 2
			tmp$ = glm.currperbal[39] Using "&&&&"
			webstr$=webstr$,tmp$[1,2],fdel$! fye 3
			list$[row]=webstr$
			let row=row+1
			totrec=totrec+1
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
			getnextbudclient: ! 
		endif
	loop
	if not(totrec)
		let returnstatus=0
		let message$="No Budget Files Exist"
	endif
	list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])

	Call CreateNetStatus(e$,returnstatus,message$,webstr$) 
        Call AddToStr(e$,rstr$,webstr$)                        
        call SetOutput(e$,rstr$)

case "BUDDROPLIST" ! -- budget gl account droplist
	call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(clientid)+" Not On File"
		goto endbuddroplist:
	endif
	call openglbfile()
	endbuddroplist: ! end getting budget droplist
	! section 3 -- send over droplist
	Clear list$[]
	List$[0]=bsdel$,"GLBudDroplist",fdel$
	Webstr$="Id",fdel$
	Webstr$=webstr$,"Description",fdel$
	Webstr$=webstr$,"AcctType",fdel$
	Webstr$=webstr$,"StatType",fdel$
	Webstr$=webstr$,"Dept",fdel$
	List$[1]=webstr$
	if returnstatus>0 ! no errors
		let row=2
		let tmpcnt=maxcnt ! 2000
		let keyglm$=" ",keyglm$
		do
			search #ch_glm,3,1;keyglm$,glmrec,e
			if e>0 exit do
			read record #ch_glm,glmrec;glm.;
			let webstr$=keyglm$,fdel$
			let webstr$=webstr$,rtrim$(glm.Desc$),fdel$
			call getglaccttype()
			let webstr$=webstr$,rtrim$(glaccttype$),fdel$
			let webstr$=webstr$,rtrim$(glm.stattype$),fdel$
			let tmp$=" "
			!! check the dept flag from the control record
			if deptflag
				let tmp$=keyglm$[8,9]
			endif
			let webstr$=webstr$,rtrim$(tmp$),fdel$
			let list$[row]=webstr$
			let row=row+1
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
		loop ! for the do
	endif ! for returnstatus
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section		
	! section 5 - status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)

case "BUDAUTOPCTLOAD" ! -- 610 - option 1 & 2 update base on last yr bud or gl data - display acct-n
	call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(clientid)+" Not On File"
		goto endbudautopct:
	endif
	call openglbfile()
	if returnstatus=0 goto endbudautopct:
	let ch_glb=ch_glm
	call dxget ("FYE",tmp$)
	let tmp3=tmp$
	let work$=" ",work$
	let work$[1,2]=tmp3 using "&&"
	let work$[3,4]=tmp3 using "&&"
	let curryear=work$
	let tmp3=tmp3-1\if tmp3<0 let tmp3=99
	let work$[1,2]=tmp3 using "&&"
	let work$[3,4]=tmp3 using "&&"
	let lastyear=work$
	let keyglb$=" ",keyglb$
	search #ch_glb,2,1;keyglb$,rec_glb,e
	if e<>0
		let returnstatus=0
		Message$="Budget Control Record Not On File for Client "+str$(clientid) 
		goto endbudautopct:
	endif
	read record #ch_glb,rec_glb;glm.;
	if glm.CurrPerBal[13]=curryear
		let scurrper=1
		let ecurrper=12
	else
		if glm.CurrPerBal[26]=curryear
			let scurrper=14
			let ecurrper=25
		else
			if glm.CurrPerBal[39]=curryear
				let scurrper=27
				let ecurrper=38
			else
				let returnstatus=0
				work$=curryear using "&&&&"
				Message$="Fiscal Year "+work$[1,2]+" Not On File for Client "+str$(clientid) 
				goto endbudautopct:	
			endif
		endif
	endif
	call dxget ("UPDATETYPE",tmp$) ! A=last year actual, B=last year budget
	let updatetype$=ucase$(rtrim$(tmp$))
	if updatetype$<>"A" and updatetype$<>"B" 
		let returnstatus=0
		Message$="Invalid Update Type Submitted"
		goto endbudautopct:
	endif
	if updatetype$="B" ! using budget file
		read record #ch_glb,rec_glb;oglm.;
	else
		! gl actual balance
		call openglmfile()
		if returnstatus=0 goto endbudautopct:
		let keyglm$=" ",keyglm$
		search #ch_glm,2,1;keyglm$,rec_glm,e
		if e<>0
			let returnstatus=0
			Message$="G/L Master Control Record Not On File for Client "+str$(clientid) 
			goto endbudautopct:
		endif
		read record #ch_glm,rec_glm;oglm.;
	endif
	! find last year data
	if oglm.CurrPerBal[13]=lastyear
		let slastper=1
		let elastper=12
	else
		if oglm.CurrPerBal[26]=lastyear
			let slastper=14
			let elastper=25
		else
			if oglm.CurrPerBal[39]=lastyear
				let slastper=27
				let elastper=38
			else
				let returnstatus=0
				work$=lastyear using "&&&&"
				Message$="Fiscal Year "+work$[1,2]+" Not On File for Client "+str$(clientid) 
				goto endbudautopct:	
			endif
		endif
	endif
	call dxget ("OVERWRITE",tmp$) ! OverWrite Existing
	let overwrite=0
	if ucase$(rtrim$(tmp$))="Y" let overwrite=99
	call dxget ("SGLACCTID",tmp$)
	let sglacctid=tmp$
	call dxget ("EGLACCTID",tmp$)
	let eglacctid=tmp$
	if eglaccrid>sglacctid
		let returnstatus=0
		Message$="Ending G/L Account Must Be Greater Than Starting" 
		goto endbudautopct:
	endif
	call dxget ("PERCENT",tmp$)
	let pct=tmp$
	if sglacctid>0 let sglacctid=sglacctid-1
	let keyglb$=" ",keyglb$
	let keyglb$[2,9]=sglacctid using "########"
	do
		search #ch_glb,3,1;keyglb$,rec_GLB,e
		if e>0 exit do
		if keyglb$[1,1]<>" " exit do
		let tmp3=keyglb$[2,9]
		if tmp3>eglacctid exit do
		read record #ch_glb,rec_glb;glm.;
		if not(overwrite)
			for ctr=scurrper to ecurrper
				if glm.CurrPerBal[ctr]<>0 goto getnxtbudacct:
			next ctr
		endif
		read record #ch_glb,rec_glb;oglm.;
		if updatetype$="A"
			let keyglm$=keyglb$ 
			search #ch_glm,2,1;keyglm$,rec_glm,e
			if e<>0 goto getnxtbudacct: ! glm account not found
			read record #ch_glm,rec_glm;oglm.;
		endif
		! calcualte the
		workper=slastper
		for ctr=scurrper to ecurrper
			let glm.CurrPerBal[ctr]=fnr(oglm.currperbal[workper]+(oglm.currperbal[workper]*(pct/100)))
			let workper=workper+1
		next ctr
		write record #ch_glb,rec_glb;glm.;
		getnxtbudacct: ! 
	loop ! for the do
	endbudautopct: ! end getting budget droplist
	! section 5 - status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)



case "BUDPCTLOAD" ! -- 610 - option 1 & 2 update base on last yr bud or gl data - display acct= Y
	dim cglm. as glglm ! control file for gl master for last year
	dim bglm. as glglm ! Control file for budget for current year
	call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(clientid)+" Not On File"
		goto endbudpct:
	endif
	call openglbfile()
	if returnstatus=0 goto endbudpct:
	let ch_glb=ch_glm
	call dxget ("FYE",tmp$)
	let tmp3=tmp$
	let work$=" ",work$
	let work$[1,2]=tmp3 using "&&"
	let work$[3,4]=tmp3 using "&&"
	let curryear=work$
	let tmp3=tmp3-1\if tmp3<0 let tmp3=99
	let work$[1,2]=tmp3 using "&&"
	let work$[3,4]=tmp3 using "&&"
	let lastyear=work$
	let keyglb$=" ",keyglb$
	search #ch_glb,2,1;keyglb$,rec_glb,e
	if e<>0
		let returnstatus=0
		Message$="Budget Control Record Not On File for Client "+str$(clientid) 
		goto endbudpct:
	endif
	read record #ch_glb,rec_glb;glm.;
	read record #ch_glb,rec_glb;bglm.;
	if glm.CurrPerBal[13]=curryear
		let scurrper=1
		let ecurrper=12
	else
		if glm.CurrPerBal[26]=curryear
			let scurrper=14
			let ecurrper=25
		else
			if glm.CurrPerBal[39]=curryear
				let scurrper=27
				let ecurrper=38
			else
				let returnstatus=0
				work$=curryear using "&&&&"
				Message$="Fiscal Year "+work$[1,2]+" Not On File for Client "+str$(clientid) 
				goto endbudpct:	
			endif
		endif
	endif
	call dxget ("UPDATETYPE",tmp$) ! A=last year actual, B=last year budget
	let updatetype$=ucase$(rtrim$(tmp$))
	if updatetype$<>"A" and updatetype$<>"B" 
		let returnstatus=0
		Message$="Invalid Update Type Submitted"
		goto endbudpct:
	endif
	if updatetype$="B" ! using budget file
		read record #ch_glb,rec_glb;oglm.;
		read record #ch_glb,rec_glb;cglm.;
	else
		! gl actual balance
		call openglmfile()
		if returnstatus=0 goto endbudpct:
		let keyglm$=" ",keyglm$
		search #ch_glm,2,1;keyglm$,rec_glm,e
		if e<>0
			let returnstatus=0
			Message$="G/L Master Control Record Not On File for Client "+str$(clientid) 
			goto endbudpct:
		endif
		read record #ch_glm,rec_glm;oglm.;
		read record #ch_glm,rec_glm;cglm.;
		
	endif
	! find last year data
	if oglm.CurrPerBal[13]=lastyear
		let slastper=1
		let elastper=12
	else
		if oglm.CurrPerBal[26]=lastyear
			let slastper=14
			let elastper=25
		else
			if oglm.CurrPerBal[39]=lastyear
				let slastper=27
				let elastper=38
			else
				let returnstatus=0
				work$=lastyear using "&&&&"
				Message$="Fiscal Year "+work$[1,2]+" Not On File for Client "+str$(clientid) 
				goto endbudpct:	
			endif
		endif
	endif
	call dxget ("GLACCTID",tmp$)
	let glacctid=tmp$
	If glacctid<=0 or glacctid>99999999
		let returnstatus=0
		Message$="Invalid G/L Account Submitted" 
		goto endbudpct:
	endif
	call dxget ("PERCENT",tmp$)
	let pct=tmp$
	call dxget ("SEARCHTYPE",tmp$)
	let work$=ucase$(rtrim$(tmp$))
	let mode=2 ! exact
	let keyglb$=" ",keyglb$
	let keyglb$[2,9]=glacctid using "########"
	if work$="PREV"
		LET  MODE=6
	endif
	if work$="NEXT"
		LET MODE=3
	endif
	search #ch_glb,mode,1;keyglb$,rec_GLB,e
	if e>0
		returnstatus=0
		if mode=2
			let message$="G/L Account "+str$(glacctid)+" Not of File "
			goto endbudpct:
		endif
		let message$="End of File "
		goto endbudpct:
	endif
	read record #ch_glb,rec_glb;glm.;
	read record #ch_glb,rec_glb;oglm.;
	if updatetype$="A"
		let keyglm$=keyglb$ 
		search #ch_glm,2,1;keyglm$,rec_glm,e
		if e<>0 goto getnxtbudacct: ! glm account not found
		read record #ch_glm,rec_glm;oglm.;
	endif
	endbudpct: ! end getting budget
	! section 1 - send over info
	clear list$[]
	List$[0]=bsdel$,"GLACCTHDR",fdel$
	Webstr$="ClientID",fdel$,"ClientName",fdel$
	Webstr$=Webstr$,"GLAcctID",fdel$
	Webstr$=Webstr$+"RecType",fdel$ ! 
	Webstr$=Webstr$+"AcctType",fdel$ !
	Webstr$=Webstr$+"Desc",fdel$ !
	Webstr$=Webstr$+"StatType",fdel$ !
	list$[1]=webstr$
	ROW=2
	if returnstatus>0
		webstr$=str$(clientid),fdel$
		webstr$=webstr$,rtrim$(acf.ClientName$),fdel$
		webstr$=webstr$,rtrim$(glm.glacct$),fdel$
		 Call GetGlRecType()
		webstr$=webstr$,glm.rectype$," ",glrectype$,fdel$
		Call GetGlAcctType() 
		webstr$=webstr$,glm.accttype$," ",glaccttype$,fdel$
		webstr$=webstr$,rtrim$(glm.desc$),fdel$
		Webstr$=webstr$,rtrim$(glm.stattype$),fdel$
		list$[ROW]=webstr$
		row=row+1
	endif
	LIST$[ROW]=ESDEL$
	call AddToStr(e$,rstr$,List$[])
	!Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! SECTION FOR LAST YEAR
	CLEAR LIST$[]
	LIST$[0]=bsdel$,"LAST YEAR",fdel$
	List$[1]="ID",fdel$,"ACCTPER",FDEL$,"AMOUNT",FDEL$
	LET ROW=1
	totamt=0
	IF RETURNSTATUS<>0
		FOR CTR=SLASTPER TO ELASTPER
			WEBSTR$=(ROW USING "##"),FDEL$
			let work$=CGLM.CURRPERBAL[CTR] USING "&&&&"
			WEBSTR$=wEBSTR$+WORK$[3,4]+"/"+WORK$[1,2],FDEL$
			WEBSTR$=WEBSTR$+(OGLM.CURRPERBAL[CTR] USING "--------------.##"),FDEL$
			LIST$[ROW+1]=WEBSTR$
			LET ROW=ROW+1
			totamt=totamt+OGLM.CURRPERBAL[CTR]
		NEXT CTR
		WEBSTR$=" ",FDEL$,"TOTAL",FDEL$
		WEBSTR$=WEBSTR$+(TOTAMT USING "--------------.##"),FDEL$
		LIST$[ROW+1]=WEBSTR$
		LET ROW=ROW+1
	ENDIF
	LIST$[ROW+1]=esdel$
	Call AddToStr(e$,rstr$,List$[])

	! SECTION FOR CURRENT BUDGET
	CLEAR LIST$[]
	LIST$[0]=bsdel$,"CURR BUDGET",fdel$
	List$[1]="ID",FDEL$,"ACCTPER",FDEL$,"AMOUNT",FDEL$
	LET ROW=1
	totamt=0
	IF RETURNSTATUS<>0
		FOR CTR=SCURRPER TO ECURRPER
			WEBSTR$=(ROW USING "##"),FDEL$
			let work$=BGLM.CURRPERBAL[CTR] USING "&&&&"
			WEBSTR$=wEBSTR$+WORK$[3,4]+"/"+WORK$[1,2],FDEL$
			WEBSTR$=WEBSTR$+(GLM.CURRPERBAL[CTR] USING "--------------.##"),FDEL$
			LIST$[ROW+1]=WEBSTR$
			LET ROW=ROW+1
			totamt=totamt+GLM.CURRPERBAL[CTR]
		NEXT CTR
		WEBSTR$=" ",FDEL$,"TOTAL",FDEL$
		WEBSTR$=WEBSTR$+(TOTAMT USING "--------------.##"),FDEL$
		LIST$[ROW+1]=WEBSTR$
		LET ROW=ROW+1
	ENDIF
	LIST$[ROW+1]=esdel$
	Call AddToStr(e$,rstr$,List$[])

	! SECTION FOR NEW BUDGET
	CLEAR LIST$[]
	LIST$[0]=bsdel$,"NEW BUDGET",fdel$
	List$[1]="ID",FDEL$,"ACCTPER",FDEL$,"AMOUNT",FDEL$
	LET ROW=1
	totamt=0
	IF RETURNSTATUS<>0
		workper=slastper
		for ctr=scurrper to ecurrper
			let glm.CurrPerBal[ctr]=fnr(oglm.currperbal[workper]+(oglm.currperbal[workper]*(pct/100)))
			let workper=workper+1
			WEBSTR$=(ROW USING "##"),FDEL$
			let work$=BGLM.CURRPERBAL[CTR] USING "&&&&"
			WEBSTR$=wEBSTR$+WORK$[3,4]+"/"+WORK$[1,2],FDEL$
			WEBSTR$=WEBSTR$+(GLM.CURRPERBAL[CTR] USING "--------------.##"),FDEL$
			LIST$[ROW+1]=WEBSTR$
			LET ROW=ROW+1
			totamt=totamt+GLM.CURRPERBAL[CTR]
		NEXT CTR
		WEBSTR$=" ",FDEL$,"TOTAL",FDEL$
		WEBSTR$=WEBSTR$+(TOTAMT USING "--------------.##"),FDEL$
		LIST$[ROW+1]=WEBSTR$
		LET ROW=ROW+1
	ENDIF
	LIST$[ROW+1]=esdel$
	Call AddToStr(e$,rstr$,List$[])
	
	
	! section status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)

!!! SUBMIT BUDGET
case "SUBMITBUDGETLOAD" ! -- 610 - option 1 & 2 update base on last yr bud or gl data - display acct= Y
	call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(clientid)+" Not On File"
		goto endsubbudload:
	endif
	call openglbfile()
	if returnstatus=0 goto endsubbudload:
	let ch_glb=ch_glm
	call dxget ("FYE",tmp$)
	let tmp3=tmp$
	let work$=" ",work$
	let work$[1,2]=tmp3 using "&&"
	let work$[3,4]=tmp3 using "&&"
	let curryear=work$
	let tmp3=tmp3-1\if tmp3<0 let tmp3=99
	let work$[1,2]=tmp3 using "&&"
	let work$[3,4]=tmp3 using "&&"
	let lastyear=work$
	let keyglb$=" ",keyglb$
	search #ch_glb,2,1;keyglb$,rec_glb,e
	if e<>0
		let returnstatus=0
		Message$="Budget Control Record Not On File for Client "+str$(clientid) 
		goto endsubbudload:
	endif
	read record #ch_glb,rec_glb;glm.;
	if glm.CurrPerBal[13]=curryear
		let scurrper=1
		let ecurrper=12
	else
		if glm.CurrPerBal[26]=curryear
			let scurrper=14
			let ecurrper=25
		else
			if glm.CurrPerBal[39]=curryear
				let scurrper=27
				let ecurrper=38
			else
				let returnstatus=0
				work$=curryear using "&&&&"
				Message$="Fiscal Year "+work$[1,2]+" Not On File for Client "+str$(clientid) 
				goto endsubbudload:	
			endif
		endif
	endif
	call dxget ("GLACCTID",tmp$)
	let glacctid=tmp$
	If glacctid<=0 or glacctid>99999999
		let returnstatus=0
		Message$="Invalid G/L Account Submitted" 
		goto endsubbudload:
	endif	
	let keyglb$=" ",keyglb$
	let keyglb$[2,9]=glacctid using "########"
	search #ch_glb,2,1;keyglb$,rec_GLB,e
	if e>0
		let returnstatus=0
		let message$="G/L Account "+str$(glacctid)+" Not of File "
		goto endsubbudload:
	endif
	read record #ch_glb,rec_glb;glm.;
	! SECTION FOR NEW BUDGET
	
	LET tmpcnt=1
	for ctr=scurrper to ecurrper
		Call dxget("AMOUNT" + Str$(tmpcnt),tmp$)
		tmp3=tmp$
		if fra(tmp3*100)<>0
				let returnstatus=0
				let message$="Amount exceeds 2 decimals places"
				goto endsubbudload:
			endif
		let glm.CurrPerBal[ctr]=tmp3	
		LET tmpcnt=tmpcnt+1
	NEXT CTR
	write record #ch_glb,rec_glb;glm.;
	endsubbudload: ! end submit budget load 
	
	
	! section status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)


!!! END SUBMIT BUDGET
case "BUDDIRECTLOAD" ! -- 610 - option 4 direct load of budet
	call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(clientid)+" Not On File"
		goto endbuddir:
	endif
	call openglbfile()
	if returnstatus=0 goto endbuddir:
	let ch_glb=ch_glm
	call dxget ("FYE",tmp$)
	let tmp3=tmp$
	let work$=" ",work$
	let work$[1,2]=tmp3 using "&&"
	let work$[3,4]=tmp3 using "&&"
	let curryear=work$
	let tmp3=tmp3-1\if tmp3<0 let tmp3=99
	let work$[1,2]=tmp3 using "&&"
	let work$[3,4]=tmp3 using "&&"
	let lastyear=work$
	let keyglb$=" ",keyglb$
	search #ch_glb,2,1;keyglb$,rec_glb,e
	if e<>0
		let returnstatus=0
		Message$="Budget Control Record Not On File for Client "+str$(clientid) 
		goto endbuddir:
	endif
	read record #ch_glb,rec_glb;glm.;
	read record #ch_glb,rec_glb;oglm.; ! to keep the accting periods
	if glm.CurrPerBal[13]=curryear
		let scurrper=1
		let ecurrper=12
	else
		if glm.CurrPerBal[26]=curryear
			let scurrper=14
			let ecurrper=25
		else
			if glm.CurrPerBal[39]=curryear
				let scurrper=27
				let ecurrper=38
			else
				let returnstatus=0
				work$=curryear using "&&&&"
				Message$="Fiscal Year "+work$[1,2]+" Not On File for Client "+str$(clientid) 
				goto endbuddir:	
			endif
		endif
	endif
	
	
	call dxget ("GLACCTID",tmp$)
	let glacctid=tmp$
	If glacctid<=0 or glacctid>99999999
		let returnstatus=0
		Message$="Invalid G/L Account Submitted" 
		goto endbuddir:
	endif
	call dxget ("SEARCHTYPE",tmp$)
	let work$=ucase$(rtrim$(tmp$))
	let mode=2 ! exact
	let keyglb$=" ",keyglb$
	let keyglb$[2,9]=glacctid using "########"
	if work$="PREV"
		LET  MODE=6
	endif
	if work$="NEXT"
		LET MODE=3
	endif
	search #ch_glb,mode,1;keyglb$,rec_GLB,e
	if e>0
		returnstatus=0
		if mode=2
			let message$="G/L Account "+str$(glacctid)+" Not of File "
			goto endbuddir:
		endif
		let message$="End of File "
		goto endbuddir:
	endif
	read record #ch_glb,rec_glb;glm.;
	
	endbuddir: ! end getting budget
	! section 1 - send over info
	clear list$[]
	List$[0]=bsdel$,"GLACCTHDR",fdel$
	Webstr$="ClientID",fdel$,"ClientName",fdel$
	Webstr$=Webstr$,"GLAcctID",fdel$
	Webstr$=Webstr$+"RecType",fdel$ ! 
	Webstr$=Webstr$+"AcctType",fdel$ !
	Webstr$=Webstr$+"Desc",fdel$ !
	Webstr$=Webstr$+"StatType",fdel$ !
	list$[1]=webstr$
	ROW=2
	if returnstatus>0
		webstr$=str$(clientid),fdel$
		webstr$=webstr$,rtrim$(acf.ClientName$),fdel$
		webstr$=webstr$,rtrim$(glm.glacct$),fdel$
		 Call GetGlRecType()
		webstr$=webstr$,glm.rectype$," ",glrectype$,fdel$
		Call GetGlAcctType()  
		webstr$=webstr$,glm.accttype$," ",glaccttype$,fdel$
		webstr$=webstr$,rtrim$(glm.desc$),fdel$
		Webstr$=webstr$,rtrim$(glm.stattype$),fdel$
		list$[ROW]=webstr$
		row=row+1
	endif
	LIST$[ROW]=ESDEL$
	call AddToStr(e$,rstr$,List$[])
	
	

	! SECTION FOR CURRENT BUDGET
	CLEAR LIST$[]
	LIST$[0]=bsdel$,"CURR BUDGET",fdel$
	List$[1]="ID",FDEL$,"ACCTPER",FDEL$,"AMOUNT",FDEL$
	LET ROW=1
	totamt=0
	IF RETURNSTATUS<>0
		FOR CTR=SCURRPER TO ECURRPER
			WEBSTR$=(ROW USING "##"),FDEL$
			LET WORK$=OGLM.CURRPERBAL[CTR] USING "&&&&"
			LET WEBSTR$=WEBSTR$+WORK$[3,4]+"/"+WORK$[1,2],FDEL$
			WEBSTR$=WEBSTR$+(GLM.CURRPERBAL[CTR] USING "--------------.##"),FDEL$
			LIST$[ROW+1]=WEBSTR$
			LET ROW=ROW+1
			totamt=totamt+GLM.CURRPERBAL[CTR]
		NEXT CTR
		WEBSTR$="",FDEL$
		WEBSTR$=WEBSTR$,"TOTAL",FDEL$
		WEBSTR$=WEBSTR$+(TOTAMT USING "--------------.##"),FDEL$
		LIST$[ROW+1]=WEBSTR$
		LET ROW=ROW+1
	ENDIF
	LIST$[ROW+1]=esdel$
	Call AddToStr(e$,rstr$,List$[])
	
	! section status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)
! END - 610 DIRECT BUD LOAD
! OPTION 3 - GL BUDGET DISTRIBUTION
case "BUDDISTLIST" ! -- 610 - option 4 direct load of budet
	returnstatus=1
	message$="OK"
	ch_bdist= FindChannel() ! need to get a channel #
	LET Filename$="1/GLBDIST"+str$(intco)
	Call FindF(filename$,fileflag)  
	If not(fileflag)
		let tmp$="[1:40] ","files/",filename$
		Build #ch_bdist,tmp$ 
		keybdist$=" ",keybdist$
		LET Rec_bdist=2 \ SEARCH #ch_bdist,0,1;keybdist$,Rec_dist,E 
		IF E<>0
			let returnstatus=0
			let message$="Error Building Budget Distribution File"
			goto endbuddistlist:
		endif
		LET Rec_bdist=1 \ SEARCH #ch_bdist,0,0;keybdist$,Rec_bdist,E 
		IF E<>0
			let returnstatus=0
			let message$="Error Building Budget Distribution File"
			goto endbuddistlist:
		endif
		let tmp$="files/",filename$," <666>"
		Modify tmp$
		Try Close #ch_bdist Else Rem
	endif
	Try
		OPen #ch_bdist,filename$
	else
		let returnstatus=0
		let message$="Error Openning Budget Distribution File "
		goto endbuddistlist:
	end try
	! CHECK FOR EVEN DISTRIBUTION
	LET KEYBDIST$=" ",KEYBDIST$ \ LET KEYBDIST$[1,2]="EV" 
	SEARCH #CH_BDIST,2,1;KEYBDIST$,REC_BDIST,E
	IF E=1
		clear bdist.
		LET M=12 \ LET tmp3=100
		FOR ctr=1 TO 12
			IF M LET bdist.DistPer[ctr]=FNR(tmp3/M)
			LET tmp3=tmp3-bdist.DistPer[ctr]
			LET M=M-1
		NEXT ctr
		bdist.Distid$="EV  "
		bdist.Desc$="Even % Distribution     "+blank$
		LET E=2 \ SEARCH #CH_BDIST,1,0;KEYBDIST$,REC_BDIST,E
		IF E<>0
			let returnstatus=0
			let message$="Error Adding Record 'EV' to Budget Distribution File "
			goto endbuddistlist:
		endif
		write record #ch_bdist,rec_bdist;bdist.;
		SEARCH #CH_BDIST,4,1;KEYBDIST$,REC_BDIST,E 
		IF E<>0
			let returnstatus=0
			let message$="Error Adding Key 'EV' to Budget Distribution File "
			goto endbuddistlist:
		endif
	ENDIF 

	LET KEYBDIST$=" ",KEYBDIST$ \ LET KEYBDIST$[1,2]="VR"
	SEARCH #CH_BDIST,2,1;KEYBDIST$,REC_BDIST,E
	IF E=1
		call dxget ("clientid",tmp$)
		let clientid=tmp$
		let keyacf$=" ",keyacf$
		let keyacf$[1,6]=clientid using "######"
		let mode$="="
		dirno=1
		AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
		if AcfRec<=0 ! record found
			let returnstatus=0
			Message$="Client "+str$(clientid)+" Not On File"
			goto endbuddistlist:
		endif
		call openglbfile()
		if returnstatus=0 goto endbuddistlist:
		let ch_glb=ch_glm
		let keyglb$=" ",keyglb$
		search #ch_glb,2,1;keyglb$,rec_glb,e
		if e<>0
			let returnstatus=0
			Message$="Budget Control Record Not On File for Client "+str$(clientid) 
			goto endbuddistlist:
		endif
		read record #ch_glb,rec_glb;glm.;
		clear bdist.
		dim 1%,mthday[12]
		let mthday[1]=31;mthday[2]=28;mthday[3]=31;mthday[4]=30
		let mthday[5]=31;mthday[6]=30;mthday[7]=31;mthday[8]=31
		let mthday[9]=30;mthday[10]=31;mthday[11]=30;mthday[12]=31
		LET tmp3=100 \ LET M=365
		FOR ctr=1 TO 12
			LET work$=glm.CurrPerBal[ctr] USING "&&&&"
			LET D=work$[3,4] !MONTH
			IF M<>0 LET bdist.DistPer[ctr]=FNR(tmp3*(mthday[D]/M))
			LET M=M-mthday[D]
			tmp3=tmp3-bdist.DistPer[ctr]
		NEXT ctr
		! CALCULATE THE DISTRIBUTION
		bdist.Distid$="VR  "
		bdist.Desc$="Variable % by Days/Month"+blank$
		LET E=2 \ SEARCH #CH_BDIST,1,0;KEYBDIST$,REC_BDIST,E
		IF E<>0
			let returnstatus=0
			let message$="Error Adding Record 'VR' to Budget Distribution File "
			goto endbuddistlist:
		endif
		write record #ch_bdist,rec_bdist;bdist.;
		SEARCH #CH_BDIST,4,1;KEYBDIST$,REC_BDIST,E 
		IF E<>0
			let returnstatus=0
			let message$="Error Adding Key 'VR' to Budget Distribution File "
			goto endbuddistlist:
		endif
	ENDIF
	

	endbuddistlist: ! end getting budget
	! section 1 - send over info
	clear list$[]
	List$[0]=bsdel$,"BudDistList",fdel$
	Webstr$="ID",fdel$,"Description",fdel$
	list$[1]=webstr$
	ROW=2
	keybdist$=" ",keybdist$
	if returnstatus>0
		do
			search #ch_bdist,3,1;keybdist$,rec_bdist,e
			if e<>0 exit do
			read record #ch_bdist,rec_bdist;bdist.;
			webstr$=bdist.distid$,fdel$
			webstr$=webstr$,rtrim$(bdist.Desc$),fdel$
			list$[ROW]=webstr$
			row=row+1
		loop
	endif
	LIST$[ROW]=ESDEL$
	call AddToStr(e$,rstr$,List$[])
	! section status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)
! END - 610 DIRECT BUD LOAD
! get 610 - option 3 -- distribution list
case "GETBUDDIST" ! -- 610 - option 3 Budget distribution 
	returnstatus=1
	message$="OK"
	ch_bdist= FindChannel() ! need to get a channel #
	LET Filename$="1/GLBDIST"+str$(intco)
	Call FindF(filename$,fileflag)  
	If not(fileflag)
		let returnstatus=0
		let message$="Budget Distribution File Does Not Exist"
		goto endgetbuddist:
	endif
	Try
		OPen #ch_bdist,filename$
	else
		let returnstatus=0
		let message$="Error Opening Budget Distribution File "
		goto endgetbuddist:
	end try
	call dxget ("BUDDISTID",tmp$)
	let Work$=ucase$(rtrim$(tmp$))
	if work$="" or Len(work$)>4
		let returnstatus=0
		let message$="Invalid Budget Distribution Id Submitted" 
		goto endgetbuddist:! CHECK FOR EVEN DISTRIBUTION
	endif
	let work$=work$+blank$
	LET KEYBDIST$=" ",KEYBDIST$ \ LET KEYBDIST$[1,4]=work$ 
	SEARCH #CH_BDIST,2,1;KEYBDIST$,REC_BDIST,E
	IF E=1
		let returnstatus=0
		let message$="Budget Distribution Id Not on File" 
		goto endgetbuddist:
	endif
	read record #ch_bdist,rec_bdist;bdist.;
	endGETbuddist: ! end getting budget
	! section 1 - send over info
	clear list$[]
	List$[0]=bsdel$,"BudDist",fdel$
	Webstr$="ID",fdel$,"Description",fdel$,"EditFlag",fdel$
	for ctr=1 to 12
		Webstr$=webstr$+"Period"+str$(ctr),fdel$
	next ctr
	webstr$=webstr$,"TOTAL",fdel$
	list$[1]=webstr$
	ROW=2
	keybdist$=" ",keybdist$
	if returnstatus>0
		webstr$=bdist.Distid$+fdel$
		webstr$=webstr$+rtrim$(bdist.Desc$),fdel$
		let tmp$="Y"
		if bdist.distid$="EV  " let tmp$="N"
		if bdist.distid$="VR  " let tmp$="N"
		webstr$=webstr$+rtrim$(tmp$),fdel$! editflag
		LET tmp3=0
		for ctr=1 to 12
			webstr$=webstr$+(bdist.DistPer[ctr] using "----#.##"),fdel$
			tmp3=tmp3+bdist.DistPer[ctr]

		next ctr
		webstr$=webstr$+(tmp3 using "----#.##"),fdel$
		list$[ROW]=webstr$
		row=row+1
	endif
	LIST$[ROW]=ESDEL$
	call AddToStr(e$,rstr$,List$[])
	! section status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)
case "SUBBUDDIST" ! -- 610 - option 3 Budget distribution 
	returnstatus=1
	message$="OK"
	ch_bdist= FindChannel() ! need to get a channel #
	LET Filename$="1/GLBDIST"+str$(intco)
	Call FindF(filename$,fileflag)  
	If not(fileflag)
		let returnstatus=0
		let message$="Budget Distribution File Does Not Exist"
		goto endsubbuddist:
	endif
	Try
		OPen #ch_bdist,filename$
	else
		let returnstatus=0
		let message$="Error Opening Budget Distribution File "
		goto endsubbuddist:
	end try
	call dxget ("BUDDISTID",tmp$)
	let Work$=ucase$(rtrim$(tmp$))
	if work$="" or Len(work$)>4
		let returnstatus=0
		let message$="Invalid Budget Distribution Id Submitted" 
		goto endsubbuddist:! CHECK FOR EVEN DISTRIBUTION
	endif
	let work$=work$+blank$
	LET KEYBDIST$=" ",KEYBDIST$ \ LET KEYBDIST$[1,4]=work$ 
	SEARCH #CH_BDIST,2,1;KEYBDIST$,REC_BDIST,E
	IF E=1
		clear bdist.
		bdist.Distid$[1,4]=work$
		LET E=2 \ SEARCH #CH_BDIST,1,0;KEYBDIST$,REC_BDIST,E
		IF E<>0
			let returnstatus=0
			let message$="Error Adding Record "+rtrim$(work$)+" to Budget Distribution File "
			goto endsubbuddist:
		endif
		write record #ch_bdist,rec_bdist;bdist.;
		SEARCH #CH_BDIST,4,1;KEYBDIST$,REC_BDIST,E 
		IF E<>0
			let returnstatus=0
			let message$="Error Adding Key "+rtrim$(work$)+" to Budget Distribution File "
			goto endsubbuddist:
		endif
	endif
	read record #ch_bdist,rec_bdist;bdist.;
	call dxget("DELETEFLAG",tmp$)
	if ucase$(rtrim$(tmp$))="Y"
		SEARCH #CH_BDIST,5,1;KEYBDIST$,REC_BDIST,E 
		IF E<>0
			let returnstatus=0
			let message$="Error Deleting Key "+rtrim$(work$)+" to Budget Distribution File "
			goto endsubbuddist:
		endif	
		LET E=3 \ SEARCH #CH_BDIST,1,0;KEYBDIST$,REC_BDIST,E
		IF E<>0
			let returnstatus=0
			let message$="Error Deleting Record "+rtrim$(work$)+" to Budget Distribution File "
			goto endsubbuddist:
		endif
		let message$="Deleted"
		goto endsubbuddist:
	endif
		
	call dxget ("DESC",tmp$)
	bdist.desc$=rtrim$(tmp$)+blank$
	for ctr=1 to 12
		Call dxget("PERIOD" + Str$(ctr),tmp$)
		let bdist.DistPer[ctr]=tmp$
	next ctr
	write record #ch_bdist,rec_bdist;bdist.;
	endsubbuddist: ! end getting budget
	! section status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)

! 610 - Distribution Load Account
!!! END SUBMIT BUDGET
case "BUDDISTACCT" ! -- 610 - option 3 Distribution Load
	returnstatus=1
	message$="OK"
	ch_bdist= FindChannel() ! need to get a channel #
	LET Filename$="1/GLBDIST"+str$(intco)
	Call FindF(filename$,fileflag)  
	If not(fileflag)
		let returnstatus=0
		let message$="Budget Distribution File Does Not Exist"
		goto endbuddistacct:
	endif
	Try
		OPen #ch_bdist,filename$
	else
		let returnstatus=0
		let message$="Error Opening Budget Distribution File "
		goto endbuddistacct:
	end try
	call dxget ("BUDDISTID",tmp$)
	let Work$=ucase$(rtrim$(tmp$))
	if work$="" or Len(work$)>4
		let returnstatus=0
		let message$="Invalid Budget Distribution Id Submitted" 
		goto endbuddistacct:
	endif
	let work$=work$+blank$
	LET KEYBDIST$=" ",KEYBDIST$ \ LET KEYBDIST$[1,4]=work$ 
	SEARCH #CH_BDIST,2,1;KEYBDIST$,REC_BDIST,E
	IF E<>0
		let returnstatus=0
		let message$="Budget Distribution Not On File "
		goto endbuddistacct:
	endif
	read record #ch_bdist,rec_bdist;bdist.;
	call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(clientid)+" Not On File"
		goto endbuddistacct:
	endif
	call openglbfile()
	if returnstatus=0 goto endbuddistacct:
	let ch_glb=ch_glm
	call dxget ("FYE",tmp$)
	let tmp3=tmp$
	let work$=" ",work$
	let work$[1,2]=tmp3 using "&&"
	let work$[3,4]=tmp3 using "&&"
	let curryear=work$
	let tmp3=tmp3-1\if tmp3<0 let tmp3=99
	let work$[1,2]=tmp3 using "&&"
	let work$[3,4]=tmp3 using "&&"
	let lastyear=work$
	let keyglb$=" ",keyglb$
	search #ch_glb,2,1;keyglb$,rec_glb,e
	if e<>0
		let returnstatus=0
		Message$="Budget Control Record Not On File for Client "+str$(clientid) 
		goto endbuddistacct:
	endif
	read record #ch_glb,rec_glb;glm.;
	read record #ch_glb,rec_glb;oglm.; ! to keep the accting periods
	if glm.CurrPerBal[13]=curryear
		let scurrper=1
		let ecurrper=12
	else
		if glm.CurrPerBal[26]=curryear
			let scurrper=14
			let ecurrper=25
		else
			if glm.CurrPerBal[39]=curryear
				let scurrper=27
				let ecurrper=38
			else
				let returnstatus=0
				work$=curryear using "&&&&"
				Message$="Fiscal Year "+work$[1,2]+" Not On File for Client "+str$(clientid) 
				goto endbuddistacct:	
			endif
		endif
	endif
	
	
	call dxget ("GLACCTID",tmp$)
	let glacctid=tmp$
	If glacctid<=0 or glacctid>99999999
		let returnstatus=0
		Message$="Invalid G/L Account Submitted" 
		goto endbuddistacct:
	endif
	call dxget ("SEARCHTYPE",tmp$)
	let work$=ucase$(rtrim$(tmp$))
	let mode=2 ! exact
	let keyglb$=" ",keyglb$
	let keyglb$[2,9]=glacctid using "########"
	if work$="PREV"
		LET  MODE=6
	endif
	if work$="NEXT"
		LET MODE=3
	endif
	search #ch_glb,mode,1;keyglb$,rec_GLB,e
	if e>0
		returnstatus=0
		if mode=2
			let message$="G/L Account "+str$(glacctid)+" Not of File "
			goto endbuddir:
		endif
		let message$="End of File "
		goto endbuddistacct:
	endif
	read record #ch_glb,rec_glb;glm.;
	
	endbuddistacct:! 
	! section 1 - send over info
	clear list$[]
	List$[0]=bsdel$,"GLACCTHDR",fdel$
	Webstr$="ClientID",fdel$,"ClientName",fdel$
	Webstr$=Webstr$,"GLAcctID",fdel$
	Webstr$=Webstr$+"RecType",fdel$ ! 
	Webstr$=Webstr$+"AcctType",fdel$ !
	Webstr$=Webstr$+"Desc",fdel$ !
	Webstr$=Webstr$+"StatType",fdel$ !
	Webstr$=webstr$+"BudDistId",fdel$
	Webstr$=webstr$+"BudDistDesc",fdel$
	list$[1]=webstr$
	ROW=2
	if returnstatus>0
		webstr$=str$(clientid),fdel$
		webstr$=webstr$,rtrim$(acf.ClientName$),fdel$
		webstr$=webstr$,rtrim$(glm.glacct$),fdel$
		 Call GetGlRecType()
		webstr$=webstr$,glm.rectype$," ",glrectype$,fdel$
		Call GetGlAcctType()  
		webstr$=webstr$,glm.accttype$," ",glaccttype$,fdel$
		webstr$=webstr$,rtrim$(glm.desc$),fdel$
		Webstr$=webstr$,rtrim$(glm.stattype$),fdel$
		webstr$=webstr$,bdist.distid$,fdel$
		webstr$=webstr$,bdist.desc$,fdel$
		list$[ROW]=webstr$
		row=row+1
	endif
	LIST$[ROW]=ESDEL$
	call AddToStr(e$,rstr$,List$[])
	
	

	! SECTION FOR CURRENT BUDGET
	CLEAR LIST$[]
	LIST$[0]=bsdel$,"CURR BUDGET",fdel$
	List$[1]="ID",FDEL$,"ACCTPER",FDEL$,"PERCENT",FDEL$,"AMOUNT",FDEL$
	LET ROW=1
	totamt=0
	IF RETURNSTATUS<>0
		FOR CTR=SCURRPER TO ECURRPER
			WEBSTR$=(ROW USING "##"),FDEL$
			LET WORK$=OGLM.CURRPERBAL[CTR] USING "&&&&"
			LET WEBSTR$=WEBSTR$+WORK$[3,4]+"/"+WORK$[1,2],FDEL$
			WEBSTR$=WEBSTR$+(BDIST.DISTPER[row] USING "----.##"),FDEL$
			WEBSTR$=WEBSTR$+(GLM.CURRPERBAL[CTR] USING "--------------.##"),FDEL$
			LIST$[ROW+1]=WEBSTR$
			LET ROW=ROW+1
			totamt=totamt+GLM.CURRPERBAL[CTR]
		NEXT CTR
		WEBSTR$="",FDEL$
		WEBSTR$=WEBSTR$,"TOTAL",FDEL$,"",fdel$
		WEBSTR$=WEBSTR$+(TOTAMT USING "--------------.##"),FDEL$
		LIST$[ROW+1]=WEBSTR$
		LET ROW=ROW+1
	ENDIF
	LIST$[ROW+1]=esdel$
	Call AddToStr(e$,rstr$,List$[])
	! bud
	! section status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        call SetOutPut(e$,rstr$)
! end -610 g/l budget file maintenance

Case "STARTCONS643"
	RETURNSTATUS=1
	MESSAGE$="OK"
	! DROPLIST OF CLIENTS
	!Call FileDropListglacfz(e$,List$[],100,Ch_Acf) ! Acf file
	!Call AddToStr(e$,rstr$,List$[])
	!clear list$[]
	clear list$[]
	List$[0]=bsdel$,"Client List",fdel$
	Webstr$="Id",fdel$
	Webstr$=webstr$,"ClientName",fdel$
	Webstr$=webstr$,"Budget",fdel$
	List$[1]=webstr$
	row=2
	if custom_customer$="JACKSON"
		! CHECK IF CONSOLIDATION ACCOUNT EXIST
		CLIENTID=99;TOTREC=0
		LET KEYACF$=" ",KEYACF$\ LET KEYACF$[3,6]=CLIENTID USING "####"  
		SEARCH #CH_ACF,2,1;KEYACF$,REC_ACF,E
		if not(e) 
			let totrec=99
		else
			let returnstatus=0
			message$="CONSOLIDATION NOT AVAILABLE"
		endif
		Let webstr$="0"+fdel$+"All Jackson-Newell Companies"+fdel$
		read #ctlc,51,8;budflag;
		let tmp$="N"
		if budflag<>0 let tmp$="Y"
		let webstr$=webstr$+tmp$+fdel$
		list$[row]=webstr$
		let row=row+1
		goto updstart643: ! 
	endif
	read #ctlc,51,6;multclientflag;
	if multclientflag=0
		let returnstatus=0
		message$="CONSOLIDATION NOT AVAILABLE"
	endif
	keyacf$=" ",keyacf$
	if returnstatus>0
		let tmpcnt=maxcnt
		totrec=0
		read #ctlc,51,8;budflag;
		do
			search #ch_acf,3,1;keyacf$,rec_acf,e
			if e<>0 exit do
			let clientid=keyacf$[3,6]
			if clientid=99 let totrec=99
			if keyacf$[7,8]="  " and clientid<>99
				let webstr$=keyacf$[3,6],fdel$
				read record #ch_acf,rec_acf;acf.;
				let webstr$=webstr$,acf.clientname$,fdel$
				let clientid=keyacf$[3,6]
				if clientid=99 let totrec=99 ! flag consolidation file exists
				tmp3=0
				if budflag<>0 
					tmp = acf.DirNum$                                                                          
					filename$ = Str$(tmp) + "/GLB" + Str$(intco) + groupid$                                        
					tmp$ = clientid Using "####"                          
					For ctr = 1 To 4                                      
						if tmp$[ctr,ctr] = " " Let tmp$[ctr,ctr] = "."      
					Next ctr                                              
					filename$ = filename$ + tmp$                          
					Call FindF(filename$,fileflag)
					let tmp3=99
					If Not(fileflag)
						let tmp3=0 
					endif
				endif
				let tmp$="N"
				if tmp3<>0 let tmp$="Y"
				let webstr$=webstr$,tmp$,fdel$
				list$[row]=webstr$
				let row=row+1
				If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
			 
			endif
		loop
	endif
	if returnstatus>0 and not(totrec)
		let returnstatus=0
		let message$="Consolidation Client Does Not Exist"
	endif
	updstart643: ! 
	list$[row]=esdel$
	Call AddToStr(e$,rstr$,List$[])
	read #ctlc,51,6;multclientflag;
	if multclientflag=0
		let returnstatus=0
		message$="CONSOLIDATION NOT AVAILABLE"
	endif
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	Call SetOutPut(e$,rstr$)                                 
	



Case "PROCESSCONS643"
	RETURNSTATUS=1
	MESSAGE$="OK"
	call start643process()
	Call SetOutPut(e$,rstr$) 



Case "STARTSHIFT642"
	RETURNSTATUS=1
	MESSAGE$="OK"
	
	clear list$[]
	List$[0]=bsdel$,"Client List",fdel$
	Webstr$="Id",fdel$
	Webstr$=webstr$,"ClientName",fdel$
	Webstr$=webstr$,"CurrAcctPer",fdel$
	Webstr$=webstr$,"NewAcctPer",fdel$
	webstr$=webstr$,"VerifyShift",fdel$
	Webstr$=webstr$,"GLClosed",fdel$
	Webstr$=webstr$,"Budget",fdel$
	Webstr$=webstr$,"BudCurrPer",fdel$
	webstr$=webstr$,"BudNewPer",fdel$
	Webstr$=Webstr$,"VerifyBudShift",fdel$
	List$[1]=webstr$
	row=2
	read #ctlc,51,8;budflag;
	WORK$=APDATE USING "&&&&&&" ! yymmdd
	let glcurrper=work$[1,4]
	totrec=0
	let tmpcnt=maxcnt
	keyacf$=" ",keyacf$
	do
		search #ch_acf,3,1;keyacf$,rec_acf,e
		if e<>0 exit do
		let clientid=keyacf$[3,6]
		if keyacf$[7,8]<>"  " goto next642acf:
		if clientid=99 goto next642acf:
		read record #ch_acf,rec_acf;acf.;
		tmp = acf.DirNum$                                                                          
		filename$ = Str$(tmp) + "/GLM" + Str$(intco) + groupid$                                        
		tmp$ = clientid Using "####"                          
		For ctr = 1 To 4                                      
			if tmp$[ctr,ctr] = " " Let tmp$[ctr,ctr] = "."      
		Next ctr                                              
		filename$ = filename$ + tmp$                          
		Call FindF(filename$,fileflag)
		If Not(fileflag) goto next642acf:
		ch_glm=findchannel()
		try
			Ropen #ch_glm,filename$
		else
			goto next642acf:
		end Try
		let keyglm$=" ",keyglm$
		search #ch_glm,2,1;keyglm$,rec_glm,e
		if e<>0 goto next642acf:
		totrec=totrec+1
		read record #ch_glm,rec_glm;glm.;
		let webstr$=keyacf$[3,6],fdel$ 
		let webstr$=webstr$,acf.clientname$,fdel$
		let work$=glm.currperbal[1] USING "&&&&"
		let webstr$=webstr$,work$[3,4],"/",work$[1,2],fdel$
		let work$=glm.currperbal[14] uSING "&&&&"
		let webstr$=webstr$,work$[3,4],"/",work$[1,2],fdel$
		! verify current period
		let tmp$="N"
		if glcurrper<=glm.currperbal[1] let tmp$="Y"
		for ctr=1 to 12 ! current year
			if glcurrper=glm.currperbal[ctr] let tmp$="Y"
		next ctr
		if tmp$<>"Y"
			for ctr=14 to 25
				if glcurrper=glm.currperbal[ctr] let tmp$="Y"
			next ctr
		endif
		
		let webstr$=webstr$,tmp$,fdel$
		! verify close
		TMP$="Y"
		let tmp3=0
		let keyglm$=" ",keyglm$
		LET keyglm$[1,2]="NN"
		search #ch_glm,2,1;keyglm$,rec_glm,e
		if e<>0 
			let tmp$="N"
			let message$="Missing 'NN' account from g/l Master File for client "+str$(clientid)
		else
		
			read record #ch_glm,rec_glm;glm.;
			let tmp3=0
			for ctr=0 to 13
				let tmp3=tmp3+glm.currperbal[ctr]
			next ctr
			if tmp3<>0 let tmp$="N"
		endif
		let webstr$=webstr$,tmp$,fdel$
		clear glm.
		if budflag<>0 
			tmp = acf.DirNum$                                                                          
			filename$ = Str$(tmp) + "/GLB" + Str$(intco) + groupid$                                        
			tmp$ = clientid Using "####"                          
			For ctr = 1 To 4                                      
				if tmp$[ctr,ctr] = " " Let tmp$[ctr,ctr] = "."      
			Next ctr                                              
			filename$ = filename$ + tmp$                          
			Call FindF(filename$,fileflag)
			if fileflag<>0
				ch_glb=findchannel()
				try
					Ropen #ch_glb,filename$
					let keyglm$=" ",keyglm$
					search #ch_glb,2,1;keyglm$,rec_glb,e
					if e=0
						read record #ch_glb,rec_glb;glm.;
						let tmp3=99
					endif
				else
					tmp3=0
				end Try
			Endif
		Endif
		if not (tmp3)
			let webstr$=webstr$+"N"+Fdel$ ! budget no
			let webstr$=webstr$+" "+fdel$ ! budget current period
			let webstr$=webstr$+" "+fdel$ ! budget new period
			let webstr$=webstr$+"N"+fdel$ ! veri
		
		else
			let webstr$=webstr$+"Y"+fdel$
			let work$=glm.currperbal[1] USING "&&&&"
			let webstr$=webstr$,work$[3,4],"/",work$[1,2],fdel$
			let work$=glm.currperbal[14] uSING "&&&&"
			let webstr$=webstr$,work$[3,4],"/",work$[1,2],fdel$
			! verify current period
			! verify current period
			let tmp$="N"
			if glcurrper<=glm.currperbal[1] let tmp$="Y"
			for ctr=1 to 12 ! current year
				if glcurrper=glm.currperbal[ctr] let tmp$="Y"
			next ctr
			if tmp$<>"Y"
				for ctr=14 to 25
					if glcurrper=glm.currperbal[ctr] let tmp$="Y"
				next ctr
			endif
			Webstr$=webstr$+tmp$+fdel$

		endif
		
		list$[row]=webstr$
		let row=row+1
		If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
		
		next642acf: ! get next acf record
	loop
	if not(totrec)
		let returnstatus=0
		let message$="No Clients Exists For Shifting Balances"
	endif
	list$[row]=esdel$
	Call AddToStr(e$,rstr$,List$[])
	clear list$[]
	let list$[0]=bsdel$,"PASSWORD",fdel$
	list$[1]="Password",fdel$
	list$[2]="SHIFT",fdel$
	list$[3]=esdel$
	Call AddToStr(e$,rstr$,List$[])
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	Call SetOutPut(e$,rstr$)                                 
	



Case "PROCSHIFT642" ! shift balances
	RETURNSTATUS=1
	MESSAGE$="OK"
	call start642process()
	Call SetOutPut(e$,rstr$) 
	! purge gl detail history

! End of Year --- 
Case "STARTCLOSE641"
	RETURNSTATUS=1
	MESSAGE$="OK"
	
	clear list$[]
	List$[0]=bsdel$,"Client List",fdel$
	Webstr$="Id",fdel$
	Webstr$=webstr$,"ClientName",fdel$
	Webstr$=webstr$,"FYE1",fdel$
	Webstr$=webstr$,"FYE2",fdel$
	Webstr$=webstr$,"FYE3",fdel$
	
	List$[1]=webstr$
	row=2
	
	totrec=0
	let tmpcnt=maxcnt
	keyacf$=" ",keyacf$
	do
		search #ch_acf,3,1;keyacf$,rec_acf,e
		if e<>0 exit do
		let clientid=keyacf$[3,6]
		if keyacf$[7,8]<>"  " goto next641acf:
		if clientid=99 goto next641acf:
		read record #ch_acf,rec_acf;acf.;
		tmp = acf.DirNum$                                                                          
		filename$ = Str$(tmp) + "/GLM" + Str$(intco) + groupid$                                        
		tmp$ = clientid Using "####"                          
		For ctr = 1 To 4                                      
			if tmp$[ctr,ctr] = " " Let tmp$[ctr,ctr] = "."      
		Next ctr                                              
		filename$ = filename$ + tmp$                          
		Call FindF(filename$,fileflag)
		If Not(fileflag) goto next641acf:
		ch_glm=findchannel()
		try
			Ropen #ch_glm,filename$
		else
			goto next641acf:
		end Try
		! control record
		let keyglm$=" ",keyglm$
		search #ch_glm,2,1;keyglm$,rec_glm,e
		if e<>0 goto next641acf:
		totrec=totrec+1
		read record #ch_glm,rec_glm;glm.;
		let webstr$=keyacf$[3,6],fdel$  ! id
		let webstr$=webstr$,acf.clientname$,fdel$ ! clientname
		tmp$ = glm.currperbal[13] Using "&&&&"
		webstr$=webstr$,tmp$[1,2],fdel$! fye 1
		tmp$ = glm.currperbal[26] Using "&&&&"
		webstr$=webstr$,tmp$[1,2],fdel$! fye 2
		tmp$ = glm.currperbal[39] Using "&&&&"
		webstr$=webstr$,tmp$[1,2],fdel$! fye 3! get current acct period
		! verify current period
		
		list$[row]=webstr$
		let row=row+1
		If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
		
		next641acf: ! get next acf record
	loop
	if not(totrec)
		let returnstatus=0
		let message$="No Clients Exists For Year End Close"
	endif
	list$[row]=esdel$
	Call AddToStr(e$,rstr$,List$[])
	clear list$[]
	let list$[0]=bsdel$,"PASSWORD",fdel$
	list$[1]="Password",fdel$
	list$[2]="CLOSE",fdel$
	list$[3]=esdel$
	Call AddToStr(e$,rstr$,List$[])
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	Call SetOutPut(e$,rstr$)                                 

Case "CLOSEDATA641"
	RETURNSTATUS=1
	MESSAGE$="OK"
	call dxget ("clientid",tmp$)
	Let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(client)+" Not On File"
		goto endclosedata:
	endif
	call openglmfile()
	if not(returnstatus) goto endclosedata:
	call dxget ("FYE",tmp$)
	let tmp3=tmp$
	let work$=" ",work$
	let work$[1,2]=tmp3 using "&&"
	let work$[3,4]=tmp3 using "&&"
	curryear=work$
	LET Keyglm$=" ",keyglm$
	search #ch_glM,2,1;keyglm$,rec_glm,e
	if e<>0
		let returnstatus=0
		Message$="Control Record Not On File for Client "+str$(clientid) 
		goto endclosedata:
	endif
	read record #ch_glM,rec_glM;glm.;
	if glm.CurrPerBal[13]=curryear
		let scurrper=1
		let ecurrper=12
		let currper=13
	else
		if glm.CurrPerBal[26]=curryear
			let scurrper=14
			let ecurrper=25
			let currper=26
		else
			if glm.CurrPerBal[39]=curryear
				let scurrper=27
				let ecurrper=38
				let currper=39
			else
				let returnstatus=0
				work$=curryear using "&&&&"
				Message$="Fiscal Year "+work$[1,2]+" Not On File for Client "+str$(clientid) 
				goto endclosedata:	
			endif
		endif
	endif
	WORK$=APDATE USING "&&&&&&" ! yymmdd
	let glcurrper=work$[1,4]
	let warncurr=0
	for ctr=scurrper to ecurrper
		if glm.currperbal[CTR]=glcurrper
			let warncurr=99
		endif
	next ctr
	let keyglm$=" ",keyglm$
	LET keyglm$[1,2]="NN"
	search #ch_glm,2,1;keyglm$,rec_glm,e
	if e<>0 
		let message$="Missing 'NN' account from g/l Master File for client "+str$(clientid)
		returnstatus=0
		goto endclosedata:
	endif
	read record #ch_glm,rec_glm;glm.;
	IF GLM.CURRPERBAL[CURRPER]<>0
		let returnstatus=0
		work$=curryear using "&&&&"
		Message$="Fiscal Year "+work$[1,2]+" for Client "+str$(clientid)+" Already Closed"
		goto endclosedata:
	endif
	let keyglm$=" ",keyglm$
	LET keyglm$[1,1]="N"
	search #ch_glm,2,1;keyglm$,rec_glm,e
	if e<>0 
		let message$="Missing 'N' account from g/l Master File for client "+str$(clientid)
		returnstatus=0
		goto endclosedata:
	endif
	read record #ch_glm,rec_glm;glm.;
	let glamount=0
	for ctr=scurrper to ecurrper
		let glamount=glamount+glm.currperbal[CTR]
	next ctr
	if glamount=0
		let returnstatus=0
		work$=curryear using "&&&&"
		Message$="Close Not Required for Fiscal Year "+work$[1,2]+" for Client "+str$(clientid)
		goto endclosedata:
	endif
	ENDCLOSEDATA: ! 
	clear list$[]
	List$[0]=bsdel$,"ClientCloseData",fdel$
	Webstr$="Id",fdel$
	Webstr$=webstr$,"ClientName",fdel$
	Webstr$=webstr$,"FYE",fdel$
	webstr$=webstr$,"VerifyClose",fdel$
	Webstr$=Webstr$,"ProfitLoss",fdel$
	Webstr$=Webstr$,"Amount",fdel$
	List$[1]=webstr$
	let webstr$=(clientid using "####"),fdel$  ! id
	let webstr$=webstr$,acf.clientname$,fdel$ ! clientname
	work$=curryear using "&&&&"
	let webstr$=webstr$,work$[1,2],fdel$
	let tmp$="N"
	if warncurr<>0 let tmp$="Y"
	let webstr$=webstr$,tmp$,fdel$
	let tmp$="Profit"
	if glamount>0 let tmp$="Loss"	
	Webstr$=Webstr$,tmp$,fdel$
	Webstr$=Webstr$,(glamount using "----------.##"),fdel$
	list$[2]=webstr$
	list$[3]=esdel$
	Call AddToStr(e$,rstr$,List$[])
	! glaccount droplist
	! section 3 -- send over droplist  - only capital accounts allowd
	Clear list$[]
	List$[0]=bsdel$,"GLMDroplist",fdel$
	Webstr$="Id",fdel$
	Webstr$=webstr$,"Description",fdel$
	List$[1]=webstr$
	row=2
	if returnstatus>0 ! no errors
		let tmpcnt=maxcnt ! 2000
		let keyglm$=" ",keyglm$
		do
			search #ch_glm,3,1;keyglm$,glmrec,e
			if e>0 exit do
			read record #ch_glm,glmrec;glm.;
			if glm.rectype$[1,1]="0" and glm.accttype$="C"
				let webstr$=keyglm$,fdel$
				let webstr$=webstr$,rtrim$(glm.Desc$),fdel$
				list$[ROW]=webstr$
				row=row+1
				If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
			endif
			
		loop ! for the do
	endif ! for returnstatus
	list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])
	
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	Call SetOutPut(e$,rstr$)                           

Case "PROCCLOSE641" ! end of year
	RETURNSTATUS=1
	MESSAGE$="OK"
	call start641process()
	Call SetOutPut(e$,rstr$) 


! end of year
end select
    !
  ! call dxclose()
else
  include "src/callmainerrnet.inc"
end try
end

	



!--------------------------------------------------------------------
sub OpenFiles()
  
  ! Open files for order entry
  
  Try
    !
    Ch_Acf = OpenFile(48,intCo) \ If Ch_Acf= -1 Error 42  
   
    !
  else
    include "src/callsuberr.inc"
  end try
end sub ! openfiles
! 
!--------------------------------------------------------------------
Sub GetGlAcctType() 
! should already have glm.accttype$

try
	let glaccttype$=""         
	IF glm.ACCTTYPE$[1,1]="A" glaccttype$="ASSET"         
	IF glm.ACCTTYPE$[1,1]="L" glaccttype$="LIABILITY"
	IF glm.ACCTTYPE$[1,1]="C" glaccttype$="CAPITAL"      
	IF glm.ACCTTYPE$[1,1]="I" glaccttype$="INCOME"        
	IF glm.ACCTTYPE$[1,1]="E" glaccttype$="EXPENSE"       
	IF glm.ACCTTYPE$[1,1]="R" glaccttype$="OTHER INC"     
	IF glm.ACCTTYPE$[1,1]="O" glaccttype$="OTHER EXP"     
	IF glm.ACCTTYPE$[1,1]="N" glaccttype$="NET PROFIT"               
else
	! this is a remark
end try
end sub ! getglaccttype                                        
!----------------------------------------------
Sub GetGlStattype()
try
	clear glst.                              
	if ch_glst <>0  
		if rtrim$(glm.stattype$)<>""
			LET keyglst$=" ",keyglst$ \ LET keyglst$[1,10]=glm.stattype$
			SEARCH #CH_glst,2,1;keyglst$,REC_glst,E                    
			IF not(e)
				read record #ch_glst,rec_glst;glst.;
			endif
		endif
	endif
else
	clear glst.
end try
end sub ! getglstattype
! ---------------
Sub OpenGlmFile() 
! should already have clientid and company
	
try
	let tmp=acf.DirNum$
	let filename$=str$(tmp)+"/GLM"+STR$(intco)+groupid$
	if source=613
		let filename$=str$(tmp)+"/GLB"+STR$(intco)+groupid$
	endif
	let tmp$=clientid using "####"
	for ctr=1 to 4
		if tmp$[ctr,ctr]=" " let tmp$[ctr,ctr]="."
	next ctr
	let filename$=filename$+tmp$
	Call FindF(filename$,fileflag)
	if not (fileflag)
		let returnstatus=0
		if source<>613
			let message$="G/L Master File for Client ",str$(clientid)," Not Found"
		else
			let message$="G/L Budget File for Client ",str$(clientid)," Not Found"
		endif
	else
		ch_glm= FindChannel() ! need to get a channel #
		open #ch_glm,filename$
		let keyglm$=" ",keyglm$
		search #ch_glm,2,1;keyglm$,glmrec,e
		if e<>0
			let returnstatus=0
			if source<>613
				let message$="G/L Master File Control Record for Client ",str$(clientid)," Not Found"
			else
				let message$="G/L Budget File Control Record for Client ",str$(clientid)," Not Found"	
			endif
		else
			read record #ch_glm,glmrec;glm.;
		endif
	endif

else
	! this is a remark
end try
end sub ! openglm    
!-------------------------------------
Sub GetGlRecType() 
! should already have glm.rectype$

try
	let glrectype$=""         
	IF glm.rectype$[1,1]="0" glrectype$="Normal Post"         
	IF glm.rectype$[1,1]="1" glrectype$="Memo"
	IF glm.rectype$[1,1]="2" glrectype$="Non-Print Memo"      
	IF glm.rectype$[1,1]="3" glrectype$="Total"        
	IF glm.rectype$[1,1]="4" glrectype$="Non-Print Total"       
	IF glm.rectype$[1,1]="5" glrectype$="Page Break"     
	             
else
	! this is a remark
end try
end sub ! getglrectype                                        
!-----------------------------------------
Sub FindAcctPeriod()
! should have account period in variable acper --- YYMM ---
try
	glcurrper=0
	let tmpkey$=" ",tmpkey$
	search #ch_glm,2,1;tmpkey$,tmprec,e
	if e
		let returnstatus=0
		let message$="G/L Accounting Period Record Not on File"
	endif
	if returnstatus>0
		mat read #ch_glm,tmprec,70;glper;
		if acper
			for ctr=1 to 12
				if acper=glper[ctr] let glcurrper=ctr
			next ctr
			if not(glcurrper)
				for ctr=14 to 25
					if acper=glper[ctr] let glcurrper=ctr
				next ctr
			endif
			if not(glcurrper)
				for ctr=27 to 38
					if acper=glper[ctr] let glcurrper=ctr
				next ctr
			endif
		endif
		if glcurrper
			let soyper=0
			if glcurrper>13 let soyper=13
			if glcurrper>26 let soyper=26
			let somper=glcurrper-1\if somper<0 let somper=0
			let work$=glper[13] using "&&&&"
			if glcurrper>13 let work$=glper[26] using "&&&&"

			if glcurrper>26 let work$=glper[39] using "&&&&"
			let glfye=work$[1,2]

		endif
	endif
else
	! this is a remark
end try
end sub ! FindAcctPeriod  
!-------------------------------------
Sub Calcglbal()	
try
	balexist=0
	clear hdrbal[]
	clear ytdbal[]
	clear mtdbal[]
	for ctr=0 to 39
		let mtdbal[ctr]=glm.currperbal[ctr]
		if mtdbal[ctr]<>0 let balexist=99
	next ctr
	if glm.accttype$="A" or glm.accttype$="L" or Glm.accttype$="C"
		let ytdbal[0]=glm.currperbal[0]
		for ctr=1 to 39
			let ytdbal[ctr]=ytdbal[ctr-1]+glm.currperbal[ctr]
		next ctr
	else
		let ytdbal[0]=glm.currperbal[0] ! first year balance
		for ctr=1 to 13
			let ytdbal[ctr]=ytdbal[ctr-1]+glm.currperbal[ctr]
		next ctr
		let ytdbal[14]=glm.currperbal[14]  ! second year balance
		for ctr=15 to 26
			let ytdbal[ctr]=ytdbal[ctr-1]+glm.currperbal[ctr]
		next ctr
		let ytdbal[27]=glm.currperbal[27]  ! third year balance
		for ctr=28 to 39
			let ytdbal[ctr]=ytdbal[ctr-1]+glm.currperbal[ctr]
		next ctr
	endif
	if glcurrper
		if glm.accttype$="A" or glm.accttype$="L" or Glm.accttype$="C"
			let hdrbal[0]=glm.currperbal[0] ! soy
			let hdrbal[1]=glm.currperbal[0] ! som
			for ctr=1 to 39
				if ctr<=soyper
					let hdrbal[0]=hdrbal[0]+glm.currperbal[ctr]
				endif
				if ctr<=somper
					let hdrbal[1]=hdrbal[1]+glm.currperbal[ctr]
				endif
			next ctr
		else ! for income & expense items
			let hdrbal[0]=0 ! income&expense alway start of year 0
			let hdrbal[1]=0
			for ctr=soyper to somper
				let hdrbal[1]=hdrbal[1]+glm.currperbal[ctr]
			next ctr
		endif
		if glcurrper>soyper
			for ctr=(soyper+1) to glcurrper
				let hdrbal[3]=hdrbal[3]+glm.currperbal[ctr]
			next ctr
		endif
		let hdrbal[2]=glm.currperbal[glcurrper]
	else
		let hdrbal[0]=0
		let hdrbal[1]=0
		let hdrbal[2]=0
		let hdrbal[3]=0
	endif                    
else
	! this is a remark
end try
end sub !   Calcglbal  
!-------------------------------------------------------------
Sub OpenGltFile() 
! should already have clientid and company
	
try
	let tmp=acf.DirNum$
	let filename$=str$(tmp)+"/GLT"+STR$(intco)+groupid$
	let tmp$=clientid using "####"
	for ctr=1 to 4
		if tmp$[ctr,ctr]=" " let tmp$[ctr,ctr]="."
	next ctr
	let filename$=filename$+tmp$+".."
	let tmp$=glfye using "&&"
	let filename$=filename$+tmp$
	Call FindF(filename$,fileflag)
	if not (fileflag)
		let returnstatus=0
		let message$="G/L Transaction File for Client ",str$(clientid),"Fiscal Year ",tmp$," Not Found"
	else
		ch_glt= FindChannel() ! need to get a channel #
		open #ch_glt,filename$
		
		
	endif

else
	! this is a remark
end try
end sub ! opengltfile   
!!! get gldata

!--------------------------------------------------------------------------------------------------
Sub GetGlData() 
! should already have clientid and company
	
try
call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(client)+" Not On File"
	endif
	if returnstatus>0
		call openglmfile()
	endif
	if returnstatus>0
		call dxget ("glacctid",tmp$)
		let glacctid=tmp$
		let keyglm$=" ",keyglm$
		let keyglm$[2,9]=glacctid using "########"
		search #ch_glm,2,1;keyglm$,glmrec,e
		if e
			let returnstatus=0
			let Message$="G/L Account "+str$(glacctid)+" Not On File"
		endif
	endif
	if returnstatus>0
		read record #ch_glm,glmrec;glm.;
		call dxget ("acctper",tmp$)
		let acper=0
		if len(tmp$)=5
			let glmo=tmp$[1,2]
			let glyr=tmp$[4,5]
			let work$=glyr using "&&"
			let work$[3]=glmo using "&&"
			let acper=work$
		endif
		call FindAcctPeriod()
		if not(glcurrper)
			let returnstatus=0
			let work$=acper using "&&&&"
			let message$="Accounting Period ",work$[3,4],"/",work$[1,2]," Not Found"
		endif
	endif
	if returnstatus>0
		call opengltfile()
	
	endif
	if returnstatus>0
		call dxget ("refrec",tmp$)
		let gltrec=tmp$
		if not (gltrec)
			let returnstatus=0
			let message$="Invalid Record Reference Number"
		endif
	endif
	if returnstatus>0
		read record #ch_glt,gltrec;glt.;
	endif
else
! this a remark
end try
end sub ! getgldat

!--------------------------------------------------------------------------------------------------
Sub GetGlBatch()

try
call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(client)+" Not On File"
		goto endgetglbatch
	endif
	call openglmfile()
	if not (returnstatus)
		goto endgetglbatch:
	endif
	call dxget ("acctper",tmp$)
	let acper=0
	if len(tmp$)=5
		let glmo=tmp$[1,2]
		let glyr=tmp$[4,5]
		let work$=glyr using "&&"
		let work$[3]=glmo using "&&"
		let acper=work$
	endif
	call FindAcctPeriod()
	if not(glcurrper)
		let returnstatus=0
		let work$=acper using "&&&&"
		let message$="Accounting Period ",work$[3,4],"/",work$[1,2]," Not Found"
		goto endgetglbatch:
	endif
	Call Dxget("batchid",tmp$)
	let batchid=tmp$
	if batchid=0 and tmp$<>"0" let batchid=-1
	if source=613 and batchid=0 let batchid=-1 ! need a batch number for budget
	if batchid<0 or batchid>999
		let returnstatus=0
		let message$="Invalid Batch Id Submitted"
		goto endgetglbatch:	
	endif
	if batchid<>0
		let tmp=acf.DirNum$
		let filename$=str$(tmp)+"/G"+STR$(intco)+groupid$
		let tmp$=clientid using "####"
		for ctr=1 to 4
			if tmp$[ctr,ctr]=" " let tmp$[ctr,ctr]="."
		next ctr
		let filename$=filename$+tmp$
		tmp$=acper using "&&&&"
		let filename$=filename$+tmp$
		let tmp$=batchid using "###"
		for ctr=1 to 3
			if tmp$[ctr,ctr]=" " let tmp$[ctr,ctr]="."
		next ctr
		let filename$=filename$+tmp$
		Call FindF(filename$,fileflag)
		if not (fileflag)
			let returnstatus=0
			let message$="Batch Number",str$(batchid)," Not On File"
			goto endgetglbatch:
		endif
		ch_glbatch= FindChannel() ! need to get a channel #
		open #ch_glbatch,filename$
                LET TRACKSCRATCH[2]=1  !EXIST BATCH
                !! CALL TRACKGLWRITE()

                ! check existing batch
		let rec_bth=chf(ch_glbatch)-1
		if rec_bth<=0   ! set end of record -- never ended properly
			LET totdr=0
			let totcr=0 
			REC_BTH=0
			LET SEQNUM=1 
			call getglendrec1()
			let rec_bth=rec_bth+1            
			call getglendrec2() 
			let rec_bth=chf(ch_glbatch)-1
		ENDIF  
		READ #ch_glbatch,rec_bth;bthctrl1$; 
		READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
		IF bthctrl1$[10,20]="1  PAY    1"  ! last record
			IF bthctrl1$[21,21]<>"0" LET bthctrl1$[21,21]="0" ! prev used for mech finanance dealer
			if source=612
				if bthctrl1$[1,1]<>"M"
					let returnstatus=0
					let message$="Batch "+str$(batchid)+" Not Designated as a Memo Account Batch. May Not Edit."
					goto endgetglbatch:
				endif
			else
				if bthctrl1$[1,1]="M"
					let returnstatus=0
					let message$="Batch "+str$(batchid)+" is Designated as a Memo Account Batch. May Not Edit."
					goto endgetglbatch:
				endif	
			endif
			rec_bth=rec_bth-1
			! second to the last record 
			read #ch_glbatch,rec_bth;bthctrl$; 
			READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
			IF bthctrl$[1,1]="*" and bthctrl$[63,63]="9" 
				if bthctrl$[62,62]="U"
					let tmp3=bthctrl$[53,58]
					if tmp3<>rec_uac
						let returnstatus=0
						let message$="Batch "+str$(batchid)+" is Already in Update Process "
						goto endgetglbatch:
					endif
					let seqnum=rec_bth+1
					goto endgetglbatch: !
				else
					let seqnum=bthctrl$[59,62]
					if not(seqnum) let seqnum=rec_bth+1
				ENDIF 				
				let bthctrl$[53,58]=rec_uac using "&&&&&&"
				if source<>613
					let bthctrl$[62,62]="U"
					write #ch_glbatch,rec_bth;bthctrl$;
					Write #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
					goto endgetglbatch:
				endif
			else
			! we dont have a * record need to create one but had a Pay		    
				let seqnum=rec_bth+1!
				let rec_bth=chf(ch_glbatch)-1
				LET totdr=0
				let totcr=0 
				call getglendrec1() ! add *
				READ #ch_glbatch,rec_bth;bthctrl1$; 
				READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
				let bthctrl$[53,58]=rec_uac using "&&&&&&"
				if source<>613
					let bthctrl$[62,62]="U"
					write #ch_glbatch,rec_bth;bthctrl$;
					Write #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
				endif
				let rec_bth=rec_bth+1            
				call getglendrec2() ! pay
				let rec_bth=chf(ch_glbatch)-1
				goto endgetglbatch: ! 
			endif
		else
			! we dont have a pay record or * record
			let seqnum=rec_bth+1!
			let rec_bth=chf(ch_glbatch)-1
			LET totdr=0
			let totcr=0 
			call getglendrec1() ! add *
			READ #ch_glbatch,rec_bth;bthctrl1$; 
			READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
			let bthctrl$[53,58]=rec_uac using "&&&&&&"
			if source<>613
				let bthctrl$[62,62]="U"
				write #ch_glbatch,rec_bth;bthctrl$;
				Write #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
			endif
			let rec_bth=rec_bth+1            
			call getglendrec2() ! pay
			let rec_bth=chf(ch_glbatch)-1
			goto endgetglbatch: ! 
		endif
	else ! create a new record
		If source=613
			let returnstatus=0
			let message$="Invalid Batch Number Submitted"
			goto endgetglbatch:
		endif
		! create a new batch	
		keyacf1$=" ",keyacf1$
		keyacf1$[1,6]=clientid using "######"
		keyacf1$[7,8]="PG"
		search #ch_acf,2,1;keyacf1$,rec_acf1,e
		if e<>0
			let returnstatus=0
			let message$="G/L Batch Control Record Not on File"
			goto endgetglbatch:
		endif
		tiebreaker=tiebreaker=0
		getnextbatchid: ! get the next batchid for new batch
		mat read #ch_acf,rec_acf1,132;batchnum
		let batchid=batchnum
		let batchnum=batchnum+1
		if batchnum>999 let batchnum=1
		mat write #ch_acf,rec_acf1,132;batchnum;
		! read acf file for batch #
		tiebreaker=tiebreaker+1
		let tmp=acf.DirNum$
		let filename$=str$(tmp)+"/G"+STR$(intco)+groupid$
		let tmp$=clientid using "####"
		for ctr=1 to 4
			if tmp$[ctr,ctr]=" " let tmp$[ctr,ctr]="."
		next ctr
		let filename$=filename$+tmp$
		tmp$=acper using "&&&&"
		let filename$=filename$+tmp$
		let tmp$=batchid using "###"
		for ctr=1 to 3
			if tmp$[ctr,ctr]=" " let tmp$[ctr,ctr]="."
		next ctr
		let filename$=filename$+tmp$
		Call FindF(filename$,fileflag)! create a new batch
		if fileflag>0
			if tiebreaker > 999
				let returnstatus=0
				let message$="No Available Batch Numbers to process. Please Post Open Batches "
				goto endgetglbatch:
			endif
			goto getnextbatchid:
		endif
		ch_glbatch= FindChannel() ! need to get a channel #
		let tmp$="<666> files/",filename$
		Build #ch_glbatch,tmp$   
                LET TRACKSCRATCH[2]=2  !NEW BATCH
                !! CALL TRACKGLWRITE()

                LET Rec_bth=0                        
		LET bthctrl$=" ",bthctrl$                  
		LET bthctrlamt=0                       
		WRITE #ch_glbatch,rec_bth;bthctrl$ ! format file item 0                  
		! MAT  WRITE #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
		WRITE #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
		let tmp$="files/",filename$," <666>"
		Modify tmp$
		Try
			CLOSE #ch_glbatch
		else
			let returnstatus=0
			let message$="Error Creating Batch "+str$(batchid)
			goto endgetglbatch:
		end try
		! tmp$ = "chmod go+rw " + filename$
		tmp$ = "chmod 664 files/",filename$
		System tmp$                   
		OPEN #ch_glbatch,Filename$ 
		BTHCTRL$=" ",BTHCTRL$
		BTHCTRL=0
		REC_BTH=0
		LET SEQNUM=1                         
		LET totdr=0
		let totcr=0
		call getglendrec1()
		let rec_bth=rec_bth+1            
		call getglendrec2() 
		let rec_bth=0	
	endif
	! Start reading file transactions
	let rec_bth=chf(ch_glbatch)-1
	if rec_bth<=0   ! set end of record -- never ended properly
		LET totdr=0
		let totcr=0 
		REC_BTH=0
		LET SEQNUM=1 
		call getglendrec1()
		let rec_bth=rec_bth+1            
		call getglendrec2() 
		let rec_bth=chf(ch_glbatch)-1
	ENDIF  
	READ #ch_glbatch,rec_bth;bthctrl1$; 
	! MAT  READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	 READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	IF bthctrl1$[10,20]<>"1  PAY    1"
		call getglendrec1()
		let rec_bth=rec_bth+1            
		call getglendrec2() 
		let rec_bth=chf(ch_glbatch)-1
		READ #ch_glbatch,rec_bth;bthctrl1$; 
	ENDIF                      
	IF bthctrl1$[21,21]<>"0" LET bthctrl1$[21,21]="0" ! prev used for mech finanance dealer
	if source=612
		 if bthctrl1$[1,1]<>"M"
			let returnstatus=0
			let message$="Batch "+str$(batchid)+" Not Designated as a Memo Account Batch. May Not Edit."
			goto endgetglbatch:
		  endif
	else
		if bthctrl1$[1,1]="M"
			let returnstatus=0
			let message$="Batch "+str$(batchid)+" is Designated as a Memo Account Batch. May Not Edit."
			goto endgetglbatch:
		  endif	
	endif
	rec_bth=rec_bth-1
	! second to the last record 
	read #ch_glbatch,rec_bth;bthctrl$; 
	!MAT  READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	 READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	IF bthctrl$[1,1]<>"*" IF bthctrl$[63,63]<>"9" 
		LET totdr=0
		let totcr=0 
		REC_BTH=0
		LET SEQNUM=1
		Call getglendrec1()
		read #ch_glbatch,rec_bth;bthctrl$;
	endif
	if bthctrl$[62,62]="U"
		let tmp3=bthctrl$[53,58]
		if tmp3<>rec_uac
			let returnstatus=0
			let message$="Batch "+str$(batchid)+" is Already in Update Process "
			goto endgetglbatch:
		endif
	ENDIF 
	let bthctrl$[53,58]=rec_uac using "&&&&&&"
	if source<>613
		let bthctrl$[62,62]="U"
		write #ch_glbatch,rec_bth;bthctrl$;
		! MAT  WRITE #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
		Write #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	else
		goto endglbatchstat:
	endif
	endgetglbatch: !
	if source=613 goto endglbatchstat:
	clear list$[]
	List$[0] = bsdel$,"GLBatchDetail",fdel$
	webstr$=""
	webstr$="JSCODE",fdel$
	webstr$=webstr$,"REFID",fdel$
	webstr$=webstr$,"DATE",fdel$ ! MMDDYY
	webstr$=webstr$,"GLACCTID",fdel$
	webstr$=webstr$,"GLACCTNAME",fdel$
	webstr$=webstr$,"DESCRIPTION",fdel$
	webstr$=webstr$,"DELFLAG",fdel$
	webstr$=webstr$,"DEBITAMT",fdel$
	webstr$=webstr$,"CREDITAMT",fdel$
	if source=612
		let webstr$=webstr$,"EDIT",fdel$
	endif
	list$[1]=webstr$
	let row=2
	let tmpcnt=maxcnt
	if returnstatus>0
		totrec=chf(ch_glbatch)-1
		LET totdr=0
		let totcr=0 
		LET SEQNUM=1
		for rec_bth=0 to totrec
			read #ch_glbatch,rec_bth;bthdesc$;
			! Mat  READ #ch_glbatch,rec_bth,1;bthamt; 
			 READ #ch_glbatch,rec_bth,1;bthamt; ! format file item 1
			IF bthdesc$[1,1]="*" GOTO getnxtbthrec:              
			IF bthdesc$[10,20]="1  PAY    1" GOTO getnxtbthrec:  
			IF bthdesc$[63,63]<>"2" 
				LET seqnum=seqnum+1
				if bthamt>0 let totdr=totdr+bthamt
				if bthamt<0 let totcr=totcr-bthamt
			endif
			let webstr$=""
			webstr$=bthdesc$[1,1],fdel$ ! jscode$
			webstr$=webstr$,bthdesc$[14,19],fdel$ ! ref num
			webstr$=webstr$,bthdesc$[20,25],fdel$ ! MMDDYY
			let glacctid=bthdesc$[3,10]
			webstr$=webstr$,str$(glacctid),fdel$                                                 
			keyglm$ = " ",keyglm$                                             
			keyglm$[2,9] = glacctid Using "########"                          
			Search #ch_glm,2,1;keyglm$,glmrec,e                               
			If not(e)
				read record #ch_glm,glmrec;glm.;
			else
				clear glm.
				glm.desc$="Invalid Acct"
			endif
			WebStr$ = WebStr$,RTrim$(glm.Desc$),fdel$
			webstr$=webstr$,rtrim$(bthdesc$[26,58]),fdel$
			let tmp$="N"
			if bthdesc$[63,63]="2" let tmp$="Y"
			webstr$=webstr$,tmp$,fdel$
			if bthamt>=0
				let webstr$=webstr$,str$(bthamt),fdel$ ! (bthamt using "##########.##"),fdel$
				let webstr$=webstr$,"",fdel$
			else
				let webstr$=webstr$,"",fdel$
				let webstr$=webstr$,str$(bthamt*(-1)),fdel$ ! using "##########.##"),fdel$
			endif
			if source=612
				let tmp$="N"
				if glm.rectype$[1,1]="1" or glm.rectype$[1,1]="2" let tmp$="Y"
				let webstr$=webstr$,tmp$,fdel$
			endif
			List$[row] = WebStr$                                 
			row = row + 1                                        
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
			getnxtbthrec:! get next record
		next rec_bth
	endif
	List$[row] = esdel$             
	Call AddToStr(e$,rstr$,List$[])
	clear list$[]
	List$[0] = bsdel$,"GLBatchHeader",fdel$
	webstr$="ClientId",fdel$
	webstr$=webstr$,"AcctPer",fdel$
	webstr$=webstr$,"BatchId",fdel$
	if source<>612
		webstr$=webstr$,"CheckBal",fdel$
		webstr$=webstr$,"DebitBal",fdel$
		webstr$=webstr$,"CreditBal",fdel$
	endif
	list$[1]=webstr$
	let row=2
	if returnstatus>0
		webstr$=(clientid using "####"),fdel$
		let tmp$=acper using "&&&&"
		let webstr$=webstr$,tmp$[3,4],"/",tmp$[1,2],fdel$ ! mm/yy format
		webstr$=webstr$,(batchid using "###"),fdel$
		if source<>612
			webstr$=webstr$,str$(totdr-totcr),fdel$ ! ((totdr-totcr) using "------------.##"),fdel$
			webstr$=webstr$,str$(totdr),fdel$ ! ((totdr) using "------------.##"),fdel$
			webstr$=webstr$,str$(totcr),fdel$ !((totcr) using "------------.##"),fdel$
		endif
		list$[row]=webstr$
		let row=row+1
	endif
	list$[row]=esdel$
	Call AddToStr(e$,rstr$,List$[])
	endglbatchstat: ! write out status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
else
	 include "src/callsuberr.inc"! this a remark
end try
end sub ! getglbatch


! ===============================================================
Sub GetGlEndRec1()
Try
		LET TMP$=CLIENTID USING "####"
		FOR CTR=1 TO 4
			IF TMP$[CTR,CTR]=" " LET TMP$[CTR,CTR]="."
		NEXT CTR
		BTHCTRL$=" ",BTHCTRL$
		BTHCTRL=0                    
		LET BTHCTRL$[1,1]="*"                
		LET BTHCTRL$[2,5]=tmp$           
		LET BTHCTRL$[6,9]=acper USING "&&&&"  
		LET BTHCTRL$[10,12]=batchid USING "###" 
		LET BTHCTRL$[13,50]=acf.ClientName$      
		LET BTHCTRL$[51,51]=intco using "#"
		LET BTHCTRL$[52,52]=groupid$
		LET BTHCTRL$[59,62]=SEQNUM USING "####"
		LET BTHCTRL$[63,63]="9"                  
		Write #ch_glbatch,rec_bth;BTHCTRL$                
		!Mat Write #ch_glbatch,rec_bth,1;BTHCTRL 
		Write #ch_glbatch,rec_bth,1;BTHCTRL
		
else
	 include "src/callsuberr.inc"! this a remark
end try
end sub ! getglEndRec1
! ===============================================================
Sub GetGlEndRec2()
Try
		LET BTHCTRL1$=" ",BTHCTRL1$                                                                                                                                     
		LET BTHCTRL1$[31,40]=TOTDR*100 USING "----------"                                                                 
		IF TOTDR>0 LET BTHCTRL1$[31,40]=TOTDR*100 USING "##########"  
		LET BTHCTRL1$[41,50]=TOTCR*100 USING "----------"                                                          
		IF TOTCR>0 LET BTHCTRL1$[41,50]=TOTCR*100 USING "##########"                                                
		LET BTHCTRL1$[51,60]=(TOTDR-TOTCR)*100 USING "----------"                                                
		LET BTHCTRL1$[10,20]="1  PAY    1"                              
		LET BTHCTRL1$[21,21]="0"                                        
		if source=612 let bthctrl1$[1,1]="M" ! flag batch as memo                                              
		WRITE #CH_GLBATCH,REC_BTH;BTHCTRL1$; 
		!MAT  WRITE #Ch_Glbatch,rec_bth,1;SEQNUM; 
		WRITE #Ch_Glbatch,rec_bth,1;SEQNUM;

else
	 include "src/callsuberr.inc"! this a remark
end try
end sub ! getglEndRec1

!--------------------------------------------------------------------------------------------------
Sub DelGlBatch()

try
call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(client)+" Not On File"
		goto enddelglbatch
	endif
	call openglmfile()
	if not (returnstatus)
		goto enddelglbatch:
	endif
	call dxget ("acctper",tmp$)
	let acper=0
	if len(tmp$)=5
		let glmo=tmp$[1,2]
		let glyr=tmp$[4,5]
		let work$=glyr using "&&"
		let work$[3]=glmo using "&&"
		let acper=work$
	endif
	call FindAcctPeriod()
	if not(glcurrper)
		let returnstatus=0
		let work$=acper using "&&&&"
		let message$="Accounting Period ",work$[3,4],"/",work$[1,2]," Not Found"
		goto enddelglbatch:
	endif
	Call Dxget("batchid",tmp$)
	let batchid=tmp$
		if batchid<1 or batchid>999
		let returnstatus=0
		let message$="Invalid Batch Id Submitted"
		goto enddelglbatch:	
	endif
	if batchid<>0
		let tmp=acf.DirNum$
		let filename$=str$(tmp)+"/G"+STR$(intco)+groupid$
		let tmp$=clientid using "####"
		for ctr=1 to 4
			if tmp$[ctr,ctr]=" " let tmp$[ctr,ctr]="."
		next ctr
		let filename$=filename$+tmp$
		tmp$=acper using "&&&&"
		let filename$=filename$+tmp$
		let tmp$=batchid using "###"
		for ctr=1 to 3
			if tmp$[ctr,ctr]=" " let tmp$[ctr,ctr]="."
		next ctr
		let filename$=filename$+tmp$
		Call FindF(filename$,fileflag)
		if not (fileflag)
			let returnstatus=0
			let message$="Batch Number",str$(batchid)," Not On File"
			goto enddelglbatch:
		endif
		ch_glbatch= FindChannel() ! need to get a channel #
		open #ch_glbatch,filename$
	endif
		
	! Start reading file transactions
	let rec_bth=chf(ch_glbatch)-1
	if rec_bth<=0   ! set end of record -- never ended properly
		LET totdr=0
		let totcr=0 
		REC_BTH=0
		LET SEQNUM=1 
		call getglendrec1()
		let rec_bth=rec_bth+1            
		call getglendrec2() 
		let rec_bth=chf(ch_glbatch)-1
	ENDIF  
	READ #ch_glbatch,rec_bth;bthctrl1$; 
	!MAT  READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	IF bthctrl1$[10,20]<>"1  PAY    1"
		call getglendrec1()
		let rec_bth=rec_bth+1            
		call getglendrec2() 
		let rec_bth=chf(ch_glbatch)-1
		READ #ch_glbatch,rec_bth;bthctrl1$; 
	ENDIF                      
	IF bthctrl1$[21,21]<>"0" LET bthctrl1$[21,21]="0" ! prev used for mech finanance dealer
	rec_bth=rec_bth-1
	! second to the last record 
	read #ch_glbatch,rec_bth;bthctrl$; 
	!MAT  READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	 READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	IF bthctrl$[1,1]<>"*" IF bthctrl$[63,63]<>"9" 
		LET totdr=0
		let totcr=0 
		REC_BTH=0
		LET SEQNUM=1
		Call getglendrec1()
		read #ch_glbatch,rec_bth;bthctrl$;
	endif
	if bthctrl$[62,62]="U"
		let tmp3=bthctrl$[53,58]
		if tmp3<>rec_uac
			let returnstatus=0
			let message$="Batch "+str$(batchid)+" is Already in Update Process "
			goto enddelglbatch:
		endif
	ENDIF 

        LET TRACKSCRATCH[1]=1  !DELETED BATCH
        !! CALL TRACKGLWRITE()
        Try Close #ch_glbatch Else Rem
	Try
		Kill Filename$
		let returnstatus=1
		let message$="Batch Deleted"
        else
		let returnstatus=0
		let message$="Unable to Delete Batch "+str$(batchid)
	end try
	enddelglbatch: !
	
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
else
	 include "src/callsuberr.inc"! this a remark
end try
end sub ! delglbatch

!--------------------------------------------------------------------------------------------------
Sub subglbatch()

try
call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(client)+" Not On File"
		goto endsubglbatch
	endif
	call openglmfile()
	if not (returnstatus)
		goto endsubglbatch:
	endif
	call dxget ("acctper",tmp$)
	let acper=0
	if len(tmp$)=5
		let glmo=tmp$[1,2]
		let glyr=tmp$[4,5]
		let work$=glyr using "&&"
		let work$[3]=glmo using "&&"
		let acper=work$
	endif
	call FindAcctPeriod()
	if not(glcurrper)
		let returnstatus=0
		let work$=acper using "&&&&"
		let message$="Accounting Period ",work$[3,4],"/",work$[1,2]," Not Found"
		goto endsubglbatch:
	endif
	Call Dxget("batchid",tmp$)
	let batchid=tmp$
	if batchid=0 and tmp$<>"0" let batchid=-1
	if batchid<0 or batchid>999
		let returnstatus=0
		let message$="Invalid Batch Id Submitted"
		goto endsubglbatch:	
	endif
	if batchid<>0
		let tmp=acf.DirNum$
		let filename$=str$(tmp)+"/G"+STR$(intco)+groupid$
		let tmp$=clientid using "####"
		for ctr=1 to 4
			if tmp$[ctr,ctr]=" " let tmp$[ctr,ctr]="."
		next ctr
		let filename$=filename$+tmp$
		tmp$=acper using "&&&&"
		let filename$=filename$+tmp$
		let tmp$=batchid using "###"
		for ctr=1 to 3
			if tmp$[ctr,ctr]=" " let tmp$[ctr,ctr]="."
		next ctr
		let filename$=filename$+tmp$
		Call FindF(filename$,fileflag)
		if not (fileflag)
			let returnstatus=0
			let message$="Batch Number",str$(batchid)," Not On File"
			goto endsubglbatch:
		endif
		ch_glbatch= FindChannel() ! need to get a channel #
		open #ch_glbatch,filename$
		LET SEQNUM=1                         
		LET totdr=0
		let totcr=0
	endif
	! Start reading file transactions
	let rec_bth=chf(ch_glbatch)-1
	if rec_bth<=0   ! set end of record -- never ended properly
		LET totdr=0
		let totcr=0 
		REC_BTH=0
		LET SEQNUM=1 
		call getglendrec1()
		let rec_bth=rec_bth+1            
		call getglendrec2() 
		let rec_bth=chf(ch_glbatch)-1
	ENDIF  
	READ #ch_glbatch,rec_bth;bthctrl1$; 
	!MAT  READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	IF bthctrl1$[10,20]<>"1  PAY    1"
		call getglendrec1()
		let rec_bth=rec_bth+1            
		call getglendrec2() 
		let rec_bth=chf(ch_glbatch)-1
		READ #ch_glbatch,rec_bth;bthctrl1$; 
	ENDIF                      
	IF bthctrl1$[21,21]<>"0" LET bthctrl1$[21,21]="0" ! prev used for mech finanance dealer
	rec_bth=rec_bth-1
	! second to the last record 
	read #ch_glbatch,rec_bth;bthctrl$; 
	!MAT  READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	IF bthctrl$[1,1]<>"*" IF bthctrl$[63,63]<>"9" 
		LET totdr=0
		let totcr=0 
		REC_BTH=0
		LET SEQNUM=1
		Call getglendrec1()
		read #ch_glbatch,rec_bth;bthctrl$;
	endif
	if bthctrl$[62,62]="U"
		let tmp3=bthctrl$[53,58]
		if tmp3<>rec_uac
			let returnstatus=0
			let message$="Batch "+str$(batchid)+" is Already in Update Process "
			goto endsubglbatch:
		endif
	else
		let returnstatus=0
		let message$="Batch "+str$(batchid)+" is not in Update Process "
		goto endsubglbatch:		
	ENDIF 
	Call Dxget("TOTREC",tmp$)                              
	totrec = tmp$    
	If totrec=0
		let tmprec=chf(ch_glbatch)-1
		if tmprec<>1! only have cntrl records 0 & 1
			Message$ = "Invalid Number of Records for Submission"
			ReturnStatus = 0                                     
			Goto endsubglbatch:
		endif
	endif
	If totrec < 0                                         
		Message$ = "Invalid Number of Records for Submission"
		ReturnStatus = 0                                     
		Goto endsubglbatch:                                 
	End If  
	tmprec=chf(ch_glbatch)-3
	if totrec<tmprec
		Call dxsave(0,"tmp/glbatcherr.txt!")
		!need to kill and rebuild batch
		Try Close #ch_glbatch Else Rem
		Try
			Kill Filename$
		else
			Message$ = "Number of Records Submitted less than original file for Submission"
			ReturnStatus = 0                                     
			Goto endsubglbatch:   
		end try
		! now let build the batch
		ch_glbatch= FindChannel() ! need to get a channel #
		let tmp$="<666> files/",filename$
		Build #ch_glbatch,tmp$    
		LET Rec_bth=0                        
		LET bthctrl$=" ",bthctrl$                  
		LET bthctrlamt=0                       
		WRITE #ch_glbatch,rec_bth;bthctrl$ ! format file item 0                  
		WRITE #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
		let tmp$="files/",filename$," <666>"
		Modify tmp$! meme
	End If 
	Try
		CLOSE #ch_glbatch
	else
		let returnstatus=0
		let message$="Error Creating Journal Entries Batch "
		goto endsubglbatch:
	end try
	!tmp$ = "chmod go+rw " + filename$
	tmp$ = "chmod 664 " + filename$
	System tmp$                   
	!EOPEN #ch_glbatch,Filename$ 
	OPEN #ch_glbatch,Filename$
	BTHCTRL$=" ",BTHCTRL$
	BTHCTRL=0
	REC_BTH=0
	LET SEQNUM=1                         
	LET totdr=0
	let totcr=0
	call getglendrec1()
	let rec_bth=rec_bth+1            
	call getglendrec2() 
	let rec_bth=0
	tmprec=chf(ch_glbatch)-1
	LET totdr=0
	let totcr=0 
	LET SEQNUM=1
	rec_bth=0
	tmprec=chf(ch_glbatch)-1
	if totrec>0
		for ctr=1 to totrec
			if rec_bth<=tmprec	
				Read #ch_glbatch,rec_bth;bthdesc$;
				!mat  Read #ch_glbatch,rec_bth,1;bthamt; 
				Read #ch_glbatch,rec_bth,1;bthamt; 
				IF bthdesc$[1,1]="*" or bthdesc$[10,20]="1  PAY    1" 
					let bthdesc$=" ",bthdesc$
				endif	
			else
				let bthdesc$=" ",bthdesc$
			endif
			let bthamt=0			
			Call Dxget("JSCODE" + Str$(ctr),tmp$)
			bthdesc$[1,1]=tmp$+" "
			Call Dxget("REFID" + Str$(ctr),tmp$)
			bthdesc$[14,19]=tmp$+"      "
			Call Dxget("DATE" + Str$(ctr),tmp$)
			if len(tmp$)>6
				xdate$ = formatdate2$(tmp$) ! yymmdd
				let tmp$=xdate$[5,8],xdate$[3,4]
			endif
			bthdesc$[20,25]=tmp$+"      " ! date mmddyy
			Call Dxget("GLACCTID" + Str$(ctr),tmp$)
			let glacctid=tmp$
			let tmp3=tmp$
			bthdesc$[2,2]=" "
			bthdesc$[3,10]=tmp3 using "########"
			bthdesc$[11,13]="   " 
			Call Dxget("DESCRIPTION" + Str$(ctr),tmp$)
			bthdesc$[26,58]=rtrim$(tmp$)+blank$
			Call Dxget("DELFLAG" + Str$(ctr),tmp$)
			bthdesc$[63,63]="0"
			if rtrim$(ucase$(tmp$))="Y" let bthdesc$[63,63]="2"
			if bthdesc$[63,63]<>"2"
				Call Dxget( "DEBITAMT"+ Str$(ctr),tmp$)
				let tmp3=tmp$
				if fra(tmp3*100)<>0
					let returnstatus=0
					let message$="Amount exceeds 2 decimals places"
					goto endsubglbatch:
				endif
				let bthamt=abs(tmp3)
				if not(bthamt)
					Call Dxget("CREDITAMT" + Str$(ctr),tmp$)
					let tmp3=tmp$
					if fra(tmp3*100)<>0
						let returnstatus=0
						let message$="Amount exceeds 2 decimals places"
						goto endsubglbatch:
					endif
					let bthamt=-(abs(tmp3))
				endif
				! check the gl acctid
				clear glm.                                                 
				keyglm$ = " ",keyglm$                                            
				keyglm$[2,9] = glacctid Using "########"                         
				Search #ch_glm,2,1;keyglm$,glmrec,e                              
				If not(e)                                                                            
					Read Record #ch_glm,glmrec;glm.; 
				endif
				if glm.rectype$[1,1]="0"
					if bthamt>0 let totdr=totdr+bthamt
					if bthamt<0 let totcr=totcr-bthamt
				endif
			endif
			BTHDESC$[59,62]=SEQNUM USING "####"
			Write #ch_glbatch,rec_bth;bthdesc$;
			!mat  write #ch_glbatch,rec_bth,1;bthamt; 
			write #ch_glbatch,rec_bth,1;bthamt;
			let rec_bth=rec_bth+1
			LET seqnum=seqnum+1
		next ctr
	endif
	call getglendrec1()
	let rec_bth=rec_bth+1            
	call getglendrec2() 
	let returnstatus=1
	let message$="Batch Submitted"
	endsubglbatch: !
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
else
	 include "src/callsuberr.inc"! this a remark
end try
end sub ! subglbatch

! Standard Journal Emtries -- Batch Number is 0
!--------------------------------------------------------------------------------------------------
Sub GetSTDBatch()

try
	call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(client)+" Not On File"
		goto endgetstdbatch
	endif
	call openglmfile()
	if not (returnstatus)
		goto endgetstdbatch:
	endif
	acper=9999 ! default for standard entries
	batchid=0 ! default for standard entries
	let tmp=acf.DirNum$
	let filename$=str$(tmp)+"/G"+STR$(intco)+groupid$
	let tmp$=clientid using "####"
	for ctr=1 to 4
		if tmp$[ctr,ctr]=" " let tmp$[ctr,ctr]="."
	next ctr
	let filename$=filename$+tmp$
	tmp$="9999" ! acper for standard entries
	let filename$=filename$+tmp$
	let tmp$=batchid using "###"
	for ctr=1 to 3
		if tmp$[ctr,ctr]=" " let tmp$[ctr,ctr]="."
	next ctr
	let filename$=filename$+tmp$
	Call FindF(filename$,fileflag)
	if fileflag<>0
		ch_glbatch= FindChannel() ! need to get a channel #
		open #ch_glbatch,filename$
	else
		ch_glbatch= FindChannel() ! need to get a channel #
		let tmp$="<666> files/",filename$
		Build #ch_glbatch,tmp$    
		LET Rec_bth=0                        
		LET bthctrl$=" ",bthctrl$                  
		LET bthctrlamt=0                       
		WRITE #ch_glbatch,rec_bth;bthctrl$ ! format file item 0                  
		! MAT  WRITE #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
		WRITE #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
		let tmp$="files/",filename$," <666>"
		Modify tmp$
		Try
			CLOSE #ch_glbatch
		else
			let returnstatus=0
			let message$="Error Creating Standard Journal Entries Batch "
			goto endgetstdbatch:
		end try
		! tmp$ = "chmod go+rw " + filename$
		tmp$ = "chmod 664 " + filename$
		System tmp$                   
		!EOPEN #ch_glbatch,Filename$ 
		OPEN #ch_glbatch,Filename$ 
		BTHCTRL$=" ",BTHCTRL$
		BTHCTRL=0
		REC_BTH=0
		LET SEQNUM=1                         
		LET totdr=0
		let totcr=0
		call getglendrec1()
		let rec_bth=rec_bth+1            
		call getglendrec2() 
		let rec_bth=0	
	endif
	! Start reading file transactions
	let rec_bth=chf(ch_glbatch)-1
	if rec_bth<=0   ! set end of record -- never ended properly
		LET totdr=0
		let totcr=0 
		REC_BTH=0
		LET SEQNUM=1 
		call getglendrec1()
		let rec_bth=rec_bth+1            
		call getglendrec2() 
		let rec_bth=chf(ch_glbatch)-1
	ENDIF  
	READ #ch_glbatch,rec_bth;bthctrl1$; 
	! MAT  READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	 READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	IF bthctrl1$[10,20]<>"1  PAY    1"
		call getglendrec1()
		let rec_bth=rec_bth+1            
		call getglendrec2() 
		let rec_bth=chf(ch_glbatch)-1
		READ #ch_glbatch,rec_bth;bthctrl1$; 
	ENDIF                      
	IF bthctrl1$[21,21]<>"0" LET bthctrl1$[21,21]="0" ! prev used for mech finanance dealer
	rec_bth=rec_bth-1
	! second to the last record 
	read #ch_glbatch,rec_bth;bthctrl$; 
	!MAT  READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	 READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	IF bthctrl$[1,1]<>"*" IF bthctrl$[63,63]<>"9" 
		LET totdr=0
		let totcr=0 
		REC_BTH=0
		LET SEQNUM=1
		Call getglendrec1()
		read #ch_glbatch,rec_bth;bthctrl$;
	endif
	if bthctrl$[62,62]="U"
		let tmp3=bthctrl$[53,58]
		if tmp3<>rec_uac
			let returnstatus=0
			let message$="Standard Journal Entry Batch  is Already in Update Process "
			goto endgetstdbatch:
		endif
	ENDIF 
	let bthctrl$[53,58]=rec_uac using "&&&&&&" 
	let bthctrl$[62,62]="U"
	write #ch_glbatch,rec_bth;bthctrl$;
	! MAT  WRITE #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	Write #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	endgetstdbatch: !
	clear list$[]
	List$[0] = bsdel$,"STDBatchDetail",fdel$
	webstr$=""
	webstr$="JSCODE",fdel$
	webstr$=webstr$,"REFID",fdel$
	! webstr$=webstr$,"DATE",fdel$ ! MMDDYY no date for standard entries
	webstr$=webstr$,"GLACCTID",fdel$
	webstr$=webstr$,"GLACCTNAME",fdel$
	webstr$=webstr$,"DESCRIPTION",fdel$
	webstr$=webstr$,"DELFLAG",fdel$
	webstr$=webstr$,"DEBITAMT",fdel$
	webstr$=webstr$,"CREDITAMT",fdel$
	list$[1]=webstr$
	let row=2
	let tmpcnt=maxcnt
	if returnstatus>0
		totrec=chf(ch_glbatch)-1
		LET totdr=0
		let totcr=0 
		LET SEQNUM=1
		for rec_bth=0 to totrec
			read #ch_glbatch,rec_bth;bthdesc$;
			! Mat  READ #ch_glbatch,rec_bth,1;bthamt; 
			 READ #ch_glbatch,rec_bth,1;bthamt; ! format file item 1
			IF bthdesc$[1,1]="*" GOTO getnxtstdrec:              
			IF bthdesc$[10,20]="1  PAY    1" GOTO getnxtstdrec:  
			IF bthdesc$[63,63]<>"2" 
				LET seqnum=seqnum+1
				if bthamt>0 let totdr=totdr+bthamt
				if bthamt<0 let totcr=totcr-bthamt
			endif
			let webstr$=""
			webstr$=bthdesc$[1,1],fdel$ ! jscode$
			webstr$=webstr$,bthdesc$[14,19],fdel$ ! ref num
			! webstr$=webstr$,bthdesc$[20,25],fdel$ ! MMDDYY
			let glacctid=bthdesc$[3,10]
			webstr$=webstr$,str$(glacctid),fdel$                                                 
			keyglm$ = " ",keyglm$                                             
			keyglm$[2,9] = glacctid Using "########"                          
			Search #ch_glm,2,1;keyglm$,glmrec,e                               
			If not(e)
				read record #ch_glm,glmrec;glm.;
			else
				clear glm.
				glm.desc$="Invalid Acct"
			endif
			WebStr$ = WebStr$,RTrim$(glm.Desc$),fdel$
			webstr$=webstr$,rtrim$(bthdesc$[26,58]),fdel$
			let tmp$="N"
			if bthdesc$[63,63]="2" let tmp$="Y"
			webstr$=webstr$,tmp$,fdel$
			if bthamt>=0
				let webstr$=webstr$,str$(bthamt),fdel$ ! (bthamt using "##########.##"),fdel$
				let webstr$=webstr$,"",fdel$
			else
				let webstr$=webstr$,"",fdel$
				let webstr$=webstr$,str$(bthamt*(-1)),fdel$ !  using "##########.##"),fdel$
			endif
			List$[row] = WebStr$                                 
			row = row + 1                                        
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
			getnxtstdrec:! get next record
		next rec_bth
	endif
	List$[row] = esdel$             
	Call AddToStr(e$,rstr$,List$[])
	clear list$[]
	List$[0] = bsdel$,"StdBatchHeader",fdel$
	webstr$="ClientId",fdel$
	!webstr$=webstr$,"AcctPer",fdel$
	!webstr$=webstr$,"BatchId",fdel$
	webstr$=webstr$,"CheckBal",fdel$
	webstr$=webstr$,"DebitBal",fdel$
	webstr$=webstr$,"CreditBal",fdel$
	list$[1]=webstr$
	let row=2
	if returnstatus>0
		webstr$=(clientid using "####"),fdel$
		!let tmp$=acper using "&&&&"
		!let webstr$=webstr$,tmp$[3,4],"/",tmp$[1,2],fdel$ ! mm/yy format
		!webstr$=webstr$,(batchid using "###"),fdel$
		webstr$=webstr$,str$(totdr-totcr),fdel$ !  using "------------.##"),fdel$
		webstr$=webstr$,str$(totdr),fdel$ !  using "------------.##"),fdel$
		webstr$=webstr$,str$(totcr),fdel$ !  using "------------.##"),fdel$
		list$[row]=webstr$
		let row=row+1
	endif
	list$[row]=esdel$
	Call AddToStr(e$,rstr$,List$[])
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
else
	 include "src/callsuberr.inc"! this a remark
end try
end sub ! getstdbatch

!--------------------------------------------------------------------------------------------------
Sub DelSTDBatch()

try
call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(client)+" Not On File"
		goto enddelstdbatch
	endif
	call openglmfile()
	if not (returnstatus)
		goto enddelstdbatch:
	endif
	acper=9999
	batchid=0
	
	let tmp=acf.DirNum$
	let filename$=str$(tmp)+"/G"+STR$(intco)+groupid$
	let tmp$=clientid using "####"
	for ctr=1 to 4
		if tmp$[ctr,ctr]=" " let tmp$[ctr,ctr]="."
	next ctr
	let filename$=filename$+tmp$
	tmp$="9999" ! acper using "&&&&"
	let filename$=filename$+tmp$
	let tmp$=batchid using "###"
	for ctr=1 to 3
		if tmp$[ctr,ctr]=" " let tmp$[ctr,ctr]="."
	next ctr
	let filename$=filename$+tmp$
	Call FindF(filename$,fileflag)
	if not (fileflag)
		let returnstatus=0
		let message$="Standard Journal Entries Batch  Not On File"
		goto enddelstdbatch:
	endif
	ch_glbatch= FindChannel() ! need to get a channel #
	open #ch_glbatch,filename$
			
	! Start reading file transactions
	let rec_bth=chf(ch_glbatch)-1
	if rec_bth<=0   ! set end of record -- never ended properly
		LET totdr=0
		let totcr=0 
		REC_BTH=0
		LET SEQNUM=1 
		call getglendrec1()
		let rec_bth=rec_bth+1            
		call getglendrec2() 
		let rec_bth=chf(ch_glbatch)-1
	ENDIF  
	READ #ch_glbatch,rec_bth;bthctrl1$; 
	!MAT  READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	IF bthctrl1$[10,20]<>"1  PAY    1"
		call getglendrec1()
		let rec_bth=rec_bth+1            
		call getglendrec2() 
		let rec_bth=chf(ch_glbatch)-1
		READ #ch_glbatch,rec_bth;bthctrl1$; 
	ENDIF                      
	IF bthctrl1$[21,21]<>"0" LET bthctrl1$[21,21]="0" ! prev used for mech finanance dealer
	rec_bth=rec_bth-1
	! second to the last record 
	read #ch_glbatch,rec_bth;bthctrl$; 
	!MAT  READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	 READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	IF bthctrl$[1,1]<>"*" IF bthctrl$[63,63]<>"9" 
		LET totdr=0
		let totcr=0 
		REC_BTH=0
		LET SEQNUM=1
		Call getglendrec1()
		read #ch_glbatch,rec_bth;bthctrl$;
	endif
	if bthctrl$[62,62]="U"
		let tmp3=bthctrl$[53,58]
		if tmp3<>rec_uac
			let returnstatus=0
			let message$="Standard Journal Entry Batch is Already in Update Process "
			goto enddelstdbatch:
		endif
	ENDIF 
	Try Close #ch_glbatch Else Rem
	Try
		Kill Filename$
		let returnstatus=1
		let message$="Standard Journal Entry Batch Deleted"
	else
		let returnstatus=0
		let message$="Unable to Delete Standard Journal Entry Batch "
	end try
	enddelstdbatch: !
	
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
else
	 include "src/callsuberr.inc"! this a remark
end try
end sub ! delstdbatch

!--------------------------------------------------------------------------------------------------
Sub SubSTDBatch()

try
call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(client)+" Not On File"
		goto endSubstdbatch
	endif
	call openglmfile()
	if not (returnstatus)
		goto endSubstdbatch:
	endif
	Call Dxget("TOTREC",tmp$)                              
	totrec = tmp$    
	If totrec<=0
		Message$ = "Invalid Number of Records for Submission"
		ReturnStatus = 0                                     
		Goto endSubstdbatch:
	endif
	acper=9999
	batchdid=0
	let tmp=acf.DirNum$
	let filename$=str$(tmp)+"/G"+STR$(intco)+groupid$
	let tmp$=clientid using "####"
	for ctr=1 to 4
		if tmp$[ctr,ctr]=" " let tmp$[ctr,ctr]="."
	next ctr
	let filename$=filename$+tmp$
	tmp$="9999" ! acper using "&&&&"
	let filename$=filename$+tmp$
	let tmp$=batchid using "###"
	for ctr=1 to 3
		if tmp$[ctr,ctr]=" " let tmp$[ctr,ctr]="."
	next ctr
	let filename$=filename$+tmp$
	Call FindF(filename$,fileflag)
	if not (fileflag)
		let returnstatus=0
		let message$="Standard Journal Entry Batch Number Not On File"
		goto endSubstdbatch:
	endif
	ch_glbatch= FindChannel() ! need to get a channel #
	open #ch_glbatch,filename$
	LET SEQNUM=1                         
	LET totdr=0
	let totcr=0
	! Start reading file transactions
	let rec_bth=chf(ch_glbatch)-1
	if rec_bth> 0 ! ended properly
		READ #ch_glbatch,rec_bth;bthctrl1$; 
		READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
		IF bthctrl1$[10,20]<>"1  PAY    1"
			call getglendrec1()
			let rec_bth=rec_bth+1            
			call getglendrec2() 
			let rec_bth=chf(ch_glbatch)-1
			READ #ch_glbatch,rec_bth;bthctrl1$; 
		ENDIF                      
		IF bthctrl1$[21,21]<>"0" LET bthctrl1$[21,21]="0" ! prev used for mech finanance dealer
		rec_bth=rec_bth-1
		! second to the last record 
		read #ch_glbatch,rec_bth;bthctrl$; 
		!MAT  READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
		READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
		IF bthctrl$[1,1]<>"*" IF bthctrl$[63,63]<>"9" 
			LET totdr=0
			let totcr=0 
			REC_BTH=0
			LET SEQNUM=1
			Call getglendrec1()
			read #ch_glbatch,rec_bth;bthctrl$;
		endif
		if bthctrl$[62,62]="U"
			let tmp3=bthctrl$[53,58]
			if tmp3<>rec_uac
				let returnstatus=0
				let message$="Standard Journal Entry Batch is Already in Update Process "
				goto endSubstdbatch:
			endif
		else
			let returnstatus=0
			let message$="Standard Journal Entry is not in Update Process "
			goto endSubstdbatch:		
		ENDIF 
	Endif
	! kill off old standard je batch
	Try Close #ch_glbatch Else Rem
	Try
		Kill Filename$
	else
		let returnstatus=0
		let message$="Error in Recreating Standard Journal Entry Batch "
	end try
	! create new standard je batch
	let tmp$="<666> files/",filename$
	Build #ch_glbatch,tmp$    
	LET Rec_bth=0                        
	LET bthctrl$=" ",bthctrl$                  
	LET bthctrlamt=0                       
	WRITE #ch_glbatch,rec_bth;bthctrl$ ! format file item 0                  
	! MAT  WRITE #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	WRITE #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	let tmp$="files/",filename$," <666>"
		Modify tmp$
	Try
		CLOSE #ch_glbatch
	else
		let returnstatus=0
		let message$="Error Creating Standard Journal Entries Batch "
		goto endsubstdbatch:
	end try
	!tmp$ = "chmod go+rw " + filename$
	tmp$ = "chmod 664 " + filename$
	System tmp$                   
	!EOPEN #ch_glbatch,Filename$ 
	OPEN #ch_glbatch,Filename$ 
	BTHCTRL$=" ",BTHCTRL$
	BTHCTRL=0
	REC_BTH=0
	LET SEQNUM=1                         
	LET totdr=0
	let totcr=0
	call getglendrec1()
	let rec_bth=rec_bth+1            
	call getglendrec2() 
	let rec_bth=0
	tmprec=chf(ch_glbatch)-1
	if totrec>0
		for ctr=1 to totrec
			if rec_bth<=tmprec	
				Read #ch_glbatch,rec_bth;bthdesc$;
				!mat  Read #ch_glbatch,rec_bth,1;bthamt; 
				Read #ch_glbatch,rec_bth,1;bthamt; 
				IF bthdesc$[1,1]="*" or bthdesc$[10,20]="1  PAY    1" 
					let bthdesc$=" ",bthdesc$
				endif	
			else
				let bthdesc$=" ",bthdesc$
			endif
			let bthamt=0			
			Call Dxget("JSCODE" + Str$(ctr),tmp$)
			bthdesc$[1,1]=tmp$+" "
			Call Dxget("REFID" + Str$(ctr),tmp$)
			bthdesc$[14,19]=tmp$+"      "
			Call Dxget("GLACCTID" + Str$(ctr),tmp$)
			let tmp3=tmp$
			bthdesc$[3,10]=tmp3 using "########"
			Call Dxget("DESCRIPTION" + Str$(ctr),tmp$)
			bthdesc$[26,58]=rtrim$(tmp$)+blank$
			Call Dxget("DELFLAG" + Str$(ctr),tmp$)
			bthdesc$[63,63]="0"
			if rtrim$(ucase$(tmp$))="Y"  goto getnexttotrec: ! let bthdesc$[63,63]="2"
			if bthdesc$[63,63]<>"2"
				Call Dxget( "DEBITAMT"+ Str$(ctr),tmp$)
				let tmp3=tmp$
				if fra(tmp3*100)<>0
					let returnstatus=0
					let message$="Amount exceeds 2 decimals places"
					goto endsubstdbatch:
				endif
				let bthamt=abs(tmp3)
				if not(bthamt)
					Call Dxget("CREDITAMT" + Str$(ctr),tmp$)
					let tmp3=tmp$
					if fra(tmp3*100)<>0
						let returnstatus=0
						let message$="Amount exceeds 2 decimals places"
						goto endsubstdbatch:
					endif
					let bthamt=-(abs(tmp3))
				endif
				if bthamt>0 let totdr=totdr+bthamt
				if bthamt<0 let totcr=totcr-bthamt
			endif
			BTHDESC$[59,62]=SEQNUM USING "####"
			Write #ch_glbatch,rec_bth;bthdesc$;
			!mat  write #ch_glbatch,rec_bth,1;bthamt; 
			write #ch_glbatch,rec_bth,1;bthamt;
			let rec_bth=rec_bth+1
			LET seqnum=seqnum+1
			getnexttotrec: ! get next record
		next ctr
	endif
	call getglendrec1()
	let rec_bth=rec_bth+1            
	call getglendrec2() 
	let returnstatus=1
	let message$="Standard Journal Entries Batch Submitted"
	endSubstdbatch: !
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
else
	 include "src/callsuberr.inc"! this a remark
end try
end sub ! Substdbatch
!--------------------------------------------------------------------------------------------------
Sub SubBudBatch()

try
call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(client)+" Not On File"
		goto endsubbudbatch:
	endif
	call openglmfile()
	if not (returnstatus)
		goto endsubbudbatch:
	endif
	call dxget ("acctper",tmp$)
	let acper=0
	if len(tmp$)=5
		let glmo=tmp$[1,2]
		let glyr=tmp$[4,5]
		let work$=glyr using "&&"
		let work$[3]=glmo using "&&"
		let acper=work$
	endif
	let cacper=acper ! set to current accounting period
	call FindAcctPeriod()
	if not(glcurrper)
		let returnstatus=0
		let work$=acper using "&&&&"
		let message$="Accounting Period ",work$[3,4],"/",work$[1,2]," Not Found"
		goto endsubbudbatch:
	endif
	Call Dxget("batchid",tmp$)
	let batchid=tmp$
	if batchid=0 let batchid=-1
	if batchid<0 or batchid>999
		let returnstatus=0
		let message$="Invalid Batch Id Submitted"
		goto endsubbudbatch:	
	endif
	if batchid<>0
		let tmp=acf.DirNum$
		let filename$=str$(tmp)+"/G"+STR$(intco)+groupid$
		let tmp$=clientid using "####"
		for ctr=1 to 4
			if tmp$[ctr,ctr]=" " let tmp$[ctr,ctr]="."
		next ctr
		let filename$=filename$+tmp$
		tmp$=cacper using "&&&&"
		let filename$=filename$+tmp$
		let tmp$=batchid using "###"
		for ctr=1 to 3
			if tmp$[ctr,ctr]=" " let tmp$[ctr,ctr]="."
		next ctr
		let filename$=filename$+tmp$
		Call FindF(filename$,fileflag)
		if not (fileflag)
			let returnstatus=0
			let message$="Batch Number",str$(batchid)," Not On File"
			goto endsubbudbatch:
		endif
		ch_glbatch= FindChannel() ! need to get a channel #
		open #ch_glbatch,filename$
		LET SEQNUM=1                         
		LET totdr=0
		let totcr=0
	endif
	! Start reading file transactions
	let rec_bth=chf(ch_glbatch)-1
	if rec_bth<=0   ! set end of record -- never ended properly
		LET totdr=0
		let totcr=0 
		REC_BTH=0
		LET SEQNUM=1 
		call getglendrec1()
		let rec_bth=rec_bth+1            
		call getglendrec2() 
		let rec_bth=chf(ch_glbatch)-1
	ENDIF  
	READ #ch_glbatch,rec_bth;bthctrl1$; 
	!MAT  READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	IF bthctrl1$[10,20]<>"1  PAY    1"
		call getglendrec1()
		let rec_bth=rec_bth+1            
		call getglendrec2() 
		let rec_bth=chf(ch_glbatch)-1
		READ #ch_glbatch,rec_bth;bthctrl1$; 
	ENDIF                      
	IF bthctrl1$[21,21]<>"0" LET bthctrl1$[21,21]="0" ! prev used for mech finanance dealer
	rec_bth=rec_bth-1
	! second to the last record 
	read #ch_glbatch,rec_bth;bthctrl$; 
	!MAT  READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	IF bthctrl$[1,1]<>"*" IF bthctrl$[63,63]<>"9" 
		LET totdr=0
		let totcr=0 
		REC_BTH=0
		LET SEQNUM=1
		Call getglendrec1()
		read #ch_glbatch,rec_bth;bthctrl$;
	endif
	if bthctrl$[62,62]="U"
		let tmp3=bthctrl$[53,58]
		if tmp3<>rec_uac
			let returnstatus=0
			let message$="Batch "+str$(batchid)+" is Already in Update Process "
			goto endsubbudbatch:
		endif
	endif
	call dxget ("sacctper",tmp$)
	let sacper=0
	if len(tmp$)=5
		let glmo=tmp$[1,2]
		let glyr=tmp$[4,5]
		let work$=glyr using "&&"
		let work$[3]=glmo using "&&"
		let sacper=work$
	endif
	let acper=sacper ! set ac per to starting acper
	call FindAcctPeriod()
	if not(glcurrper)
		let returnstatus=0
		let work$=sacper using "&&&&"
		let message$="Starting Accounting Period ",work$[3,4],"/",work$[1,2]," Not Found"
		goto endsubbudbatch:
	endif
	call dxget ("eacctper",tmp$)
	let eacper=0
	if len(tmp$)=5
		let glmo=tmp$[1,2]
		let glyr=tmp$[4,5]
		let work$=glyr using "&&"
		let work$[3]=glmo using "&&"
		let eacper=work$
	endif
	let acper=eacper ! set ac per to starting acper
	call FindAcctPeriod()
	if not(glcurrper)
		let returnstatus=0
		let work$=eacper using "&&&&"
		let message$="Ending Accounting Period ",work$[3,4],"/",work$[1,2]," Not Found"
		goto endsubbudbatch:
	endif
	if sacper>eacper
		let returnstatus=0
		let work$=acper using "&&&&"
		let message$="Ending Accounting Period must be greater than Starting"
		goto endsubbudbatch:
	endif
	Try Close #ch_glbatch Else Rem
	OPEN #ch_glbatch,Filename$ 
	let rec_bth=chf(ch_glbatch)-1
	readglbudbatch: ! set as budget
	if rec_bth<=0   ! set end of record -- never ended properly
		let returnstatus=0
		let message$="Unable to Update as Budget. Batch Cntrl Record Missing "
		goto endsubbudbatch:
	ENDIF  
	READ #ch_glbatch,rec_bth;bthctrl1$; 
	!MAT  READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
	IF bthctrl1$[10,20]="1  PAY    1"
		Let bthctrl1$[1,1]="B"
		Let bthctrl1$[2,5]=sacper using "&&&&"
		Let bthctrl1$[6,9]=eacper using "&&&&"
		Write #ch_glbatch,rec_bth;bthctrl1$; 
		!MAT  READ #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
		Write #ch_glbatch,rec_bth,1;bthctrlamt ! format file item 1
		let returnstatus=1
		let message$="Batch Submitted as Budget"
		goto endsubbudbatch:
	ENDIF                      
	rec_bth=rec_bth-1
	goto readglbudbatch:	
	endsubbudbatch: !
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
else
	 include "src/callsuberr.inc"! this a remark
end try
end sub ! subbudbatch




!--------------------------------------------------------------------------------------------------
Sub GetBatchList()

try
	DIM R0$[50],CMD$[100]
	clear list$[]
	TMPCNT=MAXCNT
	webstr$=""
	Clear list$[]
	List$[0]=bsdel$,"GLBatchList",fdel$
	Webstr$="AcctPer",fdel$
	Webstr$=webstr$,"BatchId",fdel$
	List$[1]=webstr$
	row=2
	call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(client)+" Not On File"
		goto endgetbatchlist:
	endif
	call openglmfile()
	if not (returnstatus)
		goto endgetbatchlist:
	endif
	call dxget ("acctper",tmp$)
	let acper=0
	if tmp$<>"" and tmp$<>"0"
		if len(tmp$)=5
			let glmo=tmp$[1,2]
			let glyr=tmp$[4,5]
			let work$=glyr using "&&"
			let work$[3]=glmo using "&&"
			let cacper=work$
		endif
		let acper=cacper ! set to current accounting period
		call FindAcctPeriod()
		if not(glcurrper)
			let returnstatus=0
			let work$=acper using "&&&&"
			let message$="Accounting Period ",work$[3,4],"/",work$[1,2]," Not Found"
			goto endgetbatchlist:
		endif
	endif
	! Call dxsave(0,"/x1/xslspro/md.txt!") !\ ! Stop 
	Filename$ = rec_uac Using "/tmp/blinq&&&&&&"
	let tmp=acf.DirNum$
	let tmp$=clientid using "####"
	for ctr=1 to 4
		if tmp$[ctr,ctr]=" " let tmp$[ctr,ctr]="."
	next ctr
	!let filename$=filename$+tmp$
	let work$= "files/",str$(tmp),"/G",str$(intco)+groupid$+tmp$
	if acper<>0
		let tmp$=acper using "&&&&"
		let work$=work$+tmp$
	endif
	cmd$ = "ls ",work$,"* >",filename$," 2>/dev/null"
	Call String(2,cmd$)
	System cmd$
	cmd$ = " ",cmd$
	cmd$ = "chmod 666 ",filename$," 2>/dev/null"
	System cmd$
	Call FindF(filename$,A9) 
	if not(a9) goto endGETbatchlist: ! not batch
	! need a channel #
	chnl=findchannel()
	Open #chnl,filename$
	NxtTmpFile: ! read for next tmp file
	Read #chnl;R0$;
	If R0$ = "" goto endGETbatchlist:
	
	if acper<>0
		let acctper=r0$[16,19]
		if acctper<>acper goto nxttmpfile: 
	else
		let acctper=r0$[16,19]	
	endif
	batchid=0
	let r0$[23,23]=""
	If R0$[20,20] <> "." 
		Let batchid = R0$[20,22] 
	else
		If R0$[21,21] <> "." 
			Let batchid = R0$[21,22]
		else
			let batchid=r0$[22,22]
		endif
	endif
	if batchid=0 goto nxttmpfile:
	let webstr$=""
	let tmp$=acctper using "&&&&"
	let webstr$=tmp$[3,4],"/",tmp$[1,2],fdel$
	let webstr$=webstr$+(batchid using "###"),fdel$
	list$[row]=webstr$
	let row=row+1
	If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])   
	goto nxttmpfile: !

	endgetbatchlist: ! 
	let list$[row]=esdel$
	Call AddToStr(e$,rstr$,List$[])
	! section 2 - status/error section                     
	Call CreateNetStatus(e$,returnstatus,message$,webstr$) 
	Call AddToStr(e$,rstr$,webstr$)                        
	Filename$ = rec_uac Using "/tmp/blinq&&&&&&"
	Try
		Kill Filename$
	Else
		Rem
	End Try

else
	 include "src/callsuberr.inc"! this a remark
end try
end sub ! getbatchlist

! ---------------
Sub OpenGlbFile() 
! should already have clientid and company
	
try
	let tmp=acf.DirNum$
	let filename$=str$(tmp)+"/GLB"+STR$(intco)+groupid$
	let tmp$=clientid using "####"
	for ctr=1 to 4
		if tmp$[ctr,ctr]=" " let tmp$[ctr,ctr]="."
	next ctr
	let filename$=filename$+tmp$
	Call FindF(filename$,fileflag)
	if not (fileflag)
		let returnstatus=0
		let message$="G/L Budget File for Client ",str$(clientid)," Not Found"
	else
		ch_glm= FindChannel() ! need to get a channel #
		open #ch_glm,filename$
		let keyglm$=" ",keyglm$
		search #ch_glm,2,1;keyglm$,glmrec,e
		if e<>0
			let returnstatus=0
			let message$="G/L Budget File Control Record for Client ",str$(clientid)," Not Found"	
		else
			read record #ch_glm,glmrec;glm.;
		endif
	endif

else
	! this is a remark
end try
end sub ! openglb   
!-------------------------------------
!=========================================================================================================
Sub Start643process()! startReport
 Try
	ReturnStatus=1
	Message$="OK"
	Call Dxget("TOTREC",tmp$)
	let totrec=tmp$
	if custom_customer$="JACKSON"
		if totrec>1
			returnstatus=0
			message$="Invalid Clients to Consolidate"
			goto end643process:
		endif
	else
		if totrec<=1
			let returnstatus=0
			message$="Invalid Number of Clients to Consolidate"
			goto end643process:
		endif
	endif
	Call Dxget("FILETYPE",tmp$)
	let filetype=0
	let work$=UCASE$(RTRIM$(TMP$))
	if work$="M" let filetype=1 ! master file only
	if work$="B" let filetype=2 ! budget file only
	if work$="A" let filetype=3 ! all types budget and master file
	if filetype=0
		returnstatus=0
		message$="Invalid File Types Submitted for Consolidation"
		goto end643process:
	endif
	clear spec1[]
	spec1[0]=intco ! company #
	spec1[1]=filetype! 1= g/l master , 2= g/l budget, 3= both
	spec1[2]=totrec ! total clients to process
	spec1[8]=rec_uac
	spec1[9]=returnstatus
	message$=""
	Call "gl643.dl4",SPEC1[],MESSAGE$,rstr$
	LET returnstatus=spec1[9]
	end643process: ! 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! Start643Process

!=========================================================================================================
Sub Start642process()! startReport
 Try
	ReturnStatus=1
	Message$="OK"
	
	Call Dxget("FILETYPE",tmp$)
	let filetype=0
	let work$=UCASE$(RTRIM$(TMP$))
	if work$="M" let filetype=1 ! master file only
	if work$="B" let filetype=2 ! budget file only
	if work$="A" let filetype=3 ! all types budget and master file
	if filetype=0
		returnstatus=0
		message$="Invalid File Types Submitted for Shifting Balances"
		goto end642process:
	endif
	let shifttype=0
	if filetype>1 and filetype<4 ! for budget
		Call Dxget("SHIFTTYPE",tmp$) ! 1 - date only , 2= date/data
		let shifttype=tmp$
		if shifttype<1 or shifttype>2
			returnstatus=0
			message$="Invalid File Types Submitted for Shifting Balances"
			goto end642process:
		endif
	endif
	clear spec1[]
	spec1[0]=intco ! company #
	spec1[1]=filetype! 1= g/l master , 2= g/l budget, 3= both
	spec1[2]=shiftype ! 1 - date only , 2= date/data
	spec1[6]=0 ! client
	spec1[7]=0 ! accounting period
	spec1[8]=rec_uac
	spec1[9]=returnstatus
	message$=""
	Call "gl642.dl4",SPEC1[],MESSAGE$,rstr$
	LET returnstatus=spec1[9]
	Call dxget("clientid",tmp$) 
	client = tmp$   
	end642process: ! 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	if returnstatus<>1 goto endshift: ! no error
	if spec1[7]=0 goto endshift:
	if spec1[1]=2 goto endshift: ! budget only
	if spec1[1]<1 or spec1[1]>3 goto endshift:! shift date and data only
	if not(spec1[6]) goto endshift:
	if client<1 or client>9999 goto endshift:
	spec1[0]=intco ! company #
	let tmp$=spec1[7] using "&&&&"
	let tmp3=tmp$[1,2]
	let tmp3=tmp3-8 ! purge 8 year detail back
	if tmp3<0 let tmp3=100+tmp3
	let tmp$[1,2]=tmp3 using "&&"
	let purgper=tmp$[1,4]
	spec1[1]=purgper ! yymm
	spec1[2]=0 ! starting account #
	spec1[3]=99999999 ! ending account #
	spec1[4]=0
	spec1[5]=client
	spec1[6]=0 ! 
	spec1[7]=0 ! accounting period
	spec1[8]=rec_uac
	spec1[9]=returnstatus
	spec1[10]=0
	message$=""
	Call "gldetlpurge.dl4",SPEC1[],MESSAGE$,rstr$
	endshift: ! end shift data
else
    include "src/callsuberr.inc"
end try
end sub ! Start642Process


!=========================================================================================================
Sub Start641process()! startReport
 Try
	ReturnStatus=1
	Message$="OK"
	clear spec1[]
	spec1[0]=intco ! company #
	spec1[8]=rec_uac
	spec1[9]=returnstatus
	message$=""
	call dxsave(0,"tmp/gl641.txt!")
	Call "gl641.dl4",SPEC1[],MESSAGE$,rstr$
	LET returnstatus=spec1[9]
	end641process: ! 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! Start641Process

!!==============================================================================
!! track any g/l batches touched by g/l batch entry/edit, etc
Sub TRACKGLWRITE() !! UPDATE AUDIT TRACK OF G/L BATCHES CHG/ADD/DEL-WMB 4/2004
try
 LET TRACK$=" ",TRACK$
 LET TRACKB$=" ",TRACKB$
 LET TRACKC$=" ",TRACKC$
 LET TRACKD$=" ",TRACKD$
 LET TRACKFILENAME$=" ",TRACKFILENAME$
 LET TRACKSCRIPT$=" ",TRACKSCRIPT$
 IF FILENAME$[2,2]="/"
     LET TRACKB$[1,7]=FILENAME$[10,16] 
 ELSE
     TRACKB$[1,4] = ACPER USING "####"   !ACCOUNTING PERIOD
     TRACKB$[5,7] = BATCHID USING "###"  !BATCH #
 ENDIF
 IF TRACKSCRATCH[2]<>2 
     READ #ch_glbatch,0;TRACKC$;
 ENDIF
 LET TRACKD$=MSC$(3)
 LET TRACKNAME$=" ",TRACKNAME$
 LET TRACKNAME$="??????       "
 LET TRACKNAME$[1,8]=USERID$[1,8]
 !! REM -------------------------------
 LET TRACK$[2,4]=TRACKB$[5,7]
 LET TRACK$[6,9]=TRACKB$[1,4]
 LET TRACK$[11,14]=SPC(6) USING "####"
 LET TRACK$[16,37]=TRACKD$[1,22]
 LET TRACKSCRATCH=0
 LET TRACKSCRATCH=CHF(ch_glbatch)
 IF TRACKSCRATCH<0 LET TRACKSCRATCH=0
 LET TRACK$[39,44]=TRACKSCRATCH USING "######"
 IF TRACKSCRATCH[1]=1 LET TRACK$[46,51]="DELETE"
 LET TRACK$[53,57]="?????"
 IF TRACKSCRATCH[2]=1 LET TRACK$[53,57]="EXIST"
 IF TRACKSCRATCH[2]=2 LET TRACK$[53,57]="NEW  "
 LET TRACK$[59,59]=TRACKC$[1,1]
 !! LET TRACK$[61,65]=UREC USING "----#"
 LET TRACK$[67,74]=TRACKNAME$[1,8]
 LET TRACKFILENAME$=" ",TRACKFILENAME$
 LET TRACKFILENAME$[1,16]="tmp/glbatchaudit"
 LET TRACKFILENAME$[17,20]=TRACKD$[9,12]
 IF INTC0<10 LET TRACKFILENAME$[21,21]=INTCO USING "#"
 LET TRACKFILENAME$[22]=""
 !! REM --------APPEND TO AUDIT FILE
 LET TRACKSCRIPT$="echo '"+TRACK$+"' >> "+TRACKFILENAME$
 SYSTEM TRACKSCRIPT$
 LET TRACKSCRATCH[0]=0
 LET TRACKSCRATCH[1]=0
 LET TRACKSCRATCH[2]=0
else
	! this is a remark
end try
end sub ! TRACKGLWRITE

!!==============================================================================
!! 605 - GET STATTYPE
!=========================================================================================================
Sub GetStatType()! 605 - get statement type
Try
	returnstatus=1
	message$="OK"
	Try                                
		ch_glst = OpenFile(-192,intco)   
	Else                               
		let returnstatus=0
		let message$="General Statement Type File Not Found" 
		goto endgetstattype:
	End Try
	call dxget ("TYPEID",tmp$)
	let Work$=ucase$(rtrim$(tmp$))
	if work$="" or Len(work$)>10
		let returnstatus=0
		let message$="Invalid Statement Type Submitted" 
		goto endgetstattype:
	endif
	let work$=work$+blank$
	LET keyglst$=" ",keyglst$ \ LET keyglst$[1,10]=work$ 
	SEARCH #CH_glst,2,1;keyglst$,REC_glst,E
	IF E<>0
		if e=1 ! 
			let newrecord=99
			clear glst.
			glst.StatementCode$=work$
			glst.ReportType$="I"
			if work$[1,1]="A" or work$[1,1]="L" or work$[1,1]="C"
				glst.ReportType$="I"
			endif
			glst.ReverseSign$="N"
			if work$[1,1]="L" or work$[1,1]="C"
				glst.ReverseSign$="N"
			endif
			glst.BaseAcct$="N"   
		else
			let returnstatus=0
			let message$="Search Error "+str$(e)+ "Looking for Statement Type "+keyglst$
			goto endgetstattype:
		endif
	else
		read record #ch_glst,rec_glst;glst.;
	endif
	endgetstattype: ! end getting budget
	! section 1 - send over info
	clear list$[]
	List$[0]=bsdel$,"Statement Type",fdel$
	Webstr$="TYPEID",fdel$
	Webstr$=Webstr$,"StartDesc",fdel$
	Webstr$=webstr$,"EndDesc",fdel$
	Webstr$=webstr$,"ReportType",fdel$
	Webstr$=webstr$,"ReverseSign",fdel$
	Webstr$=webstr$,"BasePctAcct",fdel$
	Webstr$=webstr$,"NewRecord",fdel$
	list$[1]=webstr$
	row=2
	if returnstatus>0
		webstr$=glst.StatementCode$,fdel$
		webstr$=webstr$,glst.StartingDescription$,fdel$
		webstr$=webstr$,glst.EndingDescription$,fdel$
		webstr$=webstr$,glst.ReportType$,fdel$
		webstr$=webstr$,glst.ReverseSign$,fdel$
		webstr$=webstr$,glst.BaseAcct$,fdel$
		let tmp$="N"
		if newrecord<>0 let tmp$="Y"
		webstr$=webstr$,tmp$,fdel$
		list$[ROW]=webstr$
		row=row+1
	endif
	LIST$[ROW]=ESDEL$
	call AddToStr(e$,rstr$,List$[])
	! section status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
        ! call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub

!=========================================================================================================
Sub SubStatType()! 605 - submit statement type
Try
	returnstatus=1
	message$="OK"
	Try                                
		ch_glst = OpenFile(192,intco)   
	Else                               
		let returnstatus=0
		let message$="General Ledger Statement Type File Not Found" 
		goto endsubstattype:
	End Try
	call dxget ("TYPEID",tmp$)
	let Work$=ucase$(rtrim$(tmp$))
	if work$="" or Len(work$)>10
		let returnstatus=0
		let message$="Invalid Statement Type Submitted" 
		goto endsubstattype:
	endif
	let work$=work$+blank$
	glst.StatementCode$=work$
	LET keyglst$=" ",keyglst$ \ LET keyglst$[1,10]=work$ 
	SEARCH #CH_glst,2,1;keyglst$,REC_glst,E                    
	IF not(e)
		read record #ch_glst,rec_glst;glst.;
		Call dxget("DELETEFLAG",tmp$)
		if Ucase$(rtrim$(tmp$))="Y"
			search #ch_glst,5,1;keyglst$,rec_glst,e
			if e<>0                                                               
				returnstatus = 0                                                        
				message$ = "Error Deleting Key for Statement Type " + rtrim$(glst.StatementCode$)       
				Goto endsubstattype:
			endif                                                                   
			e = 3 \ Search #ch_glst,1,0;keyglst$,rec_glst,e                              
			If e <> 0                                                                 
				returnstatus = 0                                                        
				message$ = "Search Error " + Str$(e) + " Deleting Record for Statement Type "+rtrim$(glst.StatementCode$)                                                            
			endif                                                   
			message$ = "Statement Type " + rtrim$(glst.StatementCode$) + " Deleted "
			goto endsubstattype:
		endif
	else
		if e=1 ! new record
			Call dxget("DELETEFLAG",tmp$)
			if Ucase$(rtrim$(tmp$))="Y"
				message$ = "Statement Type " + rtrim$(glst.StatementCode$) + " Deleted "
				goto endsubstattype:
			endif
			Call dxget("NEWRECORD",tmp$)
			if Ucase$(rtrim$(tmp$))="Y"
				let newrecord=99
				work$=glst.StatementCode$
				clear glst.
				let glst.StatementCode$=work$
				let rec_glst=-1
			else
				message$="Statement Type " + rtrim$(glst.StatementCode$) + " Not on File "
				goto endsubstattype:
			endif
                                   
		else
			returnstatus = 0                                                        
			message$ = "Search Error " + Str$(e) + " In Searching for Statement Type "+rtrim$(glst.StatementCode$)
			goto endsubstattype:
		endif
	endif
	Call dxget("STARTDESC",tmp$)
	glst.StartingDescription$=tmp$+blank$
	Call dxget("ENDDESC",tmp$)
	glst.EndingDescription$=tmp$+blank$
	Call dxget("REPORTTYPE",tmp$)
	let work$=ucase$(rtrim$(tmp$))
	if work$="B" or  work$="I"
		! ok 
	else
		returnstatus=0
		message$="Invalid Report Type Submitted for Statement Type " + rtrim$(work$)
		goto endsubstattype:
	endif
	let glst.ReportType$=work$
	Call dxget("REVERSESIGN",tmp$)
	let work$=ucase$(rtrim$(tmp$))
	if work$<>"Y" and work$<>"N"
		returnstatus=0
		message$="Invalid Reverse Sign Submitted for Statement Type " + rtrim$(glst.StatementCode$)
		goto endsubstattype:
	endif
	glst.ReverseSign$=work$
	Call dxget("BASEPCTACCT",tmp$)
	let work$=ucase$(rtrim$(tmp$))
	if work$<>"Y" and work$<>"N"
		returnstatus=0
		message$="Invalid Base Percent Account Submitted for Statement Type " + rtrim$(glst.StatementCode$)
		goto endsubstattype:
	endif
	glst.BaseAcct$=work$
	if newrecord=99 and rec_glst=-1
		e = 2 \ Search #ch_glst,1,0;keyglst$,rec_glst,e                              
		If e <> 0                                                                 
			returnstatus = 0                                                        
			message$ = "Search Error " + Str$(e) + " Adding Record for Statement Type "+rtrim$(glst.StatementCode$)                                                            
			Goto endsubstattype:
		endif
		write record #ch_glst,rec_glst;glst.;
		search #ch_glst,4,1;keyglst$,rec_glst,e
		if e<>0                                                               
			returnstatus = 0                                                        
			message$ = "Error Adding Key for Statement Type " + rtrim$(glst.StatementCode$)       
			Goto endsubstattype:
		endif
	endif
	write record #ch_glst,rec_glst;glst.;
        endsubstattype: !                                           
                                  
        Call CreateNetStatus(e$,returnstatus,message$,webstr$)              
        Call AddToStr(e$,rstr$,webstr$)                                    
        !call SetOutput(e$,rstr$)  
else
    include "src/callsuberr.inc"
end try
end sub
!=========================================================================================================
Sub StatAutoLoad()! 605 - submit statement type for update in the gl master or gl budget
Try

	call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="Update Complete"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(clientid)+" Not On File"
		goto endstatautoload:
	endif
	call openglmfile()
	if returnstatus=0 goto endstatautoload:
	call dxget ("UPDATEBUDGET",tmp$)
	let work$=ucase$(rtrim$(tmp$))
	if work$<>"Y" and work$<>"N"
		let returnstatus=0
		Message$="Invalid Update Budget Submitted "
	endif
	let budflag=0
	ch_glb=0
	if work$="Y"
		let budflag=99
		let ch_oglm=ch_glm
		call openglbfile()
		if returnstatus=0 goto endstatautoload:
		let ch_glb=ch_glm
		let ch_glm=ch_oglm
	endif
	call dxget ("OVERWRITE",tmp$) ! OverWrite Existing
	let overwrite=0
	if ucase$(rtrim$(tmp$))="Y" let overwrite=99
	call dxget ("SGLACCTID",tmp$)
	let sglacctid=tmp$
	call dxget ("EGLACCTID",tmp$)
	let eglacctid=tmp$
	if eglaccrid>sglacctid
		let returnstatus=0
		Message$="Ending G/L Account Must Be Greater Than Starting" 
		goto endstatautoload:
	endif
	call dxget ("TYPEID",tmp$)
	let Work$=ucase$(rtrim$(tmp$))
	if work$="" or Len(work$)>10
		let returnstatus=0
		let message$="Invalid Statement Type Submitted" 
		goto endstatautoload:
	endif
	let glst.StatementCode$=work$+blank$
	if sglacctid>0 let sglacctid=sglacctid-1
	let keyglm$=" ",keyglm$
	let keyglm$[2,9]=sglacctid using "########"
	do
		search #ch_glm,3,1;keyglm$,rec_GLm,e
		if e>0 exit do
		if keyglm$[1,1]<>" " exit do
		let tmp3=keyglm$[2,9]
		if tmp3>eglacctid exit do
		read record #ch_glm,rec_glm;glm.;
		if not(overwrite)
			if rtrim$(glm.StatType$)="" let glm.StatType$ = glst.StatementCode$
		else
			let glm.StatType$ = glst.StatementCode$
		endif
		write record #ch_glm,rec_glm;glm.;
	loop ! for the do
	if budflag<>0 and ch_glb<>0
		let keyglb$=" ",keyglb$
		let keyglb$[2,9]=sglacctid using "########"
		do
			search #ch_glb,3,1;keyglb$,rec_glb,e
			if e>0 exit do
			if keyglb$[1,1]<>" " exit do
			let tmp3=keyglb$[2,9]
			if tmp3>eglacctid exit do
			read record #ch_glb,rec_glb;glm.;
			if not(overwrite)
				if rtrim$(glm.StatType$)="" let glm.StatType$ = glst.StatementCode$
			else
				let glm.StatType$ = glst.StatementCode$
			endif
			write record #ch_glb,rec_glb;glm.;
		loop ! for the do
	endif
	endstatautoload: ! end getting budget droplist
	! section 5 - status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
else
    include "src/callsuberr.inc"
end try
end sub	


!=========================================================================================================
Sub StatTypeLoad()! 605 - submit statement type for update in the gl master or gl budget
Try

	
	call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="OK"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(clientid)+" Not On File"
		goto endstatload:
	endif
	call openglmfile()
	if returnstatus=0 goto endstatload:
	
	call dxget ("GLACCTID",tmp$)
	let glacctid=tmp$
	If glacctid<=0 or glacctid>99999999
		let returnstatus=0
		Message$="Invalid G/L Account Submitted" 
		goto endstatload:
	endif
	call dxget ("SEARCHTYPE",tmp$)
	let work$=ucase$(rtrim$(tmp$))
	let mode=2 ! exact
	let keyglm$=" ",keyglm$
	let keyglm$[2,9]=glacctid using "########"
	if work$="PREV"
		LET  MODE=6
	endif
	if work$="NEXT"
		LET MODE=3
	endif
	search #ch_glm,mode,1;keyglm$,rec_GLm,e
	if e>0
		returnstatus=0
		if mode=2
			let message$="G/L Account "+str$(glacctid)+" Not of File "
			goto endstatload:
		endif
		let message$="End of File "
		goto endstatload:
	endif
	read record #ch_glm,rec_glm;glm.;
	Try                                
		ch_glst = OpenFile(-192,intco)   
	Else                               
		let returnstatus=0
		let message$="General Ledger Statement Type File Not Found" 
		goto endstatload:
	End Try
	if rtrim$(glm.stattype$)<>""
		LET keyglst$=" ",keyglst$ \ LET keyglst$[1,10]=glm.stattype$
		SEARCH #CH_glst,2,1;keyglst$,REC_glst,E                    
		IF not(e)
			read record #ch_glst,rec_glst;glst.;
		else
			clear glst.
		endif
	else
		clear glst.
	endif
	endstatload: ! end getting budget
	! section 1 - send over info
	clear list$[]
	List$[0]=bsdel$,"GLACCTHDR",fdel$
	Webstr$="ClientID",fdel$,"ClientName",fdel$
	Webstr$=Webstr$,"GLAcctID",fdel$
	Webstr$=Webstr$+"RecType",fdel$ ! 
	Webstr$=Webstr$+"AcctType",fdel$ !
	Webstr$=Webstr$+"Desc",fdel$ !
	Webstr$=Webstr$+"CurrStatType",fdel$ !
	Webstr$=webstr$+"CurrStatTypeDesc",fdel$
	list$[1]=webstr$
	ROW=2
	if returnstatus>0
		webstr$=str$(clientid),fdel$
		webstr$=webstr$,rtrim$(acf.ClientName$),fdel$
		webstr$=webstr$,rtrim$(glm.glacct$),fdel$
		 Call GetGlRecType()
		webstr$=webstr$,glm.rectype$," ",glrectype$,fdel$
		Call GetGlAcctType() 
		webstr$=webstr$,glm.accttype$," ",glaccttype$,fdel$
		webstr$=webstr$,rtrim$(glm.desc$),fdel$
		Webstr$=webstr$,rtrim$(glm.stattype$),fdel$
		let tmp$=rtrim$(glst.StartingDescription$)
		if tmp$="" let tmp$=rtrim$(glst.EndingDescription$)
		Webstr$=webstr$,rtrim$(tmp$),fdel$
		list$[ROW]=webstr$
		row=row+1
	endif
	LIST$[ROW]=ESDEL$
	call AddToStr(e$,rstr$,List$[])
	! section status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
  else
    include "src/callsuberr.inc"
end try
end sub	 
!=========================================================================================================
Sub SubStatGLLoad()! 605 - submit statement type for update in the gl master or gl budget
Try
	call dxget ("TYPEID",tmp$)
	let Work$=ucase$(rtrim$(tmp$))
	if work$="" or Len(work$)>10
		let returnstatus=0
		let message$="Invalid Statement Type Submitted" 
		goto endsubstatGLload:
	endif
	glst.StatementCode$=work$+blank$
	call dxget ("clientid",tmp$)
	let returnstatus=1
	let message$="Update Complete"
	let clientid=tmp$
	let keyacf$=" ",keyacf$
	let keyacf$[1,6]=clientid using "######"
	let mode$="="
	dirno=1
	AcfRec=FileGetGlAcfz(e$,Ch_Acf,mode$,dirno,keyacf$,acf.)
	if AcfRec<=0 ! record found
		let returnstatus=0
		Message$="Client "+str$(clientid)+" Not On File"
		goto endsubstatGLload:
	endif
	call openglmfile()
	if returnstatus=0 goto endsubstatGLload:
	call dxget ("UPDATEBUDGET",tmp$)
	let work$=ucase$(rtrim$(tmp$))
	if work$<>"Y" and work$<>"N"
		let returnstatus=0
		Message$="Invalid Update Budget Submitted "
		goto endsubstatGLload:
	endif
	let budflag=0
	ch_glb=0
	if work$="Y"
		let budflag=99
		let ch_oglm=ch_glm
		call openglbfile()
		if returnstatus=0 goto endsubstatGLload:
		let ch_glb=ch_glm
		let ch_glm=ch_oglm
	endif
	call dxget ("GLACCTID",tmp$)
	let glacctid=tmp$
	If glacctid<=0 or glacctid>99999999
		let returnstatus=0
		Message$="Invalid G/L Account Submitted" 
		goto endsubstatGLload:
	endif
	let mode=2 ! exact
	let keyglm$=" ",keyglm$
	let keyglm$[2,9]=glacctid using "########"
	search #ch_glm,mode,1;keyglm$,rec_GLm,e
	if e>0
		returnstatus=0
		if mode=2
			let message$="G/L Account "+str$(glacctid)+" Not of File "
			 goto endsubstatGLload:
		endif
		let message$="End of File "
		goto endsubstatGLload:
	endif
	read record #ch_glm,rec_glm;glm.;
	let glm.StatType$ = glst.StatementCode$
	write record #ch_glm,rec_glm;glm.;
	
	if budflag<>0 and ch_glb<>0
		let keyglb$=" ",keyglb$
		let keyglb$[2,9]=glacctid using "########"
		search #ch_glb,2,1;keyglb$,rec_glb,e
		if e>0 goto endsubstatGLload:
		read record #ch_glb,rec_glb;glm.;
		let glm.StatType$ = glst.StatementCode$
		write record #ch_glb,rec_glb;glm.;		
	endif
	endsubstatGLload: ! end getting budget droplist
	! section 5 - status/error section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
else
    include "src/callsuberr.inc"
end try
end sub	
