!"SERPPOL" === description  synergy erp  PO entry/edit system
!  for line entry/edit
!
! loadsave -w -n 100,10 -o prog/dxport/serppol.dl4 src/serppol.src 
!  08/06/2008 started
!  05/07/2008 revised prod & prodwhse structs
! 07/2012 - add custom ACTION changes - recv to primary location
!
include "src/copyright.inc"
!
include "src/inc/filecust.inc"
include "src/inc/fileprod.inc"
include "src/inc/fileordhead.inc" ! combined ros,rot,roh
include "src/inc/filerolz.inc" ! lines
include "src/inc/filesproddesc.inc" ! nstk lines - sales orders
include "src/inc/fileprodwhse.inc" ! prodwhse
! include "src/inc/fileccodes.inc" ! u/m file
include "src/inc/fileccodesz.inc" ! u/m file (custom 
include "src/inc/filesordlotz.inc" ! sordlot (fixed dir's)
include "src/inc/filesprodlot.inc" ! sprodlot
include "src/inc/filecommodity.inc" ! commodity detail
include "src/inc/filecommhead.inc" ! commodity header
include "src/inc/fileprodgroup.inc" ! prod groups
include "src/inc/filesprodcatgy.inc" ! prod sls ctgy
include "src/inc/filematcode.inc" ! mat'l code
include "src/inc/filenstkdesc.inc" ! non stock file - purchase order
include "src/inc/filewhinfoz.inc" ! whse info - modified
include "src/inc/filepoline.inc" ! poline file
include "src/inc/filepohead.inc" ! po header file
include "src/inc/filea80vm.inc" ! vendor 
include "src/inc/filedeals.inc" ! deals
include "src/inc/filealtvend.inc" ! altvend
include "src/inc/filepoltag.inc" ! po line notes
include "src/inc/filevendtag.inc" ! vendor tag file
include "src/inc/filevendwhse.inc" ! vendor warehouse file
include "src/inc/filespolot.inc" ! po lot file
include "src/inc/fileporoll.inc" ! po roll file
include  "src/inc/fileptaxtype.inc"
include "src/inc/filecpidet.inc" ! CPI detail trailer
include "src/inc/filespecprice.inc" ! special price file
! For Import
include "src/inc/filepoocnfrt.inc" ! ocean freight rate
include "src/inc/filepocduty.inc" ! custom duty rate
include "src/inc/filepobroker.inc" ! broker 
! for multicurrency
include "src/inc/filecurrency.inc" ! currency exchange file

include "src/inc/sql_prod.inc" ! SQL defintions
!
! addon files for line types
! ---- need additional programming for the following:
!	1. Weighted unit of measure - -1/cwt, -2/lot, -3/lbs
!	2. Message lines
!	3. Imported Purchase Orders

! external libs for subs/functions
External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus

External Lib "ubsfunc.dl4"
Declare External Sub getportdefault,GetCostLevels,LogAccess
Declare External Function OpenFile,PDate$,JDate$,FormatDate2$
Declare External Function ChkAltItem$,CHKBADCHARS,clrtxtc$
Declare External Function OpenMySQLMirror ! new function

External Lib "libprodconv.lib"
Declare External Function ConvProdAmount


External Lib "libprodwh.lib"
Declare External Sub mxwhcreate
Declare External Function getwhavail

External Lib "libprod.lib"
Declare External Sub ProdList,ProdGroup,UMDList,CompIList
Declare External Function getpravail,getumrec,getMSDS,ChkPrdUM

External Lib "libprodwords.lib"
Declare External Sub apturbo 

External Lib "ubsprconv.dl4"
Declare External Function XUnit$

External Lib "libprice.lib"
Declare External Sub SysPriceCalc

External Lib "mxprodusage.dl4"
Declare External Sub mxprodusage

External Lib "mxvendmin.dl4"
Declare External Sub mxvendmin

External Lib "pwsalesinq.dl4"
Declare External Sub pwsalesinq

External Lib "libcpi.lib"          
Declare External Sub cpionhold  

External Lib "librasl.lib"
Declare External Sub ChkWHRasl

Declare Intrinsic sub programdump,env,Logic
Declare Intrinsic Sub DateToJulian, JulianToDate
Declare Intrinsic function findchannel

! internal subs/function
Declare Sub OpenFiles, GetNewProdPoDtl,GetPrice,Factorum,WhseList
Declare Sub SubmitRoll, GetRoll, DeleteRoll
Declare Sub SetNewPol,PRODSRCHDET
Declare Sub LineMainDtl,getpolines,getcust,setPrToPol
Declare Sub SetNewProdline,POLTAG,chksordlot
Declare Sub UpdtLines,updatelog,CalcImpLineTot,CPIPrdPONotes
Declare Sub ProdAltVend,DELPOLINE,delsordlot,delspolot,addspolot,ChkBrokenQty,delsernum
Declare Sub CalcExtAmt,CalcDeal,calcpototals,calcimplinetot
Declare Sub NSGetItem,NSDefault,NSSaveItem,NSbuildprod
Declare Sub ChkVendMin,verifystat,updateSoQty,dfltspolot,removesolink
Declare Sub VerifyNsKey,importlandcostrecap,importgetline,importsubmitline
Declare Function CalcExtWgt,CalcExtCube,getsordqty,chktagfle$
Declare Function GetOrdRec,UMtoFactor,getnxtline,GetPohRec
OPTION GOSUB NESTING 16  ! Default is 8
Try
	Option String Redim is legal ! in case subs dim/use same names
	! NOTE ALWAYS PRR for Product Rec, PWR for Prodwhse Record!
	! and OHR as header Record
	dim 1%,cnvcu[10],3%,cnvca[10],keycurr$[10],3%,rec_curr,currfact
	dim e$[500],buttonlist$[5,50],nextlist$[5,100] !error handling variables
	dim action$[30],options$[30],userid$[8],b$[200],action1$[30]
	Dim bsdel$[10],esdel$[10],rdel$[10],fdel$[10],rstr$[2000]
	dim tmp$[1200],tmp1$[300],Msgdesc$[150],Field$[1,30]
	dim Message$[200],WebStr$[2000],SessionID$[200]
	Dim Prod$[12],ProdKey$[60],P9$[50],P60$[50],P61$[256]
	Dim QMask$[20],PMask$[20],Key1$[60],UA2$[50],msg$[200]
	dim xdate$[10],KEYALT$[30],custom_customer$[30],FLG$[6]
	Dim KVend$[60],mode$[2],3%,REC_VTAG,VW3[7],rec_vendwh
	dim Blank$[100] \ Blank$=" ",Blank$
	dim 3%,dsp_extucost,dsp_extncost
	Dim 1%,PRC,PWC,CCC,OHC,OTC,OSC,OLC,CMC,CHAN[50],FLAGS[11]
	dim 1%,cost_lev[4],2%,Q0[1],1%,Whse,debug,errflag,boremflag
	Dim 2%,X2[9],NumProd,PONo,LD,UA2[2],RASL[2],APOUPSO
	Dim 2%,maxcnt \ maxcnt=50 ! init max records in arrays for list
	Dim 3%,PRR,OHR,PWR,FChan[30],FRec[99],rec_poh,rec_pol,rec_nstk
	Dim 3%,SUM,SQty,R[99],O1,UB0[16],pum,pqty,custnum
	dim 3%,FlePtr[20,1],Specs[50] ! for price
	dim 3%,lineqty,linecost,lineum
	dim 3%,extwgt,lbsunit,lbsfact
	dim 3%,extcube,cubeunit,cubefact,rec_uac
	dim 3%,rec_roh,keyroh$[30]
	dim 3%,rec_por,keypor$[50],rollid$[20],keyroll$[50],f$[16]
	dim 3%,rec_tmp
	dim List$[maxcnt,1000] ! for .net (larger size - ZLines)
	dim dmsg$[256],dblog$[60] \ dblog$="files/6/pol.log" ! fields for DEBUG
	

	Dim PR. as prod
	Dim pw. as prodwhse
	dim roh. as roh ! order header
	dim ros. as ros ! order ship to file
	dim rot. as rot ! order total file
	dim rol. as rolnew ! order lines
	dim cmc. as commhead ! commodity code
	Dim cust. as cust ! customer master
	dim umc. as ccodes ! um codes file
	dim whi. as whinfo ! whse info file
	Dim prdesc. as sproddesc ! non-stock file for orders
	dim deal. as deals ! deals 
	dim psc. as sprodcatgy ! product category
	dim pol. as poline! purchase order lines
    dim poh. as pohead ! purchase order header
	dim nstk. as  nstkdesc ! purchase order non-stock
	dim vend. as A80VM ! vendor file
	dim alt.  as altvend ! alternate vendor file
	dim ordl. as sordlot ! sordlot
	dim prodl. as sprodlot ! sprodlot
	dim vtag. as vendtag ! vendor tag file
	dim vendwh. as vendwhse ! vendor warehouse file
	dim polot. as spolot  ! purchase order lot file
	dim por. as poroll ! po roll file
	dim cpid. as cpidet
	Dim sd. as specprice
	!dim ordnstk. as proddesc ! sales order nonstock file
	! for currency exchange
	dim curr. as currency
! import
  dim poof. as poocnfrt ! ocean freight rate
  dim pocd. as pocduty  ! custom duty rate
  dim pobr. as pobroker ! broker rate file

	dim sql_prod. as sql_prod

	Def FNR(H) = Int(Abs(H) * 100 + .5) * .01 * Sgn(H)

	call dxopen()
	call GetSession(e$,CTLC,options$,action$,UserID$,intCo,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$,action1$)
	Call DXGet("POID",tmp$)
	call LogAccess(e$,"PO #: "+tmp$)
	!debugDetail=1;debug=1 ! can do debug text by changing both to 1
	debugDetail=0;debug=0 ! can do debug text by changing both to 1
	If debugDetail
		debug=1
		tmp$="SERPPOL"
		dmsg$[1,50]="-",dmsg$ \ Call updatelog(debug)               
		dmsg$="start...program "+tmp$ \ Call updatelog(debug)
	Endif
	Action$=UCase$(Action$)
	ACtion$=RTrim$(Action$) ! make sure UPPERCASE and No blanks at end
	Action1$=UCase$(action1$)
	Action1$=RTrim$(action1$) ! UC and trimmed
	if debugdetail
		dmsg$="SERPPOL ACTION "+action$+" ACTION1 "+action1$ \ Call updatelog(debug)
	Endif
	Mat Read #ctlc,61,0;P61$;
	call OpenFiles() ! open all needed files
	call GetCostLevels(e$,Cost_Lev[],IntCO,UserID$) ! get cost security
	Mat Read #ctlc,19,50;P9$;
	Mat Read #ctlc,60,50;P60$;
	
	MAT  READ #ctlc,115,60;CUSTOM_CUSTOMER$;
	custom_customer$=UCase$(Trim$(custom_customer$))
	Mat Read #CTLC,115,40;Q0;
	QMask$="-----------#.##"
	tmp$="#",tmp$
	If q0[1]<=0 Let Q0[1]=2
	If Q0[1] Let Pmask$="-----------#.",tmp$[1,Q0[1]]     !price mask
	! get the Usercntrl Rec #
	If Userid$="" or UserID$[1,2]="  "
		Call DXGet("S_USER.ID",tmp$) ! get from system variable
	Else
		tmp$=UserID$
	Endif
	Let UserID$=UCase$(tmp$) ! make sure it's UPPERCASE as that's what PM uses
	Let Key1$=UserID$+"          " ! space fill it
	UCC = OpenFile(-9988, intCo) \ if UCC=-1 Error 42
	Key1$[11]="" ! cut to length
	Search #UCC,2,1;Key1$,Rec,E
	If Not(E)
	  Let SCR=Rec
	  Mat Read #ucc,scr,200;UA2;
	  Mat read #ucc,scr,336;Ua2$;
	Else
	  Let SCR=0 ! 
	  UA2[0]=0;UA2$=" ",UA2$
	Endif
	Close #UCC
	let rec_uac=scr
	! GET additional user data flags
	REM UNPACK A2[0] TO B0[]                         
	FOR X1=0 TO 15                                          
		LET O1=2^X1 \ LET M1=1
		! CALL $LOGIC,M1,O1,A2[0],B0[X1] ! ub
		Call Logic(m1,O1,UA2[0],UB0[X1])
		LET UB0[X1]=SGN(UB0[X1])
	NEXT X1           
	!Call Logic(1,128,UA2[0],APOUPSO) !
	APOUPSO=99
	select case action$

	case "DROPLIST" !   send droplists 
		
		If Action1$="UMDROPLIST" ! doc = produmdroplist.doc
			Dim Polkey$[60]
			Call DXGet("PRODID",prod$) \ prod$=UCase$(prod$)
			Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
			ProdKey$=Prod$
			Call dxget("LTYPE",tmp$)
			tmp$ = UCase$(tmp$)
			if tmp$[1,4]<>"NSTK" ! LET PRODKEY$[1,6]="ZNSTK " ! set to non-stock
			!If Prodkey$[1,6]<>"ZNSTK "
				PrR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.) ! product mode=2 dir=1
				NonStk=0
			Else
				PRR=0;nonstk=1
				Call dxget("POID",tmp$)                           
				POno = tmp$  
				If not(pono) goto EndUMDroplist: ! end um droplist
				If pono <= 0 Or pono > 999999 Or Fra(pono)  
					ReturnStatus = 0                                   
					Message$ = "INVALID PURCHASE ORDER!"  
					 goto EndUMDroplist: ! end um droplist
				End If   
				Call dxget("LN",tmp$) ! +Str$(X1),tmp$)         
				LineNo = tmp$ ! line # (zero on new lines)
				If LineNo <= 0 Or LineNo > 999 Or Fra(lineno)  
					ReturnStatus = 0                                   
					Message$ = "INVALID PURCHASE ORDER LINE!"  
					goto EndUMDroplist: ! end um droplist
				End If   
				Polkey$ = " ",Polkey$                         
				Polkey$[1,6] = POno Using "######"         
				Polkey$[7,9] = LineNo Using "###"       
				Polkey$[10] = "" ! cut to length (space @ 10) 
				rec_pol = filegetpoline(e$,ch_pol,"=",1,polkey$,pol.)
				if rec_pol<=0
					returnstatus=0
					Message$="Purchase Order Line Not Found"
					goto EndUMDroplist: ! end um droplist
				endif
				let prodkey$=pol.prodcode$
				if pol.prodDescRec>0
					read record #ch_nstk,pol.proddescrec,0;nstk.;
				else
					clear nstk.
					rec_pol=-1
				endif
				LET X2=pol.flags ! ! REM UNPACK pol.Flags TO FLAGS[x] 
				FOR K=0 TO 11                     
					LET FLAGS[K]=SGN(FRA(X2/2)) \ LET X2=INT(X2/2) 
				NEXT K
		
				NonStk=flags[0]
				Closedshort=flags[1]
				Zline=flags[2] 
				let closed=0
				if pol.status=3 let closed=99
				if poh.status=7 let closed=99
				Call SetPRtoPol()
			Endif
			if debugdetail
				dmsg$="UMDROPLIST PROD= "+prodkey$ \ Call updatelog(debug)
			Endif
			EndUMDroplist: ! end um droplist!
			! initialize status
		  If PrR<0 ! Product record not found
			 clear PR.
			 ReturnStatus=0
			 Message$="Error, Product not found"
		  else ! continue with list
			E$="" ! clear message
			tmp$=" " ! is passed
			If Not(NonStk)
				Call UMDList(e$,tmp$,PRC,PRR,List$[],IntCo,Pr.)
			Else ! nonstk - send whole list
				if rec_pol>0
					Call UMDList(e$,tmp$,PRC,PRR,List$[],IntCo,Pr.)
				else
					clear tmp$ ! send other flag
					Clear Field$[]
					!if p9$[20,20]="F" let tmp$="F"
					tmp$="F" ! no longer to be flag driven 
					!call filedroplistccodes(e$,list$[],maxcnt,CCC)
					call filedroplistccodesz(e$,list$[],maxcnt,CCC,"",Field$[],1,"",tmp$)
				endif
			Endif
			Let ReturnStatus=1
			Message$="OK"
			If E$<>""
			  Let ReturnStatus=0
			  Message$=E$
			Endif
		  Endif ! valid prod
		  if debugdetail
				dmsg$="UMDROPLIST sent "+message$ \ Call updatelog(debug)
		  Endif
		Endif ! action1=umdroplist

		If Action1$="WHSELIST" ! doc = Ordl-WhseDroplist.doc
			Call DXGet("PRODID",prod$) \ prod$=UCase$(prod$)
			Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
			ProdKey$=Prod$
			Call dxget("LTYPE",tmp$)
			tmp$ = UCase$(tmp$)
			if tmp$[1,4]="NSTK" let Prodkey$[1,6]="ZNSTK "
			If Prodkey$[1,6]<>"ZNSTK "
				PrR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.) ! product mode=2 dir=1
				NonStk=0
			Else
				PRR=0;nonstk=1
			Endif
			if debugdetail
				dmsg$="WHSELIST PROD= "+prodkey$ \ Call updatelog(debug)
			Endif
			!
			! initialize status
		  If PrR<0 ! Product record not found
			 clear PR.
			 ReturnStatus=0
			 Message$="Error, Product not found"
		  else ! continue with list
			If NonStk Let P61$[59,59]="N" ! no prev only on nonstks!
			Call WhseList(e$,List$[],maxcnt,ReturnStatus,Message$)
		  Endif ! valid prod
		  if debugdetail
				dmsg$="WHSELIST sent "+message$ \ Call updatelog(debug)
		  Endif
		Endif ! action1=Whselist
	       	If Action1$="ORDFLAGS" ! rules for this cust/PO  doc=ORDL-OrdFlags.doc ** need for po ***
			ReturnStatus=1
			Message$="OK"
			Call DXGet("POID",tmp$)
			PONo=tmp$
			If PONo<=0 Or PONo>999999 Or Fra(PONO)
				ReturnStatus=0
				Message$="INVALID PO!"
			Endif
			!OHR=GetOrdRec(e$,OHC,OSC,OTC,PONo,roh.,ros.,rot.)
			!If OHR<=0 ! HOW can Order be found based on PO Number??
			!	ReturnStatus=0
			!	Message$="PO NOT FOUND!"
			!Endif
			!If OHR>0 ! can only do if found
			!	Call GetCust() ! need for flags
			!Else
				Clear Cust.
			!Endif
			Clear List$[]
			List$[0]=BSDEL$,"POFLAGS",fdel$
			WebStr$="Decimals",fdel$,"Rounding",fdel$ ! add more as needed
			WebStr$=WebStr$,"AllowCut",fdel$,"AllowKit",fdel$
			WebStr$=WebStr$,"Amalg",fdel$,"BOChk",fdel$
			WebStr$=WebStr$,"SPUMEqual",fdel$,"PermPrc",fdel$
			WebStr$=WebStr$,"AllowBrkn",fdel$,"EditQtyUM",fdel$
			WebStr$=WebStr$,"AllowBO",fdel$,"OvrBO",fdel$
			WebStr$=WebStr$,"EditPrntFlag",fdel$
			WebStr$=WebStr$,"EditStkUpt",fdel$,"EditQty",fdel$
			WebStr$=WebStr$,"AllowDel",fdel$,"LPPrompt",fdel$
			WebStr$=WebStr$,"AuthBuy",fdel$,"CPUMEqual",fdel$
			WebStr$=WebStr$,"Package",fdel$,"ForceSNinInv",fdel$
			WebStr$=WebStr$,"ExistPW",fdel$,"ProdNotes",fdel$
			WebStr$=WebStr$,"OT16RA",fdel$,"OT16AutoBO",fdel$
			WebStr$=WebStr$,"CostSec",fdel$


			List$[1]=WebStr$
			WebStr$=Str$(Q0[1]),fdel$,P9$[42,42],fdel$ ! add more as needed
			tmp$="N" \ if p9$[20,20]="F" let tmp$="Y"
			WebStr$=WebStr$,tmp$,fdel$,P9$[22,22],fdel$ ! cutting,kits
			WebStr$=WebStr$,p60$[12,12],fdel$,P60$[27,27],fdel$ ! amalg, BOchk
			WebStr$=WebStr$,p60$[30,30],fdel$,p60$[33,33],fdel$ ! Q=P UM, Perm
			WebStr$=WebStr$,p60$[34,34],fdel$,p60$[35,35],fdel$ ! Broken, edit sell um
			tmp$="N" \ if cust.BoSAllowedFlag=1 tmp$="Y"
			WebStr$=WebStr$,tmp$,fdel$,Ua2$[27,27],fdel$ ! allowBO, override BO
			WebStr$=WebStr$,UA2$[15,15],fdel$ !  edit line prntd
			tmp$="N" \ if UB0[13] let tmp$="Y"
			tmp1$="N" \ if UB0[5] let tmp1$="Y"
			WebStr$=WebStr$,tmp$,fdel$,tmp1$,fdel$ ! edit stkupt, edit ord qty
			tmp$="N" \ if UB0[6] let tmp$="Y"
			tmp1$="N" \ if p61$[25,25]="P" let tmp$="Y"
			WebStr$=WebStr$,tmp$,fdel$,tmp1$,fdel$ ! del line, prompt new LP
			WebStr$=WebStr$,cust.AuthBuyList$,fdel$,P61$[61,61],fdel$ ! authbuy,c=p um
			WebStr$=WebStr$,P9$[2,2],fdel$,P9$[46,46],fdel$ ! pkg, sn in inv
			WebStr$=WebStr$,P61$[59,59],fdel$,P61$[43,43],fdel$ ! exist pw, notes
			WebStr$=WebStr$,p61$[54,54],fdel$,p61$[49,49],fdel$ ! ot16 req/auth, auto BO
			WebStr$=WebStr$,Str$(Cost_Lev[1]),fdel$ ! loadcost sec
			List$[2]=WebStr$
			List$[3]=esdel$
			if debugdetail
				dmsg$="PO Flags sent "+Message$ \ Call updatelog(debug)
			Endif
			
		Endif ! of OrdFlags
		
		

		If Action1$="POFLAGS" ! rules for this cust/PO  doc=POL-POFlags.doc ** need for po ***
			ReturnStatus=1
			Message$="OK"
			Call DXGet("POID",tmp$)
			PONo=tmp$
			If PONo<0 Or PONo>999999 Or Fra(PONO)
				ReturnStatus=0
				Message$="INVALID PO!"
			Endif
			! Look up po # if needed
			Clear List$[]
			List$[0]=BSDEL$,"POFLAGS",fdel$
			WebStr$="Decimals",fdel$,"Rounding",fdel$ ! add more as needed
			WebStr$=WebStr$,"CostSec",fdel$,"ForceSNinRTS",fdel$
			List$[1]=WebStr$
			WebStr$=Str$(Q0[1]),fdel$,P9$[42,42],fdel$ ! add more as needed
			WebStr$=WebStr$,Str$(Cost_Lev[2]),fdel$ ! po cost sec
			WebStr$=WebStr$,P9$[46,46],fdel$ ! force sn in rts
			List$[2]=WebStr$
			List$[3]=esdel$
			if debugdetail
				dmsg$="PO Flags sent "+Message$ \ Call updatelog(debug)
			Endif
			
		Endif ! of POFlags
		If Action1$="LINEFLAGS" ! rules for this Line  doc=ORDL-LineFlags.doc  *** need for po ***
			ReturnStatus=1
			Message$="OK"
			Call DXGet("PRODID",tmp$)
			tmp$=UCASE$(tmp$)+Blank$
			Prod$=tmp$[1,12]
			Call DXGET("WHSE",tmp$)
			Whse=tmp$
			Call DXGET("ORDTYPE",tmp$)
			OType=tmp$
			ProdKey$=Prod$
			PRR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.)
			If PRR<=0
				ReturnStatus=0
				Message$="PRODUCT NOT FOUND"
				Clear PR.
			Endif
			tmp$=Prod$+Whse Using "##"
			tmp$[15]=""
			PWR=filegetprodwhse(e$,PWC,"=",1,tmp$,PW.)
			If PWR<=0 Clear pw.
			! any PO type specific changes?
			If OType=2 ! direct cannot do s/n, lot, etc
				pr.MBFlg$="B" ! force buy
				! pr.SerNoTrack$="N" ! can't do as none
				pr.LotCtrl$="N" ! can't do this either?
				pw.DNReordFlg=0 ! not frozen if direct
			Endif
			If p9$[1,1] = "N" Let pr.lotctrl$ = "N" ! Y not acceptable 
			Clear List$[]
			List$[0]=BSDEL$,"LINEFLAGS",fdel$
			WebStr$="CHKBrkn",fdel$,"MBFlag",fdel$
			WebStr$=WebStr$,"SerialNo",fdel$,"CatchWeight",fdel$
			WebStr$=WebStr$,"LotControl",fdel$,"RollLB",fdel$
			WebStr$=WebStr$,"DNReord",fdel$,"BrknUM",fdel$
			WebStr$=WebStr$,"BrknUMID",fdel$,"BrknUMFact",fdel$
			Webstr$=webstr$,"VendOrdUm",fdel$,"VendOrdUMID",fdel$
			webstr$=webstr$,"VendOrdUmFact",fdel$
			webstr$=webstr$,"RollInventory",fdel$

			List$[1]=WebStr$ ! add more to webstr as needed

			WebStr$=pw.ChkBrknQty$,fdel$,pr.MBFlg$,fdel$ ! chk brkn, make/buy
			WebStr$=WebStr$,pr.SerNoTrack$,fdel$,pr.CatchwgtItem$,fdel$ ! s/n, catchwgt
			WebStr$=WebStr$,pr.LotCtrl$,fdel$,pr.RollLbItem$,fdel$ ! lotcontrol, roll/lb
			tmp$=XUNIT$(pr.UMBrknQty,ccc)
			WebStr$=WebStr$,Str$(pw.DNReordFlg),fdel$,RTrim$(tmp$),fdel$ ! DNReord, brkn um
			X3=UMtoFactor(pr.UMBrknQty)
			WebStr$=WebStr$,Str$(pr.UMBrknQty),fdel$,Str$(X3),fdel$ ! um id, um factor
			tmp$=XUNIT$(pr.umvendord,ccc)
			WebStr$=WebStr$,RTrim$(tmp$),fdel$ ! , brkn um
			X3=UMtoFactor(pr.UMvendord)
			WebStr$=WebStr$,Str$(pr.UMvendord),fdel$,Str$(X3),fdel$ ! um id, um factor
			let tmp$="N"
			if p61$[104,104]="Y"
				if pr.rollinv$="Y" let tmp$="Y"
				if otype=2 let tmp$="N" ! no rolls on directs
				if otype=3 AND P60$[22,22]="N" let tmp$="N"
			endif
			webstr$=webstr$,tmp$,fdel$
			List$[2]=WebStr$ ! add more to webstr as needed
			List$[3]=esdel$
			if debugdetail
				dmsg$="Line Flags sent "+Message$ \ Call updatelog(debug)
			Endif
			
		Endif ! of LineFlags
			! add in droplist for nonstock here 
			
		if action1$="VENDOR" ! can use option=VENDM action=SEARCH 
			Let ReturnStatus=1
			Message$="OK"
			clear e$
			tmp$=Action1$ ! send as section name
			Clear List$[]
			if not(ch_vend)
				ch_vend = OpenFile(-2400,IntCo) \ If CH_vend = -1 Error 42 ! vendor droplist
			endif
			call FileDropListA80vm(e$,List$[],maxcnt,ch_vend) 
			if e$<>""
				ReturnStatus=0
				Message$=E$
			Endif
			if debugdetail
				dmsg$="VENDOR LIST SENT "+Message$ \ Call updatelog(debug)
			Endif
		endif ! droplist vendor
			if action1$="PRODCAT" ! product categoery --- does not have code in the file
			Let ReturnStatus=1
			Message$="OK"
			clear e$
			tmp$=Action1$ ! send as section name
			clear list$[]
			if not(ch_psc)
				ch_psc = OpenFile(-1984,IntCo) \ If ch_psc = -1 Error 42 ! prod sales category
			endif
			call FileDropListSProdCatgy(e$,List$[],maxcnt,ch_psc) 
			if debugdetail
				dmsg$="Product Category LIST SENT "+Message$ \ Call updatelog(debug)
			Endif
		endif ! droplist for product category
		if action1$="COMMCODE"  ! commodity code header file droplist
			Let ReturnStatus=1
			Message$="OK"
			clear e$
			tmp$=Action1$ ! send as section name
			clear list$[]
			if not(cmc)
				cmc = OpenFile(-2288,IntCo) \ If cmc = -1 Error 42 ! commod code(HEAD)
			endif
			Call FileDropListcommhead(e$,List$[],maxcnt,cmc)
			if debugdetail
				dmsg$="Commodity Code LIST SENT "+Message$ \ Call updatelog(debug)
			Endif
		endif ! droplist for commcode
		If Action1$ = "CCODE" ! unit of measure droplist   
			ReturnStatus = 1                                                        
			Message$ = "OK"                                                         
			Clear e$                                                                
			 tmp$ = Action1$ ! send as section name                                  
			Clear List$[]                                                           
			If Not(ccc)                                                             
				ccc = OpenFile(-1728,IntCo) \ If ccc = -1 Error 42 !u/m codes file    
			End If
			CLEAR FIELD$[]
			
			!let field$[0]="Code$"
			!let field$[1]="Description$"
			clear tmp$ ! send other flag
			Clear Field$[]
			!if p9$[20,20]="F" let tmp$="F"
			let tmp$="F" ! no longer fine paper flag driven
			!call filedroplistccodes(e$,list$[],maxcnt,CCC)
			call filedroplistccodesz(e$,list$[],maxcnt,CCC,"",Field$[],1,"",tmp$)
			If debugdetail                                                          
				dmsg$ = "Unit Of Measure LIST SENT " + Message$ \ Call updatelog(debug)                                                 
			 End If                                                                  
		End If ! droplist for ccode                                               
	  ! end of droplists
	  call AddToStr(e$,rstr$,List$[]) ! add droplist to string
	  !
	  ! status section
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
	  !
	case "PRODSEARCH" ! product scan    doc = prodscanlist.doc
		call DXGET("STEXT",tmp$)
		let vendchk=tmp$
		if vendchk<>0
			call Dxget("STYPE",TMP$)
			LET TMP$=UCASE$(RTRIM$(TMP$))
		endif
		IF TMP$<>"VENDOR CODE" or vendchk=0!
			X2=2 ! Purchase PO scan
			Call ProdList(e$,IntCo,List$[],maxcnt,ctlc,prc,pwc,x2,debugdetail,dblog$,UserId$)
			call AddToStr(e$,rstr$,List$[])
		else
			!!! search by prodwhse then search by alt vend
			call DXGET("SOURCE",tmp$)
			let source=tmp$
			returnstatus=1
			let maxcnt=10002 ! 1.7mb
			let tmpcnt=10002
			dim vplist$[maxcnt,1000],SUM$[4],KPW$[60]
			clear vplist$[]
			! Note: Order type doesn't make a diff since po's are not checking product groupts
			!Call DXGet("ORDTYPE",tmp$)                                                
			!OType = tmp$ \ If OType < 0 Or OType > 38 Let OType = 0                   
			! check for po types                                                      
			!If tmp$ = "W" Let OType = 0                                               
			!If tmp$ = "D" Let OType = 1                                               
			!If tmp$ = "I" Let OType = 2                                               
			Call DXGet("WHSE",tmp$)                                                   
			Whse = tmp$ \ If Whse < 0 Or Whse > 99 Let Whse = 0                       
			If Whse = 0 ! try user default                                            
				!Call GetPortDefault(e$,IntCO,Userid$,portnum,rec_uac,prt.) ! get port de                                                                      
				!Whse = prt.Wh   
				let whse=1                                                       
			End If   
			!!! prodsearch heading
			vplist$[0] = bsdel$,"PRODUCT SEARCH",fdel$                          
			WebStr$ = "Product",fdel$                                                                
			WebStr$ = WebStr$,"UM",fdel$,"UMID",fdel$                                                                                 
			WebStr$ = WebStr$,"Commodity",fdel$                               
			WebStr$ = WebStr$,"Desc1",fdel$,"Desc2",fdel$,"Avail",fdel$       
			WebStr$ = WebStr$,"AvlUM",fdel$,"Field",fdel$
			If OType And Whse = 0 Let Whse = 1 ! need it for prodgroup 
			WebStr$ = WebStr$,"UMFactor",fdel$                                                                                 
			WebStr$ = WebStr$,"VendOrdUm",fdel$,"VendOrdUMID",fdel$                                                           
			WebStr$ = WebStr$,"VendOrdUmFact",fdel$        
			WebStr$ = WebStr$,"VendItem",fdel$ ! task#23586& 23803 (add every   
			WebStr$ = WebStr$,"RESTRICT",fdel$ ! same name as orders  
			Webstr$ = Webstr$,"AllowPrdGrp",fdel$ ! From Product Groups Y=yes, N=No
			vpList$[1] = WebStr$
			row = 2
			LET PRODKEY$=" ",PRODKEY$
			LET KPW$=" ",KPW$
			LET KPW$[1,2]=WHSE USING "##"
			LET KPW$[3,8]=VENDCHK USING "######"
			! first time thru prod warehouse file
			DO
				clear pr.
				clear pw.
				LET PRr=0
				SEARCH #Pwc,3,3;kpw$,Pwr,E
				IF E <>0 EXIT DO
				let tmp=kpw$[1,2]\if tmp<>whse exit do
				let tmp=kpw$[3,8]\if tmp<>vendchk exit do
				read #pwc,pwr,50;pw.vend;
				if pw.vend=vendchk
					read record #pwc,pwr;pw.;
					if source<>381
						if pw.DNReordFlg = 1 goto getnxtvendprodwh:
					endif
					let Prodkey$=pw.ProdCode$
					search #prc,2,1;prodkey$,prr,e
					if e<>0 goto getnxtvendprodwh:
					Read Record #prc,prr;pr.;
					pr.PrimVend = pw.vend     
					pr.VendItem$ = pw.VendPN$ 
					goto fndvendprodwh
				endif
				goto getnxtvendprodwh:
				fndvendprodwh: ! we have a winner ! 
				call prodsrchdet()
                if returnstatus=0 goto psstat:                                          
				GETNXTVENDPRODWH: !
		LOOP
		! Check AltVend
		keyalt$=" ",keyalt$
		Do 
			Search #ch_alt,3,1;keyalt$,rec_alt,e
			if e<>0 exit do
			let tmp=keyalt$[13,18]\if tmp<>vendchk goto getnxtvendalt:
			let kpw$=" ",kpw$
			let kpw$[1,12]=keyalt$[1,12]
			let kpw$[13,14]=whse using "##"
			search #pwc,2,1;kpw$,pwr,e
			if not(e)
				read record #pwc,pwr;pw.;
				if pw.DNReordFlg = 1 goto getnxtvendalt:
				if pw.vend=vendchk goto getnxtvendalt: ! already have in product warehouse
			else
				clear pw.
			endif
			let prodkey$=keyalt$[1,12]
			search #prc,2,1;prodkey$,prr,e
			if e<>0 goto getnxtvendalt: ! not in product master file
			read record #prc,prr;pr.;
			Read Record #ch_alt,rec_alt;aLT.;   
			pr.PrimVend = aLT.VendorCode           
			pr.VendItem$ = aLT.VendorProductCode$  
			goto fndvendalt:
			fndvendalt: ! we have an alternate vendor
			call prodsrchdet()
			if returnstatus=0 goto psstat: 
			getnxtvendalt: ! 
		Loop
		let vplist$[row]=esdel$
		call AddToStr(e$,rstr$,vpList$[])
	endif
	PSSTAT: !
	Let ReturnStatus=1
	Message$="OK"
	If E$<>""
	  Let ReturnStatus=0
	  Message$=E$
	Endif
	  !
	  ! status section
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
	  if debugdetail
			dmsg$="Product Search sent "+Message$ \ Call updatelog(debug)
      Endif
	  !!!!
		
		
		case "VENDPRODDEAL" ! vendor/product deals
		!
		let returnstatus=1
		let message$="OK"
		let errtype=0
		let msg$=""
		Call DXGet("PRODID",tmp$)
     		tmp$=UCASE$(tmp$)+Blank$
		Prod$=tmp$[1,12]   
		ProdKey$=Prod$
		PRR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.)
		If PRR<=0
			errtype=99
			Msg$="PRODUCT NOT FOUND"
			Clear PR.
			let prr=0
		Endif  
		CALL dXGET("VENDID",tmp$)
		Clear specs[]
		clear chan[]
		let specs[0]=tmp$ ! vendor code
		let specs[1]=prr  ! product record
		let specs[10]=intco ! company #
		let chan[0]=ctlc  ! control file record #
		let chan[1]=ch_deal ! deal file
		let chan[2]=ccc   ! unit of measure 
		let chan[3]=prc   ! product file

		call "mxdeal.dl4",Chan[],specs[],prod$,msg$,errtype,list$[],maxcnt    
		call AddToStr(e$,rstr$,List$[])
		Let ReturnStatus=1
		Message$="OK"
		If errtype<>0
			Let ReturnStatus=0
			 Message$=msg$
		Endif
	  !
	  ! status section
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
	! start of usage
	 case "PRODUSAGE" ! product usage
		!
		let returnstatus=1
		let message$="OK"
		let errtype=0
		let msg$=""
		Call DXGet("PRODID",tmp$)
     		tmp$=UCASE$(tmp$)+Blank$
		Prod$=tmp$[1,12]   
		ProdKey$=Prod$
		PRR=filegetprod(e$,PRC,"=",1,ProdKey$,PR.)
		If PRR<=0
			errtype=99
			Msg$="PRODUCT NOT FOUND"
			Clear PR.
			let prr=0
		Endif 
		Clear specs[]
		clear chan[]
		CALL dXGET("WHSEID",tmp$)
		SPECS[1]=TMP$ ! warehouse
		specs[2]=tmp$ ! main warehouse
		CALL dXGET("VENDID",tmp$)
		let specs[3]=tmp$ ! vendor code
		
		let specs[10]=intco ! company #
		let chan[0]=ctlc  ! control file record #
		let chan[1] = 0 ! ) ! purchase PO header  #8
	
		let chan[2] = 0 ! po lines #14
	        
		let chan[3] = ohc ! PO header #18
	 	let chan[4] = prc  ! product file #2 * 
		let chan[5] = pwc ! product warehouse #3 * 
		let chan[7]=ccc   ! unit of measure file #5* 
		let chan[8]=olc  ! order lines #68
		let chan[12] = ch_deal  ! 
		! let chan[16] = NSC ! nonstock product sales #4    **** PRODSLS ****
		let chan[17]= ch_vend
		chan[18]=pltc ! sprodlot
		chan[19]=whi ! WHinfo #13
		chan[20]=0  ! Vendor Tag File
		chan[21]=SLTC ! sordlot
		chan[22] =0  ! buyer -9991
		call mxprodusage(Chan[],specs[],prod$,msg$,errtype,rstr$,maxcnt,cost_lev[])   
		Let ReturnStatus=1
		Message$="OK"
		If errtype<>0
			Let ReturnStatus=0
			 Message$=msg$
		Endif
	  !
	  ! status section
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)

	! end of usage
	! VENDOR MINU
	 case "VENDORMIN" ! Vendor Min
		!
		let returnstatus=1
		let message$="OK"
		let errtype=0
		let msg$=""
		Call DXGet("PRODID",tmp$) ! optional === not needs
     		tmp$=UCASE$(tmp$)+Blank$
		Prod$=tmp$[1,12]   
		Clear specs[]
		clear chan[]
		CALL dXGET("WHSEID",tmp$)
		SPECS[1]=TMP$ ! warehouse
		specs[2]=tmp$ ! main warehouse
		CALL dXGET("VENDID",tmp$)
		let specs[3]=tmp$ ! vendor code
		let specs[10]=intco ! company #
		let chan[0]=ctlc  ! control file record #
		let chan[1] = ch_vend ! vendor file 
		let chan[2]= 0 ! vendor tag file
	 	let chan[4] = prc  ! product file #2 * 
		let chan[5] = pwc ! product warehouse #3 * 
		let chan[7]=ccc   ! unit of measure file #5* 
		call mxvendmin(Chan[],specs[],prod$,msg$,errtype,list$[],maxcnt,cost_lev[])   
		Let ReturnStatus=1
		Message$="OK"
		If errtype<>0
			Let ReturnStatus=0
			 Message$=msg$
		Endif
	  call AddToStr(e$,rstr$,List$[])!
	  ! status section
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
         ! END VEND MIN
!!! start inventory history
	 case "INVENTORYHIST" ! Inventory History from 369 - option H
		!
		let returnstatus=1
		let message$="OK"
		let errtype=0
		let msg$=""
		Call DXGet("PRODID",tmp$) ! optional === not needs
     		tmp$=UCASE$(tmp$)+Blank$
		Prod$=tmp$[1,12]   
		Clear specs[]
		clear chan[]
		CALL dXGET("WHSEID",tmp$)
		SPECS[1]=TMP$ ! warehouse
		specs[2]=tmp$ ! main warehouse
		specs[10]=intco ! company #
		chan[0]=ctlc  ! control file record #
		chan[1] = prc ! product file #2 * 
	 	chan[2] = pwc  ! product warehouse #3 * 
		chan[3] = ccc ! unit of measure file
		chan[4] = 0 ! product warehouse sales
		chan[5] = whi ! warehouse info
		call pwsalesinq(Chan[],specs[],prod$,msg$,errtype,list$[],maxcnt,cost_lev[])   
		Let ReturnStatus=1
		Message$="OK"
		If errtype<>0
			Let ReturnStatus=0
			 Message$=msg$
		Endif
	  call AddToStr(e$,rstr$,List$[])!
	  ! status section
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)

	  ! start alternate vendor

 case "PRODALTVEND" ! Alternate Vendor Info
		!
		let returnstatus=1
		let message$="OK"
		let errtype=0
		let msg$=""
		Call DXGet("PRODID",tmp$) ! optional === not needs
     		tmp$=UCASE$(tmp$)+Blank$
		Prod$=tmp$[1,12]   
		call prodaltvend()
	  call AddToStr(e$,rstr$,List$[])
	  ! status section
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)

 



	case "PRODPODETAIL" !   doc = pol-newproddetails.doc
		! get details from list(single/quick also)
		Call SetNewProdline()
				
	case "GETPOLINES" ! doc =POL-getpolines.doc
		!  get existing ordlines
		Call getpolines()
		! end of getlines
	
	case "UPDTLINES" ! lines are being submitted    doc=POL-UpdtLines.doc
		!Call dxsave(0,"tmp/polupdt.txt!")! from web
		call UpdtLines()
		! end of update lines

	Case "CHKVENDMIN" ! checks vendor min
		!Call dxsave(0,"tmp/chkvendmin.txt!")! from web
		Call ChkVendMin()
	Case "CHKBROKENQTY"
		call ChkBrokenQty()
	
	case "NSDEFAULT" ! get default info for new nonstock item
		call NSDefault()
		! end nsdefault
	case "NSSAVEITEM" ! get default info for new nonstock item
		call NSSAVEITEM()
		! end nssaveitem
	case "NSGETITEM" ! get existing non-stock item info
		call NSGETITEM()
		! end nsgetitem
	case "NSBUILDPROD" ! create a product from non-stock	doc=OrdL-NSBuilldProd.doc
		call NSBUILDPROD()
		if returnstatus=0
			let rec_pol=-1
		endif
		clear list$[]                                                         
		list$[0]=bsdel$,"NSBUILDPROD",fdel$                                   
		webstr$=webstr$,"PRODID",fdel$                                        
		webstr$=webstr$,"LN",fdel$                                                                                   
		webstr$=webstr$,"STKUPDT",fdel$                                                                              
		webstr$=webstr$,"WHSE",fdel$                                          
		List$[1]=webstr$                                                      
		if rec_pol>0
			Read Record #ch_pol,rec_pol,0;pol.;
			webstr$=""                                                    
			webstr$=rtrim$(pol.prodcode$),fdel$                          
			webstr$=webstr$,str$(pol.ItemNo),fdel$                                               
			let tmp$="N"  
			if pol.UpdStock<>0 let tmp$="Y"  
			WebStr$=WebStr$,tmp$,fdel$ ! update stock flag$               
			webstr$=webstr$,str$(pol.whse),fdel$     
			list$[2]=webstr$                          
		endif     
		E$=""
		Call AddToStr(e$,rstr$,List$[])             
		Call AddToStr(e$,rstr$,esdel$) ! end of section   
		! status section                                                       
		Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)                 
		Call AddToStr(e$,rstr$,WebStr$)                                        
		Call SetOutPut(e$,rstr$)                                    
	    ! end of nsbuildprod	
	Case "LINENOTES" ! see routine for docs
		! using the poltag for zlines(does orders & history)
		returnstatus=1
		message$="OK"
		call POLTAG()
		! end of linenotes
	! next case
	Case "GETROLL"
		call getroll()
	

	Case "SUBMITROLL"
		call submitroll()

	Case "DELETEROLL"
		call Deleteroll()
	
	Case "IMPORTLOADRECAP"
		call importlandcostrecap()

	Case "IMPORTGETLINE"
		call importgetline()
	Case "IMPORTSUBMITLINE"
		call importsubmitline()
  End Select ! case action
  if debugdetail
		dmsg$="End of Program SERPPOL" \ Call updatelog(debug)
  Endif
else
 include "src/callmainerrnet.inc"
end try
end  ! end of Main
!
!--------------------------------------------------------------------

! subs start now
!------------------------------------------------------------------------------------------
Sub OpenFiles()

 Try
    !
	CTLC = OpenFile(-9999,intCo) \ If CTLC = -1 Error 42 !control
	PRC = OpenFile(1792,intCo) \ If PRC = -1 Error 42 ! prod
	PWC = OpenFile(1744,intCo) \ If PWC = -1 Error 42 ! prodwhse
	CCC = OpenFile(-1728,intCo) \ If CCC = -1 Error 42 ! u/m codes file
	OHC = OpenFile(1840,IntCo) \ if ohc = -1 Error 42 ! order header
	OSC = OpenFile(1856,IntCo) \ if osc = -1 Error 42 ! order shipto
	OTC = OpenFile(1872,IntCo) \ if otc = -1 Error 42 ! order totals
	OLC = OpenFile(1888,IntCo) \ if olc = -1 Error 42 ! order lines
	NSC = OpenFile(2128,IntCo) \ if nsc = -1 Error 42 ! non-stock lines ! Orders
	CMC = OpenFile(-2288,IntCo) \ if cmc = -1 Error 42 ! commod code(HEAD)
	CUC = OpenFile(1808,IntCo) \ if cuc = -1 Error 42 ! customer
	WHI = OpenFile(-2768,IntCo) \ if whi = -1 Error 42 ! whinfo
	PLTC=OpenFile(2528,IntCo) \ if PLTC = -1 Error 42 ! PRODLOT
	SLTC=OpenFile(2320,IntCo) \ if SLTC = -1 Error 42 ! SORDLOT
    ch_deal=OpenFile(864,intCo) \ If Ch_deals = -1 Error 42 ! deals file
	ch_vend=OpenFile(-2400,intCo) \ If Ch_vend = -1 Error 42 ! vendor code
	ch_Poh = openfile(2416,intCo) \ If Ch_Poh = -1 Error 42     !"po header file
	Ch_PoL = openfile(2432,intCo) \ If Ch_Pol = -1 Error 42     !"po lines file
	ch_nstk=OpenFile(2448,intCo) \ If Ch_nstk = -1 Error 42 !  nonstock purchase orders
	Ch_alt = OpenFile(-1568,intCo) \ If Ch_alt = -1 Error 42 !alternate vendor
	ch_polot=OpenFile(1088,IntCo) \ if ch_polot = -1 Error 42 ! spolot - po lot file
	ch_prloc=OpenFile(-208,IntCo) \ if ch_prloc = -1 Error 42 ! prod loc file
	If p61$[136,136]="Y"
		ch_curr=OpenFile(-9712,IntCo) \ if ch_curr = -1 Error 42 
	endif
	sqlChan = OpenMySQLMirror(e$)
	if debugdetail
		dmsg$="Files Opened" \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
  end try
end sub ! openfiles
! 
 !--------------------------------------------------------------------
 Function CalcExtWgt(lineqty,lbsunit ,lbsfact)
 ! send over the qty to calc, lbs per unit, lbs per factor
  Try
	
	Dim 3%,extwgt

	extwgt=0
	if lbsfact<>0
		let extwgt=fnr(lbsunit*lineqty/lbsfact)
	endif
 
  else
    include "src/callsuberr.inc"
  end try
end Function ExtWgt ! CalcExtWgt 
 !--------------------------------------------------------------------
 Function CalcExtCube(lineqty,cubeunit ,cubefact)
 ! send over the qty to calc, cube per unit, cube per factor
  Try
	
	Dim 3%,extcube

	extcube=0
	if cubefact<>0
		let extcube=fnr(cubeunit*lineqty/Cubefact)
	endif
 
  else
    include "src/callsuberr.inc"
  end try
end Function ExtCube ! CalcExtCube
!--------------------------------------------------------------------
Sub GetCust()
! get customer data (after header read!)
 Try
	Dim KCust$[60]
	Dim 3%,CUR
	KCust$=" ",KCust$
	KCust$=roh.CustNum Using "######"
	CUR=filegetcust(e$,CUC,"=",1,KCust$,Cust.) ! need customer fields
	If CUR<0 clear cust.
	if debugdetail
		dmsg$="Get Customer "+kcust$+" REC="+Str$(CUR) \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
  end try
end sub ! GetCust
!
! 
!--------------------------------------------------------------------
Sub GetVend()
! get vendor data (after header read!)
 Try
	Dim KVend$[60]
	Dim 3%,rec_vend
	KVend$=" ",KVend$
	KVend$=poh.VendorCode Using "######"
	rec_vend=filegetA80VM(e$,Ch_vend,"=",1,KVend$,vend.) ! need vendor fields
	If rec_vend<0 clear vend.
	if debugdetail
		dmsg$="Get Vendor "+kvend$+" REC="+Str$(rec_vend) \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
  end try
end sub ! GetVend
! -- START PRODALTVEND ---
Sub ProdAltVend()  
!! this get a list of alternate vendors for a product  !!
! 
try
	Dim vend$[6],xdate$[10]
	dim keyalt$[30]
	dim 3%,rec_alt
	dim 3%,qty,cost,amount,baseqty,cnvta
	clear List$[]
	List$[0]=bsdel$,"Alternate Vendor Info",fdel$
	WebStr$="VendId",fdel$
	WebStr$=WebStr$,"VendName",fdel$
	Webstr$=Webstr$,"Cost",fdel$
	Webstr$=Webstr$,"Date",fdel$
	List$[1]=WebStr$
	row=2
	let tmpcnt=maxcnt
	let returnstatus=1
	let message$="OK"
	Call DXGet("PRODID",tmp$) ! optional === not needs
     	tmp$=UCASE$(tmp$)+Blank$
	Prod$=tmp$[1,12] 
	prodkey$=prod$
	PRR = filegetprod(e$,PRC,"=",1,Prodkey$,PR.) 
	If PRR < 0 ! no product found                
		Clear PR.                                  
		 ReturnStatus = 0                           
		Message$ = "PRODUCT NOT FOUND"  
		goto endprodaltvend:
	End If
	if p61$[136,136]="Y" and vend.currid<>0
		let keycurr$=" ",keycurr$
		let keycurr$[1,4]=vend.currid using "####"
		search #ch_curr,2,1;keycurr$,rec_curr,e
		if e<>0
			let vend.currid=0
		else
			read record #ch_curr,rec_curr;curr.;
		endif
	endif
	Call DXGet("COSTUMID",tmp$) ! optional === will default to purchasing unit of measure
     	let costumid=tmp$
	if not (costumid) let costumid=pr.UMCostDefault
	Call DXGet("SOURCE",tmp$)
	SOURCE=tmp$
	if custom_customer$="MORRISETTE" and source=371 goto endprodaltvend ! "cct204166
	keyalt$=" ",keyalt$
	keyalt$[1,12]=prod$
	Do
		Rec_alt=filegetaltvend(e$,ch_alt,">",1,keyalt$,alt.)
		If Rec_alt<0   Exit Do
		if keyalt$[1,12]<>prod$[1,12] Exit Do
		vend$ = " ",vend$                                                   
		vend$ = alt.VendorCode Using "######"                                
		rec_vend = filegeta80vm(e$,Ch_vend,"=",1,vend$,vend.) ! need vendor f
   		If rec_vend < 0 Clear vend.  
		webstr$=ltrim$(alt.vendorcode using "######"),fdel$
		webstr$=webstr$,rtrim$(vend.name$),fdel$
		! cost 
		CNVTU[0] = 0;CNVTU[1] = costumid;CNVTU[2] = 2
		CNVTA = alt.LastUnitPrice                                       
		amount = 0                                                      
		If CNVTA <> 0                                               
			amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)   
			if p61$[136,136]="Y" and vend.currid<>0 and curr.ExcRate<>0 ! going from base to costing um Alternate 
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=curr.excrate
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=cnvca[0]
			endif
		End If                                                      
		WebStr$ = WebStr$,LTrim$(amount Using PMask$),fdel$ ! Unit cost 
		let xdate$=""
		if alt.LastOrderDate
			xdate$ = pdate$(alt.LastOrderDate)
		endif
		Webstr$=webstr$,rtrim$(xdate$),fdel$
		List$[row]=WebStr$
		row=row+1
		if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	Loop ! of open pos for customer
	 endprodaltvend: ! end getting product alternate vendors
	 list$[row]=esdel$ ! end of section
else
	! this is a remark
end try
end sub ! prodalt vend
!
!--------------------------------------------------------------------
Function GetPOHRec(e$,ch_poh,PONo,poh. as pohead)
! search thru all status for PO
! ch_poh= pohead
! PONo = PO # to find
! poh. = structs for pohead
! returns 
! X3 = PO header rec #
	Try
		Dim KOHC$[20]
		Dim 1%,X[9],SCHN[2]
		Dim 2%,X2[9]
		Dim 3%,X3[9],OHR
		SCHN[0]=ch_poh
		Let X2=PONo
		let rec_poh=-1 ! not found as default
		if debugdetail
			dmsg$="Look for PO "+Str$(x2) \ Call updatelog(debug)
		Endif
		Call DXGet("SOURCE",tmp$)
		SOURCE=tmp$
		If source<>381
			For X=1 to 99
				Let KOHC$=" ",KOHC$
				KOHC$[1,2]=X Using "##"
				KOHC$[3]=PONo Using "######"
				rec_poh=filegetpohead(e$,SCHN[0],"=",1,kohc$,poh.)
				If rec_poh>0 ! found it
				  Exit function rec_poh
				Endif
				if source<>370
					if x=7 let x=90
				else
					if x=14 let x=90
				endif
			Next X
		else
			For X=11 to 99
				Let KOHC$=" ",KOHC$
				KOHC$[1,2]=X Using "##"
				KOHC$[3]=PONo Using "######"
				rec_poh=filegetpohead(e$,SCHN[0],"=",1,kohc$,poh.)
				If rec_poh>0 ! found it
				  Exit function rec_poh
				Endif
				if x=14 let x=96
			Next X
		endif
		if debugdetail
			dmsg$="PO NOT FOUND "+Str$(X2) \ Call updatelog(debug)
		Endif
	else
    include "src/callsuberr.inc"
  end try
end Function rec_poh ! getpohrec
! 
!--------------------------------------------------------------------
Function GetOrdRec(e$,OHC,OSC,OTC,OrderNo,roh. as roh, ros. as ros, rot. as rot)
! search thru all status for Order
! ohc,osc,otc = channels for roh, ros, rot
! orderNo = Order # to find
! roh.,ros.,rot. = structs for roh,ros,rot
! returns 
! X3 = order header rec #
	Try
		Dim KOHC$[20]
		Dim 1%,X[9],SCHN[2]
		Dim 2%,X2[9]
		Dim 3%,X3[9],OHR
		SCHN[0]=OHC;SCHN[1]=OSC;SCHN[2]=OTC
		Let X2=OrderNo
		let OHR=-1 ! not found as default
		if debugdetail
			dmsg$="Look for Order "+Str$(X2) \ Call updatelog(debug)
		Endif
		For X=1 to 99
			If X<20 or x>24 ! skip deleted
				Let KOHC$=" ",KOHC$
				KOHC$[1,2]=X Using "##"
				KOHC$[3]=OrderNo Using "######"
				X3=filegetrohz(e$,SCHN[],"=",1,kohc$,roh.,ros., rot.)
				If X3>0 ! found it
				  Exit function X3
				Endif
			Endif
		Next X
		if debugdetail
			dmsg$="Order NOT FOUND "+Str$(X2) \ Call updatelog(debug)
		Endif
	else
    include "src/callsuberr.inc"
  end try
end Function OHR ! getordrec
! 
!--------------------------------------------------------------------
Sub GetNewProdPoDtl(e$,List$[],maxcnt,Prod$,Pqty,PUM,rec_poh)
! send prod, qty, um, PO Rec
! sends back list$ with details (use pol. varnames)
! ALSO CREATE PO LINE NOW! allocates 
Try
	Dim KPR$[60],KPW$[60],kcm$[40],k1$[50]
	
	Dim 1%,Cnvtu[2],Flag,E,X[9],Pram[5]
	Dim 1%,FCDays,Zline,NonStk
	Dim 2%,X2[9],JDate[5],FDate,ShipDate
	Dim 3%,CNVTA,Amount,x3[9],FutCost,LPR
	
	Dim Npol. as poline ! store new sent data
	if debugdetail
		dmsg$="Start New Line" \ Call updatelog(debug)
	Endif
	e$="";ZLine=0;NonStk=0
	tmpcnt=maxcnt ! row is passed 
	
	If prod$[1,3]="Z  " let Nonstk=1;ZLine=1
	If Prod$[1,3]="Z Z" let nonstk=1
	IF nonstk=0 and zline=0 ! check for alt item
		custnum=0 ! no customer to check in  see ubsfunce for chkaltItem
		tmp$=ChkAltItem$(e$,IntCo,Prod$,custnum)
		If tmp$<>"" If tmp$[1,2]<>"  " let prod$=tmp$ ! has alt item
	endif
	Let kpr$=Prod$
	Let kpr$[13]="";e=0 ! no lock
	If not(ZLine) ! still get prod for nonstk
	 PRR = filegetprod(e$,PRC,"=",1,KPr$,PR.,e)
	 If PRR<=0 ! not found
		Let E$="PRODUCT NOT FOUND"
		Let ReturnStatus=0
		if debugdetail
			dmsg$=prod$+e$ \ Call updatelog(debug)
		Endif
		Exit Sub
	 Endif
	Endif
	! check if valid um# sent
	if not(nonstk) and pUM=0
		let Pum=pr.UMpURCHDefault
	Endif
	IF pQty<0
		Let E$="Negative Quantity "
		Let ReturnStatus=0
		if debugdetail
			dmsg$=e$+" Rec "+Str$(SUM) \ Call updatelog(debug)
		Endif
		Exit Sub
	Endif

	If not(nonstk) and PUM<>0 ! can't check what's not there!
		 Flag=ChkPrdUM(e$,PUM,IntCo,Pr.)
		If Not(Flag)
			Let E$="INVALID QUANTITY U/M"
			Let ReturnStatus=0
			if debugdetail
				dmsg$=e$+" Rec "+Str$(SUM) \ Call updatelog(debug)
			Endif
			Exit Sub
		 Endif
	Endif
	Clear Pol. ! clear Pol. to start
	Clear npol. ! clear new data (as is none yet)
	
	Read Record #ch_poh,rec_poh,0;poh.; ! still there from getpohrec?
	Debit=0 \ if poh.Status>=11 and poh.Status<=14 Let Debit=1
	If pOH.OldStatus>10 AND pOH.OldStatus<=14 let Debit=1
	if poh.status=97 let debit=1
	PONo=POH.PurchaseOrder
	let pol.status=1
	if debit<>0 let pol.status=11
	let pol.whse=poh.Warehouse
	let pol.headerrec=rec_poh
	let pol.ponum=pono
	if p61$[136,136]="Y"
		Call GetVend()
		if vend.currid<>0
			let pol.currfact=poh.currfact
			let pol.currid=poh.currid
		endif
			!keycurr$ = " ",keycurr$                   
			!keycurr$[1,4] = vend.currid Using "####"  
			!Search #ch_curr,2,1;keycurr$,rec_curr,e   
			!If e <> 0                                 
			!	pol.currfact = 0 
			!	pol.currid=0
			!Else                                      
			!	Read Record #ch_curr,rec_curr;curr.; 
				!let pol.currid=vend.currid
				!let pol.currfact=curr.ExcRate
			!endif
		!else
			!let pol.currfact=0
			!let pol.currid=0
		!endif
		
	else
		let pol.currfact=0
		let pol.currid=0
	endif                                    		
	If ZLine ! set needed, rest zero/null
		Pol.Desc1$=Blank$
		Pol.Desc2$=Blank$
		Pol.ProdCode$="Z"+Blank$
		goto GNPDDone ! clear & submit nothing for zlines
	Endif
	! okay, convert qty to BASE
	let cnvtu[0]=pUM;cnvtu[1]=0;cnvtu[2]=1
	let cnvta=pQty
	Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	Let Pol.QtyOrd=Int(Amount) ! always integer base - just cut it
	let pol.qtyShip=Pol.QtyOrd
	Call Dxget("SOURCE",tmp$)
	let source=tmp$
	if source=381
		let pol.currqtyrcvd=pol.qtyord
	Else
		if poh.PODiscType=1 or poh.PODiscType=2 ! header has disc
			if poh.PODiscType=1 let pol.DiscPct=poh.PODiscAmt
			if poh.PODiscType=2 let pol.DiscUnt=poh.PODiscAmt
		Endif
	endif
	let pol.qtyum=pum
	! now get whse
	Let kpw$=" ",kpw$;e=0
	kpw$=prod$+Poh.Warehouse Using "##"
	If Not(NonStk)
	let pol.ProdDescRec=prr
	 PWR=filegetprodwhse(e$,PWC,"=",1,KPw$,PW.,e)
	 if pwr<0 ! NOT FOUND
		clear pw.
		If P61$[59,59]="Y" ! not allowed new prodwhse
			Let E$="Product Not Available In this Warehouse"
			Let ReturnStatus=0
			if debugdetail
				dmsg$=e$+" Sysflag 61-59,59 Y "+Str$(Poh.warehouse) \ Call updatelog(debug)
			Endif
			Exit Sub
		Endif
		If PWR=-1 ! not found - add now?
			Whbld[0]=PWC;Whbld[1]=POH.warehouse;WhBld[2]=pr.PrimVend
			Call mxwhcreate(e$,IntCo,prod$,WHBLD[])
			PWR=Whbld[2];E$=""
			Read record #PWC,PWR,0;PW.;
			if debugdetail
				dmsg$="Build new whse  "+kpw$ \ Call updatelog(debug)
			Endif
		Endif
	 Endif ! of whse not found
	Else ! is nonstk
	 Clear pw.
	 pol.UpdStock=0 ! can't happen!
	Endif
	! Needs a Prodgroup check (in case single entry!)
	If PW.ProdGrp>0 ! has a group
		Pram[0]=0-(poh.Type+1) !  \ if TScan=2 Let Pram[0]=0-OType+1
		Pram[1]=PW.ProdGrp
		Pram[5]=0 ! file not opened
		![0]=PO or (-)PO Type
		! [1]=Product Group
		! [2]=Allow on Ord/PO (1=y, 0=N)
		! [3]=Update Stock (1=y, 0=N)
		! [4]=On Price List (0/1)
		! [5]=Channel of 2/ProdGrp#
		Call ProdGroup(e$,intco,Pram[])
		!!!! ---- add override prod group functionality --- not longer need to check if allow for order type#34238 
		!If Pram[2]=0  ! not allowed on OType
			!E$="Product Not Allowed on this PO Type!"
			!if debugdetail
			!	dmsg$=E$+" OT "+Str$(pOH.Type)+" PG "+Str$(PW.ProdGrp) \ Call updatelog(debug)
			!Endif
			!Exit Sub
		!Endif
		pol.UpdStock=Pram[3] ! update Stock
	Endif 
	if poh.type=1 let pol.updstock=0 ! update stock on directs
	if poh.type=2 and P60$[22,22]<>"Y" let pol.updstock=0 ! indirects
	if poh.type=5 let pol.updstock=0 ! import directs
	if poh.type=6 and P60$[22,22]<>"Y" let pol.updstock=0 ! import ind
	IF NONSTK=0 ! 
		tmp$=pr.ComdtyCode$
		if tmp$="LABR" OR tmp$="TIME" OR tmp$="MACH" LET pol.UpdStock=0 ! comm's no stk
	else
		let pol.updstock=0 ! nonstock item
	endif
	! CHECK COMMODITY CODE TIME, LABR, MACH
	Call SetNewPol() ! use std routine to define rol vars !
	! remainder = get prices,costs, rbt/sp, wh/ttl avail, last price info, future cost
	pol.qtyUM=pUM ! just in case
	
	If NonStk ! **** non stock not currently working ****
		
		tmp$=" ",tmp$;tmp$=Pr.ComdtyCode$
		CMR=filegetcommhead(e$,CMC,"=",1,tmp$,cmc.)
		Goto NSBypass
	Endif
	
	let pw.DNReordFlg=0 ! set to 0 ---- need to test ----
	if pw.DNReordFlg=1 If ((pOL.UpdStock and x3[1]<=0) or (Not(POL.UpdStock))) ! dnr and no avail
		E$="Product is a Do Not ReOrder!"
		if debugdetail
			dmsg$=E$+" DNR "+Str$(pw.DNReordFlg)+" AVL "+Str$(x3[1]) \ Call updatelog(debug)
		Endif
		Exit Sub
	Endif
	
	NSBypass: ! can't get price avail etc for non-stk
	
	
	
	GNPDDone: ! go here for zline / nonstk (DO NOT CREATE LINE!)
	!!!! add poline here !!!! 
	! ADDED - Create line NOW!
	! clear / set up misc fields
	let pol.duedate=poh.duedate
	call calcdeal()	   ! COME BACK HERE
	lineqty=pol.qtyship+pol.freegoods-pol.totfreeqtyrcvd
	IF source=381 let pol.freeqtyrcvd=pol.freegoods   
	if source=381 let lineqty=pol.currqtyrcvd+pol.freeqtyrcvd
	let pol.ExtWght=calcextwgt(lineqty,pol.lbsunit,pol.lbsfactor)
	let pol.ExtCubes=calcextcube(lineqty,pol.CbfUnit,pol.CbfFactor)
	! update extended unit cost
	lineqty=pol.qtyship
	if source=381 let lineqty=pol.currqtyrcvd
	lineum=pol.costum
	linecost=pol.unitcost
	lineextamt=0
	lbsunit=pol.lbsunit
	lbsfact=pol.lbsfactor
	currfact=0 ! pol.currfact
	call calcextamt(lineqty,lineum,linecost,lineextamt,lbsunit,lbsfact,currfact)
	let pol.extunitcost=lineextamt
	let dsp_extucost=lineextamt
	if p61$[136,136]="Y" and pol.currfact<>0 
		lineum=pol.costum
		linecost=pol.unitcost
		lineextamt=0
		lbsunit=pol.lbsunit
		lbsfact=pol.lbsfactor
		currfact= pol.currfact
		call calcextamt(lineqty,lineum,linecost,lineextamt,lbsunit,lbsfact,currfact)
		let dsp_extucost=lineextamt	
	endif
	! update extended net cost
	lineqty=pol.qtyship
	if source=381 let lineqty=pol.currqtyrcvd
	lineum=pol.costum
	linecost=pol.netcost
	lineextamt=0
	lbsunit=pol.lbsunit
	lbsfact=pol.lbsfactor
	currfact=0 ! pol.currfact
	call calcextamt(lineqty,lineum,linecost,lineextamt,lbsunit,lbsfact,currfact)
	let pol.extnetcost=lineextamt
	let dsp_extncost=lineextamt
	if p61$[136,136]="Y" and pol.currfact<>0 
		lineum=pol.costum
		linecost=pol.netcost
		lineextamt=0
		lbsunit=pol.lbsunit
		lbsfact=pol.lbsfactor
		currfact= pol.currfact
		call calcextamt(lineqty,lineum,linecost,lineextamt,lbsunit,lbsfact,currfact)
		let dsp_extncost=lineextamt	
	endif
	
	if debugdetail
		dmsg$="New PO Line Setup "+Str$(Pono)+" - "+pol.prodcode$ \ Call updatelog(debug)
	Endif
	If not(nonstk) ! wait for complete to write zline/nonstk
	 Pol.ProdDescRec=PRR
	 X2=GetNxtLine(POno) ! GET NEXT LINE# 
	 pol.itemno=x2;E=0;olr=0
	 ! need to update the flags pol.flags
	 CLEAR FLAGS[]
	 FLAGS[0]=NONSTK
	 FLAGS[1]=CLOSEDshort
	 FLAGS[2]=ZLINE
	 LET X2=0 
	 FOR K=0 TO 11       
		IF FLAGS[K] LET X2=X2+2^K    
	 NEXT K 
	 LET pol.flags=X2  
	 if p60$[46,46]="Y"  
		pol.OceanFrtRec=0
		pol.DutyTypeRec=0
		if not(nonstk)! import
			if pr.OceanFrgtRec>0 and pr.OceanFrgtRec<100
				let pol.oceanfrtRec=pr.OceanFrgtRec
			endif
			if pr.CustomDutyRec>0 and pr.CustomDutyRec<1000
				let pol.DutyTypeRec=pr.CustomDutyRec
			endif
			if poh.type>3
				if not(ch_poof)
					ch_poof= OpenFile("POOCNFRT",Intco,"R") 
				endif
				if not(ch_pocd)
					ch_pocd= OpenFile("POCDUTY",Intco,"R") 
				endif
				if not(ch_pobr)
					ch_pobr= OpenFile("POBROKER",Intco,"R")
				endif
				call calcimplinetot() ! need to calculate totals
			endif
		endif
	endif
	 
	 rec_pol=fileupdatepoline(e$,ch_pol,"a",e,pol.) 
	 If Not(nonstk) and Pol.UpdStock and rec_pol>0
		if debugdetail
			dmsg$="New Line Added "+Str$(pol.ponum)+"-"+Str$(pol.Itemno) \ Call updatelog(debug)
		Endif
		if pol.UpdStock<>0 ! add NEW qty ord to prod & whse
					
			Read record #PRC,PRR,0;PR.
			If PWR>0 Read Record #PWC,PWR,0;pw.
			X3=pol.qtyord+pol.freegoods
			if source=381 let x3=pol.currqtyrcvd+pol.freeqtyrcvd ! pol.freegoods
			if source<>381 ! not a debit memo
				pr.QtyOnPO=pr.QtyOnPO+X3
				pw.QtyOnPO=pw.QtyOnPO+x3
			else  ! debit memo update on order -- to reduce availabity
				pr.QtyonPWO=pr.QtyonPWO+X3
				pw.QtyOnOrd=pw.QtyOnOrd+x3
			endif
			
			Write Record #PRC,PRR,0;PR.;
			!
			if sqlChan >= 0 ! MySQL enabled and channel opened
				call prod_DL4SQLConvert(e$,"FROMDL4",PR.,sql_prod.,PRR)
				e = prod_SQLAddUpdate(e$,sqlChan,sql_prod.) ! mode="a" or "c"
				if e <> 1 ! returns the number of records add/updated/deleted
					error 11000 ! do bad update stuff
				end if
			end if
			!
			If PWR>0 Write Record #PWC,PWR,0;pw.;
			!
		Endif ! write on order to prod/whse
	 Endif 
	
	 
	Endif ! of add stock line NOW
	IF P61$[111,111]="Y"  and not(nonstk) and rec_pol>0 
		call cpiprdponotes() ! need to add in new line cpi notes
	endif
	Call LineMainDtl() ! generate/write list$ 
	! call programdump("/tmp/ollog1!","")
 else
    include "src/callsuberr.inc"
  end try
end sub ! GetNewProdDtl
! 
!--------------------------------------------------------------------
Sub GetPrice()
! finish price setup & call it
 Try
	dim 1%,debug,dlog$[50],3%
	!let Debug=0 ! no, 1=yes
	!let Dlog$="/usr/dxport/files/6/dx.log" ! whence the debug log
	!If debugdetail let debug=1;dlog$=dblog$ ! set to this program
	!CALL "price.dl4",FLEPTR[],SPECS[],MSGDESC$,intco,debug,dlog$
	Let dbg=debug;dlog$=dblog$ ! pass what this program uses
	Call SysPriceCalc(e$,FLEPTR[],SPECS[],MSGDESC$,dbg,dlog$)
	e$=""
	if debugdetail
		!debug=1 ! reset
		dmsg$="PRICE CALLED "+Str$(SPECS[0]) \ Call updatelog(debug)
	Endif

	!
 else
    include "src/callsuberr.inc"
  end try
end sub ! GetPrice
! 
!--------------------------------------------------------------------
Sub CalcExtAmt(lineqty,lineum,linecost,lineextamt,lbsunit,lbsfact,currfact)

! bring extended amount to costing unit of measure factors
! cost should be in base 
 Try
	 Dim 1%,CNVTU[2],FLAG,e
	dim 3%,tmpqty,tmpcost
	DIM 3%,CNVTA
	lineextamt=0
	if lineqty=0 exit sub ! no qty extension will be zero
	if linecost=0 exit sub ! no cost exension will be zero
	If lineum=-2 ! lot costing 
		let lineextamt=linecost
		exit sub
	endif
	if lineum>=0                                                   
		LET CNVTA=lineqty
		let CNVTU[0]=0 ! currently in base
		let CNVTU[1]=lineum ! unit of measure
		let CNVTU[2]=5 
		Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		let tmpqty=amount                                              	                                                                   
		LET CNVTA=linecost
		CNVTU[0]=0
		CNVTU[1]=lineum
		CNVTU[2]=2 
		Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)                                                                  
		LET tmpcost=AMOUNT  
		if p61$[136,136]="Y" and currfact<>0 ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let tmpcost=cnvca[0]
		endif
		LET lineextamt=FNR(tmpqty*tmpcost)

		exit sub
	endif
	
	IF lineum=-1 or lineum=-3! cwt 
		let tmpqty=lineqty
		LET CNVTA=linecost
		CNVTU[0]=0
		CNVTU[1]=lineum
		CNVTU[2]=2 
		Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)                                                                  
		LET tmpcost=AMOUNT 
		if p61$[136,136]="Y" and currfact<>0 ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=tmpcost
			let cnvca[1]=currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let tmpcost=cnvca[0]
		endif
		if lineum=-1 ! cwt
			if lbsfact<=0 let lbsfact=pr.lbsfact
			if lbsfact<=0 let lbsfact=1
			LET lineextamt=FNR(tmpcost*(lbsunit*tmpqty/lbsfact)/100)
			exit sub
		endif
		if lineum=-3 ! per lb
			if lbsfact<=0 let lbsfact=pr.lbsfact
			if lbsfact<=0 let lbsfact=1
			LET lineextamt=FNR(tmpcost*(lbsunit*tmpqty/lbsfact))
			exit sub
		endif
		
	endif
 else
    include "src/callsuberr.inc"
  end try
end sub ! CalcExtAmt
!
!--------------------------------------------------------------------
Sub CalcDeal()
! need qty
! bring extended amount to costing unit of measure factors

! need the product file, need the poline, need the po header
 Try
	Dim 1%,CNVTU[2],FLAG,e
	DIM 3%,CNVTA
	                    
        dim keydeal$[30],TMP$[1200],TMP1$[300]                                                      
        dim 2%,currdate,jdate[5]                                                
        dim 3%,disp_discpct,disp_discunit,disp_unitcost,disp_netcost            
        dim 3%,disp_freeqty,disp_ordqty,with_qty,tmpamount                      
        read #ctlc,3,172;currdate;
	if poh.PODiscType=1 or poh.PODiscType=2 ! header has disc
	  if not(debit)
		if poh.PODiscType=1 let pol.DiscPct=poh.PODiscAmt
		if poh.PODiscType=2 
			let pol.DiscUnt=poh.PODiscAmt;disp_discunit=poh.PODiscAmt
			if p61$[136,136]="Y" and pol.currfact<>0 ! going from base to costing um
				let cnvcu[0]=1
				let cnvca[0]=disp_discunit
				let cnvca[1]=pol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let disp_discunit=cnvca[0]
			endif
		endif
		goto BPDeals ! not using deals if vendor/header file discs
	  Endif
	Endif
	let tmp$=currdate using "&&&&&&"
	Call DateToJulian(1,tmp$,tmp1$,f)
	if f<>0 let tmp1$="0"
        jdate[0]= tmp1$ ! currdate in julian                                          
        let amount=pol.qtyord ! need quantity in base                           
        ! SET DISC %, DISCOUNT DOLLAR, & FREE AMOUNT TO 0 BEFORE CHECKING FOR DEALS                                                                         
        let pol.discpct=0                                                       
        let pol.discunt=0                                                      
        let pol.freegoods=0 
	let disp_freeqty=0
	let disp_discunit=0
        LET keydeal$=" ",keydeal$                                               
        LET keydeal$[1,6]=poh.VendorCode USING "######"                         
        LET keydeal$[7,18]=pol.prodcode$                                        
        LET keydeal$[19,27]=999999999-(AMOUNT+1) USING "#########"              
        do                                                                      
                SEARCH #ch_deal,3,1;keydeal$,rec_deal,E                         
                IF E<>0 exit do                                                 
                LET X2=keydeal$[1,6]                                            
                IF X2<>poh.VendorCode exit do                                   
	        IF keydeal$[7,18]<>pol.prodcode$ exit do                        
                read record #ch_deal,rec_deal;deal.;                            
                ! start date to julian                                          
                if deal.startdate<>0                                            
                        let tmp$=deal.startdate  using "&&&&&&"                                 
                        Call DateToJulian(1,tmp$,tmp1$,f) ! convert date to julian
			if f<>0 let tmp1$="0"
                        let jdate[1]=tmp1$                                      
                else                                                            
                        let jdate[1]=0                                          
                endif                                                           
                if deal.enddate<>0                                              
                        let tmp$=deal.enddate  using "&&&&&&"                                   
                        Call DateToJulian(1,tmp$,tmp1$,f) ! convert date to julian                                
                        let jdate[2]=TMP1$                                       
                endif                                                           
                IF JDATE[0]<JDATE[1] OR (deal.enddate<>0 AND JDATE[0]>JDATE[2]) GOTO dealend:                                                                   
                IF deal.disctype=1 ! factor - % off                             
                        let pol.discpct=deal.factor 
			exit do
                endif                                                           
                if deal.disctype=2 ! disc                                       
			CNVTA=deal.factor                                               
			CNVTU[0]=0   
		        CNVTU[0]=0                                                      
			CNVTU[1]=pol.costum                                             
			CNVTU[2]=2                                                      
			Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)         
			disp_discunit=amount 
			if p61$[136,136]="Y" and pol.currfact<>0 ! going from base to costing um
				let cnvcu[0]=1
				let cnvca[0]=disp_discunit
				let cnvca[1]=pol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let disp_discunit=cnvca[0]
			endif
			 exit do
		ENDIF                                                                   
		if deal.disctype=3 ! free goods IF DL1[1]=3                             
			CNVTA=deal.WithQty ! free with                                  
			CNVTU[0]=0                                                      
			CNVTU[1]=pol.qtyum                                              
			CNVTU[2]=1                                                      
			Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)         
			WITH_QTY=AMOUNT                                                 
			CNVTA=deal.factor                                               
			CNVTU[0]=0                                                      
			CNVTU[1]=pol.qtyum                                              
			CNVTU[2]=1                                                      
			Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)         
			tmpamount=amount                                                
			IF WITH_QTY                                                     
			 ! convert order quantity to display units               
				CNVTA=pol.qtyord 
				CNVTU[0]=0                                              
				CNVTU[1]=pol.qtyum                                      
				CNVTU[2]=1                                              
				Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.) 
				disp_ordqty=amount                                      
				let disp_freeqty=int(disp_ordqty/with_qty)*tmpamount    
			ENDIF 
			 exit do
		endif
		dealend: ! look for next deal
	loop
	BPDeals: ! bypass
	let pol.netcost=pol.unitcost
	if disp_discunit<>0 or pol.discpct<>0
		cnvta=pol.unitcost
		cnvtu[0]=0
		cnvtu[1]=pol.costum
		cnvtu[2]=2
		Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if p61$[136,136]="Y" and pol.currfact<>0 ! going from base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=pol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let disp_unitcost=cnvca[0]
		endif
		let disp_unitcost=amount
		let disp_netcost=disp_unitcost-(disp_unitcost*(pol.discpct/100))-disp_discunit
		if p61$[136,136]="Y" and pol.currfact<>0 ! going from cost um to base 
			let cnvcu[0]=2
			let cnvca[0]=disp_netcost
			let cnvca[1]=pol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let disp_netcost=cnvca[0]
		endif
		cnvta=disp_netcost
		cnvtu[0]=pol.costum
		cnvtu[1]=0
		cnvtu[2]=2
		Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		let pol.netcost=amount
		if disp_discunit<>0 
			if p61$[136,136]="Y" and pol.currfact<>0 ! 
				let cnvcu[0]=2
				let cnvca[0]=disp_discunit
				let cnvca[1]=pol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let disp_discunit=cnvca[0]
			endif
			cnvta=disp_discunit
			cnvtu[0]=pol.costum
			cnvtu[1]=0
			cnvtu[2]=2
			Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			let pol.discunt=amount
		endif
	endif
	if disp_freeqty
		cnvta=disp_freeqty
		cnvtu[0]=pol.qtyum
		cnvtu[1]=0
		cnvtu[2]=1
		Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		pol.freegoods=amount
	endif
 else
    include "src/callsuberr.inc"
  end try
end sub ! CalcDeal 
!--------------------------------------------------------------------
Sub Factorum(tmp$)
! from sent factor (in tmp$) - get um text for it
! if no match - send factor back as um
 Try
	dim um$[4]
	dim 1%,umrec
	dim 3%,factor
	let factor=tmp$
	if factor<=0 let factor=1
	umrec=0
	if factor=pr.UM2Fact let umrec=PR.UM2
	if factor=pr.UM3Fact let umrec=PR.UM3
	if factor=pr.UM4Fact let umrec=PR.UM4
	if factor=pr.UM5Fact let umrec=PR.UM5
	if factor=pr.UM6Fact let umrec=PR.UM6
	if factor=pr.UM7Fact let umrec=PR.UM7
	if factor=pr.UM8Fact let umrec=PR.UM8
	If factor=1 let umrec=pr.BaseUM
	if umrec>0
		Read record #ccc,umrec,0;UMC.;
		let tmp$=umc.Code$ ! send back um attached
	Else
		if factor=1000 ! hardcode an "M"?
			tmp$="M" ! why not
		Else
			Let tmp$=Str$(Factor) ! send back w/no um (factor instead of um)
		Endif
	Endif
	if debugdetail
		dmsg$="Factor to UM" \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
  end try
end sub ! Factorum
! 
!--------------------------------------------------------------------
Sub WhseList(e$,List$[],maxcnt,ReturnStatus,Message$)
! this is determined by system flag P61$[59,59]
! if =Y - ONLY WHSE THAT CURRENTLY EXIST
! if =N - any valid whse
 Try
	Dim PWK$[60],Secname$[40]
	Dim 1%,Whse
	dim 2%,tmpcnt
	Dim 3%,PWR,WHIR
	Let ReturnStatus=1
	Message$="OK"
	Clear List$[]
	tmpcnt=maxcnt
	Secname$="WHSELIST" ! specify section name
	If P61$[59,59]="Y" ! only currently used whses for product
		List$[0]=bsdel$,Secname$,fdel$
		List$[1]="ID",fdel$,"WhName",fdel$ ! use same names as droplist
		row=2
		Pwk$=" ",Pwk$
		Pwk$=Prod$
		Do
			PWR=filegetprodwhse(e$,PWC,">",1,PWK$,PW.)
			If PWK$[1,12]<>Prod$ Let PWR=-2
			If PWR<0 Exit do
			Whse=PWK$[13,14]
			If Whse<1 or Whse>99 Exit do
			WHIR=Whse-1
			Read record #WHI,WHIR,0;WHI.;
			tmp$=RTrim$(WHI.WhName$)
			If tmp$<>"" ! whse defined
				List$[row]=Str$(Whse),fdel$,tmp$,fdel$
				row=row+1
				If row>tmpcnt let tmpcnt=expandarray(e$,List$[])
			Endif
		Loop
		List$[row]=esdel$ ! all done
	Else ! list all
		Call filedroplistwhinfoz(e$,list$[],tmpcnt,WHI,Secname$)
		! returns with bsdel$,esdel$
	Endif
	if debugdetail
		dmsg$="Whse List sent p61-59,59 "+p61$[59,59]+" "+prod$ \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
  end try
end sub ! WhseList
! 
!--------------------------------------------------------------------
Sub SetNewPOL()
! a routine for setting pol. variables
! this assumes the prod & prodwhse are already read!
! also poh.  have been read!
! AND the qtyord is already known and PurchUM is in PUM
 Try
	Dim K1$[50]
	dim 1%,PRAM[5]
	Dim 2%,X2[9]
	Dim 3%,X3[9]
	
	pol.ponum=poh.purchaseorder
	pol.updstock=1 ! yes
	X2=poh.Type
	if x2=1 OR X2=5 LET pol.UpdStock=0 ! not on directs/import directs
	if x2=2 and p60$[22,22]<>"Y" LET pol.UpdStock=0 ! indir no stk 
	if x2=6 and p60$[22,22]<>"Y" LET pol.UpdStock=0 ! indir import no stk 
	tmp$=pr.ComdtyCode$
	if tmp$="LABR" OR tmp$="TIME" OR tmp$="MACH" LET pol.UpdStock=0 ! comm's no stk
	If nonstk LET pol.UpdStock=0
	
	pol.whse=poh.warehouse! 
	If nonstk goto NStkSUBypass ! don't load the remainder
	pol.CbfUnit=PR.CubicFeet
	Pol.CbfFactor=pr.cUBICFTfACTOR \ if pol.cbffactor<=0 let pol.cbffactor=1
	pol.lbsunit=pr.lbsunit
	pol.lbsfactor=pr.lbsfact \ if pol.lbsfactor <=0 let pol.lbsfactor=1 
	pol.Desc1$=pr.Desc1$
	pol.Desc2$=pr.Desc2$
	pol.ProdCode$=pr.ProdCode$
	pol.proddescrec=prr ! product record #
	pol.QtyUM=PUM ! as passed!
	if PUM=0 Let pol.qtyUM=pr.UMPurchDefault
	pol.CostUM=pr.UMCostDefault
	pol.VendProdCode$=pr.VendItem$ !use prod
	if custom_customer$="ATHENS" and len(pol.VendProdCode$)>0
		if PW.VendPN$>"  " and pol.VendProdCode$[1,1]=" " let pol.VendProdCode$=pw.VendPN$
	Endif
	if custom_customer$="MORRISETTE" ! always pw if there on morrisette
		if PW.VendPN$>"  " let pol.VendProdCode$=pw.VendPN$
	Endif
	pol.hazitemflag=pr.DotHazardous
	pol.ApplyFrt=1 ! apply freight is always set to 1 see po361b
	IF P9$[32,32]="Y" ! whse pricing
	  If PW.Vend = poh.vendorcode
		  IF PW.VendPN$>"  " let pol.VendProdCode$=pw.VendPN$
	  endif
	Endif

	! Needs a Prodgroup check (in case single entry!)
	If PW.ProdGrp>0 ! has a group
		Pram[0]=0-(pOH.Type+1) !  \ if TScan=2 Let Pram[0]=0-OType+1
		Pram[1]=PW.ProdGrp
		Pram[5]=0 ! file not opened
		![0]=Order or (-)PO Type
		! [1]=Product Group
		! [2]=Allow on Ord/PO (1=y, 0=N)
		! [3]=Update Stock (1=y, 0=N)
		! [4]=On Price List (0/1)
		! [5]=Channel of 2/ProdGrp#
		Call ProdGroup(e$,intco,Pram[])
		! If Pram[2]=0  ! not allowed on OType
		!	E$="Product Not Allowed on this Order!"
		!	Exit Sub
		! Endif  ! DO THIS ON ENTRY ONLY!
		pol.UpdStock=Pram[3] ! update Stock
	Endif ! prodgroup
	IF NONSTK=0 ! 
		tmp$=pr.ComdtyCode$
		if tmp$="LABR" OR tmp$="TIME" OR tmp$="MACH" LET pol.UpdStock=0 ! comm's no stk
	else
		let pol.updstock=0 ! nonstock item
	endif
	if poh.type=1 let pol.updstock=0 ! update stock on directs
	if poh.type=2 and P60$[22,22]<>"Y" let pol.updstock=0 ! indirects
	if poh.type=5 let pol.updstock=0 ! import directs
	if poh.type=6 and P60$[22,22]<>"Y" let pol.updstock=0 ! import ind
	! set up cost
	keyalt$=" ",keyalt$
	keyalt$[1,12]=prod$
	keyalt$[13]=poh.vendorcode USING "######"
	rec_alt=0
	if p61$[51,51]<>"N"
		Rec_alt=filegetaltvend(e$,ch_alt,"=",1,keyalt$,alt.)
		if rec_alt>0
			IF P9$[32,32]="Y" !whse pricing turned on     
				IF pw.vend=poh.vendorcode AND pW.CostLastPo<>0                   
					LET pr.costpo=pw.CostLastPo
					if pw.VendPN$[1,5]<>"     "
						LET pol.VendProdCode$=PW.VendPN$
					else
						LET pol.VendProdCode$=pr.VendItem$
					endif
			
				ELSE                                        
					LET pr.costpo=alt.LastUnitPrice ! AV2[2]                          
					LET pol.VendProdCode$=alt.VendorProductCode$!AV1$[13,32]                
				ENDIF                                       
			else
			  If custom_customer$<>"MORRISETTE"
				IF (alt.VendorCode<>pr.PrimVend) AND (alt.VendorCode<>pw.Vend)    ! av2[0]   
					LET pr.CostPO=alt.LastUnitPrice! AV2[2]                          
					LET pol.VendProdCode$=alt.VendorProductCode$ !AV1$[13,32]                
				ELSE                                        
					LET pol.VendProdCode$=pr.VendItem$ ! A$[93,112] 
				endif
			  Else ! morrisette not using alt vend
				if PW.VendPN$>"  " let pol.VendProdCode$=pw.VendPN$ Else let pol.VendProdCode$=pr.VendItem$ !use prod
			  Endif
			endif 
		endif
	endif
	if p9$[32,32]="Y" and pW.CostLastPo>0 and rec_alt<=0
		LET pr.costpo=pw.CostLastPo
		if pw.VendPN$[1,5]<>"     "
			LET pol.VendProdCode$=PW.VendPN$
		endif
	endif
	
	let pol.unitcost=pr.costpo
	let pol.netcost=pol.unitcost
	
	if not(pol.unitcost) let pol.unitcost=pr.Costavg
	NStkSUBypass: ! bypass a lot on new nonstk
	
	if debugdetail
		dmsg$="pol. Setup "+pol.prodcode$+Message$ \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
 end try
end sub ! Setnewpol
! 
!--------------------------------------------------------------------
Sub SetPRtoPol()
! set up prod (PR.) with line values (stock & NonStock)
 Try
	Dim 1%,PFU1[20]
	Dim 3%,PFU2[6]
	IF ZLINE GOTO L30099:    ! stock factors 
	if NonStk<>0
		let rec_nstk=pol.ProdDescRec
		read record #ch_nstk,rec_nstk;nstk.;
		clear pr.                                             
		pr.baseum=nstk.BaseUM ! nsd1[2]
		pr.um2=nstk.CostUM !    nsd1[3]
		pr.um3=nstk.PurchUM !nsd1[4]
		pr.um4=nstk.StockUM !nsd1[5]
		pr.UMStkDefault = nstk.StockUM ! NSD1[5]
		pr.UMPurchDefault=nstk.PurchUM ! NSD1[4]
		pr.UMSellDefault=nstk.PurchUm ! 
		pr.UMCostDefault= nstk.CostUM  ! NSD1[3]
		pr.UM2Fact=nstk.CostFact !nsd3[3]
		pr.UM3Fact=nstk.POFact !nsd3[4]
		pr.UM4Fact=nstk.StkFact !nsd3[5]                                             
		pr.LbsFact=nstk.WgtFact !NSD3[7]
		pr.LbsUnit=nstk.Wgt  !NSD3[6]  
		pr.UMVendOrd=nstk.PurchUM
		IF NOT(pr.LbsUnit) LET pr.LbsUnit=1;pol.Lbsunit=1    
		if not(pr.lbsfact) let pr.lbsfact=1;pol.lbsfactor=1
		LET pr.CubicFeet=nstk.Cube;pr.CubicFtFactor=nstk.CubeFact
		IF NOT(pr.CubicFtFactor) LET pr.CubicFtFactor=1;pol.CbfFactor=1
		pr.comdtycode$=nstk.cmdtycode$
		pr.RollLbItem$="N"                          
		LET pr.UM5=0                                          
		LET pr.UM6=0;pr.UM7=0;pr.UM8=0
		CHGSTK=0
		                                  
		
	endif
	! below gets rid of dupes - not easy with names - so load into pfu1,pfu2
	PFU1[0]=pr.BaseUM
	pfu1[1]=pr.UM2;PFU2[0]=pr.UM2Fact
	Pfu1[2]=pr.UM3;pfu2[1]=pr.UM3Fact
	pfu1[3]=pr.UM4;pfu2[2]=pr.UM4Fact
	pfu1[4]=pr.UM5;pfu2[3]=pr.UM5Fact
	FOR X1=1 TO 4                                                   
		FOR X2=0 TO X1-1                                              
			IF PFU1[X1]=PFU1[X2] LET PFU1[X1]=0;PFU2[X1-1]=0            
		NEXT X2                                                       
	NEXT X1 
	! now reload checked um's to names
	pr.BaseUM=PFU1[0]
	pr.UM2=pfu1[1];pr.UM2Fact=PFU2[0]
	pr.UM3=Pfu1[2];pr.UM3Fact=pfu2[1]
	pr.UM4=pfu1[3];pr.UM4Fact=pfu2[2]
	pr.UM5=pfu1[4];pr.UM5Fact=pfu2[3]
L30099: ! finito
	if debugdetail
		dmsg$="Put pol. into pr. "+Str$(Pono)+"-"+Str$(ItemNo)+" "+pol.prodcode$ \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
 end try
end sub ! SetPRtoPol
! 
!--------------------------------------------------------------------------------------------------------
Function UMtoFactor(UMRec)
! from sent um # - get um factor for it
! if no match - send factor back as one (base?)
 Try
	
	dim 3%,factor
	let factor=0
	if umrec=-1 let factor=-1 ! web wants umrec in factor
	if umrec=-3 let factor=-3 ! for these
	if umrec<=0 exit function Factor ! 0 ! no um - no factor!
	If umrec=Pr.BaseUM let factor=1
	if umrec=PR.UM2 let factor=pr.UM2Fact
	if umrec=PR.UM3 let factor=pr.UM3Fact
	if umrec=PR.UM4 let factor=pr.UM4Fact
	if umrec=PR.UM5 let factor=pr.UM5Fact
	if umrec=PR.UM6 let factor=pr.UM6Fact
	if umrec=PR.UM7 let factor=pr.UM7Fact
	if umrec=PR.UM8 let factor=pr.UM8Fact
	if debugdetail
		dmsg$="UM to Factor" \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
  end try
end Function Factor ! umtofactor
! 
!--------------------------------------------------------------------
Sub LineMainDtl() ! purchase order line
! the routine to load string for the web
! all pol. set up already 
! commodity code read
! prod code & prodwhse read or set up
! futcost already gotten
!
 Try
	dim qtyum$[4],costum$[4]
	Dim QUM$[4],PUM$[4],CUM$[4]
	Dim LPPUM$[4],LPCUM$[4],LPSUM$[4]
	Dim 1%,X1[9]
	Dim 2%,X2[9]
	Dim 3%,LPR,X3[9],plcost,pldate

	! generate list
	!If Nonstk !  and elflag=0 ! new nonstk line  -- need info on nonstocks
		!pol.qtyum=0; pol.costum=0
		
		!Qtyum$=blank$;costUM$=blank$
		!pol.prodcode$="NONSTOCK"+Blank$
		
	!Else
		QTYUM$=xunit$(POL.QTYUM,ccc) ! u/m
		COSTUM$=xunit$(POL.COSTUM,ccc) ! u/m
		
	!Endif
	If zline<>0 ! ZLINE
		pol.qtyum=0; pol.costum=0
		Qtyum$=blank$;costUM$=blank$
	Endif
   if zline=0  ! no zlines now - endif near end
	if Nonstk<>0
		if pol.extwght<>0 and pol.lbsunit=0
			let pol.lbsunit=nstk.wgt
			let pol.lbsfactor=nstk.wgtfact
			if not(pol.lbsfactor) let pol.lbsfactor=1
		endif
		if pol.extcubes<>0 and pol.cbfunit=0
			let pol.cbfunit=nstk.cube
			let pol.cbffactor=nstk.cubefact
		endif
	endif
	WebStr$=pol.prodcode$,fdel$ ! prod code
	tmp$=clrtxtc$(e$,pol.Desc1$)
	Webstr$=webstr$,RTrim$(tmp$),fdel$ !  desc 1
	tmp$=clrtxtc$(e$,pol.Desc2$)
	Webstr$=webstr$,RTrim$(tmp$),fdel$ !  desc 2
	WebStr$=WebStr$,Rtrim$(pr.ComdtyCode$),fdel$,RTRIM$(CMC.CodeDescription$),fdel$ ! commod & desc
	! qty ordered, qty um , qty umid
	let x3=0
	Cnvtu[0]=0;Cnvtu[1]=pol.qtyum;Cnvtu[2]=1
	CNVTA=pol.qtyord
	if (cnvta)
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	endif
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$,RTrim$(QTYUM$),fdel$ ! ORDER QTY, UM , 
	WebStr$=WebStr$,Str$(pol.qtyum),fdel$ ! QTY um id
	! qty to ship **** PL4[5] ****
	let x3=0
	Cnvtu[0]=0;Cnvtu[1]=pol.qtyum;Cnvtu[2]=1
	if closed<>0 let pol.qtyship=0
	CNVTA=pol.qtyship
	if (cnvta)
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	endif
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$
	! last qty received
	let x3=0
	Cnvtu[0]=0;Cnvtu[1]=pol.qtyum;Cnvtu[2]=1
	CNVTA=pol.LastQtyRcvD
	if (cnvta)
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	endif
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$
        ! last date received
	if pol.DateLastRcvd
		let xdate$=pdate$(pol.DateLastRcvd)
	else
		let xdate$=" ",xdate$
	endif
	webstr$=webstr$,rtrim$(xdate$),fdel$
	let tmp$="Y"
	if pol.UpdStock=0 let tmp$="N"
	webstr$=webstr$,rtrim$(tmp$),fdel$
	webstr$=webstr$,str$(pol.whse),fdel$
	! net cost
	cnvtu[0]=0;cnvtu[1]=pol.costum;cnvtu[2]=2
	Cnvta=pol.netcost
	let x3=0
	if cnvta<>0
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if p61$[136,136]="Y" and pol.currfact<>0 ! go from base to costing um
			let cnvcu[0]=1
			let cnvca[0]=x3
			let cnvca[1]=pol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=cnvca[0]
		endif
	endif
	WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! Net cost
	! extended cost
	let dsp_extncost= pol.extNetCost
	if p61$[136,136]="Y" and pol.currfact<>0 
		let cnvcu[0]=1
		let cnvca[0]=dsp_extncost
		let cnvca[1]=pol.currfact
		call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
		let dsp_extncost=fnr(cnvca[0])
	endif
	if (source=371 or source=381) and pol.currqtyrcvd<>0
		! update extended net cost                                          
		lineqty = pol.currqtyrcvd-pol.freeqtyrcvd                                              
		lineum = pol.CostUM                                                 
		linecost = pol.netcost                                              
		lineextamt = 0  
		LbsUnit = pol.LbsUnit                                               
		LbsFact = pol.LbsFactor 
		if lbsfact<=0
			if pr.lbsfact>0
				let pol.lbsfactor=pr.lbsfact;lbsfact=pr.lbsfact
			else
				let pol.lbsfactor=1;lbsfact=1
			endif
		endif
		if lbsunit<=0
			if pr.lbsunit>0
				let pol.lbsunit=pr.lbsunit; lbsunit=pr.lbsunit
			else
				let pol.lbsunit=1; lbsunit=1
			endif
		endif
		let currfact=0! pol.currfact
		Call CalcExtAmt(lineqty,lineum,linecost,lineextamt,LbsUnit,LbsFact,currfact) 
		pol.extNetCost = lineextamt
		let dsp_extncost=lineextamt
		if p61$[136,136]="Y" and pol.currfact<>0 
			lineum=pol.costum
			linecost=pol.netcost
			lineextamt=0
			lbsunit=pol.lbsunit
			lbsfact=pol.lbsfactor
			currfact= pol.currfact
			call calcextamt(lineqty,lineum,linecost,lineextamt,lbsunit,lbsfact,currfact)
			let dsp_extncost=lineextamt	
		endif
	else
		lineqty = pol.QtyShip                                            
		lineum = pol.CostUM                                                 
		linecost = pol.netcost                                              
		lineextamt = 0                                                      
		LbsUnit = pol.LbsUnit                                               
		LbsFact = pol.LbsFactor 
		let currfact=0 ! pol.currfact
		Call CalcExtAmt(lineqty,lineum,linecost,lineextamt,LbsUnit,LbsFact,currfact) 
		pol.extNetCost = lineextamt
		let dsp_extncost=lineextamt
		if p61$[136,136]="Y" and pol.currfact<>0 
			lineum=pol.costum
			linecost=pol.netcost
			lineextamt=0
			lbsunit=pol.lbsunit
			lbsfact=pol.lbsfactor
			currfact= pol.currfact
			call calcextamt(lineqty,lineum,linecost,lineextamt,lbsunit,lbsfact,currfact)
			let dsp_extncost=lineextamt	
		endif
	endif
	Webstr$=Webstr$,Ltrim$(dsp_extncost using "##########.##"),fdel$ ! extended net cost pol.extNetCost
	Webstr$=webstr$,LTRIM$(pol.discpct using "###.##"),fdel$ ! disc %
	! discount dollars
	cnvtu[0]=0;cnvtu[1]=pol.costum;cnvtu[2]=2
	Cnvta=pol.discunt
	let x3=0
	if cnvta<>0
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if p61$[136,136]="Y" and pol.currfact<>0 ! from base to costing um
			let cnvcu[0]=1
			let cnvca[0]=x3
			let cnvca[1]=pol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=cnvca[0]	
		endif
	endif
	WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! discount dollars
	! unit cost 
	cnvtu[0]=0;cnvtu[1]=pol.costum;cnvtu[2]=2
	Cnvta=pol.unitcost
	let x3=0
	if cnvta<>0
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if p61$[136,136]="Y" and pol.currfact<>0 ! going from base to costing um 
			let cnvcu[0]=1
			let cnvca[0]=x3
			let cnvca[1]=pol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=cnvca[0]
		endif
	endif
	WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! Unit cost
	! extended cost
	let dsp_extucost= pol.extUnitCost
	if p61$[136,136]="Y" and pol.currfact<>0 
		let cnvcu[0]=1
		let cnvca[0]=dsp_extncost
		let cnvca[1]=pol.currfact
		call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
		let dsp_extucost=fnr(cnvca[0])
	endif
	if (source=371 or source=381) and pol.currqtyrcvd<>0
		! update extended net cost                                          
		lineqty = pol.currqtyrcvd-pol.freeqtyrcvd 
		if source=381 let lineqty=pol.currqtyrcvd ! +pol.freeqtyrcvd
		lineum = pol.CostUM                                                 
		linecost = pol.unitcost                                              
		lineextamt = 0                                                      
		LbsUnit = pol.LbsUnit                                               
		LbsFact = pol.LbsFactor   
		currfact=0 ! pol.currfact
		Call CalcExtAmt(lineqty,lineum,linecost,lineextamt,LbsUnit,LbsFact,currfact) 
		pol.extuNITCost = lineextamt
		let dsp_extucost=lineextamt
		if p61$[136,136]="Y" and pol.currfact<>0 
			lineum=pol.costum
			linecost=pol.unitcost
			lineextamt=0
			lbsunit=pol.lbsunit
			lbsfact=pol.lbsfactor
			currfact= pol.currfact
			call calcextamt(lineqty,lineum,linecost,lineextamt,lbsunit,lbsfact,currfact)
			let dsp_extucost=lineextamt	
		endif
	endif
	Webstr$=Webstr$,Ltrim$(dsp_extucost using "##########.##"),fdel$ ! extended unit cost pol.ExtUnitCost
	WebStr$=WebStr$,Str$(Cost_Lev[2]),fdel$ ! last cost security
	WebStr$=WebStr$,RTrim$(CostUM$),fdel$ ! Cost, UM , 
	WebStr$=WebStr$,Str$(pol.costum),fdel$ ! cost um id
	! free goods
	let x3=0
	Cnvtu[0]=0;Cnvtu[1]=pol.qtyum;Cnvtu[2]=1
	CNVTA=pol.Freegoods
	if (cnvta)
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	endif
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! free goods
	tmp$=clrtxtc$(e$,pol.VendProdCode$)
	Webstr$=webstr$,RTrim$(tmp$),fdel$ !  vendor item code
	!Webstr$=webstr$,rtrim$(pol.VendProdCode$),fdel$! vendor item code
	! Rcvd Qty to Date l3[3]
	let x3=0
	Cnvtu[0]=0;Cnvtu[1]=pol.qtyum;Cnvtu[2]=1
	CNVTA=pol.qtyrcvdtodate
	if (cnvta)
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	endif
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! due date
	if pol.DueDate
		let xdate$=pdate$(pol.DueDate)
	else
		let xdate$=" ",xdate$
	endif
	webstr$=webstr$,rtrim$(xdate$),fdel$ ! due date
	WebStr$=WebStr$,LTrim$(pol.CbfUnit Using "##########.##"),fdel$ ! cube unit
	tmp$=Str$(pol.cbfFactor)
	call factorum(tmp$) ! get um for factor
	WebStr$=WebStr$,Str$(pol.CbfFactor),fdel$,Rtrim$(tmp$),fdel$ ! cube factor & um
	if (source=371 or source=381) and pol.currqtyrcvd<>0
	        lineqty = pol.currqtyrcvd
		if source=381 let lineqty=pol.currqtyrcvd+pol.freeqtyrcvd
		pol.ExtWght = calcextwgt(lineqty,pol.LbsUnit,pol.LbsFactor)    
		pol.ExtCubes = calcextcube(lineqty,pol.cbfunit,pol.cbffactor)
	endif
	Webstr$=webstr$,Ltrim$(pol.ExtCubes Using PMask$),fdel$ ! extended cubes
	WebStr$=WebStr$,LTrim$(pol.LbsUnit Using "##########.##"),fdel$ ! wgt unit
	tmp$=Str$(pol.LbsFactor)
	call factorum(tmp$) ! get um for factor
	WebStr$=WebStr$,Str$(pol.LbsFactor),fdel$,Rtrim$(tmp$),fdel$ ! wgt factor & um
	Webstr$=webstr$,Ltrim$(pol.ExtWght Using PMask$),fdel$ ! extended weight
	! freight charge
	If closed<>0 let pol.frgtunitcost=pol.prevfrgtunit
	cnvtu[0]=0;cnvtu[1]=pol.costum;cnvtu[2]=2
	Cnvta=pol.frgtunitcost
	let x3=0
	if cnvta<>0
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if p61$[136,136]="Y" and pol.currfact<>0 ! goinh from base to costing um
			let cnvcu[0]=1
			let cnvca[0]=x3
			let cnvca[1]=pol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=cnvca[0]
		endif
	endif
	WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! Freight Unit cost
	! misc charge
	If closed<>0 let pol.MiscChrgUnit=pol.prevMiscChrgUnit
	cnvtu[0]=0;cnvtu[1]=pol.costum;cnvtu[2]=2
	Cnvta=pol.MiscChrgUnit
	let x3=0
	if cnvta<>0
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if p61$[136,136]="Y" and pol.currfact<>0 ! goinh from base to costing um
			let cnvcu[0]=1
			let cnvca[0]=x3
			let cnvca[1]=pol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=cnvca[0]
		endif
	endif
	WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! Misc cost
	! hazard y/n
	let tmp$="N"
	if pol.HazItemFlag <>0 let tmp$="Y"
	WebStr$=Webstr$,tmp$,fdel$
	! Apply freight y/n
	let tmp$="N"
	if pol.applyfrt<>0 let tmp$="Y"
	Webstr$=Webstr$,tmp$,fdel$
	let plcost=pr.pendlastcost
	let pldate=pr.pendlastcostdate
	if p9$[32,32]="Y"
		let plcost=pw.pendpocost
		let pldate=pw.pendpocostdate
	endif
	! pending cost
	cnvtu[0]=0;cnvtu[1]=pol.costum;cnvtu[2]=2
	Cnvta=plcost
	let x3=0
	if cnvta<>0
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if p61$[136,136]="Y" and pol.currfact<>0  ! goinh from base to costing um
			let cnvcu[0]=1
			let cnvca[0]=x3
			let cnvca[1]=pol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=cnvca[0]
		endif
	endif
	if x3<>0 and cost_lev[2]<>0
		WebStr$=WebStr$,LTrim$(X3 Using PMask$),fdel$ ! pend last cost
	else
		webstr$=webstr$,"",fdel$
	endif
	! pending po date
	let xdate$=""
	if pldate<>0 and x3<>0 and cost_lev[2]<>0
		let xdate$=pdate$(pldate)
	else
		let xdate$=" ",xdate$
	endif
	webstr$=webstr$,rtrim$(xdate$),fdel$
	webstr$=webstr$,ltrim$(pol.itemno using "###"),fdel$
	webstr$=webstr$,str$(closed),fdel$
	! line type 
	let tmp$="STK"
		
	if zline 
		let pr.rolllbItem$="N"
		chgstk=0
		let tmp$="MSG"
	endif
	if nonstk
		let pr.rolllbItem$="N"
		let pr.rollinv$="N"
		let tmp$="NSTK"
		chgstk=0
	endif
	if tmp$="STK"
		let chgstk=1
		if closed let chgstk=0
		if pr.ComdtyCode$="LABR" let chgstk=0 
		if pr.ComdtyCode$="MACH" let chgstk=0 
		if pr.ComdtyCode$="TIME" let chgstk=0
		!If pw.prodgrp>0 ! check prod group to update inventory
			! if pram[3]=0 let chgstk=0
		!endif
		if poh.type=1 let chgstk=0 ! direct -- no stock change 
		if poh.type=2 AND P60$[22,22]="N" let chgstk=0 ! indirect -- update stock = n -- do not update

		
	endif
	webstr$=webstr$,rtrim$(tmp$),fdel$
	webstr$=webstr$,pr.RollLbItem$,fdel$ ! roll item
	! chgstk
	let tmp$="Y"
	if not (chgstk) let tmp$="N"
	webstr$=webstr$,tmp$,fdel$ ! change stock flag -- could be based on prod group
	! qty in receiving process l3[4]
	let x3=0
	Cnvtu[0]=0;Cnvtu[1]=pol.qtyum;Cnvtu[2]=1
	CNVTA=pol.CurrQtyRcvd
	if (cnvta)
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	endif
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! 
	webstr$=webstr$+str$(pol.salesord )+fdel$ ! sales order number
	webstr$=webstr$+str$(pol.salesordline)+fdel$ ! sales order line #
	 X3 = UMtoFactor(pol.qtyum) ! get qty um factor
	
	WebStr$=WebStr$,str$(x3),fdel$ ! qty factor
	
	x3=umtofactor(pol.costum) ! get um for factor
	WebStr$=WebStr$,str$(x3),fdel$ ! cost um factor
	
	webstr$=webstr$+str$(closedshort)+fdel$
	Cnvtu[0]=0;Cnvtu[1]=pol.qtyum;Cnvtu[2]=1
	x3=0
	CNVTA= pol.freeqtyrcvd
	if (cnvta)
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	endif
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! 
	
	Cnvtu[0]=0;Cnvtu[1]=pol.qtyum;Cnvtu[2]=1
	x3=0
	CNVTA= pol.totfreeqtyrcvd
	if (cnvta)
		X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	endif
	WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ !
	tmp$="N" \ if pr.SerNoTrack$="Y" let tmp$="Y"
	webstr$=webstr$,tmp$,fdel$ ! sn track
	tmp$ = XUnit$(pr.UMVendOrd,ccc)                                                     
	WebStr$ = WebStr$,RTrim$(tmp$),fdel$                                                                   
	x3 = UMtoFactor(pr.UMVendOrd)                                             
	WebStr$ = WebStr$,Str$(pr.UMVendOrd),fdel$,Str$(x3),fdel$ ! um id, um factor
	tmp$="N" \ if p61$[105,105]="Y" let tmp$="Y"
	if source<>361 AND source<>0 let tmp$="N" ! only PO Entry/Edit
	webstr$=webstr$,tmp$,fdel$ ! prompt on po qty>order qty
	if tmp$="Y" and pol.SalesOrd>0 and pol.SalesOrdLine>0
		tmp3=getsordqty()
		webstr$=webstr$,LTrim$(tmp3 using QMask$),fdel$ ! tied order qty
	Else
		webstr$=webstr$,"0",fdel$ ! no ties or flag=N
	Endif
	let tmp$="N"
		if p61$[104,104]="Y"
			if pr.rollinv$="Y" let tmp$="Y"
			if poh.type=1 let tmp$="N"
			if poh.type=2 AND P60$[22,22]="N" let tmp$="N"
		endif
	webstr$=webstr$,tmp$,fdel$
	tmp$="N" \ if pr.lotctrl$="Y" let tmp$="Y"
	If OType=2 or nonstk or zline or chgstk=0 let tmp$="N"
	If p9$[1,1] = "N" Let tmp$ = "N" ! Y NOT ACCEPTABLE   
	webstr$=webstr$,tmp$,fdel$ ! lot cntrl
	tmp$=blank$;tmp$="" ! clear
	tmp$=chktagfle$()
	WebStr$=WebStr$,tmp$[1,1],fdel$ ! do notes exist?
	tmp$="N" ! rasl loc edit
	if (source=371 or source=381) and chgstk ! only on RTS/DM
		whse=pol.Whse ! or is it poh.Warehouse?
		if whse<1 or whse>99 or fra(whse) let whse=poh.Warehouse
		If Whse>0 and Whse<=99
			!call ChkWhRasl(e$,intco,Ctlc,WHI,Whse,RASL[])
			WHIR=Whse-1
			Read record #WHI,WHIR,0;WHI.;
		endif
		if p9$[41,41]="W" let rasl=whi.useRasl
		if p9$[41,41]="Y" let rasl=1
		if Rasl ! using rasl - is allow edit flag set?
			if whi.PoRtsDflt=1 let tmp$="Y"
			if source=381 let tmp$="Y" ! debit memo
		endif
	Endif ! rts rasl loc edit allowed
	WebStr$=WebStr$,tmp$[1,1],fdel$ ! allow rasl alloc?
   ENDIF ! of no zlines (from near beginning)
	List$[row]=WebStr$
	Let row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	if debugdetail
		dmsg$="Main Detail "+Str$(pono)+"-"+Str$(pol.itemno)+" "+pol.prodcode$+Message$ \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
 end try
end sub ! LineMainDtl
! 
!--------------------------------------------------------------------
Sub getpolines()
! go thru passed order and send existing lines back
 Try
	Dim KOL$[60],KPW$[60],KCM$[50],KLP$[60],keypoh$[30]
	Dim ZOL$[60],xdate$[10]
	Dim 1%,FCDays,cnvtu[2],elflag,flags[11]
	Dim 2%,PONo,row,tmpcnt,JDate[5],FDate
	Dim 3%,OLR,FutCost,CNVTA,Amount,rec_poh
	Dim 3%,totordamt,totordcube, totordcube,totordqty
	Dim 3%,totrcvdamt,totrcvdwgt, totrcvdcube,totrcvdqty
	! not sure what to do with message lines
	! Dim ZROL. as rolnew ! for zlines (get data for it before sending line)
	if debugdetail
		dmsg$="Start get Existing Lines" \ Call updatelog(debug)
	Endif
	let totordamt=0;totordcube=0;totordcube=0;totordqty=0
	let totrcvdamt=0;totrcvdwgt=0; totrcvdcube=0;totrcvdqty=0
	ReturnStatus=1
	Message$="OK"
	! Call dxsave(0,"tmp/subadjgldist.txt!")
	Call DXGet("POID",tmp$)
	X2=tmp$
	If X2<1 or X2>999999 or Fra(X2) ! not valid
		ReturnStatus=0
		Message$="Purchase Order Number "+str$(x2)+" Not Valid"
		goto golDone:
	Endif
	PONo=x2
	Rec_poh=getpohrec(e$,ch_poh,pono,poh.)
	
	If rec_poh<=0 ! not found
		ReturnStatus=0
		Message$="Purchase Order "+str$(x2)+" Not On File"
		goto golDone:
	Endif
	Call GetVend()
	Call DXGet("SOURCE",tmp$)
	SOURCE=tmp$
	! set list header (SIMILAR TO PRODDETAIL ACTION!)
	elflag=9 ! existing Line Flag (for detail to string) as add'l fields needed
		Clear List$[]
		List$[0]=bsdel$,"LINEDETAIL",fdel$
		WebStr$="ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$
		Webstr$=Webstr$,"ComID",fdel$,"ComDesc",fdel$
		WebStr$=WebStr$,"QtyOrder",fdel$,"QtyUM",fdel$,"QtyUMID",fdel$
		WebStr$=Webstr$,"QtyToShip",fdel$,"LastQtyRcvd",fdel$
		webstr$=webstr$,"LastRcvdDate",fdel$
		Webstr$=Webstr$,"Stock",fdel$,"Wh",fdel$
		Webstr$=Webstr$,"Net Cost",fdel$,"Ext Net Cost",fdel$
		Webstr$=Webstr$,"Disc%",fdel$,"DiscDollars",fdel$
		WebStr$=WebStr$,"UnitCost",fdel$,"ExtUnitCost",fdel$,"CostSecurity",fdel$
		WebStr$=WebStr$,"CostUM",fdel$,"CostUMID",fdel$
		WebStr$=WebStr$,"QtyFreeGoods",fdel$,"VendItemCode",fdel$
		WebStr$=WebStr$,"QtyRecvdToDate",fdel$,"DueDate",fdel$
		WebStr$=WebStr$,"Cube",fdel$,"CubeFactor",fdel$,"CubeUM",fdel$
		WebStr$=WebStr$,"ExtCube",fdel$
		WebStr$=WebStr$,"Weight",fdel$,"WgtFactor",fdel$,"WgtUM",fdel$
		WebStr$=WebStr$,"ExtWgt",fdel$
		Webstr$=webstr$,"Frt",fdel$,"MiscChrg",fdel$
		webstr$=webstr$,"Hazard",fdel$,"ApplyFrgt",fdel$
		webstr$=webstr$,"PendPoCost",fdel$
		webstr$=webstr$,"PendPoCostDate",fdel$
		WebStr$=WebStr$,"LineNum",fdel$
		webstR$=webstr$,"Closed",fdel$
		webstr$=webstr$,"Ltype",fdel$
		webstr$=webstr$,"Roll",fdel$
		webstr$=webstr$,"ChgStkFlag",fdel$
		webstr$=webstr$,"QtyRecv",fdel$ ! 
		webstr$=webstr$,"SlsOrdNum",fdel$
		webstr$=webstr$,"SlsOrdLine",fdel$
		webstr$=webstr$,"QtyFactor",fdel$
		webstr$=webstr$,"CostFactor",fdel$
		webstr$=webstr$,"CLOSEDSHORT",fdel$
		webstr$=webstr$,"FREEQTYRECV",fdel$
		webstr$=webstr$,"FREEQTYRECVTODATE",fdel$
		webstr$=webstr$,"SERIALNO",fdel$
		WebStr$ = WebStr$,"VendOrdUM",fdel$,"VendOrdUMID",fdel$,"VendOrdUMFact",fdel$
		Webstr$=Webstr$,"POUPSOQ",fdel$,"OrdQty",fdel$
		Webstr$=webstr$,"ROLLINVENTORY",FDEL$
		Webstr$=webstr$,"LotControl",fdel$
		Webstr$=webstr$,"NOTES",fdel$
		Webstr$=Webstr$,"RASL",fdel$
		List$[1]=WebStr$
		Row=2;tmpcnt=maxcnt
		Call DXGet("SOURCE",tmp$)
		SOURCE=tmp$
		Call DXGet("DISPLAYOPT",tmp$)
		displayopt=tmp$
		if displayopt<0 or displayopt>2 
			let displayopt=0
		endif
	! okay - see if lines
	KOL$=" ",KOL$;NumLines=0
	KOL$=PONo Using "######"
	! what if start with or only zlines on Purchase order??
	Do
		rec_pol=filegetpoline(e$,ch_pol,">",1,kol$,pol.)
		If rec_pol<0 exit do
		X2=kol$[1,6] \ if x2<>pono exit do
		! flag for non-stock item in logic
		LET X2=pol.flags ! ! REM UNPACK pol.Flags TO FLAGS[x] 
	        FOR K=0 TO 11                     
		   LET FLAGS[K]=SGN(FRA(X2/2)) \ LET X2=INT(X2/2) 
		NEXT K
		
		NonStk=flags[0]
		CLOSED=0
		if poh.status=7 let closed = 99
		if pol.status=3 let closed = 99
		! Closed=flags[1]
		closedshort=flags[1]
		Zline=flags[2] 
		
		!CALL $LOGIC,1,2^0,pol.flag,NonStk ! 0 = stock , 1 = nonstock
		!CALL $LOGIC,1,2^1,pol.flag,Closed ! 0 = open  <>0 closed / short
		!CALL $LOGIC,1,2^2,pol.flag,Zline  ! <>0 message line   
		
		! get/read appropriate records (prod,prodwhse,comm,lastprice
		If Not(NonStk) ! it's a prod
			PRR=pol.ProdDescRec
			Read record #PRC,PRR,0;PR.;
			KPW$=" ",KPW$
			Kpw$=pol.prodcode$+pol.whse Using "##"
			PWR=filegetprodwhse(e$,PWC,"=",1,KPW$,pw.)
			if PWR<0 ! not found
				Clear pw.
				If PWR=-1 ! not found - add?
					E$=""
					Whbld[0]=PWC;Whbld[1]=pol.whse;WhBld[2]=pr.PrimVend
					Call mxwhcreate(e$,IntCo,pol.prodcode$,WHBLD[])
					PWR=Whbld[2]
					Read record #PWC,PWR,0;PW.;
					if pwr>0 let e$=""
				Endif
			Endif
		Else
			Clear pr.
			Clear pw.
		Endif
		! always set up pr. w/line factors
		LineNo=pol.ItemNo
		if (NonStk)
			Read Record #ch_nstk,pol.ProdDescRec; nstk.;
		endif
		Call SetPRtoPol() !!! 
		KCM$=" ",KCM$
		KCM$=pr.ComdtyCode$
		CMR=filegetcommhead(e$,cmc,"=",1,KCM$,cmc.)
		If CMR<1 Clear cmc.
		if displayopt>0
			if displayopt=1 and closed=99 goto endgetpoline: ! end getting po line loop 
			if displayopt=2 and closed<>99 goto endgetpoline:  ! CLOSED ONLY
		endif
		Call LineMainDtl() ! set up web string
		NumLines=NumLines+1
		endgetpoline: ! end getting po line loop 
		if source=371 and Zline=0 and closed=0 ! only open lines
			call calcpototals()
		endif
		if source=381 and Zline=0 and closed=0 ! only open lines
			call calcpototals()
		endif
	Loop ! done with order
	List$[row]=esdel$ ! finished
	call AddToStr(e$,rstr$,List$[])
	GolDone: ! finish ord line get
	! status section
	if debugdetail
		dmsg$="Existing Lines "+Str$(Orderno)+" TTL "+Str$(NumLines)+" "+Message$ \ Call updatelog(debug)
	Endif
	if source=371 ! receiving only
		clear list$[]
		List$[0]=bsdel$,"RTSTotal",fdel$
		webstr$=""
		WebStr$="TotAmount",fdel$
		WebStr$=webstr$,"TotWeight",fdel$
		WebStr$=Webstr$,"TotCubes",fdel$
		Webstr$=Webstr$,"TotPiece",fdel$
		webstr$=webstr$,"TotRecvAmt",fdel$
		webstr$=webstr$,"TotRecvWgt",fdel$
		webstr$=webstr$,"TotRecvCube",fdel$
		webstr$=webstr$,"TotRecvPiece",fdel$
		List$[1]=WebStr$
		if returnstatus<>0
			webstr$=""
			Webstr$=RTrim$(TotOrdAmt Using "-----------.##") + fdel$   
			Webstr$=webstr$+RTrim$(TotOrdWgt  Using "-----------.##") + fdel$ 
			Webstr$=webstr$+RTrim$(TotOrdCube Using "-----------.##") + fdel$ 
			Webstr$=webstr$+RTrim$(TotOrdQty Using "---------.##") + fdel$
			Webstr$=webstr$+RTrim$(TotrcvdAmt Using "-----------.##") + fdel$   
			Webstr$=webstr$+RTrim$(TotrcvdWgt  Using "-----------.##") + fdel$ 
			Webstr$=webstr$+RTrim$(TotrcvdCube Using "-----------.##") + fdel$ 
			Webstr$=webstr$+RTrim$(TotrcvdQty Using "---------.##") + fdel$
			LIST$[2]=Webstr$
		endif
		call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
		Call AddToStr(e$,rstr$,esdel$) ! end of section 
	endif
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
	! 
	! call programdump("/tmp/ollog6!","")
 else
    include "src/callsuberr.inc"
 end try
end sub ! getpolines
! 
!--------------------------------------------------------------------

! --------------------------------------------------------------------
Sub SetNewProdline() ! purchase orders
! take pad list - send line details
 Try
	Call DXGet("POID",tmp$)
		if tmp$="" 
			let e$="Purchase Order # is missing "
			
			Let ReturnStatus=0
			Goto PDSendDone:
		Endif
		PONo=tmp$
		If poNo>0 and poNo<999999 and Not(Fra(OrderNo))	
			Rec_poh=getpohrec(e$,ch_poh,pono,poh.)
			If rec_poh<=0 ! no order found
				Let e$="Purchase Order # "+str$(pono)+" Not Found"
				Let ReturnStatus=0
				Goto PDSendDone:
			Endif
		Endif
		call verifystat()
		if returnstatus=99 goto Pdsenddone:
		Call GetVend()
		Call DXGet("TTLPRODS",tmp$)
		Let NumProds=tmp$
		if NumProds<1 ! HAS TO BE AT LEAST 1!
			let e$="NO NUMBER OF ITEMS SENT"
			Let ReturnStatus=0
			Goto PDSendDone:
		Endif
		ReturnStatus=1
		Message$="OK" 
		! set list header
		Clear List$[]
		List$[0]=bsdel$,"PRODUCTDETAIL",fdel$
		WebStr$="ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$
		Webstr$=Webstr$,"ComID",fdel$,"ComDesc",fdel$
		WebStr$=WebStr$,"QtyOrder",fdel$,"QtyUM",fdel$,"QtyUMID",fdel$
		WebStr$=Webstr$,"QtyToShip",fdel$,"LastQtyRcvd",fdel$
		webstr$=webstr$,"LastRcvdDate",fdel$
		Webstr$=Webstr$,"Stock",fdel$,"Wh",fdel$
		Webstr$=Webstr$,"Net Cost",fdel$,"Ext Net Cost",fdel$
		Webstr$=Webstr$,"Disc%",fdel$,"DiscDollars",fdel$
		WebStr$=WebStr$,"UnitCost",fdel$,"ExtUnitCost",fdel$,"CostSecurity",fdel$
		WebStr$=WebStr$,"CostUM",fdel$,"CostUMID",fdel$
		WebStr$=WebStr$,"QtyFreeGoods",fdel$,"VendItemCode",fdel$
		WebStr$=WebStr$,"QtyRecvToDate",fdel$,"DueDate",fdel$
		WebStr$=WebStr$,"Cube",fdel$,"CubeFactor",fdel$,"CubeUM",fdel$
		WebStr$=WebStr$,"ExtCube",fdel$
		WebStr$=WebStr$,"Weight",fdel$,"WgtFactor",fdel$,"WgtUM",fdel$
		WebStr$=WebStr$,"ExtWgt",fdel$
		Webstr$=webstr$,"Frt",fdel$,"MiscChrg",fdel$
		webstr$=webstr$,"Hazard",fdel$,"ApplyFrgt",fdel$
		webstr$=webstr$,"PendPoCost",fdel$
		webstr$=webstr$,"PendPoCostDate",fdel$
		WebStr$=WebStr$,"LineNum",fdel$
		webstR$=webstr$,"Closed",fdel$
		webstr$=webstr$,"Ltype",fdel$
		webstr$=webstr$,"Roll",fdel$
		webstr$=webstr$,"ChgStkFlag",fdel$
		webstr$=webstr$,"QtyRecv",fdel$
		webstr$=webstr$,"SlsOrdNum",fdel$
		webstr$=webstr$,"SlsOrdLine",fdel$
		webstr$=webstr$,"QtyFactor",fdel$
		webstr$=webstr$,"CostFactor",fdel$
		webstr$=webstr$,"CLOSEDSHORT",fdel$
		webstr$=webstr$,"FREEQTYRECV",fdel$
		webstr$=webstr$,"FREEQTYRECVTODATE",fdel$
		webstr$=webstr$,"SERIALNO",fdel$
		Webstr$=webstr$,"VendOrdUm",fdel$,"VendOrdUMID",fdel$
		webstr$=webstr$,"VendOrdUmFact",fdel$
		Webstr$=Webstr$,"POUPSOQ",fdel$,"OrdQty",fdel$
		webstr$=webstr$,"RollInventory",fdel$
		webstr$=webstr$,"LotControl",fdel$
		webstr$=webstr$,"NOTES",fdel$
		webstr$=webstr$,"RASL",fdel$
		! webstr$=webstr$,"CURRFACT",fdel$
		!!! end from line detail 
		List$[1]=WebStr$
		Row=2;tmpcnt=maxcnt
		ReturnStatus=1;Message$=""
		For LD=1 to NumProds
			let e$=""
			Call DXGet("PRODID"+Str$(LD),tmp$)
			tmp$=RTrim$(tmp$)
			If tmp$="" Goto LDPDone: ! NEED A PRODUCT!
			Let PROD$=UCase$(tmp$)+Blank$
			If prod$[1,3]="+  " OR PROD$[1,6]="ZNSTK "! it's nonstock
				prod$="Z ZZZZZZZZZZ"
			Endif ! will not have um or qty for messg or nonstk?
			Call DXGet("QTY"+Str$(LD),tmp$)
			Let pQty=tmp$ ! in sum units
			Call DXGet("UM"+Str$(LD),tmp$)
			Let pUM=tmp$
			
			Call GetNewProdPoDtl(e$,List$[],tmpcnt,Prod$,Pqty,pUM,rec_poh)
			If RTRIM$(e$)<>""  ! a problem!
				Message$=Message$+rTRIM$(Prod$)+" "+E$+" " ! send prod & reason
				ReturnStatus=0
			Endif
		LDPDone: ! bypass
		Next LD ! next sent prod,qty,um
		List$[row]=esdel$
		call AddToStr(e$,rstr$,List$[])
		!
	  PDSendDone: ! finished
	  ! status section
	  If ReturnStatus=1 let message$="OK"
	  if returnstatus=0
		IF rtrim$(message$)=""
			if rtrim$(e$)<>""
				let message$=E$
			else
				let message$="Error Occured Adding Line to Purchase Order"
			endif
		endif
	  endif
	  if debugdetail
		dmsg$="List Setup "+Str$(Pono)+" TTL IN "+Str$(NumProds)+" "+Message$ \ Call updatelog(debug)
	  Endif
	  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	  call AddToStr(e$,rstr$,WebStr$)
	  call SetOutPut(e$,rstr$)
 else
    include "src/callsuberr.inc"
 end try
end sub ! SetNewProdline
! 
!--------------------------------------------------------------------
sub UpdtLines()
! lines are being sent back to PM
! changed to 1 at a time (as user leaves line - save it!)
 Try
	Dim pOLKey$[60],X$[20],NSFKey$[60]
	 Dim 1%,STAT[2],CH[10],3%,REC[10]
	Dim 1%,CNVTU[2],FLAG[9],X1[9]
	Dim 1%,NewLn,HFlg[16],Credit
	Dim 2%,X2[9],NumLines,ShipDate,JDate[5],lctr
	Dim 3%,CNVTA,AMOUNT,X3[9],V3[99]
	Dim 3%,WHBLD[3],S9[20],tmprec

	Dim Npol. as poline ! store new sent data
	dim npw. as prodwhse ! store new warehouse if need
	
	if debugdetail
		dmsg$="Start Line Update" \ Call updatelog(debug)
	Endif
	ReturnStatus=1
	Message$="OK"
	Call DXGet("SOURCE",tmp$)
	SOURCE=tmp$
	ch_por=0
	if p61$[104,104]="Y" and source=371 ! roll inventory
		ch_por=findchannel()
		let f$="3/SPOROLL"+STR$(INTCO)
		try
			open #ch_por,f$
		else
			let p61$[104,104]="N"
			ch_por=0
		end try	
	endif
	Call DXGet("POID",tmp$)
	If tmp$="" goto UDLDone:
	PONo=tmp$
	If PONo<1 or PONo>999999 or Fra(PONo)
		ReturnStatus=0
		Message$="PURCHASE ORDER "+STR$(PONO)+" NUMBER INVALID"
		Goto UDLDone
	Endif
	rec_poh = getpohrec(e$,ch_poh,POno,poh.)
	
	If rec_poh<=0 ! not found
		ReturnStatus=99
		Message$="PURCHASE ORDER "+STR$(PONo)+" WAS NOT FOUND"
		goto udldone                
	Endif
	if returnstatus<>0
		call verifystat()
		if returnstatus=99 goto udldone:
	endif
	IF p60$[46,46]="Y" ! import section
		ch_poof= OpenFile("POOCNFRT",Intco,"R") 
		ch_pocd= OpenFile("POCDUTY",Intco,"R") 
		ch_pobr= OpenFile("POBROKER",Intco,"R") 
	endif
	Call DXGet("TTLLNS",tmp$) ! number of lines sent
	let numlines=tmp$
	If numlines<1 or NumLines>999
		let returnstatus=0
		Message$="PURCHASE ORDER "+STR$(PONO)+" Invalid Number of Line to Update"
		goto udldone ! cant update
	endif
	let boremflag=0
	if source=381
		if p60$[27,27]="S" let boremflag=1
		if p60$[27,27]="B" let boremflag=2
		if p60$[27,27]="E" let boremflag=3
	endif
	! now read in stuff
	Message$="" ! in case issues in loop
	For lctr=1 to NumLines ! this is the loop 
		E$="" ! clear for this loop
		rec_pol=0;NewLn=0
		Clear npol.
		Clear pr.
		Clear pw.
		Clear prdesc. ! nonstock
		Call DXGet("LINENUM"+str$(lctr),tmp$) ! +Str$(X1),tmp$)
		npol.itemno=tmp$ ! line # (zero on new lines)
		LineNo=npol.itemno
		if npol.itemno ! get prev data
			polkey$=" ",polkey$
			polkey$[1,6]=PONo Using "######"
			Polkey$[7,9]=npol.itemno using "###"
			polkey$[10]="" ! cut to length (space @ 10)
			rec_pol=filegetpoline(e$,ch_pol,"=",1,polkey$,pol.)
			if rec_pol<=0 ! what do we do if not found?
				clear pol.
				npol.itemno=0 ! treat as new?
				newln=0
				goto Createnewline:
			Endif
			If rec_pol>0
				newln=1
				! flag for non-stock item in logic               
				X2 = pol.flags ! ! REM UNPACK pol.Flags TO FLAGS[
				For K = 0 To 11                                  
					flags[K] = Sgn(Fra(X2 / 2)) \ X2 = Int(X2 / 2) 
				Next K                                           
				NonStk = flags[0]                                
				ClosedShort = flags[1]                                
				ZLine = flags[2]
				CLOSED=0
				if poh.status=7 let closed=99
				if pol.status=3 let closed=99
				if poh.status=14 let closed=99
				if pol.status=14 let closed=99
				if (source=371 or source=381) and closed<>0 ! do not update closed lines
					goto ELDLine
				endif
				if closed<>0 goto eldline:
				if NonStk<>0 
					rec_nstk=pol.ProdDescRec
					Read record #cH_nstk,rec_nstk,0;nstk.;
					PRR=0;PWR=0
					clear pr.
					clear pw.
				Endif
				If Nonstk=0 ! get prod & whse
					PRR=pol.ProdDescRec
					Read record #PRC,PRR,0;pr.;
					Tmp$=" ",tmp$
					tmp$=Pr.ProdCode$+pol.Whse Using "##"
					PWR=filegetprodwhse(e$,PWC,"=",1,tmp$,pw.)
					if PWR<0 ! not found - add new
						Clear pw.
						If PWR=-1 ! not found
							E$=""
							Whbld[0]=PWC;Whbld[1]=pol.whse;WhBld[2]=pr.PrimVend
							Call mxwhcreate(e$,IntCo,pol.PRODCode$,WHBLD[])
							PWR=Whbld[2]
							Read record #PWC,PWR,0;PW.;
							if pwr>0 let e$=""
						Endif
					Endif
				Endif
			Endif
		Else
			Createnewline: ! createnewline
			Clear pol. ! clear
			Clear nstk.
			Call DXGet("LTYPE"+str$(lctr),tmp$) ! +Str$(X1),tmp$) ! line type (stk,nstk,msg,del)
			tmp$=UCase$(tmp$)
			ZLine=0;NonStk=0;Stk=0;Delline=0
			if tmp$="MSG" let ZLine=1;NonStk=1
			If tmp$[1,4]="NSTK" let NonStk=1
			if tmp$[1,3]="STK" let Stk=1
		
			if tmp$="DEL" let Nonstk=1! deleting line
			
			If not(stk) and not(nonStk) ! has to be one or the other!
				E$="NO LINE TYPE PASSED"
				goto ELDLine
			Endif
			Call DXGet("PRODID"+str$(lctr),tmp$) ! +Str$(X1),tmp$)
			npol.ProdCode$=UCase$(tmp$)+Blank$
			If Not(nonStk) ! get product now (for um's)
				Prodkey$=" ",prodkey$
				prodkey$=npol.ProdCode$
				PRR=filegetprod(e$,PRC,"=",1,ProdKey$,pr.)
				If PRR<0 clear pr. ! switch to non-stk? bomb?
			Else ! Nonstk
				if not(zline) ! just + items - dropping off leading spaces
					If pol.ProdCode$<>npol.ProdCode$ ! code changed!? dropped spaces?
						if npol.prodcode$[1,1]<>" " and pol.prodcode$[1,1]=" "
							if npol.prodcode$[1,11]=pol.prodcode$[2,12]
								let npol.prodcode$=pol.prodcode$
							endif
						endif
					endif
				endif
			Endif
		Endif
		If rec_pol>0 
			Read Record #ch_pol,rec_pol,0;npol. ! read / lock with prev values
			newln=0
		else
			 Let NewLn=1
		endif
		
		! we assume qty/price/cost are passed in display u/m
		Call DXGet("LTYPE"+str$(lctr),tmp$) ! +Str$(X1),tmp$) ! line type (stk,nstk,msg,del)
		tmp$=UCase$(tmp$)
		ZLine=0;NonStk=0;Stk=0;Delline=0
		if tmp$="MSG" let ZLine=1;NonStk=1
		If tmp$[1,4]="NSTK" let NonStk=1
		if tmp$[1,3]="STK" let Stk=1
		if npol.itemno=0 and tmp$[1,4]="NSTK" ! how did this happen
			E$="New Nonstock Line Cannot be Created. Need Line Number."
			goto ELDLINE:
		endif
		if tmp$="DEL" ! deleting line
			if closed<>0 goto eldline:
			if pol.QtyRcvdToDate<>0
				let e$="Cannot Delete. Line Partially Received. "
				goto eldline:
			endif
			let delline=1
			If rec_pol>0 call DELPOLINE(PoNo,npol.itemno,rec_pol)
			goto ELDLine
		Endif
		
		If not(stk) and not(nonStk) ! has to be one or the other!
			E$="NO LINE TYPE PASSED"
			goto ELDLine
		Endif
		
		Pol.Status= 1;Debit=0
		Npol.status=1
		if poh.Status>10 and poh.status<=14
			let npol.Status=11;debit=1;pol.status=11 ! determine order/credit?
		endif
		If poh.status=97
			let npol.Status=11;debit=1;pol.status=11 ! determine order/credit?
		endif
		npol.poNum=pono
		Call DXGet("DESC1"+str$(lctr),tmp$) ! +Str$(X1),tmp$)
		strgok=chkbadchars(e$,tmp$)
		if not(strgok)
			returnstatus=0
			Message$="Invalid Characters in Description 1"
			goto ELDLINE
		Endif
		npol.Desc1$=tmp$+Blank$
		Call DXGet("DESC2"+str$(lctr),tmp$) ! +Str$(X1),tmp$)
		strgok=chkbadchars(e$,tmp$)
		if not(strgok)
			returnstatus=0
			Message$="Invalid Characters in Description 2"
			goto ELDLINE
		Endif
		npol.Desc2$=tmp$+Blank$
		Call DXGet("WH"+str$(lctr),tmp$) ! +Str$(X1),tmp$)
		npol.whse=tmp$ \ if npol.whse<1 or npol.whse>99 let npol.whse=poh.warehouse
		if npol.whse<>pol.whse and nonstock=0 ! warehouse change for stock item
			Tmp$=" ",tmp$
			tmp$=Pr.ProdCode$+npol.Whse Using "##"
			tmprec=filegetprodwhse(e$,PWC,"=",1,tmp$,npw.)
			if tmprec<0 ! not found - add new
				Clear npw.
				If tmprec=-1 ! not found
					if boremflag=3
						let returnstatus=0
						e$="There no stock in warehouse "+str$(npol.whse)+ " for product "+rtrim$(Pr.ProdCode$)
						let e$=e$+". Please change warehouse."    
						goto eldline
					endif
					if boremflag=1 or boremflag=2

						let returnstatus=2
						let message$=message$+" Warning: There is no stock in warehouse "+str$(npol.whse)+ " for product "+rtrim$(Pr.ProdCode$)
						let message$=message$+". You may wish to change warehouse. "
					endif
					E$=""
					Whbld[0]=PWC;Whbld[1]=npol.whse;WhBld[2]=pr.PrimVend
					Call mxwhcreate(e$,IntCo,npol.PRODCode$,WHBLD[])
					tmprec=Whbld[2]
					Read record #PWC,tmprec,0;nPW.;
					if pwr>0 let e$=""
				Endif			
			Endif
		endif
		If ZLine ! that's all folks
			npol.ProdCode$="Z"+Blank$
			Goto SLUChk
		Endif
		Call DXGet("STOCK"+str$(lctr),tmp$) ! +Str$(X1),tmp$) ! Y/N
		let npol.updstock=0
		if tmp$="Y" let npol.updstock=1
		!!!! cost figures !!!!
		Call DXGet("NETCOST"+str$(lctr),tmp$) ! +Str$(X1),tmp$)
		V3[1]=tmp$
		Call DXGet("UNITCOST"+str$(lctr),tmp$) ! +Str$(X1),tmp$)
		V3[2]=tmp$
		Call DXGet("DISCPCT"+str$(lctr),tmp$) ! +Str$(X1),tmp$)
		npol.DiscPct=tmp$
		Call DXGet("DISCDOLLAR"+str$(lctr),tmp$) ! +Str$(X1),tmp$)
		LET V3[3]=tmp$ !  npol.DiscUnt=tmp$
		Call DXGet("CUBE"+str$(lctr),tmp$) ! +Str$(X1),tmp$)  !!!! st
		npol.CbfUnit=tmp$
		Call DXGet("WEIGHT"+str$(lctr),tmp$) ! +Str$(X1),tmp$)
		nPol.LbsUnit=tmp$
		Call DXGet("PRODID"+str$(lctr),tmp$) ! +Str$(X1),tmp$)
		npol.ProdCode$=UCase$(tmp$)+Blank$
		If Not(nonStk) ! get product now (for um's)
			Prodkey$=" ",prodkey$
			prodkey$=npol.ProdCode$
			PRR=filegetprod(e$,PRC,"=",1,ProdKey$,pr.)
			If PRR<0 clear pr. ! switch to non-stk? bomb?
		Endif
		If npol.itemno>0 and Trim$(pol.ProdCode$)<>"" ! need a product check?
			If pol.ProdCode$<>npol.ProdCode$ ! what should we do?
				let npol.prodcode$=pol.ProdCode$
			Endif	
		Endif
		if nonstk<>0 and rtrim$(pol.prodcode$)<>"" and npol.itemno<>0
			let npol.prodcode$=pol.prodcode$
		endif
		
		call DXGet("QTYORD"+str$(lctr),tmp$) ! +Str$(X1),tmp$)
		let V3[4]=tmp$

		Call DXGet("QTYSHIP"+str$(lctr),tmp$) ! +Str$(X1),tmp$)
		Let V3[5]=tmp$
		call dxget("QTYFREE"+str$(lctr),tmp$)
		let v3[6]=tmp$
		Call DXGet("QTYUM"+str$(lctr),tmp$) ! +Str$(X1),tmp$)
		!If tmp$[1,1]>"9" ! sent text?
			R=getumrec(e$,CCC,tmp$,IntCo,PR.)
			If R<>0 let tmp$=Str$(R)
			IF R<0 !
				let e$="Invalid Quantity Unit of Measure"
				goto ELDLine: ! end of line 
			endif
		!Endif
		let nPol.Qtyum=tmp$
		Call DXGet("COSTUM"+str$(lctr),tmp$) ! +Str$(X1),tmp$)
		!If tmp$[1,1]>"9" ! sent text?
			R=getumrec(e$,CCC,tmp$,IntCo,PR.)
			If R<>0 let tmp$=Str$(R)
		!Endif
		npol.Costum=tmp$
		call dxget("VENDITM"+str$(lctr),tmp$) ! +Str$(X1),tmp$)
		strgok=chkbadchars(e$,tmp$)
		if not(strgok)
			returnstatus=0
			Message$="Invalid Characters in Vendor Item Code"
			goto ELDLINE
		Endif
		npol.VendProdCode$=tmp$+Blank$
		call dxget("APPLYFRGT"+str$(lctr),tmp$)
		if tmp$="Y" let npol.ApplyFrt=1
		if tmp$="N" let npol.ApplyFrt=0
		call dxget("HAZARD"+str$(lctr),tmp$)
		if tmp$="Y" let npol.hazitemflag=1
		if tmp$="N" let npol.hazitemflag=0
		call dxget("SLSORDNUM"+str$(lctr),tmp$)
		let npol.salesord=tmp$
		call dxget("SLSORDLINE"+str$(lctr),tmp$)
		let npol.salesordline=tmp$
		call dxget("DUEDATE"+str$(lctr),tmp$)
		xdate$ = formatdate2$(TMP$) ! from MM/DD/YYYY to yyyymmdd    
		npol.duedate = xdate$[3,8]   
		If Not(ZLine) and NonStk ! has more fields to get
			!! update for non-stock lines
		Endif
		! now the update work starts
		SLUChk: ! start update
		If ZLine ! just move in descs and done!
			If npol.itemno=0
				X2=GetNxtLine(POno)
				npol.itemno=x2
				if npol.headerrec=0 and rec_poh<>0
					let npol.headerrec=rec_poh
				endif
				rec_pol=fileupdatepoline(e$,ch_pol,"a",rcdno,npol.)
			Else ! existing line !!! need to be updated
				Read record #ch_pol,rec_pol,0;pol.
				pol.Desc1$=npol.Desc1$
				pol.Desc2$=npol.Desc2$
				if pol.headerrec=0 and rec_poh<>0
					let pol.headerrec=rec_poh
				endif
				Write record #ch_pol,rec_pol,0;pol.;
			Endif
			goto eldline ! finished
		Endif ! ALL for zlines
		
		If npol.itemno=0 ! new line
			npol.itemno=getnxtline(POno)
			
			If not(nonstk) ! need prod for add'l data product line
				ProdKey$=npol.ProdCode$+Blank$
				ProdKey$[13]=""
				PRR=filegetprod(e$,PRC,"=",1,prodkey$,pr.)
				If PRR>0
					npol.ProdDescRec=PRR
				Else
					E$="PRODUCT "+npol.ProdCode$+"NOT FOUND!"
				Endif
				Tmp$=" ",tmp$
				tmp$=Pr.ProdCode$+npol.Whse Using "##"
			
				!Prodkey$=ProdKey$+npol.Whse Using "##" ! getting the null
				PWR=filegetprodwhse(e$,PwC,"=",1,tmp$,pw.)
				if PWR<0 ! not found
					Clear pw.	
					if boremflag=3
						let returnstatus=0
						let e$="There no stock in warehouse "+str$(npol.whse)+ " for product "+rtrim$(Pr.ProdCode$)
						let e$=e$+". Please change warehouse."    
						goto eldline
					endif
					if boremflag=1 or boremflag=2
						let returnstatus=2
						let message$=message$+ " Warning: There is no stock in warehouse "+str$(npol.whse)+ " for product "+rtrim$(Pr.ProdCode$)
						let message$=message$+". You may wish to change warehouse. "
					endif
					E$=""
					Whbld[0]=PWC;Whbld[1]=npol.whse;WhBld[2]=pr.PrimVend
					Call mxwhcreate(e$,IntCo,pr.prodcode$,WHBLD[])
					PWR=Whbld[2]
					Read record #PWC,PWR,0;PW.;
					if pwr>0 let e$=""
				! Endif
				Endif
				!qum=npol.qtyum
				!pol.qtyord=V3[4]
				call setnewpol() ! set default values
				
			Else ! nonstks - set rol. to nrol. for converts
				
				PRR=0;PWR=0
				
			Endif ! of stk/nonstk
			
		endif ! of new line
		! so nrol. has new, rol. has orig
		Call setprtopol() ! set to pol. factors ! was setprtorol
		! convert sent to base as sent in display um
		! **** convert cost *****
		! V3[1] = net po cost
		CNVTU[0]=npol.CostUM;CNVTU[1]=0;CNVTU[2]=2
		if v3[1]<>0
			if p61$[136,136]="Y" and npol.currfact<>0  ! going from costing um to base
				let cnvcu[0]=2
				let cnvca[0]=v3[1]
				let cnvca[1]=npol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[1]=cnvca[0]
			endif
			cnvta=V3[1]
			npol.NetCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		else
			npol.NetCost=0
		endif
		! V3[2] = unit po cost
		if v3[2]<>0
			if p61$[136,136]="Y" and npol.currfact<>0 ! going from costing um to base
				let cnvcu[0]=2
				let cnvca[0]=v3[2]
				let cnvca[1]=npol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[2]=cnvca[0]
			endif
			cnvta=V3[2]
			npol.UnitCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		else
			npol.UNitCost=0
		endif
		! V3[3] = discount dollars
		if v3[3]<>0
			if p61$[136,136]="Y" and npol.currfact<>0 ! going from costing um to base
				let cnvcu[0]=2
				let cnvca[0]=v3[3]
				let cnvca[1]=npol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let v3[3]=cnvca[0]
			endif
			cnvta=V3[3]
			npol.DiscUnt=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		else
			npol.DiscUnt=0
		endif
		! convert quantity
		! V3[4] = QTY ORDER
		CNVTU[0]=npol.qtyum;Cnvtu[1]=0;Cnvtu[2]=1
		if v3[4]<>0
			cnvta=V3[4] ! qty orders
			npol.QtyOrd=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		else
			let npol.QtyOrd=0
		endif
		! V3[5]=QTY SHIP
		if v3[5]<>0
			cnvta=V3[5] ! qty ship
			npol.QtyShip=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			Call Dxget("SOURCE",tmp$) ! check this routine 
			let source=tmp$
		else
			let npol.QtyShip=0
		endif
		! V3[6]=QTY FREE
		if v3[6]<>0
			cnvta=V3[6] ! qty free		
			npol.Freegoods=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		else
			let npol.Freegoods=0
		endif
		! calculate extensions
		if source=381
			call dxget("QTYRECV"+str$(lctr),tmp$)
			cnvta=tmp$
			CNVTU[0]=npol.qtyum;Cnvtu[1]=0;Cnvtu[2]=1
			IF CNVTA<>0
				npol.currqtyrcvd=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			else
				npol.currqtyrcvd=0
				let Npol.currqtyrcvd=Npol.qtysHIP
			endif
			let npol.qtyship=npol.currqtyrcvd
			let npol.qtyord=npol.currqtyrcvd
			call dxget("FREEQTYRECV"+str$(lctr),tmp$)
			cnvta=tmp$
			CNVTU[0]=npol.qtyum;Cnvtu[1]=0;Cnvtu[2]=1
			IF CNVTA<>0
				npol.freeqtyrcvd=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			else
				npol.freeqtyrcvd=0
			endif
			let npol.freegoods=npol.freeqtyrcvd
		endif
		lineqty = npol.QtyShip + npol.Freegoods - npol.totfreeqtyrcvd 
		if source=381 let lineqty=npol.currqtyrcvd+ npol.freeqtyrcvd

		If lineqty<>0 
			npol.ExtWght = calcextwgt(lineqty,npol.LbsUnit,npol.LbsFactor)               
			npol.ExtCubes = calcextcube(lineqty,npol.CbfUnit,npol.CbfFactor) 
		else
			npol.ExtWght = 0
			npol.ExtCubes = 0
		endif
		! update extended unit cost                                               
		lineqty = npol.QtyShip
		if source=381 let lineqty=npol.currqtyrcvd
		lineum = npol.costum                                                       
		linecost = npol.UnitCost                                                   
		lineextamt = 0                                                            
		LbsUnit = npol.LbsUnit                                                     
		LbsFact = npol.LbsFactor 
		currfact=0 ! npol.currfact
		if lineqty<>0 and linecost<>0
			Call CalcExtAmt(lineqty,lineum,linecost,lineextamt,LbsUnit,LbsFact,currfact)
		endif
		npol.ExtUnitCost = lineextamt 
		let dsp_extucost=lineextamt
		if p61$[136,136]="Y" and npol.currfact<>0 
			lineum=pol.costum
			linecost=npol.unitcost
			lineextamt=0
			lbsunit=npol.lbsunit
			lbsfact=npol.lbsfactor
			currfact= npol.currfact
			call calcextamt(lineqty,lineum,linecost,lineextamt,lbsunit,lbsfact,currfact)
			let dsp_extucost=lineextamt	
		endif
		! update extended net cost                                                
		lineqty = npol.QtyShip 
		if source=381 let lineqty=npol.currqtyrcvd
		lineum = npol.costum                                                       
		linecost = npol.netcost                                                    
		lineextamt = 0                                                            
		LbsUnit = npol.LbsUnit                                                     
		LbsFact = npol.LbsFactor 
		let currfact=0 ! npol.currfact
		if lineqty<>0 and linecost<>0
			Call CalcExtAmt(lineqty,lineum,linecost,lineextamt,LbsUnit,LbsFact,currfact)
		endif
		npol.extNetCost = lineextamt
		let dsp_extncost=lineextamt
		if p61$[136,136]="Y" and lineextamt<>0 and npol.currfact<>0 
			lineum=pol.costum
			linecost=npol.netcost
			lineextamt=0
			lbsunit=npol.lbsunit
			lbsfact=npol.lbsfactor
			currfact= npol.currfact
			call calcextamt(lineqty,lineum,linecost,lineextamt,lbsunit,lbsfact,currfact)
			let dsp_extncost=lineextamt	
		endif
		if source=371 or source=381
			call dxget("QTYRECV"+str$(lctr),tmp$)
			cnvta=tmp$
			CNVTU[0]=npol.qtyum;Cnvtu[1]=0;Cnvtu[2]=1
			IF CNVTA<>0
				npol.currqtyrcvd=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			else
				npol.currqtyrcvd=0
			endif
			call dxget("FREEQTYRECV"+str$(lctr),tmp$)
			cnvta=tmp$
			CNVTU[0]=npol.qtyum;Cnvtu[1]=0;Cnvtu[2]=1
			IF CNVTA<>0
				npol.freeqtyrcvd=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			else
				npol.freeqtyrcvd=0
			endif
			call dxget("CLOSEDSHORT"+str$(lctr),tmp$)
			let closedshort=tmp$
			if rtrim$(tmp$)="Y" let closedshort=1
			if rtrim$(tmp$)="N" let closedshort=0
			if npol.status=1
				if npol.currqtyrcvd<>0 or npol.freeqtyrcvd<>0 or closedshort<>0
					let npol.status=2
				endif
			else
				if npol.status=2
					if npol.currqtyrcvd=0 and npol.freeqtyrcvd=0 and closedshort<>0
						let npol.status=1
					endif
				endif
			endif
			! roll inventory
			if poh.type=1 goto bypassroll: ! 
			if poh.type=2 AND P60$[22,22]="N" goto bypassroll: 
			if p61$[104,104]="Y" and pr.rollinv$="Y" and ch_por<>0
				if npol.currqtyrcvd=0 ! nothing received
					let keyroll$=" ",keyroll$
					let keyroll$[1,6]=pono using "######"
					let keyroll$[7,9]=lineno using "###"
					do
						rec_por = filegetporoll(e$,ch_por,">",1,Keyroll$,por.)
						e$=""
						IF rec_por<0 exit do
						let tmp3=keyroll$[1,6]
						if tmp3<>pono exit do
						let tmp3=keyroll$[7,9]
						if tmp3<>lineno exit do
						rec_tmp=fileupdateporoll(e$,ch_por,"d",rec_roll,por.)
						e$=""
						if rec_tmp<0
							let returnstatus=0
							let message$=message$="Error Deleting Rolls "
						endif
	 				loop
				else ! have qty received check it roll entered
					let keyroll$=" ",keyroll$
					let keyroll$[1,6]=pono using "######"
					let keyroll$[7,9]=lineno using "###"
					rec_por = filegetporoll(e$,ch_por,">",1,Keyroll$,por.)
					e$=""
					IF rec_por<0
						let returnstatus=0
						let message$=" Rolls were not entered for Line "+str$(lineno)+". "
					endif
					let tmp3=keyroll$[1,6]
					if tmp3<>pono 
						let returnstatus=0
						let message$=" Rolls were not entered for Line "+str$(lineno)+". "
					endif
					let tmp3=keyroll$[7,9]
					if tmp3<>lineno
						let returnstatus=0
						let message$=" Rolls were not entered for Line "+str$(lineno)+". "
					endif
				endif ! stock received check
			endif ! roll flag check
			bypassroll: ! 
			! let check for rasl
			let rasl=0;rtsqchg=0;LotEntd=0;locentd=0
			if not(nonstock)
				if npol.currqtyrcvd<>pol.currqtyrcvd let rtsqchg=1
				if p9$[41,41]="Y" let rasl=99
				if p9$[41,41]="W"
					let rec=npol.whse-1
					read record #whi,rec;whi.;
					If whi.UseRasl <> 0 Let rasl = 99
				endif
				IF source=381 
					call chksordlot()
					if pr.lotctrl$<>"Y" or rtsqchg or LotEntd=0
					  if (rasl and locentd=0) or not(rasl) ! rasl no loc or no rasl
						call delsordlot()  ! ?? delete all sordlots?? if lot entered??
					  endif
					endif  ! if lotcontrol or oldqty=newqty LEAVE sordlot
				ENDIF
				! only delete prev sord/spo if qtychg or not lotcontrol
				! call programdump("tmp/polrts.txt!","")
				if source=371 ! will delete ALL POLot lines!
					if (not(Rasl) and pr.lotctrl$<>"Y") or rtsqchg
						call delspolot() ! delete recvd lots?
					endif ! only nonrasl or when qtychg
				endif
				if pr.lotctrl$<>"Y" AND NOT(RASL) let rtsqchg=1
				! whi.PoRtsDflt = Enter/edit Locations / Quantites in 371? (Y/N)
				! pr.LotCtrl$="N"
				if pol.updstock<>0 and rasl=0 and rtsqchg
					if source=371 call addspolot() ! will add 1 record for FULL AMOUNT!
				endif
		    endif
		endif ! of 371/381
		flags[0] = NonStk                  
		flags[1] = ClosedShort             
		flags[2] = ZLine                   
		X2 = 0                             
		For K = 0 To 11                    
			If flags[K] Let X2 = X2 + 2 ^ K  
		Next K                             
		npol.flags = X2 
		let x3=(npol.currqtyrcvd+ npol.freeqtyrcvd)
		tmp3=(pol.currqtyrcvd+ pol.freeqtyrcvd)
		if boremflag=3 and npol.updstock<>0
			if  pol.whse<>npol.whse or tmp3<>x3 ! warehouse or qty change
			let x3=(npol.currqtyrcvd+ npol.freeqtyrcvd)
			tmp$ = " ",tmp$                              
            Tmp$ = PR.ProdCode$ + nPol.Whse Using "##"    
			PWR = filegetprodwhse(e$,PWC,"=",1,tmp$,pw.) 
			If PWR>0 
				Read Record #PWC,PWR,0;pw.
				
				let tmp3=pw.qtyonhand-pw.QtyOnOrd-x3
				if source=381
					let tmp3=pw.qtyonhand-pw.QtyOnOrd
					let tmp3=tmp3+(pol.currqtyrcvd+ pol.freeqtyrcvd) ! original amount
					let tmp3=tmp3-(npol.currqtyrcvd+ npol.freeqtyrcvd) ! new amount
				endif
					
				if tmp3<0
					let returnstatus=0
					let e$="Insufficient stock in warehouse "+str$(npol.whse)+ " for product "+rtrim$(Pr.ProdCode$)
					let e$=e$+". Please change warehouse or returned quantity."    
					goto eldline:
				endif
			else
				let returnstatus=0
				let e$="There no stock in warehouse "+str$(npol.whse)+ " for product "+rtrim$(Pr.ProdCode$)
				let e$=e$+". Please change warehouse."
				goto eldline:
			endif
			endif
		endif
		If NewLn ! new line
			if npol.headerrec=0 and rec_poh<>0
				let npol.headerrec=rec_poh
			endif
			rec_pol = fileupdatepoline(e$,ch_pol,"a",rcdno,npol.)
			If rec_pol<0 ! will pass e$ to bottom
				let returnstatus=0
				Message$="PURCHASE ORDER "+STR$(PONO)+" Cannot Add "+rtrim$(NPOL.PRODCODE$)
				goto eldline ! cant update! set up for new immediate allocation
			endif
		
		Else ! existing linE
			Write record #ch_pol,rec_pol,0;npol.;
			let tmpflag=0
			if pol.updstock<>npol.updstock let tmpflag=99
			if pol.whse<>npol.whse let tmpflag=99
			if pol.qtyship<>npol.qtyship let tmpflag=99
			if pol.qtyord<>npol.qtyord let tmpflag=99
			If source = 381
				if (pol.CurrQtyRcvd + pol.freeqtyrcvd) <> (npol.CurrQtyRcvd + npol.freeqtyrcvd) let tmpflag=99
			endif
			if tmpflag=99			
				! back out previous inventory
				if pol.updstock<>0 and pol.qtyord<>0
					let x3=-pol.qtyord
					if source=381 let x3=-(pol.currqtyrcvd +pol.freeqtyrcvd) !pol.currqtyrcvdqty+pol.freeqty)
					let prr=pol.ProdDescRec
					Read record #PRC,PRR,0;PR.
					if source<>381 ! not a debit memo
						PR.QtyOnPO = PR.QtyOnPO + X3
					else ! debit memos update on order to reduce availabity
						 pr.QtyonPWO = pr.QtyonPWO + X3 ! already backed out
					endif 
					Write Record #PRC,PRR,0;PR.;
					!
					!
					if sqlChan >= 0 ! MySQL enabled and channel opened
						call prod_DL4SQLConvert(e$,"FROMDL4",PR.,sql_prod.,PRR)
						e = prod_SQLAddUpdate(e$,sqlChan,sql_prod.) ! mode="a" or "c"
						if e <> 1 ! returns the number of records add/updated/deleted
							error 11000 ! do bad update stuff
						end if
					end if
					!
					!
					tmp$ = " ",tmp$                              
                                      	tmp$ = PR.ProdCode$ + Pol.Whse Using "##"    
					PWR = filegetprodwhse(e$,PWC,"=",1,tmp$,pw.) 
					If PWR>0 
						Read Record #PWC,PWR,0;pw.

						if source<>381
							pw.QtyOnPO = pw.QtyOnPO + X3
						else
							pw.QtyOnOrd = pw.QtyOnOrd + X3
						endif
						Write Record #PWC,PWR,0;pw.; 
					endif
				endif
				if npol.updstock and npol.qtyord<>0
					let x3=npol.qtyord
					if source=381 let x3=(npol.currqtyrcvd+ npol.freeqtyrcvd)
					Read record #PRC,PRR,0;PR.
					if source<>381
						PR.QtyOnPO = PR.QtyOnPO + X3
					else
						
						pr.QtyonPWO = pr.QtyonPWO + X3
					endif
					Write Record #PRC,PRR,0;PR.;
					!
					!
					if sqlChan >= 0 ! MySQL enabled and channel opened
						call prod_DL4SQLConvert(e$,"FROMDL4",PR.,sql_prod.,PRR)
						e = prod_SQLAddUpdate(e$,sqlChan,sql_prod.) ! mode="a" or "c"
						if e <> 1 ! returns the number of records add/updated/deleted
							error 11000 ! do bad update stuff
						end if
					end if
					!
					!
					tmp$ = " ",tmp$                              
                                      	tmp$ = PR.ProdCode$ + nPol.Whse Using "##"    
					PWR = filegetprodwhse(e$,PWC,"=",1,tmp$,pw.) 
					If PWR>0 
						Read Record #PWC,PWR,0;pw.
						if source<>381
							pw.QtyOnPO = pw.QtyOnPO + X3
						else
							if boremflag<>0	
								let tmp3=pw.qtyonhand-pw.QtyOnOrd-x3
								if tmp3<0
									let returnstatus=2
									let message$=message$+"Insufficient stock in warehouse "+str$(npol.whse)+ " for product "+rtrim$(Pr.ProdCode$)
									let message$=message$+". Please change warehouse or returned quantity."    
								endif
							endif	
							pw.QtyOnOrd = pw.QtyOnOrd + X3
						endif
						Write Record #PWC,PWR,0;pw.; 
					endif
					
				endif
				! need check for po sales order copy

			endif
		endif	
		!! make sure that spolot gets updated even if the user does not do it task 48360
		call dfltspolot(rec_pol)
		if npol.salesord>0 and npol.salesOrdLine>0 and apoupso<>0
			if npol.unitcost<>pol.unitcost or npol.netcost<>pol.netcost
				If P61$[2,2] = "Y" or P61$[2,2] = "G" or P61$[2,2] = "L" 
				
					LET KEYROH$=" ",KEYROH$
					LET KEYROH$[3]=npol.salesord USING "######"
					REC_ROH=0
					FOR STATCNT=1 TO 99
						LET KEYROH$[1,2]=STATCNT USING "##"
						SEARCH #ohc,2,1;KEYROH$,REC_ROH,E
						IF Not(e) GOTO endfindrohrec:
						if statcnt>7 and statcnt<12
							let statcnt=50
						endif
						If statcnt=96 let statcnt=98 ! 97 is cred in process
					next statcnt
					endfindrohrec: ! 
					if rec_roh>0
						CH[0] = ctlc ! CONTROL FILE             
						CH[1] = ch_poh;REC[1] = rec_poh           
						CH[2] = ch_pol;REC[2] = rec_pol            
						CH[3] = ohc;REC[3] = rec_roh ! - npol.salesord      
						CH[4] = olc;REC[4] = - npol.salesordline    
						CH[5] = prc;REC[5] = 0              ! prod file
						CH[6] = pwc;REC[6] = 0              ! prod warehouse
						CH[7] = cuc;REC[7] = 0              ! customer file
						CH[8] = otc;REC[8] = 0              ! order total ffile
						rec[10]=rec_uac! user record #
						STAT[0] = 0;STAT[1] = 0   
						STAT[2]=intco 
						Call "poupsocost.dl4",CH[],REC[],STAT[],userid$
					endif
				endif
			endif
		Endif
		! update direct qty on receiving
		if Poh.Type<>1 and poh.type<>5 goto endposoq: ! purchase order is not direct
		if p61$[117,117]="Y" and Source=371 and npol.salesord>0 and npol.salesOrdLine>0 !  and npol.currqtyrcvd>0 ! 
			LET KEYROH$=" ",KEYROH$
			LET KEYROH$[3]=npol.salesord USING "######"
			REC_ROH=0
			FOR STATCNT=1 TO 4
				LET KEYROH$[1,2]=STATCNT USING "##"
				SEARCH #ohc,2,1;KEYROH$,REC_ROH,E
				if not(e)
					Read Record #ohc,rec_roh;roh.;
					!if roh.OrdType <>2 goto endposoq: -- not just sales order type 2 
					if npol.currqtyrcvd<=0 and roh.ordtype<>2 goto endposoq: ! 
					goto startposoq: 
				endif
			next statcnt
			if returnstatus<>2 or lastslsord<>npol.salesord
				let returnstatus=2
				let lastslsord=npol.salesord
				let message$=message$+" Sls Ord "+str$(npol.salesord)+" no longer in order status and cannot be updated." 
				goto endposoq: 
			endif
			startposoq: ! start the update
			if rec_roh>0
				clear chan[] ! dim for 50
				clear rec[]
				CHan[1] = ctlc ! CONTROL FILE             
				CHan[2] = ch_poh;REC[8] = rec_poh           
				CHan[3] = ch_poL;REC[9] = rec_pol 
				chan[4] = cuc ! customer	1808
				CHan[5] = OHC! order header	1840
				chan[6] = olc ! order line	1888
				chan[7] = NSC! proddesc		2128
				chan[8] = OSC! ros			1856
				chan[9] = 0   ! zone		1920 (not already opened)
				chan[10]= prc ! product		1792	
				chan[11]= otc ! rot			1872
				chan[12]= pwc ! prodwhse	1744
				chan[13]= pltc! prod lot	2528
				chan[14]= sltc! sordlot		2320
				chan[15]= 0	  ! cpi det		9928
				chan[16]= 0	  ! order type 10108
				rec[0]=371 ! source
				
				! order total ffile
				Call "poupsoq.dl4",CHan[],REC[],e$,intco,rstr$
			endif
			endposoq: ! 
		Endif

		if nonstk<>0 ! non-stock line
			if rec_pol>0
				Read record #ch_pol,rec_pol,0;pol.;
				rec_nstk=pol.ProdDescRec
				Read record #cH_nstk,rec_nstk,0;nstk.! set variables
				if not(zline) ! just + items - dropping off leading spaces
					If pol.ProdCode$<>nstk.ProdCode$ ! code changed!? dropped spaces?
						if pol.prodcode$[1,1]<>" " and nstk.prodcode$[1,1]=" "
							if pol.prodcode$[1,11]=nstk.prodcode$[2,12]
								let pol.prodcode$=nstk.prodcode$
							endif
						endif
					endif
				endif
				nstk.prodcode$=pol.prodcode$
				nstk.desc1$=pol.desc1$
				nstk.desc2$=pol.desc2$
				nstk.vendpart$=pol.vendprodcode$
				nstk.costum=pol.costum
				nstk.purchum=pol.qtyum
				nstk.ponum=pol.ponum
				! nstk.vendid=poh.vendorcode
				nstk.cube=pol.cbfunit
				nstk.wgt=pol.lbsunit ! pol.unitlbs
				nstk.wgtfact=pol.lbsfactor ! pol.lbfact
				nstk.cubefact=pol.cbffactor
				nstk.wgtlb=pol.grosswgt
				Write record #ch_nstk,rec_nstk,0;nstk.;
				call verifynskey()
			endif
		endif
		! added system flag and new prompt to update sls ord qty
		If source=361 or source=0
			if npol.SalesOrd>0 and npol.SalesOrdLine>0
				call dxget("UPDTSOQTY"+str$(lctr),tmp$)
				if UCase$(RTrim$(tmp$))="Y" ! do it
					call updateSoQty()
				Endif
			Endif ! has tied order&line
		Endif ! po entry/edit
		IF p60$[46,46]="Y" and rec_pol>0 ! import section 
			Read record #ch_pol,rec_pol,0;pol.;
			call calcimplinetot()
			Write record #ch_pol,rec_pol,0;pol.;
		endif
		ELDLine: ! end of line load
		If E$<>"" ! had an issue
			message$=message$+e$
			ReturnStatus=0
			if delline goto UDLDone
		Endif
	Next lctr ! process next line sent (was for multiple
	if source=381 and (rtsqchg or LotEntd=0) ! RASL?
	  if not(rasl) or locentd=0
		Call GetVend()
		Clear Ch[]                                 
		Ch[0] = ctlc ! cntrl file                  
		Ch[1] = ch_poh ! purchase order header     
		Ch[2] = Ch_Pol ! po lines
		Ch[3] = ch_vend ! vendor file          
		Ch[4] = prc! product file #64         
		Ch[5] = pwc ! product warehouse #65    
		Ch[6] = ch_nstk !  nonstock #66            
		Ch[7] = ccc ! unit of measure file #67
		ch[8] = pltc! sprodlot
		ch[9] = sltc ! sordlot
		clear specS[]           
		specS[0] = Rec_poh ! purchase order record #  
		specS[1] = rec_vend ! vendor record #         
		specS[10] = intCo ! control #                 
		msg$ = ""                                    
		errtype = 0                                  
		Call "po381l.dl4",Ch[],specS[],msg$,errtype,rstr$
	  endif ! if rasl and locentd = KEEP EXISTING!
	endif ! clears/defaults ALL DM LINES!?
	!IF p60$[46,46]="Y" and rec_pol>0 ! import section 
	!	Read record #ch_pol,rec_pol,0;pol.;
	!	call calcimplinetot()
	!	Write record #ch_pol,rec_pol,0;pol.;
	!endif
	! now any post update work starts
	
	
	! was after all lines processed - now is single line? do whole order rasl on every line?
	
	UDLDone: ! send status back
	if returnstatus=1 let message$="OK" ! set if no other problems
	if debugdetail
		dmsg$="Update Line "+Str$(pono)+"-"+Str$(npol.Itemno)+" "+npol.ProdCode$+Message$ \ Call updatelog(debug)
	Endif
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
 else
    include "src/callsuberr.inc"
 end try
end sub ! UpdtLines
! 
!--------------------------------------------------------------------
Function getnxtline(PONum)
! get first available PO line number
 Try
	Dim OLK$[60]
	Dim 3%,LRec,NRec

	Dim Cpol. as poline ! do not use pol. or prol.!(would overwrite)
	
	Dim cnstk. As nstkdesc 
	
	X2=1
	CHKNXTLN: ! loop til not found (get first available line)
	OLK$=" ",OLK$
	OLK$[1,6]=PONum Using "######"
	OLK$[7,9]=X2 Using "###"
	OLK$[10]="" ! cut to length
	LRec=filegetpoline(e$,ch_pol,"=",1,OLK$,cpol.)
	If LRec>0 ! found a line with same number
		x2=x2+1
		if x2>999 Error 10000 ! bomb it!
		goto chknxtln
	Endif ! not found - check sproddesc
	!!!! check nonstock stuff !!!!
	NRec=filegetnstkdesc (e$,ch_nstk,"=",1,OLK$,cnstk.)
	If NRec>0 ! found a line with same number
		x2=x2+1
		if x2>999 Error 10000 ! bomb it!
		goto chknxtln
	Endif ! not found - drop thru and send back
	e$="" ! clear any not found messg
	if debugdetail
		dmsg$="Get new Line No "+Str$(pol.poNum)+"-"+Str$(X2) \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
  end try
end Function X2 ! getnxtline
! 
!--------------------------------------------------------------------
Sub DELPOLINE(POnum,linenum,rec_pol)
! delete an PO line
 Try
	! all passed from UpdtLines(only place to delete!)
	! 
	! rec_pol MAY BE ZERO - SO see if actually there first (and nonstocks)
	! 
	! Dim Npol. as poline! store new sent data

	RTC=OpenFile(9936,IntCo) \ if RTC = -1 Let RTC=0 ! Error 42
	Dim cpol. as poline
	Dim rtg. as poltag

	Dim PWKey$[60],RTKey$[60]
	
	
	if debugdetail
		dmsg$="Delete Line "+Str$(PoNum)+"-"+Str$(LineNum) \ Call updatelog(debug)
	Endif
	tmp$=ShipDate Using "&&&&&&"
	
	If rec_pol<=0 ! no record, see if there!
		PWKey$=" ",PWKey$
		PWKey$[1,6]=PoNum Using "######"
		PWKey$[7,9]=LineNum Using "###"
		PWKey$[11]=""
		rec_pol=filegetpoline(e$,ch_po1,"=",1,PWKey$,npol.)
		If rec_pol<0 exit sub ! NO LINE (New?)
		RTKey$=PWKey$ ! keep line key!
	Endif
	Clear cpol. ! would have no org nos!
	Read record #ch_pol,rec_pol,0;pol.;
	X2 = pol.flags ! ! REM UNPACK pol.Flags TO FLAGS[x] 
	For K = 0 To 11                                     
		 flags[K] = Sgn(Fra(X2 / 2)) \ X2 = Int(X2 / 2)    
	Next K                                              
	NonStk = flags[0]                                   
	Closedshort = flags[1]                                   
	ZLine = flags[2]                                    
	if poh.status=7 let closed=99
	if pol.status=3 let closed=99
	! back out of sord/sprodlot
	! Nonstk=rol.NStkItem ! set above (ROL?)
	if Not(nonstk) and pol.UpdStock ! back out prev qty ord from prod & whse
	  !If not(debit)  ! debits = no on po 
		PRR=pol.proddescrec
		Read record #PRC,PRR,0;PR.
		PWKey$=" ",PWKey$
		PWKey$=pol.ProdCode$+pol.Whse Using "##"
		PWR=filegetprodwhse(e$,PWC,"=",1,Pwkey$,PW.)
		If PWR<0 Clear pw.
		! no add of whse on delete
		X3 = pol.QtyOrd + pol.Freegoods
		! if Poh.Type=1 let x3=0 ! direct do not update
				       ! indirect thpe
		If source<>381 ! not debit memos
			pr.QtyOnPO=pr.QtyOnPo-X3
			pw.QtyOnPO=pw.QtyOnPo-x3
		else ! debit memo update on order to reduce availabity
			x3=pol.currqtyrcvd+pol.freeqtyrcvd
			pr.QtyonPWO=pr.QtyonPWO-X3
			pw.QtyOnOrd=pw.QtyOnOrd-x3
		endif
		
		If pr.QtyOnPo<0 Let pr.QtyOnPo=0
		If pw.QtyOnPO<0 let pw.QtyOnPO=0
		
		Write Record #PRC,PRR,0;PR.;
		!
		!
		if sqlChan >= 0 ! MySQL enabled and channel opened
			call prod_DL4SQLConvert(e$,"FROMDL4",PR.,sql_prod.,PRR)
			e = prod_SQLAddUpdate(e$,sqlChan,sql_prod.) ! mode="a" or "c"
			if e <> 1 ! returns the number of records add/updated/deleted
				error 11000 ! do bad update stuff
			end if
		end if
		!
		!
		IF PWR>0 Write Record #PWC,PWR,0;pw.; ! in case not found
		if source=381 ! need to delete the sordlot keys
			!dim keychk$[50],keyslt$[60],keyplt$[60]
			Call delsordlot()
			Call delsernum() ! CHECK FOR SERIAL NUMBER DELETE
		!endif
		! check spolot
		if nonstk=0
			let pono=POnum
			let linenum=linenum
			Call delspolot() ! delpoline
		endif
		
	  Endif ! of update on PO
		
	Endif ! of stk & updatestk
	If NonStk  ! delete sproddesc (zline none)
		
		NSR=pol.ProdDescRec ! record
		Read Record #CH_NSTK,NSR,0;NSTK.;
		call verifynskey()
		X3=fileupdatenstkdesc(e$,ch_nstk,"d",nsr,nstk.) ! delete nonstock record
		! if x3<0 ! problem deleting
	Endif
	If RTC>0 ! poltag file opened
		RTKey$=" ",RTKey$
		RTkey$[1,6]=PoNum using "######"
		RTKey$[7,9]=LineNum using "###"
		RTKey$[11]="" ! space
		RTR=filegetpoltag(e$,RTC,"=",1,RTKey$,rtg.)
		If RTR>0
			if rtg.Blankforkey$="" ! CANNOT BE NULL (from UB- causes SE)
				rtg.Blankforkey$=" "
				write record #RTC,RTR,0;rtg.;
			Endif
			X3=fileupdatepoltag(e$,RTC,"d",RTR,rtg.)
		Else
			e$=""
		Endif
	Endif
	
	IF Pol.SalesOrd and Pol.SalesOrdLine
	call removesolink(Pol.SalesOrd,Pol.SalesOrdLine,PONUM)
	endif 

	! finally delete the line
	X3=fileupdatepoline(e$,ch_pol,"d",rec_pol,Pol.)
	! if x3<0 ! problem with delete	
	if debugdetail
		dmsg$="Line "+Str$(POL.PONum)+"-"+Str$(Pol.ItemNo)+" Deleted "+e$ \ Call updatelog(debug)
	Endif
 else
    include "src/callsuberr.inc"
 end try
end sub ! DELPOLINE
!
Sub NSDefault()
!-------------------------------------------------------------------
! defaults for nonstock items
 try
	Dim keymat$[2],kcm$[40]
	dim 1%,ch_matc
	dim 3%,rec_mat
	ReturnStatus=1
	Message$="OK"
  ! unit of measure droplist  *** keep this section ****
  clear list$[]
  if not (CCC)
	ccc = OpenFile(-1728,intCo) \ If ccc= -1 Error 42  !u/m codes file
  endif
  PTC = OpenFile(-944,intCo) \ if PTC = -1 error 42 ! product tax type
  CLEAR FIELD$[]
  !let field$[0]="Code$"
  !let field$[1]="Description$"
  clear tmp$ ! send other flag
  Clear Field$[]
  !if p9$[20,20]="F" let tmp$="F"
  tmp$="F" ! no longer fine paper flag driven
  !call filedroplistccodes(e$,list$[],maxcnt,CCC)
  call filedroplistccodesz(e$,list$[],maxcnt,CCC,"",Field$[],1,"",tmp$)  
    call AddToStr(e$,rstr$,List$[])

  ! section 2
  clear list$[]
  List$[0] = bsdel$,"NSDEFAULT",fdel$
  Webstr$="ComId",fdel$,"CommDesc",fdel$
  Webstr$=webstr$,"ProdCatId",fdel$,"ProdCatName",fdel$
  Webstr$=webstr$,"ProdTaxType",fdel$
  list$[1]=webstr$
  if not(prc)
	PRC = OpenFile(-1792,intCo) \ If PRC = -1 Error 42  !product file 
  endif
  let prodkey$="Z ZZZZZZZZZZ"
  PRR = filegetprod(e$,PRC,"=",1,Prodkey$,PR.)
  if prr>0
	if not(cmc)
		cmc = OpenFile(-2288,IntCo) \ If cmc = -1 Error 42 ! commod code(HEAD)
	endif
	let kcm$=PR.ComdtyCode$ ! pr.A$[152,155]
	CMR = filegetcommhead(e$,cmc,"=",1,KCM$,cmc.)
	if cmr<=0
		clear cmc.
	endif
	if not(ch_psc)
		 ch_psc = OpenFile(-1984,IntCo) \ If ch_psc = -1 Error 42 ! prod sales category
	endif
	if pr.ProdCat>0 and pr.ProdCat<(chf(ch_psc)-1)
		read record #ch_psc,pr.ProdCat;psc.;
	else
		clear psc.
	endif
  else
	clear pr.
	clear cmc.
	clear psc.
  endif
  Webstr$=rtrim$(PR.ComdtyCode$),fdel$ ! "ComId"
  Webstr$=webstr$,rtrim$(cmc.CodeDescription$),fdel$
  Webstr$=webstr$,str$(pr.ProdCat),fdel$ ! "ProdCatId"
  webstr$=webstr$,rtrim$(psc.CategoryDesc$),fdel$
  webstr$=webstr$,str$(pr.TaxType),fdel$
  
  List$[2] = WebStr$
  Call AddToStr(e$,rstr$,List$[])             
  Call AddToStr(e$,rstr$,esdel$) ! end of section   
	if returnstatus=1 let message$="OK" ! set if no other problems
	if debugdetail
		dmsg$="NS Default Line "+Message$ \ Call updatelog(debug)
	Endif

	clear list$[]
	call filedroplistptaxtype(e$,list$[],100,PTC)
	call addToStr(e$,rstr$,list$[])

	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
 else
	include "src/callsuberr.inc"
 end try
End sub !NSDEFAULT
!---------------------------------------------------------------------
Sub NSsaveitem()
!--------------------------------------------------------------------
! save a nonstock item -- adding line 
 try
	dim 1%,tmptax
	dim 2%,currdate
	dim 3%,V3[99],blank$[50],keynstk$[14],polkey$[60]
	Dim 3%,Whbld[3],S9[20] 
	dim npol. as poline
	Dim cnstk. As nstkdesc 
	clear pol.
	clear nstk.
	clear npol.
	clear cnstk.
	     
	If debugdetail                                         
		dmsg$ = "Start NonStock Line Update" \ Call updatelog(debug)  
	End If                                                 
	ReturnStatus = 1                                       
	Message$ = "OK"                                        
	Call dxget("POID",tmp$)                             
	If tmp$ = "" Goto NSUDLDone                              
	pono = tmp$                                         
	If pono < 1 Or pono > 999999 Or Fra(pono)     
		 ReturnStatus = 0                                     
		Message$ = "PURCHASE ORDER NUMBER INVALID"                    
		Goto NSUDLDone                                         
	End If                                                 
	
	rec_poh = getpohrec(e$,ch_poh,pono,poh.)
	If rec_poh <= 0 ! not found                                
		ReturnStatus = 99                                    
		Message$ = "PURCHASE ORDER WAS NOT FOUND"                     
		Goto NSUDLDone 
	endif
	if returnstatus<>0
		call verifystat()
		if returnstatus=99 goto NSUDLDone:
	endif
	ZLine = 0;NonStk = 1;stk = 0;delline = 0
	Call dxget("LTYPE",tmp$)
	tmp$ = UCase$(tmp$)
	if tmp$<>"NSTK"
		returnstatus=0
		Message$="Order Line has Invalid Line Type. Not a non-stock item."
		goto nsudldone:
	endif
	If tmp$[1,4] = "NSTK" Let NonStk = 1
	Call DXGet("LN",tmp$) ! +Str$(X1),tmp$)
	let pol.itemno=tmp$
	let npol.itemno=tmp$
	If pol.itemno ! get prev data                 
		polkey$ = " ",polkey$                         
		polkey$[1,6] = pono Using "######"         
		polkey$[7,9] = pol.itemno Using "###"       
		polkey$[10] = "" ! cut to length (space @ 10) 
		rec_pol = filegetpoline(e$,ch_pol,"=",1,polkey$,pol.)
		If rec_pol <= 0 ! what do we do if not found?     
			Clear pol. 
			Clear npol.
			npol.ItemNo = 0 ! treat as new?  
			NewLn = 1                        
		else
			Read Record #ch_pol,rec_pol,0;npol. ! read / lock with prev values
			NewLn = 0                                             
			 ! flag for non-stock item in logic                      
			X2 = pol.flags ! ! REM UNPACK pol.Flags TO FLAGS[       
			For K = 0 To 11                                         
				flags[K] = Sgn(Fra(X2 / 2)) \ X2 = Int(X2 / 2)        
			Next K                                                  
			NonStk = flags[0]                                       
			Closedshort = flags[1]                                       
			Zline = flags[2]
			let closed=0
			if poh.status=7 let closed=99
			if pol.status=3 let closed=99
			If NonStk <> 0                                          
				rec_nstk = pol.proddescrec                            
				Read Record #ch_nstk,rec_nstk,0;nstk.;                
				prr = 0;PWR = 0                                       
			Else                                                  
  				returnstatus=0
				Message$="Existing Purchase Order Line Is Not A Non-Stock Item."
				goto nsudldone:
			End If  
		Endif
	Endif
	npol.Status = 1;debit = 0
	If poh.Status > 10  and poh.status<15
		Let npol.Status = 11;debit = 1 ! determine order/
	endif
	if poh.status=97
		Let npol.Status = 11;debit = 1 ! determine order
	endif
 	npol.PONum = pono
	nstk.PONum = pono
	Call dxget("DESC1",tmp$) ! +Str$(X1),tmp$) 
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Description 1"
		goto nsudldone:
	Endif
	let tmp$=rtrim$(ucase$(tmp$))
	npol.desc1$ = tmp$ + Blank$ 
	nstk.desc1$ = npol.desc1$
	Call dxget("DESC2" ,tmp$) ! +Str$(X1),tmp$)
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Description 2"
		goto nsudldone:
	Endif
	let tmp$=rtrim$(ucase$(tmp$))
	npol.desc2$ = tmp$ + Blank$
	nstk.desc2$ = npol.desc2$
	If npol.Whse < 1 Or npol.Whse > 99 Let npol.Whse = poh.warehouse                                                                 
 	npol.updStock=0 ! non stock set to No
    Call dxget("UNITCOST" ,tmp$) ! +Str$(X1),tmp$) 
	V3[2] = tmp$    ! as entered unit of measure  
	Call dxget("CUBE" ,tmp$) ! +Str$(X1),tmp$)  !!!! st   
	npol.cbfunit = tmp$ 
	nstk.cube=npol.cbfunit
	Call dxget("WEIGHT",tmp$) ! +Str$(X1),tmp$)          
	npol.LbsUnit = tmp$
	nstk.wgt= npol.LbsUnit
	Call dxget("QTYORD",tmp$) ! +Str$(X1),tmp$)      
	V3[4] = tmp$                           
	  
	Call dxget("QTYUM",tmp$) ! +Str$(X1),tmp$)       
	!If tmp$[1,1] > "9" ! sent text?                               
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)                         
		If R <> 0 Let tmp$ = Str$(R)
		IF R<0 !
			let returnstatus=0
			let message$="Invalid Quantity Unit of Measure"
			goto nsudldone:! set up for new immediate allocation
		endif
	!End If                                                        
	npol.qtyum = tmp$
	nstk.purchum=tmp$
	Call dxget("COSTUM",tmp$) ! +Str$(X1),tmp$)        
	!If tmp$[1,1] > "9" ! sent text?                                 
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)                           
		If R <> 0 Let tmp$ = Str$(R)                                  
	!End If                                                          
	npol.CostUM = tmp$
	nstk.costum = npol.costum
	Call dxget("VENDITM" ,tmp$) ! +Str$(X1),tmp$)
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Vendor Item Code"
		goto nsudldone:
	Endif
	npol.vendprodcode$ = tmp$ + Blank$ 
	nstk.vendpart$=npol.vendprodcode$
	Call Dxget("SOURCE",tmp$) ! check this routine -- add this time 
	let source=tmp$
	Call dxget("PRODTAXTYPE" ,tmp$) ! +Str$(X1),tmp$)
	let tmp3=tmp$
	if source<>381
		if tmp3<1 or tmp3>99
			returnstatus=0
			Message$="Invalid Product Tax Type"
			goto nsudldone:
		Endif
	endif
	nstk.ptaxtype=tmp3
	If npol.itemno>0  ! line already exists
		Call dxget("NETCOST" ,tmp$)   
		V3[1] = tmp$                                                    
		Call dxget("DISCPCT" ,tmp$)     
		npol.DiscPct = tmp$                                             
		Call dxget("DISCDOLLAR" ,tmp$) 
		V3[3] = tmp$ !  npol.DiscUnt=tmp$               
  		Call dxget("QTYSHIP" ,tmp$)    
		V3[5] = tmp$                                                  
		Call dxget("QTYFREEGOODS",tmp$)                  
		V3[6] = tmp$
       		Call dxget("APPLYFRGT",tmp$)                       
		If tmp$ = "Y" Let npol.ApplyFrt = 1                             
		If tmp$ = "N" Let npol.ApplyFrt = 0                             
		Call dxget("HAZARD" ,tmp$)                          
		If tmp$ = "Y" Let npol.hazitemflag = 1                          
		If tmp$ = "N" Let npol.hazitemflag = 0                          
		Call dxget("SLSORDNUM" ,tmp$)                       
		npol.salesord = tmp$                                            
		Call dxget("SLSORDLINE" ,tmp$)                      
		npol.salesordline = tmp$                                        
		Call dxget("DUEDATE" ,tmp$)
		if tmp$<>""
			xdate$ = formatdate2$(tmp$) ! from MM/DD/YYYY to yyyymmdd  
			npol.duedate = xdate$[3,8]  
		endif
	endif
  	! unique for non-stocks         
	Call dxget("COMMD",tmp$) !   
	nstk.CmdtyCode$ = tmp$ + Blank$            
	Call dxget("SLSCAT",tmp$) 
	nstk.ProdCat = tmp$                         
	Call dxget("BASEUM",tmp$) !+Str$(X1),tmp$)   
	!If tmp$[1,1] > "9" ! sent text?              
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)        
		If R <> 0 Let tmp$ = Str$(R)               
	!End If                                       
	nstk.BaseUM = tmp$                           
	Call dxget("STOCKUM",tmp$)
	!If tmp$[1,1] > "9" ! sent text?              
		 R = getumrec(e$,ccc,tmp$,IntCo,PR.)        
		If R <> 0 Let tmp$ = Str$(R)               
	!End If                                       
	nstk.StockUM = tmp$                          	
	! end new fields
	 Call dxget("STOCKFCTR",tmp$)  
	 nstk.StkFact = tmp$  \if nstk.stkfact<=0 let nstk.stkfact=1  	             
	 Call dxget("COSTFCTR",tmp$) 
	 nstk.CostFact = tmp$    \ if nstk.CostFact<=0 let nstk.CostFact=1                     
	 Call dxget("QTYFCTR",tmp$) 
	 nstk.POFact = tmp$  \if nstk.POFact<=0 let nstk.pofact=1 	    
	!Call dxget("CUBEFCTR",tmp$) 
	 !nstk.CubeFact = tmp$    \ if nstk.CubeFact<=0 let nstk.CubeFact=1                     
	
	Call dxget("UMCUBE",tmp$) !+Str$(X1),tmp$)   
	!If tmp$[1,1] > "9" ! sent text?              
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)        
		If R <> 0 Let tmp$ = Str$(R)               
	!End If
	!nstk.CubeFact=tmp$
	!if nstk.CubeFact<=0 let nstk.CubeFact=1
	nstk.CubeFact=1
	nstk.CubeFact=1
	if R=nstk.baseum
		let nstk.CubeFact=1
	else
		if r=nstk.stockum
			let nstk.CubeFact=nstk.stkfact
		else
			if r=nstk.purchum
				let nstk.CubeFact=nstk.pofact
			else
				if r=nstk.costum
					let nstk.CubeFact=nstk.costfact
				endif
			endif
		endif
	endif
	npol.CbfFactor=nstk.cubefact
        !Call dxget("LBSFCTR",tmp$)     
	!nstk.WgtFact = tmp$ \if nstk.WgtFact<=0 let nstk.Wgtfact=1 
	Call dxget("UMLBS",tmp$) !+Str$(X1),tmp$)    
	!If tmp$[1,1] > "9" ! sent text?              
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)        
		If R <> 0 Let tmp$ = Str$(R)               
	!End If 
	!nstk.WgtFact=tmp$
	!if nstk.WgtFact<=0 let nstk.WgtFact=1
	nstk.wgtfact=1
	if R=nstk.baseum
		let nstk.WgtFact=1
	else
		if r=nstk.stockum
			let nstk.WgtFact=nstk.stkfact
		else
			if r=nstk.purchum
				let nstk.WgtFact=nstk.pofact
			else
				if r=nstk.costum
					let nstk.WgtFact=nstk.costfact
				endif
			endif
		endif
	endif
        npol.lbsfactor=nstk.wgtfact
	If npol.itemno = 0 ! new line 
		IF P61$[136,136]="Y"
			let npol.currid=poh.currid
			let npol.currfact=poh.currfact
		endif
		NEWLN=99
		if custom_customer$="PIEDMONT" ! TASK#51466 
			npol.ApplyFrt = 1 
		ENDIF
		npol.ponum=pono
		nstk.ponum=pono
		npol.itemno = getnxtline(pono)   
		npol.ProdCode$ = str$(pono) ! pono Using "######"                      
		npol.ProdCode$ = npol.ProdCode$ + "-" + npol.itemno Using "&&&"
		npol.ProdCode$ = npol.ProdCode$ + Blank$                        
		nstk.ProdCode$ = npol.ProdCode$
		nstk.vendid=poh.vendorcode
		if poh.PODiscType=1 or poh.PODiscType=2 ! header has disc
			if source<>381
				if poh.PODiscType=1 let npol.DiscPct=poh.PODiscAmt
				if poh.PODiscType=2 let npol.DiscUnt=poh.PODiscAmt
			endif
		endif
		read #ctlc,3,172;currdate;
		nstk.createdate=currdate
		nstk.LineNum=npol.itemno
		npol.duedate=poh.duedate
		nonstk=1;closed=0;zline=0;closedshort=0
		FLAGS[0]=NONSTK
		FLAGS[1]=CLOSEDSHORT
		FLAGS[2]=ZLINE
		LET X2=0 
		FOR K=0 TO 11       
			IF FLAGS[K] LET X2=X2+2^K    
		NEXT K 
		LET npol.flags=X2  
		V3[1]=V3[2] ! Set netcost to unit cost
		V3[5] =v3[4] ! set qty ship - qty order 
		nstk.TieBreak=0
		let nstk.prodcode$=rtrim$(nstk.prodcode$)+blank$
		keynstk$=" ",keynstk$
		keynstk$[1,12]=nstk.prodcode$[1,12]
		do
			keynstk$[13]=nstk.TieBreak using "##"
			search #ch_nstk,2,1;keynstk$,rec_nstk,e
			if e exit do
			let nstk.tiebreak=nstk.tiebreak+1
			if nstk.tiebreak>99
				e$ = "NONSTOCK " + npol.ProdCode$ + " FILE NOT ADDED"
				returnstatus=0
				Message$="NONSTOCK " + npol.ProdCode$ + " FILE NOT ADDED"
			endif
		loop
		rec_nstk = fileupdatenstkdesc(e$,ch_nstk,"a",0,nstk.) 
		If rec_nstk > 0                                                    
			 npol.ProdDescRec = rec_nstk                                        
		Else   		                                                    
			 e$ = "NONSTOCK " + npol.ProdCode$ + " FILE NOT ADDED"
			 returnstatus=0
			 Message$="NONSTOCK " + npol.ProdCode$ + " FILE NOT ADDED"
			 goto nsudldone:
		End If  
	else
		Call dxget("PRODID",tmp$) 
		let npol.prodcode$=tmp$+blank$
		if rtrim$(tmp$)="" and newln=0 let npol.prodcode$=pol.prodcode$
		If pol.ProdCode$<>npol.ProdCode$ ! code changed!? dropped spaces?
			if npol.prodcode$[1,1]<>" " and pol.prodcode$[1,1]=" "
				if npol.prodcode$[1,11]=pol.prodcode$[2,12]
					let npol.prodcode$=pol.prodcode$
				endif
			endif
		endif
	End If ! of stk/nonstk  
	if rec_nstk>0
		write record #ch_nstk,rec_nstk,0;nstk.;
		call verifynskey()
	endif
	If NewLn ! new line  
		if npol.headerrec=0 and rec_poh<>0
			let npol.headerrec=rec_poh
			endif
		rec_pol = fileupdatepoline(e$,ch_pol,"a",rcdno,npol.)  
		If rec_pol < 0 ! will pass e$ to bottom                
			returnstatus=0
			Message$="NONSTOCK " + npol.ProdCode$ + " FILE NOT ADDED"
			goto nsudldone:! set up for new immediate allocation 
		endif
		let newln=0
	endif
     	if rec_pol>0
		if npol.headerrec=0 and rec_poh<>0
			let npol.headerrec=rec_poh
		endif
		 write record #ch_pol,rec_pol,0;npol.;
		 read record #ch_pol,rec_pol,0;pol. ! read for the factor
	endif
	! 
	if p61$[136,136]="Y"
		!Call GetVend()
		!if vend.currid<>0
			!keycurr$ = " ",keycurr$                   
			!keycurr$[1,4] = vend.currid Using "####"  
			!Search #ch_curr,2,1;keycurr$,rec_curr,e   
			!If e <> 0                                 
			!	pol.currfact = 0 
			!	pol.currid=0
			!Else                                      
			!	Read Record #ch_curr,rec_curr;curr.; 
			!	let pol.currid=poh.currid
			!	let pol.currfact=poh.currfact
			!endif
		!else
			!let pol.currfact=0
			!let pol.currid=0
			!let pol.currfact=poh.currfact
			!let pol.currid=poh.currid
		!endif
	else
		!let pol.currfact=0
		!let pol.currid=0
	endif                            
	Call setprtopol() ! set to rol. factors                            
	! convert sent to base as sent in display um                       
	     ! **** convert cost *****                                           
	! V3[1] = net po cost
	CNVTU[0] = npol.CostUM;CNVTU[1] = 0;CNVTU[2] = 2  
	IF V3[1] <> 0	
		if p61$[136,136]="Y" and npol.currfact<>0 ! going from costing um to base
			let cnvcu[0]=2
			let cnvca[0]=v3[1]
			let cnvca[1]=npol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let v3[1]=cnvca[0]
		endif
		CNVTA = V3[1]               
		npol.netcost = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)     
	Else                                                                
		npol.netcost = 0                                                  
	End If                                                              
	! V3[2] = unit po cost
	IF V3[2]<>0	
		if p61$[136,136]="Y" and npol.currfact<>0 ! going from costing um to base
			let cnvcu[0]=2
			let cnvca[0]=v3[2]
			let cnvca[1]=npol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let v3[2]=cnvca[0]
		endif
		CNVTA = V3[2]                                            
		npol.unitcost = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)    
	Else                                                                
		npol.unitcost = 0                                                 
	End If                                                              
	! V3[3] = discount dollars 
	IF V3[3]<>0   
		if p61$[136,136]="Y" and npol.currfact<>0 ! going from costing um to base
			let cnvcu[0]=2
			let cnvca[0]=v3[3]
			let cnvca[1]=npol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let v3[3]=cnvca[0]
		endif
		CNVTA = V3[3]                                 
		npol.DiscUnt = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)     
	Else                                                                                
		npol.DiscUnt = 0                                                  
	End If                                                              
	! convert quantity
	CNVTU[0] = npol.qtyum;CNVTU[1] = 0;CNVTU[2] = 1  
	IF V3[4]<>0                                                                  
		CNVTA = V3[4] ! qty orders                              
		npol.QtyOrd = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)      
	Else                                                                
		npol.QtyOrd = 0                                                   
	End If 
	IF V3[5]<>0
		CNVTA = V3[5] ! qty ship                              
		 npol.qtyship = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		 Call Dxget("SOURCE",tmp$) ! check this routine -- add this time 
			let source=tmp$
			if source=381 and Npol.currqtyrcvd=0
				let Npol.currqtyrcvd=Npol.qtysHIP
			endif
	
	Else                                                                
		 npol.qtyship = 0                                                  
	End If 
	if v3[6]<>0
		CNVTA = V3[6] ! qty free                  
		npol.Freegoods = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)   
	Else                                                                
		npol.Freegoods = 0                                                
	End If                                                                                       
	! calculate extensions                                              
	lineqty = npol.qtyship + npol.Freegoods - npol.totfreeqtyrcvd
	if lineqty<>0
		npol.ExtWght = calcextwgt(lineqty,npol.LbsUnit,npol.LbsFactor)      
		npol.ExtCubes = calcextcube(lineqty,npol.cbfunit,npol.cbffactor)
	else
		npol.ExtWght=0
		npol.ExtCubes=0
	endif
	! update extended unit cost                                         
	lineqty = npol.qtyship                                              
	lineum = npol.CostUM                                                
	linecost = npol.unitcost                                            
	lineextamt = 0                                                      
	LbsUnit = npol.LbsUnit                                              
	LbsFact = npol.LbsFactor
	currfact=0 ! npol.currfact
	if lineqty<>0 and linecost<>0
		Call CalcExtAmt(lineqty,lineum,linecost,lineextamt,LbsUnit,LbsFact,currfact)
	endif
	npol.ExtUnitCost = lineextamt 
	let dsp_extucost=lineextamt
		if p61$[136,136]="Y" and npol.currfact<>0 
			lineum=npol.costum
			linecost=npol.unitcost
			lineextamt=0
			lbsunit=npol.lbsunit
			lbsfact=npol.lbsfactor
			currfact= npol.currfact
			call calcextamt(lineqty,lineum,linecost,lineextamt,lbsunit,lbsfact,currfact)
			let dsp_extucost=lineextamt	
		endif
	! update extended net cost                         
	lineqty = npol.qtyship                                              
	lineum = npol.CostUM                                                
	linecost = npol.netcost                                             
	lineextamt = 0                                                      
	LbsUnit = npol.LbsUnit                                              
	LbsFact = npol.LbsFactor 
	currfact=npol.currfact
	if lineqty<>0 and linecost<>0
		Call CalcExtAmt(lineqty,lineum,linecost,lineextamt,LbsUnit,LbsFact,currfact)
	endif
	npol.extNetCost = lineextamt 
	let dsp_extncost=lineextamt
		if p61$[136,136]="Y" and lineextamt<>0  and npol.currfact<>0 
			lineum=pol.costum
			linecost=npol.netcost
			lineextamt=0
			lbsunit=npol.lbsunit
			lbsfact=npol.lbsfactor
			currfact= npol.currfact
			call calcextamt(lineqty,lineum,linecost,lineextamt,lbsunit,lbsfact,currfact)
			let dsp_extncost=lineextamt	
		endif
   	if rec_pol>0
		 write record #ch_pol,rec_pol,0;npol.;
	endif
      
	nsUDLDone: ! send status back                                            
	If ReturnStatus = 1 Let Message$ = "OK" ! set if no other problems     
	If debugdetail                                                         
		dmsg$ = "Update Line " + Str$(pono) + "-" + Str$(npol.itemno) +npol.ProdCode$ + Message$ 
		Call updatelog(debug)                         
	End If 
	clear list$[]                                                         
	list$[0]=bsdel$,"NSSAVEITEM",fdel$ 
	webstr$=""
	webstr$=webstr$,"PRODID",fdel$                                        
	webstr$=webstr$,"LN",fdel$                                            
                                
	List$[1]=webstr$                                                      
	if rec_pol>0                                                              
		webstr$=""  
		webstr$=rtrim$(npol.prodcode$),fdel$                          
		webstr$=webstr$,str$(npol.ItemNo),fdel$                       
		list$[2]=webstr$                          
	 endif                                             
	Call AddToStr(e$,rstr$,List$[])           
	Call AddToStr(e$,rstr$,esdel$) ! end of section   
	! status section                                                       
	Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)                 
	Call AddToStr(e$,rstr$,WebStr$)                                        
	Call SetOutPut(e$,rstr$)                                               
 else
	 include "src/callsuberr.inc"
 end try
End sub !NSSAveItem
!--------------------------------------------------------------------
Sub NSBUILDPROD()
!-------------------------------------------------------------------
! BUILD PRODUCT FROM NON-STOCK
 try
	dim nspw. as prodwhse
	Dim keyprod$[12],kcm$[40],field$[1,30]
	Dim polkey$[60], polkey2$[50],KRol$[50]
	dim 1%,ch_matc,errstatus,e$[500]
	dim 2%,currdate,L4
	dim 3%,rec_mat,Rec_prod,V3[99]
	DIM A$[156],HZ$[90],PR_A2$[30],C1$[32],PSN$[20],U3$[60]        
	DIM PRFLG$[10],PRMKUPTYP$[4],PIC$[50],PRIML$[12]               
	DIM 1%,LLC,PFTB[3],PFU1[20],LM[1],UPCT,PR_PO[1]                
	DIM 1%,PRBASE,PRPARC2[3],PRD1[4],AGEDAY                        
	DIM 2%,A2,A3[2],B[24],PR_C4[10],PFCO[3],PLC[3],PSN[1],U2[1],U4[1] 
	DIM 2%,STK[2],FDT[1],PRMKUP[3],PRD0[2]                         
	DIM 3%,A1[7],A[33],PF_LOAD2,PFU2[6],PLV[1],PRPARC[3],U3,PFN[1] 
	DIM 3%,LBSORD,FUT[1],PRREDI[1],PRD2[3]                         
	REM {end dim.prod.i}                                           
	DIM K1$[25],K2$[20],K3$[40],K4$[40],K5$[45],COPYPROD$[12]      
	DIM PROD$[12],WHKEY$[14]
	DIM 3%,UNWORK[7],UNFWORK[7] 
	DIM 3%,P2[12,2],rec_tmp,FLE[5]
	dim 3%,rec_ror,keyroll$[50],keyroll2$[50],F$[16]
	dim nspwkey$[30],3%,rec_nspw
	dim rolkey2$[30]
	mat read #1,60,6;flg$;
	ReturnStatus=1
	Message$="OK"
	Call dxget("POID",tmp$)                                        
	If tmp$ = "" Goto  NSBPrdDone:                                      
	pono = tmp$                                                    
	If pono < 1 Or pono > 999999 Or Fra(pono)                
		 ReturnStatus = 0                                                
		 Message$ = "PURCHASE ORDER NUMBER INVALID"                               
		Goto NSBPrdDone                                                 
	End If                                                            
	rec_poh = getpohrec(e$,ch_poh,pono,poh.)  
	If rec_poh <= 0 ! not found                                               
		ReturnStatus = 0                                                    
		Message$ = "PURCHASE ORDER WAS NOT FOUND"                                    
		Goto NSBPrdDone                                                       
	End If             
	let keyprod$="Z ZZZZZZZZZZ"
	PRR = filegetprod(e$,PRC,"=",1,keyprod$,PR.)
	clear e$
	if prr<=0
		let returnstatus=0
		let message$="Default Non-Stock Product 'Z ZZZZZZZZZZ' Not On File"
		Goto NSBPrdDone
	endif
	Call dxget("PRODID",tmp$)      
	tmp$ = Rtrim$(UCase$(tmp$)) + Blank$   
	prod$ = tmp$[1,12]
	if rtrim$(prod$)=""
		let returnstatus=0
		let message$="Invalid Product Code "+Prod$
		Goto NSBPrdDone
	endif
	let keyprod$=rtrim$(prod$)+blank$
	rec_prod = filegetprod(e$,PRC,"=",1,keyprod$,PR.)
	clear e$
	if rec_prod>0
		let returnstatus=0
		let message$="Product Id "+Rtrim$(PROD$)+" Already On File "
		Goto NSBPrdDone
	endif                            
	Call dxget("LTYPE",tmp$)                                              
	tmp$ = UCase$(tmp$)                                                   
	If tmp$[1,4] <> "NSTK"                                                     
		 ReturnStatus = 0                                                    
		Message$ = "Purchase Order Line has Invalid Line Type. Not a non-stock item."
		Goto NSBPrdDone                                                     
	End If                                                                
	Let NonStk = 1                                  
	Call dxget("LN",tmp$)                              
	pol.ItemNo = tmp$ 
	If pol.ItemNo < 1 Or pol.ItemNo > 999 Or Fra(pol.ItemNo)                
		 ReturnStatus = 0                                                
		 Message$ = "PURCHASE ORDER LINE NUMBER INVALID"                               
		 Goto NSBPrdDone: !   EndNSGetItem 
	endif
	Call dxget("SOURCE",tmp$)
	let source=tmp$
	polkey$ = " ",polkey$                                 
	polkey$[1,6] = pono Using "######"                    
	polkey$[7,9] = pol.ItemNo Using "###"                
	polkey$[10] = "" ! cut to length (space @ 10)         
	rec_pol = filegetpoline(e$,ch_pol,"=",1,polkey$,Pol.)                    
	If rec_pol <= 0 ! what do we do if not found?                          
		 ReturnStatus = 0                                                
		 Message$ = "PURCHASE ORDER LINE NOT ON FILE"                               
		 Goto NSBPrdDone !  EndNSGetItem 
	endif
    ! no check the flags !!!
	X2 = Pol.flags ! ! REM UNPACK pol.Flags TO FLAGS[x]       
	For K = 0 To 11                                           
		flags[K] = Sgn(Fra(X2 / 2)) \ X2 = Int(X2 / 2)          
	Next K                                                    
	NonStk = flags[0]                                         
	Closedshort = flags[1]                                         
	ZLine = flags[2]
	let closed=0
	if pol.status=3 let closed=99
	if poh.status=7 let closed=99
	If Not(NonStk)
         ReturnStatus = 0                                                
		 Message$ = "PURCHASE ORDER LINE IS NOT A NON-STOCK LINE" 
		 clear Pol.
		 rec_pol=-1
		 Goto NSBPrdDone
	endif
	if Closed <>0   ! it's a zline line  
		ReturnStatus = 0                                                
	    Message$ = "PURCHASE ORDER LINE IS CLOSED. MAY NOT EDIT" 
	    clear Pol.
	    rec_pol=-1
		goto NSBPrdDone  !	 Goto EndNSGetItem 
	endif
	if Zline <>0   ! it's a zline line  
		ReturnStatus = 0                                                
		 Message$ = "PURCHASE ORDER LINE IS NOT A NON-STOCK LINE" 
		 clear Pol.
		 rec_pol=-1
		 Goto NSBPrdDone
	endif
	rec_nstk = pol.proddescrec
	if not(rec_nstk)
		ReturnStatus = 0                                                
		Message$ = "Invalid Non-Stock Record " 
		clear Pol.
		clear nstk.
		rec_pol=-1
		rec_nstk=-1
		Goto NSBPrdDone   
	endif
	Read Record #ch_nstk,rec_nstk,0;nstk.;                                   
	Call setprtopol() ! set to pol. factors 
	If not(ch_prsls)
		ch_prsls = OpenFile(2080,IntCo) \ If ch_prsls = -1 Error 42 ! prod sales file
	endif
	IF not(CH_PDESCKEY)
		ch_pdesckey = OpenFile(1104,IntCo) \ If ch_pdesckey = -1 Error 42 
	endif
	! read old product use prr  -- using with old format since I need arrays
	! from the Z product
	MAT  READ #PRC,PRR,0;A$;          
	MAT  READ #PRC,PRR,156;B;        
	MAT  READ #PRC,PRR,256;A;        
	MAT  READ #PRC,PRR,460;A1;        
	MAT  READ #PRC,PRR,508;A2;       
	MAT  READ #PRC,PRR,512;PFU1;      
	MAT  READ #PRC,PRR,554;PFU2;      
	MAT  READ #PRC,PRR,596;PRPARC;    
	MAT  READ #PRC,PRR,620;LM;   
	MAT  READ #PRC,PRR,624;PR_PO;     
	MAT  READ #PRC,PRR,628;AGEDAY;   
	READ #PRC,PRR,630;LLC;            
	MAT  READ #PRC,PRR,632;PSN$;      
	MAT  READ #PRC,PRR,652;PSN;       
	MAT  READ #PRC,PRR,660;U2;        
	MAT  READ #PRC,PRR,664;LBSORD;
	MAT  READ #PRC,PRR,670;U4;            
	READ #PRC,PRR,678;U3;                 
	MAT  READ #PRC,PRR,684;U3$;           
	MAT  READ #PRC,PRR,744;HZ$;           
	MAT  READ #PRC,PRR,834;A3;            
	MAT  READ #PRC,PRR,846;PFTB;          
	READ #PRC,PRR,854;UPCT;               
	MAT  READ #PRC,PRR,856;C1$;           
	MAT  READ #PRC,PRR,894;PR_C4;         
	MAT  READ #PRC,PRR,938;PF_LOAD2;      
	MAT  READ #PRC,PRR,944;PR_A2$;        
	MAT  READ #PRC,PRR,974;PFCO;          
	MAT  READ #PRC,PRR,990;PLV;           
	MAT  READ #PRC,PRR,1002;PLC;          
	MAT  READ #PRC,PRR,1018;PFN;          
	MAT  READ #PRC,PRR,1030;STK;          
	MAT  READ #PRC,PRR,1048;FDT;          
	MAT  READ #PRC,PRR,1056;PRFLG$;       
	MAT  READ #PRC,PRR,1066;PRBASE;       
	MAT  READ #PRC,PRR,1068;PRMKUP;                     
	MAT  READ #PRC,PRR,1084;PRMKUPTYP$;                       
	MAT  READ #PRC,PRR,1088;FUT;                              
	MAT  READ #PRC,PRR,1100;PRPARC2;                          
	MAT  READ #PRC,PRR,1108;PRREDI;                           
	MAT  READ #PRC,PRR,1120;PIC$; 
	MAT  READ #PRC,PRR,1270;PRD0;                             
	MAT  READ #PRC,PRR,1282;PRIML$;                           
	MAT  READ #PRC,PRR,1294;PRD1;                            
	MAT  READ #PRC,PRR,1304;PRD2;           
	! clear variables needed ! 
	FOR I=0 TO 33                         
		FOR A2=0 TO 2                       
			IF I<=12 LET P2[I,A2]=0           
		NEXT A2                             
		IF I<=3 LET A[I]=0                  
		IF I>=7 and I<=19 LET A[I]=0         
		IF I>=26 LET A[I]=0                 
		IF I>=1 and I<=7 LET B[I]=0          
		IF I>=12 and I<=15 LET B[I]=0        
		IF I<4 LET PFCO[I]=0                
	NEXT I                                
	LET PR_A2$[1,12]=" ",PR_A2$[1,12]     
	LET A1[0]=0 \ LET A1[2]=0 \ LET A2=0
	A3[0]=0;A3[1]=0;A3[2]=0 ! HAZ,MSDS,
	! lm[0]=0;lm[1]=0 keep load markup tables from Z_ZZZZZZ
	hz$=" ",hz$
	Read #ctlc,3,172;currdate;
	LET pr_C4[7]=currdate ! DATE ESTABLISHED
	! U4[0]=0;U4[1]=0 keep Except Sale and Lead Time % from Z_ZZZZZZZ
	! PR_C4[3]=0; keep Price Markup Table
	U2[0]=0;U2[1]=0
	A$[116,126]="           " ! COST GROUP
    Call dxget("DESC1",tmp$)
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Description 1"
		Goto NSBPrdDone
	Endif
	A$[9,38]=rtrim$(tmp$) + Blank$ 
	Call dxget("DESC2",tmp$)
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Description 2"
		Goto NSBPrdDone
	Endif
	A$[63,92] = rtrim$(tmp$) + Blank$                            
	Call dxget("VENDITM",tmp$) 
	strgok=chkbadchars(e$,tmp$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Vendor Item"
		Goto NSBPrdDone
	Endif
	A$[93,112] = rtrim$(tmp$) + Blank$                               
	A$[140,151]=prod$
	Call dxget("COMMD",tmp$)              
	A$[152,155]=rtrim$(tmp$)+blank$
	Call dxget("PRODTAXTYPE" ,tmp$) ! +Str$(X1),tmp$)
	let tmp3=tmp$
	if tmp3<1 or tmp3>99
		returnstatus=0
		Message$="Invalid Product Tax Type"
		Goto NSBPrdDone 
	Endif
	A1[7]=tmp3
	call dxget("UNITCOST",tmp$) !+Str$(X1),tmp$) ! NSBUILD
	V3[9]=tmp$
	if v3[9]<0 or v3[9]>9999999
		returnstatus=0
		message$="Unit Cost is out of range"
		Goto NSBPrdDone
	Endif
	CALL dxget("NETCOST",tmp$)
	v3[8]=tmp$
	if v3[9]<0 or v3[9]>9999999
		returnstatus=0
		message$="Unit Cost is out of range"
		Goto NSBPrdDone
	Endif
	Call dxget("BASEUM",tmp$) 
	!If tmp$[1,1] > "9" ! sent text?             
		 R = getumrec(e$,ccc,tmp$,IntCo,PR.)       
		If R <> 0 Let tmp$ = Str$(R)              
	!End If                                      
	UNWORK[0] = tmp$
	if unwork[0]<0
		returnstatus=0
		Message$="Invalid Base UM"
		Goto NSBPrdDone
	Endif
	! Costing unit of measure ! unwork[3]
	Call dxget("COSTUM",tmp$) 
	!If tmp$[1,1] > "9" ! sent text?             
		 R = getumrec(e$,ccc,tmp$,IntCo,PR.)       
		If R <> 0 Let tmp$ = Str$(R) 
	!End If                                      
	UNWORK[3] = tmp$	
	! Purchasing unit of measure ! unwork[4]
	Call dxget("QTYUM",tmp$) 
	!If tmp$[1,1] > "9" ! sent text?             
		 R = getumrec(e$,ccc,tmp$,IntCo,PR.)       
		If R <> 0 Let tmp$ = Str$(R)              
	!End If                                      
	UNWORK[4] = tmp$ ! 
	! lbs unit of measure ! unwork[4]
	Call dxget("UMLBS",tmp$)  ! this might be lbs factor
	!If tmp$[1,1] > "9" ! sent text?             
		 R = getumrec(e$,ccc,tmp$,IntCo,PR.)       
		If R <> 0 Let tmp$ = Str$(R)              
	!End If                                      
	UNWORK[5] = tmp$
	Call dxget("UMCUBE",tmp$) !+Str$(X1),tmp$)   
	!If tmp$[1,1] > "9" ! sent text?              
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)        
		If R <> 0 Let tmp$ = Str$(R)               
	!End If 
	UNWORK[6] =tmp$ ! UNFWORK[6]=tmp$
	! let do the factors
	Call dxget("STOCKUM",tmp$) !+Str$(X1),tmp$)   
	!If tmp$[1,1] > "9" ! sent text?              
		R = getumrec(e$,ccc,tmp$,IntCo,PR.)        
		If R <> 0 Let tmp$ = Str$(R)               
	!End If 
	UNWORK[7] =tmp$ ! UNFWORK[6]=tmp$
	Call dxget("STOCKFCTR",tmp$)
	let unfwork[7]=tmp$
	Call dxget("COSTFCTR",tmp$) 
	UNFWORK[3]=tmp$ \ If unfwork[3] <= 0 Let unfwork[3] = 1
	Call dxget("QTYFCTR",tmp$)                           
	UNFWORK[4]=tmp$ \ If unfwork[4] <= 0 Let unfwork[4] = 1
	Call dxget("LBSFCTR",tmp$)
	UNFWORK[5]=tmp$ \ If unfwork[5] <= 0 Let unfwork[5] = 1
    Call dxget("CUBEFCTR",tmp$) 
	UNFWORK[6]=tmp$ \ If unfwork[6] <= 0 Let unfwork[6] = 1!+Str$(X1),tmp$)
	let unfwork[5]=-1;unfwork[6]=-1 
	for ctr=3 to 4
		if unwork[5]=unwork[ctr] ! matching lb factor
			let unfwork[5]=unfwork[ctr]
		endif
		if unwork[6]=unwork[ctr] ! matching cube factor
			let unfwork[6]=unfwork[ctr]
		endif
	next ctr
	if unfwork[5]=-1 and unwork[5]=unwork[7] ! stocking um
		let unfwork[5]=unfwork[7]
	else
		let unfwork[5]=1
	endif
	if unfwork[6]=-1 and unwork[6]=unwork[7]
		let unfwork[6]=unfwork[7]
	else
		let unfwork[6]=-1
	endif
	! default selling from purchasing um
	let unwork[1]=unwork[4]
	let unfwork[1]=unfwork[4]
	! default pricing from costing um
	let unwork[2]=unwork[3]
	let unfwork[2]=unfwork[3]
    !Call dxget("VENDOR",tmp$)
	LET B[24]=poh.VendorCode! Tmp$! vendor code 
	Call dxget("SLSCAT",tmp$) 
	LET B[11]=tmp$
	Call dxget("CUBE",tmp$) 
	LET B[23]=tmp$ ! cube feet
	Call dxget("WEIGHT",tmp$) 
	LET A[6]=tmp$ ! cube feet 
	LET krol$=" ",krol$
	KRol$[1,6] = pol.SalesOrd Using "######"  
	KRol$[7] = pol.SalesOrdLine Using "###"   
	Search #OLC,2,1;KRol$,rec_rol,e 
	If e<>0
		let rec_rol=-1
	else
		read record #olc,rec_rol,0;rol.;
		! check product code
		if Ucase$(trim$(pol.ProdCode$))<>uCase$(trim$(rol.ProdCode$)) ! diff product
			let rec_rol=-1
		endif
		if rol.NStkItem=0 ! it's a product
			let rec_rol=-1
		endif
	endif
	if rec_rol>0
		let nsr=rol.pdrecnum
		read record #nsc,nsr,0;prdesc.;
		if unwork[0]=rol.UMBase
			let uNwork[1]=rol.UMSell
			let uNfwork[1]=rol.SellFactor
			let uNwork[2]=rol.umprice
			let uNfwork[2]=rol.PriceFactor
			! 
		endif
		a$[156,156]=rol.MatCode$   ! material code 
		if prdesc.HazFlg<>0 
			if prdesc.HazFileRecno>0
				a3[2]=prdesc.HazFileRecno
			endif
		endif
		LET HZ$[41,64]=rtrim$(prdesc.HazClass$)+BLANK$ ! haz class
		let HZ$[65,70]=rtrim$(prdesc.PackGrp$)+blank$ ! pack group
		let hz$[71,80]=rtrim$(prdesc.DotID$)+blank$ ! dot id
		let hz$[81,90]=rtrim$(prdesc.ERGdbk$)+blank$ ! err book
	endif
	LET PFU1[0]=UNWORK[0]                  
	LET K=0                                
	FOR Y=1 TO 4                         
		FOR X=0 TO 7                           
			 IF UNWORK[Y]=PFU1[X] GOTO NEXTY:     
		NEXTX: NEXT X                          
		LET K=K+1                              
		IF UNWORK[Y]>0 LET PFU1[K]=UNWORK[Y]   
		IF UNWORK[Y]>0 LET PFU2[K-1]=UNFWORK[Y]
	NEXTY: NEXT Y                  
	FOR X=0 TO 7                           
		 IF UNWORK[7]=PFU1[X] GOTO ENDSTOCKUM:     
	NEXT X                          
	LET K=K+1                              
	IF UNWORK[7]>0 LET PFU1[K]=UNWORK[7]   
	IF UNWORK[7]>0 LET PFU2[K-1]=UNFWORK[7]
	ENDSTOCKUM: !
	! stocking unit of measure
	LET PFU1[8]=UNWORK[7]
	LET PFU1[9]=UNWORK[1]                  
	LET PFU1[10]=UNWORK[4]                 
	LET PFU1[11]=UNWORK[3]                 
	LET PFU1[12]=UNWORK[2] 
	! SET TO PURCHASING UNIT OF MEASURE
	!LET PFU1[8]=unwork[7] ! PFU1[10] ! STOCKING
	LET PFU1[20]=PFU1[10] ! VENDOR ORDER
	LET PFU1[18]=PFU1[10] ! PACKING
	LET PFU1[19]=PFU1[10]  ! PROD SIZE
	! SET TO SELLING UNIT OF MEASURE
	LET PFU1[16]=PFU1[9] ! UPCHARGE
	LET PFU1[17]=PFU1[9] ! BROKEN
	LET PFU1[13]=PFU1[9] ! PROD/POS
	LET A1[3]=UNFWORK[6]                   
	!LET B[23]=UNWORK[6]  ! cube feet                   
	!LET A[6]=UNWORK[5]  ! lbs                   
	LET A[5]=UNFWORK[5]                    
	LET PGWL=A[6];PGWF=A[5] 
	! SET COST
	if v3[9]>0 ! sent unitcost
		if p61$[136,136]="Y" and pol.currfact<>0 ! going from costing um to base
			let cnvcu[0]=2
			let cnvca[0]=v3[9]
			let cnvca[1]=pol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let v3[9]=cnvca[0]
		endif
		CNVTU[0]=unwork[3];CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
		cnvta=v3[9] 
		pol.UnitCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)

		LET PR_C4[4]=pol.UNITCOST ! base cost
		let b[10]=pol.unitcost ! po cost
		let b[21]=pol.unitcost ! average cost
	Endif
	if v3[8]>0 ! sent netcost
		if p61$[136,136]="Y" and pol.currfact<>0 ! going from costing um to base
			let cnvcu[0]=2
			let cnvca[0]=v3[8]
			let cnvca[1]=pol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let v3[8]=cnvca[0]	
		endif
		CNVTU[0]=unwork[3];CNVTU[1]=0;CNVTU[2]=6 ! to base no round was =2
		cnvta=v3[8] 
		pol.NetCost=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		PRPARC[2]=pol.NetCost
	Endif
	let e=2
	search #prc,1,0;keyprod$,rec_prod,e
	if e
		let returnstatus=0
		let message$="Error in Allocating Product Id "+Rtrim$(PROD$)+" Cannot Add"
		goto NSBPrdDone
	endif
	LET A[26]=REC_PROD;PRR=REC_PROD
    MAT  WRITE #prc,REC_PROD,0;A$          
	MAT  WRITE #prc,REC_PROD,156;B         
	MAT  WRITE #prc,REC_PROD,256;A         
	MAT  WRITE #prc,REC_PROD,460;A1        
	MAT  WRITE #prc,REC_PROD,508;A2        
	MAT  WRITE #prc,REC_PROD,512;PFU1      
	MAT  WRITE #prc,REC_PROD,554;PFU2      
	MAT  WRITE #prc,REC_PROD,596;PRPARC    
	MAT  WRITE #prc,REC_PROD,620;LM        
	MAT  WRITE #prc,REC_PROD,624;PR_PO     
	MAT  WRITE #prc,REC_PROD,628;AGEDAY    
	WRITE #prc,REC_PROD,630;LLC            
	MAT  WRITE #prc,REC_PROD,632;PSN$      
	MAT  WRITE #prc,REC_PROD,652;PSN       
	MAT  WRITE #prc,REC_PROD,660;U2        
	MAT  WRITE #prc,REC_PROD,664;LBSORD
	MAT  WRITE #prc,REC_PROD,670;U4            
	WRITE #prc,REC_PROD,678;U3                 
	MAT  WRITE #prc,REC_PROD,684;U3$           
	MAT  WRITE #prc,REC_PROD,744;HZ$           
	MAT  WRITE #prc,REC_PROD,834;A3            
	MAT  WRITE #prc,REC_PROD,846;PFTB   
	WRITE #prc,REC_PROD,854;UPCT               
	MAT  WRITE #prc,REC_PROD,856;C1$           
	MAT  WRITE #prc,REC_PROD,894;PR_C4         
	MAT  WRITE #prc,REC_PROD,938;PF_LOAD2      
	MAT  WRITE #prc,REC_PROD,944;PR_A2$        
	MAT  WRITE #prc,REC_PROD,974;PFCO          
	MAT  WRITE #prc,REC_PROD,990;PLV           
	MAT  WRITE #prc,REC_PROD,1002;PLC          
	MAT  WRITE #prc,REC_PROD,1018;PFN          
	MAT  WRITE #prc,REC_PROD,1030;STK          
	MAT  WRITE #prc,REC_PROD,1048;FDT          
	MAT  WRITE #prc,REC_PROD,1056;PRFLG$       
	MAT  WRITE #prc,REC_PROD,1066;PRBASE       
	MAT  WRITE #prc,REC_PROD,1068;PRMKUP	                        
	MAT  WRITE #prc,REC_PROD,1084;PRMKUPTYP$                       
	MAT  WRITE #prc,REC_PROD,1088;FUT                              
	MAT  WRITE #prc,REC_PROD,1100;PRPARC2                          
	MAT  WRITE #prc,REC_PROD,1108;PRREDI                           
	MAT  WRITE #prc,REC_PROD,1120;PIC$                             
	MAT  WRITE #prc,REC_PROD,1270;PRD0                             
	MAT  WRITE #prc,REC_PROD,1282;PRIML$                           
	MAT  WRITE #prc,REC_PROD,1294;PRD1                             
	MAT  WRITE #prc,REC_PROD,1304;PRD2;
	K1$=KEYPROD$
	SEARCH #prc,4,1;K1$,REC_PROD,E
	IF E>1
		let returnstatus=0
		message$="Error in Adding Directory 1 for Product "+Rtrim$(prod$)
		Goto NSBPrdDone
	endif        
	LET K2$=" ",K2$ \ LET K2$[2,2]=A$[139,139] \ LET K2$[3]=K1$        
	SEARCH #prc,4,2;K2$,REC_PROD,E 
	IF E>1
		let returnstatus=0
		message$="Error in Adding Directory 2 for Product "+Rtrim$(prod$)
		Goto NSBPrdDone
	endif     
	LET K3$=" ",K3$ \ LET K3$[1,4]=A$[152,155] \ LET K3$[5]=K1$[1,12]  
	SEARCH #prc,4,3;K3$,REC_PROD,E
	IF E>1
		let returnstatus=0
		message$="Error in Adding Directory 3 for Product "+Rtrim$(prod$)
		Goto NSBPrdDone
	endif       
	LET K4$=" ",K4$ \ LET K4$[1,20]=A$[93,112] \ LET K4$[21]=K1$       
	SEARCH #prc,4,4;K4$,REC_PROD,E
	IF E>1
		let returnstatus=0
		message$="Error in Adding Directory 4 for Product"+Rtrim$(prod$)
		Goto NSBPrdDone
	endif       
	!sqlChan = OpenMySQLChan(e$) !
	!if sqlChan >= 0 ! SQL option enabled and open succeeded
	!	e = prod_UpdateSQLFromDL4(e$, intCo, K1$, sqlChan, prc)
	!	if E<>1 ! 1 record inserted / updated
	!		message$="Error adding MySQL product record!"
	!		Goto NSBPrdDone
	!	end if
	!end if
	LET K5$[1,30]=UCase$(A$[9,38])+blank$
	Let k5$[31]=A$[140,151]  
	! need to open a product description file
	SEARCH #CH_PDESCKEY,4,1;K5$,REC_PROD,E
	IF E>1
		let returnstatus=0
		message$="Error in Adding Product Description Key "+Rtrim$(prod$)
		Goto NSBPrdDone
		endif     
	! UPDATE PROD SALES
	WRITE #CH_PRSLS,REC_PROD,0;A$[140,151]
	MAT  WRITE #CH_PRSLS,REC_PROD,16;P2   
	MAT  WRITE #CH_PRSLS,REC_PROD,256;P2; 
	! UPDATE WAREHOUSE -- GET WAREHOUSE FROM HEADER
	
	let k5$=" ",k5$
	k5$[1,12]=prod$[1,12]
	k5$[13]=pol.Whse Using "##"
	PWR=filegetprodwhse(e$,PWC,"=",1,k5$,pw.)
	clear e$
	if PWR<0 ! not found
		Clear pw.
		Whbld[0] = PWC
		if pol.whse<=0 let pol.whse=poh.warehouse
		if pol.whse<=0 let pol.whse=1
		! whbld[0] = channel number for prodwhse file
		Whbld[1] = pol.Whse
		Whbld[2] = B[24] ! vednor
		WHBLD[3]=1 ! flag as non-stock
		IF pol.whse<>1 let whbld[1]=pol.whse+.01 ! fra=copy whse 1
		Call mxwhcreate(e$,IntCo,Prod$,Whbld[])        
		PWR = Whbld[2];e$ = "" 
		read record #pwc,pwr,0;pw.;
		nspwkey$=" ",nspwkey$
		let nspwkey$[1,12]="Z ZZZZZZZZZZ"
		let nspwkey$[13,14]=rol.whse using "##"
		rec_nspw=0
		search #pwc,2,1;nspwkey$,rec_nspw,e
		if not (e)
			read record #pwc,rec_nspw,0;nspw.;
		else
			let rec_nspw=0
			if rol.whse<>1
				let nspwkey$[13,14]=" 1"
				search #pwc,2,1;nspwkey$,rec_nspw,e
				if not(e)
					read record #pwc,rec_nspw,0;nspw.;
				else
					let rec_nspw=0
				endif
			endif
		endif
		if rec_nspw<>0 ! ok
			pw.VendPN$= A$[93,112]
			pw.DNReordFlg=nspw.DNReordFlg! 
			pw.ProdGrp=nspw.ProdGrp 
			pw.FrcstWgtTbl=nspw.FrcstWgtTbl ! Forecase
			pw.CalcSrc=nspw.Calcsrc ! Reorder Table
			if P9$[32,32]="Y" ! warehouse pricing
				Pw.CostAvg=b[21]   
				pw.CostLastPo=b[10]
				pw.CostBase=pr_c4[4]
			endif
			write record #pwc,pwr,0;pw.;
		endif			
		PRR = filegetprod(e$,PRC,"=",1,keyprod$,PR.)

	endif
	Read Record #PWC,PWR,0;pw.;
	if not(pol.buyer) let pol.buyer=poh.buyer
	if pol.buyer<>pw.buyer
		let k3$=" ",k3$
		let k3$[1,2]=pw.whse using "##"
		let k3$[3,5]=pw.buyer using "###"
		let k3$[6,17]=pw.prodcode$
		search #pwc,2,2;k3$,tmprec,e
		if not(e)
			search #pwc,5,2;k3$,tmprec,e
		endif
		let k4$=k3$
		let k4$[3,5]=pol.buyer using "###"
		search #pwc,4,2;k4$,pwr,e
	endif
	pw.Buyer = pol.buyer 
	write Record #PWC,PWR,0;pw.;
	if P61$[35,35] = "Y"
		Read record #PRC,Rec_Prod,0;pr.; ! reread new rec
		!fle[0]=ctlc
		!fle[1]=prc
		!fle[2]=pwc
		!errstatus=1
		e$=""
		!Call turboadd(intco,prod$,e$,fle[],errstatus)
		call apturbo(e$,CTLC,IntCo,REC_PROD,pr.) ! add new turbo
		e$=""
	endif
	
	! need to delete the non-stock item
	if pol.itemno<>0 and rec_pol>0
		rec_nstk = pol.proddescrec ! record                                        
		X3 = fileupdatenstkdesc(e$,ch_nstk,"d",rec_nstk,nstk.)
		pol.proddescrec=PRR ! rec_prod 
		CLEAR FLAGS[]
		FLAGS[0]=0 ! NONSTK  -- no longer a non-stock
		FLAGS[1]=CLOSEDshort
		FLAGS[2]=ZLINE
		LET X2=0 
		FOR K=0 TO 11       
			IF FLAGS[K] LET X2=X2+2^K    
		 NEXT K 
		LET pol.flags=X2  
		pol.UpdStock=1 ! set to update stock 
		tmp$=pr.ComdtyCode$
		if tmp$="LABR" OR tmp$="TIME" OR tmp$="MACH" LET pol.UpdStock=0 ! comm's no stk
		!!!! check product group  !!! 
        !If PW.ProdGrp>0 ! has a group
		!	Pram[0]=0-(poh.Type+1) !  \ if TScan=2 Let Pram[0]=0-OType+1
		!	Pram[1]=PW.ProdGrp
		!	Pram[5]=0 ! file not opened
			![0]=PO or (-)PO Type
			! [1]=Product Group
			! [2]=Allow on Ord/PO (1=y, 0=N)
			! [3]=Update Stock (1=y, 0=N)
			! [4]=On Price List (0/1)
			! [5]=Channel of 2/ProdGrp#
		!	Call ProdGroup(e$,intco,Pram[])
		!	If Pram[2]=0  ! not allowed on OType
				! already on from non-stock
				!E$="Product Not Allowed on this PO Type!"
				!if debugdetail
				!	dmsg$=E$+" OT "+Str$(pOH.Type)+" PG "+Str$(PW.ProdGrp) \ Call updatelog(debug)
				!Endif
				!Exit Sub
			!else
			!	pol.UpdStock=Pram[3] ! update Stock
		!	Endif		
		!Endif 
		if poh.type=1 let pol.updstock=0 ! update stock on directs
		if poh.type=2 and P60$[22,22]<>"Y" let pol.updstock=0 ! indirects
		if poh.type=5 let pol.updstock=0 ! import directs
		if poh.type=6 and P60$[22,22]<>"Y" let pol.updstock=0 ! import ind
		! check commodity code of TIME,MACH,LABR LET UpdStock=0 ! STOCK UPDATE=N
		pol.ProdCode$=rtrim$(prod$)+blank$
		Write Record #ch_pol,rec_pol,0;pol.;
		let polkey2$=""
		let polkey2$[1,6]=pol.proddescrec using "######"
		let polkey2$[7,12]=pol.poNum using "######"
		let polkey2$[13,15]=pol.itemno using "###"
		search #ch_pol,4,2;polkey2$,rec_pol,e
		let polkey2$[1,6]=rec_nstk using "######"
		search #ch_pol,5,2;polkey2$,rec_pol,e
		! update stock
		Read Record #PRC,PRR,0;pr.               
		If pwr > 0 Read Record #PWC,pwr,0;pw.    
		X3 = pol.QtyOrd + pol.FreeGoods              
		pr.QtyOnPO = pr.QtyOnPO + X3           
		pw.QtyOnPO = pw.QtyOnPO + X3 
		write Record #PRC,PRR,0;pr.;              
		If pwr > 0 write Record #PWC,pwr,0;pw.;
	endif
	if rec_rol<=0 goto NSBPrdDone:
	! delete line nonstock description record
	nsr = rol.PDRecNum ! record                                        
	Read Record #nsc,nsr,0;prdesc.;
	if prdesc.SpareNu$=""
		let prdesc.SpareNu$="  "
		write record #NSC,NSR,0;prdesc.;
	Endif
	
	clear chan[]
	chan[0] = ctlc ! control file
	chan[1] = ch_poh !purchase order header	
	chan[2] = ch_pol ! purchase order lines   #61
	chan[3] = ohc ! sales order header 
	chan[4] = prc ! product file 
	chan[5] = pwc ! product warehouse #
	chan[6] = ch_nstk ! nonstock purchase order #66
	chan[7] = ccc ! unit of measure file #67
	chan[8] = olc !order lines #68
	chan[9] = 0 ! po messages  Not Used
	chan[10] =0 !  order message Not Used
	chan[11] = 0!  not used 
	chan[12] = ch_deals ! deals #19
	chan[13] = cuc ! customer
	chan[14] = otc ! order total
	chan[15] = ch_alt ! altvend
	chan[16] = nsc ! nonstock sales order
	chan[17] = 0 ! lastprice --- open in call
	chan[18] = cmc ! commodity code header
	chan[19] = osc ! order ship to file
	parm[0] = rec_pol ! purchase order line record #
	parm[1]=rec_poh ! purchase order record #
	parm[2]=pono! Purchase order id #
	parm[3]=pol.salesord
	parm[4]=rec_prod
	parm[5]=rec_prwh
	parm[6]=rec_rol
	parm[7]=0
	parm[8]=rec_uac
	parm[9]=intco ! control #
	msg$=""
	errtype=0
	call "sopolinecreate.dl4",Chan[],parm[],msg$,errtype,userid$
	
	NSBPrdDone: ! done
	if returnstatus=1 let message$="OK" ! set if no other problems
		if debugdetail
		dmsg$="Product "+rtrim$(Prod$)+" Built "+Str$(pol.ponum)+"-"+Str$(pol.itemno)+" "+Message$ \ Call updatelog(debug)
	Endif
 else
	include "src/callsuberr.inc"
 end try
End sub !NSBUILDPROD

!---------------------------------------------------------------------
Sub nsgetitem()
!--------------------------------------------------------------------

 try
	dim 1%,tmptax
	dim Polkey$[60],KCM$[40]
	Dim vend. As a80vm
	clear pol.
	clear nstk.
	rec_pol=-1
	If debugdetail                                                    
		dmsg$ = "Start Get NonStock Line Detail" \ Call updatelog(debug)    
	End If                                                            
	ReturnStatus = 1                                                  
	Message$ = "OK"                                                   
	Call dxget("POID",tmp$)                                        
	If tmp$ = "" Goto EndNSGetItem                                       
	pono = tmp$                                                    
		If pono < 1 Or pono > 999999 Or Fra(pono)                
		 ReturnStatus = 0                                                
		 Message$ = "PURCHASE ORDER NUMBER INVALID"                               
		Goto EndNSGetItem                                                 
	End If                                                            
	rec_poh = getpohrec(e$,ch_poh,pono,poh.)  
	If rec_poh <= 0 ! not found                                               
		ReturnStatus = 0                                                    
		Message$ = "PURCHASE ORDER WAS NOT FOUND"                                    
		Goto  EndNSGetItem                                                       
	End If                                                                
	           
	Call dxget("LTYPE",tmp$)                                              
	tmp$ = UCase$(tmp$)                                                   
	If tmp$[1,4] <> "NSTK"                                                     
		 ReturnStatus = 0                                                    
		Message$ = "Purchase Order Line has Invalid Line Type. Not a non-stock item."
		Goto EndNSGetItem                                                     
	End If                                                                
	Let NonStk = 1                                  
	Call dxget("LN",tmp$)                              
	pol.ItemNo = tmp$ 
	If pol.ItemNo < 1 Or pol.ItemNo > 999 Or Fra(pol.ItemNo)                
		 ReturnStatus = 0                                                
		 Message$ = "PURCHASE ORDER LINE NUMBER INVALID"                               
		Goto EndNSGetItem 
	endif
	Call dxget("SOURCE",tmp$)
	let source=tmp$
	polkey$ = " ",polkey$                                 
	polkey$[1,6] = pono Using "######"                    
	polkey$[7,9] = pol.ItemNo Using "###"                
	polkey$[10] = "" ! cut to length (space @ 10)         
	rec_pol = filegetpoline(e$,ch_pol,"=",1,polkey$,Pol.) 
	                   
	If rec_pol <= 0 ! what do we do if not found?                          
		 ReturnStatus = 0                                                
		 Message$ = "PURCHASE ORDER LINE NOT ON FILE"                               
		Goto EndNSGetItem 
	endif
    	! no check the flags !!!
	X2 = Pol.flags ! ! REM UNPACK pol.Flags TO FLAGS[x]       
	For K = 0 To 11                                           
		flags[K] = Sgn(Fra(X2 / 2)) \ X2 = Int(X2 / 2)          
	Next K                                                    
	NonStk = flags[0]                                         
	Closedshort = flags[1]                                         
	ZLine = flags[2]
	let closed=0
	if pol.status=3 let closed=99
	if poh.status=7 let closed=99
	If Not(NonStk)
          	 ReturnStatus = 0                                                
		 Message$ = "PURCHASE ORDER LINE IS NOT A NON-STOCK LINE" 
		 clear Pol.
		 rec_pol=-1
		 Goto EndNSGetItem 
	endif
	!if Closed <>0   ! it's a zline line  
	!	ReturnStatus = 0                                                
	!	 Message$ = "PURCHASE ORDER LINE IS CLOSED. MAY NOT EDIT" 
	!	 clear Pol.
	!	 rec_pol=-1
	!	 Goto EndNSGetItem 
	!endif
	if Zline <>0   ! it's a zline line  
		ReturnStatus = 0                                                
		 Message$ = "PURCHASE ORDER LINE IS NOT A NON-STOCK LINE" 
		 clear Pol.
		 rec_pol=-1
		 Goto EndNSGetItem 
	endif
	rec_nstk = pol.proddescrec
	if not(rec_nstk)
		ReturnStatus = 0                                                
		 Message$ = "Invalid Non-Stock Record " 
		 clear Pol.
		 clear nstk.
		 rec_pol=-1
		 rec_nstk=-1
		 Goto EndNSGetItem 
	endif
	Read Record #ch_nstk,rec_nstk,0;nstk.                                   
	Call setprtopol() ! set to pol. factors 
	
	EndNSGetItem: ! load this up for heading
     	clear list$[]
	list$[0]=bsdel$,"GETNONSTOCK",fdel$
	webstr$="QTYORD",fdel$ ! 
	webstr$=webstr$,"UNITCOST",fdel$
	webstr$=webstr$,"IDBASE",fdel$!
	webstr$=webstr$,"BASEUM",fdel$ !
	webstr$=webstr$,"IDSTOCK",fdel$
	webstr$=webstr$,"STOCKUM",fdel$
	webstr$=webstr$,"STOCKFCTR",fdel$
	webstr$=webstr$,"IDQTY",fdel$
	webstr$=webstr$,"QTYUM",fdel$
	webstr$=webstr$,"QTYFCTR",fdel$
	webstr$=webstr$,"IDCOST",fdel$
	webstr$=webstr$,"COSTUM",fdel$
	webstr$=webstr$,"COSTFCTR",fdel$
	webstr$=webstr$,"WEIGHT",fdel$
	webstr$=webstr$,"LBSFCTR",fdel$
	webstr$=webstr$,"UMLBS",fdel$
	webstr$=webstr$,"CUBE",fdel$
	webstr$=webstr$,"CUBEFCTR",fdel$
	webstr$=webstr$,"UMCUBE",fdel$
	webstr$=webstr$,"DESC1",fdel$
	webstr$=webstr$,"DESC2",fdel$
	webstr$=webstr$,"SLSCAT",fdel$
	webstr$=webstr$,"SLSCATDESC",fdel$
	webstr$=webstr$,"COMMD",fdel$
	webstr$=webstr$,"COMMDDESC",fdel$
	webstr$=webstr$,"VENDITM",fdel$
	webstr$=webstr$,"VENDOR",fdel$
	webstr$=webstr$,"VENDNAME",fdel$
	webstr$=webstr$,"LN",fdel$
	webstr$=webstr$,"BUILDPRODFLAG",fdel$
	webstr$=webstr$,"PRODTAXTYPE",fdel$
	List$[1]=webstr$
	if rec_pol>0
		webstr$=""
		CNVTU[0] = 0;CNVTU[1] =pol.qtyum;cnVTU[2] = 1          
		CNVTA = pol.QtyOrd                                       
		X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)      
		WebStr$ = WebStr$,LTrim$(X3 Using QMask$),fdel$ ! Qty Ord
		CNVTU[0] = 0;CNVTU[1] = pol.costum;CNVTU[2] = 2                
		cnvta=pol.unitcost
		X3 = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		if p61$[136,136]="Y" and pol.currfact<>0 ! going from base to costing um
			let cnvcu[0]=1
			let cnvca[0]=x3
			let cnvca[1]=pol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let x3=cnvca[0]
		endif
        WebStr$ = WebStr$,LTrim$(X3 Using pMask$),fdel$ ! Unit Cost                         
		webstr$ = webstr$,str$(nstk.BaseUM),fdel$ ! Base rec#/id
		tmp$=XUnit$(nstk.BaseUM,ccc) ! u/m
		webstr$=webstr$,rtrim$(tmp$),fdel$
		webstr$ = webstr$,str$(nstk.StockUM),fdel$ ! Stock rec#/id
		tmp$=XUnit$(nstk.StockUM,ccc) ! u/m
		webstr$=webstr$,rtrim$(tmp$),fdel$
		webstr$=webstr$,str$(nstk.StkFact),fdel$
		webstr$ = webstr$,str$(nstk.PURCHUM),fdel$ ! PURCH rec#/id
		tmp$=XUnit$(nstk.PURCHUM,ccc) ! u/m
		webstr$=webstr$,rtrim$(tmp$),fdel$
		webstr$=webstr$,str$(nstk.poFact),fdel$
		webstr$ = webstr$,str$(nstk.CostUM),fdel$ ! Cost rec#/id
		tmp$=XUnit$(nstk.CostUM,ccc) ! u/m
		webstr$=webstr$,rtrim$(tmp$),fdel$
		webstr$=webstr$,str$(nstk.CostFact),fdel$
		WebStr$ = WebStr$,LTrim$(nstk.wgt Using PMask$),fdel$ ! wgt unit       
		tmp$ = Str$(nstk.WgtFact)                                                
		Call factorum(tmp$) ! get um for factor                                   
		WebStr$ = WebStr$,Str$(nstk.WgtFact),fdel$,RTrim$(tmp$),fdel$ ! wgt facto
	        WebStr$ = WebStr$,LTrim$(nstk.Cube Using PMask$),fdel$ ! cube unit     
		 tmp$ = Str$(nstk.CubeFact)                                               
		Call factorum(tmp$) ! get um for factor                                   
		WebStr$ = WebStr$,Str$(nstk.CubeFact),fdel$,Rtrim$(tmp$),fdel$
		tmp$=clrtxtc$(e$,nstk.Desc1$)
		Webstr$=webstr$,RTrim$(tmp$),fdel$ !  desc 1
		tmp$=clrtxtc$(e$,pol.Desc2$)
		Webstr$=webstr$,RTrim$(tmp$),fdel$ !  desc 2
		!webstr$=webstr$,rtrim$(nstk.desc1$),fdel$ 
		!webstr$=webstr$,rtrim$(nstk.desc2$),fdel$ 
		webstr$=webstr$,str$(nstk.ProdCat),fdel$
		clear psc.
		if nstk.ProdCat
			if not(ch_psc)
				ch_psc = openfile(-1984,intCo) \ If ch_psc = -1 Error 42 ! prod 	
			endif
			If nstk.ProdCat > 0 And nstk.ProdCat< (Chf(ch_psc) - 1)
				Read Record #ch_psc,nstk.ProdCat;psc.; 
			endif
		endif
		webstr$=webstr$,rtrim$(psc.CategoryDesc$),fdel$ 
		webstr$=webstr$,rtrim$(nstk.CmdtyCode$),fdel$
		if not(cmc)
			cmc = openfile(-2288,intCo) \ If cmc = -1 Error 42 ! commo
		endif
		KCM$ = " ",KCM$        
		KCM$ = nstk.CmdtyCode$ 
		cmr = filegetcommhead(e$,cmc,"=",1,kcm$,cMC.)
		if cmr<=0
			clear cmc.
		endif
		webstr$=webstr$,rtrim$(cmc.CodeDescription$),fdel$
		tmp$=clrtxtc$(e$,nstk.VendPart$)
		Webstr$=webstr$,RTrim$(tmp$),fdel$ !  Vendor Item Code
		!webstr$=webstr$,rtrim$(nstk.VendPart$),fdel$
		webstr$=webstr$,str$(nstk.vendid),fdel$
		clear vend.
		if nstk.vendid<>0
			if not(vnc)
				vnc = OpenFile(-2400,IntCo) \ If vnc = -1 Error 42 ! vendor droplist
			endif
			let tmp$=nstk.vendid using "######"
			vnr = filegeta80vm(e$,vnc,"=",1,tmp$,vend.) 
			if vnr<0
				clear vend.
			endif
		endif
		webstr$=webstr$,rtrim$(vend.name$),fdel$ ! vendor name
		webstr$=webstr$,str$(nstk.LineNum),fdel$
		let tmp$="N"
		if p61$[85,85]="P" let tmp$="Y" ! buildprod from non-stock flag
		If source>380 let tmp$="N" ! not from debit memos
		webstr$=webstr$,tmp$,fdel$
		webstr$=webstr$,str$(nstk.PTAXTYPE),fdel$
		list$[2]=webstr$
	endif
	Call AddToStr(e$,rstr$,List$[]) !                   
	Call AddToStr(e$,rstr$,esdel$) ! end of section         
	! status section                                                       
	Call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)                 
	Call AddToStr(e$,rstr$,WebStr$)                                        
	Call SetOutPut(e$,rstr$)                      
 else
   include "src/callsuberr.inc"
   
 end try
End sub !
!-------------------------------------------------------------------

Sub CalcPOTotals() 
   ! purchase order header and purchase order lines should already be read in poh & pol                                              	  

try
	if pol.currqtyrcvd<>0 ! we have a received amount
		let cnvta=pol.currqtyrcvd
		if source=381 let cnvta=pol.currqtyrcvd+pol.freeqtyrcvd
		let amount=0
		if cnvta<>0
			CNVTU[0] = 0;CNVTU[1] = pr.UMPurchDefault;CNVTU[2] = 1         
			Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)
			totrcvdqty=totrcvdqty+amount
		endif                          
		lineqty = pol.currqtyrcvd-pol.freeqtyrcvd 
		if source=381 let lineqty = pol.currqtyrcvd
		lineum = pol.CostUM                                                 
		linecost = pol.netcost                                              
		lineextamt = 0                                                      
		LbsUnit = pol.LbsUnit                                               
		LbsFact = pol.LbsFactor  
		currfact= pol.currfact
		if lineqty<>0 and linecost<>0 
			Call CalcExtAmt(lineqty,lineum,linecost,lineextamt,LbsUnit,LbsFact,currfact) 
			totrcvdamt = totrcvdamt+ lineextamt
		endif
		lineqty = pol.currqtyrcvd
		if source=381 let lineqty=pol.currqtyrcvd+pol.freeqtyrcvd
		tmp3 = calcextwgt(lineqty,pol.LbsUnit,pol.LbsFactor) 
		totrcvdwgt=totrcvdwgt+tmp3
		tmp3 = calcextcube(lineqty,pol.cbfunit,pol.cbffactor)
		totrcvdcube=totrcvdcube+tmp3
	endif ! receiving qty
	! order totals ! 
	lineum = pol.CostUM                                                 
	linecost = pol.netcost                                              
	lineextamt = 0                                                      
	LbsUnit = pol.LbsUnit                                               
	LbsFact = pol.LbsFactor
	currfact= pol.currfact
	let lineqty=pol.QtyShip ! pol.QtyOrd
	if lineqty<>0 and linecost<>0 
		Call CalcExtAmt(lineqty,lineum,linecost,lineextamt,LbsUnit,LbsFact,currfact) 
		totordamt = totordamt+ lineextamt
	endif
	let lineqty= pol.QtyShip+pol.FreeGoods-Totfreeqtyrcvd  ! pol.QtyOrd+POL.FreeGoods 
	if source=381 let lineqty=pol.currqtyrcvd+pol.freeqtyrcvd
	let amount=0
	let cnvta=lineqty
	if cnvta<>0
		CNVTU[0] = 0;CNVTU[1] = pr.UMPurchDefault;CNVTU[2] = 1         
		Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)
		totordqty=totordqty+amount
	endif
	tmp3 = calcextwgt(lineqty,pol.LbsUnit,pol.LbsFactor) 
	totordwgt=totordwgt+tmp3
	tmp3 = calcextcube(lineqty,pol.cbfunit,pol.cbffactor)
	totordcube=totordcube+tmp3
else
	! this is a remark
end try
end sub ! calcpototals for receiving
! delsordlot
Sub delsordlot()
! delete of debit memo line -- delete the sordlot
Try
	dim keytmp$[60],keysltc$[60],keypltc$[60],keysltc1$[60]
	dim 3%,v1,r17
	if source<>381 exit sub
	if nonstock<>0 exit sub                                                           
	If not(pol.UpdStock) exit sub!
	LET keysltc$=" ",keysltc$ \ LET keysltc$=poh.PurchaseOrder USING "######" \ LET keysltc$[7]=POL.ItemNo USING "###"   
	LET keysltc$[10]=POL.Whse USING "##" \ LET keytmp$=keysltc$                                      
	Do                                                          
		SEARCH #sltc,3,3;keysltc$,V1,E                     
		IF E exit do                                                             
		IF keysltc$[1,11]<>keytmp$[1,11] exit do  ! "order/line/whse changed              
		IF keysltc$[30,32]="KIT" GOTO getnxtslt: !  "kits deleted separately                     
		IF keysltc$[40,40]<>"4" GOTO getnxtslt: ! NOT A DEBIT MEMO                              
		LET keytmp$=keysltc$ \ LET R17=V1
		read record #sltc,v1,0;ordl.
		!MAT  READ #sltc,V1;S0$; \ MAT  READ #sltc,V1,60;S5;                                 
		!MAT  READ #sltc,V1,106;LOC$; \ MAT  READ #sltc,V1,36;S1;                            
		if ordl.OrdType<>4 GOTO getnxtslt:                                                        
		LET keypltc$=" ",keypltc$ \ LET keypltc$[1,2]=POL.WHSE USING "##" !rel qty in prodlot             
		LET keypltc$[3,8]=ordl.LOC$
		let keypltc$[9,20]=ordl.ProdCode$
		let keypltc$[21,32]=ordl.LotNum$
		!LET keypltc$[9,32]=S0$[1,24]                                
		SEARCH #pltc,2,3;keypltc$,V1,E ! \ IF E>1 GOSUB Err_Search:                              
		IF not(e)                                                              
			read record #pltc,v1,0;prodl.
			!MAT  READ #pltc,V1,82;P4                                                          
			LET prodl.QtyAlloc=prodl.QtyAlloc-ordl.QtyAlloc \ IF prodl.QtyAlloc<0 LET prodl.QtyAlloc=0 ! "qty allocated                 
			LET prodl.QtyBO=prodl.QtyBO-ordl.QtyOnBO  \ IF prodl.QtyBO<0 LET prodl.QtyBO=0 ! "qty b'ord                     
			!MAT  WRITE #pltc,V1,82;P4;
			write record #pltc,v1,0;prodl.;
		endif
		LET keysltc1$=" ",keysltc1$ 
		LET keysltc1$[1,12]=ordl.LotNum$ ! S0$[13,24]
		LET keysltc1$[23,39]=keytmp$[1,17]   
		LET keysltc1$[40,51]=ordl.ProdCode$ ! S0$[1,12] 
		LET keysltc1$[52,52]="4" \ LET V1=R17 \ LET keysltc$=keytmp$        
		SEARCH #sltc,5,3;keysltc$,V1,E !\ IF E GOSUB Err_Search: !delete ordlot                 
		SEARCH #sltc,5,2;keysltc1$,V1,E !\ IF E GOSUB Err_Search:                                
		LET keysltc1$=" ",keysltc1$                                                                 
		LET keysltc1$[1,12]=ordl.ProdCode$
		keysltc1$[13,29]=keytmp$[1,17]
		keysltc1$[30,41]=ordl.LotNum$ !S0$[13,24]              
		LET keysltc1$[52,52]="4"                                                              
		SEARCH #sltc,5,1;keysltc1$,V1,E                                                         
		! IF E GOSUB Err_Search:                                                          
		LET V1=R17                                                                      
		LET E=3 \ SEARCH #sltc,1,0;keysltc1$,V1,E !\ IF E GOSUB Err_Search:                      
		LET keysltc$=keytmp$
		getnxtslt: ! get next sordlot for the line
	Loop  
else
	! error log
end try
end sub ! delsordlot
!---------------------------------------------------------------------
Sub delsernum()
! delete of debit memo line -- delete the serial number
Try
	dim key_posn1$[60],key_posn2$[60],key_sn$[60],3%,rec_posn,rec_sn,rec_tmp
	dim sn1$[54],2%,sn0[1],1%,sn1[2]
	dim 3%
	if source<>381 exit sub
	if nonstock<>0 exit sub                                                           
	If not(pol.UpdStock) exit sub!
	if pr.SerNoTrack$<>"Y" exit sub 
	Try
		IF CH_POSN<>0 close #ch_posn
		IF CH_SN<>0 close #ch_sn
	else
	end try
	ch_posn = OpenFile(2944,intCo) \ If ch_posn = -1 Error 42 !control ! for debit memos -- this is the sales order file using
	ch_sn = OpenFile(416,intCo) \ If ch_sn = -1 Error 42 !control
	let key_posn1$=" ",key_posn1$
	let key_posn1$[1,6]=poh.PurchaseOrder using "######"
	let key_posn1$[7,9]=pol.itemno using "###"
	do
		search #ch_posn,3,1;key_posn1$,rec_posn,e
		if e<>0 exit do
		let tmp3=key_posn1$[1,6]
		if tmp3<>poh.PurchaseOrder exit do
		let tmp3=key_posn1$[7,9]
		if tmp3<>pol.itemno exit do
		mat read #ch_posn,rec_posn,0;sn1$;
		mat read #ch_posn,rec_posn,54;sn0;
		let key_sn$=" ",key_sn$
		let key_sn$[1,30]=SN1$[25,54]
		srchsn: ! 
		search #ch_sn,3,1;key_sn$,rec_sn,e
		if e<>0 goto endsrchsn:
		if key_sn$[1,30]<>sn1$[25,54] goto endsrchsn:
		mat read #ch_sn,rec_sn,290;sn1;
		if sn1[2]=3
			let sn1[2]=0
			mat write #ch_sn,rec_sn,290;sn1;
		endif
		endsrchsn:! 
		let key_posn2$=" ",key_posn2$
		let key_posn2$[1,30]=SN1$[25,54]
		let key_posn2$[31,36]=pol.ProdDescRec using "######"
		search #ch_posn,5,2;key_posn2$,rec_tmp,e
		! if e
		search #ch_posn,5,1;key_posn1$,rec_tmp,e
		if not(e)
			let e=3\search #ch_posn,1,0;key_posn1$,rec_posn,e
			! if e 
		endif
	loop
	Try
		close #ch_posn
		close #ch_sn
		let ch_posn=0
		let ch_sn=0
	else
	end try
else
	! error log
end try
end sub ! delsernum




!------------------------------------------------------------------------------------
Sub chksordlot()
! check of debit memo line -- see if ANY lot or loc entered
Try
	dim keytmp$[60],keysltc$[60]
	dim 3%,v1,r17
	lotentd=0;locentd=0
	if source<>381 exit sub
	if nonstock<>0 exit sub                                                           
	If not(pol.UpdStock) exit sub!
	LET keysltc$=" ",keysltc$
	LET keysltc$=poh.PurchaseOrder USING "######"
	LET keysltc$[7]=POL.ItemNo USING "###"   
	LET keysltc$[10]=POL.Whse USING "##" \ LET keytmp$=keysltc$                                      
	Do                                                          
		SEARCH #sltc,3,3;keysltc$,V1,E                     
		IF E exit do                                                             
		IF keysltc$[1,11]<>keytmp$[1,11] exit do  ! "order/line/whse changed              
		IF keysltc$[30,32]="KIT" GOTO chknxtslt: !  "kits deleted separately                     
		IF keysltc$[40,40]<>"4" GOTO chknxtslt: ! NOT A DEBIT MEMO                              
		LET keytmp$=keysltc$ \ LET R17=V1
		read record #sltc,v1,0;ordl.;
		!MAT  READ #sltc,V1;S0$; \ MAT  READ #sltc,V1,60;S5;                                 
		!MAT  READ #sltc,V1,106;LOC$; \ MAT  READ #sltc,V1,36;S1;                            
		if ordl.OrdType<>4 GOTO chknxtslt: ! not an order
		if ordl.LotNum$[1,5]<>"STOCK" let LotEntd=1
		if ordl.Loc$[1,5]<>"STOCK" and ordl.Loc$[1,4]<>"NONE" let locentd=1
	chknxtslt: ! get next sordlot for the line
	Loop  
else
	! error log
end try
end sub ! chksordlot
!--------------------------------------------------------------------
Sub updatelog(debug)                                        
    If not(debug) Exit Sub                                    
	System "echo ''" + msc$(0) + " UID "+RTrim$(Userid$)+" " + dmsg$ + "'' >> " + dblog$
End Sub 
! 
!--------------------------------------------------------------------
Sub POLTAG()
! using poltag for zlines - use action1$ for function (GET,DELETE,SAVE)

  Try
	Dim RTKey$[60],UDA$[70],mode$[2]
	Dim RolKey$[60]
	Dim 3%,RTR,refno
	Read #ctlc,68,112;uda$;
	
		Dim RTG. as poltag
		RTC=OpenFile(9936,IntCo)
	
	if RTC=-1
		returnstatus=0
		message$="File 3/PORDPOLTAG not found"
		goto RLTDone
	Endif
	
	Call DXGet("POID",tmp$)
	  if tmp$="" 
		let message$="PO # MISSING"
		Let ReturnStatus=0
		Goto RLTDone:
	  Endif
	  OrderNo=tmp$
	  If OrderNo>0 and OrderNo<=999999 and Not(Fra(OrderNo))
		PONO=ORDERNO
		OHR=GetPOHRec(e$,ch_poh,PONo,poh.)
	  Else
		OHR=-1
	  Endif
	  If OHR<=0 ! no order found
		Let message$="PO # NOT FOUND"
		Let ReturnStatus=0
		Goto RLTDone:
	  Endif
	
	Call dxget("LN",tmp$) !        
	LineNo = tmp$ ! line # 
	If LineNo <= 0 Or LineNo > 999 Or Fra(lineno)  
		ReturnStatus = 0                                   
		Message$ = "INVALID PO LINE NUMBER!"  
		goto RLTDone: ! out 
	End If   
	rolkey$ = " ",rolkey$  
	
	rolkey$[1,6] = orderno Using "######"         
	rolkey$[7,9] = LineNo Using "###"       
	rolkey$[10] = "" ! cut to length (NO space @ 10) 
	OLR = filegetpoline(e$,ch_pol,"=",1,rolkey$,pol.)
	
	if olr<=0
		returnstatus=0
		Message$="PO Line Not Found"
		goto RLTDone: ! out 
	endif
	X2 = pol.flags ! ! REM UNPACK pol.Flags TO FLAGS[x] 
	For K = 0 To 11                                     
		 flags[K] = Sgn(Fra(X2 / 2)) \ X2 = Int(X2 / 2)    
	Next K                                              
	NonStk = flags[0]                                   
	Closedshort = flags[1]                                   
	ZLine = flags[2] 
	Closed=0
	if poh.status=7 let closed=99
	if pol.status=3 let closed=99
	if poh.status=14 let closed=99
	if pol.status=14 let closed=99
	! okay order & line exist - now action1
	Select Case Action1$
		case "GET" ! get data for web						doc=POL-GetLineTag.doc
			RTKey$=ROLKey$ ! same key as line				
			RTR=filegetpoltag(e$,RTC,"=",1,RTKey$,rtg.) ! hist & ord same layout
			If RTR<=0 ! not found
				clear rtg.
				! no defaults
			Endif
			! send uda names
			Clear List$[]
			List$[0]=bsdel$,"FLDNAMES",fdel$
			List$[1]="FLD1",fdel$,"FLD2",fdel$,"FLD3",fdel$,"FLD4",fdel$,"FLD5",fdel$
			webstr$=RTrim$(UDA$[1,14]),fdel$,RTrim$(UDA$[15,28]),fdel$
			webstr$=webstr$,RTrim$(UDA$[29,42]),fdel$,RTrim$(UDA$[43,56]),fdel$
			webstr$=webstr$,RTrim$(UDA$[57,70]),fdel$
			List$[2]=webstr$
			List$[3]=esdel$
			call addtostr(e$,rstr$,List$[])
			Clear List$[]
			List$[0]=bsdel$,"LINENOTES",fdel$
			tmp$="POID" 
			Webstr$=tmp$,fdel$,"LINE",fdel$,"FLD1",FDEL$
			webstr$=webstr$,"FLD2",fdel$,"FLD3",fdel$
			webstr$=webstr$,"FLD4",fdel$,"FLD5",fdel$
			for x=6 to 30 ! now 30 lines!
				tmp$="FLD"+Str$(X)
				webstr$=webstr$,tmp$,fdel$
			Next X
			List$[1]=webstr$
			x3=orderno 
			webstr$=Str$(X3),fdel$,Str$(LineNo),fdel$
			webstr$=webstr$,RTrim$(rtg.JobNum$),fdel$,RTrim$(rtg.PONum$),fdel$
			webstr$=webstr$,RTrim$(rtg.PressNum$),fdel$,Rtrim$(rtg.MSGLine1$),fdel$
			webstr$=webstr$,RTrim$(rtg.MSGLine2$),fdel$
			for x=1 to 25 ! send the 25 add'l lines
				x1=(x-1)*30+1
				tmp$=RTrim$(rtg.msgs$[x1,x1+29])
				webstr$=webstr$,tmp$,fdel$
			Next X
			List$[2]=webstr$
			List$[3]=esdel$
			call addtostr(e$,rstr$,List$[])
		case "SUBMIT" ! write to file						doc=POL-SubmitLineTag.doc
			If Closed or ClosedShort ! done
				returnstatus=0
				message$="Can not submit - Line is closed"
				goto RLTDone
			Endif
			RTKey$=ROLKey$ ! same key as line
			RTR=filegetpoltag(e$,RTC,"=",1,RTKey$,rtg.)
			If RTR<=0 
				clear rtg.
				RTR=0
			Else ! existing - check blank for key (NOT NULL!!!)
				if rtg.Blankforkey$="" ! it is - from UB - fill it NOW
					rtg.Blankforkey$=" "
					write record #RTC,RTR,0;rtg.;
				Endif ! not null - ok
			Endif
			rtg.Status=Pol.Status
			rtg.OrdNum=Orderno
			rtg.LineNum=LineNo
			call dxget("FLD1",tmp$)
			strgok=chkbadchars(e$,tmp$)
			if not(strgok)
				returnstatus=0
				Message$="Invalid Characters in Job Number"
				goto RLTDone
			Endif
			rtg.JobNum$=tmp$+Blank$
			call dxget("FLD2",tmp$)
			strgok=chkbadchars(e$,tmp$)
			if not(strgok)
				returnstatus=0
				Message$="Invalid Characters in PO Number"
				goto RLTDone
			Endif
			rtg.PONum$=tmp$+Blank$
			call dxget("FLD3",tmp$)
			strgok=chkbadchars(e$,tmp$)
			if not(strgok)
				returnstatus=0
				Message$="Invalid Characters in Press Number"
				goto RLTDone
			Endif
			rtg.PressNum$=tmp$+Blank$
			call dxget("FLD4",tmp$)
			strgok=chkbadchars(e$,tmp$)
			if not(strgok)
				returnstatus=0
				Message$="Invalid Characters in Message Line 1"
				goto RLTDone
			Endif
			rtg.MSGLine1$=tmp$+Blank$
			call dxget("FLD5",tmp$)
			strgok=chkbadchars(e$,tmp$)
			if not(strgok)
				returnstatus=0
				Message$="Invalid Characters in Message Line 2"
				goto RLTDone
			Endif
			rtg.MSGLine2$=tmp$+Blank$
			rtg.MSGS$=" ",rtg.MSGS$
			For X=6 to 30 ! 30 total flds
				call dxget("FLD"+str$(x),tmp$)
				tmp$=Rtrim$(tmp$)
				if tmp$<>"" ! sent something
					strgok=chkbadchars(e$,tmp$)
					if not(strgok)
						returnstatus=0
						Message$="Invalid Characters in Message Line"
						goto RLTDone
					Endif
					x1=x-5 ! so is 1 to 25
					x2=(x1-1)*30+1
					rtg.msgs$[x2,x2+29]=tmp$+Blank$
				Endif
			Next X
			rtg.Blankforkey$=" "
			mode$="c" \ if rtr<=0 let mode$="a"
			rec_tmp=fileupdatepoltag(e$,RTC,mode$,RTR,rtg.)
			if rec_tmp<0 ! problem
				returnstatus=0
				message$="Search Error "+Str$(X)+" updating poltag file"
			Endif
		case "DELETE" ! delete								doc=POL-DeleteLineTag.doc
			If Closed or ClosedShort ! done
				returnstatus=0
				message$="Can not delete - Line is closed"
				goto RLTDone
			Endif
			RTKey$=ROLKey$ ! same key as line
			RTR=filegetpoltag(e$,RTC,"=",1,RTKey$,rtg.)
			If RTR<=0 goto RLTDone ! no key - no delete
			if rtg.Blankforkey$="" ! it is null - from UB - fill it NOW
				rtg.Blankforkey$=" " ! otherwise "not found"(SE)
				write record #RTC,RTR,0;rtg.;
			Endif ! not null - ok
			mode$="d"
			rec_tmp=fileupdatepoltag(e$,RTC,mode$,RTR,rtg.)
			if rec_tmp<0 ! problem
				returnstatus=0
				message$="Search Error "+Str$(X)+" deleting poltag file"
			Endif
	End select ! action1$
	RLTDone: ! finshed
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
  else
    include "src/callsuberr.inc"
 end try
end sub ! POLTAG
! 
!--------------------------------------------------------------------
Function chktagfle$()
! see if any data for all msglines in tagfile
! as messages are condensed (ie: enter msg 20, will move to lower number
!   so all messages start at 1, 2, etc.)
  Try
	Dim RTKey$[60],tflg$[1]
	Dim 3%,RTR,refno
	Dim RTG. as poltag
	tflg$="N"
	RTC=OpenFile(-9936,IntCo)
	if rtc=-1 goto ctfdone
	RTKey$=" ",rtkey$ ! same key as line
	rtkey$[1,6]=pol.PONum using "######"
	rtkey$[7,9]=pol.ItemNo using "###"
	RTR=filegetpoltag(e$,RTC,"=",1,RTKey$,rtg.) ! hist & ord same layout
	clear e$
	If RTR<=0 ! not found
		tflg$="N"
	Else
		if rtrim$(rtg.MSGLine1$)<>"" let tflg$="Y"
		if rtrim$(rtg.MSGLine2$)<>"" let tflg$="Y"
		if rtrim$(rtg.PONum$)<>"" let tflg$="Y"
		if rtrim$(rtg.JobNum$)<>"" let tflg$="Y"
		if rtrim$(rtg.PressNum$)<>"" let tflg$="Y"
		for x=1 to 25
			x1=(x-1)*30
			let tmp$=rtg.MSGS$[x1+1,x1+30]
			if rtrim$(tmp$)<>"" let tflg$="Y"
		Next X
	Endif
	e$=""
	try close #RTC Else Rem
	Ctfdone: ! finished
  else
    include "src/callsuberr.inc"
  end try
end Function tflg$ ! chktagfle$
! 
!--------------------------------------------------------------------
sub ChkVendMin()
! lines are being sent back to PM
! changed to 1 at a time (as user leaves line - save it!)
 Try
	dim 1%,minflag[9],minmsg$[9,50]
	Dim KOL$[60],KPW$[60],KCM$[50],KLP$[60],keypoh$[30]
	Dim ZOL$[60],xdate$[10],KOHC$[20]
	ch_vtag=OpenFile(1120,intCo) \ If Ch_vtag = -1 Error 42 ! vemdtag
	ReturnStatus=1
	Message$="OK"
	Call DXGet("POID",tmp$)
	If tmp$="" goto endchkvendmin:
	PONo=tmp$
	If PONo<1 or PONo>999999 or Fra(PONo)
		ReturnStatus=0
		Message$="PURCHASE ORDER "+STR$(PONO)+" NUMBER INVALID"
		Goto endchkvendmin:
	Endif
	rec_poh = getpohrec(e$,ch_poh,POno,poh.)
	If rec_poh<=0 ! not found
		!! may be here by mistake for a debit memo, check for that also
		!! if source was set from other end in PO inquiry this may not be needed
			For X=11 to 14
				Let KOHC$=" ",KOHC$
				KOHC$[1,2]=X Using "##"
				KOHC$[3]=PONo Using "######"
				rec_poh=filegetpohead(e$,SCHN[0],"=",1,kohc$,poh.)
				If rec_poh>0 ! found it
				  goto endchkvendmin:
				Endif
				if x=14 let x=96
			Next X
		!! end if debit memo check
	endif 
	If rec_poh<=0 ! not found
		ReturnStatus=0
		Message$="PURCHASE ORDER "+STR$(PONO)+" WAS NOT FOUND"
		goto endchkvendmin:               
	Endif
	IF poh.status>1 and poh.status<90
	     ReturnStatus=99
		Message$="Purchase Order "+STR$(PONO)+" Is No Longer in Edit Status"
		goto endchkvendmin:
	endif
	
	if poh.status>96 goto endchkvendmin:
	if poh.Type=1 goto endchkvendmin: ! direct
	if poh.type=5 goto endchkvendmin: ! import directs
	If poh.lastrtsdate<>0 goto  endchkvendmin:
	if poh.totporcvd<>0 goto endchkvendmin:
	!call dxget ("vendid",tmp$)
	!poh.VendorCode=tmp$
	!Call GetVend()
	KVEND$=" ",KVEND$
	KVEND$=poh.VendorCode using "######"
	mode$="=" ! search mode 2
	dir=1
	clear vtag.
	Rec_vtag=filegetvendtag(e$,ch_vtag,mode$,dir,KVEND$,vtag.)
	if rec_vtag<0
		let returnstatus=0
		let message$="Vendor "+str$(poh.vendorcode)+" Not In Tag File . "
		goto endchkvendmin:
	endif	
	if p61$[63,63]="Y" ! check vendor min in warehouse file
		 ch_vendwh = OpenFile(-9961,intCo) \ If CH_vendwh = -1 Error 42 ! vendor whse
		 KVEND$=" ",KVEND$
		KVEND$[1,6]=poh.VendorCode using "######"
		KVEND$[7,8]=poh.Warehouse using "##"
		search #ch_vendwh,2,1;kvend$,rec_vendwh,e
		if not(e)
			read record #ch_vendwh,rec_vendwh;vendwh.;
			MAT  READ #ch_vendwh,rec_vendwh,442;VW3;
			for ctr=0 to 7
				if vw3[ctr]<>0 goto updvwmin:
			next ctr
			goto endvwmin: ! none set-up for vendor warehouse
			updvwmin: ! 
			let vtag.MinOrder=vendwh.MinOrder  
			let vtag.MinWtOrder=vendwh.MinWghtOrder
			let vtag.MinCubeOrd=vendwh.MinCubeOrder
			let vtag.MinQtyOrd=vendwh.MinQtyOrder
			let vtag.FrtPaid=vendwh.frgtpaid
			let vtag.FrtPaidWt=vendwh.frgtpaidwght
			let vtag.FrtPaidCubes=vendwh.frgtpaidCube
			let vtag.FrtPaidQty=vendwh.frgtpaidQty
			endvwmin: ! 
		endif
		
	endif
	If not(vtag.MinOrder) and not(vtag.MinWtOrder) and not(vtag.MinCubeOrd) and not(vtag.MinQtyOrd)
		goto endchkvendmin:! no minimums
	endif
	KOL$=" ",KOL$
	KOL$=PONo Using "######"
	! what if start with or only zlines on Purchase order??
	Do
		rec_pol=filegetpoline(e$,ch_pol,">",1,kol$,pol.)
		If rec_pol<0 exit do
		X2=kol$[1,6] \ if x2<>pono exit do
		! flag for non-stock item in logic
		LET X2=pol.flags ! ! REM UNPACK pol.Flags TO FLAGS[x] 
	        FOR K=0 TO 11                     
		   LET FLAGS[K]=SGN(FRA(X2/2)) \ LET X2=INT(X2/2) 
		NEXT K
		NonStk=flags[0]
		CLOSED=0
		if poh.status=7 let closed = 99
		if pol.status=3 let closed = 99
		Zline=flags[2] 
		if zline<>0 goto endminloop:
		if closed<>0 goto endminloop:
		! get/read appropriate records (prod,prodwhse,comm,lastprice
		If Not(NonStk) ! it's a prod
			PRR=pol.ProdDescRec
			Read record #PRC,PRR,0;PR.;
			KPW$=" ",KPW$
			Kpw$=pol.prodcode$+pol.whse Using "##"
			PWR=filegetprodwhse(e$,PWC,"=",1,KPW$,pw.)
			if PWR<0 ! not found
				Clear pw.
				If PWR=-1 ! not found - add?
					E$=""
					Whbld[0]=PWC;Whbld[1]=pol.whse;WhBld[2]=pr.PrimVend
					Call mxwhcreate(e$,IntCo,pol.prodcode$,WHBLD[])
					PWR=Whbld[2]
					Read record #PWC,PWR,0;PW.;
					if pwr>0 let e$=""
				Endif
			Endif
		Else
			Clear pr.
			Clear pw.
		Endif
		! always set up pr. w/line factors
		LineNo=pol.ItemNo
		if (NonStk)
			Read Record #ch_nstk,pol.ProdDescRec; nstk.;
		endif
		Call SetPRtoPol() !!! 
		let pol.currqtyrcvd=0
		pol.QtyShip = pol.QtyOrd 
		call calcpototals()
		let poh.totamt=totordamt
		let poh.totweight=totordwgt
		let poh.totcubes=totordcube
		let poh.totpieces=totordqty
		endminloop:! end the loop
	Loop ! done with order
	! Check Vendor Total
	if vtag.MinOrder>0
		if poh.TotAmt<vtag.MinOrder
			let minflag[0]=99 
            IF COST_LEV[2]<>0
				let minflag[1]=99
				Let tmp$="MINIMUM DOLLAR    "
				let tmp$=tmp$+vtag.MinOrder using "$#######.## "
				let tmp$=tmp$+"ORDER "
				let tmp$=tmp$+poh.totamt using "$#######.## "
				LET minmsg$[1]=tmp$ 
			endif
		endif
	endif 
	if vtag.FrtPaid > 0 ! 
		if poh.TotAmt<vtag.FrtPaid
			let minflag[0]=99 
            IF COST_LEV[2]<>0
				let minflag[5]=99
				Let tmp$="MINIMUM DOLLAR    "
				let tmp$="FREIGHT MIN DOLLAR"
				let tmp$=tmp$+vtag.FrtPaid using "$#######.## "
				let tmp$=tmp$+"ORDER "
				let tmp$=tmp$+poh.totamt using "$#######.## "
				LET minmsg$[5]=tmp$ 
			endif
		endif
	endif 
    ! check vend min weight
	if vtag.MinWtOrder>0
		if poh.TotWeight<vtag.MinWtOrder 
			LET minflag[0]=99
			let minflag[2]=99
			Let tmp$="MINIMUM WEIGHT/LBS"
			let tmp$=tmp$+vtag.MinWTOrder using " #######.## "
			let tmp$=tmp$+"ORDER "
			let tmp$=tmp$+poh.TotWeight using " #######.## "
			let minmsg$[2]=tmp$
        	endif
	endif
	if vtag.FRTPAIDWT>0
		if poh.TotWeight<vtag.FRTPAIDWT
			LET minflag[0]=99
			let minflag[6]=99
			Let tmp$="MINIMUM WEIGHT/LBS"
			let tmp$="FREIGHT MIN WEIGHT"
			let tmp$=tmp$+vtag.fRTPAIDWT using " #######.## "
			let tmp$=tmp$+"ORDER "
			let tmp$=tmp$+poh.TotWeight using " #######.## "
			let minmsg$[6]=tmp$
        	endif
	endif
	! check vend min cubes
	if vtag.MinCubeOrd>0
		if poh.TotCubes<vtag.MinCubeOrd 
			LET minflag[0]=99
			let minflag[3]=99
			Let tmp$="MINIMUM CUBES     "
			let tmp$=tmp$+vtag.MinCubeOrd using " #######.## "
			let tmp$=tmp$+"ORDER "
			let tmp$=tmp$+poh.TotCubes using " #######.## "
			let minmsg$[3]=tmp$
        	endif
	endif
	! check vend min cubes
	if vtag.FRTPAIDCUBES>0
		if poh.TotCubes<vtag.FRTPAIDCUBES
			LET minflag[0]=99
			let minflag[7]=99
			LET TMP$="FREIGHT MIN CUBES "
			let tmp$=tmp$+vtag.FRTPAIDCUBES using " #######.## "
			let tmp$=tmp$+"ORDER "
			let tmp$=tmp$+poh.TotCubes using " #######.## "
			let minmsg$[7]=tmp$
        	endif
	endif
	! check vend min 
	! check vend min pieces/qty
	if vtag.MinQtyOrd>0
		if poh.TotPieces<vtag.MinQtyOrd 
			LET minflag[0]=99
			let minflag[4]=99
			Let tmp$="MINIMUM QUANTITY  "
			let tmp$=tmp$+vtag.MinQtyOrd using " #######.## "
			let tmp$=tmp$+"ORDER "
			let tmp$=tmp$+poh.TotPieces using " #######.## "
			let minmsg$[4]=tmp$
        endif
	endif
	if vtag.FrtPaidQty>0
		if poh.TotPieces<vtag.FrtPaidQty
			LET minflag[0]=99
			let minflag[8]=99
			Let tmp$="MINIMUM QUANTITY  "
			let tmp$="FREIGHT MIN QTY   "
			let tmp$=tmp$+vtag.FrtPaidQty using " #######.## "
			let tmp$=tmp$+"ORDER "
			let tmp$=tmp$+poh.TotPieces using " #######.## "
			let minmsg$[8]=tmp$
        endif
	endif
	! last check
	if minflag[0]<>0
		let minmsg$[0]="ORDER IS LESS THAN VENDORS MINIMUM ORDER!!"
		let returnstatus=2
		let message$="ORDER IS LESS THAN VENDORS MINIMUM ORDER!!"

	endif  
        endchkvendmin:!
	clear list$[]
	List$[0]=bsdel$,"Vendor Order Minimums",fdel$
	webstr$=""
	WebStr$="Message$",fdel$
	List$[1]=WebStr$
	let row=2
	if returnstatus=2
		for ctr=1 to 8
			if minflag[ctr]
				let list$[row]=minmsg$[ctr],fdel$
				let row=row+1
             endif
		next ctr
	endif
	let list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string                          
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
 else
    include "src/callsuberr.inc"
 end try
end sub ! chkvendmin

!--------------------------------------------------------------------------------
Sub verifystat()
! verify status on save data 
! header record needs to read first
  Try

	Call dxget("SOURCE",tmp$)
	let tmp3=tmp$
	if tmp3=370 goto endverifystat: ! inquiry
	if tmp3=361 or tmp3=369 ! po edit or auto po create
		if poh.status<>94 and poh.status<>95 ! missing 95?
			let returnstatus=99
			let message$="Purchase Order is not longer in an edit status. Data is not saved. "
		endif
		goto endverifystat:
	endif
	if tmp3=371 ! receipts to stock
		if poh.status<>96
			let returnstatus=99
			let message$="Purchase Order is no longer in receipts to stock edit status. Data is not saved. "
		endif
		goto endverifystat:
	endif
	If tmp3=381 
		if poh.status<>97
			let returnstatus=99
			let message$="Debit Memo is no longer in debit memo edit status. Data is not saved. "
		endif
		goto endverifystat:
	endif
	if poh.status<95 or poh.status>97 
		let returnstatus=99
		let message$="Purchase Order is no longer in an edit status. Data is not saved. "
	endif
	endverifystat: ! end the status check
		

	! status section
	e$=""
	!
	!  call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	!  call AddToStr(e$,rstr$,WebStr$)
	!  call SetOutPut(e$,rstr$)
  else
    include "src/callsuberr.inc"
 end try
end sub ! verifystat
! delete spolot
Sub delspolot() !
! line deleted  - delete spolot
Try
	dim keytmp$[60],spolotkey$[50]
	dim 3%,rec_spolot
	if nonstock<>0 exit sub                                                           
	If not(pol.UpdStock) exit sub!
	let spolotkey$=" ",spolotkey$
	let spolotkey$[1,6]=PoNo Using "######"
	let spolotkey$[7,9]=LineNo Using "###"                                     
	Do                                                          
		SEARCH #ch_polot,3,1;spolotkey$,rec_spolot,E                     
		IF E<>0 exit do                                                             
		let tmp3=spolotkey$[1,6]
		if tmp3<>poNo exit do
		let tmp3=spolotkey$[7,9]
		if tmp3<>LineNo exit do
		read record #ch_polot,rec_spolot;polot.; ! unlock for delete
		mode$="d"
		rec_tmp=fileupdatespolot(e$,ch_polot,mode$,rec_spolot,polot.)
		if rec_tmp<0 ! problem
			returnstatus=0
			message$="Search Error "+Str$(X)+" deleting spolot file"
		Endif
	Loop  
else
	! error log
end try
end sub ! delpolot

Sub addspolot()
! line added - add spolot
! lot control should be N and dfltrcvloc$=Y
Try
	dim keytmp$[60],spolotkey$[50],dfltrcvloc$[6]
	Dim ploc$[18],tempk1$[60]
	dim 3%,rec_spolot
	if nonstock<>0 exit sub                                                           
	If not(pol.UpdStock) exit sub!
	if not (rasl) exit sub
	if source<>371 exit sub
	if not(npol.currqtyrcvd) exit sub
	mat read #ctlc,69,52;dfltrcvloc$;
	dfltrcvloc$=dfltrcvloc$+Blank$ ! space fill it
	if dfltrcvloc$[1,6]=Blank$[1,6] let dfltrcvloc$="STOCK "
	If (DfltRcvLoc$[1,4]="DOOR" OR DfltRcvLoc$[1,3]="BAY")
	  If poh.WhseBay ! PO1[7] ! "only append # if there
		If DfltRcvLoc$[1,4]="DOOR" Let DfltRcvLoc$[5]=Str$(poh.WhseBay)+"  "
		If DfltRcvLoc$[1,3]="BAY" Let DfltRcvLoc$[4]=Str$(poh.WhseBay)+"   "
	  Endif
	Endif
	clear polot.       
	If custom_customer$="ACTION" ! get primary location cct171651
		let tempk1$=" ",tempk1$                               
		LET PLOC$=" ",PLOC$
		LET tempk1$[1,12]=npol.ProdCode$ ! l1$[81,92]  
		let tempk1$[13,14]=npol.whse using "##"
		SEARCH #CH_PRLOC,3,1;tempk1$,v1,E    
		if e goto gplctndone
		if tempk1$[1,12]<>npol.ProdCode$ goto gplctndone
		Let X2[9]=tempk1$[13,14] \ if x2[9] <> npol.whse goto gplctndone
		MAT  READ #CH_PRLOC,V1,0;PLOC$;  
	 gplctndone: ! done
	Endif
	polot.LotNum$=" ",polot.LotNum$
	polot.LotNum$[1,7]=npol.whse USING "STOCK&&"             
	polot.Stock$=" ",polot.Stock$	! POL1$[13,22] 
	if custom_customer$="ACTION"
		if ploc$[13,14]<>"  " if ploc$[13,13]<>""    
			let polot.Loc$=ploc$[13,18]+Blank$
		else 
			polot.Loc$=rtrim$(DFLTRCVLOC$)+Blank$	! POL1$[23,28] 
		Endif
	Else ! not custom
		polot.Loc$=rtrim$(DFLTRCVLOC$)+Blank$	! POL1$[23,28]
	Endif
	polot.ProdWO$=" ",polot.ProdWO$	! POL1$[29,34]  IF PWO   
	!polot.sOpen$[4]				! POL1$[35,38]  OPEN     
	polot.PoNum=pono				! POL1[0]                
	polot.LineNum=LineNo			! POL1[1]                
	polot.Whse=npol.whse            ! POL1[2]                
	polot.QtyRcvd=npol.currqtyrcvd  ! POL1[3]                
	polot.UM=npol.QtyUM				! POL1[4]                
	!polot.sOpen1$[32] 
	!KEY =     123456789012                                                                                                             
	let spolotkey$=" ",spolotkey$
	let spolotkey$[1,6]=PoNo Using "######"
	let spolotkey$[7,9]=LineNo Using "###"
	let spolotkey$[10,21]=polot.lotnum$
	let spolotkey$[22,31]=polot.stock$
	let spolotkey$[32]=polot.loc$
	mode$="=" ! search mode 2
	dir=1
	Rec_spolot=filegetspolot(e$,ch_polot,mode$,dir,spolotkey$,polot.)
	if rec_spolot>=0
		polot.QtyRcvd=npol.currqtyrcvd
		write record #ch_polot,rec_spolot;polot.;
	else
		let e$="" ! error because the line was not there clear var
		mode$="a"
		rec_spolot=fileupdatespolot(e$,ch_polot,mode$,rec_spolot,polot.)
		if rec_spolot<0 ! problem
			returnstatus=0
			message$="Search Error "+Str$(X)+" adding spolot file"
		Endif
	endif
else
	! error log
end try
end sub ! addpolot
! 
!--------------------------------------------------------------------
Function getsordqty()
  ! details - get the Order Qty for a order/line tied to po line
  Try
	Dim KRol$[50],3%,OQty,Rec_rol
	Oqty=0 ! default
	X2=pol.SalesOrd
	OHR=GetOrdRec(e$,OHC,OSC,OTC,X2,roh., ros., rot.)
	clear e$
	if OHR<0 goto GetSOQDone ! no order found
	KRol$=" ",KRol$
	KRol$[1,6]=pol.SalesOrd using "######"
	KRol$[7]=pol.SalesOrdLine using "###"
	Search #OLC,2,1;KRol$,rec_rol,E
	if e goto GETSOQDone
	Read Record #OLC,rec_rol,0;rol.;
	if rol.Status=12 goto GetSOQDone ! credit?
	if rol.PONum<>poh.PurchaseOrder goto GetSOQDone
	if rol.LineType=3 goto GetSOQDone
	if rol.QtyOrd<0 goto GetSOQDone
	cnvtu[0]=0;Cnvtu[1]=pol.qtyum;Cnvtu[2]=1
	cnvta=rol.QtyOrd
	X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	OQty=x3 ! converted to PO Qty UM
	GetSOQDone: ! finished
  else
    include "src/callsuberr.inc"
  end try
end Function Oqty ! getsordqty
! 
!--------------------------------------------------------------------
Sub updateSoQty()
! details - get & update SOQty to match PO Qty(already base
  Try
	Dim KRol$[50]
	dim 1%,chopen[20]
	dim 3%,CHBASE,NetCost,Ordwt,rec_rol,s9[12]
	X2=npol.SalesOrd
	OHR=GetOrdRec(e$,OHC,OSC,OTC,X2,roh., ros., rot.)
	clear e$
	if OHR<0 goto UptSOQDone ! no order found
	if roh.status>5 and roh.status<8 goto UptSOQDone ! no inv prnt/reg
	KRol$=" ",KRol$
	KRol$[1,6]=npol.SalesOrd using "######"
	KRol$[7]=npol.SalesOrdLine using "###"
	Search #OLC,2,1;KRol$,rec_rol,E
	if e goto UptSOQDone
	Read Record #OLC,rec_rol,0;rol.
	if rol.Status=12 goto UptSOQDone ! credit?
	if rol.PONum<>poh.PurchaseOrder goto UptSOQDone
	if rol.LineType=3 goto UptSOQDone
	! back out of prev
	! try the cheap way - back out orig line from totals
	rot.MdseOrdAmt = rot.MdseOrdAmt - rol.ExtOrdAmt
	rot.TotOrdCost = rot.TotOrdCost - rol.ExtLoadOrd
	rot.TotOrdQty=rot.TotOrdQty-rol.QtyOrd
	! ok - change order
	let rol.QtyOrd=npol.QtyOrd
	if (rol.PrevQtyShip+rol.QtyShip)<rol.QtyOrd ! now a difference
		let rol.QtyBO=rol.QtyOrd-(rol.PrevQtyShip+rol.QtyShip) ! diff to BO
	endif
	if rol.QtyBO<0 let rol.QtyBO=0
	! missing from native - re-extend order Line & rot totals!!
	
	If Not(rol.WgtFactor) Let rol.WgtFactor = 1
	ORDWT = (rol.LbsUnit * rol.QtyOrd) / rol.WgtFactor
	If rol.UMCutCost = -3 And rol.QtyOrd Let CHBASE = (rol.CutCost / rol.QtyOrd) Else Let CHBASE = rol.CutCost
	NETCOST = rol.UnitCost + CHBASE
	IF rol.LoadUpchrg
	  IF rol.LoadUpchrg <0
		LET NETCOST=NETCOST+ABS(rol.LoadUpchrg )
	  ELSE
		LET NETCOST=NETCOST+(NETCOST*(rol.LoadUpchrg /100))
	  ENDIF
	ENDIF
	rol.ExtOrdAmt = FNR(rol.QtyOrd * rol.NetPrice)
	rol.ExtLoadOrd = FNR(rol.QtyOrd * NETCOST)
	IF rol.UMPrice=-2 ! lot
	  LET rol.ExtOrdAmt=FNR(Rol.NetPrice)*SGN(rol.QtyOrd)
	Endif
	IF rol.UMCost=-2 ! LOT
	  LET rol.ExtLoadOrd=FNR(NETCOST*SGN(rol.QtyOrd))
	Endif
	if roh.OrdType=8 or roh.OrdType=16 ! cons/trans - no price/cost
		rol.ExtLoadOrd = 0
	Endif
	write record #OLC,rec_rol,0;rol.; ! updated
	! now add in new line totals
	rot.TotOrdQty=rot.TotOrdQty+rol.QtyOrd
	rot.MdseOrdAmt = rot.MdseOrdAmt + rol.ExtOrdAmt
	rot.TotOrdCost =rot.TotOrdCost + rol.ExtLoadOrd
	Write Record #OTC,roh.TotRec,0;rot.;
	! saves on calling ordertotal, etc just for the OrdQty fields
	! do rasl for line
	s9[0]=0;S9[2] = OHR;s9[3]=0;S9[4] = 208;S9[5] = 0;s9[6]=0
	s9[7]=0;s9[8]=0;s9[9]=0;s9[10]=0;s9[11]=0;s9[12]=rec_rol
	CHOPEN[0] = ctlc;CHOPEN[1] =prc;CHOPEN[2] = ohc;CHOPEN[3] = olc;CHOPEN[4] = 0
	CHOPEN[5] = 0;CHOPEN[6] = pltc;CHOPEN[7] = 0;CHOPEN[8] = sltc;CHOPEN[9] = 0
	Call "MXRASL5.DL4",intco,Ctlc,S9[],CHOPEN[]
	UptSOQDone: ! finished
	Unlock #OLC ! just in case
  else
    include "src/callsuberr.inc"
 end try
end sub ! updateSoQty
! =====================================================


!--------------------------------------------------------------------
Sub getroll()
! details - get & update SOQty to match PO Qty(already base
  Try
	Dim Polkey$[60]
	ReturnStatus=1
	Message$="OK" 
	if p61$[104,104]<>"Y"
		let returnstatus=0
		let message$="Roll Inventory is not Available "
		goto endgetroll:
	endif
	Call dxget("POID",tmp$)                           
	POno = tmp$  
	If pono <= 0 Or pono > 999999 Or Fra(pono)  
		ReturnStatus = 0                                   
		Message$ = "INVALID PURCHASE ORDER!"  
		goto endgetroll:
	End If 
	CALL dXGET("VENDID",tmp$)
	Call dxget("LN",tmp$) ! +Str$(X1),tmp$)         
	LineNo = tmp$ ! line # (zero on new lines)
	If LineNo <= 0 Or LineNo > 999 Or Fra(lineno)  
		ReturnStatus = 0                                   
		Message$ = "INVALID PURCHASE ORDER LINE!"  
		goto endgetroll:
	End If   
	Polkey$ = " ",Polkey$                         
	Polkey$[1,6] = POno Using "######"         
	Polkey$[7,9] = LineNo Using "###"       
	Polkey$[10] = "" ! cut to length (space @ 10) 
	rec_pol = filegetpoline(e$,ch_pol,"=",1,polkey$,pol.)
	if rec_pol<=0
		returnstatus=0
		Message$="Purchase Order Line Not Found"
		goto endgetroll:
	endif
	LET X2=pol.flags ! ! REM UNPACK pol.Flags TO FLAGS[x] 
	FOR K=0 TO 11                     
		LET FLAGS[K]=SGN(FRA(X2/2)) \ LET X2=INT(X2/2) 
	NEXT K
	NonStk=flags[0]
	Closedshort=flags[1]
	Zline=flags[2] 
	if nonstk<>0
		returnstatus=0
		Message$="Roll Inventory Not Available for Nonstock Items"
		goto endgetroll:
	endif
	if zline<>0
		returnstatus=0
		Message$="Roll Inventory Not Available for Message Lines"
		goto endgetroll:
	endif
	!if pol.currqtyrcvd=0
	!	returnstatus=0
	!	Message$="No Items have been received "
	!	goto endgetroll:
	!endif
	Prodkey$=" ",prodkey$
	prodkey$=pol.ProdCode$
	PRR=filegetprod(e$,PRC,"=",1,ProdKey$,pr.)
	If PRR<0  
		returnstatus=0
		Message$="Product "+rtrim$(prodkey$)+" Not On File"
		goto endgetroll:
	endif				
	if pr.rollinv$<>"Y"
		returnstatus=0
		Message$="Product "+rtrim$(prodkey$)+" Not A Roll Inventory Item"
		goto endgetroll:
	endif
	! open the roll
	ch_por=findchannel()
	let f$="3/SPOROLL"+STR$(INTCO)
	try
		ropen #ch_por,f$
	else
		let returnstatus=0
		let message$="Roll Inventory is not Available "
		goto endgetroll:
	end try
	endgetroll: ! ! set list header
	Clear List$[]

	List$[0]=bsdel$,"RollList",fdel$
	WebStr$="Roll ID",fdel$,"Weight",fdel$
    List$[1]=WebStr$
	row=2
	let totrollwgt=0
	if returnstatus>0
		let keyroll$=" ",keyroll$
		let keyroll$[1,6]=pono using "######"
		let keyroll$[7,9]=lineno using "###"
		do
			rec_por = filegetporoll(e$,ch_por,">",1,Keyroll$,por.)
			IF rec_por<0 exit do
			let tmp3=keyroll$[1,6]
			if tmp3<>pono exit do
			let tmp3=keyroll$[7,9]
			if tmp3<>lineno exit do
			webstr$=rtrim$(por.rollid$),fdel$
			webstr$=webstr$,str$(por.wgt),fdel$
			let totrollwgt=totrollwgt+por.wgt
			list$[row]=webstr$
			row=row+1
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])			
	     loop
	endif
	list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])
	! section 2
	CLEAR list$[]
	list$[0]=bsdel$,"ProdInfo",fdel$
	webstr$="POID",fdel$
	webstr$=webstr$,"LN",fdel$
	webstr$=webstr$,"PRODID",fdel$
	webstr$=webstr$,"DESC1",fdel$
	webstr$=webstr$,"DESC2",fdel$
	webstr$=webstr$,"RECEIVED",fdel$
	webstr$=webstr$,"ENTERED",fdel$
	list$[1]=webstr$
	let row=2
	if returnstatus>0
		webstr$=str$(Pono),fdel$
		webstr$=webstr$,str$(lineno),fdel$
		webstr$=webstr$,rtrim$(pol.ProdCode$),fdel$
		tmp$=clrtxtc$(e$,pr.Desc1$) ! chk/clr control chars
		webstr$=webstr$,rtrim$(tmp$),fdel$
		tmp$=clrtxtc$(e$,pr.Desc2$) ! chk/clr control chars
		webstr$=webstr$,rtrim$(tmp$),fdel$
		let x3=0
		Cnvtu[0]=0;Cnvtu[1]=pol.qtyum;Cnvtu[2]=1
		CNVTA=pol.CurrQtyRcvd
		if (cnvta)
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		endif
		WebStr$=WebStr$,LTrim$(X3 Using QMask$),fdel$ ! 
		webstr$=webstr$,str$(totrollwgt),fdel$
		LIST$[2]=webstr$
		row=3
	endif
	LIST$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
    call SetOutput(e$,rstr$) 
  else
    include "src/callsuberr.inc"
 end try
end sub ! getroll

!--------------------------------------------------------------------
Sub submitroll()
! details - get & update SOQty to match PO Qty(already base
  Try
	Dim Polkey$[60]
	ReturnStatus=1
	Message$="OK" 
	if p61$[104,104]<>"Y"
		let returnstatus=0
		let message$="Roll Inventory is not Available "
		goto endsubroll:
	endif
	Call dxget("POID",tmp$)                           
	POno = tmp$  
	If pono <= 0 Or pono > 999999 Or Fra(pono)  
		ReturnStatus = 0                                   
		Message$ = "INVALID PURCHASE ORDER!"  
		goto endsubroll:
	End If   
	Call dxget("LN",tmp$) ! +Str$(X1),tmp$)         
	LineNo = tmp$ ! line # (zero on new lines)
	If LineNo <= 0 Or LineNo > 999 Or Fra(lineno)  
		ReturnStatus = 0                                   
		Message$ = "INVALID PURCHASE ORDER LINE!"  
		goto endsubroll:
	End If   
	Polkey$ = " ",Polkey$                         
	Polkey$[1,6] = POno Using "######"         
	Polkey$[7,9] = LineNo Using "###"       
	Polkey$[10] = "" ! cut to length (space @ 10) 
	rec_pol = filegetpoline(e$,ch_pol,"=",1,polkey$,pol.)
	if rec_pol<=0
		returnstatus=0
		Message$="Purchase Order Line Not Found"
		goto endsubroll:
	endif
	LET X2=pol.flags ! ! REM UNPACK pol.Flags TO FLAGS[x] 
	FOR K=0 TO 11                     
		LET FLAGS[K]=SGN(FRA(X2/2)) \ LET X2=INT(X2/2) 
	NEXT K
	NonStk=flags[0]
	Closedshort=flags[1]
	Zline=flags[2] 
	if nonstk<>0
		returnstatus=0
		Message$="Roll Inventory Not Available for Nonstock Items"
		goto endsubroll:
	endif
	if zline<>0
		returnstatus=0
		Message$="Roll Inventory Not Available for Message Lines"
		goto endsubroll:
	endif
	!if pol.currqtyrcvd=0
	!	returnstatus=0
	!	Message$="No Items have been received "
	!	goto endsubroll:
	!endif
	Prodkey$=" ",prodkey$
	prodkey$=pol.ProdCode$
	PRR=filegetprod(e$,PRC,"=",1,ProdKey$,pr.)
	If PRR<0 
		returnstatus=0
		Message$="Product "+rtrim$(prodkey$)+" Not On File"
		goto endsubroll:
	endif				
	if pr.rollinv$<>"Y"
		returnstatus=0
		Message$="Product "+rtrim$(prodkey$)+" Not A Roll Inventory Item"
		goto endsubroll:
	endif
	! open the roll
	ch_por=findchannel()
	let f$="3/SPOROLL"+STR$(INTCO)
	try
		open #ch_por,f$
	else
		let returnstatus=0
		let message$="Roll Inventory is not Available "
		goto endsubroll:
	end try
	ch_prdrl=findchannel()
	let f$="2/PRODROLL"+STR$(intco)
	try
		ropen #ch_prdrl,f$
	else
		let returnstatus=0
		let message$="Roll Inventory is not Available "
		goto endsubroll:
	end try
	! delete roll items
	let keyroll$=" ",keyroll$
	let keyroll$[1,6]=pono using "######"
	let keyroll$[7,9]=lineno using "###"
	do
		rec_por = filegetporoll(e$,ch_por,">",1,Keyroll$,por.)
		let e$=""
		IF rec_por<0 exit do
		let tmp3=keyroll$[1,6]
		if tmp3<>pono exit do
		let tmp3=keyroll$[7,9]
		if tmp3<>lineno exit do
		rec_tmp=fileupdateporoll(e$,ch_por,"d",rec_por,por.)
		e$=""
		if rec_tmp<0
			let returnstatus=0
			let message$=message$="Error Deleting Rolls "	
		endif
	 loop
	 Call DXGet("TOTREC",tmp$) ! number of lines sent
	let numlines=tmp$
	If numlines<1 or NumLines>999
		let returnstatus=0
		Message$="PURCHASE ORDER "+STR$(PONO)+" Invalid Number of Line to Update"
		goto endsubroll: ! 
	endif
	if not (numlines) goto endsubroll:
	For lctr=1 to NumLines ! this is the loop 
		Call DXGet("ROLLID"+str$(lctr),tmp$)
		if rtrim$(tmp$)=""
			let returnstatus=0
			let message$="Invalid Roll Id Submitted "
			goto endsubroll:
		endif
		let rollid$=tmp$+blank$
		let keyroll$=" ",keyroll$
		let keyroll$[1,20]=rollid$[1,20]
		let keyroll$[21,32]=pol.prodcode$[1,12]
		search #ch_prdrl,3,2;keyroll$,rec_prdrl,e
		if not(e)
			if keyroll$[1,20]=rollid$[1,20] and keyroll$[21,32]=pol.prodcode$[1,12]
				let returnstatus=0
				let message$="Roll Id: "+rtrim$(rollid$)+" Already in Roll Inventory File "
				goto endsubroll:
			endif
		endif
		let keyroll$=" ",keyroll$
		let keyroll$[1,20]=rollid$[1,20]
		let keyroll$[21,26]=PRR using "######"
		search #ch_por,3,2;keyroll$,rec_por,e
		if not(e)
			if keyroll$[1,20]=rollid$[1,20]
				let tmp3=keyroll$[21,26]
				if tmp3=prr
				    let returnstatus=0
					let message$="Roll Id: "+rtrim$(rollid$)+" Already on a Purchase Order "
					goto endsubroll:
				endif
			endif
		endif
		Call DXget("WEIGHT"+STR$(lctr),tmp$)
		let tmp3=tmp$
		if tmp3<=0
			let returnstatus=0
			let message$="Invalid Weight Submitted for ROll "+rtrim$(rollid$)
			goto endsubroll:
		endif
		let por.wgt=tmp3
		CALL dXGET("VENDID",tmp$)
		let tmp3=tmp$
		let por.vend=tmp3
		let por.prodid$=pol.ProdCode$+blank$
		let por.rollid$=rollid$
		let por.spare$=" ",por.spare$
		let por.whse=pol.whse
		let por.poline=lineno
		let por.spare1$=" ",por.spare1$
		let por.ponum=pono
		let por.prodrec=prr
		let por.spacekey$=" ",por.spacekey$
		rec_por=fileupdateporoll(e$,ch_por,"a",0,por.)
		if rec_por<0
			let returnstatus=0
			let message$="Error Adding Roll Id "+rollid$
			goto endsubroll:
		endif
	next lctr
	!
	endsubroll: ! ! set list header
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
    call SetOutput(e$,rstr$) 
  
  else
    include "src/callsuberr.inc"
 end try
end sub ! submitroll

!!! delete roll
!--------------------------------------------------------------------
Sub deleteroll()
! details - get & update SOQty to match PO Qty(already base
  Try
	Dim Polkey$[60]
	ReturnStatus=1
	Message$="OK" 
	if p61$[104,104]<>"Y"
		let returnstatus=0
		let message$="Roll Inventory is not Available "
		goto enddelroll:
	endif
	Call dxget("POID",tmp$)                           
	POno = tmp$  
	If pono <= 0 Or pono > 999999 Or Fra(pono)  
		ReturnStatus = 0                                   
		Message$ = "INVALID PURCHASE ORDER!"  
		goto enddelroll:
	End If   
	Call dxget("LN",tmp$) ! +Str$(X1),tmp$)         
	LineNo = tmp$ ! line # (zero on new lines)
	If LineNo <= 0 Or LineNo > 999 Or Fra(lineno)  
		ReturnStatus = 0                                   
		Message$ = "INVALID PURCHASE ORDER LINE!"  
		goto enddelroll:
	End If   
	Polkey$ = " ",Polkey$                         
	Polkey$[1,6] = POno Using "######"         
	Polkey$[7,9] = LineNo Using "###"       
	Polkey$[10] = "" ! cut to length (space @ 10) 
	rec_pol = filegetpoline(e$,ch_pol,"=",1,polkey$,pol.)
	if rec_pol<=0
		returnstatus=0
		Message$="Purchase Order Line Not Found"
		goto enddelroll:
	endif
	LET X2=pol.flags ! ! REM UNPACK pol.Flags TO FLAGS[x] 
	FOR K=0 TO 11                     
		LET FLAGS[K]=SGN(FRA(X2/2)) \ LET X2=INT(X2/2) 
	NEXT K
	NonStk=flags[0]
	Closedshort=flags[1]
	Zline=flags[2] 
	if nonstk<>0
		returnstatus=0
		Message$="Roll Inventory Not Available for Nonstock Items"
		goto enddelroll:
	endif
	if zline<>0
		returnstatus=0
		Message$="Roll Inventory Not Available for Message Lines"
		goto enddelroll:
	endif
	Prodkey$=" ",prodkey$
	prodkey$=pol.ProdCode$
	PRR=filegetprod(e$,PRC,"=",1,ProdKey$,pr.)
	If PRR<0 
		returnstatus=0
		Message$="Product "+rtrim$(prodkey$)+" Not On File"
		goto enddelroll:
	endif				
	if pr.rollinv$<>"Y"
		returnstatus=0
		Message$="Product "+rtrim$(prodkey$)+" Not A Roll Inventory Item"
		goto enddelroll:
	endif
	! open the roll
	ch_por=findchannel()
	let f$="3/SPOROLL"+STR$(INTCO)
	try
		open #ch_por,f$
	else
		let returnstatus=0
		let message$="Roll Inventory is not Available "
		goto enddelroll:
	end try
	ch_prdrl=findchannel()
	let f$="2/PRODROLL"+STR$(intco)
	try
		ropen #ch_prdrl,f$
	else
		let returnstatus=0
		let message$="Roll Inventory is not Available "
		goto enddelroll:
	end try
	! delete roll items
	let keyroll$=" ",keyroll$
	let keyroll$[1,6]=pono using "######"
	let keyroll$[7,9]=lineno using "###"
	do
		rec_por = filegetporoll(e$,ch_por,">",1,Keyroll$,por.)
		e$=""
		IF rec_por<0 exit do
		let tmp3=keyroll$[1,6]
		if tmp3<>pono exit do
		let tmp3=keyroll$[7,9]
		if tmp3<>lineno exit do
		rec_tmp=fileupdateporoll(e$,ch_por,"d",rec_por,por.)
		e$=""
		if rec_tmp<0
			let returnstatus=0
			let message$=message$="Error Deleting Rolls "
			goto enddelroll:
		endif
	 loop
	 if returnstatus=1
		let message$="Deleted "
	 endif
	enddelroll: ! ! set list header
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	! done with it
    call SetOutput(e$,rstr$) 
  
  else
    include "src/callsuberr.inc"
 end try
end sub ! deleteroll
!--------------------------------------------------------------------------------
Sub verifynskey()

  Try
	dim newnskey$[30], oldnskey$[30]
	read record #ch_nstk,rec_nstk;nstk.				
	let rec_tmp=rec_nstk
	let newnskey$=" ",newnskey$
	let newnskey$[1,12]=nstk.prodcode$
	let newnskey$[13,14]=nstk.tiebreak using "##"
	search #ch_nstk,2,1;newnskey$,rec_tmp,e
	if e<>0
		let oldnskey$=" ",oldnskey$
		do
			search #ch_nstk,3,1;oldnskey$,rec_tmp,e
			if e<>0 exit do
			if rec_tmp=rec_nstk
				let nstk.prodcode$=oldnskey$[1,12]
				let nstk.tiebreak=oldnskey$[13,14]
				write record #ch_nstk,rec_nstk;nstk.;
				exit do
			endif
		 loop
	endif

 else
    include "src/callsuberr.inc"
 end try
end sub ! verifynskey
					
!!! imports
!--------------------------------------------------------------------
Sub importlandcostrecap()
! go thru passed order and send existing lines back
 Try
	Dim KOL$[60],KPW$[60],KCM$[50],KLP$[60],keypoh$[30]
	Dim ZOL$[60],xdate$[10]
	Dim 1%,FCDays,cnvtu[2],elflag,flags[11]
	Dim 2%,PONo,row,tmpcnt,JDate[5],FDate
	Dim 3%,OLR,FutCost,CNVTA,Amount,rec_poh
	Dim 3%,totordamt,totordcube, totordcube,totordqty
	Dim 3%,totrcvdamt,totrcvdwgt, totrcvdcube,totrcvdqty
	dim 3%,impqty,landcost
	dim qtyum$[4],costum$[4]
	Dim 3%,LPR,X3[9]
	DIM 3%,NETCOST,LANDCOST
	let totordamt=0;totordcube=0;totordcube=0;totordqty=0
	let totrcvdamt=0;totrcvdwgt=0; totrcvdcube=0;totrcvdqty=0
	ReturnStatus=1
	Message$="OK"
	Call DXGet("POID",tmp$)
	X2=tmp$
	If X2<1 or X2>999999 or Fra(X2) ! not valid
		ReturnStatus=0
		Message$="Purchase Order Number "+str$(x2)+" Not Valid"
		goto endlandrecap:
	Endif
	PONo=x2
	Rec_poh=getpohrec(e$,ch_poh,pono,poh.)
	
	If rec_poh<=0 ! not found
		ReturnStatus=0
		Message$="Purchase Order "+str$(x2)+" Not On File"
		goto endlandrecap:
	Endif
	Call GetVend()
	endlandrecap: ! end of info
	Clear List$[]
	List$[0]=bsdel$,"LANDEDCOSTRECAP",fdel$
	WebStr$="ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$
	Webstr$=Webstr$,"LineNum",fdel$
	Webstr$=WEBSTR$,"NetCost",fdel$
	Webstr$=WEBSTR$,"OceanFrt",fdel$
	Webstr$=WEBSTR$,"Custom",fdel$
	Webstr$=WEBSTR$,"Broker",fdel$
	Webstr$=WEBSTR$,"CartIn",fdel$
	Webstr$=WEBSTR$,"WhseLoad",fdel$
	Webstr$=WEBSTR$,"CartOut",fdel$
	Webstr$=WEBSTR$,"Insurance",fdel$
	Webstr$=webstr$,"Airfare",fdel$
	webstr$=webstr$,"Miscell",fdel$
	webstr$=webstr$,"ExtLandedCost",fdel$
	webstr$=webstr$,"LandedCost",fdel$
	List$[1]=webstr$
	Row=2;tmpcnt=maxcnt
	if not(returnstatus) goto endlandrecap1:
	Call DXGet("SOURCE",tmp$)
	SOURCE=tmp$
	KOL$=" ",KOL$;NumLines=0
	KOL$=PONo Using "######"
	! what if start with or only zlines on Purchase order??
	Do
		rec_pol=filegetpoline(e$,ch_pol,">",1,kol$,pol.)
		If rec_pol<0 exit do
		X2=kol$[1,6] \ if x2<>pono exit do
		! flag for non-stock item in logic
		LET X2=pol.flags ! ! REM UNPACK pol.Flags TO FLAGS[x] 
	        FOR K=0 TO 11                     
		   LET FLAGS[K]=SGN(FRA(X2/2)) \ LET X2=INT(X2/2) 
		NEXT K
		NonStk=flags[0]
		CLOSED=0
		if poh.status=7 let closed = 99
		if pol.status=3 let closed = 99
		closedshort=flags[1]
		Zline=flags[2]
		if zline<>0 goto getnxtrecap:
		let impqty=0
		let impqty=pol.QtyShip
		if not(impqty) let impqty=pol.QtyOrd
		if source=371 let impqty=pol.CurrQtyRcvd
		if closed<>0 let impqty=QtyRcvdToDate
		if impqty<=0 goto getnxtrecap:
		
		! get/read appropriate records (prod,prodwhse,comm,lastprice
		If Not(NonStk) ! it's a prod
			PRR=pol.ProdDescRec
			Read record #PRC,PRR,0;PR.;
		Else
			Clear pr.
			Clear pw.
		Endif
		! always set up pr. w/line factors
		LineNo=pol.ItemNo
		if (NonStk)
			Read Record #ch_nstk,pol.ProdDescRec; nstk.;
		endif
		Call SetPRtoPol() !!! 
		! Call LineMainDtl() ! set up web string

	LET LANDCOST=0 
        IF IMPQTY<>0
		 LET LANDCOST=POL.LandedCost/IMPQTY  
		 IF CLOSED<>0
			LET LANDCOST=POL.TtlLandedCost/IMPQTY  
		 ENDIF
	ENDIF
	IF LANDCOST<>0  
		cnvtu[0]=0;cnvtu[1]=pol.costum;cnvtu[2]=2
		Cnvta=LANDCOST
		let x3=0
		if cnvta<>0
			X3=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
			if p61$[136,136]="Y" and pol.currfact<>0 ! going from base to costing um
				let cnvcu[0]=1
				let cnvca[0]=x3
				let cnvca[1]=pol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let x3=cnvca[0]
			endif
		endif
		LANDCOST=X3
	ENDIF
	IF NOT (CLOSED)
		LET NETCOST=0
		lineqty =  impqty                                            
		lineum = pol.CostUM                                                 
		linecost = pol.netcost   
				lineextamt = 0  
		LbsUnit = pol.LbsUnit                                               
		LbsFact = pol.LbsFactor 
		currfact= pol.currfact
		if lbsfact<=0
			if pr.lbsfact>0
				let pol.lbsfactor=pr.lbsfact;lbsfact=pr.lbsfact
			else
				let pol.lbsfactor=1;lbsfact=1
			endif
		endif
		if lbsunit<=0
			if pr.lbsunit>0
				let pol.lbsunit=pr.lbsunit; lbsunit=pr.lbsunit
			else
				let pol.lbsunit=1; lbsunit=1
			endif
		endif
		Call CalcExtAmt(lineqty,lineum,linecost,lineextamt,LbsUnit,LbsFact,currfact) 
		NetCost = lineextamt
	else                                        
  		LET NETCOST=FNR(pol.TtlLandedCost)   
		let netcost=Fnr(netcost-pol.TtlOceanFrt) ! PL6[0]  
		let netcost=Fnr(netcost-pol.TtlDuty)	 ! PL6[1]  
		let netcost=Fnr(netcost-pol.TtlBrokerFee)! PL6[2]  
		let netcost=Fnr(netcost-pol.TtlCartageIn)! PL6[3]  
		let netcost=Fnr(netcost-pol.TtlWhseLoad) ! PL6[4]  
		let netcost=Fnr(netcost-pol.TtlCartageOut)! PL6[5]  
		let netcost=Fnr(netcost-pol.TtlInsurance)! PL6[6]  
		let netcost=Fnr(netcost-pol.TtlAirfare)  ! PL6[7]  
		let netcost=Fnr(netcost-pol.TtlMiscAddOn)! PL6[8]  
		IF NETCOST<0 LET NETCOST=0
	endif                                 
                                             
	WebStr$=pol.prodcode$,fdel$ ! prod code
	tmp$=clrtxtc$(e$,pol.Desc1$)
	Webstr$=webstr$,RTrim$(tmp$),fdel$ !  desc 1
	tmp$=clrtxtc$(e$,pol.Desc2$)
	Webstr$=webstr$,RTrim$(tmp$),fdel$ !  desc 2
	webstr$=webstr$,ltrim$(pol.itemno using "###"),fdel$ ! linenum
	webstr$=webstr$,ltrim$(netcost using "-------#.##"),fdel$ ! netcost
	if not(closed) 
		webstr$=webstr$,ltrim$(pol.ExtdOceanFrt using "-------#.##"),fdel$ ! oceanfreight
		webstr$=webstr$,ltrim$(pol.ExtdDuty using "-------#.##"),fdel$ ! custom duty
		webstr$=webstr$,ltrim$(pol.ExtdBrokerFee using "-------#.##"),fdel$ ! broker
		webstr$=webstr$,ltrim$(pol.ExtdCartgIn using "-------#.##"),fdel$ ! cartin
		webstr$=webstr$,ltrim$(pol.ExtdWhseLoad   using "-------#.##"),fdel$ ! whseload
		webstr$=webstr$,ltrim$(pol.ExtdCartgOut using "-------#.##"),fdel$ ! cartout
		webstr$=webstr$,ltrim$(pol.ExtdInsurance using "-------#.##"),fdel$ ! insurance
		webstr$=webstr$,ltrim$(pol.AirfareAddOn  using "-------#.##"),fdel$ ! airfare
		webstr$=webstr$,ltrim$(pol.MiscAddOn  using "-------#.##"),fdel$ ! misc
		webstr$=webstr$,ltrim$(pol.LandedCost using "-------#.##"),fdel$ ! landcost
	else
		webstr$=webstr$,ltrim$(pol.TtlOceanFrt using "-------#.##"),fdel$ ! oceanfreight
		webstr$=webstr$,ltrim$(pol.TtlDuty using "-------#.##"),fdel$ ! custom duty
		webstr$=webstr$,ltrim$(pol.TtlBrokerFee   using "-------#.##"),fdel$ ! broker
		webstr$=webstr$,ltrim$(pol.TtlCartageIn  using "-------#.##"),fdel$ ! cartin
		webstr$=webstr$,ltrim$(pol.TtlWhseLoad  using "-------#.##"),fdel$ ! whseload
		webstr$=webstr$,ltrim$(pol.TtlCartageOut using "-------#.##"),fdel$ ! cartout
		webstr$=webstr$,ltrim$(pol.TtlInsurance using "-------#.##"),fdel$ ! insurance
		webstr$=webstr$,ltrim$(pol.TtlAirfare  using "-------#.##"),fdel$ ! airfare
		webstr$=webstr$,ltrim$(pol.TtlMiscAddOn using "-------#.##"),fdel$ ! misc
		webstr$=webstr$,ltrim$(pol.TtlLandedCost using "-------#.##"),fdel$ ! landed cost

	endif
	COSTUM$=xunit$(POL.COSTUM,ccc) ! u/m
	webstr$=webstr$,ltrim$(LandCost using pmask$)," ",rtrim$(costum$),fdel$ ! land cost
	List$[row]=WebStr$
	Let row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
	getnxtrecap: ! get next recap line
	Loop ! done with order
	
	endlandrecap1:! finish ord line get
	List$[row]=esdel$ ! finished
	call AddToStr(e$,rstr$,List$[])
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	
 else
    include "src/callsuberr.inc"
 end try
end sub ! importlandcostrecap
! 

!!!!!!!!!!!!!! import get line
!--------------------------------------------------------------------
Sub importgetline()
! go thru passed order and send existing lines back
 Try
	Dim KOL$[60],KPW$[60],KCM$[50],KLP$[60],keypoh$[30]
	Dim ZOL$[60],xdate$[10],keybr$[6],polkey$[60]
	Dim 1%,FCDays,cnvtu[2],elflag,flags[11]
	Dim 2%,PONo,row,tmpcnt,JDate[5],FDate
	dim 2%,cfee[2],poins,ofrate
	dim 3%,bcdamt,bbrate,tlandcost
	Dim 3%,OLR,FutCost,CNVTA,Amount,rec_poh
	Dim 3%,totordamt,totordcube, totordcube,totordqty
	Dim 3%,totrcvdamt,totrcvdwgt, totrcvdcube,totrcvdqty
	dim 3%,impqty,impcube,rec_pobr
	dim qtyum$[4],costum$[4]
	Dim 3%,LPR,X3[9]
	DIM 3%,NETCOST,LANDCOST
	let totordamt=0;totordcube=0;totordcube=0;totordqty=0
	let totrcvdamt=0;totrcvdwgt=0; totrcvdcube=0;totrcvdqty=0

	ReturnStatus=1
	Message$="OK"
	if p60$[46,46]<>"Y"
		returnstatus=0
		message$="Import Purchase Order not Available"
		goto endimpgetline:
	endif
	IF p60$[46,46]="Y" ! import section
		ch_poof= OpenFile("POOCNFRT",Intco,"R") 
		ch_pocd= OpenFile("POCDUTY",Intco,"R") 
		ch_pobr= OpenFile("POBROKER",Intco,"R") 
	ENDIF

	Call DXGet("POID",tmp$)
	X2=tmp$
	If X2<1 or X2>999999 or Fra(X2) ! not valid
		ReturnStatus=0
		Message$="Purchase Order Number "+str$(x2)+" Not Valid"
		goto endimpgetline:
	Endif
	PONo=x2
	Rec_poh=getpohrec(e$,ch_poh,pono,poh.)	
	If rec_poh<=0 ! not found
		ReturnStatus=0
		Message$="Purchase Order "+str$(x2)+" Not On File"
		goto endimpgetline:
	Endif
	if poh.type<3 or poh.type>6
		returnstatus=0
		Message$="Purchase Order "+str$(pono)+ " Not an Import Order Type "
		goto endimpgetline:
	endif

	Call DXGet("LINENUM",tmp$) ! +Str$(X1),tmp$)
	LineNo=tmp$
	if lineno<1 or lineno>999
		ReturnStatus=0
		Message$="Purchase Order Number "+str$(x2)+" Not Valid"
		goto endimpgetline:
	endif
	polkey$=" ",polkey$
	polkey$[1,6]=PONo Using "######"
	Polkey$[7,9]=LINENO using "###"
	polkey$[10]="" ! cut to length (space @ 10)
	rec_pol=filegetpoline(e$,ch_pol,"=",1,polkey$,pol.)
	if rec_pol<=0 ! what do we do if not found?
		let returnstatus=0
		let message$="Line is not on file "
		goto endimpgetline:
	endif
	Call GetVend()

	endimpgetline: ! end of info
	List$[0]=bsdel$,"ImportLine",fdel$
	WebStr$="ProdID",fdel$,"Desc1",fdel$,"Desc2",fdel$
	Webstr$=Webstr$,"LineNum",fdel$
	Webstr$=webstr$,"CostSec",fdel$
	Webstr$=webstr$,"LineClosed",fdel$
	Webstr$=webstr$,"LineCube",fdel$
	Webstr$=webstr$,"LineCubeUM",fdel$
	Webstr$=webstr$,"LineQty",fdel$
	Webstr$=webstr$,"LineQtyUM",fdel$
	if cost_lev[2]
		Webstr$=webstr$,"LineCost",fdel$
	else
		Webstr$=webstr$,"",fdel$
	endif
	Webstr$=webstr$,"OceanFrtId",fdel$
	Webstr$=webstr$,"OceanFrtDesc",fdel$
    Webstr$=webstr$,"DutyId",fdel$
	Webstr$=webstr$,"DutyDesc",fdel$
	Webstr$=webstr$,"BrokerId",fdel$
	Webstr$=webstr$,"BrokerName",fdel$
	List$[1]=webstr$
	Row=2;tmpcnt=maxcnt
	if not(returnstatus) goto endimpgetline1:
	Call DXGet("SOURCE",tmp$)
	SOURCE=tmp$
	LET X2=pol.flags ! ! REM UNPACK pol.Flags TO FLAGS[x] 
	       FOR K=0 TO 11                     
	   LET FLAGS[K]=SGN(FRA(X2/2)) \ LET X2=INT(X2/2) 
	NEXT K
	NonStk=flags[0]
	CLOSED=0
	if poh.status=7 let closed = 99
	if pol.status=3 let closed = 99
	closedshort=flags[1]
	Zline=flags[2]
	if zline<>0 
		let returnstatus=0
		let message$="Line is designated as a message"
		goto endimpgetline1: 
	endif
	let impqty=0
	let impqty=pol.QtyShip
	if not(impqty) let impqty=pol.QtyOrd
	if source=371 
		let impqty=pol.CurrQtyRcvd
		if not(impqty) let impqty=pol.qtyord
	endif
	if closed<>0 let impqty=QtyRcvdToDate
	if impqty<=0
			let returnstatus=0
			let message$="No Quantity to be imported "
			goto endimpgetline1: 
	endif	
	! get/read appropriate records (prod,prodwhse,comm,lastprice
	If Not(NonStk) ! it's a prod
		PRR=pol.ProdDescRec
		Read record #PRC,PRR,0;PR.;
	Else
		Clear pr.
		Clear pw.
	Endif
	! always set up pr. w/line factors
	LineNo=pol.ItemNo
	if (NonStk)
		Read Record #ch_nstk,pol.ProdDescRec; nstk.;
	endif
	Call SetPRtoPol() !!! 
	let impcube=pol.ExtCubes
	if pol.CbfUnit<>0 and pol.CbfFactor <>0
		IMPCUBE=FNR(IMPQTY*pol.CbfUnit/pol.CbfFactor) 
	endif
    LET NETCOST=FNR(IMPQTY*pol.netcost) 	                                              
	WebStr$=pol.prodcode$,fdel$ ! prod code
	tmp$=clrtxtc$(e$,pol.Desc1$)
	Webstr$=webstr$,RTrim$(tmp$),fdel$ !  desc 1
	tmp$=clrtxtc$(e$,pol.Desc2$)
	Webstr$=webstr$,RTrim$(tmp$),fdel$ !  desc 2
	webstr$=webstr$,ltrim$(pol.itemno using "###"),fdel$ ! linenum
	Webstr$=webstr$,str$(cost_lev[2]),fdel$
	let tmp$=""
	if closed<>0 let tmp$="Y"
	Webstr$=webstr$,tmp$,fdel$ ! line closed
	Webstr$=webstr$,Ltrim$(impcube using "#########.##"),fdel$ ! line cube
	Webstr$=webstr$,"CbFt",fdel$ ! LineCubeUM
	CNVTA=IMPQTY ! importqty                                
	CNVTU[0]=0                                                      
	CNVTU[1]=pol.qtyum                                              
	CNVTU[2]=1  
	let amount=0
	if cnvta<>0
		Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)         
	endif   
	WEBSTR$=WEBSTR$,LTRIM$(AMOUNT USING QMASK$),FDEL$ ! LINE QTY
	QTYUM$=xunit$(POL.QTYUM,ccc) ! u/m 
	Webstr$=webstr$,QTYUM$,FDEL$ ! LineQtyUM"
	if cost_lev[2]
		Webstr$=webstr$,ltrim$(netcost using "##########.##"),fdel$
	else
		Webstr$=webstr$,"",fdel$
	endif
	if pol.OceanFrtRec<>-100
		if pol.OceanFrtRec<0 or pol.OceanFrtRec>100
			let pol.OceanFrtRec=0
		endif
	endif
    WEBSTR$=WEBSTR$,STR$(pol.OceanFrtRec),fdel$
	if pol.OceanFrtRec<>0
		Read Record #ch_poof,pol.OceanFrtRec;poof.;
	else
		clear poof.
	endif
	Webstr$=webstr$,rtrim$(poof.description$),fdel$
	Webstr$=webstr$,str$(pol.DutyTypeRec),fdel$
	if pol.DutyTypeRec<0 OR pol.DutyTypeRec>999
		let pol.DutyTypeRec=0
	endif
	if pol.DutyTypeRec>0
		Read Record #ch_pocd,pol.DutyTypeRec;pocd.;
	else
		clear pocd.
	endif
	Webstr$=webstr$,rtrim$(pocd.CustomDutyDesc$),fdel$
	let keybr$=" ",keybr$;keybr$[1,5]=poh.broker$
	clear pobr.
	search #ch_pobr,2,1;keybr$,rec_pobr,e
	if not(e)
		read record #ch_pobr,rec_pobr;pobr.;
	endif
	webstr$=webstr$,poh.broker$,fdel$
	webstr$=webstr$,rtrim$(pobr.Description$),fdel$

	LIST$[ROW]=WEBSTR$
	LET ROW=ROW+1

	endimpgetline1:! finish ord line get
	List$[row]=esdel$ ! finished
	call AddToStr(e$,rstr$,List$[])	
    
   !---- SECTION 2 -- COST
   clear list$[]
   List$[0]=bsdel$,"ImportCost",fdel$
	Webstr$="OceanFrtRate",fdel$
	Webstr$=Webstr$,"OceanFrtUM",fdel$
	webstr$=webstr$,"DutyRate",fdel$
	Webstr$=webstr$,"DutyType",fdel$
	webstr$=webstr$,"DutyUM",fdel$
	webstr$=webstr$,"BrokerRate",fdel$
	webstr$=webstr$,"BrokerType",fdel$
	webstr$=webstr$,"CartInRate",fdel$
	webstr$=webstr$,"WhseLoadRate",fdel$
	webstr$=webstr$,"CartOutRate",fdel$
	webstr$=webstr$,"RateUm",fdel$
	Webstr$=webstr$,"InsurRate",fdel$
	webstr$=webstr$,"ExtdOceanFrt",fdel$ 
	webstr$=webstr$,"ExtdDuty",fdel$     
	webstr$=webstr$,"ExtdBrokerFee",fdel$
	webstr$=webstr$,"ExtdCartgIn",fdel$ 
	webstr$=webstr$,"ExtdWhseLoad",fdel$
	webstr$=webstr$,"ExtdCartgOut",fdel$ 
	webstr$=webstr$,"ExtdInsurance",fdel$
	webstr$=webstr$,"AirfareAddOn",fdel$
	webstr$=webstr$,"MiscAddOn",fdel$  
	webstr$=webstr$,"ExtLandedCost",fdel$  
	webstr$=webstr$,"UnitLandCost",fdel$
	webstr$=webstr$,"Boat",fdel$
	webstr$=webstr$,"Container",fdel$
	list$[1]=webstr$
	Row=2;tmpcnt=maxcnt
	if not(returnstatus) goto endimpgetline2:
	if not(cost_lev[2]) goto endimpgetline2:
	webstr$=(poof.CubicFt using "###.####"),fdel$
	Webstr$=webstr$,"CbFt",fdel$ ! LineCubeUM
	webstr$=webstr$,(pocd.DutyAmount using "###.####"),fdel$
	if pocd.cdtype<0 or pocd.cdtype>1
		let pocd.cdtype=0
	endif
	webstr$=webstr$,str$(pocd.Cdtype),fdel$ ! duty type 0=dollar, 1=percentage
	COSTUM$=xunit$(POL.COSTUM,ccc) ! u/m 
	Webstr$=webstr$,COSTUM$,FDEL$ ! LineQtyUM"
	webstr$=webstr$,(pobr.Rate using "###.####"),fdel$
	if pobr.RateType<0 or pobr.RateType>1
		let pobr.RateType=0
	endif
	webstr$=webstr$,str$(pobr.RateType),fdel$ ! broker type 0=dollar, 1=percentage
	for ctr=0 to 2\let cfee[ctr]=0\next ctr
	IF POH.TYPE<>5 ! IMPORT DIRECT
		 MAT  READ #ctlc,32,4;CFEE;
	ENDIF

    for ctr=0 to 2 ! cartin, whse load, cart out
		if cfee[ctr]<>0
			webstr$=webstr$,(cfee[ctr] using "###.####"),fdel$
		else
			webstr$=webstr$,"",fdel$
		endif
	NEXT CTR
	qtyUM$=xunit$(pr.UMStkDefault,ccc) ! u/m 
	Webstr$=webstr$,qtyUM$,FDEL$ ! 
	READ #CTLC,32,24;POINS;
	IF POINS<>0
		webstr$=webstr$,(poins using "###.####"),fdel$
	else
		webstr$=webstr$,"",fdel$
	endif
	if cost_lev[2]<>0
		if not(closed)
			call calcimplinetot ()
			webstr$=webstr$+(pol.ExtdOceanFrt USING "--------#.##"),fdel$
			webstr$=webstr$+(pol.ExtdDuty  USING "--------#.##"),fdel$   
			webstr$=webstr$+(pol.ExtdBrokerFee USING "--------#.##"),fdel$
			webstr$=webstr$+(pol.ExtdCartgIn USING "--------#.##"),fdel$ 
			webstr$=webstr$+(pol.ExtdWhseLoad USING "--------#.##"),fdel$
			webstr$=webstr$+(pol.ExtdCartgOut USING "--------#.##"),fdel$
			webstr$=webstr$+(pol.ExtdInsurance USING "--------#.##"),fdel$
			webstr$=webstr$+(pol.AirfareAddOn USING "--------#.##"),fdel$
			webstr$=webstr$+(pol.MiscAddOn USING "--------#.##"),fdel$   
			webstr$=webstr$+(pol.LandedCost USING "--------#.##"),fdel$  
			webstr$=webstr$+(LandCost USING "--------#.##"),fdel$ 
		else
			webstr$=webstr$+(pol.TtlOceanFrt USING "--------#.##"),fdel$   
			webstr$=webstr$+(pol.TtlDuty USING "--------#.##"),fdel$       
			webstr$=webstr$+(pol.TtlBrokerFee USING "--------#.##"),fdel$  
			webstr$=webstr$+(pol.TtlCartageIn USING "--------#.##"),fdel$   
			webstr$=webstr$+(pol.TtlWhseLoad USING "--------#.##"),fdel$   
			webstr$=webstr$+(pol.TtlCartageOut USING "--------#.##"),fdel$ 
			webstr$=webstr$+(pol.TtlInsurance USING "--------#.##"),fdel$  
			webstr$=webstr$+(pol.TtlAirfare  USING "--------#.##"),fdel$   
			webstr$=webstr$+(pol.TtlMiscAddOn USING "--------#.##"),fdel$  
			webstr$=webstr$+(pol.TtlLandedCost USING "--------#.##"),fdel$
			let landcost=0
			if impqty<>0
				let landcost=fnr(pol.TtlLandedCost/impqty)
			endif
			webstr$=webstr$+(LandCost USING "--------#.##"),fdel$ 
		endif
	else
		! no cost security -- send nothing
		for ctr=0 to 11
			let webstr$=webstr$,"",fdel$
		next ctr
	endif
	webstr$=webstr$+rtrim$(pol.boatname$),fdel$
	webstr$=webstr$+rtrim$(pol.container$),fdel$
   LIST$[ROW]=WEBSTR$
   LET ROW=ROW+1
		

	!!! START WITH THE PL5
	endimpgetline2: ! finish cost section
	List$[row]=esdel$ ! finished
	call AddToStr(e$,rstr$,List$[])

	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	
 else
    include "src/callsuberr.inc"
 end try
end sub ! importgetline
! 
!  --- submit import info
!--------------------------------------------------------------------
Sub importsubmitline()
! go thru passed order and send existing lines back
 Try
	Dim KOL$[60],KPW$[60],KCM$[50],KLP$[60],keypoh$[30]
	Dim ZOL$[60],xdate$[10],keybr$[6],polkey$[60]
	Dim 1%,FCDays,cnvtu[2],elflag,flags[11]
	Dim 2%,PONo,row,tmpcnt,JDate[5],FDate
	dim 2%,cfee[2],poins,ofrate
	dim 3%,bcdamt,bbrate,tlandcost
	Dim 3%,OLR,FutCost,CNVTA,Amount,rec_poh
	Dim 3%,totordamt,totordcube, totordcube,totordqty
	Dim 3%,totrcvdamt,totrcvdwgt, totrcvdcube,totrcvdqty
	dim 3%,impqty,impcube,rec_pobr
	dim qtyum$[4],costum$[4]
	Dim 3%,LPR,X3[9]
	DIM 3%,NETCOST,LANDCOST
	let totordamt=0;totordcube=0;totordcube=0;totordqty=0
	let totrcvdamt=0;totrcvdwgt=0; totrcvdcube=0;totrcvdqty=0

	ReturnStatus=1
	Message$="OK"
	if p60$[46,46]<>"Y"
		returnstatus=0
		message$="Import Purchase Order not Available"
		goto endIMPSUBLINE:
	endif
	IF COST_LEV[2]<>2
		returnstatus=0
		message$="Invalid Security Level "
		goto endIMPSUBLINE:
	endif
	IF p60$[46,46]="Y" ! import section
		ch_poof= OpenFile("POOCNFRT",Intco,"R") 
		ch_pocd= OpenFile("POCDUTY",Intco,"R") 
		ch_pobr= OpenFile("POBROKER",Intco,"R") 
	ENDIF

	Call DXGet("POID",tmp$)
	X2=tmp$
	If X2<1 or X2>999999 or Fra(X2) ! not valid
		ReturnStatus=0
		Message$="Purchase Order Number "+str$(x2)+" Not Valid"
		goto endIMPSUBLINE:
	Endif
	PONo=x2
	Rec_poh=getpohrec(e$,ch_poh,pono,poh.)	
	If rec_poh<=0 ! not found
		ReturnStatus=0
		Message$="Purchase Order "+str$(x2)+" Not On File"
		goto endIMPSUBLINE:
	Endif
	if poh.type<3 or poh.type>6
		returnstatus=0
		Message$="Purchase Order "+str$(pono)+ " Not an Import Order Type "
		goto endIMPSUBLINE:
	endif

	Call DXGet("LINENUM",tmp$) ! +Str$(X1),tmp$)
	LineNo=tmp$
	if lineno<1 or lineno>999
		ReturnStatus=0
		Message$="Purchase Order Number "+str$(x2)+" Not Valid"
		goto endIMPSUBLINE:
	endif
	polkey$=" ",polkey$
	polkey$[1,6]=PONo Using "######"
	Polkey$[7,9]=LINENO using "###"
	polkey$[10]="" ! cut to length (space @ 10)
	rec_pol=filegetpoline(e$,ch_pol,"=",1,polkey$,pol.)
	if rec_pol<=0 ! what do we do if not found?
		let returnstatus=0
		let message$="Line is not on file "
		goto endIMPSUBLINE:
	endif
	Call GetVend()
	Call DXGet("SOURCE",tmp$)
	SOURCE=tmp$
	IF SOURCE=370 OR SOURCE=381
		LET RETURNSTATUS=0
		let message$="Invalid Source for Submitting Changes "
		goto endimpsubline:
	endif
	LET X2=pol.flags ! ! REM UNPACK pol.Flags TO FLAGS[x] 
	       FOR K=0 TO 11                     
	   LET FLAGS[K]=SGN(FRA(X2/2)) \ LET X2=INT(X2/2) 
	NEXT K
	NonStk=flags[0]
	CLOSED=0
	if poh.status=7 let closed = 99
	if pol.status=3 let closed = 99
	if closed<>0 
		let returnstatus=0
		let message$="Line is closed. May Not Change"
		goto endIMPSUBLINE: 
	endif
	closedshort=flags[1]
	Zline=flags[2]
	if zline<>0 
		let returnstatus=0
		let message$="Line is designated as a message"
		goto endIMPSUBLINE: 
	endif
	! get/read appropriate records (prod,prodwhse,comm,lastprice
	If Not(NonStk) ! it's a prod
		PRR=pol.ProdDescRec
		Read record #PRC,PRR,0;PR.;
	Else
		Clear pr.
		Clear pw.
	Endif
	! always set up pr. w/line factors
	LineNo=pol.ItemNo
	if (NonStk)
		Read Record #ch_nstk,pol.ProdDescRec; nstk.;
	endif
	Call SetPRtoPol() !!! 
	Call DXGet("OCEANFRTID",tmp$) !  OceanFrtId  
	let tmp3=tmp$
	if not (tmp3) and rtrim$(tmp$)=""
		let returnstatus=0
		let message$="Invalid Ocean Freight Id Entered "
		goto endimpsubline:
	endif
	if tmp3=-100
		! not sure if this code is valid since it doesn't look like input in avail in 361bimp
	endif
	if tmp3<0 or tmp3>100
		let returnstatus=0
		let message$="Invalid Ocean Freight Id Entered "
		goto endimpsubline:
	endif
	let pol.OceanFrtRec=tmp3
	Call DXGet("DUTYID",tmp$) ! ! Custom Duty
	let tmp3=tmp$
	if not (tmp3) and rtrim$(tmp$)=""
		let returnstatus=0
		let message$="Invalid Custom Duty Id Entered "
		goto endimpsubline:
	endif
	if tmp3<0 or tmp3>999
		let returnstatus=0
		let message$="Invalid Ocean Freight Id Entered "
		goto endimpsubline:
	endif
	pol.DutyTypeRec=tmp3

	Call DXGet("AirfareAddOn",tmp$) ! Airfare Add On
	let tmp3=tmp$
	if tmp3<0
		let returnstatus=0
		let message$="Invalid Airfare Entered "
		goto endimpsubline:
	endif
	let pol.AirfareAddOn=tmp3

	Call DXGet("MiscAddOn",tmp$) ! Airfare Add On
	let tmp3=tmp$
	if tmp3<0
		let returnstatus=0
		let message$="Invalid Miscellaneous Add On  Entered "
		goto endimpsubline:
	endif
	let pol.MiscAddOn=tmp3

	Call Dxget("BOAT",tmp$) !
	let pol.boatname$=rtrim$(tmp$)+blank$

	Call Dxget("CONTAINER",tmp$)
	let pol.container$=rtrim$(tmp$)+blank$

	call calcimplinetot ()
	Write Record #ch_pol,rec_pol,0;pol.;
	endimpsubline:! finish ord line get
	

	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	
 else
    include "src/callsuberr.inc"
 end try
end sub ! importsubmitline
! 







! end submit import info
!--------------------------------------------------------------------
Sub CalcImpLineTot()
! need qty
! bring extended amount to costing unit of measure factors

! need the product file, need the poline, need the po header
Try
	dim 2%,cfee[2],poins,ofrate
	dim 3%,bcdamt,bbrate,tlandcost
	Dim 3%,CNVTA,Amount,rec_poh
	dim 3%,impqty,impcube,rec_pobr
	dim qtyum$[4],costum$[4],keybr$[6]
	DIM 3%,NETCOST,LANDCOST! need calc for impqty
	let impqty=0
	let impqty=pol.QtyShip
	if not(impqty) let impqty=pol.QtyOrd
	if source=371 let impqty=pol.CurrQtyRcvd
	if closed<>0 let impqty=QtyRcvdToDate
	! need calc for impcube
	let impcube=pol.ExtCubes
	if pol.CbfUnit<>0 and pol.CbfFactor <>0
		IMPCUBE=FNR(IMPQTY*pol.CbfUnit/pol.CbfFactor) 
	endif
   	 LET NETCOST=FNR(IMPQTY*pol.netcost)
	! need calc for netcost
	if (closed) exit sub
	! ocean freight calculation (pl5[0])
	if pol.OceanFrtRec<>-100
		let pol.ExtdOceanFrt=0;ofrate=0
		if pol.OceanFrtRec<>0
			Read Record #ch_poof,pol.OceanFrtRec;poof.;
			let ofrate=poof.CubicFt
			let pol.ExtdOceanFrt=FNR(IMPCUBE*OFRATE) 
		endif	
	else
		let ofrate=0
		if pol.ExtdOceanFrt<>0
			if impcube<>0
				let ofrate=(pol.ExtdOceanFrt/IMPCUBE)
			endif
		endif
	endif                     
  	! Custom Duty (pl5[1])
	LET pol.ExtdDuty=0
	if pol.DutyTypeRec<0 OR pol.DutyTypeRec>999
		let pol.DutyTypeRec=0
	endif
	if pol.DutyTypeRec>0
		Read Record #ch_pocd,pol.DutyTypeRec;pocd.;
	else
		clear pocd.
	endif
	if POCD.Cdtype=1 ! percentage	                                            
  		LET pol.ExtdDuty=FNR(NETCOST*pocd.DutyAmount/100)                       
	ELSE                                                      
  		LET CNVTA=POCD.DutyAmount;CNVTU[0]=pr.UMPurchDefault;CNVTU[1]=0;CNVTU[2]=2 
		If cnvta<>0  
			if p61$[136,136]="Y" and pol.currfact<>0 ! going from base to costing um
				let cnvcu[0]=2
				let cnvca[0]=cnvta
				let cnvca[1]=pol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let cnvta=cnvca[0]
			endif
			amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)                                                         
  			LET BCDAMT=AMOUNT                                       
  			LET pol.ExtdDuty=FNR(AMOUNT*IMPQTY)  
		ENDIF
	ENDIF                                                     
	! Extended Broker Fee (pl5[2])
	pol.ExtdBrokerFee=0
	let keybr$=" ",keybr$;keybr$[1,5]=poh.broker$
	clear pobr.
	search #ch_pobr,2,1;keybr$,rec_pobr,e
	if not(e)
		read record #ch_pobr,rec_pobr;pobr.;
		IF pobr.RateType=0  ! dollar amount
			if p61$[136,136]="Y" and pol.currfact<>0 ! going from costing um 
				let cnvcu[0]=2
				let cnvca[0]=pobr.rate
				let cnvca[1]=pol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let pobr.rate=cnvca[0]
			endif
  			LET CNVTA=pobr.Rate;CNVTU[0]=pr.UMPurchDefault;CNVTU[1]=0;CNVTU[2]=2     
  			amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)                                           
  			LET BBRATE=AMOUNT                                           
		ELSE                                                          
  			LET BBRATE=pobr.rate                                            
		ENDIF                                                         
		IF pobr.RateType=0 let pol.ExtdBrokerFee=FNR(BBRATE*IMPQTY)                     
		IF pobr.RateType=1 LET pol.ExtdBrokerFee=FNR(NETCOST*BBRATE/100)  
	endif  
	for ctr=0 to 2\let cfee[ctr]=0\next ctr
	IF POH.TYPE<>5 ! IMPORT DIRECT
	   MAT  READ #ctlc,32,4;CFEE;
	ENDIF
	! Extended Cart iN (pl5[3])
	LET POL.EXTDCARTGIN=0
	IF CFEE[0]<>0        
	    if p61$[136,136]="Y" and pol.currfact<>0 ! going from costing um to base
			let cnvcu[0]=2
				let cnvca[0]=cfee[0]
				let cnvca[1]=pol.currfact
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let cfee[0]=cnvca[0]
			endif
  		LET CNVTA=CFEE[0];CNVTU[0]=pr.UMStkDefault;CNVTU[1]=0;CNVTU[2]=2  
 		amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)                                      
  		POL.EXTDCARTGIN=FNR(AMOUNT*IMPQTY)                          
        endif
	! Extended Whse Load (pl5[4])
	let pol.ExtdWhseLoad=0
	if cfee[1]<>0 
		if p61$[136,136]="Y" and pol.currfact<>0 ! going from costing um to base
			let cnvcu[0]=2
			let cnvca[0]=cfee[1]
			let cnvca[1]=pol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let cfee[1]=cnvca[0]
		endif
		LET CNVTA=CFEE[1];CNVTU[0]=pr.UMStkDefault;CNVTU[1]=0;CNVTU[2]=2  
 		amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)                                     
  		POL.ExtdWhseLoad =FNR(AMOUNT*IMPQTY)  
	endif
	! Extended Cart Out (pl5[5])
	let pol.ExtdCartgOut=0
    if cfee[2]<>0
		if p61$[136,136]="Y" and pol.currfact<>0  ! going from costing um to base
			let cnvcu[0]=2
			let cnvca[0]=cfee[2]
			let cnvca[1]=pol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let cfee[2]=cnvca[0]
			endif
		LET CNVTA=CFEE[2];CNVTU[0]=pr.UMStkDefault;CNVTU[1]=0;CNVTU[2]=2  
 		amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)                                      
  		POL.ExtdCartgOut=FNR(AMOUNT*IMPQTY)  
	endif 
	! ExtdInsurance (pl5[6])  
	let pol.ExtdInsurance=0                             
        READ #CTLC,32,24;POINS;
	IF POINS<>0  
		let pol.ExtdInsurance=FNR(POINS*NETCOST/100)
	endif
	! 
	LET TLANDCOST=NETCOST  
	LET TLANDCOST=TLANDCOST+pol.ExtdOceanFrt 
	LET TLANDCOST=TLANDCOST+pol.ExtdDuty     
	LET TLANDCOST=TLANDCOST+pol.ExtdBrokerFee
	LET TLANDCOST=TLANDCOST+pol.ExtdCartgIn  
	LET TLANDCOST=TLANDCOST+pol.ExtdWhseLoad 
	LET TLANDCOST=TLANDCOST+pol.ExtdCartgOut 
	LET TLANDCOST=TLANDCOST+pol.ExtdInsurance
	LET TLANDCOST=TLANDCOST+pol.AirfareAddOn 
	LET TLANDCOST=TLANDCOST+pol.MiscAddOn    
	LET POL.LandedCost=TLANDCOST 
	if impqty<>0
		LET LANDCOST=TLANDCOST/IMPQTY                                                              
		LET CNVTA=LANDCOST;CNVTU[0]=0;CNVTU[1]=pol.costum;CNVTU[2]=2 
		amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)  
		if p61$[136,136]="Y" and pol.currfact<>0 ! from base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=pol.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=cnvca[0]
		endif
		LET LANDCOST=AMOUNT 
	else
		let landcost=0
	endif
		
 else
    include "src/callsuberr.inc"
  end try
end sub ! CalcImpLineTot
!------------------------------------------------
!!! end imports


!--------------------------------------------------------------------
Sub CPIPrdPONotes()
Try
	dim cpikey$[60]
	Dim RolKey$[60]
	dim 2%,currdate
	Dim 3%,RTR,refno,rec_cpid,lastrec,lastdate
	Dim RTKey$[60],UDA$[70],mode$[2]
	Dim RTG. as poltag
	if p61$[111,111]="Y"
		CPIDC=OpenFile(-9928,IntCo)
		if CPIDC = -1 Exit Sub ! CPIDETAIL
		RTC=OpenFile(9936,IntCo)
		if RTC=-1 exit Sub ! not po tag file
		splc = OpenFile(-1936,IntCo) 
		if splc=-1 exit sub ! special price
		let rtkey$=" ",rtkey$
		let rtkey$[1,6]=pol.ponum using "######"
		let rtkey$[7,9]=pol.itemno using "###"
		let lastdate=0
		let lastrec=0
		search #rtc,2,1;rtkey$,rtr,e
		if not(e) exit sub ! has message lines
		if e<>1 exit sub	                                                               
        read #ctlc,3,172;currdate;
		let cpikey$=" ",cpikey$
		let cpikey$[1,12]=pol.prodcode$[1,12]
		loopcpidc: ! 
		search #cpidc,3,2;cpikey$,rec_cpid,e
		if e<>0
			if lastrec<>0 goto getcpinote:
			exit sub
		endif
		if cpikey$[1,12]<>pol.prodcode$[1,12]
			if lastrec<>0 goto getcpinote:
			exit sub
		endif
		read record #cpidc,rec_cpid;cpid.;
		if cpid.purwhse<>pol.whse goto loopcpidc: ! 1. If the warehouse does not match
		! need to get the special price record
		Search #splc,2,2;cpikey$,rec_splc,e
		if e<>0 goto loopcpidc:
		read record #splc,rec_splc;sd.;
		if sd.CancelDate<>0
			if sd.CancelDate<currdate goto loopcpidc:! 2. If the cancel date is prior to po date
		endif
		if cpid.ResStock>0 !: 	  ! 3. If there is a reserve stock amount and it has been depleted, don't add it.
			let cnvtu[0]=sd.UMQty;cnvtu[1]=0;cnvtu[2]=1
			let cnvta=cpid.ResStock
			Amount=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)! need to convert ResStock from qtyum to base
			IF (AMOUNT-sd.QtySinceStart)<=0 goto loopcpidc:
		endif
		if lastdate<sd.StartDate
			let lastdate=sd.startdate
			let lastrec=rec_cpid
		endif
		goto loopcpidc:
		!
		getcpinote: ! 
		clear cpid.
		if lastrec>0
			let rec_cpid=lastrec
			read record #cpidc,rec_cpid;cpid.;
		endif
		if rtrim$(cpid.note1$)<>"" or rtrim$(cpid.note2$)<>"" or rtrim$(cpid.note3$)<>"" or rtrim$(cpid.note4$)<>""
			clear rtg.
			rtg.Status=Pol.Status
			rtg.OrdNum=pol.ponum
			rtg.LineNum=pol.itemno
			rtg.Blankforkey$=" "   
			rtg.JobNum$=" ",rtg.JobNum$ 
			rtg.PressNum$=" ",rtg.pressnum$  
			rtg.MSGLine1$=rtrim$(cpid.note1$)+Blank$
			rtg.MSGLine2$=rtrim$(cpid.note2$)+Blank$
			rtg.MSGS$=" ",rtg.MSGS$
			rtg.msgs$[1,30]=rtrim$(cpid.note3$)+Blank$
			rtg.msgs$[31,60]=rtrim$(cpid.note4$)+Blank$		
			rtg.Blankforkey$=" "
			let mode$="a"
			rec_tmp=fileupdatepoltag(e$,RTC,mode$,RTR,rtg.)
			if rec_tmp<0 ! problem
				returnstatus=0
				message$="Search Error "+Str$(X)+" updating poltag file"
			Endif	
		endif
	ELSE
		EXIT SUB
	end if
 else
    include "src/callsuberr.inc"
  end try
end sub ! CPIPrdPONotes







!------------------------------------------------
! begin sub for product search
Sub PRODSRCHDET()
Try
	Dim 1%,Pram[5],3%
 AVUM = pr.UMPurchDefault ! po 
Read Record #CCC,AVUM,0;UMC.;                                                            
SUM$ = UMC.Code$ ! for um field AND Available 
clear pram[]
let pram[2]=1 ! default to allowed
if pwr>0 ! we have a warehouse record	
	! prodgroup not used for po -- 
	if pw.ProdGrp > 0 ! not for normal scanning                     
 		Pram[0] = 0-(OType+1)  ! po's=0,1, 
		if p60$[46,46]="Y" and OTYPE>3 LET parm[0]=0-(OTYPE)
  		Pram[1] = pw.ProdGrp                                                    
  		Pram[5] = 0 ! file not opened                                           
  	!	![0]=Order or (-)PO Type                                                
  	!	! [1]=Product Group                                                     
  	!	! [2]=Allow on Ord/PO (1=y, 0=N)                                        
  	!	! [3]=Update Stock (1=y, 0=N)                                           
  	!	! [4]=On Price List (0/1)                                               
  	!	! [5]=Channel of 2/ProdGrp#                                             
  		Call ProdGroup(e$,IntCO,Pram[])                                         
  		If Pram[2] = 0                                                          
    			!If TScan = 1 Let RSProd = 1 Else Goto NxtKey ! not allowed on OType                                                         
  		End If                                                                  
	End If ! of prod group check                                              
                                                               
End If ! get whse   
! set up the line  
!                         

Let WebStr$ = RTrim$(PR.ProdCode$),fdel$                     ! product                                                                                                                                                              
WebStr$ = WebStr$,RTrim$(SUM$),fdel$,Str$(AVUM),fdel$ !  um &  umid
WebStr$ = WebStr$,RTrim$(pr.ComdtyCode$),fdel$  ! commodity code                                                                
WebStr$ = WebStr$,RTrim$(pr.Desc1$),fdel$  ! desc                                                                    
WebStr$ = WebStr$,RTrim$(pr.Desc2$),fdel$  ! desc 2                                                                           
If Whse Let QtyAvl = getwhavail(e$,IntCO,pwc,Prodkey$,Whse)
If Not(Whse) Let QtyAvl = getpravail(e$,IntCO,prc,Prodkey$)
let amount=0
if qtyavl<>0
	CNVTU[0] = 0 ! convert from rcd #, 0=base                         
	CNVTU[1] = AVUM ! from rcd#,convert um code to record #           
	CNVTU[2] = 1 ! 2= convert cost/price, 1=convert qty               
	CNVTA = QtyAvl                                                    
	Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,pr.)  
endif         
tmp$ = Amount Using QMask$                                        
 
                                                                                   
WebStr$ = WebStr$,LTrim$(tmp$),fdel$  ! avail                             
WebStr$ = WebStr$,RTrim$(SUM$),fdel$  ! availum                                
wEBSTR$=WEBSTR$,Str$(pr.PrimVend),FDEL$! VENDOR CODE -- field search   
umrec = avum                                               
factor = 0  
If umrec = -1 Let factor = -1 ! web wants umrec in factor    
If umrec = -3 Let factor = -3 ! for these                    
If umrec > 0 !   exit function Factor ! 0 ! no um - no factor
  If umrec = pr.BaseUM 
	Let factor = 1   
  else                     
  	If umrec = pr.UM2
		Let factor = pr.UM2Fact   
	else               
 	 	If umrec = pr.UM3 
			Let factor = pr.UM3Fact  
		else                
  			If umrec = pr.UM4 
				Let factor = pr.UM4Fact 
			else
			                 
  				If umrec = pr.UM5 Let factor = pr.UM5Fact                  
  				If umrec = pr.UM6 Let factor = pr.UM6Fact                  
  				If umrec = pr.UM7 Let factor = pr.UM7Fact                  
  				If umrec = pr.UM8 Let factor = pr.UM8Fact 
			endif
		endif
	endif
  endif                
End If                                                       
WebStr$ = WebStr$,Str$(factor),fdel$     ! umfactor            
! vendor minimum factors                                     
tmp$ = ""                                                    
If pr.UMvendord > 0                                          
  tmp$ = Xunit$(pr.UMvendord,CCC)                            
End If                                                       
WebStr$ = WebStr$,RTrim$(tmp$),fdel$ ! , Vend Ord UM           
WebStr$ = WebStr$,Str$(pr.UMvendord),fdel$  ! Vend ord UMid
umrec = pr.UMvendord                                               
factor = 0                                                         
If umrec = -1 Let factor = -1 ! web wants umrec in factor          
If umrec = -3 Let factor = -3 ! for these                          
If umrec > 0 !   exit function Factor ! 0 ! no um - no factor!     
	If umrec = pr.BaseUM 
		Let factor = 1  
	else                           
		If umrec = pr.UM2 
			Let factor = pr.UM2Fact  
		else
			If umrec = pr.UM3 
				Let factor = pr.UM3Fact 
			else
				If umrec = pr.UM4 
					Let factor = pr.UM4Fact  
				else		
					If umrec = pr.UM5 Let factor = pr.UM5Fact  
					If umrec = pr.UM6 Let factor = pr.UM6Fact  
					If umrec = pr.UM7 Let factor = pr.UM7Fact  
					If umrec = pr.UM8 Let factor = pr.UM8Fact   
				endif
			endif
		endif
	endif
endif  
WebStr$ = WebStr$,Str$(factor),fdel$  ! vend Ord Um Factor                                         
WebStr$ = WebStr$,UCase$(RTrim$(pr.VendItem$)),fdel$   !vend item
let tmp$="N"                                       
                                                     
 If P61$[111,111] = "Y" ! cpi sysflag                                                   
 	Call cpionhold(e$,IntCO,cpiflag,pr.ProdCode$,X2[3],tmp1$) 
	If cpiflag > 0 Let tmp$ = "Y"
endif
WebStr$ = WebStr$,tmp$,fdel$ ! can not order this prod  ! restrict
let tmp$="Y"
if pram[2]=0 let tmp$="N"
Webstr$=webstr$,tmp$,fdel$
VPList$[row] = WebStr$   

row = row + 1 \ If row > tmpcnt Let tmpcnt = expandarray(e$,VPList$[])      
e$ = ""                                                                   
If row > MaxCNT ! prevent basic error in libgeneral 1000 is PLENTY!!(40+p
                                                                          
  returnstatus = 0 ! send error?                                          
  e$ = "Please narrow down search!"                                       
  EXIT sub                                                           
End If                                                                    
 else
    include "src/callsuberr.inc"
end try                                                         






end sub ! prodsearch 
!--------------------------------------------------------------------
sub ChkBrokenQty()
! lines are being sent back to PM
! changed to 1 at a time (as user leaves line - save it!)
 Try
	DIM QTYUM$[4]
	
	Call DXGet("PRODID",tmp$) 
	npol.ProdCode$=rtrim$(UCase$(tmp$))+Blank$
	Prodkey$=" ",prodkey$
	prodkey$=npol.ProdCode$
	PRR=filegetprod(e$,PRC,"=",1,ProdKey$,pr.)
	If PRR<0 
		clear pr. 
		let returnstatus=0
		let message$="Product "+rtrim$(prodkey$)+" Not Found "
		goto endverifbroke:
	endif
	Call DXGet("QTYUM",tmp$) 
	R=getumrec(e$,CCC,tmp$,IntCo,PR.)
	If R<>0 let tmp$=Str$(R)
	IF R<0 !
		let message$="Invalid Quantity Unit of Measure"
		goto endverifbroke: ! end of line 
	endif
	let nPol.Qtyum=tmp$
	if npol.qtyum=pr.UMVendOrd
		returnstatus=1
		let message$="Same Unit of Measure "
		goto endverifbroke:
	endif
	call DXGet("QTYORD",tmp$) ! +Str$(X1),tmp$)
	let V3[4]=tmp$
	if not(v3[4])
		let returnstatus=1
		let message$="No Quantity Ordered "
		goto endverifbroke:
	endif
	! V3[4] = QTY ORDER
	CNVTU[0]=npol.qtyum;Cnvtu[1]=pr.UmVendOrd;Cnvtu[2]=1
	cnvta=V3[4] ! qty orders
	npol.QtyOrd=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	if not (fra(npol.qtyord))
		let returnstatus=1
		let message$="Purchase Qty Matching Vendor Qty "
		goto endverifbroke:
	endif
	returnstatus=2 ! means to provide user with option
	message$="Prompt User For Choices "
	cnvtu[0]=pr.UmVendOrd;cnvtu[1]=npol.qtyum;cnvtu[2]=1
	cnvta=int(npol.qtyord) ! decrease amount
	V3[5]=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	cnvtu[0]=pr.UmVendOrd;cnvtu[1]=npol.qtyum;cnvtu[2]=1
	cnvta=int(npol.qtyord)+1 ! INCREASE amount
	V3[6]=ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
	endverifbroke: ! 
	clear list$[]
    List$[0]=BSDEL$,"BROKENQTY",fdel$
	WebStr$="VendOrdUM",fdel$,"QtyUm",fdel$,"IncreaseQty",fdel$,"DecreaseQty",fdel$,"LeaveQty",fdel$ ! add more as needed
	List$[1]=webstr$
	let row=2
	if returnstatus=2
		QTYUM$=xunit$(pr.UmVendOrd,ccc) ! u/m 
		Webstr$=QTYUM$,FDEL$ ! Vendor Order Unit of Measure
		QTYUM$=xunit$(nPOL.QTYUM,ccc) ! u/m 
		Webstr$=webstr$,QTYUM$,FDEL$ ! Purchase Order Qty
		Webstr$=webstr$,str$(v3[6]),fdel$ ! Increase Quantity
		Webstr$=webstr$,str$(v3[5]),fdel$ ! Decrease Quantity
		Webstr$=webstr$,str$(v3[4]),fdel$ ! Leave Quantity	
		List$[row]=webstr$
		row=row+1
	endif
	!
	
	let list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string                          
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
 else
    include "src/callsuberr.inc"
 end try
end sub ! chkbrokeqty

!--------------------------------------------------------------------------------

sub dfltspolot(rec_pol)
try
	DIM dfltrcvloc$[6],spolotkey$[38]
	
	!Dim Dpol. as poline ! store new sent data
	dim 3%

	if rec_pol<=0 exit sub
	if not (rasl) exit sub
	if source<>371 exit sub
	Read Record #ch_pol,rec_pol,0;pol.; 
	if Sgn(fra(pol.flags / 2))<>0 exit sub      !! NONSTOCK CHECK                                                     
	If not(pol.UpdStock) exit sub!
	
	mat read #ctlc,69,52;dfltrcvloc$;
	dfltrcvloc$=dfltrcvloc$+Blank$ ! space fill it
	if dfltrcvloc$[1,6]=Blank$[1,6] let dfltrcvloc$="STOCK "
	If (DfltRcvLoc$[1,4]="DOOR" OR DfltRcvLoc$[1,3]="BAY")
	  If poh.WhseBay ! PO1[7] ! "only append # if there
		If DfltRcvLoc$[1,4]="DOOR" Let DfltRcvLoc$[5]=Str$(poh.WhseBay)+"  "
		If DfltRcvLoc$[1,3]="BAY" Let DfltRcvLoc$[4]=Str$(poh.WhseBay)+"   "
	  Endif
	Endif
    
	let spolotkey$=" ",spolotkey$
	let spolotkey$[1,6]=poh.PurchaseOrder Using "######"
	let spolotkey$[7,9]=pol.itemno Using "###"
	!let spolotkey$[10,21]=polot.lotnum$
	!let spolotkey$[22,31]=polot.stock$
	!let spolotkey$[32]=polot.loc$
	tmp_spolot=0
	lot_total=0
	mode$=">" ! search mode 3
	dir=1
spolot_loop: Rec_spolot=filegetspolot(e$,ch_polot,mode$,dir,spolotkey$,polot.)
	! libfilespolot.lib
	if rec_spolot>0 and polot.ponum=poh.PurchaseOrder and polot.LineNum=pol.itemno
		if polot.loc$ = DFLTRCVLOC$ then tmp_spolot=rec_spolot
		lot_total = lot_total + polot.QtyRcvd
		GOTO spolot_loop:
	endif
	E$=""
	if lot_total<>pol.currqtyrcvd
		! need to add to default receiving location
		if not(tmp_spolot)
			!call addspolot()
			polot.LotNum$=" ",polot.LotNum$
			polot.LotNum$[1,7]=pol.whse USING "STOCK&&"             
			polot.Stock$=" ",polot.Stock$	! POL1$[13,22] 
			if custom_customer$="ACTION"
				if ploc$[13,14]<>"  " if ploc$[13,13]<>""    
					let polot.Loc$=ploc$[13,18]+Blank$
				else 
					polot.Loc$=rtrim$(DFLTRCVLOC$)+Blank$	! POL1$[23,28] 
				Endif
			Else ! not custom
				polot.Loc$=rtrim$(DFLTRCVLOC$)+Blank$	! POL1$[23,28]
			Endif

			polot.ProdWO$=" ",polot.ProdWO$	! POL1$[29,34]  IF PWO   
			!polot.sOpen$[4]				! POL1$[35,38]  OPEN     
			polot.PoNum=poh.PurchaseOrder	! POL1[0]                
			polot.LineNum=pol.itemno		! POL1[1]                
			polot.Whse=pol.whse            ! POL1[2]                
			polot.QtyRcvd=0				  ! POL1[3]                
			polot.UM=pol.QtyUM				! POL1[4]                
			!polot.sOpen1$[32] 
			!KEY =     123456789012                                                                                                             
			!let spolotkey$=" ",spolotkey$
			!let spolotkey$[1,6]=poh.PurchaseOrder Using "######"
			!let spolotkey$[7,9]=pol.itemno Using "###"
			!let spolotkey$[10,21]=polot.lotnum$
			!let spolotkey$[22,31]=polot.stock$
			!let spolotkey$[32]=polot.loc$
			mode$="a" ! search mode ADD
			dir=1
			Rec_spolot=fileupdatespolot(e$,ch_polot,mode$,rec_spolot,polot.)
			if rec_spolot>=0
				write record #ch_polot,rec_spolot;polot.;
			endif
		endif
		if tmp_spolot then rec_spolot=tmp_spolot
		if rec_spolot>=0
			read record #ch_polot,rec_spolot;polot.
			polot.QtyRcvd=polot.QtyRcvd+(pol.currqtyrcvd-lot_total)
			write record #ch_polot,rec_spolot;polot.;
		endif
	endif
! delspolot  does all lines in spolot for pol line
!addspolot adds only the 1 record for default loc
	
else
    include "src/callsuberr.inc"
 end try
end sub  ! dflespolot
!--------------------------------------------------------------------------------

sub removesolink(SORDER,LNE,PONUM)
try
	DIM RMK$[10]
	RMK$=" ",RMK$
	RMK$[1,6]=SORDER USING "######"
	RMK$[7,9]=LNE USING "###"
	olr = filegetrolz(e$,olc,"=",1,RMK$,rol.)
	if olr >0
		read record #olc,olr,0;rol.
		if rol.ponum=PONUM
			ROL.PONUM = 0
			Write Record #olc,olr,0;rol.;
		endif
	endif
else
    include "src/callsuberr.inc"
 end try
end sub  ! removesolink  task 57698
!--------------------------------------------------------------------------------

