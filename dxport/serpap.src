!"serpap" === description  synergy erp Accounts Payable
!
!loadsave -w -n 100,10 -o prog/dxport/serpap.dl4 src/serpap.src 
!

External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus
Declare External Function openprinter

External Lib "libprodconv.lib"           
Declare External Function ConvProdAmount 

External Lib "ubsprconv.dl4"     
Declare External Function XUnit$ 
!
External Lib "libgeneralcode.lib"
Declare External Function ConvertDate
!
External Lib "ubsfunc.dl4"
Declare External Sub getportdefault,GetCostLevels,LogAccess
Declare External Function OpenFile,PDate$,FormatDate2$,chkbadchars
Declare External Function getuidrec,getuidinfo$,buildsort

External Lib "libprod.lib"
Declare External Sub ProdList,ProdGroup,UMDList
Declare External Function getpravail,getumrec,ChkPrdUM
external lib "libdroplist.lib"

External Lib "dxblockcustom.lib"
Declare External Sub blockPrintersDropList

External Lib "getglname.lib"        
Declare External Function getglname$

Declare Intrinsic Sub StringSearch
Declare Intrinsic Sub DateToJulian,FindF,JulianToDate,VerifyDate,CheckNumber,Time
Declare Intrinsic function findchannel
!
!
Declare sub OpenFiles
Declare sub VerifyVendor,VerifyAPTran
Declare sub StartDataEntry
Declare sub GetClient, GetAcctPer, AcperBatchList, GETAPBATCH, ExitApBatch, APBATCHREM,validatebatch
Declare sub APBATCHDELETE,oidelete,GetApVendDet,GetApVendPoList,GetApTransaction,getaptrans,aphdelete
Declare sub getapvendpo,GETPAYTOVEND
declare sub VerifyAPBatch
Declare sub GetApDiv,SubmitApDiv
Declare sub submitaptrans,deleteaptrans
Declare sub calcapdate,calctermdate
Declare sub getapgldist,submitapgldist
Declare sub verifypoid, verifycheckid
Declare sub DelOrgPOAlloc,DelPoAlloc
Declare sub GetAPPOLIST,getappohdr,getappotot,submitappotot,getappoline,submitappoline
Declare sub SetPRtoPol,calcextamt,findappoid,updapbthtot,findvendpo
! Subs for 511 Data Entry List
Declare Sub StartReport,start511report,start512report,StartPerEnd,start540report
Declare Sub GETDELAPTRANS,submitdelaptrans
Declare Sub GetdateApTrans,submitdateApTrans,relmanchk
! Subs for 514-516 Monthly Adjustments
Declare Sub start516report,start515report,getadjgldist,submitadjgldist,getadjtrans,submitadjtrans,deleteadjtrans
! Sub for 517-519 Recurring Entries

Declare Sub getretrans,submitretrans,deleteretrans,getregldist,submitregldist
Declare Sub start519report,start518report
! subs for 520 Invoice Release
Declare sub getvendaprel,aprelinv,getapflags,getapinvrel,getapselrel,vendpayhdr,vendaptranhdr,vendaptrandet
Declare sub submitaprelease,unreleaseap,APCHKREL
! subs for 522 Direct Disbursement Entry
Declare Sub getddtrans,submitddtrans,deleteddtrans,getddgldist,submitddgldist
Declare Sub start525report
Declare Sub StartChkRec,exitchkrec,getchkrectrans,submitchkrectrans
Declare Sub getvoidcheck,submitvoidcheck,factorum
Declare Function umtofactor
Declare sub startclosecntrl,getclosecntrl,submitclosecntrl

!****** includes ********
include "src/copyright.inc"
!
include "src/inc/filea80vm.inc" ! vendor file  vend.
include "src/inc/filevendtag.inc" ! vendor tag file 
include "src/inc/fileapa20oi.inc" ! ap open item file oi.
! a00ap
include "src/inc/fileapa10vl.inc" ! ap validation file apvl.
! acf 
include "src/inc/fileapcash.inc" ! ap bank - apcash.
include "src/inc/fileapdeta.inc" ! ap detail account  apda.
include "src/inc/fileapdeth.inc" ! ap detail header   apdh.
include "src/inc/fileapdetL.inc" ! ap detail lines  apdl.
include "src/inc/fileapdetm.inc" ! ap detail message line
include "src/inc/fileapa20di.inc" ! ap0di apdi.
include "src/inc/fileapbatch.inc" ! apbth
include "src/inc/fileapapdiv.inc" ! apdiv.
! for accounts payable po control
Include "src/inc/fileappoh.inc" ! appoh
Include "src/inc/fileappol.inc" ! appol
include "src/inc/filepohead.inc" ! po header	poh.
include "src/inc/filepoline.inc" ! po lines file pol.
Include "src/inc/filepomiscchrg.inc" ! po misc charge file misc.
include "src/inc/fileprod.inc" ! product	prod.
include "src/inc/filewhinfoz.inc" ! warehouse wh.
include "src/inc/fileccodesz.inc" ! u/m file! ccode - not needed
include "src/inc/filenstkdesc.inc" ! non stock file nstk.
include "src/inc/filepoctfle.inc" ! poctfle
include "src/inc/fileaprec.inc" ! aprec
include "src/inc/fileapred.inc" ! apred
include "src/inc/fileprtdefault.inc" ! port default prt
include "src/inc/fileapa10ad.inc" ! monthly adjustments gl distributions Distributions
include "src/inc/fileapa10aj.inc" ! month adjustments
include "src/inc/fileapam0do.inc" ! monthly purchase journal header
include "src/inc/fileapa50db.inc" ! direct disbursement entry
include "src/inc/fileapa50dd.inc" ! direct disbursement entry gl distributions
include "src/inc/fileapa50cr.inc" ! check rec
include "src/inc/fileapa10vc.inc" ! void check
include "src/inc/filevendbank.inc" ! vendor bank 
! for multicurrency
include "src/inc/filecurrency.inc" ! currency exchange file
include "src/inc/fileapdett.inc" ! ap detail tag file
	

!--------------------------------------------------------------------
!
!
! ** main procedure
!
OPTION GOSUB NESTING 16  ! Default is 8
try
  !
  dim 1%,cnvcu[10],3%,cnvca[10]
  Dim action$[30],options$[30],userid$[8],3%,fdel$[10],bsdel$[10],esdel$[10],rdel$[10]
  Dim rstr$[5000]
  Dim 2%,WHSE
  Dim 1%,IntCo
  Dim 3%,SPREC,rec_uac,updstatus
  dim 1%,ch_curr,keycurr$[30],3%,rec_curr,keyapdt$[30],3%,rec_apdt,apl5
  dim keysort$[50],vendname$[30]
  dim e$[500],buttonlist$[5,50],nextlist$[5,100] ! error handling variables
  dim Section$[30],Field$[20,30]
  dim mergedir$[60],action1$[20],action2$[30]
  dim Company$[2],keyvend$[10]
  dim xdate$[10],tmpdate$[20]
  dim tmpkey$[50],apR$[63]
  dim 1%,editstatus,source,acceptrts,remreqflag
  dim 1%,ua5[10]
  dim 1%,tmp1,intSls,CTLC,errflag,WH,Div,portnum,chan[25],flag
  dim 3%,spec[50],spec1[30]
  dim 2%,DAYS,TRANSDATE,CALCDATE
  dim 2%,tmp2,maxcnt \ maxcnt=2000 ! max records in arrays
  dim 3%,tmp3,JDepositDate,DocNo
  DIM 3%,parm[25],ORGTOT[10],miscdist
  dim 2%,vendid,vendid$[6]
  dim 2%,currdate
  dim 4%,tmp4,VALUE_RECV,WEIGHT_RECV,CUBES_RECV,QTY_RECV 
  Dim 1%,flags[11],FLAG,CNVTU[2],ERRTYPE
  dim 3%,qty,cost,amount,baseqty,cnvta
  dim 3%,totrcvdamt,totrcvdqty,totrcvdwgt,totrcvdcube
  dim 3%,totordamt,totordqty,totordwgt,totordcube
  dim 3%,lineqty,lineum,linecost,lineextamt,lbsunit,lbsfact                                        
  dim 3%,rec_tmp,rec_apc,rec_acf,ponum
  dim keyapc$[30],keyacf$[30],r2$[4],clientname$[40],currper$[5],nxtper$[5],2%,clientid,currper,nxtper,apdate
  Dim keybatch$[50],period$[4],z1$[220] ,keyoi$[50], keypoh$[50],keyappoh$[50]
  DIM KEYAPDH$[50],KEYDI$[50],KEYAPDA$[50],TRANSID$[12],keyapdh3$[50],keyvl$[50],CHKkey$[50],keycroi$[50]
  dim keyapdm$[50],1%,ch_apdm,3%,rec_apdm,apmsg$[50],apchkmsg$[50]
  dim 3%,rec_modo,keymodo$[50],fname$[50],g8$[2],groupid$[1]
  dim 1%,transtype,poglflag,dept,uncrflag,manchkflag
  dim 1%,achflag,3%,rec_vbnk,keyvbnk$[20]
  Dim 2%,acctper,c1,newbatch
  dim 3%,rec_oi,rec_apdh,rec_apda,rec_di,REC_POH,rec_vl,rec_appoh,rec_croi
  dim 3%,payamt,paydisc,paychk,totcred
  dim keyred$[50],keyrec$[50],3%,rec_aprec,rec_apred,rec_adg,keyadg$[50],keyadj$[50],rec_adj,keyadg2$[50]
  dim keydd$[50],keydb$[50],3%,rec_dd,rec_db
  dim WORK$[600]
  dim whlist$[100,100]
  dim p60$[50],p61$[256],P9$[50]
  dim List$[maxcnt,2000],sdate$[50]
  dim SList$[maxcnt,800] ! for .net selector(drop down) list
  dim logfname$[50],client$[40]
  dim SearKey$[64],BegKey$[64],mode$[3]
  dim Desc$[50],PayFlag$[1],RecType$[1],DocNo$[10],ARInvKey$[64],InvType$[3]
  dim tmp$[200],tmp1$[200],WebStr$[1000],Message$[5000],MSG$[500]
  dim blank$[200] \ blank$=" ",blank$
   DIM 1%,C0[8],spo,2%,e1  
                            
   Dim 1%,WPF[1023]
  Dim 1%,flags[11],zline,nonstock,closedshort
  Dim 2%,qtyumid,costumid
  Dim 3%,rec_pol,rec_poc,rec_appol
  Dim keypoc$[50],keypol$[50],keyappol$[50]
  dim 3%,prodfact,prodlbs,poqty,pocost,poextcost,prevqty,prevcost,prevextcost,currqty,currcost,currextcost
  dim 3%,lineqty,lineum,linecost,lineextamt,lbsunit,lbsfact
  ! product file
  Dim Prod$[12],KeyProd$[60]
  Dim 3%,rec_prod,rec_tmp,cntrlid,lineid
  dim 2%,lasteomdate,1%,apforce540,g9$[140]
 
  ! process flags
  dim 1%,wpf[1023],rtsflag,ch_tmp,foundpovend
  Dim 1%,cost_lev[4],2%,Q0[1]
  dim 3%,keytmp$[50],filename$[50],USR$[40]
  dim 3%,entnum,workqty,workcost,workcqty,postdate
  dim 3%,totappld,totporec,1%,aph3[4],3%,aph4[4]
  dim QMask$[20],PMask$[20],COSTUM$[4],QTYUM$[4],searchtype$[50]
  dim 2%,jduedate,jdiscdate,japduedate,japdiscdate,jtmpdate
  Dim 2%,divflag,div[1],bank,discflag,discountplus
  dim M3$[3] \ M3$="###"
  dim M10$[10] \ M10$="##########"
  dim 3%
  let tmp$=tim(4) using "&&&&&&"
  let work$=tmp$[5,6],tmp$[1,2],tmp$[3,4]
  let currdate=work$

! ------- Define Structures ------------
dim vend. as a80vm ! vend file vend.
dim vtag. as vendtag ! vendor tag file
dim oi. as apA20oi ! ap open item file oi.
! a00ap ! not needed
Dim apvl. as apa10vl !ap validation file apvl.
! acf  ! not needed
Dim apcash. as apcash ! ! ap bank - apcash.
Dim apda. as apdeta !  ap detail account  apda.
Dim apdh. as apdeth !  ap detail header   apdh.
Dim apdl. as apdetl !  ap detail Lines  apdl.
dim apdm. as apdetm !  ap detail message line
dim apdt. as apdett !  ap detail tag file
Dim apdi. as apa20di ! ap0di
Dim apbth. as apbatch! apbth
Dim apdiv. as apapdiv !  apdiv.
! ****** for accounts payable po control *********
Dim appoh. as appoh ! appoh
Dim appol. as appol ! appol
Dim poh. as pohead ! poh.
Dim pol. as poline ! po lines file pol.
Dim misc. as  pomiscchrg ! po misc charge file misc.
Dim pr. as prod ! product	prod.
Dim wh. as whinfo ! warehouse wh.
dim umc. as ccodes ! um codes file! ccode - not needed
dim nstk. as  nstkdesc
dim poc. as poctfle ! poctfle
dim prt. as prtdefault ! port defaults
dim red. as apred ! recurring entries
dim rec. as aprec ! recurring enttries distributions
dim adg. as apa10ad	
dim adj. as apa10aj
dim modo. as apam0do ! monthly purchase journal file
dim db. as apa50db ! direct disbursements
dim dd. as apa50dd ! direct disbursements gl dist
dim cr. as apa50cr ! check rec file
dim vc. as apa10vc ! void check file
dim vbnk. As Vendbank ! vendor bank file
dim curr. as currency ! multi currency


  Def FNR(H) = Int(Abs(H) * 100 + .5) * .01 * Sgn(H) ! rounding to nearest penny
  Def FNS(H) = Int(Abs(H) * 100) * .01 * Sgn(H) ! rounding to nearest penny
  !
  call dxopen()
  Call dxget("S_USER.AppID",tmp$) !company #               
                                                         
  Try Let intCo = Val(tmp$) Else Let intCo = 1 !company #  
  ctlc = OpenFile(9999,intCo) \ If ctlc = -1 Error 42 !control   ! openning with read/write
  call GetSession(e$,CTLC,options$,action$,UserID$,intCo,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$,action1$,action2$)
  call LogAccess(e$)
  call GetPortDefault(e$,IntCO,UserID$,portnum,rec_uac,prt.) ! get port default
  Call GetCostLevels(e$,cost_lev[],IntCo,Userid$) ! get cost security 
  Call dxsave(0,"/tmp/apmtg.txt!")
  mat read #ctlc,60,50;p60$; ! system flag variable
  mat read #ctlc,61,0;p61$;
  mat read #ctlc,19,50;p9$;                                                 
  Mat Read #ctlc,115,40;Q0; 
  MAT  READ #ctlc,51,18;C0; 
   MAT  READ #CTLC,51,76;SPO;
  mat read #ctlc,51,88;poglflag;
  mat read #ctlc,51,10;dept;
  mat read #ctlc,51,92;remreqflag;
!!! CO FLAGS	0-No 1=Yes
!C0[0] - MULTIPLE BANKS 
!c0[1] - TERM ATTRIBUTES		not used  
!C0[2] - AP ACCT DIST HIST       always 1 for Yes       1    
!C0[3] - AP BATCH MODE		always 1 for Yes       1    
!c0[4] - AP-PO INTERFACE            
!c0[5] - DISCOUNTABLE=GROSS              
!c0[6] - DIVISIONAL A/P       
!c0[7] - CREDIT TERM UPDATE     
!c0[8] - VENDOR BY BANK
  QMask$ = "-----------#.##"                                              
  tmp$ = "#",tmp$                                                         
  If Q0[1] <= 0 Let Q0[1] = 2                                             
  If Q0[1] Let PMask$ = "-----------#.",tmp$[1,Q0[1]] !price mask
  
  ! -- ap data entry batch status ---
	LET Z1$[1]="Entry in Process"    
	LET Z1$[21]="Entry Completed"    
	LET Z1$[41]="List in Process"    
	LET Z1$[61]="List Completed"     
	LET Z1$[81]="Journal in Process" 
	LET Z1$[101]="***error***"       
	LET Z1$[121]="Accepted & Closed" 
	LET Z1$[141]="***error***"       
	LET Z1$[161]="***error***"       
	LET Z1$[181]="DELETED"           
	LET Z1$[201]="***error***"       
  !
  call dxget("s_view.mergedir",mergedir$)
  
  !
  
  call OpenFiles()
         
  select case action$

  case "DROPLIST" !   send droplists 
    
  !================================= Begin Action Droplist ================================================
	
	  if action1$="APGLACCT"
		clear list$[]
		 Call filedroplistapa10vl(e$,List$[],maxcnt,ch_vl) 
		 call AddToStr(e$,rstr$,List$[])
	  endif!
	  if action1$="APCASH"
		Call filedroplistapcash(e$,List$[],maxcnt,ch_cash)
		 call AddToStr(e$,rstr$,List$[])
	  endif
	  IF ACTION1$="APDIVISION"
		Clear list$[]
		Call filedroplistapapdiv(e$,List$[],maxcnt,ch_apdiv)
		Call AddToStr(e$,rstr$,List$[])
	  Endif
	  if action1$="WHINFO"
		 call FileDropListWhinfoz(e$,whList$[],100,ch_wh)
		 call AddToStr(e$,rstr$,whList$[])
	  endif
	  if action1$="CURRENCY"
		clear list$[]
		 Call filedroplistcurrency(e$,List$[],maxcnt,ch_curr) 
		 call AddToStr(e$,rstr$,List$[])
	  endif!
	   If Action1$="UMDROPLIST" ! doc = mrts.produmdroplist.doc
		Call DXGet("PRODID",prod$) \ prod$=UCase$(prod$)
		Prod$=Prod$+Blank$ \ If Len(Prod$)>12 let Prod$[13]=""
		KeyProd$=Prod$
		Call DXGET("UTYPE",tmp$) ! tmp$=QTY, PRICE, COST
		rec_prod=filegetprod(e$,ch_prod,"=",1,KeyProd$,PR.) ! product mode=2 dir=1
		If rec_prod<0 ! Product record not found
			 clear PR.
			 ReturnStatus=0
			 Message$="Error, Product not found"
		else ! continue with list
			E$="" ! clear message
			if rtrim$(tmp$)="" let tmp$=" " ! is passed

			Call UMDList(e$,tmp$,ch_prod,rec_prod,List$[],IntCo,Pr.)
			Let ReturnStatus=1
			Message$="OK"
			If E$<>""
			   Let ReturnStatus=0
			   Message$=E$
			Endif
			call AddToStr(e$,rstr$,List$[])
			!Call AddToStr(e$,rstr$,esdel$) ! end of section 
		Endif ! valid prod
	  Endif ! action1=umdroplist
	 
	  
	 
          ! end droplist -- sent output
	  ! droplist for entries
	 
          call SetOutput(e$,rstr$)
Case "GETVEND" ! Gets info for ap entry
	RETURNSTATUS=1
	Message$="OK"
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	Call VerifyVendor()
	Call GetApVendDet()
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
	
!!! Start 510 - Data Entry Calls !!!!
Case "STARTDATAENTRY" ! sends over flags, defaults, droplist for divisions, banks, validation file
		ReturnStatus=1
		Message$="OK"
		Call dxsave(0,"/tmp/mtgstartdataentry.txt!")
		call startdataentry()
	!endif
Case "ACPERBATCHLIST" ! create of list of all the batches for an accounting period
	RETURNSTATUS=1
	Message$="OK"
	! Call dxsave(0,"/tmp/mtgacperbatchlist.txt!")
	call acperbatchlist()

Case "VERIFYAPBATCH"
	RETURNSTATUS=1
	Message$="OK"
	call VERIFYAPBATCH()

Case "GETAPBATCH"  ! gets data for an existing ap batch or creates a new ap batch
	RETURNSTATUS=1
	Message$="OK"
	Call dxsave(0,"/tmp/mtggetapbatch.txt!")
	call GETAPBATCH()

Case "EXITAPBATCH" ! Reset the in-process status of the batch
	RETURNSTATUS=1
	Message$="OK"
	call EXITAPBATCH()

Case "APBATCHREM" ! Updates the Batch Remarks
	RETURNSTATUS=1
	Message$="OK"
	call APBATCHREM()

Case "APBATCHDELETE" ! Deletes Transactions in the a/p batch
	RETURNSTATUS=1
	Message$="OK"
	call APBATCHDELETE()

Case "GETAPVEND" ! Gets info for ap entry
	Call dxsave(0,"/tmp/mtggetapvend.txt!")
	RETURNSTATUS=1
	Message$="OK"
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	Call VerifyVendor()
	let currid=0
	IF P61$[136,136]="Y"
		Call Dxget("CURRID",tmp$)
		let  currid=tmp$
		! IF NOT(CURRID) and vend.currid=517 let currid=517
		if currid<>vend.currid
			let returnstatus=0
			let message$="Vendor is assigned to another currency. "
		endif
	endif
	Call GetApVendDet()
	Call GetAPVendPoList()
	
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)

Case "GETAPTRANSACTION" ! Gets info for ap entry
	RETURNSTATUS=1
	Message$="OK"
	Call GetApTrans()

Case "SUBMITAPTRANSACTION" ! Updates Info for ap entry
	dim prevoi. as apA20oi ! ap open item file oi.
	RETURNSTATUS=1
	Message$="OK"
	Call SUBMITApTrans()

Case "DELETEAPTRANSACTION" ! Delete ap entry
	RETURNSTATUS=1
	Message$="OK"
	Call DeleteapTrans()
	
Case "CALCAPDATE"
	Returnstatus=1
	Message$="OK"
	Call CalcApDate()

Case "GETAPGLDIST"
	Returnstatus=1
	Message$="OK"
	Call getapgldist()
	
Case "SUBMITAPGLDIST"
	Returnstatus=1
	Message$="OK"
	Call submitapgldist()

Case "VERIFYPOID"     ! verify purchase order exists, received, etc
	Returnstatus=1
	Message$="OK"
	Call VERIFYPOID()

Case "VERIFYCHECKID"	! verify that the check has not already been issued to the vendor
	Returnstatus=1
	Message$="OK"
	Call VERIFYCHECKID()

Case "APPOLIST" ! list of purchase orders applied to an a/p transaction
	Returnstatus=1
	Message$="OK"
	Call GETAPPOLIST()

Case "DELORGPOALLOC" ! deletes the original po allocation when po# has been changed
	Returnstatus=1
	Message$="OK"
	Call DelOrgPoAlloc()

Case "DELPOALLOC" ! deletes the po allocation for an a/p transaction -- for all or for 1
	Returnstatus=1
	Message$="OK"
	call DELPOALLOC()


Case "GETAPPOHDR" ! get the purchase order header screen
	Returnstatus=1
	message$="OK"
	call GetAppohdr()

Case "GETAPPOTOT" ! get the purchase order header screen
	Returnstatus=1
	message$="OK"
	call GetAppotot()


Case "SUBMITAPPOTOT" ! get the purchase order header screen
	Returnstatus=1
	message$="OK"
	call SubmitAppotot()

Case "GETAPPOLINE" ! get the purchase order header screen
	Returnstatus=1
	message$="OK"
	call GetAppoline()

Case "SUBMITAPPOLINE" ! get the purchase order header screen
	Returnstatus=1
	message$="OK"
	call SubmitAppoline()
	
!!! End 510 - Data Entry Calls !!!!
!!! 511 - Data Entry List
Case "STARTREPORT" ! sends over flags, defaults, client name and accounting period
		ReturnStatus=1
		Message$="OK"
		call startreport()

Case "STARTPEREND" ! 540 End of Month/End of Year
	ReturnStatus=1
	Message$="OK"
	call startperend()

Case "ENDPER540" ! 540  ! End of Month/End of Year
	RETURNSTATUS=1
	MESSAGE$="OK"
	!Call dxsave(0,"/tmp/540eop.txt!")
	call start540report()
	!endif
Case "ENTRYLIST511"
	RETURNSTATUS=1
	MESSAGE$="OK"
	call start511report()

Case "PURCHJRNL512"
	RETURNSTATUS=1
	MESSAGE$="OK"

	call start512report()

!!! Start 513 - Data Entry Calls !!!!
Case "STARTDELOPEN" ! sends over flags, defaults, droplist for divisions, banks, validation file
		ReturnStatus=1
		Message$="OK"
		call startdATAENTRY()

Case "GETDELAPTRANS"
		ReturnStatus=1
		Message$="OK"
		call getdelaptrans()
	
Case "SUBMITDELAPTRAN" 
		ReturnStatus=1
		Message$="OK"
		call submitdelaptrans()
! Monthly Adjustments
! 514 Monthly Adjustment Entry
Case "GETADJTRANSACTION" ! Gets info for recurring Entry
	ch_adj=OpenFile(9811,intCo) \ If Ch_adj = -1 Error 42! 
	ch_adg=OpenFile(9812,intCo) \ If ch_adg = -1 Error 42! 
	
	RETURNSTATUS=1
	Message$="OK"
	Call GetAdjTrans()

Case "SUBMITADJTRANSACTION" ! Updates Info for ap entry
	ch_adj=OpenFile(9811,intCo) \ If Ch_adj = -1 Error 42! 
	ch_adg=OpenFile(9812,intCo) \ If ch_adg = -1 Error 42! 
	RETURNSTATUS=1
	Message$="OK"
	Call SUBMITADJTrans()

Case "DELETEADJTRANSACTION" ! Delete ap transtion
	ch_adj=OpenFile(9811,intCo) \ If Ch_adj = -1 Error 42! 
	ch_adg=OpenFile(9812,intCo) \ If ch_adg = -1 Error 42! 
	Returnstatus=1
	Message$="OK"
	Call DeleteAdjTrans()

Case "GETADJGLDIST"
	ch_adj=OpenFile(9811,intCo) \ If Ch_adj = -1 Error 42! 
	ch_adg=OpenFile(9812,intCo) \ If ch_adg = -1 Error 42! 
	
	Returnstatus=1
	Message$="OK"
	Call getadjgldist()
	
Case "SUBMITADJGLDIST"
	ch_adj=OpenFile(9811,intCo) \ If Ch_adj = -1 Error 42! 
	ch_adg=OpenFile(9812,intCo) \ If ch_adg = -1 Error 42! 
	! Call dxsave(0,"/tmp/subadjgldist.txt!")
                                  
	
	Returnstatus=1
	Message$="OK"
	Call submitadjgldist()


Case "ADJLIST515"		! 
	RETURNSTATUS=1
	MESSAGE$="OK"
	call start515report()

Case "ADJJRNL516"		! 
	RETURNSTATUS=1
	MESSAGE$="OK"
	call start516report()


! Recurring Entries
! 517 Recurring Entry Entry
Case "GETREVEND" ! Gets info for ap entry
	ch_aprec=OpenFile(9809,intCo) \ If Ch_aprec = -1 Error 42! 
	ch_apred=OpenFile(9810,intCo) \ If Ch_apred = -1 Error 42! 
	RETURNSTATUS=1
	Message$="OK"
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	Call VerifyVendor()
	Call GetApVendDet()
	!Call GetVendREList()
	
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)

Case "CHKAPDIV" ! check if ap division is available
	RETURNSTATUS=1
	Message$="OK"
	if c0[6]=0
		let returnstatus=0
		let message$="Accounts Payable Division Option is Not Available"
	endif
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)

Case "GETAPDIV"
	Call GetApDiv()
	
Case  "SUBMITAPDIV"
	Call SubmitApDiv()

Case "GETRETRANSACTION" ! Gets info for recurring Entry
	ch_aprec=OpenFile(9809,intCo) \ If Ch_aprec = -1 Error 42! 
	ch_apred=OpenFile(9810,intCo) \ If Ch_apred = -1 Error 42! 
	RETURNSTATUS=1
	Message$="OK"
	Call GetReTrans()

Case "SUBMITRETRANSACTION" ! Updates Info for Recurring entry
	ch_aprec=OpenFile(9809,intCo) \ If Ch_aprec = -1 Error 42! 
	ch_apred=OpenFile(9810,intCo) \ If Ch_apred = -1 Error 42! 
	RETURNSTATUS=1
	Message$="OK"
	Call SUBMITRETrans()

Case "DELETERETRANSACTION" ! Delete ap entry
	ch_aprec=OpenFile(9809,intCo) \ If Ch_aprec = -1 Error 42! 
	ch_apred=OpenFile(9810,intCo) \ If Ch_apred = -1 Error 42! 
	RETURNSTATUS=1
	Message$="OK"
	Call DeleteRETrans()
	
Case "GETREGLDIST"
	ch_aprec=OpenFile(9809,intCo) \ If Ch_aprec = -1 Error 42! 
	ch_apred=OpenFile(9810,intCo) \ If Ch_apred = -1 Error 42! 
	Returnstatus=1
	Message$="OK"
	Call getregldist()
	
Case "SUBMITREGLDIST"
	ch_aprec=OpenFile(9809,intCo) \ If Ch_aprec = -1 Error 42! 
	ch_apred=OpenFile(9810,intCo) \ If Ch_apred = -1 Error 42! 
	Returnstatus=1
	Message$="OK"
	Call submitregldist()

!!! 518 Recurring Entry List
Case "RECURENTLIST518"
	RETURNSTATUS=1
	MESSAGE$="OK"
	call start518report()
!!! 519 Recurring Entry Journal
Case "RECURENTJRNL519"
	RETURNSTATUS=1
	MESSAGE$="OK"
	call start519report()

! 542 -- Due Date Edit
Case "GETDATEAPTRANS"
	ReturnStatus=1
	Message$="OK"
	call getdateaptrans()

Case "SUBMITDATEAPTRANS" 
	ReturnStatus=1
	Message$="OK"
	call submitdateaptrans()

!!! 520 - Invoice Release
Case "GETAPFLAGS"
	Returnstatus=1
	message$="OK"
	call GetAPFlags()

Case "APTRANRELEASE"  ! 520 Invoice Release -- Auto Release -- Option 1 & 2
	dim croi. as apa20oi
	Returnstatus=1
	message$="OK"
	call GetAPInvRel()

Case "APTRANSELREL" ! 520 Invoice Release - Selective Release -- Option 4
	returnstatus=1
	message$="OK"
	call GetApSelRel()

Case "GETVENDAPREL" ! get vendor detail - opt 4 - for individual vendor, opt 3 -release specific , opt 2 -exception
	dim croi. as apa20oi
	Returnstatus=1
	message$="OK"
	call GetVendApRel()

Case "SUBMITAPRELEASE"
	REturnstatus=1
	message$="OK"
	call SUBMITAPRELEASE()

Case "RELMANCHK"
	REturnstatus=1
	message$="OK"
	call RELMANCHK()
	
Case "UNRELEASEAP"
	dim 1%,manchkflag
	REturnstatus=1
	message$="OK"
	CALL DXGET("MANUALCHKONLY",TMP$)
	manchkflag=0
	if ucase$(rtrim$(tmp$))="Y" let manchkflag=99
	let divflag=0;div[0]=0;div[1]=99 
	if c0[6] ! divisional
		Call dxget("DIVRELEASE",tmp$)
		if UCASE$(rtrim$(tmp$))="Y" let divflag=99
		if divflag<>0
			Call dxget("STARTDIV",tmp$)
			let div[0]=tmp$
			if div[0]<0 or div[0]>99
				let returnstatus=0
				let message$="Invalid Starting Division Submitted"
			endif
			Call dxget("ENDDIV",tmp$)
			let div[1]=tmp$
			if div[1]<0 or div[1]>99
				let returnstatus=0
				let message$="Invalid Ending Division Submitted"
			endif
			if div[1]<div[0]
				let returnstatus=0
				let message$="Ending Division Must Be Greater Than Starting Division"
	 		endif
		endif
	Endif
	bankflag=0;bank=0
	if c0[8] ! vendor by bank
		bankflag=99
		Call dxget("BANK",tmp$)
		LET BANK=TMP$
		IF NOT(BANK)
			let returnstatus=0
			let message$="Invalid Bank Number Submitted"
		ENDIF
	ENDIF
	IF RETURNSTATUS>0
		clear chan[]
		chan[0]=ctlc
		chan[1]=ch_oi
		chan[2]=ch_vend
		Chan[3]=ch_apdh
		Chan[4]=ch_cash
		Call "la520e.dl4",CHAN[],manchkflag,divflag,div[],bank,returnstatus,Message$,IntCo,rstr$,e$
	ENDIF
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)

! 523 Direct Disbursement Entry
Case "STARTDDPROC" ! Gets info for ap entry
	RETURNSTATUS=1
	Message$="OK"
	Keyapc$ = "20"                                 
	Search #ch_apc,2,1;Keyapc$,Rec_apc,e           
	If e > 0                                       
		ReturnStatus = 0                             
		Message$ = "RECORD '20' NOT FOUND IN A00AP"  
		Goto endstartddproc                          
	End If                                         
	Mat Read #ch_apc,Rec_apc,10;apR$;              
	If apR$[3,3] <> "0"                            
		ReturnStatus = 0                             
		Message$ = "CHECK REGISTER MUST BE ACCEPTED" 
		Goto endstartddproc                          
	End If                                         
	endstartddproc: ! 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
!
Case "GETDDVEND" ! Gets info for ap entry
	RETURNSTATUS=1
	Message$="OK"
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	Call VerifyVendor()
	clear list$[]
	List$[0]=bsdel$,"VendorInfo",fdel$
	WebStr$="VendId",fdel$,"Name",fdel$
	Webstr$=Webstr$,"Addr1",fdel$
	Webstr$=Webstr$,"Addr2",fdel$
	Webstr$=webstr$,"City",fdel$
	Webstr$=webstr$,"State",fdel$
	webstr$=webstr$,"Zip",fdel$
        List$[1]=WebStr$
	row=2   
	if returnstatus<>0
		webstr$=""
		webstr$=str$(vend.VendorCode),fdel$
		webstr$=webstr$,rtrim$(vend.PayToName$),fdel$
		webstr$=webstr$,rtrim$(vend.PayToAddress$),fdel$
		webstr$=webstr$,rtrim$(vend.PayToOptAddress$),fdel$
		webstr$=webstr$,rtrim$(vend.paytocity$),fdel$
		webstr$=webstr$,rtrim$(vend.paytostate$),fdel$
		webstr$=webstr$,rtrim$(vend.paytozip$),fdel$
		list$[row]=webstr$
		row=row+1
	endif
	list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])
	
	
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)


Case "GETDDTRANSACTION" ! Gets info for recurring Entry
	ch_db=OpenFile(9813,intCo) \ If Ch_db = -1 Error 42! 
	ch_dd=OpenFile(9814,intCo) \ If Ch_dd = -1 Error 42! 
	RETURNSTATUS=1
	Message$="OK"
	Call GetDDTrans()

Case "SUBMITDDTRANSACTION" ! Updates Info for Recurring entry
	ch_db=OpenFile(9813,intCo) \ If ch_db = -1 Error 42! 
	ch_dd=OpenFile(9814,intCo) \ If ch_dd = -1 Error 42!  
	RETURNSTATUS=1
	Message$="OK"
	Call SUBMITDDTrans()

Case "DELETEDDTRANSACTION" ! Delete ap entry
	ch_db=OpenFile(9813,intCo) \ If ch_db = -1 Error 42! 
	ch_dd=OpenFile(9814,intCo) \ If ch_dd = -1 Error 42! 
	RETURNSTATUS=1
	Message$="OK"
	Call DeleteDDTrans()
	
Case "GETDDGLDIST"
	ch_db=OpenFile(9813,intCo) \ If ch_db = -1 Error 42! 
	ch_dd=OpenFile(9814,intCo) \ If ch_dd = -1 Error 42! 
	Returnstatus=1
	Message$="OK"
	Call getddgldist()
	
Case "SUBMITDDGLDIST"
	ch_db=OpenFile(9813,intCo) \ If ch_db = -1 Error 42! 
	ch_dd=OpenFile(9814,intCo) \ If ch_dd = -1 Error 42! 
	Returnstatus=1
	Message$="OK"
	Call submitddgldist()
! end 522

Case "CHECKREG525"
	RETURNSTATUS=1
	MESSAGE$="OK"
	call start525report()


Case "STARTCHKREC" ! sends over flags, droplist for divisions
		ReturnStatus=1
		Message$="OK"
		call startchkrec()
Case "GETCHKRECTRANS" ! Gets info for check rec
	ch_cr=OpenFile(9815,intCo) \ If ch_cr = -1 Error 42! 
	RETURNSTATUS=1
	Message$="OK"
	Call GetChkRecTrans()

Case "SUBMITCHKRECTRANS" ! Updates Info for ap entry
	ch_cr=OpenFile(9815,intCo) \ If ch_cr = -1 Error 42
	RETURNSTATUS=1
	Message$="OK"
	Call SUBMITChkRecTrans()


Case "EXITCHKREC" ! sends over flags, droplist for divisions
		ReturnStatus=1
		Message$="OK"
		call exitchkrec()


Case "GETVOIDCHECK" ! Gets info for recurring Entry
	ch_cr=OpenFile(9815,intCo) \ If ch_cr = -1 Error 42! 
	ch_vc=OpenFile(9816,intCo) \ if ch_vc = -1 Error 42
	ch_apdl=OpenFile(448,intCo) \ if ch_apdl= -1 Error 42
	RETURNSTATUS=1
	Message$="OK"
	Call GetVoidCheck()

Case "SUBMITVOIDCHECK" ! Updates Info for ap entry
	ch_cr=OpenFile(9815,intCo) \ If ch_cr = -1 Error 42
	ch_vc=OpenFile(9816,intCo) \ if ch_vc = -1 Error 42
	RETURNSTATUS=1
	Message$="OK"
	Call SUBMITVoidCheck()

Case "STARTCLOSECNTRL" ! sends over flags, warehouse list
		ReturnStatus=1
		Message$="OK"
		call startclosecntrl()

Case "GETCLOSECNTRL" ! 
		Mat Read #ctlc,51,88;poglflag;
		if poglflag<>0
			ch_cch=OpenFile(9817,intCo) \ If ch_cch = -1 Error 42
			ch_ccd=OpenFile(9818,intCo) \ if ch_ccd = -1 Error 42
		endif
		ReturnStatus=1
		Message$="OK"
		call getclosecntrl()

Case "SUBMITCLOSECNTRL" ! 
		Mat Read #ctlc,51,88;poglflag;
		if poglflag<>0
			ch_cch=OpenFile(9817,intCo) \ If ch_cch = -1 Error 42
			ch_ccd=OpenFile(9818,intCo) \ if ch_ccd = -1 Error 42
		endif
		ReturnStatus=1
		Message$="OK"
		call submitclosecntrl()

Case "GETAPVENDPO"
	let returnstatus=1
	Message$="OK"
	Call dxsave(0,"/tmp/mtggetapvendpo.txt!")
	call getapvendpo()

! next case

end select

  ! call dxclose()
else
  include "src/callmainerrnet.inc"
  call dxclose()
end try
end

!--------------------------------------------------------------------
sub OpenFiles()
  
  Try
    !
    Ch_Vend = OpenFile(2400,intCo) \ If Ch_Vend = -1 Error 42  ! vend
    ch_vtag=OpenFile(1120,intCo) \ If Ch_vtag = -1 Error 42 ! vemdtag
    ch_oi=OpenFile( 9801,intCo) \ If Ch_oi = -1 Error 42 ! open item file
    ch_apc=OpenFile( 16,intCo) \ If Ch_apc = -1 Error 42 ! ap control file
    ch_vl=OpenFile( 32,intCo) \ If Ch_vl = -1 Error 42 ! ap /gl validation file  
    ch_acf=OpenFile(48,intCo) \ If Ch_acf = -1 Error 42 ! acf file 
    ch_cash=OpenFile(112,intCo) \ If Ch_cash = -1 Error 42 ! ap cash file
    ch_apda=OpenFile(144,intCo) \ If Ch_apda = -1 Error 42 ! ap detail gl acct file
    ch_apdh=OpenFile(432,intCo) \ If Ch_apdh = -1 Error 42 ! ap detail header file 
	ch_apdm=OpenFile(9820,intCo) \ If Ch_apdm = -1 Error 42 ! ap detail header file
    ch_di=OpenFile(9806,intCo) \ If Ch_di = -1 Error 42 ! ap dist file    
    ch_bth=OpenFile(9804,intCo) \ If Ch_bth = -1 Error 42 ! ap batch file      
    ch_apdiv=OpenFile(9805,intCo) \ If Ch_apdiv = -1 Error 42 
    IF C0[4]<>0 and SPO<>0 ! purchase order interface is on                                        
	ch_appoh=OpenFile(9802,intCo) \ If Ch_appoh = -1 Error 42! 
	ch_appol=OpenFile(9803,intCo) \ If Ch_appol = -1 Error 42!  
	ch_poh = OpenFile(2416,intCo) \ If ch_poh = -1 Error 42 !"po header file 
	Ch_Pol = OpenFile(2432,intCo) \ If Ch_Pol = -1 Error 42 !"po lines file  
	ch_misc = OpenFile(-9949,intCo) \ If ch_misc = -1 Error 42 !po misc charge              
	Ch_Prod = OpenFile(1792,intCo) \ If Ch_Prod = -1 Error 42  !product file 
	Ch_Wh = OpenFile(2768,intCo) \ If Ch_Wh = -1 Error 42  !" warehouse file
	Ch_Ccode = OpenFile(-1728,intCo) \ If Ch_Ccode = -1 Error 42  !u/m codes file
	ch_nstk = OpenFile(2448,intCo) \ If ch_nstk = -1 Error 42 ! nonstock p
    ch_poc=OpenFile(9944,intCo) \ If Ch_poc = -1 Error 42! 
	ch_curr=OpenFile(9712,intCo) \ If Ch_curr = -1 Error 42! 
	ch_apdt=OpenFile(9821,intCo) \ If Ch_apdt = -1 Error 42! 
   ENDIF                                             
   else
    include "src/callsuberr.inc"
  end try
end sub ! openfiles

! ------------------------------------------------------------------------
Sub VerifyVendor() 

try
	  keyvend$=" ",keyvend$
	  keyvend$=vendid using "######"
	  mode$="=" ! search mode 2
	  dir=1
	  clear vend.
	  Rec_vend=filegeta80vm(e$,ch_vend,mode$,dir,keyvend$,vend.)
	  if rec_vend<0
		let returnstatus=0
		let message$="Vendor "+str$(vendid)+" Not On File. "
	  endif
	  if returnstatus>0
		keyvend$=" ",keyvend$
		keyvend$=vendid using "######"
		mode$="=" ! search mode 2
		dir=1
		clear vtag.
		Rec_vtag=filegetvendtag(e$,ch_vtag,mode$,dir,keyvend$,vtag.)
		if rec_vtag<0
			let returnstatus=0
			let message$="Vendor "+str$(vendid)+" Not In Tag File . "
		endif	
	  endif
		
else
	! this is a remark
end try
end sub ! Verify Vendor  


! 
! ------------------------------------------------------------------------
Sub GetAPVendDet() 
! 
try
	DIM VUDAN$[56]
	clear list$[]
	List$[0]=bsdel$,"VendorInfo",fdel$
	WebStr$="VendId",fdel$,"VendName",fdel$,"TermsDesc",fdel$
	Webstr$=Webstr$,"TermsPct",fdel$,"PayVendId",fdel$,"PayVendName",fdel$,"PayAddr1",fdel$
	Webstr$=Webstr$,"PayAddr2",fdel$,"PayAddr3",fdel$,"VerifyPO",fdel$,"CalcTermDate",fdel$
        List$[1]=WebStr$
	row=2   
	if returnstatus<>0
		webstr$=""
		webstr$=str$(vend.VendorCode),fdel$
		webstr$=webstr$,rtrim$(vend.Name$),fdel$
		webstr$=webstr$,rtrim$(vend.TermsAlpha$),fdel$
		webstr$=webstr$,(vend.Terms using "##.##"),fdel$
		if not(vend.paytovendorcode) let vend.paytovendorcode=vend.vendorcode
		if vend.paytovendorcode<>vend.vendorcode
			call getpaytovend ()
		endif
		webstr$=webstr$,str$(vend.paytovendorcode),fdel$
		webstr$=webstr$,rtrim$(vend.PayToName$),fdel$
		webstr$=webstr$,rtrim$(vend.PayToAddress$),fdel$
		if rtrim$(vend.PayToOptAddress$)<>""
			webstr$=webstr$,rtrim$(vend.PayToOptAddress$),fdel$
			let tmp$=""
			let tmp$=rtrim$(vend.paytocity$)+" "+rtrim$(vend.paytostate$)," "+rtrim$(vend.paytozip$)
			webstr$=webstr$,rtrim$(tmp$),fdel$
		else
			let tmp$=""
			let tmp$=rtrim$(vend.paytocity$)+" "+rtrim$(vend.paytostate$)," "+rtrim$(vend.paytozip$)
			webstr$=webstr$,rtrim$(tmp$),fdel$
			let tmp$=""
			webstr$=webstr$,tmp$,fdel$
		endif
		let tmp$="Y"
		if vtag.allowpos=0 let tmp$="N"
		if not(CO[4]) LET TMP$="N"
		If not(SPO) let tmp$="N"
		webstr$=webstr$,tmp$,fdel$
		! calc term date
		let tmp$="N"
		!IF P9$[20,20]="F" ! fine paper package
			MAT READ #CTLC,67,56;VUDAN$;
			IF UCASE$(RTRIM$(VUDAN$[43,56]))="PROX TERMS"
				if vtag.uda4>0 and vtag.uda4<20 let tmp$="Y"! find if prox terms exists
			endif
		!endif
		webstr$=webstr$,tmp$,fdel$
		list$[row]=webstr$
		row=row+1
	endif
	list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])
else
	! this is a remark
end try
end sub ! getapvenddet
! 
! ------------------------------------------------------------------------
Sub GetAPVendPolist() 
! 
try
	 Call dxsave(0,"/tmp/appomtg.txt!")
	clear list$[]
	Call Dxget("TRANSTYPE",tmp$)
	let transtype=0
	if ucase$(rtrim$(Tmp$))="INV" let transtype=1
	if ucase$(rtrim$(Tmp$))="C/M" let transtype=2
	if ucase$(rtrim$(Tmp$))="M/C" let transtype=3
	List$[0]=bsdel$,"APVendPoList",fdel$
	WebStr$="ID",fdel$,"Type",fdel$,"Rcvd Date",fdel$,"VendRef",fdel$,"Amount",fdel$
	List$[1]=WebStr$
	row=2
	let tmpcnt=maxcnt
	if returnstatus<>0 and c0[4]<>0 ! APOFLAG=Y
		let keypoh$=" ",keypoh$
		let keypoh$[1,6]=vend.vendorcode using "######"
		do
			search #ch_poh,3,2;keypoh$,rec_poh,e
			if e<>0 exit do
			let tmp3=keypoh$[1,6]
			if tmp3<>vend.vendorcode exit do
			read record #ch_poh,rec_poh;poh.;
			IF P61$[136,136]="Y" and currid<>0
				if poh.currid<>currid goto nextvendpotran:
			endif
			if poh.ClosedAp=0 and poh.LastRtsDate<>0 and poh.TotPoRcvd<>0
				if transtype<>0
					if transtype=2 ! credit memo
						if poh.status<10 goto nextvendpotran:
						if poh.status>14 goto nextvendpotran:
					else
						if poh.status>9 goto nextvendpotran:
					endif
				endif
				webstr$=str$(poh.PurchaseOrder),fdel$
				let tmp$="PO"
				if poh.status>10 and poh.status<15
					let tmp$="DM"
				endif
				webstr$=webstr$,tmp$,fdel$
				If poh.LastRtsDate <> 0                
					 xdate$ = pdate$(poh.LastRtsDate)     
				Else                                  
					 xdate$ = "01/01/1900"               
				End If                                
				WebStr$ = WebStr$,RTrim$(xdate$),fdel$
				webstr$ = webstr$,rtrim$(poh.VendorRef$),fdel$
				let amount = poh.TotPoRcvd
				if p61$[136,136]="Y" and poh.currfact<>0 and amount<>0  ! going for base to costing um
					let cnvcu[0]=1
					let cnvca[0]=amount
					let cnvca[1]=poh.currfact
					let CNVCU[1]=1 ! no rounding
					call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
					let amount=fnr(cnvca[0])
				endif
				webstr$= webstr$,(amount using "#######.##"),fdel$ ! poh.TotPoRcvd
				LIST$[ROW]=WEBSTR$
				row = row + 1                                        
				If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
				nextvendpotran: ! get the next vendor po transaction
			endif
			
		Loop                                                 
	endif
	list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])
else
	! this is a remark
end try
end sub ! getapvendpolist
! 
!--------------------------------------------------------------------------------------------------------
Function UMtoFactor(UMRec)
! from sent um # - get um factor for it
! if no match - send factor back as one (base?)
 Try
	
	dim 3%,factor
	let factor=0
	if umrec<=0 exit function 0 ! no um - no factor!
	If umrec=Pr.BaseUM let factor=1
	if umrec=PR.UM2 let factor=pr.UM2Fact
	if umrec=PR.UM3 let factor=pr.UM3Fact
	if umrec=PR.UM4 let factor=pr.UM4Fact
	if umrec=PR.UM5 let factor=pr.UM5Fact
	if umrec=PR.UM6 let factor=pr.UM6Fact
	if umrec=PR.UM7 let factor=pr.UM7Fact
	if umrec=PR.UM8 let factor=pr.UM8Fact
	
 else
    include "src/callsuberr.inc"
  end try
end Function Factor ! umtofactor
! 
!--------------------------------------------------------------------
Sub StartDataEntry()! send droplist and flags for data entry screen
 Try
	ReturnStatus=1
	Message$="OK"
	Call GetAcctPer()
	clear list$[]
	List$[0]=bsdel$,"AccountPeriod",fdel$
	WebStr$="Name",fdel$,"Period",fdel$
	list$[1]=webstr$
	Webstr$="Current Month",fdel$,currper$[1,5],fdel$
	list$[2]=webstr$
	Webstr$="Next Month",fdel$,nxtper$[1,5],fdel$
	list$[3]=webstr$
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	! filedroplistapcash
	Clear list$[]
	Call filedroplistapcash(e$,List$[],maxcnt,ch_cash)  
	Call AddToStr(e$,rstr$,List$[])
	! get ap division
	Clear list$[]
	! check if division flag is on
	IF C0[6]<>0
		Call filedroplistapapdiv(e$,List$[],maxcnt,ch_apdiv)
		if rtrim$(list$[2])=esdel$
			let returnstatus=0
			let message$="No AP Divisions Has Been Set-UP "
		endif
	else
		List$[0]=bsdel$,"droplistapapdiv",fdel$
		List$[1]="ID",fdel$,"DivName",fdel$
		List$[2]="0",fdel$,"None",fdel$
		list$[3]=esdel$
	endif
	Call AddToStr(e$,rstr$,List$[])
	! get ap validation
	Clear list$[]
	Call filedroplistapa10vl(e$,List$[],maxcnt,ch_vl) 
	if rtrim$(list$[2])=esdel$
			let returnstatus=0
			let message$="No GL Accounts Has Been Set-Up In Validation File "
		endif
	Call AddToStr(e$,rstr$,List$[])
	! get control flags
	Call GetClient()
	Clear List$[]
	List$[0]=bsdel$,"APControl",fdel$
	Webstr$=""
	webstr$="ClientId",fdel$
	webstr$=webstr$,"ClientName",fdel$
	webstr$=webstr$,"APPOFlag",fdel$
	webstr$=webstr$,"DivFlag",fdel$
	webstr$=webstr$,"DefaultDiv",fdel$
	webstr$=webstr$,"RemarkReqFlag",fdel$
	webstr$=webstr$,"MultiCurrency",fdel$
	List$[1]=webstr$
	webstr$=str$(clientid),fdel$
	webstr$=webstr$,rtrim$(clientname$),fdel$
	let tmp$="N"
	if c0[4]<>0 AND spo<>0 let tmp$="Y"
	webstr$=webstr$,tmp$,fdel$
	let tmp$="N"
	if c0[6]<>0 let tmp$="Y"
	webstr$=webstr$,tmp$,fdel$
	if c0[6]<>0
		if prt.div<=0 let prt.div=1
		webstr$=webstr$,str$(prt.div),fdel$
	else
		webstr$=webstr$,"",fdel$
	endif
	let tmp$="N"
	if remreqflag=1 let tmp$="Y"
	webstr$=webstr$,tmp$,fdel$
	let tmp$="N"\If p61$[136,136]="Y" let tmp$="Y"
	webstr$=webstr$,tmp$,fdel$
	List$[2]=webstr$
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	if c0[4]<>0 AND spo<>0
		Clear List$[]                                      
		Call FileDropListpomiscchrg(e$,List$[],100,ch_misc)
		Call AddToStr(e$,rstr$,List$[])
	endif
	clear list$[]
    list$[0]=bsdel$,"droplistcurrency",fdel$ ! this is using the validation but using the same section heading
	list$[1]="ID",fdel$,"Desc",fdel$
	if p61$[136,136]<>"Y"
		list$[2]="0",fdel$,"None",fdel$
	else
		list$[2]="0",fdel$,"No Currency Exchange",fdel$
	endif
	let row=3
	if p61$[136,136]="Y"
		ch_curr=findchannel()
		tmp$="2/CURRENCY"+str$(Intco)
		ROpen #ch_curr,tmp$
		let keycurr$=" ",keycurr$
		do
			search #ch_curr,3,1;keycurr$,rec_curr,e
			if e<>0 exit do
			read record #ch_curr,rec_curr;curr.;
			let list$[row]=str$(curr.CurrId),fdel$,rtrim$(curr.desc$),fdel$
			let row=row+1
			if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
		loop
		try
			close #ch_curr
		else
			rem
		end try
	endif
	list$[row]=esdel$
	call addtostr(e$,rstr$,list$[])
	endcurrency: ! 
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! StartDataEntry
!============================================================================================================
Sub GetClient()! send droplist and flags for data entry screen
Try

	LET Keyapc$="10" 
	clientid=0
	clientname$="Client Not On File"
	SEARCH #ch_apc,2,1;Keyapc$,rec_apc,E
	if not(e)               
		MAT  READ #ch_apc,rec_apc,2;R2$; 
		let clientid=r2$
		LET Keyacf$=" ",Keyacf$ \ LET Keyacf$[3,6]=R2$       
		SEARCH #ch_acf,2,1;Keyacf$,rec_acf,E               
		IF not(e)                
			MAT  READ #ch_acf,Rec_acf,10;clientname$; 
		endif
	endif
else
    include "src/callsuberr.inc"
end try
end sub ! GetClient

!!============================================================================================================
Sub GetAcctPer()! get current month and next month account periods (yymm)
Try
	Dim 1%,tmpmth,tmpyr
	MAT  READ #1,0,134;apdate;     ! yymmdd                             
	LET tmp$=apdate USING "&&&&&&"                               
	LET currper=tmp$[1,4] 
	let currper$=tmp$[3,4],"/",tmp$[1,2]
	LET tmpmth=tmp$[3,4]                                         
	LET tmpmth=tmpmth+1                                            
	IF tmpmth>12 ! next year
		LET tmpmth=1                                      
		tmpyr=tmp$[1,2]
		tmpyr=tmpyr+1
		if tmpyr>99 let tmpyr=0
		let tmp$[1,2]=tmpyr using "&&"
		let tmp$[3,4]=tmpmth using "&&"
	else
		LET tmp$[3,4]=tmpmth USING "&&"
	endif
	let nxtper=tmp$[1,4] ! yymm
	let nxtper$=tmp$[3,4],"/",tmp$[1,2] ! mm/yy                  
	
else
    include "src/callsuberr.inc"
end try
end sub ! get acctper
!============================================================================================================
Sub AcperBATCHLIST()! gets list of ap batches for current period
Try
	dim uacname$[20]
	ch_uac=OpenFile(-9988, intCo)
	Clear List$[]
	List$[0]=bsdel$,"APBatchList",fdel$
	Webstr$=""
	webstr$="BatchId",fdel$
	!BATCH #    ENTRIES  BATCH TOTALS  REMARKS         STATUS         
	webstr$=webstr$,"Entries",fdel$
	webstr$=webstr$,"Batch Totals",fdel$
	webstr$=webstr$,"Remarks",fdel$
	webstr$=webstr$,"StatusId",fdel$
	webstr$=webstr$,"Status",fdel$
	webstr$=webstr$,"Currency",fdel$
	
	List$[1]=webstr$
	row=2
	tmpcnt=maxcnt
	Call Dxget ("ACCTPER",tmp$) ! MM/YY
	if rtrim$(tmp$)=""
		let returnstatus=0
		message$="Invalid Accounting Period" 
		goto endapbatchlist:
		
	endif
	if tmp$[3,3]<>"/"
		let returnstatus="Invalid Accounting Period Format Submitted"
		goto endapbatchlist:
	endif
	let period$=tmp$[4,5],tmp$[1,2]
	let acctper=period$
	let keybatch$=" ",keybatch$
	LET keybatch$[1,4]=acctper using "####"
	do
		search #ch_bth,3,1;keybatch$,rec_bth,e
		if e<>0 exit do
		let tmp3=keybatch$[1,4]
		if tmp3<>acctper exit do
		read record #ch_bth,rec_bth;apbth.;
		webstr$=""                                                                 
		webstr$=str$(apbth.BatchId),fdel$ ! batch id
		webstr$=webstr$,str$(apbth.TotRec),fdel$  ! entries
		tmp3=apbth.TotInv+apbth.TotCM+apbth.TotMC-apbth.TotDel 
		let amount=tmp3
		if p61$[136,136]="Y" and apbth.currfact<>0 and amount<>0  ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=apbth.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let tmp3=fnr(cnvca[0])
		endif
		webstr$=webstr$,(tmp3 using "--------------.##"),fdel$
		if apbth.remark$<"              "
			let apbth.remark$=" ",apbth.remark$
		endif
		if apbth.remark$>"zzzzzzzzzzzzzz"
			let apbth.remark$=" ",apbth.remark$
		endif
		webstr$=webstr$,rtrim$(apbth.Remark$),fdel$
		webstr$=webstr$,str$(apbth.Status),fdel$
		webstr$=webstr$,rtrim$(Z1$[(apbth.status*20)+1])
		if apbth.status=0 or apbth.status=2 or apbth.status=4
			if apbth.uarec<>0
				try
					read #ch_uac,apbth.uarec,280;UACNAME$;
					let webstr$=webstr$+" by "+rtrim$(uacname$)
				else
					rem
				end try
			endif
		endif
		webstr$=webstr$,fdel$
		if p61$[136,136]<>"Y"
			webstr$=webstr$+""+fdel$
		else
			if apbth.currid<>0
				let keycurr$=" ",keycurr$
				let keycurr$[1,4]=apbth.currid using "####"
				search #ch_curr,2,1;keycurr$,rec_curr,e
				if not(e)
					read record #ch_curr,rec_curr;curr.;
				else
					curr.desc$="" 
				endif
				let webstr$=webstr$+(apbth.currid using "####")+" "+rtrim$(curr.desc$)+fdel$
			else
				webstr$=webstr$+""+fdel$
			endif
		endif
		list$[row]=webstr$
		row = row + 1                                         
		If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])  
	loop
	endapbatchlist: ! 
	list$[row]=esdel$ ! end of section
	call AddToStr(e$,rstr$,List$[])
	
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)	
else
    include "src/callsuberr.inc"
end try
end sub ! acperbatchlist
!============================================================================================================
Sub GETAPBATCH()! gets ap batch and list of all transactions
Try
	dim uacname$[20]
	ch_uac=OpenFile(-9988, intCo)
	newbatch=0
	Call Dxget ("ACCTPER",tmp$) ! MM/YY
	if rtrim$(tmp$)=""
		let returnstatus=0
		message$="Invalid Accounting Period" 
		goto endgetbatch:
	endif
	if tmp$[3,3]<>"/"
		let returnstatus="Invalid Accounting Period Format Submitted"
		goto endgetbatch:
	endif
	let period$=tmp$[4,5],tmp$[1,2]
	let acctper=period$
	Call Dxget ("BATCHID",tmp$) ! 
	let batchid=tmp$
	if batchid=0 and rtrim$(tmp$)<>"0"
		let returnstatus=0
		let message$="Invalid Batch Id Submitted"
		goto endgetbatch:
	endif
	if batchid<0 or batchid>999999
		let returnstatus=0
		let message$="Invalid Batch Id Submitted"
		goto endgetbatch:
	endif
	if batchid<>0	
		let keybatch$=" ",keybatch$
		LET keybatch$[1,4]=acctper using "####"
		let keybatch$[5,10]=batchid using "######"
		search #ch_bth,2,1;keybatch$,rec_bth,e
		if e<>0 
			let returnstatus=0
			let message$="Batch Id "+str$(batchid)+" Not On File" 
			goto endgetbatch:
		endif
		Clear List$[]
		read record #ch_bth,rec_bth;apbth.;
		if apbth.status=0 !
			if apbth.UARec<>rec_uac
				returnstatus=0                                                    
				message$="Batch is in process elsewhere"
				if apbth.uarec<>0
					try
						read #ch_uac,apbth.uarec,280;UACNAME$;
						let message$=message$+" by "+rtrim$(uacname$)+". Please have user reset this batch. "
					else
						rem
					end try
				endif
				goto endgetbatch:
			else
				 call updapbthtot() ! verify ap batch totals
			endif
		endif
		if apbth.status=2 and apbth.uarec<>rec_uac
			returnstatus=0
			message$="Data Entry List in Process" 
			if apbth.uarec<>0
				try
					read #ch_uac,apbth.uarec,280;UACNAME$;
					let message$=message$+" by "+rtrim$(uacname$)+". Please have user reset this batch. "
				else
					rem
				end try
			endif
			goto endgetbatch:
		endif                                                     
                !if apbth.status=3
			!let returnstatus=2
			!message$="DATA ENTRY LIST HAS BEEN ACCEPTED!!!"
		!endif
		if apbth.status=4
			returnstatus=0
			message$="Purchase Journal in Process"
			if apbth.uarec<>0
				try
					read #ch_uac,apbth.uarec,280;UACNAME$;
					let message$=message$+" by "+rtrim$(uacname$)+". Please have user complete the purchase journal. "
				else
					rem
				end try
			endif
			goto endgetbatch:
		endif                                                         
		IF apbth.status=6
			message$="BATCH HAS ALREADY BEEN ACCEPTED!!!"
			returnstatus=0
			goto endgetbatch:
                endif                                                         
		IF apbth.status=9 
			let message$="BATCH HAS BEEN DELETED!!!"
			returnstatus=0
			goto endgetbatch:
		endif
	else ! new batch
		newbatch=99
		clear apbth.
		call GetAcctPer()
		Try Close #ctlc Else Rem
		ctlc = OpenFile(9999,IntCo) \ If ctlc = -1 Error 42 !control   ! open w/ write permiss
		! Determine account period
		if currper=acctper
			READ #ctlc,51,36;C1
			If not (c1) let c1=1
			LET apbth.batchid=C1
			LET C1=C1+1
			WRITE #ctlc,51,36;C1;
		else ! most be next month
			READ #ctlc,51,40;C1
			if not(c1) let c1=1
			apbth.batchid=C1 
			LET C1=C1+1
			WRITE #ctlc,51,40;C1;
		endif
		! check if batch already exists
		let batchid=apbth.batchid
		if batchid>999999
			let returnstatus=0
			let message$="Error. Batch Id has Exceeded Limits "
			goto endgetbatch:
		endif
		let keybatch$=" ",keybatch$
		LET keybatch$[1,4]=acctper using "####"
		let keybatch$[5,10]=batchid using "######"
		search #ch_bth,2,1;keybatch$,rec_bth,e
		if not(e) 
			let returnstatus=0
			let message$="Creating New Batch Error. Duplicate Batch Number "+str$(batchid) 
			goto endgetbatch:
		endif
		Call Dxget("REMARK",tmp$)
		let apbth.remark$=rtrim$(tmp$)+blank$
		if apbth.remark$<"              "
			let returnstatus=0
			let message$="Invalid Remark Submitted. "
			goto endgetbatch:
		endif
		if apbth.remark$>"zzzzzzzzzzzzzz"
			let returnstatus=0
			let message$="Invalid Remark Submitted. "
			goto endgetbatch:
		endif
		if p61$[136,136]="Y"
			Call DXGET("CURRID",tmp$)
			let apbth.currid=tmp$
			if apbth.currid<>0
				let keycurr$=" ",keycurr$
				let keycurr$[1,4]=apbth.currid using "####"
				search #ch_curr,2,1;keycurr$,rec_curr,e
				if not(e)
					read record #ch_curr,rec_curr;curr.;
					apbth.currfact=curr.excrate
				else
					let returnstatus=0
					let message$="Invalid Currency Selected "
				endif
			else
				apbth.currid=0
				apbth.currfact=0
			endif
		else
			let apbth.currid=0
			let apbth.currfact=0
		endif

		let apbth.acctper=acctper
		let e=2\search #ch_bth,1,0;KEYBATCH$,rec_bth,e
		if e>0 Error (10000+e)
		let KEYBATCH$[1,4]=apbth.acctper using "####"
		let KEYBATCH$[5,10]=apbth.batchid using "######"
		let batchid=apbth.batchid
		write #ch_bth,rec_bth;apbth.;
		search #ch_bth,4,1;KEYBATCH$,rec_bth,e
		if e>0  Error (10000+e)
	endif
	let apbth.status=0 ! set to inprocess
	let apbth.UARec=rec_uac
	write record #ch_bth,rec_bth;apbth.;
	endgetbatch: ! 
	Clear List$[]
	List$[0]=bsdel$,"GetApBatch",fdel$
	Webstr$=""
	webstr$="BatchId",fdel$
	webstr$=webstr$,"PostingPeriod",fdel$
	webstr$=webstr$,"Remarks",fdel$
	webstr$=webstr$,"Entries",fdel$
	webstr$=webstr$,"Invoices",fdel$
	webstr$=webstr$,"Credits",fdel$
	webstr$=webstr$,"ManualChk",fdel$
	webstr$=webstr$,"Deletes",fdel$
	webstr$=webstr$,"NewRecord",fdel$
	webstr$=webstr$,"CurrId",fdel$
	webstr$=webstr$,"CurrDesc",fdel$
	List$[1]=webstr$
	if returnstatus<>0
		webstr$=""
		webstr$=str$(apbth.batchid),fdel$
		tmp$=apbth.acctper using "&&&&"
		webstr$=webstr$+tmp$[3,4]+"/"+tmp$[1,2]+fdel$ ! mm/yy format
		if apbth.remark$<"              "
			let apbth.remark$=" ",apbth.remark$
			
		endif
		if apbth.remark$>"zzzzzzzzzzzzzz"
			let apbth.remark$=" ",apbth.remark$
		endif
		webstr$=webstr$,rtrim$(apbth.Remark$),fdel$
		webstr$=webstr$,str$(apbth.TotRec),fdel$  ! entries
		tmp3=+apbth.TotCM+apbth.TotMC-apbth.TotDel
		let amount=apbth.TotInv 
		if p61$[136,136]="Y" and apbth.currfact<>0 and amount<>0  ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=apbth.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=fnr(cnvca[0])
		endif
		webstr$=webstr$,(amount using "--------------.##"),fdel$ ! apbth.TotInv
		let amount=apbth.TotCM
		if p61$[136,136]="Y" and apbth.currfact<>0 and amount<>0  ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=apbth.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=fnr(cnvca[0])
		endif
		webstr$=webstr$,(amount using "--------------.##"),fdel$ ! apbth.TotCM
		let amount=apbth.TotMC
		if p61$[136,136]="Y" and apbth.currfact<>0 and amount<>0  ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=apbth.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=fnr(cnvca[0])
		endif
		webstr$=webstr$,(amount using "--------------.##"),fdel$ !apbth.TotMC
		let amount=apbth.TotDel
		if p61$[136,136]="Y" and apbth.currfact<>0 and amount<>0  ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=apbth.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=fnr(cnvca[0])
		endif
		webstr$=webstr$,(amount using "--------------.##"),fdel$
		let tmp$="N"
		if newrecord<>0 let tmp$="Y"
		webstr$=webstr$,tmp$,fdel$
		if p61$[136,136]<>"Y"
			webstr$=webstr$+""+fdel$
			webstr$=webstr$+""+fdel$
		else
			if apbth.currid<>0
				let keycurr$=" ",keycurr$
				let keycurr$[1,4]=apbth.currid using "####"
				search #ch_curr,2,1;keycurr$,rec_curr,e
				if not(e)
					read record #ch_curr,rec_curr;curr.;
				else
					curr.desc$="" 
				endif
			endif
			let webstr$=webstr$+(apbth.currid using "####")+fdel$
			let webstr$=webstr$+rtrim$(curr.desc$)+fdel$
		endif
		list$[2]=webstr$
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	! get ap transactions for the batch
	Clear List$[]
	List$[0]=bsdel$,"ApBatchTrans",fdel$
	Webstr$=""
	Webstr$="VendId",fdel$
	Webstr$=webstr$,"VendName",fdel$
	Webstr$=webstr$,"Transaction",fdel$
	Webstr$=webstr$,"Type",fdel$
	Webstr$=webstr$,"Date",fdel$
	Webstr$=webstr$,"Amount",fdel$
	List$[1]=webstr$
	row=2
	tmpcnt=maxcnt
	if returnstatus<>0 and newbatch=0
		let keyoi$=" ",keyoi$
		DO
			search #ch_oi,3,1;keyoi$,rec_oi,e
			if e<>0 exit do
			read record #ch_oi,rec_oi;oi.;
			if oi.BatchNumber<>Batchid goto getnxtoi:
			if oi.PostingPeriod<>acctper goto getnxtoi:
  			webstr$=""                                                                 
			webstr$=str$(oi.VendorCode),fdel$ ! vendor code
			let keyvend$=oi.VendorCode using "######"
			search #ch_vend,2,1;keyvend$,rec_vend,e
			if not(e)
				read record #ch_vend,rec_vend;vend.;
			else
				let vend.name$="Vendor Not On File"
			endif
			webstr$=webstr$,rtrim$(vend.name$),fdel$  ! vendor name
			webstr$=webstr$,rtrim$(oi.InvoiceCode$),fdel$
			let tmp$="INV"
			if oi.TransactionType=2 let tmp$="C/M"
			if oi.TransactionType=3 let tmp$="M/C"
			if oi.StatusCode$="9" let tmp$="DEL"
			webstr$=webstr$,rtrim$(tmp$),fdel$
			If oi.InvoiceDate<>0 
				xdate$ = pdate$(oi.InvoiceDate)   
			Else                               
				xdate$ = "01/01/1900"                                             	
			endif
			webstr$=webstr$,rtrim$(xdate$),fdel$
			let amount=oi.GrossInvoiceAmount
			if p61$[136,136]="Y" and oi.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=oi.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=fnr(cnvca[0])
			endif
			webstr$=webstr$,(amount USING "--------.##"),fdel$ ! oi.GrossInvoiceAmount
			list$[row]=webstr$
			row = row + 1                                         
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
			getnxtoi: ! get next open item 
		LOOP
	endif
	
	list$[row]=esdel$ ! end of section
	call AddToStr(e$,rstr$,List$[])
	
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)	
else
    include "src/callsuberr.inc"
end try
end sub ! GETAPBATCH

!============================================================================================================
Sub EXITAPBATCH()! resets in process flags
Try
	call validatebatch()
	if not(returnstatus)
	    read record #ch_bth,rec_bth;apbth.;
		if apbth.status=1 or apbth.status=3! entry or data entry list complete
			let returnstatus=1
			let message$="ok"
			goto endexitbatch: ! out of entry status 
		 endif
	endif
	if not(returnstatus) goto endexitbatch:	
	read record #ch_bth,rec_bth;apbth.;
	if remreqflag=1
		if rtrim$(apbth.remark$)=""
			let returnstatus=0
			let message$="Batch Remark Needs To Entered "
			goto endexitbatch:
		endif
	endif
	let apbth.status=1 ! set to Entry Completed
	let apbth.UARec=rec_uac
	write record #ch_bth,rec_bth;apbth.;
	call updapbthtot() ! verify ap batch totals
	endexitbatch: ! 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)	
else
    include "src/callsuberr.inc"
end try
end sub ! EXIT AP BATCH

!============================================================================================================

Sub updapbthtot()! update ap batch totals ! batch record should already be read
Try	
	read record #ch_bth,rec_bth;apbth.;
	let apbth.totrec=0
	let apbth.totinv=0
	let apbth.totcm=0
	let apbth.totmc=0
	let apbth.totdel=0
	let keyoi$=" ",keyoi$
	DO
		search #ch_oi,3,1;keyoi$,rec_oi,e
		if e<>0 exit do
		read record #ch_oi,rec_oi;oi.;
		if oi.BatchNumber=apbth.Batchid and oi.PostingPeriod=apbth.acctper
			let apbth.totrec=apbth.totrec+1
			amount=oi.GrossInvoiceAmount
			if p61$[136,136]="Y"
				if oi.currfact<>apbth.currfact
					if oi.currfact<>0 and apbth.currfact<>0
						let cnvcu[0]=1
						let cnvca[0]=amount
						let cnvca[1]=oi.currfact
						let CNVCU[1]=1 ! no rounding
						call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
						let amount=cnvca[0]
						let cnvcu[0]=2
						let cnvca[0]=amount
						let cnvca[1]=apbth.currfact
						let CNVCU[1]=1
						call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
						let amount=fnr(cnvca[0])
					endif
				endif
			endif
			if oi.StatusCode$="9" 
				let apbth.totdel= apbth.totdel+amount ! oi.GrossInvoiceAmount
			else
				if oi.TransactionType=1 let apbth.totinv=apbth.totinv+amount ! oi.GrossInvoiceAmount
				if oi.TransactionType=2 let apbth.totcm =apbth.totcm+amount ! oi.GrossInvoiceAmount
				if oi.TransactionType=3 let apbth.totmc =apbth.totmc+amount ! oi.GrossInvoiceAmount
			endif
			
		endif
	LOOP
	write record #ch_bth,rec_bth;apbth.;
else
    include "src/callsuberr.inc"
end try
end sub ! upapbthtot

!============================================================================================================

Sub APBATCHREM()! updates remarks of a batch
Try
	returnstatus=1
	let message$="ok"
	call validatebatch()
	if not(returnstatus)
		if apbth.status=1 or apbth.status=3! entry or data entry list complete
			let returnstatus=1
			let message$="ok"
		 endif
		goto endrembatch:
	endif
	Call Dxget("REMARK",tmp$)
	if remreqflag=1 and rtrim$(tmp$)=""
		let returnstatus=0
		let message$="Batch Remark is Required "
		goto endrembatch:
	endif
		
	let apbth.remark$=rtrim$(tmp$)+blank$
	if apbth.remark$<"              "
		let returnstatus=0
		let message$="Invalid Remark Submitted. "
	endif
	if apbth.remark$>"zzzzzzzzzzzzzz"
		let returnstatus=0
		let message$="Invalid Remark Submitted. "
	endif
	if returnstatus<>0
		write record #ch_bth,rec_bth;apbth.;
	endif
	endrembatch: ! 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)	
else
    include "src/callsuberr.inc"
end try
end sub ! APBATCHREM
!====================================================================================================
Sub ValidateBatch()! validates the status of an a/p batch
Try
	dim uacname$[20]
	ch_uac=OpenFile(-9988, intCo)
Call Dxget ("ACCTPER",tmp$) ! MM/YY
	if rtrim$(tmp$)=""
		let returnstatus=0
		message$="Invalid Accounting Period" 
		goto endvalidatebatch:
	endif
	if tmp$[3,3]<>"/"
		let returnstatus="Invalid Accounting Period Format Submitted"
		goto endvalidatebatch:
	endif
	let period$=tmp$[4,5],tmp$[1,2]
	let acctper=period$
	Call Dxget ("BATCHID",tmp$) ! 
	let batchid=tmp$
	if batchid<=0 or batchid>999999
		let returnstatus=0
		let message$="Invalid Batch Id Submitted"
		goto endvalidatebatch:
	endif
	let keybatch$=" ",keybatch$
	LET keybatch$[1,4]=acctper using "####"
	let keybatch$[5,10]=batchid using "######"
	search #ch_bth,2,1;keybatch$,rec_bth,e
	if e<>0 
		let returnstatus=0
		let message$="Batch Id "+str$(batchid)+" Not On File" 
		goto endvalidatebatch:
	endif
	read record #ch_bth,rec_bth;apbth.;
	if apbth.status=2 and apbth.UAREC=REC_UAC ! DATA ENTRY LIST IN PROCESS
		goto endvalidatebatch:! 
	endif
	If apbth.status<>0
		let returnstatus=0
		let message$="Invalid Batch Status for Update "+str$(apbth.status)
		if apbth.status>-1 and apbth.status<10
			let message$=message$+" "+rtrim$(Z1$[(apbth.status*20)+1])
			if apbth.status=0 or apbth.status=2 or apbth.status=4
				if apbth.uarec<>0
					try
						read #ch_uac,apbth.uarec,280;UACNAME$;
						let message$=message$+" by "+rtrim$(uacname$)+". Please have user reset this batch. "
					else
					rem
					end try
				endif
			endif
		endif

		goto endvalidatebatch:
	endif
	if apbth.status=0 and apbth.UARec<>rec_uac
		returnstatus=0                                                    
		message$="Batch is in process"
		if apbth.uarec<>0
				try
					read #ch_uac,apbth.uarec,280;UACNAME$;
					let message$=message$+" by "+rtrim$(uacname$)
				else
					rem
				end try
			endif
		goto endvalidatebatch:
	endif
	endvalidatebatch: ! end validatebatch
else
    include "src/callsuberr.inc"
end try
end sub ! ValidateBatch
!=======================================================================================
Sub FindAPPOID()! find ap
Try
	if not(appoh.PoVendId)
		LET keypoh$=" ",keypoh$;keypoh$[3,8]=poid USING "######"        
		IF TRANSTYPE=2                                               
			LET keypoh$[1,2]="14"                                    
			SEARCH #ch_poh,2,1;keypoh$,rec_poh,E    
			if e<>0
				let returnstatus=0
				let message$=message$+"Debit Memo "+str$(poid)+" Not on File "
				goto endfindappoid:
			endif		
		ELSE                                                    
			FOR STAT=7 TO 1 STEP -1                               
				LET keypoh$[1,2]=STAT USING "##"                       
				SEARCH #ch_poh,2,1;keypoh$,rec_poh,E 
				if not(E) goto foundpoid:                             
			NEXT STAT                                             
			LET keypoh$[1,2]="21"
			SEARCH #ch_poh,2,1;keypoh$,rec_poh,E                                           
			IF NOT(E)                                                             
				goto foundpoid:
			ENDIF
			let returnstatus=0
			message$=message$+"Purchase Order "+str$(poid)+" Not On File "
			goto foundpoid: 
		ENDIF                                                                   
		foundpoid: ! need to find po #
		read record #ch_poh,rec_poh;poh.;
		if rec_appoh<0 ! need to create the record then
			appoh.VendID=vendid        
			appoh.PoID=poid        
			appoh.PoVendId=poh.vendorcode        
			appoh.TransCode$=transid$+blank$  
			appoh.Type=transtype
			appoh.MiscCode1=poh.miscchrcode1
			appoh.MiscCode2=poh.miscchrcode2
			appoh.MiscCode3=poh.miscchrcode3
			appoh.MiscCode4=poh.miscchrcode4
			appoh.MiscCode5=poh.miscchrcode5
			let aph3[0]=poh.miscchrcode1
			let aph3[1]=poh.miscchrcode2
			let aph3[2]=poh.miscchrcode3
			let aph3[3]=poh.miscchrcode4
			let aph3[4]=poh.miscchrcode5
			appoh.currid=oi.currid
			appoh.currfact=oi.currfact
			mode$="a"
			UpdStatus = fileupdateappoh(e$,ch_appoh,mode$,rec_appoh,appoh.)! need to do the update program
		endif
	else
		let keypoh$=" ",keypoh$
		let keypoh$[1,6]=appoh.povendid using "######"
		let keypoh$[7,12]=appoh.PoID using "######"
		search #ch_poh,2,2;keypoh$,rec_poh,e
		if e<>0
			let returnstatus=0
			let message$=""
			if transtype<>2
				let message$="Purchase Order "
			else
				let message$="Debit Memo "
			endif
			message$=message$+str$(poid)+" For Vendor "+str$(appoh.povendid)+" Not Found "
		endif
		read record#ch_poh,rec_poh;poh.; 
	endif
	endfindappoid: ! end find appoid
else
    include "src/callsuberr.inc"
end try
end sub ! FINDAPPOID
!=======================================================================================
Sub APBATCHDELETE()! deletes ap batch and open items in the batch
Try
	Call ValidateBatch()
	if not(returnstatus) goto endapbatchdelete:
	! Verify Ap Transactions
	read record #ch_bth,rec_bth;apbth.
	let eflag=0
	let numrec=0
	let message$=""
	let keyoi$=" ",keyoi$
	DO
		search #ch_oi,3,1;keyoi$,rec_oi,e
		if e<>0 exit do
		read record #ch_oi,rec_oi;oi.;
		if oi.BatchNumber<>Batchid goto getnextoi:
		if oi.PostingPeriod<>acctper goto getnextoi:
		if oi.StatusCode$="0"
			let numrec=numrec+1
			goto getnextoi: !
		endif
		if oi.statusCode$="9"
			let eflag=eflag+1
			let message$=message$+ "Transaction "+rtrim$(keyoi$[7,18])+" For Vendor "+rtrim$(keyoi$[1,6])+" Already Deleted. "
			goto getnextoi:
		endif
		if oi.statusCode$<>"0"
			let eflag=eflag+1
			let message$="Transaction "+rtrim$(keyoi$[7,18])+" For Vendor "+rtrim$(keyoi$[1,6])+" Already Acceptedd. "
			goto getnextoi:
		endif
		
		getnextoi: ! 
	Loop
	if eflag<>0
		let returnstatus=0
		let message$=Message$+" Cannot Delete Batch."
		goto endapbatchdelete:
	endif
  	! start the delete of the batch
	keyoi$=" ",keyoi$
	DO
		search #ch_oi,3,1;keyoi$,rec_oi,e
		if e<>0 exit do
		read record #ch_oi,rec_oi;oi.;
		if oi.BatchNumber<>Batchid goto getnextdeloi:
		if oi.PostingPeriod<>acctper goto getnextdeloi:
		if oi.StatusCode$<>"0" goto getnextdeloi: !
		if c0[4]<>0 ! ap po delete
			let ponum=0
			clear chan[]
			chan[0]=ctlc
			chan[1]=ch_oi
			chan[2]=ch_appoh
			chan[3]=ch_appol
			chan[4]=ch_poh
			chan[5]=ch_pol
			chan[6]=ch_poc
			Call "la510d.dl4",chan[],ponum,rec_oi,message$,IntCo,rstr$,e$
		endif
		Vendid=oi.VendorCode
		TransId$=oi.InvoiceCode$
		TransType=oi.TransactionType
	        call oidelete(VendId,TransID$,TransType)! delete open item
		if eflag<>0
			let returnstatus=0
			goto endapbatchdelete:
		endif
		call aphdelete(VendId,TransID$,TransType)! delete ap history item
		if eflag<>0
			let returnstatus=0
			goto endapbatchdelete:
		endif
		getnextdeloi: ! 
	Loop
	if returnstatus<>0
		let message$="Batch "+str$(batchid)+" Deleted "
		apbth.status=9 ! set to deleted
		write record #ch_bth,rec_bth;apbth.;
	endif
	endapbatchdelete: ! 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)	
else
    include "src/callsuberr.inc"
end try
end sub ! APBATCHDELETE

!==================================================================================================
Sub OiDelete(Vendid,TransId$,TransType)
Try
	eflag=0
	let message$=""
	let keyoi$=" ",keyoi$
	let keyoi$[1,6]=vendid using "######"
	let keyoi$[7,18]=transid$[1,12]
	let keyoi$[19,20]=transtype using "##"
	search #ch_oi,2,1;keyoi$,rec_oi,e
	if e<>0
		let eflag=eflag+1
		let message$="Error Deleting Transaction "+rtrim$(transid$)+" For Vendor "+str$(vendid)
		exit sub
	endif
	read record #ch_oi,rec_oi;oi.
	if oi.statuscode$<>"9"
		SEARCH #ch_oi,5,1;keyoi$,rec_oi,E\ if e<>0 Error (10000+e)           
		LET E=3 \ SEARCH #ch_oi,1,0;Keyoi$,rec_oi,E \ IF E<>0 Error( 10000+e)
		let keydi$=" ",keydi$
		let keydi$[1,5]=rec_oi using "#####"
		Do                          
			SEARCH #ch_di,3,1;keydi$,rec_di,E
			IF E=2 exit do      
			IF E<>0 Error (10000+e)
			let tmp3=keydi$[1,5]
			if tmp3<>rec_oi exit do
               		SEARCH #ch_di,5,1;Keydi$,rec_di,E \ IF E<>0 Error( 10000+e)         
			LET E=3 \ SEARCH #ch_di,1,0;Keydi$,rec_di,E \ IF E<>0 Error( 10000+e) 
		Loop                                                
	endif
Else
    include "src/callsuberr.inc"
end try
end sub ! OiDelete
!=================================================================================
Sub APPODelete(Vendid,TransId$,TransType,Poid)
Try
	eflag=0
	let message$=""
else
    include "src/callsuberr.inc"
end try
end sub ! APPoDelete
!=================================================================================
Sub GetAptrans() ! gets the ap transaction or creates a new one
Try
	Call ValidateBatch() ! checks acct per & batch id
	if not(returnstatus) goto endgetaptran:
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto endgetaptran:
	Call Dxget("INVOICECODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto endgetaptran:
	endif
	let transid$=rtrim$(tmp$)+blank$
	Call Dxget("TRANSTYPE",tmp$)
	let transtype=0
	if ucase$(rtrim$(Tmp$))="INV" let transtype=1
	if ucase$(rtrim$(Tmp$))="C/M" let transtype=2
	if ucase$(rtrim$(Tmp$))="M/C" let transtype=3
	IF not(transtype)
		let message$="Invalid Transaction Type Submitted"
		let returnstatus=0
		goto endgetaptran:
	endif
	newtrans=0 ! no
	if ucase$(rtrim$(transid$))<>rtrim$(transid$) ! check for lower case transaction		
		let tmpkey$=" ",tmpkey$
		let tmpkey$[1,6]=vendid using "######"
		let tmpkey$[7,18]=transid$
		let tmpkey$[19,20]=transtype using "##"
		search #ch_oi,2,1;tmpkey$,rec_oi,e
		if not(e) goto endlowcase:
		if e=1
			search #ch_apdh,2,1;tmpkey$,rec_apdh,e ! verify if in ap history
			if not(e)
				let message$="Transaction "+rtrim$(transid$)+" For Vendor "+str$(vendid)+" Already on File"
				let returnstatus=0
				goto endgetaptran:
			endif
			if transtype=3 ! verify if duplicate as a manual check
				let keyapdh$=tmpkey$
				let keyapdh$[19,20]=" 1"
				search #ch_apdh,2,1;keyapdh$,rec_apdh,e
				if not(e)
					call Dxget("VERIFYDUP",tmp$)
					if rtrim$(tmp$)=""
						let returnstatus=2 ! present warning
						Message$="INVOICE IS CURRENTLY ON FILE FOR THIS MANUAL CHECK."
						goto endgetaptran: ! 
					endif
				endif
			endif
			REM check if invoice is paid to another payto vendor
			IF vend.VendorCode<>Vend.PayToVendorCode                                                  
				LET Keyapdh$=tmpkey$;keyapdh$[1,6]=Vend.PaytoVendorcode USING "######"                
				SEARCH #ch_apdh,2,1;Keyapdh$,R[10],E
				if not(e)
					let returnstatus=0
					let message$="Transaction Already On File For Payto Vendor "+str$(vend.PaytoVendorCode)
					goto endgetaptran:
				endif
			endif
			let keyapdh3$=" ",keyapdh3$
			let keyapdh3$[1,6]=Vend.PaytoVendorCode using "######"
			Do
				search #ch_apdh,3,3;keyapdh$,rec_apdh,e
				if e>0 exit do
				let tmp3=keyapdh$[1,6]
				if tmp3<>Vend.PaytoVendorCode exit do
				let tmp3=keyapdh$[7,12] ! regular vendor code
				if tmp3=Vend.VendorCode
					let keyapdh3$=" ",keyapdh3$
					let keyapdh3$[1,6]=Vend.PaytoVendorCode using "######"
					if (tmp3+1)<=999999
						let keyapdh3$[7,12]=(tmp3+1) using "######"
					else
						let keyapdh3$[7,12]="zzzzzz"
					endif
				else
					if tmp3=Vend.PaytoVendorCode
						let keyapdh3$=" ",keyapdh3$
						let keyapdh3$[1,6]=Vend.PaytoVendorCode using "######"
						if (tmp3+1)<=999999
							let keyapdh3$[7,12]=(tmp3+1) using "######"
						else
							let keyapdh3$[7,12]="zzzzzz"
						endif
					else
						read record #ch_apdh,rec_apdh;apdh.;
						if apdh.TransactionType=transtype and apdh.InvoiceCode$=transid$
							let returnstatus=0
							message$="Duplicate Transaction for Pay To Vendor "+str$(apdh.PayToVendorCode)      
							message$=message$+" Buy From Vendor "+str$(apdh.VendorCode)
							goto endgetaptran:
						endif
					endif
				endif
			loop
			let transid$=ucase$(transid$)
			endlowcase: ! 
		endiF
	endif
	let keyoi$=" ",keyoi$
	let keyoi$[1,6]=vendid using "######"
	let keyoi$[7,18]=transid$
	let keyoi$[19,20]=transtype using "##"
	let keyoi$[7,18]=transid$
	search #ch_oi,2,1;keyoi$,rec_oi,e
	if e=1 ! new record !
		search #ch_apdh,2,1;keyoi$,rec_apdh,e ! verify if in ap history
		if not(e)
			let message$="Transaction "+rtrim$(transid$)+" For Vendor "+str$(vendid)+" Already on File"
			let returnstatus=0
			goto endgetaptran:
		endif
		if transtype=3 ! verify if duplicate as a manual check
			let keyapdh$=keyoi$
			let keyapdh$[19,20]=" 1"
			search #ch_apdh,2,1;keyapdh$,rec_apdh,e
			if not(e)
				call Dxget("VERIFYDUP",tmp$)
				if rtrim$(tmp$)=""
					let returnstatus=2 ! present warning
					Message$="INVOICE IS CURRENTLY ON FILE FOR THIS MANUAL CHECK."
					goto endgetaptran: ! 
				endif
			endif
		endif
		REM check if invoice is paid to another payto vendor
		IF vend.VendorCode<>Vend.PayToVendorCode                                                  
			LET Keyapdh$=Keyoi$;keyapdh$[1,6]=Vend.PaytoVendorcode USING "######"                
			SEARCH #ch_apdh,2,1;Keyapdh$,R[10],E
			if not(e)
				let returnstatus=0
				let message$="Transaction Already On File For Payto Vendor "+str$(vend.PaytoVendorCode)
				goto endgetaptran:
			endif
		endif
		let keyapdh3$=" ",keyapdh3$
		let keyapdh3$[1,6]=Vend.PaytoVendorCode using "######"
		Do
			search #ch_apdh,3,3;keyapdh$,rec_apdh,e
			if e>0 exit do
			let tmp3=keyapdh$[1,6]
			if tmp3<>Vend.PaytoVendorCode exit do
			let tmp3=keyapdh$[7,12] ! regular vendor code
			if tmp3=Vend.VendorCode
				let keyapdh3$=" ",keyapdh3$
				let keyapdh3$[1,6]=Vend.PaytoVendorCode using "######"
				if (tmp3+1)<=999999
					let keyapdh3$[7,12]=(tmp3+1) using "######"
				else
					let keyapdh3$[7,12]="zzzzzz"
				endif

			else
				if tmp3=Vend.PaytoVendorCode
					let keyapdh3$=" ",keyapdh3$
					let keyapdh3$[1,6]=Vend.PaytoVendorCode using "######"
					if (tmp3+1)<=999999
						let keyapdh3$[7,12]=(tmp3+1) using "######"
					else
						let keyapdh3$[7,12]="zzzzzz"
					endif
				else
					read record #ch_apdh,rec_apdh;apdh.;
					if apdh.TransactionType=transtype and apdh.InvoiceCode$=transid$
						 let returnstatus=0
						 message$="Duplicate Transaction for Pay To Vendor "+str$(apdh.PayToVendorCode)      
						 message$=message$+" Buy From Vendor "+str$(apdh.VendorCode)
						 goto endgetaptran:
					endif
				endif
			endif
		loop	                                      
		newtrans=99
		clear oi.
		oi.StatusCode$="0"                      
		oi.DataEntryStatus$="0"                       
		oi.DocumentCode$=transtype using "#"
		oi.Spare$=" "
		oi.Spare1$=" "
		Call GetAcctPer()
		oi.CurrentMoFlag$="0"
		if acctper=nxtper let oi.CurrentMoFlag$="1"
		oi.InvoiceCode$ = transid$
		oi.TransactionType=transtype
		oi.PostingPeriod=acctper
		oi.BatchNumber=batchid   
		oi.VendorCode=vendid
		oi.PayToVendorCode=vend.PaytoVendorCode
		!LET O1[1]=A[0] \ LET O1[2]=(A2*100)
		oi.TermsDays=vend.DiscountDays 
		oi.Terms=(vend.Terms*100)    
		oi.BankNumber=0
		oi.Division=0
		If c0[6]<>0
			If prt.div<=0 let prt.div=1
			let oi.Division=prt.div
		endif
		if transtype=3
			if not(c0[0]) let oi.BankNumber=1
		endif
		let oi.currid=0
		let oi.currfact=0
		if p61$[136,136]="Y" and apbth.currid<>0
			oi.currid=apbth.currid
			oi.currfact=apbth.currfact
			if oi.PONumber<>0
				let vendid=oi.vendorcode
				let poid=oi.ponumber
				foundpovend=0
				call findvendpo (vendid,poid,foundpovend)
				if foundpovend<>0
					let oi.currfact=poh.currfact
				endif
			endif
		endif			
		let mode$="a"
		UpdStatus = fileupdateapa20oi(e$,ch_oi,mode$,rec_oi,oi.)
		rec_oi=updStatus
		read record #ch_oi,rec_oi;oi.;  
		! new record update 
		Read Record #ch_bth,rec_bth;apbth.
		let apbth.TotRec=apbth.TotRec+1
		write Record #ch_bth,rec_bth;apbth.;
		let apmsg$=" ",apmsg$
		let apchkmsg$=" ",apchkmsg$
	else ! existing record
		NEWTRANS=0
		read record #ch_oi,rec_oi;oi.;
		IF oi.StatusCode$<>"0"
			let returnstatus=0
			let message$="Transaction "+rtrim$(transid$)+" Already on File for Vendor "+str$(VendId)
			goto endgetaptran:
		endif
		if oi.BatchNumber<>batchid or oi.PostingPeriod<>acctper
			let returnstatus=0
			let message$="Transaction "+rtrim$(transid$)+" Already Entered in Batch "+str$(oi.BatchNumber)
			goto endgetaptran:
		endif
		let apmsg$=" ",apmsg$
		let apchkmsg$=" ",apchkmsg$
		let keyapdm$=" ",keyapdm$
		let keyapdm$[1,6]=vendid using "######"
		let keyapdm$[7,18]=transid$[1,12]
		let keyapdm$[19,20]=transtype using "##"
		search #ch_apdm,3,1;keyapdm$,rec_apdm,e
		if e<>0 goto endgetapmsg:
		if keyapdm$[7,18]<>transid$[1,12] goto endgetapmsg:
		let tmp3=keyapdm$[1,6]\if tmp3<>vendid goto endgetapmsg:
		let tmp3=keyapdm$[19,20]\if tmp3<>transtype goto endgetapmsg:
		read record #ch_apdm,rec_apdm;apdm.;
		let apmsg$=apdm.Message$
		let apchkmsg$=apdm.chkmsg$
		endgetapmsg: ! end getting the ap message
			
		!!!! need to adjust the batch info here

		call aphdelete(VendId,TransID$,TransType)! delete open item
		
			
	endif
	endgetaptran: !
	clear list$[]
	list$[0]=bsdel$,"APTransaction",fdel$
	webstr$=""
	webstr$="VendId",fdel$
	webstr$=webstr$,"InvoiceCode",fdel$
	Webstr$=webstr$,"TranType",fdel$
	webstr$=webstr$,"InvoiceDate",fdel$
	webstr$=webstr$,"DiscountDate",fdel$
	webstr$=webstr$,"DueDate",fdel$
	webstr$=webstr$,"GrossInvAmt",fdel$
	webstr$=webstr$,"DiscountableAmt",fdel$
	webstr$=webstr$,"TermsPct",fdel$
	webstr$=webstr$,"DiscountAmt",fdel$
	webstr$=webstr$,"PONumber",fdel$
	webstr$=webstr$,"Division",fdel$
	webstr$=webstr$,"CheckNumber",fdel$
	webstr$=webstr$,"CheckDate",fdel$
	webstr$=webstr$,"BankNumber",fdel$
	webstr$=webstr$,"NewRecord",fdel$
	webstr$=webstr$,"CalcTermDate",fdel$
	webstr$=webstr$,"SetDiscountable",fdel$
	webstr$=webstr$,"Message",fdel$
	webstr$=webstr$,"CheckMessage",fdel$
	list$[1]=webstr$
	row=2
	if returnstatus=1 ! no errors
		if oi.transactiontype=2 ! need to reverse sign on display items
			oi.GrossInvoiceAmount=oi.GrossInvoiceAmount*(-1)
			oi.DiscountableAmount=oi.DiscountableAmount*(-1)
			oi.DiscountAmount=oi.DiscountAmount*(-1)
		endif
		let webstr$=""
		webstr$=str$(vendid),fdel$
		webstr$=webstr$,rtrim$(transid$),fdel$
		let tmp$="INV"
		if transtype=2 let tmp$="C/M"
		if transtype=3 let tmp$="M/C"
		WebStr$ = WebStr$,RTrim$(tmp$),fdel$
		xdate$=""
		If oi.InvoiceDate <> 0                
			 xdate$ = pdate$(oi.InvoiceDate)     
		endif                         
		WebStr$ = WebStr$,RTrim$(xdate$),fdel$
		xdate$=""
		If oi.DiscountDate <> 0                
			 xdate$ = pdate$(oi.DiscountDate)     
		endif                         
		WebStr$ = WebStr$,RTrim$(xdate$),fdel$
		xdate$=""
		If oi.DueDate <> 0                
			 xdate$ = pdate$(oi.DueDate)     
		endif                         
		WebStr$ = WebStr$,RTrim$(xdate$),fdel$
		let amount=oi.GrossInvoiceAmount
		if p61$[136,136]="Y" and oi.currfact<>0 and amount<>0  ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=oi.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=fnr(cnvca[0])
		endif
		webstr$=webstr$,(Amount using "###########.##"),fdel$ !oi.GrossInvoiceAmount
		let amount=oi.DiscountableAmount
		if p61$[136,136]="Y" and oi.currfact<>0 and amount<>0  ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=oi.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=fnr(cnvca[0])
		endif
		webstr$=webstr$,(Amount using "###########.##"),fdel$ ! oi.DiscountableAmount
		webstr$=webstr$,((Oi.Terms/100) using "##.##"),fdel$
		let amount=oi.DiscountAmount
		if p61$[136,136]="Y" and oi.currfact<>0 and amount<>0  ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=oi.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=fnr(cnvca[0])
		endif
		webstr$=webstr$,(amount using "###########.##"),fdel$ ! oi.DiscountAmount
		Webstr$=webstr$,(oi.PONumber using "######"),fdel$
		If c0[6] 
			webstr$=webstr$,(oi.Division using"##"),fdel$
		else
			webstr$=webstr$,"",fdel$
		endif
		if transtype=3
			webstr$=webstr$,str$(oi.CheckNumber),fdel$
			If oi.CheckDate <> 0                
				 xdate$ = pdate$(oi.CheckDate)     
			endif                         
			WebStr$ = WebStr$,RTrim$(xdate$),fdel$ ! check date
			webstr$=webstr$,str$(oi.BankNumber),fdel$
		else
			webstr$=webstr$,"",fdel$
			webstr$=webstr$,"",fdel$
			webstr$=webstr$,"",fdel$
		endif
		let tmp$="N"
		if newtrans<>0 let tmp$="Y"
		webstr$=webstr$,tmp$,fdel$ ! new record
		Let tmp$="Y"
		if transtype=2 and c0[7]=0 let tmp$="N"
		if vend.DiscountDays=0 and vend.NetPaymentDays=0
			let tmp$="N"
		endif
		webstr$=webstr$,tmp$,fdel$ ! calcTermDate
		let tmp$="N"
		if c0[5] let tmp$="Y"
		if transtype=2 and c0[7]=0 let tmp$="N" ! no calc disc /
		webstr$=webstr$,tmp$,fdel$
		webstr$=webstr$,rtrim$(apmsg$),fdel$ ! internal message
		webstr$=webstr$,rtrim$(apchkmsg$),fdel$ ! check messgage
		let list$[row]=webstr$
		row=row+1
	endif
	list$[row]=esdel$ ! end of section
	call AddToStr(e$,rstr$,List$[])
	
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)	! let send over the data

else
    include "src/callsuberr.inc"
end try
end sub ! getaptrans
!==================================================================================================
Sub AphDelete(Vendid,TransId$,TransType)
Try
	eflag=0
	let message$=""
	
	! AP HISTORY DELETE
	keyapdh$=" ",keyapdh$
	let keyapdh$[1,6]=vendid using "######"
	let keyapdh$[7,18]=transid$[1,12]
	let keyapdh$[19,20]=transtype using "##"
	SEARCH #ch_apdh,2,1;Keyapdh$,rec_apdh,E 
	if e<>0 goto enddelaph: ! what happens if there is an error
	read record #ch_apdh,rec_apdh,0;apdh.;
	let keyapda$=" ",keyapda$
	let keyapda$[1,6]=rec_apdh using "######"
        do
		search #ch_apda,3,1;keyapda$,rec_apda,e
		if e<>0 exit do
		let tmp3=keyapda$[1,6]
		if tmp3<>rec_apdh exit do
		read record #ch_apda,rec_apda;apda.;
		if	apda.ApdethRec<> rec_apdh goto nxtapadel:
		if	apda.Vendor<>vendid   goto nxtapadel:
		if rtrim$(apda.InvoiceCode$)<>rtrim$(transid$ ) goto nxtapadel:  
		search #ch_apda,5,1;keyapda$,rec_apda,e\ IF E<>0 Error( 10000+e)
		let e=3\search #ch_apda,1,0;keyapda$,rec_apda,e\  IF E<>0 Error( 10000+e) 
		nxtapadel: ! 
	loop
	let keyapdm$=" ",keyapdm$
	let keyapdm$[1,20]=keyapdh$[1,20]
	do
		search #ch_apdm,3,1;keyapdm$,rec_apdm,e
		if e <>0 exit do
		if keyapdm$[1,20]<>keyapdh$[1,20] exit do
		search #ch_apdm,5,1;keyapdm$,rec_apdm,e \ IF E<>0 Error( 10000+e)
		let e=3\search #ch_apdm,1,0;keyapdm$,rec_apdm,e \ IF E<>0 Error( 10000+e)
	loop
	! mode$ = "d" ! delete                                              
	!UpdStatus = fileupdateapdeth(e$,ch_apdh,mode$,rec_apdh,apdh.) -- don't use rec# in key
	let keyapdh3$=" ",keyapdh3$
	let keyapdh3$[1,6]=apdh.PayToVendorCode using "######"
	let keyapdh3$[7,12]=apdh.VendorCode  using "######"
        let keyapdh3$[13,18]=apdh.TransactionDate using "######"
	let keyapdh3$[19,24]=rec_apdh using "######"
	search #ch_apdh,5,3;keyapdh3$,rec_apdh,e\IF E<>0 Error( 10000+e)
	let keyapdh3$=" ",keyapdh3$
	let keyapdh3$[1,6]=apdh.VendorCode using "######"
	let keyapdh3$[7,12]=apdh.TransactionDate using "######"
	let keyapdh3$[13,18]=rec_apdh using "######"
	search #ch_apdh,5,2;keyapdh3$,rec_apdh,e\IF E<>0 Error( 10000+e)
	search #ch_apdh,5,1;keyapdh$,rec_apdh,e\IF E<>0 Error( 10000+e)           
    let e=3\search #ch_apdh,1,0;keyapdh$,rec_apdh,e\IF E<>0 Error( 10000+e)  
	let keyapdt$=" ",keyapdt$
	let keyapdt$[1,20]=keyapdh$[1,20]
	! delete the apdt record
	search #ch_apdt,2,1;keyapdt$,rec_apdt,e
	if e <>0 goto enddelaph: 
	search #ch_apdt,5,1;keyapdt$,rec_apdt,e \ IF E<>0 Error( 10000+e)
	let e=3\search #ch_apdt,1,0;keyapdt$,rec_apdt,e \ IF E<>0 Error( 10000+e)
	! end delete the apdt record
	enddelaph: ! end delete ap history
else
    include "src/callsuberr.inc"
end try
end sub ! AphDelete
!=====================================================================================
Sub SubmitAptrans() ! gets the ap transaction or creates a new one
Try
	dim keycash$[30],3%,rec_cash
	message$="OK"
	Call ValidateBatch() ! checks acct per & batch id
	if not(returnstatus) goto endsubmitaptran:
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto endsubmitaptran:
	Call Dxget("INVOICECODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto endsubmitaptran:
	endif
	let transid$=rtrim$(tmp$)+blank$
	Call Dxget("TRANSTYPE",tmp$)
	let transtype=0
	if ucase$(rtrim$(Tmp$))="INV" let transtype=1
	if ucase$(rtrim$(Tmp$))="C/M" let transtype=2
	if ucase$(rtrim$(Tmp$))="M/C" let transtype=3
	IF not(transtype)
		let message$="Invalid Transaction Type Submitted"
		let returnstatus=0
		goto endsubmitaptran:
	endif
	
	let keyoi$=" ",keyoi$
	let keyoi$[1,6]=vendid using "######"
	let keyoi$[7,18]=transid$
	let keyoi$[19,20]=transtype using "##"
	search #ch_oi,2,1;keyoi$,rec_oi,e
	if e<>0
		let message$="Error A/P Transaction "+rtrim$(transid$)+" Not On File. "
		returnstatus=0
		goto endsubmitaptran:
	endif
	read record #ch_oi,rec_oi;oi.
	read record #ch_oi,rec_oi;prevoi.
	If oi.StatusCode$<> "0"
		let message$="A/P Transaction "+rtrim$(transid$)+" Is Invalid Status. May Not Submit."
		returnstatus=0
		goto endsubmitaptran:
	endif
	If oi.BatchNumber <> batchid Or oi.PostingPeriod <> acctper               
		ReturnStatus = 0                                                        
		Message$ = "Transaction " + RTrim$(transid$) + "Entered in Batch " + Str$(oi.BatchNumber)+" May Not Submit."                                                     
		Goto endsubmitaptran                                                       
	End If
	Call Dxget("Message",tmp$)
	let apmsg$=rtrim$(tmp$)+blank$
	strgok=chkbadchars(e$,apmsg$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Internal Message Line"
		goto endsubmitaptran
	Endif
	Call Dxget("CheckMessage",tmp$)
	let apchkmsg$=rtrim$(tmp$)+blank$
	strgok=chkbadchars(e$,apchkmsg$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Check Message Line"
		goto endsubmitaptran
	Endif
	if transtype=3
		Call Dxget("CheckNumber",tmp$)
		oi.CheckNumber=tmp$
		let tmp3=tmp$
		If tmp3<=0 or  tmp3>999999
			let returnstatus=0
			If rtrim$(ucase$(message$))="OK" let message$=""
			let message$=message$+ "Invalid Check Number Entered. "
		endif
		Call Dxget("CheckDate",tmp$)
		if rtrim$(tmp$)=""
			let returnstatus=0
			If rtrim$(ucase$(message$))="OK" let message$=""
			let message$=message$+ "Invalid Check Date Entered. "
		else
			xdate$ = formatdate2$(tmp$)
			oi.CheckDate =  xdate$[3,8]
		endif
		Call Dxget("BankNumber",tmp$)
		oi.banknumber=tmp$
		if oi.banknumber<=0 or oi.banknumber>99
			let returnstatus=0
			If rtrim$(ucase$(message$))="OK" let message$=""
			let message$=message$+ "Invalid Bank Number Entered. "
		endif
		if p61$[136,136]="Y"
			let keycash$=" ",keycash$
			let keycash$[1,2]=oi.banknumber using "##"
			search #ch_cash,2,1;keycash$,rec_cash,e
			if e<>0
				let message$="Bank "+str$(oi.banknumber)+" Not On File "
				returnstatus=0
			else
				read record #ch_cash,rec_cash;apcash.;	
				if apcash.currid<>0
					if apcash.currid<>apbth.currid
						let message$="Bank "+str$(oi.banknumber)+" Currency does not match AP Batch "
						let returnstatus=0
					else
						if apcash.currid<>vend.currid
							let message$="Bank "+str$(oi.banknumber)+" Currency does not match Vendor's Currency "
							let returstatus=0
						endif
					endif
				endif
			endif
		endif					
		if not(oi.PayToVendorCode) let oi.PayToVendorCode=oi.VendorCode     
        LET KEYAPDH$=" ",KEYAPDH$                                                                                                                  
        LET KEYAPDH$[1,6]=oi.PayToVendorCode USING "######"                                                                                       
        LET KEYAPDH$[7,12]=oi.CheckNumber USING "######"                                                                                           
        LET KEYAPDH$[20,20]="9"                                                                                                                          
        SEARCH #ch_apdh,2,1;KEYAPDH$,Rec_apdh,E                             
        IF NOT(E)
			MESSAGE$="Check Number "+str$(oi.CheckNumber)+" Already Issued to Pay To Vendor "+str$(oi.PayToVendorCode)                              
            returnstatus=0                                          
        endif                                                                      
		if returnstatus=0 goto endsubmitaptran:
	endif
	! Reduce Entry From batc
	Read Record #ch_bth,rec_bth;apbth.
	let apbth.TotRec=apbth.TotRec-1
	amount=oi.GrossInvoiceAmount
	if p61$[136,136]="Y"
		if oi.currfact<>apbth.currfact
			if oi.currfact<>0 and apbth.currfact<>0
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=oi.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=cnvca[0]
				let cnvcu[0]=2
				let cnvca[0]=amount
				let cnvca[1]=apbth.currfact
				let CNVCU[1]=1
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=fnr(cnvca[0])
			endif
		endif
	endif
	if oi.transactiontype=1
		apbth.TotInv=apbth.TotInv-amount ! oi.GrossInvoiceAmount
	else
		if oi.TransactionType=2
			apbth.TotCM=apbth.TotCM-amount ! oi.GrossInvoiceAmount 
		else
			if oi.TransactionType=3
				apbth.TotMC=apbth.TotMC-amount ! oi.GrossInvoiceAmount
			endif
		endif
	endif
	write Record #ch_bth,rec_bth;apbth.;
	Call Dxget("InvoiceDate",tmp$)
	xdate$ = formatdate2$(tmp$)
	oi.InvoiceDate =  xdate$[3,8]                
	Call Dxget("DiscountDate",tmp$)
	xdate$ = formatdate2$(tmp$)
	oi.DiscountDate =  xdate$[3,8]  
	Call Dxget("DueDate",tmp$)
	xdate$ = formatdate2$(tmp$)
	oi.DueDate =  xdate$[3,8]  
	Call Dxget("PONumber",tmp$)
	oi.PONumber=tmp$
	If p61$[136,136]="Y" and prevoi.ponumber=0 and prevoi.GrossInvoiceAmount=0
		if oi.PONumber<>0
			let foundpovend=0
			let vendid=oi.vendorcode
			let poid=oi.ponumber
			foundpovend=0
			call findvendpo (vendid,poid,foundpovend)
			if foundpovend<>0
				let oi.currfact=poh.currfact
			endif
		endif
	endif
	Call Dxget("GrossInvAmt",tmp$)
	oi.GrossInvoiceAmount=tmp$
	if transtype=2 let oi.GrossInvoiceAmount=oi.GrossInvoiceAmount*(-1)
	let amount=oi.GrossInvoiceAmount
	if p61$[136,136]="Y" and oi.currfact<>0 and amount<>0  ! going for base to costing um
			let cnvcu[0]=2
			let cnvca[0]=amount
			let cnvca[1]=oi.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let oi.GrossInvoiceAmount=fnr(cnvca[0])
		endif
	Call Dxget("DiscountableAmt",tmp$)
	oi.DiscountableAmount=tmp$
	if transtype=2 let oi.DiscountableAmount=oi.DiscountableAmount*(-1)
	let amount=oi.DiscountableAmount
	if p61$[136,136]="Y" and oi.currfact<>0 and amount<>0  ! going for base to costing um
			let cnvcu[0]=2
			let cnvca[0]=amount
			let cnvca[1]=oi.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let oi.DiscountableAmount=fnr(cnvca[0])
		endif
	Call Dxget("TermsPct",tmp$)
	let tmp3=tmp$
	let oi.terms=(tmp3*100)
	Call Dxget("DiscountAmt",tmp$)
	oi.DiscountAmount=tmp$
	let tmp3=tmp$
	if fra(tmp3*100)<>0
		returnstatus = 0                         
		Message$=mESSAGE$+" Invalid Disc Amt Submitted "
		goto endsubmitaptran:
	endif
	if transtype=2 let oi.DiscountAmount=oi.DiscountAmount*(-1)
	let amount=oi.DiscountAmount
	if p61$[136,136]="Y" and oi.currfact<>0 and amount<>0  ! going for base to costing um
			let cnvcu[0]=2
			let cnvca[0]=amount
			let cnvca[1]=oi.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let oi.DiscountAmount=fnr(cnvca[0])
		endif
	
	if c0[6]<>0
		Call Dxget("Division",tmp$)
		oi.Division=tmp$
		if oi.Division<1 or oi.Division>99
			returnstatus = 0                         
			Message$=mESSAGE$+" Invalid Division Submitted "
			goto endsubmitaptran:
		endif

	endif
	
	oi.NetInvoiceAmount=oi.GrossInvoiceAmount-oi.DiscountAmount
	If oi.PurchJournEntry<=0 or oi.PurchJournEntry>999999
		MAT  READ #CTLC,51,44;E1 \ LET E1=E1+1 \ IF E1>999999 LET E1=1    
		IF E1<=0 LET E1=1                                              
		LET oi.PurchJournEntry=E1                                                   
		MAT  WRITE #CTLC,51,44;E1; 
	endif
	oi.PostingPeriod=acctper
	oi.BatchNumber=batchid
	Write Record #ch_oi,rec_oi;oi.;
	! update the batch 
	Read Record #ch_bth,rec_bth;apbth.
	let apbth.TotRec=apbth.TotRec+1
	let amount=oi.GrossInvoiceAmount
	if p61$[136,136]="Y"
		if oi.currfact<>apbth.currfact
			if oi.currfact<>0 and apbth.currfact<>0
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=oi.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=cnvca[0]
				let cnvcu[0]=2
				let cnvca[0]=amount
				let cnvca[1]=apbth.currfact
				let CNVCU[1]=1
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=fnr(cnvca[0])
			endif
		endif
	endif
	if oi.transactiontype=1
		apbth.TotInv=apbth.TotInv+amount ! oi.GrossInvoiceAmount
	else
		if oi.TransactionType=2
			apbth.TotCM=apbth.TotCM+amount ! oi.GrossInvoiceAmount 
		else
			if oi.TransactionType=3
				apbth.TotMC=apbth.TotMC+amount ! oi.GrossInvoiceAmount
			endif
		endif
	endif
	write Record #ch_bth,rec_bth;apbth.;
	! delete ap history if already exists
	Call AphDelete(Vendid,TransId$,TransType)
	clear apdh.
	apdh.TransactionType=transtype    
	apdh.PaidIndicator=0  
	apdh.InvoiceCode$=transid$+blank$
	apdh.VendorCode=vendid 
	XDATE$ = oi.InvoiceDate Using "&&&&&&"        
	Call DateToJulian(5,XDATE$,XDATE$,errflag)  
	apdh.TransactionDate=xdate$ ! needs to be in julian        
	apdh.PostingDate=0                                    
	apdh.DueDate=oi.DueDate                        
	apdh.DiscountDate=oi.DiscountDate                        
	apdh.CheckNumber=oi.CheckNumber                       
	apdh.CheckDate=oi.CheckDate                        
	apdh.PoNumber=oi.PoNumber                      
	apdh.Division=oi.Division 
	apdh.OriginalAmount=oi.GrossInvoiceAmount                       
	apdh.DiscountAvail=oi.DiscountAMount                                                                    
	apdh.AmountPaid=0                         
	apdh.DiscountTaken=0                         
	apdh.PayToVendorCode=oi.PaytoVendorCode
	keyapdh$=" ",keyapdh$
    let keyapdh$[1,6]=vendid using "######"
	let keyapdh$[7,18]=transid$[1,12]
	let keyapdh$[19,20]=transtype using "##"
	let e=2\search #ch_apdh,1,0;keyapdh$,rec_apdh,e\IF E<>0 Error( 10000+e)
	write record #ch_apdh,rec_apdh;apdh.;
	let keyapdh3$=" ",keyapdh3$
	let keyapdh3$[1,6]=apdh.PayToVendorCode using "######"
	let keyapdh3$[7,12]=apdh.VendorCode  using "######"
    let keyapdh3$[13,18]=apdh.TransactionDate using "######"
	let keyapdh3$[19,24]=rec_apdh using "######"
	search #ch_apdh,4,3;keyapdh3$,rec_apdh,e\IF E<>0 Error( 10000+e)
	let keyapdh3$=" ",keyapdh3$
	let keyapdh3$[1,6]=apdh.VendorCode using "######"
	let keyapdh3$[7,12]=apdh.TransactionDate using "######"
	let keyapdh3$[13,18]=rec_apdh using "######"
	search #ch_apdh,4,2;keyapdh3$,rec_apdh,e\IF E<>0 Error( 10000+e)
	search #ch_apdh,4,1;keyapdh$,rec_apdh,e\IF E<>0 Error( 10000+e)           
    !Let message$="Transaction Submitted"
	if rtrim$(apmsg$)<>"" or rtrim$(apchkmsg$)<>""
		clear apdm.
		apdm.VendID=vendid                           
		apdm.TransType=transtype                          
		apdm.MsgType=1 ! message only type                                           
		apdm.MsgLine=1 ! only one line                                               
		apdm.TransID$=transid$[1,12]                          
		apdm.SPARE1$=" ",apdm.SPARE1$                            
		apdm.Message$=rtrim$(apmsg$)+blank$  
		apdm.ChkMsg$=rtriM$(apchkmsg$)+blank$
		apdm.SPARE2$=" ",apdm.SPARE2$                             
		apdm.SPARE3$=" "                   
		let keyapdm$=" ",keyapdm$
		let keyapdm$[1,6]=apdm.vendid using "######"
		let keyapdm$[7,18]=apdm.Transid$[1,12]
		let keyapdm$[19,20]=apdm.TransType using "##"
		let keyapdm$[21,22]=apdm.msgtype using "##"
		let keyapdm$[23,26]=apdm.msgline using "####"
		search #ch_apdm,2,1;keyapdm$,rec_apdm,e\IF E >1 Error( 10000+e)
		if e=1
			let e=2\search #ch_apdm,1,0;keyapdm$,rec_apdm,e \IF E<>0 Error( 10000+e)
			write record #ch_apdm,rec_apdm;apdm.;
			search #ch_apdm,4,1;keyapdm$,rec_apdm,e\IF E<>0 Error( 10000+e)
		else
			write record #ch_apdm,rec_apdm;apdm.;
		endif
	endif
	clear apdt.
	apdt.spare1$=" ",apdt.spare1$
	apdt.spare2$=" ",apdt.spare2$
	apdt.spare3$=" ",apdt.spare3$
	apdt.spare4$=" ",apdt.spare4$
	apdt.TransType=transtype    
	if p61$[136,136]="Y"
		let apdt.currid=oi.currid
		if apdt.currid<>0 let apdt.currfact=oi.currfact
	endif
	let apdt.vendid=vendid  
	let apdt.transid$=transid$+blank$   
	keyapdt$=" ",keyapdt$
    let keyapdt$[1,6]=vendid using "######"
	let keyapdt$[7,18]=transid$[1,12]
	let keyapdt$[19,20]=transtype using "##"
	search #ch_apdt,2,1;keyapdt$,rec_apdt,e
	if e>1 Error( 10000+e)
	if e=1
		let e=2\search #ch_apdt,1,0;keyapdt$,rec_apdt,e\IF E<>0 Error( 10000+e)
		write record #ch_apdt,rec_apdt;apdt.;
		search #ch_apdt,4,1;keyapdt$,rec_apdt,e
	endif
	write record #ch_apdt,rec_apdt;apdt.;	
	let message$="OK"
	endsubmitaptran: !
	if returnstatus=1 ! ok -- where to go next
		let returnstatus=2 ! goto apgl section
		if not(c0[4]) goto endsubmitaptran1: ! no ap po interface
		! if not(oi.ponumber) goto endsubmitaptran1: ! no po #
		LET KEYAPPOH$=" ",KEYAPPOH$                                               
		LET CHKKEY$[1,6]=vendid USING "######"                                     
		LET CHKKEY$[7,18]=TRANSID$[1,12]                                               
		LET CHKKEY$[19,20]=TRANSTYPE USING "##"
		eflag=0
		LET KEYAPPOH$=" ",KEYAPPOH$
		let keyappoh$[1,20]=chkkey$[1,20]
		do               
			SEARCH #ch_appoh,3,1;KEYAPPOH$,rec_appoh,E 
			IF e>0 exit do                                                                 
			IF KEYAPPOH$[1,20]<>CHKKEY$[1,20] exit do                         
			let eflag=eflag+1
			
		loop                 
		if eflag<>0
			let returnstatus=3 ! single po
			if eflag>1 let returnstaus=4 ! multi lines
			! goto endsubmitaptran1: ! 
		endif
		if not(oi.ponumber)
			if vtag.AllowPoS<>0
				if rtrim$(ucase$(message$))="OK" let message$=""
					let message$=message$+" No Purchase Order Number Entered. "
				endif
			goto endsubmitaptran1:! 
		endif
		! verify is ap transaction exist                                                 
		LET keypoh$=" ",keypoh$;keypoh$[3,8]=OI.PONUMBER USING "######"        
		IF TRANSTYPE=2                                               
			LET keypoh$[1,2]="14"                                    
			SEARCH #ch_poh,2,1;keypoh$,rec_poh,E    
			if e=0
				let returnstatus=3
				read record #ch_poh,rec_poh;poh.;
				if prevoi.ponumber<>oi.ponumber ! purchase order # has been changed
					if poh.VendorCode<>oi.PayToVendorCode and poh.VendorCode<>oi.VendorCode
						if rtrim$(ucase$(message$))="OK" let message$=""
						let message$=message$+" DM belongs to Vendor Code "+str$(poh.Vendorcode)+". "
					endif
				endif
				if c0[6]<>0
					if prevoi.ponumber<>oi.ponumber or prevoi.division<>oi.Division
					      	if poh.Warehouse<>oi.Division
							if rtrim$(ucase$(message$))="OK" let message$=""
							let message$=message$+" Division <> Purchase Order Warehouse "+str$(poh.Warehouse)+". "
						endif
				
					endif
				endif
				! verify if dm is already on file
			endif
			goto endsubmitaptran1:
		ELSE                                                    
			FOR STAT=7 TO 1 STEP -1                               
				LET keypoh$[1,2]=STAT USING "##"                       
				SEARCH #ch_poh,2,1;keypoh$,rec_poh,E 
				if not(E) 
					let returnstatus=3
					read record#ch_poh,rec_poh;poh.;
					!if prevoi.ponumber<>oi.ponumber 
					!	if poh.VendorCode<>oi.PayToVendorCode and poh.VendorCode<>oi.VendorCode
					!		if rtrim$(ucase$(message$))="OK" let message$=""
					!		let message$=message$+" PO belongs to Vendor Code "+str$(poh.Vendorcode)+". "
					!	endif
					!endif
					if c0[6]<>0
						if prevoi.ponumber<>oi.ponumber or prevoi.division<>oi.Division
							if poh.Warehouse<>oi.Division
								if rtrim$(ucase$(message$))="OK" let message$=""
								let message$=message$+" Division <> Purchase Order Warehouse "+str$(poh.Warehouse)+". "
							endif
						endif
					endif
					goto endsubmitaptran1:
				endif                             
			NEXT STAT                                             
			LET keypoh$[1,2]="21"
			SEARCH #ch_poh,2,1;keypoh$,rec_poh,E                                                                                                     
			if not(E) 
				let returnstatus=3 ! single po transaction
				goto endsubmitaptran1:
			endif                       		
		ENDIF                                                                                                               
	 endif	
	endsubmitaptran1: ! 
	! ALREADY CHECKED IN VERIFYPO CALL
	!if returnstatus>0 and oi.ponumber<>0 and prevoi.ponumber<>oi.ponumber
	!	LET KEYAPPOH$=" ",KEYAPPOH$                                               
	!	LET CHKKEY$[1,6]=vendid USING "######"                                     
	!	LET CHKKEY$[7,18]=TRANSID$[1,12]                                               
	!	LET CHKKEY$[19,20]=TRANSTYPE USING "##"
	!	eflag=0
	!	LET KEYAPPOH$=" ",KEYAPPOH$
	!	let keyappoh$[1,20]=chkkey$[1,20]
	!	do      
	!		let miscdist=0	 !  for gl check
	!		SEARCH #ch_appoh,3,1;KEYAPPOH$,rec_appoh,E 
	!		IF e>0 exit do                                                                 
	!		IF KEYAPPOH$[1,20]<>CHKKEY$[1,20]
	!			let tmp3=keyappoh$[21,26]
	!			If tmp3=oi.ponumber
	!				if rtrim$(ucase$(message$))="OK" let message$=""
	!				let message$=message$+" PO-DM Already on Transaction "+keyappoh$[7,18]+" For Vendor "+Keyappoh$[1,6]+". "
	!				if poglflag<>0
	!					! need to find the
	!				else
	!					exit do
	!				endif
	!			endif
	!		endif
	!	loop 
	!endif
	!let returnstatus=2
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)	! let send over the data

else
    include "src/callsuberr.inc"
end try
end sub ! submitaptrans
!=====================================================================================
Sub DeleteAptrans() ! deletes an existing ap transaction
Try
	Call ValidateBatch() ! checks acct per & batch id
	if not(returnstatus) goto enddeleteaptran:
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto enddeleteaptran:
	Call Dxget("INVOICECODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto enddeleteaptran:
	endif
	let transid$=rtrim$(tmp$)+blank$
	Call Dxget("TRANSTYPE",tmp$)
	let transtype=0
	if ucase$(rtrim$(Tmp$))="INV" let transtype=1
	if ucase$(rtrim$(Tmp$))="C/M" let transtype=2
	if ucase$(rtrim$(Tmp$))="M/C" let transtype=3
	IF not(transtype)
		let message$="Invalid Transaction Type Submitted"
		let returnstatus=0
		goto enddeleteaptran:
	endif
	let keyoi$=" ",keyoi$
	let keyoi$[1,6]=vendid using "######"
	let keyoi$[7,18]=transid$
	let keyoi$[19,20]=transtype using "##"
	search #ch_oi,2,1;keyoi$,rec_oi,e
	if e<>0
		let message$="Error A/P Transaction "+rtrim$(transid$)+" Not On File. "
		returnstatus=0
		goto enddeleteaptran:
	endif
	read record #ch_oi,rec_oi;oi.  
	If oi.StatusCode$<> "0"
		let message$="A/P Transaction "+rtrim$(transid$)+" Is Invalid Status. May Not Delete."
		returnstatus=0
		goto enddeleteaptran:
	endif
	If oi.BatchNumber <> batchid Or oi.PostingPeriod <> acctper               
		ReturnStatus = 0                                                        
		Message$ = "Transaction " + RTrim$(transid$) + "Entered in Batch " + Str$(oi.BatchNumber)+" May Not Delete."                                                     
		Goto enddeleteaptran                                                       
	End If
	Read Record #ch_bth,rec_bth;apbth.
	let apbth.TotRec=apbth.TotRec-1
	let amount=oi.GrossInvoiceAmount
	if p61$[136,136]="Y"
		if oi.currfact<>apbth.currfact
			if oi.currfact<>0 and apbth.currfact<>0
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=oi.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=cnvca[0]
				let cnvcu[0]=2
				let cnvca[0]=amount
				let cnvca[1]=apbth.currfact
				let CNVCU[1]=1
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let amount=fnr(cnvca[0])
			endif
		endif
	endif
	if oi.transactiontype=1
		apbth.TotInv=apbth.TotInv-amount ! oi.GrossInvoiceAmount
	else
		if oi.TransactionType=2
			apbth.TotCM=apbth.TotCM-amount ! oi.GrossInvoiceAmount 
		else
			if oi.TransactionType=3
				apbth.TotMC=apbth.TotMC-amount ! oi.GrossInvoiceAmount
			endif
		endif
	endif
	write Record #ch_bth,rec_bth;apbth.;
	if c0[4]<>0 ! ap po delete
			let ponum=0
			clear chan[]
			chan[0]=ctlc
			chan[1]=ch_oi
			chan[2]=ch_appoh
			chan[3]=ch_appol
			chan[4]=ch_poh
			chan[5]=ch_pol
			chan[6]=ch_poc
			Call "la510d.dl4",chan[],ponum,rec_oi,message$,IntCo,rstr$,e$
	endif
	Call OiDelete(vendid,transid$,transtype) ! delete open item         
	If eflag <> 0                                                       
		 ReturnStatus = 0                                                  
		 Goto enddeleteaptran                                             
	End If                                                              
	Call AphDelete(vendid,transid$,transtype) ! delete ap history item  
	If eflag <> 0                                                       
		ReturnStatus = 0                                                  
		 Goto enddeleteaptran                                             
	End If                                                              
	enddeleteaptran: !
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)	! let send over the data

else
    include "src/callsuberr.inc"
end try
end sub ! Deleteaptrans
!=====================================================================================
Sub CalcApDate() ! 
Try
	dim tmpdate$[20],discdate$[20],duedate$[20]
	dim 2%,xdate,newdate,discdate,duedate,trandate
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto endcalcapdate
	Call Dxget ("INVOICEDATE",tmpdate$) ! tmpdate$="mm/dd/yyyy"
	Call VerifyDate(tmpDate$,tmp$,errflag,1) ! returns in yyyymmdd
	let trandate=tmp$[3,8] ! yymmdd
	if errflag<>0
		let returnstatus=0
		let message$="Invalid Invoice Date Submitted "
		goto endcalcapdate:
	endif
	If errflag = 0                                                        
		Call DateToJulian(5,tmp$,tmp1$,errflag)                             
		jtmpdate= tmp1$
	endif
	days=vend.DiscountDays
	if not (days)
		let days=vend.NetPaymentDays
	endif
	call calctermdate(days,trandate,calcdate)
	DiscDate=calcdate
	days=vend.NetPaymentDays
	if vtag.uda4>0 ! SPLIT PROX TERMS
		let tmp$=trandate using "&&&&&&"
		let tranday=tmp$[5,6]
		let tranmonth=tmp$[3,4]
		let tranyear=tmp$[1,12]
		LET EOMDAY=31
		IF TRANMONTH=2
			LET EOMDAY=28
			IF NOT(FRA(TRANYEAR/4)) LET EOMDAY=29
		ENDIF 
		IF TRANMONTH=4 OR TRANMONTH=6 OR TRANMONTH=9 OR TRANMONTH=11
			LET EOMDAY=30
		ENDIF 
		let days=0
		if vtag.uda4=1
			!If Invoice Day is between the 1st and the 15th the Due Date is in 25th of the invoice day month 
			!If Invoice Day is between the 16thst and the Last Day of the Month the Due Date is the 10th of the next month
			IF TRANDAY>0 AND TRANDAY<16
				LET DAYS=25-TRANDAY
			else
				let days=-10
			endif
			goto gettermdate:
		endif
		if vtag.uda4=2
			!If Invoice Day is between the 1st and the 15th the Due Date is in 25th of the invoice date month 
			!If Invoice Day is between the 16thst and the Last Day of the Month the Due Date is the 15th of the next month 
			iF TRANDAY>0 AND TRANDAY<16
				LET DAYS=25-TRANDAY
			else
				let days=-15
			endif
			goto gettermdate:
		endif
		if vtag.uda4=3
			!If Invoice Day is between the 1st and the 15th the Due Date is the Last Day of the month 
			!If Invoice Day is between the 16thst and the Last Day of the Month the Due Date is the 10th of the next month
			iF TRANDAY>0 AND TRANDAY<16
				LET DAYS=eomday-TRANDAY
			else
				let days=-10
			endif
			goto gettermdate:
		endif
		if vtag.uda4=4
			!If Invoice Day is between the 1st and the 15th the Due Date is the Last Day of the month 
			!If Invoice Day is between the 16thst and the Last Day of the Month the Due Date is the 15th of the next month      
			iF TRANDAY>0 AND TRANDAY<16
				LET DAYS=eomday-TRANDAY
			else
				let days=-15
			endif
			goto gettermdate:
		endif

		if vtag.uda4=5
			!If Invoice Day is between the 1st and the 10th the Due Date is the 2O of the current month 
			!If Invoice Day is between the 11thst and the Last Day of the Month the Due Date is the 20th of the next month      
			iF TRANDAY>0 AND TRANDAY<11
				LET DAYS=20-TRANDAY
			else
				let days=-20
			endif
			goto gettermdate:
		endif
		if vtag.uda4=6
			!If Invoice Day is between the 1st and the 25th the Due Date is the 1Oth of the  next month 
			!If Invoice Day is between the 26thst and the Last Day of the Month the Due Date is the 10th of the 2 month      
			LET DAYS=-10
			call calctermdate(days,trandate,calcdate)
			DueDate=calcdate
			if tranday>25
				let tmp$=duedate using "&&&&&&" ! yymmdd
				let tmp3=tmp$[3,4]
				let tmp3=tmp3+1
				if tmp3>12
					let tmp3=tmp$[1,2]
					let tmp3=tmp3+1
					let tmp$[1,2]=tmp3 using "&&" ! next year
					let tmp3=1
				endif
				let tmp$[3,4]=tmp3 using "&&"
				let duedate=tmp$[1,6]
			endif
			goto endcalcapdate:!			
		endif
		if vtag.uda4=7
			!If Invoice Day is between the 1st and the 16th the Due Date is the Last Day of the month 
			!If Invoice Day is between the 17th and the Last Day of the Month the Due Date is the 15th of the next month
			iF TRANDAY>0 AND TRANDAY<17
				LET DAYS=eomday-TRANDAY
			else
				let days=-15
			endif
			goto gettermdate:
		endif
		if vtag.uda4=8
			!If Invoice Day is between the 1st and the 20th the Due Date is the 5th of the  next month 
			!If Invoice Day is between the 21thst and the Last Day of the Month the Due Date is the 5th of the 2 month      
			LET DAYS=-5
			call calctermdate(days,trandate,calcdate)
			DueDate=calcdate
			if tranday>20
				let tmp$=duedate using "&&&&&&" ! yymmdd
				let tmp3=tmp$[3,4]
				let tmp3=tmp3+1
				if tmp3>12
					let tmp3=tmp$[1,2]
					let tmp3=tmp3+1
					let tmp$[1,2]=tmp3 using "&&" ! next year
					let tmp3=1
				endif
				let tmp$[3,4]=tmp3 using "&&"
				let duedate=tmp$[1,6]
			endif
			goto endcalcapdate:!			
		endif
		if vtag.uda4=9
			!If Invoice Day is between the 1st and the 12th the Due Date is the 12th of the next month 
			!If Invoice Day is between the 13th and the Last Day of the Month the Due Date is the 28th of the next month
			iF TRANDAY>0 AND TRANDAY<13
				LET DAYS=-12
			else
				let days=-28
			endif
			goto gettermdate:
		endif
	endif
	days=vend.NetPaymentDays
	GETTERMDATE: ! get then date
	call calctermdate(days,trandate,calcdate)
	DueDate=calcdate
	endcalcapdate:!
	
	Clear List$[]
	List$[0]=bsdel$,"CalcApDate",fdel$
	Webstr$=""
	webstr$="DiscDate",fdel$
	webstr$=webstr$,"DueDate",fdel$
	List$[1]=webstr$
	row=2
	if returnstatus=1
		let xdate$=""
		if discdate<>0
			let xdate$=pdate$(discdate)
		endif
		webstr$=rtrim$(xdate$)+fdel$
		let xdate$=""
		if duedate<>0
			let xdate$=pdate$(duedate)
		endif
		webstr$=webstr$+rtrim$(XDATE$)+fdel$
		list$[2]=webstr$
		row=row+1
	endif
	list$[row]=esdel$
	Call AddToStr(e$,rstr$,List$[])                 
	!Call AddToStr(e$,rstr$,esdel$) ! end of section - cust age
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! CalcApDates
!--------------------------------------------------------------------
Sub calctermdate(days,trandate,calcdate)
Try
	Dim 2%,d3[2]               
	LET xdate$=trandate USING "&&&&&&"                      
	LET D3[0]=xdate$[3,4];D3[1]=xdate$[5,6];D3[2]=xdate$[1,2]
	if days>=0 ! calculate based on days         
		Call DateToJulian(5,xdate$,xdate$,errflag)   !CALL 25,1,xdate$,xdate$,Errflag   ! from yymmdd to julian                              
		if errflag goto endcalctermdate: !IF E LET D3[0]=0 \ GOTO L_8150:                  
		LET tmp3=xdate$;tmp3=tmp3+DAYS;xdate$=tmp3 USING "&&&&&&"        
		Call JulianToDate(1,xdate$,xdate$,errflag)!CALL 27,1,D$,D$,E   ! from julian to mm/dd/yy 
		if errflag goto endcalctermdate:
		!IF E LET E=0 \ GOSUB ERR_SEARCH:                 
		LET D3[0]=xdate$[1,2];D3[1]=xdate$[4,5];D3[2]=xdate$[7,8]    
		IF D3[0] LET CALCDATE=D3[2]*10^4+D3[0]*10^2+D3[1]
	else
		 LET D3[0]=D3[0]+1 \ IF D3[0]>12 LET D3[0]=1;D3[2]=D3[2]+1   
		 IF CDAY IF D3[1]>CDAY LET D3[0]=D3[0]+1                     
		 LET D3[1]=ABS(DAYS)                                         
		 IF D3[0]>12 LET D3[0]=1;D3[2]=D3[2]+1                       
		 IF D3[2]>99 LET D3[2]=D3[2]-100 
		 do
			LET XDATE$=D3[2]*10^4+D3[0]*10^2+D3[1] USING "&&&&&&"   
			Call DateToJulian(5,xdate$,xdate$,errflag)   ! CALL 25,XDATE$,XDATE$,E 
			if not(errflag) exit do                 
			LET D3[1]=D3[1]-1                                           
			IF D3[0]=2 IF D3[1]<28 exit do                         
			IF D3[0]<>2 IF D3[1]<30 exit do                       
		loop
		IF D3[0] LET CALCDATE=D3[2]*10^4+D3[0]*10^2+D3[1]
	endif
	endcalctermdate: ! end calculating the date

else
    include "src/callsuberr.inc"
  end try
end sub ! callcalctermdate
!
!--------------------------------------------------------------------
Sub getapgldist() ! get the apgl distribution for the transaction
Try
	dim 3%,postingamt
	Call ValidateBatch() ! checks acct per & batch id
	if not(returnstatus) goto endgetapgldist:
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto endgetapgldist:
	Call Dxget("INVOICECODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto endgetapgldist:
	endif
	let transid$=rtrim$(tmp$)+blank$
	Call Dxget("TRANSTYPE",tmp$)
	let transtype=0
	if ucase$(rtrim$(Tmp$))="INV" let transtype=1
	if ucase$(rtrim$(Tmp$))="C/M" let transtype=2
	if ucase$(rtrim$(Tmp$))="M/C" let transtype=3
	IF not(transtype)
		let message$="Invalid Transaction Type Submitted"
		let returnstatus=0
		goto endgetapgldist: 
	endif
	let keyoi$=" ",keyoi$
	let keyoi$[1,6]=vendid using "######"
	let keyoi$[7,18]=transid$
	let keyoi$[19,20]=transtype using "##"
	search #ch_oi,2,1;keyoi$,rec_oi,e
	if e<>0
		let message$="Error A/P Transaction "+rtrim$(transid$)+" Not On File. "
		returnstatus=0
		goto endgetapgldist: !
	endif
	read record #ch_oi,rec_oi;oi.  
	If oi.StatusCode$<> "0" 
		if oi.statuscode$<>"9" ! deleted also
			let message$="A/P Transaction "+rtrim$(transid$)+" Is Invalid Status. May Not Edit."
			returnstatus=0
			goto endgetapgldist:
		endif
	endif
	If oi.BatchNumber <> batchid Or oi.PostingPeriod <> acctper               
		ReturnStatus = 0                                                        
		Message$ = "Transaction " + RTrim$(transid$) + "Entered in Batch " + Str$(oi.BatchNumber)+" May Not Edit."                                                     
		Goto endgetapgldist:!                                                        
	End If  
	let eflag=0
	checkdirec: ! check to see if ap gl records exists
	! check if gl transactions already exists
	let keydi$=" ",keydi$
	let keydi$[1,5]=rec_oi using "#####"
	search #ch_di,3,1;keydi$,rec_di,e
	if not(e)
		let tmp3=keydi$[1,5]
		if tmp3=rec_oi goto endgetapgldist:! need to check if apgl dist already exists
	endif 
	if c0[4]<>0 and spo<>0 and p9$[17,17]="Y" and oi.statuscode$<>"9"
		let keyappoh$=" ",keyappoh$
		let keyappoh$[1,20]=keyoi$[1,20]
		search #ch_appoh,3,1;keyappoh$,rec_appoh,e
		if not(e) and keyappoh$[1,20]=keyoi$[1,20]
			Clear chan[]! 
			CHAN[0]=CH_APPOH
			CHAN[1]=CH_APPOL
			CHAN[2]=CH_POC
			CHAN[3]=CH_POH
			CHAN[4]=CH_POL
			CHAN[5]=CH_DI
			CHAN[6]=CH_OI
			CHAN[7]=CH_APDH
			CHAN[8]=CH_APDA
			CHAN[9]=CH_PROD
			CHAN[10]=CH_WH
			CHAN[11]=CH_MISC
			CHAN[12]=CH_NSTCK
			CHAN[14]=0 ! GLPOCNTRL
			CHAN[20]=CTLC                            
			LET SRC=510   
			found=0
			CALL "LACALCDIST.DL4",CHAN[],VENDID,TRANSID$,TRANSTYPE,SRC,MESSAGE$,IntCo,rstr$,RETURNSTATUS,rec_uac,found                                       
			! call to generate pogl interface
			if found<>0 goto endgetapgldist: 
		endif
	endif
	
	LET dfltacctid=vend.GLAccountNumber$
	if not(dfltacctid) goto endgetapgldist:
	IF C0[6]<>0 AND DEPT<>0 ! AP DIVISIONS SET UP WITH GL DEPARTMENT
		keyvl$=" ",keyvl$
		keyvl$[2,9]=dfltacctid using "########"
		keyvl$[8,9]=oi.division using "&&"
		search #ch_vl,2,1;keyvl$,rec_vl,e
		if e=0
			let dfltacctid=keyvl$[2,9]
			goto defgldist:
		endif
	endif
	keyvl$=" ",keyvl$
	keyvl$[2,9]=dfltacctid using "########"
	search #ch_vl,2,1;keyvl$,rec_vl,e
	if e<>0 goto endgetapgldist:
	defgldist: ! start default g/l distribution
	! now create gl distribution
	clear apdi.
	apdi.OIRec=rec_oi
	apdi.VendId=vendid
	apdi.InvCode$=transid$+blank$      
	apdi.AcctId=dfltacctid     
	apdi.Amount=oi.GrossInvoiceAmount 
	if oi.statuscode$="9"
		let apdi.Amount=-(oi.GrossInvoiceAmount)
	endif
	apdi.ItemNum=1     
	apdi.Type=transtype     
	apdi.Auto=0 
	mode$ = "a" ! add                                                 
	UpdStatus = fileupdateapa20di(e$,ch_di,mode$,rec_di,apdi.)
	! get gl acct # in vendor file
	! check if division and department and 
	endgetapgldist: ! 
	clear list$[]
	list$[0]=bsdel$,"APGLDIST",fdel$
	webstr$=""
	webstr$=webstr$,"GLACCTID",fdel$
	webstr$=webstr$,"GLACCTNAME",fdel$
	webstr$=webstr$,"GLAMOUNT",fdel$
	webstr$=webstr$,"ALLOWEDIT",fdel$
	list$[1]=webstr$
	let row=2
	let tmpcnt=maxcnt
	let postingamt=0
	if returnstatus=1
		let keydi$=" ",keydi$
		let keydi$[1,5]=rec_oi using "#####"
		do
			search #ch_di,3,1;keydi$,rec_di,e
			if e>0 exit do
			let tmp3=keydi$[1,5]
			if tmp3<>rec_oi exit do
			read record #ch_di,rec_di;apdi.;
			webstr$=(apdi.AcctId using "########"),fdel$
			keyvl$=" ",keyvl$
			keyvl$[2,9]=apdi.AcctId using "########"
			clear apvl.
			search #ch_vl,2,1;keyvl$,rec_vl,e
			if not(e)
				read record #ch_vl,rec_vl;apvl.;
			else
				apvl.desc$="Not on File!!!"
			endif
			webstr$=webstr$,rtrim$(apvl.desc$),fdel$ ! account name
			if oi.statuscode$="9"
				let apdi.amount=apdi.amount*(-1)
			endif
			if transtype=2 
				let apdi.Amount=apdi.Amount *(-1)
			endif
			let amount=apdi.Amount
			if p61$[136,136]="Y"
				if oi.currfact<>0 and amount<>0  ! going for base to costing um
					let cnvcu[0]=1
					let cnvca[0]=amount
					let cnvca[1]=oi.currfact
					let CNVCU[1]=1 ! no rounding
					call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
					let apdi.Amount=fnr(cnvca[0])
				endif
			endif
			webstr$=webstr$,(apdi.Amount using "-----------.##"),fdel$
			let tmp$="Y"
			if apdi.auto<>0 let tmp$="N"
			webstr$=webstr$,tmp$,fdel$! allow edit
			let postingamt=postingamt+apdi.amount
			list$[row]=webstr$
			row=row+1                                       
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])                                        
		Loop                                                      
	End If                                                      
	List$[row] = esdel$                                         
	Call AddToStr(e$,rstr$,List$[]) 
	clear list$[]
	list$[0]=bsdel$,"POSTAMT",fdel$
	webstr$=""
	webstr$=webstr$,"POSTINGAMOUNT",fdel$
	list$[1]=webstr$
	row=2
	if returnstatus=1
		webstr$=(postingamt using "-----------.##"),fdel$
		list$[row]=webstr$
		row=row+1
	endif
	List$[row] = esdel$                                         
	Call AddToStr(e$,rstr$,List$[])
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
  end try
end sub ! getapgldist

!--------------------------------------------------------------------
Sub submitapgldist() ! the apgl distributions
Try
	Call ValidateBatch() ! checks acct per & batch id
	if not(returnstatus) goto endsubapgldist:
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto endsubapgldist:
	Call Dxget("INVOICECODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto endsubapgldist:
	endif
	let transid$=rtrim$(tmp$)+blank$
	Call Dxget("TRANSTYPE",tmp$)
	let transtype=0
	if ucase$(rtrim$(Tmp$))="INV" let transtype=1
	if ucase$(rtrim$(Tmp$))="C/M" let transtype=2
	if ucase$(rtrim$(Tmp$))="M/C" let transtype=3
	IF not(transtype)
		let message$="Invalid Transaction Type Submitted"
		let returnstatus=0
		goto endsubapgldist: 
	endif
	let keyoi$=" ",keyoi$
	let keyoi$[1,6]=vendid using "######"
	let keyoi$[7,18]=transid$
	let keyoi$[19,20]=transtype using "##"
	search #ch_oi,2,1;keyoi$,rec_oi,e
	if e<>0
		let message$="Error A/P Transaction "+rtrim$(transid$)+" Not On File. "
		returnstatus=0
		goto endsubapgldist: !
	endif
	read record #ch_oi,rec_oi;oi.  
	If oi.StatusCode$<> "0"
		if oi.statuscode$<>"9" ! deleted
			let message$="A/P Transaction "+rtrim$(transid$)+" Is Invalid Status. May Not Edit."
			returnstatus=0
			goto endsubapgldist:
		endif
	endif
	If oi.BatchNumber <> batchid Or oi.PostingPeriod <> acctper               
		ReturnStatus = 0                                                        
		Message$ = "Transaction " + RTrim$(transid$) + "Entered in Batch " + Str$(oi.BatchNumber)+" May Not Edit."                                                     
		Goto endsubapgldist:!                                                        
	End If
	if oi.statuscode$<>"9"
		let keyoi$=" ",keyoi$
		let keyoi$[1,6]=vendid using "######"
		let keyoi$[7,18]=transid$
		let keyoi$[19,20]=transtype using "##"
		Search #CH_APDH,2,1;keyoi$,rec_apdh,e
		if e<>0
			let message$="A/P Transaction "+rtrim$(transid$)+" Is Not In History. May Not Update."
			returnstatus=0
			goto endsubapgldist:
		endif
	endif
	! delete existing acct distributions
	let keydi$=" ",keydi$
	let keydi$[1,5]=rec_oi using "#####"
	do
		search #ch_di,3,1;keydi$,rec_di,e
		if e>0 exit do
		let tmp3=keydi$[1,5]
		if tmp3<>rec_oi exit do
		search #ch_di,5,1;keydi$,rec_di,e \If e <> 0 Error (10000 + e) 
		let e=3\search #ch_di,1,0;keydi$,rec_di,e \If e <> 0 Error (10000 + e) 
		!mode$ = "d" ! delete transaction                                               
		!UpdStatus = fileupdateapa20di(e$,ch_di,mode$,rec_di,apdi.)
	loop
	if oi.statuscode$<>"9"
		keyapda$ = " ",keyapda$                                                   
		keyapda$[1,6] = rec_apdh Using "######"                                   
		Do                                                                        
			Search #CH_APDA,3,1;keyapda$,rec_apda,e                                 
			If e <> 0 Exit Do                                                       
			tmp3 = keyapda$[1,6]                                                    
			If tmp3 <> rec_apdh Exit Do  
			read record #ch_apda,rec_apda;apda.;
			if	apda.ApdethRec<> rec_apdh goto nxtapadel1:
			if	apda.Vendor<>vendid   goto nxtapadel1:
			if rtrim$(apda.InvoiceCode$)<>rtrim$(transid$ ) goto nxtapadel1: 
			Search #CH_APDA,5,1;keyapda$,rec_apda,e \ If e <> 0 Error (10000 + e)   
			e = 3 \ Search #CH_APDA,1,0;keyapda$,rec_apda,e \ If e <> 0 Error (10000 + e)  
			nxtapadel1: !
		Loop 
	endif
	let postingamt=0
	Call Dxget("TOTREC",tmp$)                                         
	totrec = tmp$                                                     
	If totrec < 0                                       
		message$ = "Invalid Number of Records for Submission"
		returnstatus = 0                                                
	        Goto EndSubAPGLDIST                                         
	EndIf 
	if totrec=0 and oi.grossinvoiceamount<>0
		message$ = "No Records Submitted for G/L Account Distributions"
		returnstatus = 0                                                
	        Goto EndSubAPGLDIST                                         
	EndIf 
	For ctr = 1 To totrec                    
		Call Dxget("GLACCTID" + Str$(ctr),tmp$) 
		dfltacctid=TMp$
		keyvl$=" ",keyvl$
		keyvl$[2,9]=dfltacctid using "########"
		search #ch_vl,2,1;keyvl$,rec_vl,e
		if e<>0
			message$ = "G/L Account "+str$(dfltacctid)+" Not on File. May Not Update."
			returnstatus = 0                                                
			Goto EndSubAPGLDIST
		endif
		IF C0[6]<>0 AND DEPT<>0 ! AP DIVISIONS SET UP WITH GL DEPARTMENT
			let tmp3=keyvl$[8,9]
			if oi.division<>tmp3 ! different division
				keyvl$=" ",keyvl$
				keyvl$[2,9]=dfltacctid using "########"
				keyvl$[8,9]=oi.division using "&&"
				search #ch_vl,2,1;keyvl$,rec_vl,e
				if e=0
					let returnstatus=2
					let message$="Warning! G/L Distribution Account is for another division."
				endif
			endif
		endif
		clear apdi.
		apdi.OIRec=rec_oi
		apdi.VendId=vendid
		apdi.InvCode$=transid$
		apdi.ItemNum=ctr ! counter
		apdi.Type=transtype
		apdi.AcctID=dfltacctid
		Call Dxget("GLAMOUNT" + Str$(ctr),tmp$)
		let tmp3=tmp$
		if fra(tmp3*100)<>0
			let returnstatus=0
			message$="Invalid Amount Submitted"
			Goto EndSubAPGLDIST
		endif
		if oi.statuscode$="9" let tmp3=tmp3*(-1)
		if transtype=2 let tmp3=tmp3*(-1)
		let apdi.Amount=tmp3
		Call Dxget("ALLOWEDIT"+Str$(ctr),tmp$)
		if ucase$(rtrim$(tmp$))="N" let apdi.auto=99 ! pogl
		if p61$[136,136]="Y" and oi.currfact<>0 and apdi.Amount<>0 
				let cnvcu[0]=2
				let cnvca[0]=apdi.Amount
				let cnvca[1]=oi.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let apdi.amount=fnr(cnvca[0])
		endif
		let postingamt=postingamt+apdi.Amount
		mode$ = "a" ! add                                                 
		UpdStatus = fileupdateapa20di(e$,ch_di,mode$,rec_di,apdi.)
		if oi.statuscode$<>"9"
			clear apda.
			apda.ApdethRec=rec_apdh
			apda.Vendor=vendid   
			apda.InvoiceCode$=transid$   
			apda.GLAccount=apdi.AcctId
			apda.Amount=apdi.Amount
			apda.TransactionType=transtype
			e = 2 \ Search #CH_APDa,1,0;keyapda$,rec_apda,e \ If e <> 0 Error (10000 + e)
			apda.ApdetaRec=rec_apda
			write record #ch_apda,rec_apda;apda.;
			let keyapda$=" ",keyapda$
			let keyapda$[1,6]=apda.ApdethRec using "######"
			let keyapda$[7,12]=apda.Vendor using "######"
			let keyapda$[13,18]=apda.ApdetaRec using "######"
			search #ch_apda,4,1;keyapda$,rec_apda,e\If e <> 0 Error (10000 + e)
		endif
	next ctr
	if oi.statuscode$="9"
		let oi.GrossInvoiceAmount=oi.GrossInvoiceAmount*(-1)
	endif
	if postingamt<>oi.GrossInvoiceAmount
		returnstatus = 0                                                
		message$ = "G/L Posting Amount "+str$(postingamt)+" Not Equal to Transaction "+str$(oi.GrossInvoiceAmount)
	endif
	endsubapgldist: ! 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
  end try
end sub ! submitapgldist
!=========================================================================================================
Sub verifypoid() ! verify po id
Try
	Dim 1%,appolist
	Dim 3%
	message$=""
	returnstatus=1 ! set to ok
	eflag=0
	Call ValidateBatch() ! checks acct per & batch id
	if not(returnstatus) goto endverifypoid:
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto endverifypoid:
	Call Dxget("POID",tmp$)
	let poid=tmp$
	if poid<0 or poid>999999
		let message$="Invalid Purchase Order Number Submitted"
		returnstatus=0
		goto endverifypoid:
	endif
	Call Dxget("INVOICECODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto endverifypoid:
	endif
	let transid$=rtrim$(tmp$)+blank$
	Call Dxget("TRANSTYPE",tmp$)
	let transtype=0
	if ucase$(rtrim$(Tmp$))="INV" let transtype=1
	if ucase$(rtrim$(Tmp$))="C/M" let transtype=2
	if ucase$(rtrim$(Tmp$))="M/C" let transtype=3
	IF not(transtype)
		let message$="Invalid Transaction Type Submitted"
		let returnstatus=0
		goto endverifypoid: 
	endif
	let keyoi$=" ",keyoi$
	let keyoi$[1,6]=vendid using "######"
	let keyoi$[7,18]=transid$
	let keyoi$[19,20]=transtype using "##"
	search #ch_oi,2,1;keyoi$,rec_oi,e
	if e<>0
		let message$="Error A/P Transaction "+rtrim$(transid$)+" Not On File. "
		returnstatus=0
		goto endverifypoid: !
	endif
	read record #ch_oi,rec_oi;oi.  
	If oi.StatusCode$<> "0"
		let message$="A/P Transaction "+rtrim$(transid$)+" Is Invalid Status. May Not Edit."
		returnstatus=0
		goto endverifypoid:
	endif
	if not(c0[4])
		let returnstatus=1
		let message$="A/P - PO Interface is not available"
		goto endverifypoid:
	endif
	Call Dxget("APPOLIST",tmp$)
	let appolist=0
	if rtrim$(ucase$(tmp$))="Y" let appolist=99
	MESSAGE$="OK"
	if oi.PoNumber<>0 and oi.PoNumber<>poid and appolist=0 ! check if po allocation exist and should be deleted
		let KEYAPPOH$=" ",KEYAPPOH$
		let KEYAPPOH$[1,6]=vendid using "######"
		let KEYAPPOH$[7,18]=transid$
		let KEYAPPOH$[19,20]=transtype using "##"                        
		let KEYAPPOH$[21,26]=oi.PoNumber USING "######"       
		SEARCH #CH_APPOH,2,1;KEYAPPOH$,REC_APPOH,E              
		IF NOT(E)
			!CALL DXGET("CONFIRMED",tmp$)
			!if ucase$(rtrim$(tmp$))<>"Y"
				returnstatus=3 ! ask to delete
				IF Rtrim$(ucase$(message$))="OK" let message$=""
				message$=message$+" AP transaction was originally allocated to " 
				IF transtype=2 let message$=message$+"DM# " ELSE  message$=message$+ "PO# "                        
				message$=message$+str$(oi.PoNumber) 
				if not(poid) goto endverifypoid:! prompt to delete po allocations
				!goto endverifypoid:
			!endif
		endif
	endif
	if not(poid)
		if appolist=0
			goto endverifypoid: !
		else
			let returnstatus=0
			let message$="No Purchase Order Number Submitted "
		endif
	endif
	LET keypoh$=" ",keypoh$ \ LET keypoh$[1,6]=vendid USING "######"    
	LET keypoh$[7,12]=poid USING "######"                       
	SEARCH #ch_poh,2,2;keypoh$,rec_poh,E
	if not(e) goto checkpodetail:                                         
	IF SPO                                                    
		LET keypoh$=" ",keypoh$;keypoh$[3,8]=poid USING "######"        
		IF TRANSTYPE=2                                               
			LET keypoh$[1,2]="14"                                    
			SEARCH #ch_poh,2,1;keypoh$,rec_poh,E    
			if e<>0
				eflag=eflag+1
				if appolist let returnstatus=0
				IF Rtrim$(ucase$(message$))="OK" let message$=""
				let message$=message$+" Debit Memo "+str$(poid)+" Not on File. "
				goto endverifypoid:
			endif
			
		ELSE                                                    
			FOR STAT=7 TO 1 STEP -1                               
				LET keypoh$[1,2]=STAT USING "##"                       
				SEARCH #ch_poh,2,1;keypoh$,rec_poh,E 
				if not(E) goto checkpodetail:                             
			NEXT STAT                                             
			LET keypoh$[1,2]="21"
			SEARCH #ch_poh,2,1;keypoh$,rec_poh,E                                           
			IF NOT(E)                                                             
				eflag=eflag+1
				IF Rtrim$(ucase$(message$))="OK" let message$=""
				message$=message$+" Purchase Order is In Unreceive Process "
				goto endverifypoid:
			ENDIF
			eflag=eflag+1
			if appolist let returnstatus=0
			IF Rtrim$(ucase$(message$))="OK" let message$=""
			message$=message$+" Purchase Order "+str$(poid)+" Not On File "
			goto endverifypoid: 
		ENDIF                                                                   
	ENDIF                                                                     
	checkpodetail: !              
	read record#ch_poh,rec_poh;poh.;                               
	LET KEYAPPOH$=" ",KEYAPPOH$                                               
	LET CHKKEY$[1,6]=vendid USING "######"                                     
	LET CHKKEY$[7,18]=TRANSID$[1,12]                                               
	LET CHKKEY$[19,20]=TRANSTYPE USING "##"
	do               
		SEARCH #ch_appoh,3,1;KEYAPPOH$,rec_appoh,E 
		IF e>0 exit do                                                                 
		IF KEYAPPOH$[1,20]<>CHKKEY$[1,20]                          
			LET CHKPONUM=KEYAPPOH$[21,26]                                             
			IF CHKPONUM=poid
				eflag=eflag+1
				IF Rtrim$(ucase$(message$))="OK" let message$=""
				message$="PO# "+str$(poid)+" Already in Process on AP Trans "+rtrim$(KEYAPPOH$[7,18])+" for Vendor "+KEYAPPOH$[1,6]+". "
				Mat Read #ctlc,51,88;poglflag;
				IF POGLFLAG<>0
					IF P60$[49,49]="F" OR P60$[49,49]="M" OR P60$[49,49]="B" 
						let returnstatus=0 ! cannot use this po# 
						message$=message$+" This Transaction needs to be Accept prior to Entry. " 
						goto endverifypoid:
					endif
				endif
			endif
		endif
	loop                 
	
	IF TRANSTYPE=2 
		IF POH.STATUS<11
			if returnstatus<> 3 let RETURNSTATUS=2
			IF Rtrim$(ucase$(message$))="OK" let message$=""
			message$=message$+"Debit Memo "+str$(poid)+" Does Not Exist. On File as a Purchase Order "
			goto endverifypoid:
		endif
		if poh.status<14
			eflag=eflag+1
			IF Rtrim$(ucase$(message$))="OK" let message$=""
			message$=message$+"Debit Memo "+str$(poid)+" Has Not Been Accepted."
			goto endverifypoid:
		endif
	else
		if poh.status>10 and poh.status<=14
			eflag=eflag+1
			IF Rtrim$(ucase$(message$))="OK" let message$=""
			message$=message$+"Purchase Order "+str$(poid)+ " Does Not Exist. On File as a Debit Memo "
			goto endverifypoid:
		endif
		if poh.status>90 and poh.status<91
			eflag=eflag+1
			IF Rtrim$(ucase$(message$))="OK" let message$=""
			message$=message$+"Purchase Order "+str$(poid)+ " In Edit/Receiving Process Elsewhere "
			goto endverifypoid:
		endif
		if poh.status=95
			eflag=eflag+1
			IF Rtrim$(ucase$(message$))="OK" let message$=""
			message$=message$+"Purchase Order "+str$(poid)+ " In Edit/Receiving Process Elsewhere "
			goto endverifypoid:
		endif
	endif                                   
	IF poh.VendorCode<>vendid                                                          
		dim povend. as a80vm
		keyvend$=" ",keyvend$
		keyvend$=poh.VendorCode using "######"
		mode$="=" ! search mode 2
		dir=1
		clear POvend.
		Rec_vend=filegeta80vm(e$,ch_vend,mode$,dir,keyvend$,POvend.)
		if rec_vend<0
			POVEND.NAME$="Vendor Not on File"
		endif
		IF Rtrim$(ucase$(message$))="OK" let message$=""
		message$=message$+" PO-DM belongs to Vendor "+str$(poh.vendorcode)+" "+rtrim$(povend.name$)
		eflag=eflag+1
         endif
                                         
	IF NOT (poh.LastRtsDate)! no receipt date                                           
		eflag=eflag+1
		IF Rtrim$(ucase$(message$))="OK" let message$=""
		message$=message$+" PO-DM has not yet been received"   
	endif
	IF poh.ClosedAp<>0                                                                 
		eflag=eflag+1
		IF Rtrim$(ucase$(message$))="OK" let message$=""
		message$=message$+" Purchase Order/Debit Memo has been closed for A/P"
	endif
        endverifypoid: ! 
	if eflag<>0
		if returnstatus=1 let returnstatus=2 ! warn to continue with the po
		!if returnstatus=3 let returnstatus=3 ! warn to continue with entered po and to delete existing po allocation
	endif
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
  end try
end sub ! verifypo
!=========================================================================================================
Sub verifycheckid() ! verify po id
Try
	message$=""
	returnstatus=1 ! set to ok
	Call ValidateBatch() ! checks acct per & batch id
	if not(returnstatus) goto endverifycheckid:
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto endverifycheckid:
	
	Call Dxget("INVOICECODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto endverifycheckid:
	endif
	let transid$=rtrim$(tmp$)+blank$
	Call Dxget("TRANSTYPE",tmp$)
	let transtype=0
	if ucase$(rtrim$(Tmp$))="INV" let transtype=1
	if ucase$(rtrim$(Tmp$))="C/M" let transtype=2
	if ucase$(rtrim$(Tmp$))="M/C" let transtype=3
	IF transtype<>3
		let message$="Invalid Transaction Type Submitted for this Action"
		let returnstatus=0
		goto endverifycheckid: 
	endif
	Call Dxget("CHECKNUMBER",tmp$)
	let Checkid=tmp$
	if checkid<0 or checkid>999999
		let message$="Invalid Check Number Submitted"
		returnstatus=0
		goto endverifycheckid:
	endif
	let keyoi$=" ",keyoi$
	let keyoi$[1,6]=vendid using "######"
	let keyoi$[7,18]=transid$
	let keyoi$[19,20]=transtype using "##"
	search #ch_oi,2,1;keyoi$,rec_oi,e
	if e<>0
		let message$="Error A/P Transaction "+rtrim$(transid$)+" Not On File. "
		returnstatus=0
		goto endverifycheckid: !
	endif
	read record #ch_oi,rec_oi;oi.  
	If oi.StatusCode$<> "0"
		let message$="A/P Transaction "+rtrim$(transid$)+" Is Invalid Status. May Not Edit."
		returnstatus=0
		goto endverifycheckid:
	endif
	if not(oi.PayToVendorCode) let oi.PayToVendorCode=oi.VendorCode
	LET KEYAPDH$=" ",KEYAPDH$                                                   
	LET KEYAPDH$[1,6]=oi.PayToVendorCode USING "######"                                     
	LET KEYAPDH$[7,12]=checkid USING "######"                                    
	LET KEYAPDH$[20,20]="9"                                                    
	SEARCH #ch_apdh,2,1;KEYAPDH$,Rec_apdh,E                     
	IF NOT(E)                                                            
		MESSAGE$="Check Number "+str$(checkid)+" Already Issued to Pay To Vendor "+str$(oi.PayToVendorCode)
		returnstatus=0
	endif
        endverifycheckid: !                                                                                                              
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
  end try
end sub ! verifychecknumber
!=========================================================================================================
Sub delorgpoalloc() ! Deletes original po allocations
Try
	message$=""
	returnstatus=1 ! set to ok
	Call ValidateBatch() ! checks acct per & batch id
	if not(returnstatus) goto enddelorgpoalloc:
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto enddelorgpoalloc:
	Call Dxget("POID",tmp$)
	let poid=tmp$
	if poid<0 or poid>999999
		let message$="Invalid Purchase Order Number Submitted"
		returnstatus=0
		goto enddelorgpoalloc:
	endif
	Call Dxget("INVOICECODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto enddelorgpoalloc:
	endif
	let transid$=rtrim$(tmp$)+blank$
	Call Dxget("TRANSTYPE",tmp$)
	let transtype=0
	if ucase$(rtrim$(Tmp$))="INV" let transtype=1
	if ucase$(rtrim$(Tmp$))="C/M" let transtype=2
	if ucase$(rtrim$(Tmp$))="M/C" let transtype=3
	IF not(transtype)
		let message$="Invalid Transaction Type Submitted"
		let returnstatus=0
		goto enddelorgpoalloc: 
	endif
	let keyoi$=" ",keyoi$
	let keyoi$[1,6]=vendid using "######"
	let keyoi$[7,18]=transid$
	let keyoi$[19,20]=transtype using "##"
	search #ch_oi,2,1;keyoi$,rec_oi,e
	if e<>0
		let message$="Error A/P Transaction "+rtrim$(transid$)+" Not On File. "
		returnstatus=0
		goto enddelorgpoalloc: !
	endif
	read record #ch_oi,rec_oi;oi.  
	If oi.StatusCode$<> "0"
		let message$="A/P Transaction "+rtrim$(transid$)+" Is Invalid Status. May Not Edit."
		returnstatus=0
		goto enddelorgpoalloc:
	endif
	if not(c0[4]) 
		message$="A/P - P/O Interface is not available "
		goto enddelorgpoalloc:
	endif
	if oi.PoNumber<>0 and oi.PoNumber<>poid ! check if po allocation exist and should be deleted
		Clear CHAN[]      
		CHAN[0] = CTLC    
		CHAN[1] = CH_OI   
		CHAN[2] = CH_APPOH
		CHAN[3] = CH_APPOL
		CHAN[4] = CH_POH  
		CHAN[5] = CH_POL  
		CHAN[6] = CH_POC  
		Call "la510d.dl4",CHAN[],oi.Ponumber,rec_oi,Message$,IntCo,rstr$,e$
	else
		returnstatus=0
		message$="Invalid Purchase Order Number for Delete"
	endif
        enddelorgpoalloc: !                                                                                                              
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
  end try
end sub ! delorgpoalloc
!=========================================================================================================
Sub GetAPPOLIST()
Try
	message$=""
	returnstatus=1 ! set to ok
	Call ValidateBatch() ! checks acct per & batch id
	if not(returnstatus) goto ENDAPPOLIST:
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto ENDAPPOLIST:
	Call Dxget("POID",tmp$)
	let poid=tmp$
	if poid<0 or poid>999999
		let message$="Invalid Purchase Order Number Submitted"
		returnstatus=0
		goto ENDAPPOLIST:
	endif
	Call Dxget("INVOICECODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto ENDAPPOLIST:
	endif
	let transid$=rtrim$(tmp$)+blank$
	Call Dxget("TRANSTYPE",tmp$)
	let transtype=0
	if ucase$(rtrim$(Tmp$))="INV" let transtype=1
	if ucase$(rtrim$(Tmp$))="C/M" let transtype=2
	if ucase$(rtrim$(Tmp$))="M/C" let transtype=3
	IF not(transtype)
		let message$="Invalid Transaction Type Submitted"
		let returnstatus=0
		goto ENDAPPOLIST: 
	endif
	let keyoi$=" ",keyoi$
	let keyoi$[1,6]=vendid using "######"
	let keyoi$[7,18]=transid$
	let keyoi$[19,20]=transtype using "##"
	search #ch_oi,2,1;keyoi$,rec_oi,e
	if e<>0
		let message$="Error A/P Transaction "+rtrim$(transid$)+" Not On File. "
		returnstatus=0
		goto ENDAPPOLIST: !
	endif
	read record #ch_oi,rec_oi;oi.  
	If oi.StatusCode$<> "0"
		let message$="A/P Transaction "+rtrim$(transid$)+" Is Invalid Status. May Not Edit."
		returnstatus=0
		goto ENDAPPOLIST:
	endif
	if not(c0[4])
		returnstatus=0
		message$="A/P - P/O Interface is not available "
		goto ENDAPPOLIST:
	endif
	ENDAPPOLIST: !
	clear list$[]
	list$[0]=bsdel$,"APPOLIST",fdel$
	webstr$="ID",fdel$,"AMOUNT",fdel$         
	List$[1] = WebStr$                                                    
	row = 2                                                               
	tmpcnt = maxcnt
	if returnstatus<>0
		LET KEYAPPOH$=" ",KEYAPPOH$                                               
		LET CHKKEY$[1,6]=vendid USING "######"                                     
		LET CHKKEY$[7,18]=TRANSID$[1,12]                                               
		LET CHKKEY$[19,20]=TRANSTYPE USING "##"
		LET KEYAPPOH$=" ",KEYAPPOH$
		let keyappoh$[1,20]=chkkey$[1,20]
		do               
			SEARCH #ch_appoh,3,1;KEYAPPOH$,rec_appoh,E 
			IF e>0 exit do                                                                 
			IF KEYAPPOH$[1,20]<>CHKKEY$[1,20] exit do
			read record #ch_appoh,rec_appoh;appoh.;
			webstr$=str$(appoh.PoID),fdel$
			let amount = appoh.TotAP+appoh.TotFrgt+appoh.TotMisc
			if p61$[136,136]="Y" and appoh.currfact<>0 and amount<>0  ! going for base to costing um
					let cnvcu[0]=1
					let cnvca[0]=amount
					let cnvca[1]=appoh.currfact
					let CNVCU[1]=1 ! no rounding
					call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
					let amount=fnr(cnvca[0])
			endif
			webstr$=webstr$+((amount) using "-----------.##"),fdel$ ! appoh.TotAP+appoh.TotFrgt+appoh.TotMisc
			List$[row] = WebStr$                                
			row = row + 1                                       
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])                                              
		Loop                                                    
     End If                                                    
     List$[row] = esdel$                                       
     Call AddToStr(e$,rstr$,List$[])                                                                                                                                        
     call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
     call AddToStr(e$,rstr$,WebStr$)
     call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
  end try
end sub ! 
!=====================================================================
!=========================================================================================================
Sub delpoalloc() ! Deletes  po allocations for an a/p invoice -- poid=0 will delete all allocations
Try
	message$=""
	returnstatus=1 ! set to ok
	Call ValidateBatch() ! checks acct per & batch id
	if not(returnstatus) goto enddelpoalloc:
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto enddelpoalloc:
	Call Dxget("POID",tmp$)
	let poid=tmp$
	if poid<0 or poid>999999
		let message$="Invalid Purchase Order Number Submitted"
		returnstatus=0
		goto enddelpoalloc:
	endif
	if poid=0 and rtrim$(tmp$)<>"0"
		let message$="Invalid Purchase Order Number Submitted"
		returnstatus=0
		goto enddelpoalloc:
	endif
	Call Dxget("INVOICECODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto enddelpoalloc:
	endif
	let transid$=rtrim$(tmp$)+blank$
	Call Dxget("TRANSTYPE",tmp$)
	let transtype=0
	if ucase$(rtrim$(Tmp$))="INV" let transtype=1
	if ucase$(rtrim$(Tmp$))="C/M" let transtype=2
	if ucase$(rtrim$(Tmp$))="M/C" let transtype=3
	IF not(transtype)
		let message$="Invalid Transaction Type Submitted"
		let returnstatus=0
		goto enddelpoalloc: 
	endif
	let keyoi$=" ",keyoi$
	let keyoi$[1,6]=vendid using "######"
	let keyoi$[7,18]=transid$
	let keyoi$[19,20]=transtype using "##"
	search #ch_oi,2,1;keyoi$,rec_oi,e
	if e<>0
		let message$="Error A/P Transaction "+rtrim$(transid$)+" Not On File. "
		returnstatus=0
		goto enddelpoalloc: !
	endif
	read record #ch_oi,rec_oi;oi.  
	If oi.StatusCode$<> "0"
		let message$="A/P Transaction "+rtrim$(transid$)+" Is Invalid Status. May Not Edit."
		returnstatus=0
		goto enddelpoalloc:
	endif
	if not(co[4]) 
		message$="A/P - P/O Interface is not available "
		goto enddelpoalloc:
	endif
	
	Clear CHAN[]      
	CHAN[0] = CTLC    
	CHAN[1] = CH_OI   
	CHAN[2] = CH_APPOH
	CHAN[3] = CH_APPOL
	CHAN[4] = CH_POH  
	CHAN[5] = CH_POL  
	CHAN[6] = CH_POC  
	Call "la510d.dl4",CHAN[],poid,rec_oi,Message$,IntCo,rstr$,e$
	
        enddelpoalloc: !                                                                                                              
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
  end try
end sub ! delorgpoalloc
!========================================================================================================
Sub verifyaptran(vendid) ! verify a/p transaction is on file ! 
Try
	Call Dxget("INVOICECODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto endverifyaptran:
	endif
	let transid$=rtrim$(tmp$)+blank$
	Call Dxget("TRANSTYPE",tmp$)
	let transtype=0
	if ucase$(rtrim$(Tmp$))="INV" let transtype=1
	if ucase$(rtrim$(Tmp$))="C/M" let transtype=2
	if ucase$(rtrim$(Tmp$))="M/C" let transtype=3
	IF not(transtype)
		let message$="Invalid Transaction Type Submitted"
		let returnstatus=0
		goto endverifyaptran:
	endif
	let keyoi$=" ",keyoi$
	let keyoi$[1,6]=vendid using "######"
	let keyoi$[7,18]=transid$
	let keyoi$[19,20]=transtype using "##"
	search #ch_oi,2,1;keyoi$,rec_oi,e
	if e<>0
		let message$="Error A/P Transaction "+rtrim$(transid$)+" Not On File. "
		returnstatus=0
		goto endverifyaptran: !
	endif
	read record #ch_oi,rec_oi;oi.  
	If oi.StatusCode$<> "0"
		let message$="A/P Transaction "+rtrim$(transid$)+" Is Invalid Status. May Not Edit."
		returnstatus=0
	endif
       endverifyaptran: !                                                                                                               
	
else
    include "src/callsuberr.inc"
  end try
end sub ! verify aptran

!=========================================================================================================
Sub getappohdr() ! for dispay of ap po header
Try
	dim 3%,totporec
	message$=""
	returnstatus=1 ! set to ok
	Call ValidateBatch() ! checks acct per & batch id
	if not(returnstatus) goto endgetappohdr:
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto endgetappohdr:
	Call Dxget("POID",tmp$)
	let poid=tmp$
	if poid<=0 or poid>999999
		let message$="Invalid Purchase Order Number Submitted"
		returnstatus=0
		goto endgetappohdr:
	endif
	call verifyaptran(vendid)
	if not (returnstatus) goto endgetappohdr:
	if not(c0[4]) 
		message$="A/P - P/O Interface is not available "
		goto endgetappohdr:
	endif
	let KEYAPPOH$=" ",KEYAPPOH$
	let KEYAPPOH$[1,6]=vendid using "######"
	let KEYAPPOH$[7,18]=transid$
	let KEYAPPOH$[19,20]=transtype using "##"                        
	let KEYAPPOH$[21,26]=oi.PoNumber USING "######"       
	SEARCH #CH_APPOH,2,1;KEYAPPOH$,REC_APPOH,E
	if not(e)
		read record #ch_appoh,rec_appoh;appoh.;
	else
		clear appoh.
	endif
	call FindAPPOID()
	endgetappohdr: ! 
	Clear List$[]                                                         
	List$[0] = bsdel$ + "POAddrInfo" + fdel$ ! section name
	webstr$="APTransID",fdel$
	webstr$=webstr$,"APAmount",fdel$
	webstr$=webstr$,"BuyName",fdel$
	webstr$=webstr$,"BuyAddr1",fdel$
	webstr$=webstr$,"BuyAddr2",fdel$
	webstr$=webstr$,"BuyCity",fdel$
	webstr$=webstr$,"BuyState",fdel$
	webstr$=webstr$,"BuyZip",fdel$
	webstr$=webstr$,"POVendId",fdel$
	webstr$=webstr$,"PoId",fdel$
	webstr$=webstr$,"ShipName",fdel$
	webstr$=webstr$,"ShipAddr1",fdel$
	webstr$=webstr$,"ShipAddr2",fdel$
	webstr$=webstr$,"ShipCity",fdel$
	webstr$=webstr$,"ShipState",fdel$
	webstr$=webstr$,"ShipZip",fdel$
	webstr$=Webstr$,"VendId",fdel$
	let list$[1]=webstr$
	row=2
	if returnstatus<>0 ! no errors send over the data
		webstr$=rtrim$(transid$),fdel$
		if transtype=2 let oi.grossinvoiceamount=oi.grossinvoiceamount*(-1)
		LET amount=oi.grossinvoiceamount
		if p61$[136,136]="Y" and OI.currfact<>0 and amount<>0  ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=oi.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=fnr(cnvca[0])
		endif
		webstr$=webstr$,(amount using "-----------.##"),fdel$ ! oi.grossinvoiceamount
		webstr$ = webstr$,RTRIM$(vend.name$),fdel$                              
		webstr$ = webstr$,RTRIM$(vend.address$),fdel$              
		webstr$ = webstr$,rtrim$(vend.optaddress$),fdel$           
		webstr$ = webstr$,rtrim$(vend.city$),fdel$                 
		webstr$ = webstr$,rtrim$(vend.state$),fdel$                
		webstr$ = webstr$,rtrim$(vend.zip$),fdel$     
		webstr$=webstr$,str$(poh.vendorcode),fdel$
		webstr$=webstr$,str$(poh.purchaseorder),fdel$ ! need to add level?
		webstr$=webstr$,rtrim$(poh.ShipToName$),fdel$
		webstr$=webstr$,rtrim$(poh.Address1$),fdel$                       
		webstr$=webstr$,rtrim$(poh.Address2$),fdel$                          
		webstr$=webstr$,rtrim$(poh.city$),fdel$
		webstr$=webstr$,rtrim$(poh.state$),fdel$
		webstr$=webstr$,rtrim$(poh.zipcode$),fdel$
		webstr$=Webstr$,str$(VendId),fdel$
		LIST$[2]=WEBSTR$
		row=row+1
	endif
	LIST$[row]=esdel$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	!Call AddToStr(e$,rstr$,esdel$) ! end of section
	Clear List$[]                                                         
	List$[0] = bsdel$ + "POHeaderInfo" + fdel$ ! section name
	webstr$="POVendId",fdel$
	webstr$=webstr$,"POId",fdel$
	webstr$=webstr$,"PODate",fdel$
	webstr$=webstr$,"DueDate",fdel$
	webstr$=webstr$,"VendorRef",fdel$
	webstr$=webstr$,"ShipViaId",fdel$
	webstr$=webstr$,"ShipViaDesc",fdel$
	webstr$=webstr$,"Routing",fdel$
	webstr$=webstr$,"Terms",fdel$
	Webstr$=webstr$,"FOB",fdel$
	webstr$=webstr$,"Confirmed",fdel$
	webstr$=webstr$,"ConfDate",fdel$
	webstr$=webstr$,"Type",fdel$
	webstr$=webstr$,"Typedesc",fdel$
	webstr$=webstr$,"Warehouse",fdel$
	webstr$=webstr$,"WarehouseDesc",fdel$
	webstr$=webstr$,"SalesOrder",fdel$
	webstr$=Webstr$,"VendId",fdel$
	let list$[1]=webstr$
	row=2
	if returnstatus<>0 ! no errors send over the data
		webstr$=str$(poh.vendorcode),fdel$
		webstr$=webstr$,str$(poh.purchaseorder),fdel$
		if poh.orderdate
			let xdate$=pdate$(poh.orderdate)
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! po date
		if Poh.duedate
			let xdate$=pdate$(poh.duedate)
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! due date
		WebStr$=WebStr$,RTrim$(poh.VendorRef$),fdel$ ! vendor ref #
		Webstr$=webstr$,str$(poh.shipviaid),fdel$ ! ship via id
		Webstr$=webstr$,rtrim$(poh.shipvia$),fdel$ ! ship via desc
		Webstr$=webstr$,rtrim$(poh.Routing$),fdel$ ! routing
		Webstr$=webstr$,rtrim$(poh.terms$),fdel$ ! terms
		Webstr$=webstr$,rtrim$(poh.fob$),fdel$ ! fob
		Webstr$=webstr$,rtrim$(poh.ConfirmName$),fdel$ ! confirmed
		if poh.ConfirmDate
			if poh.ConfirmDate<>999999
				let xdate$=pdate$(poh.ConfirmDate)
			else
				let xdate$="999999"
			endif
		else
			let xdate$=" ",xdate$
		endif
		WebStr$=WebStr$,RTrim$(xdate$),fdel$ ! ship date
		let tmp$=""
		if poh.type=0 let tmp$="W "
		if poh.type=1 let tmp$="D "
		if poh.type=2 let tmp$="I "
		Webstr$=webstr$,tmp$,fdel$ ! po type id
		let tmp$=""
		if poh.type=0 let tmp$="Warehouse"
		if poh.type=1 let tmp$="Direct"
		if poh.type=2 let tmp$="Indirect"
		Webstr$=webstr$,tmp$,fdel$ ! po type id description
		Webstr$=webstr$,str$(poh.warehouse),fdel$
		if poh.warehouse>0
			read record #ch_wh,(poh.warehouse-1);wh.; 
		else
			clear wh.
		endif
		Webstr$=webstr$,rtrim$(wh.whname$),fdel$
		Webstr$=webstr$,(poh.SalesOrder using "######"),fdel$
		webstr$=Webstr$,str$(VendId),fdel$
		let list$[2]=webstr$
		row=row+1
	endif
	let list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	! total section
	Clear List$[]                                                         
	List$[0] = bsdel$ + "POHDRTOT" + fdel$ ! section name
	webstr$="DESCRIPTION",fdel$
	webstr$=webstr$+"RVCD ON PO",fdel$
	webstr$=webstr$+"PREVIOUS AP",fdel$
	webstr$=webstr$+"CURRENT AP",fdel$
	webstr$=webstr$+"VARIANCE",fdel$
	LIST$[1]=webstr$ ! heading
	row=2
	if returnstatus=1
		IF P61$[60,60]="Y" AND POH.TotGlRec<>0
			LET TOTPOREC=POH.TotGlRec           
		ELSE                             
			 LET TOTPOREC=POH.TotPoRcvd             
		ENDIF 
		!!!! start
		if p61$[136,136]="Y" and oi.currfact<>0 and poh.currfact<>0
			let amount=totporec
			if poh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let totporec=fnr(cnvca[0])
			endif
			! MERCHANDISE
			let amount=POH.TotApMerchAppl
			if  poh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let POH.TotApMerchAppl=fnr(cnvca[0])
			endif
			let amount=poh.apamtpend
			if poh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let poh.apamtpend=fnr(cnvca[0])
			endif
			let amount=appoh.totap
			if  appoh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=appoh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let appoh.totap=fnr(cnvca[0])
			endif
			! FREIGHT
			let amount=POH.TotPoFreightRec
			if poh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let poh.TotPoFreightRec=fnr(cnvca[0])
			endif

			let amount=poh.freightapplpend
			if poh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let poh.freightapplpend=fnr(cnvca[0])
			endif
			let amount=appoh.totfrgt
			if appoh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=appoh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let appoh.totfrgt=fnr(cnvca[0])
			endif	
			! Misc Charges
			amount= POH.TotMiscCharges
			if  poh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let POH.TotMiscCharges=fnr(cnvca[0])
			endif	
			let amount=poh.miscapplpend
			if  poh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let poh.miscapplpend=fnr(cnvca[0])
			endif	
			let amount=appoh.totmisc
			if appoh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=appoh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let appoh.totmisc=fnr(cnvca[0])
			endif
		endif
		let poh.apamtpend=poh.apamtpend-appoh.totap
		let poh.freightapplpend=poh.freightapplpend-appoh.totfrgt
		let poh.miscapplpend= poh.miscapplpend-appoh.totmisc	
		! merchandise
		webstr$="MERCHANDISE",fdel$
		webstr$=webstr$+(totporec using  "###########.##"),fdel$ ! totporec
		webstr$=webstr$+((POH.TotApMerchAppl+POH.ApAmtPend) using  "###########.##"),fdel$ ! (POH.TotApMerchAppl+POH.ApAmtPend)
		webstr$=webstr$+(appoh.TotAP using  "###########.##"),fdel$ ! appoh.TotAP
		webstr$=webstr$+(((POH.TotApMerchAppl+POH.ApAmtPend+appoh.TotAP)-TOTPOREC) using  "-----------.##"),fdel$
		list$[2]=webstr$
		! freight
		webstr$="FREIGHT",fdel$
		webstr$=webstr$+(POH.TotPoFreightRec using  "###########.##"),fdel$
		webstr$=webstr$+((POH.TotFreightAppl+POH.FreightApplPend) using  "###########.##"),fdel$
		webstr$=webstr$+(appoh.TotFrgt using  "###########.##"),fdel$
		webstr$=webstr$+(((POH.TotFreightAppl+POH.FreightApplPend+appoh.TotFrgt)-POH.TotPoFreightRec) using  "-----------.##"),fdel$
		list$[3]=webstr$   
		! misc charge
		webstr$="MISC CHARGE",fdel$
		webstr$=webstr$+(POH.TotMiscCharges using  "###########.##"),fdel$
		webstr$=webstr$+((POH.TotMiscAppl+POH.MiscApplPend) using  "###########.##"),fdel$
		webstr$=webstr$+(appoh.TotMisc using  "###########.##"),fdel$
		webstr$=webstr$+(((POH.TotMiscAppl+POH.MiscApplPend+appoh.TotMisc)-POH.TotMiscCharges) using  "-----------.##"),fdel$
		list$[4]=webstr$
		! totals
		webstr$="TOTALS",fdel$
		let tmp3=totporec+POH.TotPoFreightRec+POH.TotMiscCharges ! po received
		webstr$=webstr$+(tmp3 using  "###########.##"),fdel$
		tmp3=POH.TotApMerchAppl+POH.ApAmtPend+POH.TotFreightAppl+POH.FreightApplPend+POH.TotMiscAppl+POH.MiscApplPend ! prev ap amount
		webstr$=webstr$+(tmp3 using  "###########.##"),fdel$ 
		tmp3=appoh.TotAP+appoh.TotFrgt+appoh.TotMisc ! current a/p amounts
		webstr$=webstr$+(tmp3 using  "###########.##"),fdel$
		tmp3=((POH.TotApMerchAppl+POH.ApAmtPend+appoh.TotAP)-TOTPOREC)! PO RCVD
		TMP3=TMP3+((POH.TotFreightAppl+POH.FreightApplPend+appoh.TotFrgt)-POH.TotPoFreightRec) ! PREV
		TMP3=TMP3+((POH.TotMiscAppl+POH.MiscApplPend+appoh.TotMisc)-POH.TotMiscCharges) ! CURR
		webstr$=webstr$+(tmp3 using  "-----------.##"),fdel$
		list$[5]=webstr$
		row=6
	endif
	list$[row]=esdel$ ! end of section
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	!call AddToStr(e$,rstr$,WebStr$)
	!Call AddToStr(e$,rstr$,esdel$) ! end of section
	If returnstatus=1 let message$="OK"
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
  end try
end sub ! getappohdr
 
!=========================================================================================================
Sub getappotot() ! for display of ap po total
Try
	dim openmsg$[200]
	dim 1%,defcloseflag,openflag
	dim 3%,totporec
	dim appoht. as appoh
	message$=""
	returnstatus=1 ! set to ok
	Call ValidateBatch() ! checks acct per & batch id
	if not(returnstatus) goto endgetappotot:
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto endgetappotot:
	Call Dxget("POID",tmp$)
	let poid=tmp$
	if poid<=0 or poid>999999
		let message$="Invalid Purchase Order Number Submitted"
		returnstatus=0
		goto endgetappotot:
	endif
	call verifyaptran(vendid)
	if not (returnstatus) goto endgetappotot:
	if not(c0[4]) 
		message$="A/P - P/O Interface is not available "
		goto endgetappotot:
	endif
	let KEYAPPOH$=" ",KEYAPPOH$
	let KEYAPPOH$[1,6]=vendid using "######"
	let KEYAPPOH$[7,18]=transid$
	let KEYAPPOH$[19,20]=transtype using "##"                        
	!let KEYAPPOH$[21,26]=oi.PoNumber USING "######"  
	let KEYAPPOH$[21,26]=poid USING "######"
	SEARCH #CH_APPOH,2,1;KEYAPPOH$,REC_APPOH,E
	if not(e)
		read record #ch_appoh,rec_appoh;appoh.;
		mat Read #ch_appoh,rec_appoh,48;aph3;
		mat read #ch_appoh,rec_appoh,58;aph4;
	else
		rec_appoh=-1
		clear appoh.
		for ctr=0 to 4
			let aph3[ctr]=0
			let aph4[ctr]=0
		next ctr
	endif
	call FindAPPOID()
	let defcloseflag=99
	let openflag=0
	let openmsg$=""
	if poh.status<7
		let openflag=1
		let openmsg$="PO Still Open For Receipts To Stock "
		let defcloseflag=0
	endif
	keypoc$=" ",keypoc$
	keypoc$[1,6]=poid using "######"
	do
		search #ch_poc,3,1;keypoc$,rec_poc,e
		if e<>0 exit do
		let tmp3=keypoc$[1,6]\if tmp3<>poid exit do
		read record #ch_poc,rec_poc;poc.;  
  		if poc.APClose>=87 AND poc.ApClose<=89 goto nxtpoctran: ! in unreceive process
		if poglflag<>0
			if poc.APClose>=97 AND poc.ApClose<=99 goto nxtpoctran: ! 543 manual cntrl# close
		endif
		! get the poline
		let keypol$=" ",keypol$
		let keypol$[1,6]=poid using "######"
		let keypol$[7,9]=poc.LineNum using "###"
		let keypol$[10]=""
		rec_pol = filegetpoline(e$,ch_pol,"=",1,keypol$,pol.)
		if rec_pol<=0 goto nxtpoctran                
		! find an appol record
		LET keyappol$=" ",keyappol$                                   
		LET keyappol$[1,6]=vendid USING "######" \ LET keyappol$[7,18]=transid$[1,12]       
		LET keyappol$[19,20]=transtype USING "##" \ LET keyappol$[21,26]=poid USING "######"
		LET keyappol$[27,29]=poc.LineNum USING "###"                                   
		LET keyappol$[30,35]=POC.CntrlNum USING "######"                              
		SEARCH #ch_appol,2,1;keyappol$,rec_appol,E 
		if e=0 ! does not exist 
			read record #ch_appol,rec_appol;appol.;	
			if pol.CloseAp=0 and appol.APClose=0
				let openflag=openflag+1
				let openmsg$=openmsg$+" Lines are still open for Accounts Payable. "
				let defcloseflag=0
				exit do
			endif
		else
			let openflag=openflag+1
			let openmsg$=openmsg$+" Lines are still open for Accounts Payable. "
			let defcloseflag=0
			exit do	
		endif
		nxtpoctran: ! 
	LOOP
	endgetappotot: ! 
	Clear List$[]                                                         
	List$[0] = bsdel$ + "POTotalInfo" + fdel$ ! section name
	webstr$="APTransID",fdel$
	webstr$=webstr$,"APAmount",fdel$
	webstr$=webstr$,"BuyName",fdel$
	webstr$=webstr$,"POVendID",fdel$
	webstr$=webstr$,"POID",fdel$
	webstr$=webstr$,"ShipName",fdel$
	webstr$=webstr$,"TotalRcvd",fdel$
	webstr$=webstr$,"PrevAppld",fdel$
	webstr$=webstr$,"CurrAppld",fdel$
	webstr$=webstr$,"AcctPayAmt",fdel$
	webstr$=webstr$,"Applied",fdel$
	webstr$=webstr$,"Variance",fdel$
	webstr$=webstr$,"FreightPO",fdel$
	webstr$=webstr$,"FreightPrev",fdel$
	webstr$=webstr$,"FreightCurr",fdel$ ! *****
	webstr$=webstr$,"FreightVar",fdel$
	webstr$=webstr$,"MiscChrgPO",fdel$
	webstr$=webstr$,"MiscChrgPrev",fdel$
	webstr$=webstr$,"MiscChrgCurr",fdel$
	webstr$=webstr$,"MiscChrgVar",fdel$
	webstr$=webstr$,"VendorID",fdel$
	webstr$=webstr$,"DefaultClose",fdel$
	webstr$=webstr$,"OpenStat",fdel$
	webstr$=webstr$,"OpenMsg",fdel$
	let list$[1]=webstr$
	row=2
	if returnstatus<>0 ! no errors send over the data
		IF P61$[60,60]="Y" AND POH.TotGlRec<>0
			LET TOTPOREC=POH.TotGlRec           
		ELSE                             
			 LET TOTPOREC=POH.TotPoRcvd             
		ENDIF 
		if p61$[136,136]="Y" and oi.currfact<>0 
			let amount=totporec
			if poh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let totporec=fnr(cnvca[0])
			endif
			! MERCHANDISE
			let amount=POH.TotApMerchAppl
			if  poh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let POH.TotApMerchAppl=fnr(cnvca[0])
			endif
			let amount=poh.apamtpend
			if poh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let poh.apamtpend=fnr(cnvca[0])
			endif
			let amount=appoh.totap
			if  appoh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=appoh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let appoh.totap=fnr(cnvca[0])
			endif
			! FREIGHT
			let amount=POH.TotPoFreightRec
			if poh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let poh.TotPoFreightRec=fnr(cnvca[0])
			endif

			let amount=poh.freightapplpend
			if poh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let poh.freightapplpend=fnr(cnvca[0])
			endif
			let amount=appoh.totfrgt
			if appoh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=appoh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let appoh.totfrgt=fnr(cnvca[0])
			endif	
			! Misc Charges
			amount= POH.TotMiscCharges
			if  poh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let POH.TotMiscCharges=fnr(cnvca[0])
			endif	
			let amount=poh.miscapplpend
			if  poh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let poh.miscapplpend=fnr(cnvca[0])
			endif	
			let amount=appoh.totmisc
			if appoh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=appoh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let appoh.totmisc=fnr(cnvca[0])
			endif
		endif
		let poh.apamtpend=poh.apamtpend-appoh.totap
		let poh.freightapplpend=poh.freightapplpend-appoh.totfrgt
		let poh.miscapplpend= poh.miscapplpend-appoh.totmisc	
		totappld=0
		LET KEYAPPOH$=" ",KEYAPPOH$                                               
		LET CHKKEY$[1,6]=vendid USING "######"                                     
		LET CHKKEY$[7,18]=TRANSID$[1,12]                                               
		LET CHKKEY$[19,20]=TRANSTYPE USING "##"
		
		eflag=0
		LET KEYAPPOH$=" ",KEYAPPOH$
		let keyappoh$[1,20]=chkkey$[1,20]
		do               
			SEARCH #ch_appoh,3,1;KEYAPPOH$,rec_appoh,E 
			IF e>0 exit do                                                                 
			IF KEYAPPOH$[1,20]<>CHKKEY$[1,20] exit do                         
			read record #ch_appoh,rec_appoh;appoht.;
			let amount=appoht.TotAP
			if p61$[136,136]="Y" and appoht.currfact<>0 and amount<>0 and oi.currfact<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=appoht.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let appoht.TotAP=fnr(cnvca[0])
			endif
			let amount=appoht.TotFrgt
			if p61$[136,136]="Y" and appoht.currfact<>0 and amount<>0 and oi.currfact<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=appoht.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let appoht.TotFrgt=fnr(cnvca[0])
			endif
			let amount=appoht.TotMisc
			if p61$[136,136]="Y" and appoht.currfact<>0 and amount<>0  and oi.currfact<>0! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=appoht.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let appoht.TotMisc=fnr(cnvca[0])
			endif
			let totappld=totappld+appoht.TotAP+appoht.TotFrgt+appoht.TotMisc	
		loop                 

		webstr$=rtrim$(transid$),fdel$
		if transtype=2 let oi.grossinvoiceamount=oi.grossinvoiceamount*(-1) ! reverse sign
		let amount=oi.grossinvoiceamount
		if p61$[136,136]="Y" and oi.currfact<>0 and amount<>0  ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=oi.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let oi.grossinvoiceamount=fnr(cnvca[0])
		endif
		webstr$=webstr$,(oi.grossinvoiceamount using "-----------.##"),fdel$
		webstr$ = webstr$,RTRIM$(vend.name$),fdel$
		webstr$=webstr$,str$(poh.vendorcode),fdel$
		webstr$=webstr$,str$(poh.purchaseorder),fdel$ ! need to add level?
		webstr$=webstr$,rtrim$(poh.ShipToName$),fdel$
		webstr$=webstr$,(totporec using  "###########.##"),fdel$ ! total rcvd
		webstr$=webstr$,((POH.TotApMerchAppl+POH.ApAmtPend) using  "###########.##"),fdel$ ! prev rec
		webstr$=webstr$,(appoh.TotAP using  "###########.##"),fdel$ ! currappld
		webstr$=webstr$,(oi.grossinvoiceamount using "-----------.##"),fdel$ !AcctPayAmt
		webstr$=webstr$,(totappld using "-----------.##"),fdel$ ! Applied 
		webstr$=webstr$,((oi.grossinvoiceamount-totappld) using "-----------.##"),fdel$ 
		webstr$=webstr$+(POH.TotPoFreightRec using  "-----------.##"),fdel$ ! po freight
		webstr$=webstr$+((POH.TotFreightAppl+POH.FreightApplPend) using  "-----------.##"),fdel$ ! prev freight
		webstr$=webstr$+(appoh.TotFrgt using  "-----------.##"),fdel$ ! curr freight
		webstr$=webstr$+(((POH.TotFreightAppl+POH.FreightApplPend+appoh.TotFrgt)-POH.TotPoFreightRec) using  "-----------.##"),fdel$ ! var
		webstr$=webstr$+(POH.TotMiscCharges using  "-----------.##"),fdel$
		webstr$=webstr$+((POH.TotMiscAppl+POH.MiscApplPend) using  "-----------.##"),fdel$
		webstr$=webstr$+(appoh.TotMisc using  "-----------.##"),fdel$
		webstr$=webstr$+(((POH.TotMiscAppl+POH.MiscApplPend+appoh.TotMisc)-POH.TotMiscCharges) using  "-----------.##"),fdel$
		webstr$=webstr$+str$(vendid),fdel$
		let tmp$="Y" 
		if not(defcloseflag) let tmp$="N"
		webstr$=webstr$,tmp$,fdel$
		let tmp$="N"
		if openflag<>0 let tmp$="Y"
		webstr$=webstr$,tmp$,fdel$
		webstr$=webstr$,rtrim$(OpenMsg$),fdel$
		LIST$[2]=WEBSTR$
		row=row+1
	endif
	LIST$[row]=esdel$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	!Call AddToStr(e$,rstr$,esdel$) ! end of section
	Clear List$[]                                                         
	List$[0] = bsdel$ + "POTotalMisc" + fdel$ ! section name
	webstr$="MiscCode",fdel$
	webstr$=webstr$,"Description",fdel$
	webstr$=webstr$,"MiscAmount",fdel$
	let list$[1]=webstr$
	row=2
	if returnstatus<>0 ! no errors send over the data
		for ctr=0 to 4
			if aph3[ctr]<>0
				webstr$=str$(aph3[ctr]),fdel$
				read record #ch_misc,aph3[ctr];misc.;
				let tmp$=misc.desc$
				webstr$=webstr$+Rtrim$(tmp$)+fdel$
				webstr$=webstr$+ Rtrim$(aph4[ctr] Using "-----------.##") + fdel$
				list$[row]=webstr$
				row=row+1
			endif
		next ctr
	endif
	let list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	! status section
	If returnstatus=1 let message$="OK"
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
  end try
end sub ! getappotot
!!!=========================== submitappotot ===================================
Sub submitappotot() ! for display of ap po total
Try
	dim 3%,totporec
	dim appoht. as appoh
	message$=""
	returnstatus=1 ! set to ok
	Call ValidateBatch() ! checks acct per & batch id
	if not(returnstatus) goto endsubappotot:
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto endsubappotot:
	Call Dxget("POID",tmp$)
	let poid=tmp$
	if poid<=0 or poid>999999
		let message$="Invalid Purchase Order Number Submitted"
		returnstatus=0
		goto endsubappotot:
	endif
	call verifyaptran(vendid)
	if not (returnstatus) goto endsubappotot:
	if not(c0[4]) 
		message$="A/P - P/O Interface is not available "
		goto endsubappotot:
	endif
	let KEYAPPOH$=" ",KEYAPPOH$
	let KEYAPPOH$[1,6]=vendid using "######"
	let KEYAPPOH$[7,18]=transid$
	let KEYAPPOH$[19,20]=transtype using "##"                        
	!Let KEYAPPOH$[21,26]=oi.PoNumber USING "######"
	let KEYAPPOH$[21,26]=poid USING "######"
	SEARCH #CH_APPOH,2,1;KEYAPPOH$,REC_APPOH,E
	if not(e)
		read record #ch_appoh,rec_appoh;appoh.;
		mat Read #ch_appoh,rec_appoh,48;aph3;
		mat read #ch_appoh,rec_appoh,58;aph4;
		mat read #ch_appoh,rec_appoh,88;aph5;
	else
		rec_appoh=-1
		clear appoh.
		for ctr=0 to 4
			let aph3[ctr]=0
			let aph4[ctr]=0
			let aph5=0
		next ctr
		if p61$[136,136]="Y" and apbth.currid<>0 ! and oi.PONumber<>0
			let appoh.currid=oi.currid
			let appoh.currfact=oi.currfact
		endif
	endif
	call FindAPPOID()
	
	endsubappotot: ! 
	! take totals out of the po header file
	if p61$[136,136]="Y" and poh.currfact<>appoh.currfact and oi.currfact<>0
			let amount=poh.freightapplpend
			if poh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let poh.freightapplpend=fnr(cnvca[0])
			endif
			let amount=appoh.totfrgt
			if appoh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=appoh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let appoh.totfrgt=fnr(cnvca[0])
			endif	
			! Misc Charges
			let amount=poh.miscapplpend
			if  poh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let poh.miscapplpend=fnr(cnvca[0])
			endif
			let amount=appoh.totmisc
			if appoh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=appoh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let appoh.totmisc=fnr(cnvca[0])
			endif
	endif
	POH.FreightApplPend=POH.FreightApplPend-appoh.TotFrgt 
	POH.MiscApplPend=POH.MiscApplPend-appoh.TotMisc
	if p61$[136,136]="Y" and poh.currfact<>appoh.currfact and oi.currfact<>0
		let amount=poh.freightapplpend
		if poh.currfact<>0 and amount<>0  ! going for base to costing um
			let cnvcu[0]=2
			let cnvca[0]=amount
			let cnvca[1]=poh.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let poh.freightapplpend=fnr(cnvca[0])
		endif
		let amount=poh.miscapplpend
		if  poh.currfact<>0 and amount<>0  ! going for base to costing um
			let cnvcu[0]=2
			let cnvca[0]=amount
			let cnvca[1]=poh.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let poh.miscapplpend=fnr(cnvca[0])
		endif
	endif
	appoh.TotFrgt=0
	appoh.TotMisc=0

	Call Dxget("FreightCurr",tmp$)
	let appoh.totfrgt=tmp$ !
	if p61$[136,136]="Y" and oi.currfact<>0
		let amount=appoh.totfrgt
		if appoh.currfact<>0 and amount<>0  !  
			let cnvcu[0]=2
			let cnvca[0]=amount
			let cnvca[1]=appoh.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let appoh.totfrgt=fnr(cnvca[0])
		endif	
	endif
	Call Dxget("APCLOSE",tmp$)
	let appoh.APClose=0
	if UCASE$(RTRIM$(tmp$))="Y" let appoh.ApClose=1
	for ctr=1 to 5 ! for misc charges
		let aph3[ctr-1]=0
		let aph4[ctr-1]=0
		call dxget ("MiscCode"+str$(ctr),tmp$)
		let aph3[ctr-1]=tmp$
		if aph3[ctr-1]<>0 ! code submitted
			call dxget("MiscAmount"+str$(ctr),tmp$)
			let aph4[ctr-1]=tmp$
			if p61$[136,136]="Y" and oi.currfact<>0
				let amount=aph4[ctr-1]
				if appoh.currfact<>0 and amount<>0  ! going for base to costing um
					let cnvcu[0]=2
					let cnvca[0]=amount
					let cnvca[1]=appoh.currfact
					let CNVCU[1]=1 ! no rounding
					call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
					let aph4[ctr-1]=fnr(cnvca[0])
				endif	
			endif
			appoh.TotMisc=appoh.TotMisc+aph4[ctr-1]
		else
			call dxget("MiscAmount"+str$(ctr),tmp$)
			let aph4[ctr-1]=tmp$
			if aph4[ctr-1]<>0
				let returnstatus=0
				Let message$="Misc Charge Submitted Without Code"
				goto endsubappotot1:
			endif
		endif
	next ctr
	write record #ch_appoh,rec_appoh;appoh.;
	mat write #ch_appoh,rec_appoh,48;aph3;
	mat write #ch_appoh,rec_appoh,58;aph4;
	if p61$[136,136]="Y" and poh.currfact<>appoh.currfact and oi.currfact<>0
			let amount=poh.freightapplpend
			if poh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let poh.freightapplpend=fnr(cnvca[0])
			endif
			let amount=appoh.totfrgt
			if appoh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=appoh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let appoh.totfrgt=fnr(cnvca[0])
			endif	
			! Misc Charges
			let amount=poh.miscapplpend
			if  poh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=poh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let poh.miscapplpend=fnr(cnvca[0])
			endif
			let amount=appoh.totmisc
			if appoh.currfact<>0 and amount<>0  ! going for base to costing um
				let cnvcu[0]=1
				let cnvca[0]=amount
				let cnvca[1]=appoh.currfact
				let CNVCU[1]=1 ! no rounding
				call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
				let appoh.totmisc=fnr(cnvca[0])
			endif
	endif
	POH.FreightApplPend=POH.FreightApplPend+appoh.TotFrgt 
	POH.MiscApplPend=POH.MiscApplPend+appoh.TotMisc
	if p61$[136,136]="Y" and poh.currfact<>appoh.currfact  and oi.currfact<>0! bring it back to base
		let amount=poh.freightapplpend
		if poh.currfact<>0 and amount<>0  ! going for base to costing um
			let cnvcu[0]=2
			let cnvca[0]=amount
			let cnvca[1]=poh.currfact
			let CNVCU[1]=1
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let poh.freightapplpend=fnr(cnvca[0])
		endif
		let amount=poh.miscapplpend
		if  poh.currfact<>0 and amount<>0  ! going for base to costing um
			let cnvcu[0]=2
			let cnvca[0]=amount
			let cnvca[1]=poh.currfact
			let CNVCU[1]=1
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let poh.miscapplpend=fnr(cnvca[0])
		endif
	endif
	write record#ch_poh,rec_poh;poh.;
	!!!!! CALCULATE misc/freight for lines 
	Clear chan[]! 
	CHAN[0]=CH_APPOH
	CHAN[1]=CH_APPOL
	CHAN[2]=CH_POC
	CHAN[3]=CH_POH
	CHAN[4]=CH_POL
	CHAN[5]=0! NOT USED 
	CHAN[6]=0! NOT USED
	CHAN[7]=0! NOT USED
	CHAN[8]=0! NOT USED
	CHAN[9]=CH_PROD
	CHAN[10]=CH_WH
	CHAN[11]=CH_MISC
	CHAN[12]=CH_NSTCK	
	CHAN[20]=CTLC                            
	SRC=510                                               
	CALL "LAUPDCHRG.DL4",CHAN[],VENDID,POH.VENDorcode,TRANSID$,TRANSTYPE,poid,SRC,MESSAGE$,IntCo,rstr$,RETURNSTATUS
	! status section
	If returnstatus=1 let message$="OK"
	endsubappotot1: ! 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
  end try
end sub ! submitappotot
!
!--------------------------------------------------------------------
Sub Factorum(tmp$)
! from sent factor (in tmp$) - get um text for it
! if no match - send factor back as um
 Try
	dim um$[4]
	dim 1%,umrec
	dim 3%,factor
	let factor=tmp$
	if factor<=0 let factor=1
	umrec=0
	if factor=pr.UM2Fact let umrec=PR.UM2
	if factor=pr.UM3Fact let umrec=PR.UM3
	if factor=pr.UM4Fact let umrec=PR.UM4
	if factor=pr.UM5Fact let umrec=PR.UM5
	if factor=pr.UM6Fact let umrec=PR.UM6
	if factor=pr.UM7Fact let umrec=PR.UM7
	if factor=pr.UM8Fact let umrec=PR.UM8
	If factor=1 let umrec=pr.BaseUM
	if umrec>0
		Read record #ccc,umrec,0;UMC.;
		let tmp$=umc.Code$ ! send back um attached
	Else
		if factor=1000 ! hardcode an "M"?
			tmp$="M" ! why not
		Else
			Let tmp$=Str$(Factor) ! send back w/no um (factor instead of um)
		Endif
	Endif
 else
    include "src/callsuberr.inc"
  end try
end sub ! Factorum
!--------------------------------------------------------------------
Sub SetPRtoPol()
! set up prod (PR.) with line values (stock & NonStock)
 Try
	Dim 1%,PFU1[20]
	Dim 3%,PFU2[6]
	IF ZLINE GOTO L30099:    ! stock factors 
	if NonStk<>0
		let rec_nstk=pol.ProdDescRec
		read record #ch_nstk,rec_nstk;nstk.;
		clear pr.                                             
		pr.baseum=nstk.BaseUM ! nsd1[2]
		pr.um2=nstk.CostUM !    nsd1[3]
		pr.um3=nstk.PurchUM !nsd1[4]
		pr.um4=nstk.StockUM !nsd1[5]
		pr.UMStkDefault = nstk.StockUM ! NSD1[5]
		pr.UMPurchDefault=nstk.PurchUM ! NSD1[4]
		pr.UMCostDefault= nstk.CostUM  ! NSD1[3]
		pr.UM2Fact=nstk.CostFact !nsd3[3]
		pr.UM3Fact=nstk.POFact !nsd3[4]
		pr.UM4Fact=nstk.StkFact !nsd3[5]                                             
		pr.LbsFact=nstk.WgtFact !NSD3[7]
		pr.LbsUnit=nstk.Wgt  !NSD3[6]  
		IF NOT(pr.LbsUnit) LET pr.LbsUnit=1;pol.LbsFactor=1    
		LET pr.CubicFeet=nstk.Cube;pr.CubicFtFactor=nstk.CubeFact
		IF NOT(pr.CubicFtFactor) LET pr.CubicFtFactor=1;pol.CbfFactor=1
		pr.comdtycode$=nstk.cmdtycode$
		pr.RollLbItem$="N"                          
		LET pr.UM5=0                                          
		LET pr.UM6=0;pr.UM7=0;pr.UM8=0
		CHGSTK=0
		                                  
		
	endif
	! below gets rid of dupes - not easy with names - so load into pfu1,pfu2
	PFU1[0]=pr.BaseUM
	pfu1[1]=pr.UM2;PFU2[0]=pr.UM2Fact
	Pfu1[2]=pr.UM3;pfu2[1]=pr.UM3Fact
	pfu1[3]=pr.UM4;pfu2[2]=pr.UM4Fact
	pfu1[4]=pr.UM5;pfu2[3]=pr.UM5Fact
	FOR X1=1 TO 4                                                   
		FOR X2=0 TO X1-1                                              
			IF PFU1[X1]=PFU1[X2] LET PFU1[X1]=0;PFU2[X1-1]=0            
		NEXT X2                                                       
	NEXT X1 
	! now reload checked um's to names
	pr.BaseUM=PFU1[0]
	pr.UM2=pfu1[1];pr.UM2Fact=PFU2[0]
	pr.UM3=Pfu1[2];pr.UM3Fact=pfu2[1]
	pr.UM4=pfu1[3];pr.UM4Fact=pfu2[2]
	pr.UM5=pfu1[4];pr.UM5Fact=pfu2[3]
	L30099: ! finito	
 else
    include "src/callsuberr.inc"
 end try
end sub ! SetPRtoPol
!
!---------------------------------------------------------------------
Sub FindVendPo(vendid,poid,foundpovend)
Try
	LET keypoh$=" ",keypoh$ \ LET keypoh$[1,6]=vendid USING "######"    
	LET keypoh$[7,12]=poid USING "######"                       
	SEARCH #ch_poh,2,2;keypoh$,rec_poh,E
	if not(e) 
		let foundpovend=99 ! found for vendor/
		goto foundvendpo: 
	endif                                                                                        
	LET keypoh$=" ",keypoh$;keypoh$[3,8]=poid USING "######"                                                    
	LET keypoh$[1,2]="14"                                    
	SEARCH #ch_poh,2,1;keypoh$,rec_poh,E    
	if e=0
		let foundpovend=98 ! debit memo
		goto foundvendpo:
	endif                                   
	FOR STAT=7 TO 1 STEP -1                               
		LET keypoh$[1,2]=STAT USING "##"                       
		SEARCH #ch_poh,2,1;keypoh$,rec_poh,E 
		if not(E) 
			let foundpovend=97 ! vendor for another/po found
           	goto foundvendpo:
		endif           
	NEXT STAT                                             
	LET keypoh$[1,2]="21"
	SEARCH #ch_poh,2,1;keypoh$,rec_poh,E                                           
	IF NOT(E)                                                             
		foundpovend=96 ! in unreceive prodcess
		goto foundvendpo:
	endif
	fOR STAT=99 TO 90 STEP -1                               
		LET keypoh$[1,2]=STAT USING "##"                       
		SEARCH #ch_poh,2,1;keypoh$,rec_poh,E 
		if not(E) 
			let foundpovend=97 ! vendor for another/po found
            goto foundvendpo:
		endif           
	NEXT STAT             
	!If foundpovend=0
	!	let returnstatus=0
	!	let Message$="Purchase Order Is Not On File "
	!	goto endgetapvendpo:
	!endif
	Foundvendpo: ! 
	if foundpovend<>0
		Read Record #ch_poh,rec_poh;poh.;
	else
		clear poh.
	endif
else
    include "src/callsuberr.inc"
  end try
end sub ! FindVendPo
!--------------------------------------------------------------------
Sub CalcExtAmt(lineqty,lineum,linecost,lineextamt,lbsunit,lbsfact,currfact)

! bring extended amount to costing unit of measure factors
! cost should be in base 
 Try
	 Dim 1%,CNVTU[2],FLAG,e
	dim 3%,tmpqty,tmpcost
	DIM 3%,CNVTA
	lineextamt=0
	if lineqty=0 exit sub ! no qty extension will be zero
	if linecost=0 exit sub ! no cost exension will be zero
	If lineum=-2 ! lot costing 
		let lineextamt=linecost
		exit sub
	endif
	if lineum>=0                                                   
		LET CNVTA=lineqty
		let CNVTU[0]=0 ! currently in base
		let CNVTU[1]=lineum ! unit of measure
		let CNVTU[2]=5 
		Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
		let tmpqty=amount
                                                
	                                                                   
		LET CNVTA=linecost
		CNVTU[0]=0
		CNVTU[1]=lineum
		CNVTU[2]=2 
		Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)                                                                  
		LET tmpcost=AMOUNT  
		if p61$[136,136]="Y" and currfact<>0 and oi.currfact<>0 ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let tmpcost=cnvca[0]
		endif
		LET lineextamt=FNR(tmpqty*tmpcost)
		exit sub
	endif
	
	IF lineum=-1 or lineum=-3! cwt 
		let tmpqty=lineqty
		LET CNVTA=linecost
		CNVTU[0]=0
		CNVTU[1]=lineum
		CNVTU[2]=2 
		Amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)                                                                  
		LET tmpcost=AMOUNT 
		if p61$[136,136]="Y" and currfact<>0  and oi.currfact<>0 ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=tmpcost
			let cnvca[1]=currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let tmpcost=cnvca[0]
		endif
		if lineum=-1 ! cwt
			LET lineextamt=FNR(tmpcost*(lbsunit*tmpqty/lbsfact)/100)
			exit sub
		endif
		if lineum=-3 ! per lb
			LET lineextamt=FNR(tmpcost*(lbsunit*tmpqty/lbsfact))
			exit sub
		endif
	endif
 else
    include "src/callsuberr.inc"
  end try
end sub ! CalcExtAmt
!=========================================================================================================
Sub getappoline() ! for display of ap po lines
Try
	message$=""
	returnstatus=1 ! set to ok
	Call ValidateBatch() ! checks acct per & batch id
	if not (returnstatus) goto endgetappoline:
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto endgetappoline:
	Call Dxget("POID",tmp$)
	let poid=tmp$
	if poid<=0 or poid>999999
		let message$="Invalid Purchase Order Number Submitted"
		returnstatus=0
		goto endgetappoline:
	endif
	call verifyaptran(vendid)
	if not (returnstatus) goto endgetappoline:
	if not(c0[4]) 
		message$="A/P - P/O Interface is not available "
		goto endgetappoline:
	endif
	if not (CCC)
		ccc = OpenFile(-1728,intCo) \ If ccc= -1 Error 42  !u/m codes file
	endif
	let KEYAPPOH$=" ",KEYAPPOH$
	let KEYAPPOH$[1,6]=vendid using "######"
	let KEYAPPOH$[7,18]=transid$
	let KEYAPPOH$[19,20]=transtype using "##"                        
	let KEYAPPOH$[21,26]=POID USING "######"       
	SEARCH #CH_APPOH,2,1;KEYAPPOH$,REC_APPOH,E
	if not(e)
		read record #ch_appoh,rec_appoh;appoh.;
		mat Read #ch_appoh,rec_appoh,48;aph3;
		mat read #ch_appoh,rec_appoh,58;aph4;
		mat read #ch_appoh,rec_appoh,88;aph5;
	else
		rec_appoh=-1
		clear appoh.
		for ctr=0 to 4
			let aph3[ctr]=0
			let aph4[ctr]=0
			let aph5=0
		next ctr
		if p61$[136,136]="Y" and oi.currid<>0
			let aph5=oi.currfact
			appoh.currid=oi.currid
			appoh.currfact=oi.currfact
		endif
	endif
	call findappoid()
	
	endgetappoline: !  end get appoline
	!!!!! section --- heading for po lines
	Clear List$[]                                                         
	List$[0] = bsdel$ + "POLineHdrInfo" + fdel$ ! section name
	webstr$="APTransID",fdel$
	webstr$=webstr$,"APAmount",fdel$
	webstr$=webstr$,"BuyName",fdel$
	webstr$=webstr$,"POVendID",fdel$
	webstr$=webstr$,"POID",fdel$
	webstr$=webstr$,"ShipName",fdel$
	webstr$=webstr$,"TotalRcvd",fdel$
	webstr$=webstr$,"PrevAppld",fdel$
	webstr$=webstr$,"CurrAppld",fdel$
	webstr$=webstr$,"VendorID",fdel$
	let list$[1]=webstr$
	row=2
	if returnstatus<>0 ! no errors send over the data
		let poh.apamtpend=poh.apamtpend-appoh.totap
		let poh.freightapplpend=poh.freightapplpend-appoh.totfrgt
		let poh.miscapplpend= poh.miscapplpend-appoh.totmisc
		IF P61$[60,60]="Y" AND POH.TotGlRec<>0
			LET TOTPOREC=POH.TotGlRec           
		ELSE                             
			 LET TOTPOREC=POH.TotPoRcvd             
		ENDIF 
		webstr$=rtrim$(transid$),fdel$
		if transtype=2 let oi.grossinvoiceamount=oi.grossinvoiceamount*(-1)
		let amount=oi.grossinvoiceamount
		if p61$[136,136]="Y" and oi.currfact<>0 and amount<>0  ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=oi.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=fnr(cnvca[0])
		endif
		webstr$=webstr$,(amount using "-----------.##"),fdel$ ! oi.grossinvoiceamount
		webstr$ = webstr$,RTRIM$(vend.name$),fdel$
		webstr$=webstr$,str$(poh.vendorcode),fdel$
		webstr$=webstr$,str$(poh.purchaseorder),fdel$ ! need to add level?
		webstr$=webstr$,rtrim$(poh.ShipToName$),fdel$
		let amount=totporec
		if p61$[136,136]="Y" and poh.currfact<>0 and amount<>0 and oi.currfact<>0 ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=poh.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=fnr(cnvca[0])
		endif
		webstr$=webstr$,(amount using  "###########.##"),fdel$ ! total rcvd totporec
		let amount=POH.TotApMerchAppl+POH.ApAmtPend
		if p61$[136,136]="Y" and poh.currfact<>0 and amount<>0 and oi.currfact<>0 ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=poh.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=fnr(cnvca[0])
		endif
		webstr$=webstr$,((amount) using  "###########.##"),fdel$ ! prev rec POH.TotApMerchAppl+POH.ApAmtPend
		let amount=appoh.TotAP
		if p61$[136,136]="Y" and appoh.currfact<>0 and amount<>0 and oi.currfact<>0 ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=appoh.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=fnr(cnvca[0])
		endif
		webstr$=webstr$,(amount using  "###########.##"),fdel$ ! currappld
		webstr$=webstr$,str$(vendid),fdel$
		LIST$[2]=WEBSTR$
		row=row+1
	endif
	LIST$[row]=esdel$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	!Call AddToStr(e$,rstr$,esdel$) ! end of section
	Clear List$[]                                                         
	List$[0] = bsdel$ + "POLineList" + fdel$ ! section name
	webstr$="CntrlId",fdel$
	WebStr$=webstr$,"LineId",fdel$
	WebStr$=WebStr$,"ProdID",fdel$
	Webstr$=webstr$,"Desc1",fdel$
	webstr$=webstr$,"Desc2",fdel$
	webstr$=webstr$,"VendProdId",fdel$
	webstr$=webstr$,"LastRcvdDate",fdel$
	Webstr$=Webstr$,"CostUm",fdel$,"CostUmID",fdel$,"CostFactor",fdel$
	Webstr$=Webstr$,"QtyUm",fdel$,"QtyUmId",fdel$,"QtyFactor",fdel$
	WebStr$=WebStr$,"POQty",fdel$
	Webstr$=Webstr$,"POUnitCost",fdel$
	webstr$=webstr$,"POExtCost",fdel$
	WebStr$=WebStr$,"PrevQty",fdel$
	Webstr$=Webstr$,"PrevUnitCost",fdel$
	webstr$=webstr$,"PrevExtCost",fdel$
	WebStr$=WebStr$,"CurrQty",fdel$
	Webstr$=Webstr$,"CurrUnitCost",fdel$
	webstr$=webstr$,"CurrExtCost",fdel$
	webstr$=webstr$,"Close",fdel$
	Webstr$=Webstr$,"Whse",fdel$
	webstr$=webstr$,"ExtWeight",fdel$
	webstr$=webstr$,"Weight",fdel$
	webstr$=webstr$,"WgtFactor",fdel$
	webstr$=webstr$,"WgtUm",fdel$
	let list$[1]=webstr$
	row=2
	tmpcnt=maxcnt
	if returnstatus<>0 ! no errors send over the data
		keypoc$=" ",keypoc$
		keypoc$[1,6]=poid using "######"
		do
			search #ch_poc,3,1;keypoc$,rec_poc,e
			if e<>0 exit do
			let tmp3=keypoc$[1,6]\if tmp3<>poid exit do
			read record #ch_poc,rec_poc;poc.;  
  			if poc.APClose>=87 AND poc.ApClose<=89 goto getnxtpoc: ! in unreceive process
			if poglflag<>0
				if poc.APClose>=97 AND poc.ApClose<=99 goto getnxtpoc: ! 543 manual cntrl# close
			endif
			! get the poline
			let keypol$=" ",keypol$
			let keypol$[1,6]=poid using "######"
			let keypol$[7,9]=poc.LineNum using "###"
			let keypol$[10]=""
			rec_pol = filegetpoline(e$,ch_pol,"=",1,keypol$,pol.)
			if rec_pol<=0 goto getnxtpoc:
			X2 = POL.flags ! ! REM UNPACK pol.Flags TO FLAGS[x]
			For K = 0 To 11                                    
				flags[K] = Sgn(Fra(X2 / 2)) \ X2 = Int(X2 / 2)   
			Next K                                             
			NonStk = flags[0]                                  
			Closedshort = flags[1]                             
			Zline = flags[2]                                    
			IF zline<>0 goto getnxtpoc: ! 
			if pol.Status=1 and pol.QtyRcvdToDate=0  goto getnxtpoc:! not received and not qty received                 
			! find an appol record
			LET keyappol$=" ",keyappol$                                   
			LET keyappol$[1,6]=vendid USING "######" \ LET keyappol$[7,18]=transid$[1,12]       
			LET keyappol$[19,20]=transtype USING "##" \ LET keyappol$[21,26]=poid USING "######"
			LET keyappol$[27,29]=poc.LineNum USING "###"                                   
			LET keyappol$[30,35]=POC.CntrlNum USING "######"                              
			SEARCH #ch_appol,2,1;keyappol$,rec_appol,E 
			if e=0 ! does not exist 
				read record #ch_appol,rec_appol;appol.;	 
 				!if rec_pol<>0
				!	read record #ch_pol,rec_pol;pol.;
				!	let pol.ApQtyPend= pol.ApQtyPend - appol.APQty 		\if pol.ApQtyPend<0 let pol.ApQtyPend=0   
				!	let pol.ApCostPend = 0 ! pol.ApCostPending -appol.APCost   \if pol.ApCostPending <0 let pol.ApCostPending =0   
				!	let pol.ApExtCostPend = pol.ApExtCostPend - appol.ExtCost \if pol.ApExtCostPend <0 let pol.ApExtCostPend=0
				!	write record #ch_pol,rec_pol;pol.;
				!endif
				!if rec_poc<>0
				!	read record #ch_poc,rec_poc;poc.;  
				!	LET poc.ApQtyAppl=poc.ApQtyAppl-appol.APQty\if poc.ApQtyAppl<0 let poc.ApQtyAppl=0
				!	write record #ch_poc,rec_poc;poc.; 
				!endif
				!if rec_poh<>0
				!	read record #ch_poh,rec_poh;poh.; 
				!	let poh.apamtpend=poh.apamtpend-appol.ExtCost ! remove orig b4 adjust
				!	IF poh.apamtpend<=0 let poh.apamtpend=0
				!	write record #ch_poh,rec_poh;poh.;
				!endif
			Else
				rec_appol=-1
				clear appol.
			endif
			! Find product/nonstock
			If Not(NonStk) ! it's a prod
				rec_prod=pol.ProdDescRec
				Read record #ch_prod,rec_prod,0;PR.;
			else		
				Read Record #ch_nstk,pol.ProdDescRec;nstk.;
			endif
			Call SetPRtoPol() !!! 
			LET QTYUMid=pol.QtyUm                       
			IF poc.CWFlag LET QTYUMid=-3  ! catch weight item qty in lbs
			COSTUMID=pol.CostUm
			!------quantity conversions-----------
			! poqty, prevqty, currqty                          
			if not (poc.CWFlag)    ! not catchweight by lb item
				let poqty=0
				LET CNVTA=poc.PoQtyRcvd
				if cnvta<>0
					LET CNVTU[0]=0 \ LET CNVTU[1]=qtyumid \ LET CNVTU[2]=1
					amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
					let poqty=amount ! po qty received
				endif
				let prevqty=0                    
				let cnvta=poc.ApQtyRcvd  +(poc.ApQtyAppl-appol.APQty)
				if cnvta<0 let cnvta=0
				if cnvta<>0
					 LET CNVTU[0]=0 \ LET CNVTU[1]=qtyumid \ LET CNVTU[2]=1
					 amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
					 let prevqty=amount ! previous ap qty applied 
				endif
				let currqty=0                            
				LET CNVTA=appol.APQty ! appol.APQty
				if cnvta<>0
					 LET CNVTU[0]=0 \ LET CNVTU[1]=qtyumid \ LET CNVTU[2]=1    
					 amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
					 let currqty=amount ! current ap qty applied
				endif                           
			else  
				! catchweight by lbs --- qty is in lbs
				let poqty=PoQtyRcvd                                                        
				let prevqty=poc.ApQtyRcvd+(poc.ApQtyAppl-appol.APQty)                                          
				let currqty=appol.APQty                                                        
			endif
			!------cost conversions-------
			! pocost, currcost --- no prevcost is retained
			let pocost=0
			LET CNVTA=poc.PoCost 
			if cnvta<>0
			    lET CNVTU[0]=0 \ LET CNVTU[1]=costumid \ LET CNVTU[2]=2                                      
				amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				let pocost=amount
				if p61$[136,136]="Y" and poc.currfact<>0 and amount<>0 and oi.currfact<>0  ! going for base to costing um
					let cnvcu[0]=1
					let cnvca[0]=amount
					let cnvca[1]=poc.currfact
					let CNVCU[1]=1 ! no rounding
					call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
					let pocost=cnvca[0]
				endif
			End If                              
			currcost=0
			if not (poc.CWFlag)                         
				LET CNVTA=appol.APCost
				if cnvta<>0
					prodfact=PR.LbsFact;prodlbs=PR.LbsUnit ! save product weight factors
					let PR.LbsFact=poc.LbsFact;PR.LbsUnit=poc.LbsUnit
					LET CNVTU[0]=0 \ LET CNVTU[1]=costumid \ LET CNVTU[2]=2 
					amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
					let currcost=amount ! current ap cost                  
					let PR.LbsFact=prodfact;PR.LbsUnit=prodlbs
					if p61$[136,136]="Y" and appol.currfact<>0 and amount<>0 and oi.currfact<>0  ! going for base to costing um
						let cnvcu[0]=1
						let cnvca[0]=amount
						let cnvca[1]=appol.currfact
						let CNVCU[1]=1 ! no rounding
						call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
						let currcost=cnvca[0]
					endif
				endif
			else                                                                       
				let currcost=appol.APCost ! appol.APCost 
				if p61$[136,136]="Y" and poc.currfact<>0 and amount<>0  and oi.currfact<>0! going for base to costing um
						let cnvcu[0]=1
						let cnvca[0]=amount
						let cnvca[1]=appol.currfact
						let CNVCU[1]=1 ! no rounding
						call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
						let currcost=cnvca[0]
				endif
			endif                                                                           
			!------extended amount conversions-------
			let poextcost=0;currextcost=0;prevextcost=0
			if not(poc.CWFlag)
				lineqty=poc.PoQtyRcvd !pol.qtyship
				lineum=costumid
				linecost=poc.PoCost !pol.unitcost
				lineextamt=0
				lbsunit=poc.LbsUnit
				lbsfact=poc.lbsfact
				prodfact=PR.LbsFact;prodlbs=PR.LbsUnit ! save product weight factors
				let PR.LbsFact=poc.LbsFact;PR.LbsUnit=poc.LbsUnit
				let currfact=poc.currfact
				call calcextamt(lineqty,lineum,linecost,lineextamt,lbsunit,lbsfact,currfact)
				let PR.LbsFact=prodfact;PR.LbsUnit=prodlbs
				let poextcost=lineextamt
				! for ext curr ap cost
				lineqty=appol.APQty !pol.qtyship
				lineum=costumid
				linecost=appol.APCost !pol.unitcost
				lineextamt=0
				lbsunit=poc.LbsUnit
				lbsfact=poc.lbsfact
				prodfact=PR.LbsFact;prodlbs=PR.LbsUnit
				currfact=appol.currfact
				let PR.LbsFact=poc.LbsFact;PR.LbsUnit=poc.LbsUnit                  		
				call calcextamt(lineqty,lineum,linecost,lineextamt,lbsunit,lbsfact,currfact)
				let PR.LbsFact=prodfact;PR.LbsUnit=prodlbs
				let currextcost=lineextamt
			else
				! lb for lb 
				poextcost=fnr(poc.PoQtyRcvd*poc.PoCost)
				amount=poextcost
				if p61$[136,136]="Y" and poc.currfact<>0 and amount<>0 and oi.currfact<>0  ! going for base to costing um
						poextcost=(poc.PoQtyRcvd*poc.PoCost)
						amount=poextcost
						let cnvcu[0]=1
						let cnvca[0]=amount
						let cnvca[1]=appol.currfact
						let CNVCU[1]=1 ! no rounding
						call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
						let poextcost=fnr(cnvca[0])
				endif
				currextcost=fnr(appol.Apqty*appol.ApCost)
				amount=currextcost
				if p61$[136,136]="Y" and appol.currfact<>0 and amount<>0  and oi.currfact<>0! going for base to costing um
						currextcost=(appol.Apqty*appol.ApCost)
						amount=currextcost
						let cnvcu[0]=1
						let cnvca[0]=amount
						let cnvca[1]=appol.currfact
						let CNVCU[1]=1 ! no rounding
						call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
						let currextcost=fnr(cnvca[0])
				endif
			endif
			let prevextcost=poc.ApAmtRcvd
			amount=prevextcost
			if p61$[136,136]="Y" and poc.currfact<>0 and amount<>0 and oi.currfact<>0 ! going for base to costing um
					let cnvcu[0]=1
					let cnvca[0]=amount
					let cnvca[1]=appol.currfact
					let CNVCU[1]=1 ! no rounding
					call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
					let prevextcost=fnr(cnvca[0])
			endif
			QTYUM$=xunit$(QTYUMID,ch_ccode) ! u/m
			COSTUM$=xunit$(COSTUMID,ch_ccode) 
			webstr$=(poc.CntrlNum using "######"),fdel$ ! cntrl #
			WebStr$=webstr$,(poc.LineNum),fdel$
			WebStr$=webstr$,pol.prodcode$,fdel$ ! prodid
			Webstr$=webstr$,RTrim$(pol.desc1$),fdel$  ! desc1
			WebStr$=WebStr$,RTrim$(pol.desc2$),fdel$  ! desc 2
			webstr$=webstr$,rtrim$(pol.VendProdCode$),fdel$
			if poc.RcvdDate<>0
				let xdate$=pdate$(poc.RcvdDate)
			else
				let xdate$=""
			endif
			webstr$=webstr$,xdate$,fdel$ !"LastRcvdDat
			x3=umtofactor(costumid) ! get um for factor
			if not(x3) let x3=1
			Webstr$=Webstr$,rtrim$(CostUm$),fdel$,str$(CostUmID),fdel$,str$(x3),fdel$
			X3 = UMtoFactor(qtyumid) ! get qty um factor
			if not(x3) let x3=1
			Webstr$=Webstr$,rtrim$(QtyUm$),fdel$,str$(QtyUmId),fdel$,str$(x3),fdel$
			WebStr$=WebStr$,(POQty Using QMask$),fdel$
			Webstr$=Webstr$,(POCost  Using PMask$),fdel$
			webstr$=webstr$,(POExtCost   using "----------.##"),fdel$
			WebStr$=WebStr$,(PrevQty Using QMask$) ,fdel$
			Webstr$=Webstr$,"",fdel$ ! not available
			webstr$=webstr$,(PrevExtCost using "----------.##"),fdel$
			WebStr$=WebStr$,(CurrQty Using QMask$),fdel$
			Webstr$=Webstr$,(CurrCost Using PMask$),fdel$
			webstr$=webstr$,(CurrExtCost using "----------.##"),fdel$
			let tmp$="N"
			if rec_appol>0
				if appol.APClose<>0 let tmp$="Y"
			else
				if poc.APClose<>0 let tmp$="Y"
			endif
			webstr$=webstr$,tmp$,fdel$ ! close
			Webstr$=Webstr$,(poc.Whse using "##"),fdel$ !
			if poc.PoWgtRcvd>0
				webstr$=webstr$,(poc.PoWgtRcvd using "----------.##"),fdel$
			else
				webstr$=webstr$,"",fdel$
			endif
			if  not(poc.lbsfact)
				let poc.lbsunit=pol.lbsunit
				let poc.lbsfact=pol.lbsfactor
			endif
			if poc.lbsfact=0 let poc.lbsfact=1
			WebStr$ = WebStr$,LTrim$(poc.LbsUnit Using "##########.##"),fdel$ ! unit weight
			WebStr$ = WebStr$,Str$(poc.LbsFact),fdel$! weight factor                                                                    
			tmp$ = Str$(poc.LbsFact)                                          
			Call factorum(tmp$) ! get um for factor                             
			WebStr$ = WebStr$,RTrim$(tmp$),fdel$ ! wgt um
			list$[row]=webstr$
			row=row+1
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
			!IF REC_APPOL>0
			!	LET keyappol$=" ",keyappol$                                   
			!	LET keyappol$[1,6]=vendid USING "######" \ LET keyappol$[7,18]=transid$[1,12]       
			!	LET keyappol$[19,20]=transtype USING "##" \ LET keyappol$[21,26]=poid USING "######"
			!	LET keyappol$[27,29]=poc.LineNum USING "###"                                   
			!	LET keyappol$[30,35]=POC.CntrlNum USING "######"                              
			!	SEARCH #ch_appol,5,1;keyappol$,rec_appol,E 
			!	LET E=3\ SEARCH #ch_appol,5,1;keyappol$,rec_appol,E 
			!ENDIF
			getnxtpoc:  !get the next control #
		loop
		
	endif
	let list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	! status section
	If returnstatus=1 let message$="OK"
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
  end try
end sub ! getappoline
!=========================================================================================================
Sub submitappoline() ! for display of ap po lines
Try
	message$=""
	returnstatus=1 ! set to ok
	Call ValidateBatch() ! checks acct per & batch id
	if not(returnstatus) goto endsubappoline:
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto endsubappoline:
	Call Dxget("POID",tmp$)
	let poid=tmp$
	if poid<=0 or poid>999999
		let message$="Invalid Purchase Order Number Submitted"
		returnstatus=0
		goto endsubappoline:
	endif
	call verifyaptran(vendid)
	if not (returnstatus) goto endsubappoline:
	if not(c0[4]) 
		message$="A/P - P/O Interface is not available "
		goto endsubappoline:
	endif
	let KEYAPPOH$=" ",KEYAPPOH$
	let KEYAPPOH$[1,6]=vendid using "######"
	let KEYAPPOH$[7,18]=transid$
	let KEYAPPOH$[19,20]=transtype using "##"                        
	let KEYAPPOH$[21,26]=POID USING "######"       
	SEARCH #CH_APPOH,2,1;KEYAPPOH$,REC_APPOH,E
	if not(e)
		read record #ch_appoh,rec_appoh;appoh.;
		mat Read #ch_appoh,rec_appoh,48;aph3;
		mat read #ch_appoh,rec_appoh,58;aph4;
		mat read #ch_appoh,rec_appoh,88;aph5;
	else		
		rec_appoh=-1
		clear appoh.
		for ctr=0 to 4
			let aph3[ctr]=0
			let aph4[ctr]=0
			let aph5=0
		next ctr
	endif
	call findappoid()
	If not(returnstatus) goto endsubappoline:
	Call Dxget("TOTREC",tmp$)                               
	totrec = tmp$                                           
	If totrec <= 0                                           
		 Message$ = "Invalid Number of Records for Submission" 
		 ReturnStatus = 0                                      
		Goto endsubappoline
	endif
	if rec_appoh<0 ! create a new key now
		appoh.VendID=vendid        
		appoh.PoID=poid        
		appoh.PoVendId=poh.vendorcode        
		appoh.TransCode$=transid$+blank$  
		appoh.Type=transtype
		let appoh.currid=0
		let appoh.currfact=0
		if p61$[136,136]="Y" and apbth.currid<>0  !and oi.currfact<>0
			let appoh.currid=oi.currid
			let appoh.currfact=oi.currfact
		endif
		mode$="a"
		UpdStatus = fileupdateappoh(e$,ch_appoh,mode$,rec_appoh,appoh.)! need to do the update program
		let KEYAPPOH$=" ",KEYAPPOH$
		let KEYAPPOH$[1,6]=vendid using "######"
		let KEYAPPOH$[7,18]=transid$
		let KEYAPPOH$[19,20]=transtype using "##"                        
		let KEYAPPOH$[21,26]=POID USING "######"       
		SEARCH #CH_APPOH,2,1;KEYAPPOH$,REC_APPOH,e
		if e<>0
			 Message$ = "Error Creating AP PO Header File" 
			ReturnStatus = 0                                      
			Goto endsubappoline
		endif
		read record #ch_appoh,rec_appoh;appoh.;
		mat Read #ch_appoh,rec_appoh,48;aph3;
		mat read #ch_appoh,rec_appoh,58;aph4;
		mat read #ch_appoh,rec_appoh,88;aph5;
	endif
    For ctr=1 to totrec                                              
		Call Dxget("CNTRLID"+Str$(ctr),tmp$)
		let cntrlid=tmp$
		Call Dxget("LINEID"+ Str$(ctr),tmp$)
		let lineid=tmp$
		Call Dxget("CURRQTY"+ Str$(ctr),tmp$)
		let currqty=tmp$
		Call Dxget("CURRUNITCOST"+ Str$(ctr),tmp$)
		let currcost=tmp$
		Call Dxget("CLOSE"+Str$(ctr),tmp$)
		let closeflag=0
		if ucase$(rtrim$(tmp$))="Y" let closeflag=1
		Call Dxget("WHSE"+str$(ctr),tmp$)
		let whse=tmp$
		keypoc$=" ",keypoc$
		keypoc$[1,6]=poid using "######"
		keypoc$[7,12]=cntrlid using "######"
		keypoc$[13,16]=lineid using "####"
		keypoc$[17,18]=whse using "##"
		search #ch_poc,2,1;keypoc$,rec_poc,e
		If e<>0
			let message$="Line Not Found For Cntrl# "+str$(cntrlid)+" For PO "+str$(poid)
			Goto endsubappoline
		endif
		read record #ch_poc,rec_poc;poc.;                
  		if poc.APClose>=87 AND poc.ApClose<=89
			let message$="Cntrl# "+str$(cntrlid)+" For PO "+str$(poid)+" In Unreceive Processs"
			Goto endsubappoline
		endif
		if poglflag<>0
			if poc.APClose>=97 AND poc.ApClose<=99 
				let message$="Cntrl# "+str$(cntrlid)+" For PO "+str$(poid)+" In Close"
				Goto endsubappoline
			endif
		endif	! get the poline
		let keypol$=" ",keypol$
		let keypol$[1,6]=poid using "######"
		let keypol$[7,9]=poc.LineNum using "###"
		let keypol$[10]=""
		rec_pol = filegetpoline(e$,ch_pol,"=",1,keypol$,pol.)
		if rec_pol<=0
			let message$="Line Number "+str$(lineid)+" For PO "+str$(poid)+" Not Found "
			Goto endsubappoline
		endif
		X2 = POL.flags ! ! REM UNPACK pol.Flags TO FLAGS[x]
		For K = 0 To 11                                    
			flags[K] = Sgn(Fra(X2 / 2)) \ X2 = Int(X2 / 2)   
		Next K                                             
		NonStk = flags[0]                                  
		Closedshort = flags[1]                             
		Zline = flags[2]                                    
		IF zline<>0
			let message$="Line Number "+str$(lineid)+" For PO "+str$(poid)+" Is a message line"
			Goto endsubappoline
		endif
		if pol.Status=1 and pol.QtyRcvdToDate=0
			let message$="Line Number "+str$(lineid)+" For PO "+str$(poid)+" Has Not Been Received"
			Goto endsubappoline
		endif                
		! find an appol record
		LET keyappol$=" ",keyappol$                                   
		LET keyappol$[1,6]=vendid USING "######" \ LET keyappol$[7,18]=transid$[1,12]       
		LET keyappol$[19,20]=transtype USING "##" \ LET keyappol$[21,26]=poid USING "######"
		LET keyappol$[27,29]=poc.LineNum USING "###"                                   
		LET keyappol$[30,35]=POC.CntrlNum USING "######"                              
		SEARCH #ch_appol,2,1;keyappol$,rec_appol,E 
		if e=0 ! does not exist 
			read record #ch_appol,rec_appol;appol.;	
		else
			rec_appol=-1
			clear appol.
			if p61$[136,136]="Y" and appoh.currid<>0
				let appol.currid=appoh.currid
				let appol.currfact=appoh.currfact
			endif
		endif
		! Find product/nonstock
		If Not(NonStk) ! it's a prod
			rec_prod=pol.ProdDescRec
			Read record #ch_prod,rec_prod,0;PR.;
		else		
			Read Record #ch_nstk,pol.ProdDescRec;nstk.;
		endif
		! reduce cost
		LET pol.ApQtyPend=pol.ApQtyPend-appol.APQty \if  pol.ApQtyPend<0 let pol.ApQtyPend=0  
		!!!!! reduce po extended cost
		let amount=appol.ExtCost
		if p61$[136,136]="Y" and appol.currid<>0 and amount<>0 and pol.currfact<>appol.currfact and oi.currfact<>0
		! need to bring up to appol factor
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=appol.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=cnvca[0]
		! need to bring down to pol factor
			let cnvcu[0]=2
			let cnvca[0]=amount
			let cnvca[1]=pol.currfact
			let CNVCU[1]=1
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=fnr(cnvca[0])
		endif
		LET pol.ApExtCostPend=pol.ApExtCostPend-amount \if pol.ApExtCostPend <0 let pol.ApExtCostPend=0
		!!!!! update pending ap cost
		let amount=appol.apcost
		if p61$[136,136]="Y" and appol.currid<>0 and amount<>0 and pol.currfact<>appol.currfact and oi.currfact<>0
		! need to bring up to appol factor
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=appol.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=cnvca[0]
		! need to bring down to pol factor
			let cnvcu[0]=2
			let cnvca[0]=amount
			let cnvca[1]=pol.currfact
			let CNVCU[1]=1
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=fnr(cnvca[0])
		endif
		LET pol.ApCostPend=amount 
		!!!!
		let amount=appol.ExtCost 
		if p61$[136,136]="Y" and appol.currid<>0 and amount<>0 and pol.currfact<>appol.currfact and oi.currfact<>0
		! need to bring up to appol factor
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=appol.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=cnvca[0]
		! need to bring down to pol factor
			let cnvcu[0]=2
			let cnvca[0]=amount
			let cnvca[1]=pol.currfact
			let CNVCU[1]=1
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=fnr(cnvca[0])
		endif
		let poh.apamtpend=poh.apamtpend-amount! remove orig b4 adjust
		IF poh.apamtpend<=0 let poh.apamtpend=0
		LET appoh.TotAP=appoh.TotAP-appol.ExtCost 
		if appoh.ToTAP<0 let appoh.totap=0
		LET poc.ApQtyAppl=poc.ApQtyAppl-appol.APQty \if poc.ApQtyAppl<0 let poc.ApQtyAppl=0
		Call SetPRtoPol() !!! 
		LET QTYUMid=pol.QtyUm                       
		IF poc.CWFlag LET QTYUMid=-3  ! catch weight item qty in lbs
		COSTUMID=pol.CostUm
		!------quantity conversions-----------
		! poqty, prevqty, currqty                          
		if not (poc.CWFlag)    ! not catchweight by lb item	
			let appol.apqty=0                            
			LET CNVTA=currqty! appol.APQty
			if cnvta<>0
				 LET CNVTU[0]=qtyumid \ LET CNVTU[1]=0 \ LET CNVTU[2]=1    
				 amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				 let appol.apqty=amount ! current ap qty applied
			endif                           
		else  
			appol.apqty=currqty
		endif
		let appol.apcost=0
		if not (poc.CWFlag)                         
			LET CNVTA=currcost
			if cnvta<>0
				let amount=currcost
				if p61$[136,136]="Y" and appol.currfact<>0 and amount<>0 and oi.currfact<>0
					let cnvcu[0]=2 ! going to base 
					let cnvca[0]=cnvta
					let cnvca[1]=appol.currfact
					let CNVCU[1]=1 ! no rounding
					call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
					let cnvta=cnvca[0]
				endif
				prodfact=PR.LbsFact;prodlbs=PR.LbsUnit ! save product weight factors
				let PR.LbsFact=poc.LbsFact;PR.LbsUnit=poc.LbsUnit
				LET CNVTU[0]=costumid \ LET CNVTU[1]=0 \ LET CNVTU[2]=2 
				amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				let appol.apcost=amount ! current ap cost                  
				let PR.LbsFact=prodfact;PR.LbsUnit=prodlbs
			endif
		else   
			let amount=currcost
				if p61$[136,136]="Y" and appol.currfact<>0 and amount<>0 and oi.currfact<>0
					let cnvcu[0]=2
					let cnvca[0]=cnvta
					let cnvca[1]=appol.currfact
					let CNVCU[1]=1
					call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
					let cnvta=cnvca[0]
				endif
			let appol.APCost=currcost ! appol.APCost                                                       
		endif                                                                           
		!------extended amount conversions-------
		currextcost=0
		if not(poc.CWFlag)
			! for ext curr ap cost
			lineqty=appol.APQty !pol.qtyship
			lineum=costumid
			linecost=appol.APCost !pol.unitcost
			lineextamt=0
			lbsunit=poc.LbsUnit
			lbsfact=poc.lbsfact
			prodfact=PR.LbsFact;prodlbs=PR.LbsUnit ! save product weight factors
			let PR.LbsFact=poc.LbsFact;PR.LbsUnit=poc.LbsUnit
			currfact=0
			call calcextamt(lineqty,lineum,linecost,lineextamt,lbsunit,lbsfact,currfact)
			let PR.LbsFact=prodfact;PR.LbsUnit=prodlbs
			let currextcost=lineextamt
		else
			!lb for lb 
			currextcost=fnr(appol.Apqty*appol.ApCost)
		endif
		appol.ExtCost=CURREXTCOST
		! L_4400: REM ADJUST QTY*ADD IN *            
		LET pol.ApQtyPend=pol.ApQtyPend+appol.APQty
		!!!!
		LET amount=appol.APCost
		if p61$[136,136]="Y" and pol.currid<>0 and amount<>0 and pol.currfact<>appol.currfact and oi.currfact<>0
		! need to bring up to appol factor
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=appol.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=cnvca[0]
		! need to bring down to pol factor
			let cnvcu[0]=2
			let cnvca[0]=amount
			let cnvca[1]=pol.currfact
			let CNVCU[1]=1
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=fnr(cnvca[0])
		endif
		LET pol.ApCostPend=amount
		!!!!! 
		amount=appol.ExtCost
		if p61$[136,136]="Y" and pol.currid<>0 and amount<>0 and pol.currfact<>appol.currfact and oi.currfact<>0
		! need to bring up to appol factor
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=appol.currfact
			let CNVCU[1]=1 ! no rounding
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=cnvca[0]
		! need to bring down to pol factor
			let cnvcu[0]=2
			let cnvca[0]=amount
			let cnvca[1]=pol.currfact
			let CNVCU[1]=1
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let amount=fnr(cnvca[0])
		endif
		LET pol.ApExtCostPend=pol.ApExtCostPend+amount  ! appol.extcost
		let poh.apamtpend=poh.apamtpend+amount ! appol.ExtCost  ! appoh.totap
		LET appoh.TotAP=appoh.TotAP+appol.ExtCost 
		LET poc.ApQtyAppl=poc.ApQtyAppl+appol.APQty 
	
		appol.apclose=closeflag
		! update files
		if rec_appol>0 and appol.apqty=0 and appol.apcost=0 and closeflag=poc.apclose
			!mode$="d"
			!UpdStatus = fileupdateappol(e$,ch_appol,mode$,rec_appol,appol.)
			LET keyappol$=" ",keyappol$                                   
			LET keyappol$[1,6]=vendid USING "######" \ LET keyappol$[7,18]=transid$[1,12]       
			LET keyappol$[19,20]=transtype USING "##" \ LET keyappol$[21,26]=poid USING "######"
			LET keyappol$[27,29]=poc.LineNum USING "###"                                   
			LET keyappol$[30,35]=POC.CntrlNum USING "######"                              
			SEARCH #ch_appol,2,1;keyappol$,rec_appol,E 
			if not(e)
				SEARCH #ch_appol,5,1;keyappol$,rec_appol,E 
				if not(e)
					let e=3\SEARCH #ch_appol,2,1;keyappol$,rec_appol,E
					let rec_appol=0
				endif
			endif
		else
			if rec_appol>0
				write record #ch_appol,rec_appol;appol.;
			else
				if appol.apqty=0 and appol.apcost=0 and closeflag=poc.apclose
					! DO NOT ADD THE LINE IF NOTHING IN APPLIED OR CHANGE
				ELSE
					appol.VendId=vendid        
					appol.PoId=poid      
					appol.CntrlID=cntrlid        
					appol.TransId$=transid$      
					appol.Type=transtype 
					appol.QtyUM=pol.QtyUM ! qtyumid
					appol.CostUM=CostUMId          
					appol.LineNum=LineId            
					appol.Whse=whse
					appol.lbsunit=poc.LbsUnit
					appol.lbsfact=poc.lbsfact
					appol.cwflag=poc.CWFlag
					let appol.currid=0
					let appol.currfact=0
					if p61$[136,136]="Y" and appoh.currid<>0
						let appol.currid=appoh.currid
						let appol.currfact=appoh.currfact
					endif
					!mode$ = "a"                                                    
					!UpdStatus = fileupdateappol(e$,ch_appol,mode$,rec_appol,appol.)
					LET keyappol$=" ",keyappol$                                   
					LET keyappol$[1,6]=vendid USING "######" \ LET keyappol$[7,18]=transid$[1,12]       
					LET keyappol$[19,20]=transtype USING "##" \ LET keyappol$[21,26]=poid USING "######"
					LET keyappol$[27,29]=poc.LineNum USING "###"                                   
					LET keyappol$[30,35]=POC.CntrlNum USING "######"                              
					SEARCH #ch_appol,2,1;keyappol$,rec_appol,E 
					if (e)
						let e=2\SEARCH #ch_appol,1,0;keyappol$,rec_appol,E
						write record #ch_appol,rec_appol;appol.;
						SEARCH #ch_appol,4,1;keyappol$,rec_appol,E 
					else
						write record #ch_appol,rec_appol;appol.;	
					endif
				endif
			endif
		endif     
		IF REC_POH>0 write record #ch_poh,rec_poh;poh.;
		IF REC_APPOH>0 write record #ch_appoh,rec_appoh;appoh.;
		IF REC_POC>0 write record #ch_poc,rec_poc;poc.;
		IF REC_POL>0 write record #ch_pol,rec_pol;pol.;
		getnxtappoline: ! get the next appoline 
	next ctr	
	endsubappoline: ! 
	! status section
	If returnstatus=1 let message$="OK"
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
  end try
end sub ! submitappoline
!============================================================================================================
Sub GETVENDAPREL()! Get Vendor A/P Transactions
Try
	Call dxget("VENDID",tmp$)
	let vendid=tmp$
	Call verifyvendor()                       
	CALL vendpayhdr()
	Call vendaptranhdr()
	let divflag=0;div[0]=0;div[1]=99 
	if c0[6] ! divisional
		Call dxget("DIVRELEASE",tmp$)
		if UCASE$(rtrim$(tmp$))="Y" let divflag=99
		if divflag<>0
			Call dxget("STARTDIV",tmp$)
			let div[0]=tmp$
			if div[0]<0 or div[0]>99
				let returnstatus=0
				let message$="Invalid Starting Division Submitted"
			endif
			Call dxget("ENDDIV",tmp$)
			let div[1]=tmp$
			if div[1]<0 or div[1]>99
				let returnstatus=0
				let message$="Invalid Ending Division Submitted"
			endif
			if div[1]<div[0]
				let returnstatus=0
				let message$="Ending Division Must Be Greater Than Starting Division"
	 		endif
		endif
	Endif
	bankflag=0
	if c0[8] ! vendor by bank
		bankflag=99
		Call dxget("BANK",tmp$)
		LET BANK=TMP$
		IF NOT(BANK)
			let returnstatus=0
			let message$="Invalid Bank Number Submitted"
		ENDIF
	ENDIF
	if p61$[99,99]="Y" 
		let filename$="2/VENDBANK"+STR$(INTCO)
		Call FindF(filename$,fileflag)  
		If not(fileflag)
			let returnstatus=0
			let message$="ACH Vendor File Does Not Exist "
			goto endvendaprel:
		endif
		ch_vbnk = FindChannel() ! need to get a channel #  
		rOpen #ch_vbnk,filename$ 
		Call dxget("ACHRELEASE",tmp$)
		if ucase$(rtrim$(tmp$))="Y" let achflag=99
		if achflag=99 ! need to open file
			Call dxget("ACHBANK",tmp$)
			LET achBANK=TMP$
			IF NOT(achBANK)
				let returnstatus=0
				let message$="Invalid ACH Bank Number Submitted"
				goto endvendaprel:
			ENDIF
		endif
	endif
	
	if p61$[99,99]="Y" and achflag<>0
		let keyvbnk$=vendid using "######"
		search #ch_vbnk,2,1;keyvbnk$,rec_vbnk,e
		If not(e)
			read record #ch_vbnk,rec_vbnk;vbnk.;
		else
			clear vbnk.
		endif
		if achbank<>vbnk.bank
			let returnstatus=0
			let message$="Vendor is not set-up for this ACH Bank "
			goto endvendaprel:
		endif
		if rtrim$(vbnk.routing$)=""
			let returnstatus=0
			let message$="Vendor Routing is not set-up  "
			goto endvendaprel:
		endif
		if rtrim$(vbnk.BankAcctId$)=""
			let keyoi$[7,20]="zzzzzzzzzzzzzz"! bypass this vendor
			let returnstatus=0
			let message$="Vendor Bank Account is not set-up  "
			goto endvendaprel:
		endif
	endif
	endvendaprel: ! GETVENDAPREL
	row=2
	tmpcnt=maxcnt
	if returnstatus=1
		let keyoi$=" ",keyoi$
		let keyoi$[1,6]=vendid using "######"
		DO
			search #ch_oi,3,1;keyoi$,rec_oi,e
			if e<>0 exit do
			let tmp3=keyoi$[1,6]
			if tmp3<>vendid exit do
			read record #ch_oi,rec_oi;oi.;
			if oi.statuscode$<="0" goto getnxtvendoi:
			if oi.statuscode$>="4" goto getnxtvendoi:
			if oi.transactiontype=3 goto getnxtvendoi:
			!if oi.documentcode$>"2" goto getnxtvendoi:
			If DIVFLAG                                    
				If oi.Division < DIV[0] Goto getnxtvendoi:   
				If oi.Division > DIV[1] Goto getnxtvendoi:    
			End If                                        
			
			call vendaptrandet()
			getnxtvendoi: ! get next open item 
		LOOP
	endif
	
	list$[row]=esdel$ ! end of section
	call AddToStr(e$,rstr$,List$[])
	! check total section
	clear list$[]
	list$[0]=bsdel$,"CheckTotal",fdel$
	list$[1]="GrossAmount",fdel$,"DiscountAmount",fdel$,"CheckAmount",fdel$
	webstr$=""
	webstr$=(payamt using "-----------.##"),fdel$
	webstr$=webstr$+(paydisc using "-----------.##"),fdel$
	webstr$=webstr$+(paychk using "-----------.##"),fdel$
	list$[2]=webstr$
	list$[3]=esdel$
	call AddToStr(e$,rstr$,List$[])
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)	
else
    include "src/callsuberr.inc"
end try
end sub ! GETvendaprel
!======================================================================================================
!============================================================================================================
Sub GETAPINVREL()! Release Items for payments
Try
	dim 2%,vend[1],3%
	tmp3=0
	jduedate=0
	Call dxget("DUEDATE",tmp$)
	if rtrim$(tmp$)=""
		let returnstatus=0
		let message$="Invalid Due Date Submitted"
		goto endapinvrel:
	endif
	if rtrim$(tmp$)<>""
		xdate$ = formatdate2$(tmp$)    
		tmp3 = xdate$[3,8]  ! yymmdd format
		if not(tmp3)
			let returnstatus=0
			let message$="Invalid Due Date Submitted"
			goto endapinvrel:
		endif
		xdate$ = tmp3 Using "&&&&&&"                
		Call DateToJulian(5,xdate$,xdate$,errflag)
		if (errflag)
			let returnstatus=0
			let message$="Invalid Due Date Submitted"
			goto endapinvrel:
		endif
		jduedate= xdate$ ! needs to be in julian
	endif
	tmp3=0
	jdiscdate=0
	Call dxget("DISCDATE",tmp$)
	if rtrim$(tmp$)<>""
		xdate$ = formatdate2$(tmp$)    
		tmp3 = xdate$[3,8]  ! yymmdd format
		if not(tmp3)
			let returnstatus=0
			let message$="Invalid Discount Date Submitted"
			goto endapinvrel:
		endif
		xdate$ = tmp3 Using "&&&&&&"                
		Call DateToJulian(5,xdate$,xdate$,errflag)
		if (errflag)
			let returnstatus=0
			let message$="Invalid Discount Date Submitted"
			goto endapinvrel:
		endif
		jdiscdate= xdate$ ! needs to be in julian
		discflag=0
		Call dxget("INELIGIBLEDISC",tmp$)
		if UCASE$(rtrim$(tmp$))="Y" let discflag=99
		if not (discflag)
			Call dxget("DAYSPASTDUE",tmp$)
			LET DISCOUNTPLUS=TMP$
		ENDIF
	endif
	let uncrflag=0
	Call dxget("UNCRRELEASE",tmp$)
	if UCASE$(rtrim$(tmp$))="Y" let uncrflag=99
	let manchkflag=0
	Call dxget("MANCHKRELEASE",tmp$)
	if UCASE$(rtrim$(tmp$))="Y" let manchkflag=99	
	let divflag=0;div[0]=0;div[1]=99 
	if c0[6] ! divisional
		Call dxget("DIVRELEASE",tmp$)
		if UCASE$(rtrim$(tmp$))="Y" let divflag=99
		if divflag<>0
			Call dxget("STARTDIV",tmp$)
			let div[0]=tmp$
			if div[0]<0 or div[0]>99
				let returnstatus=0
				let message$="Invalid Starting Division Submitted"
				goto endapinvrel:
			endif
			Call dxget("ENDDIV",tmp$)
			let div[1]=tmp$
			if div[1]<0 or div[1]>99
				let returnstatus=0
				let message$="Invalid Ending Division Submitted"
				goto endapinvrel:
			endif
			if div[1]<div[0]
				let returnstatus=0
				let message$="Ending Division Must Be Greater Than Starting Division"
				goto endapinvrel:
	 		endif
		endif
	Endif
	bankflag=0
	if c0[8] ! vendor by bank
		Call dxget("BANK",tmp$)
		LET BANK=TMP$
		IF NOT(BANK)
			let returnstatus=0
			let message$="Invalid Bank Number Submitted"
			goto endapinvrel:
		ENDIF
	ENDIF
	let achflag=0;achbank=0
	if p61$[99,99]="Y" 
		let filename$="2/VENDBANK"+STR$(INTCO)
		Call FindF(filename$,fileflag)  
		If not(fileflag)
			let returnstatus=0
			let message$="ACH Vendor File Does Not Exist "
			goto endapinvrel:
		endif
		ch_vbnk = FindChannel() ! need to get a channel #  
		rOpen #ch_vbnk,filename$
		Call dxget("ACHRELEASE",tmp$)
		if ucase$(rtrim$(tmp$))="Y" let achflag=99
		if achflag=99 ! need to open file
			Call dxget("ACHBANK",tmp$)
			LET achBANK=TMP$
			IF NOT(achBANK)
				let returnstatus=0
				let message$="Invalid ACH Bank Number Submitted"
				goto endapinvrel:
			ENDIF
		endif
	endif
	Call dxget("SVEND",tmp$)
	if rtrim$(tmp$)="" let tmp$="0"
	let vend[0]=tmp$
	if vend[0]<0 or vend[0]>999999
		let returnstatus=0
		let message$="Invalid Starting Vendor Entered"
		goto endapinvrel:
	ENDIF
	Call dxget("EVEND",tmp$)
	if rtrim$(tmp$)="" let tmp$="999999"
	let vend[1]=tmp$
	if vend[1]<0 or vend[1]>999999
		let returnstatus=0
		let message$="Invalid Ending Vendor Entered"
		goto endapinvrel:
	ENDIF
	if vend[0]>vend[1]
		let returnstatus=0
		let message$="Ending Vendor Must Be Greater Than Starting Vendor"
		goto endapinvrel:
	endif
	LET keyoi$=" ",keyoi$ 
	if vend[0]<>0 let keyoi$[1,6]=vend[0] using "######"
	let chkvend=0
	let creditnum=0
	let payamt=0;paydisc=0;paychk=0
	do                                                                              
		search #ch_oi,3,1;keyoi$,rec_oi,e                                       
		if e<>0 
			call ApchkRel()
			exit do
		endif
		let tmp3=keyoi$[1,6]
		if tmp3>vend[1]
			call ApchkRel()
			exit do
		endif
		read record #ch_oi,rec_oi;oi.; 
		if chkvend<>oi.vendorcode
			Call ApChkRel()
			let paychk=0
			let totcred=0
			let totrec=0
			let chkvend=oi.vendorcode
			keyvend$ = oi.vendorcode Using "######" 
			chkvend=oi.vendorcode ! vendid
			mode$="=" ! search mode 2
			dir=1
			clear vend.
			rec_vend = filegeta80vm(e$,ch_vend,mode$,dir,keyvend$,vend.)
			if rec_vend<0 ! invalid vendor
				let keyoi$[7,20]="zzzzzzzzzzzzzz"! bypass this vendor
				GOTO nxtapinvrel:
			endif
			if vend.VendorOnHold<>0 ! vendor is on hold
				let keyoi$[7,20]="zzzzzzzzzzzzzz"! bypass this vendor
				GOTO nxtapinvrel:
			endif
			if c0[8]
				if bank<>vend.bank
					let keyoi$[7,20]="zzzzzzzzzzzzzz"! bypass this vendor
					GOTO nxtapinvrel:
				endif
			endif
			if p61$[99,99]="Y"
				let keyvbnk$=oi.vendorcode using "######"
				search #ch_vbnk,2,1;keyvbnk$,rec_vbnk,e
				If not(e)
					read record #ch_vbnk,rec_vbnk;vbnk.;
				else
					clear vbnk.
				endif
			    if achflag<>0
					if achbank<>vbnk.bank
						let keyoi$[7,20]="zzzzzzzzzzzzzz"! bypass this vendor
						goto nxtapinvrel:
					endif
					if rtrim$(vbnk.routing$)=""
						let keyoi$[7,20]="zzzzzzzzzzzzzz"! bypass this vendor
						goto nxtapinvrel:
					endif
					if rtrim$(vbnk.BankAcctId$)=""
						let keyoi$[7,20]="zzzzzzzzzzzzzz"! bypass this vendor
						goto nxtapinvrel:
					endif
				else
					if vbnk.bank<>0
						let keyoi$[7,20]="zzzzzzzzzzzzzz"! bypass this vendor
						goto nxtapinvrel:
					endif
					if rtrim$(vbnk.routing$)<>""
						let keyoi$[7,20]="zzzzzzzzzzzzzz"! bypass this vendor
						goto nxtapinvrel:
					endif
					if rtrim$(vbnk.BankAcctId$)<>"" 
						let keyoi$[7,20]="zzzzzzzzzzzzzz"! bypass this vendor
						goto nxtapinvrel:
					endif
				endif
			endif
		endif
		IF oi.StatusCode$<"1" GOTO nxtapinvrel:
		if oi.statusCode$>"3" goto nxtapinvrel:
		IF oi.DocumentCode$>"7" GOTO nxtapinvrel: 
		if oi.DocumentCode$="3" and oi.statuscode$="1"
			if not(manchkflag)
				GOTO nxtapinvrel:
			else
				if c0[8]<>0
					if bank<>oi.banknumber goto nxtapinvrel:
				endif
				let oi.statuscode$="3"
				LET oi.paymentcurrentRun=oi.grossinvoiceamount-oi.paymentcurrentPeri-oi.paymentnextmo  
				write record #ch_oi,rec_oi;oi.;
				GOTO nxtapinvrel:
			endif
		endif
		IF DIVFLAG 
			IF oi.Division<DIV[0] GOTO nxtapinvrel:                                         
			IF oi.Division>DIV[1] GOTO nxtapinvrel:
		endif
		if oi.statuscode$="2" or oi.statuscode$="3"
			if oi.documentcode$<>"3"
				if oi.paymentcurrentrun<>0
					paychk = paychk + oi.paymentcurrentrun - oi.discountamount
					let totrec=totrec+1
				endif
			endif
			
			
			goto nxtapinvrel:
		endif
		if oi.statuscode$<>"1" goto nxtapinvrel:
		if oi.transactiontype=2 and (oi.grossinvoiceamount-oi.paymentcurrentPeri-oi.paymentnextmo)<>0 let totcred=totcred+1
		xdate$ = oi.duedate Using "&&&&&&"                
		Call DateToJulian(5,xdate$,xdate$,errflag)
		if errflag<>0 goto nxtapinvrel:
		let japduedate=xdate$
		xdate$ = oi.discountdate Using "&&&&&&"                
		Call DateToJulian(5,xdate$,xdate$,errflag)
		if errflag<>0 goto nxtapinvrel:
		let japdiscdate=xdate$
		
		! what is discountplus                                          
                if not(jdiscdate)
			IF japduedate>jduedate 	GOTO nxtapinvrel: 
		else
			if not(discflag) ! release ineligle discount is no
				IF japdiscdate<jdiscdate AND japduedate>jduedate GOTO nxtapinvrel:
			endif
			if oi.discountamount<>0 and discountplus<>0	
				IF japdiscdate>jdiscdate IF japdiscdate<=(jdiscdate+DISCOUNTPLUS) goto relSELpay:
			endif
			IF japduedate>jduedate IF japdiscdate>jdiscdate GOTO nxtapinvrel:
		endif
		relSELpay: ! release for payment
		if chkvend<>oi.vendorcode
			keyvend$ = oi.vendorcode Using "######" 
			chkvend=oi.vendorcode ! vendid
			mode$="=" ! search mode 2
			dir=1
			clear vend.
			rec_vend = filegeta80vm(e$,ch_vend,mode$,dir,keyvend$,vend.)
			if rec_vend<0 ! invalid vendor

				let keyoi$[7,20]="zzzzzzzzzzzzzz"! bypass this vendor
				GOTO nxtapinvrel:
			endif
			if vend.VendorOnHold<>0 ! vendor is on hold
				let keyoi$[7,20]="zzzzzzzzzzzzzz"! bypass this vendor
				GOTO nxtapinvrel:
			endif
			if c0[8]
				if bank<>vend.bank
					let keyoi$[7,20]="zzzzzzzzzzzzzz"! bypass this vendor
					GOTO nxtapinvrel:
				endif
			endif
		endif
		                             
		LET oi.paymentcurrentRun=oi.grossinvoiceamount-oi.paymentcurrentPeri-oi.paymentnextmo                                        
		IF oi.paymentcurrentRun<>0
			LET oi.DocumentCode$="4"
			if jdiscdate<>0 and oi.discountamount<>0
				if not(discflag) ! take ineligible discounts = no                        
					IF jdiscdate>japdiscdate
						LET oi.DocumentCode$="5"
						LET oi.discountamount=0
					endif
				endif
			endif
			paychk = paychk + oi.PaymentCurrentRun - oi.DiscountAmount 
			let totrec=totrec+1
		endif
	        LET oi.StatusCode$="2"                                            
		IF oi.transactiontype=2
			LET oi.StatusCode$="3"     ! credit memo  
			!let totcred=totcred-1
			!if totcred<0 let totcred=0
		endif
		IF SGN(oi.paymentcurrentRun)<>SGN(oi.grossinvoiceamount) GOTO nxtapinvrel:                                
		write record #ch_oi,rec_oi;oi.;
		nxtapinvrel: ! get next tran for release
	loop                                                     
	endapinvrel: ! endaprel: ! 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! apinvrel
!!! =====================================================================================
Sub APCHKREL()! Checks for negative ap checks and unreleases them
Try
	if paychk>0 and uncrflag<>0 and totcred<>0
	! have credits let release them
		LET KEYCROI$=" ",KEYCROI$
		KEYCROI$[1,6]=CHKVEND USING "######"
		DO
			SEARCH #CH_OI,3,1;KEYCROI$,REC_CROI,E
			IF E>0 EXIT DO
			LET TMP3=KEYCROI$[1,6]
			IF TMP3<>CHKVEND EXIT DO
			READ RECORD #CH_OI,REC_CROI;CROI.;
			IF CROI.STATUSCODE$="1" AND CROI.transactiontype=2
				let tmp3=(croi.grossinvoiceamount-croi.paymentcurrentPeri-croi.paymentnextmo-croi.discountamount)
				IF PAYCHK+tmp3>=0
					IF DIVFLAG<>0
						IF croi.Division<DIV[0] GOTO nxtcrinvrel:                                         
						IF CRoi.Division>DIV[1] GOTO nxtcrinvrel:
					endif
					croi.paymentcurrentrun=croi.grossinvoiceamount-croi.paymentcurrentPeri-croi.paymentnextmo
					let paychk = paychk + croi.paymentcurrentrun - croi.discountamount
					let croi.statuscode$="3"
					write record #ch_oi,rec_croi;croi.;
					if paychk<=0 goto endcrinvrel:
				endif
			ENDIF
			nxtcrinvrel:! 
		LOOP	
	ENDIF
	endcrinvrel:	! end this may have gone negative 
	IF PAYCHK<0 and totrec<>0 ! has a negative balance ! need to get rid of the payment
		LET KEYCROI$=" ",KEYCROI$
		KEYCROI$[1,6]=CHKVEND USING "######"
		DO
			SEARCH #CH_OI,3,1;KEYCROI$,REC_CROI,E
			IF E>0 EXIT DO
			LET TMP3=KEYCROI$[1,6]
			IF TMP3<>CHKVEND EXIT DO
			READ RECORD #CH_OI,REC_CROI;CROI.;
			IF CROI.STATUSCODE$="2" or CRoi.STATUSCODE$="3" 
				IF CROI.transactiontype>0 AND CROI.transactiontype<3
					IF DIVFLAG<>0
						IF croi.Division<DIV[0] GOTO nxtUNcrinvrel:                                         
						IF CRoi.Division>DIV[1] GOTO nxtUNcrinvrel:
					endif
					croi.paymentcurrentrun=0
					let croi.statuscode$="1"
					write record #ch_oi,rec_croi;croi.;
					SEARCH #ch_apdh,2,1;Keycroi$,rec_apdh,E
					if not(e)
						read record #ch_apdh,rec_apdh,0;apdh.;
						croi.DiscountAmount=apdh.DiscountAvail
					endif
					croi.documentcode$=croi.transactiontype using "&"
					if croi.transactiontype=1
						if (croi.paymentcurrentPeri+croi.paymentnextmo)<>0
							let croi.documentcode$="0"
						endif
					endif
					write record #ch_oi,rec_croi;croi.;
				endif	
			endif
			nxtuncrinvrel:! 
		LOOP
	ENDIF
else
    include "src/callsuberr.inc"
end try
end sub ! apchkrel



!!! ========================================================

!!! Start invoice release
Sub GETAPFLAGS()! Get Vendor A/P Transactions
Try
	Clear List$[]
	List$[0]=bsdel$,"ApFlags",fdel$
	Webstr$=""
	Webstr$="DivFlag",fdel$
	Webstr$=webstr$,"BankFlag",fdel$
	Webstr$=webstr$,"ACHBankFlag",fdel$
	List$[1]=webstr$
	webstr$=""
	let tmp$="N"
	if c0[6] let tmp$="Y"
	webstr$=tmp$,fdel$! division flag
	let tmp$="N"
	if c0[8] let tmp$="Y"
	webstr$=webstr$,tmp$,fdel$! bank flag
	let tmp$="N"
	if p61$[99,99]="Y" let tmp$="Y"
    webstr$=webstr$,tmp$,fdel$! bank flag
	list$[2]=webstr$
	list$[3]=esdel$
	call AddToStr(e$,rstr$,List$[])
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)

else
    include "src/callsuberr.inc"
end try
end sub ! apflags
!============================================================================================================
Sub GetAPSelREL()! Release Payments for a Vendor or Next Vendor
Try
	dim 2%,jduedate,jdiscdate,japduedate,japdiscdate
	Dim 2%,divflag,div[1],bank,discflag,discountplus
	Dim 1%,achflag,warnflag
	dim 3%
	tmp3=0
	jduedate=0
	Call dxget("DUEDATE",tmp$)
	!if rtrim$(tmp$)=""
	!	let returnstatus=0
	!	let message$="Invalid Due Date Submitted"
	!	goto endapselrel:
	!endif
	if rtrim$(tmp$)<>""
		xdate$ = formatdate2$(tmp$)    
		tmp3 = xdate$[3,8]  ! yymmdd format
		if not(tmp3)
			let returnstatus=0
			let message$="Invalid Due Date Submitted"
			goto endapselrel:
		endif
		xdate$ = tmp3 Using "&&&&&&"                
		Call DateToJulian(5,xdate$,xdate$,errflag)
		if (errflag)
			let returnstatus=0
			let message$="Invalid Due Date Submitted"
			goto endapselrel:
		endif
		jduedate= xdate$ ! needs to be in julian
	endif
	tmp3=0
	jdiscdate=0
	discountplus=0

	Call dxget("DISCDATE",tmp$)
	if rtrim$(tmp$)<>""
		xdate$ = formatdate2$(tmp$)    
		tmp3 = xdate$[3,8]  ! yymmdd format
		if not(tmp3)
			let returnstatus=0
			let message$="Invalid Discount Date Submitted"
			goto endapselrel:
		endif
		xdate$ = tmp3 Using "&&&&&&"                
		Call DateToJulian(5,xdate$,xdate$,errflag)
		if (errflag)
			let returnstatus=0
			let message$="Invalid Discount Date Submitted"
			goto endapselrel:
		endif
		jdiscdate= xdate$ ! needs to be in julian
		discflag=0
		Call dxget("INELIGIBLEDISC",tmp$)
		if UCASE$(rtrim$(tmp$))="Y" let discflag=99
		if not (discflag)
			Call dxget("DAYSPASTDUE",tmp$)
			LET DISCOUNTPLUS=TMP$
		ENDIF
	endif
	let divflag=0;div[0]=0;div[1]=99 
	chkdivision: ! 
	if c0[6] ! divisional
		Call dxget("DIVRELEASE",tmp$)
		if UCASE$(rtrim$(tmp$))="Y" let divflag=99
		if divflag<>0
			Call dxget("STARTDIV",tmp$)
			let div[0]=tmp$
			if div[0]<0 or div[0]>99
				let returnstatus=0
				let message$="Invalid Starting Division Submitted"
				goto endapselrel:
			endif
			Call dxget("ENDDIV",tmp$)
			let div[1]=tmp$
			if div[1]<0 or div[1]>99
				let returnstatus=0
				let message$="Invalid Ending Division Submitted"
				goto endapselrel:
			endif
			if div[1]<div[0]
				let returnstatus=0
				let message$="Ending Division Must Be Greater Than Starting Division"
				goto endapselrel:
	 		endif
		endif
	Endif
	bankflag=0
	if c0[8] ! vendor by bank
		Call dxget("BANK",tmp$)
		LET BANK=TMP$
		IF NOT(BANK)
			let returnstatus=0
			let message$="Invalid Bank Number Submitted"
			goto endapselrel:
		ENDIF
	ENDIF
	let uncrflag=0
	Call dxget("UNCRRELEASE",tmp$)
	if UCASE$(rtrim$(tmp$))="Y" let uncrflag=99
	let manchkflag=0
	Call dxget("MANCHKRELEASE",tmp$)
	if UCASE$(rtrim$(tmp$))="Y" let manchkflag=99
	Call dxget("VENDID",tmp$)
	let vendid=tmp$
	if vendid<0 or vendid>999999
		let returnstatus=0
		let message$="Vendor"
		goto endapselrel:
	endif
	Call dxget("SEARCHTYPE",tmp$)
	let searchtype$=UCASE$(RTRIM$(tmp$))
	if searchtype$<>"NEXT" and searchtype$<>"EXACT" and searchtype$<>"PREV"
		let returnstatus=0
		let message$="Invalid Search Type Submitted"
		goto endapselrel:
	endif
	if searchtype$="NEXT" 
		LET VEND[0]=(VENDID+1)
		LET VEND[1]=999999
	endif
	if searchtype$="PREV"
		LET VEND[0]=0
		LET VEND[1]=(VENDID-1)
	ENDIF
	let achflag=0;achbank=0
	if p61$[99,99]="Y" 
		let filename$="2/VENDBANK"+STR$(INTCO)
		Call FindF(filename$,fileflag)  
		If not(fileflag)
			let returnstatus=0
			let message$="ACH Vendor File Does Not Exist "
			goto endapselrel:
		else
			ch_vbnk = FindChannel() ! need to get a channel #  
			rOpen #ch_vbnk,filename$ 
		endif
		Call dxget("ACHRELEASE",tmp$)
		if ucase$(rtrim$(tmp$))="Y" let achflag=99
		if achflag=99 ! need to open file
			Call dxget("ACHBANK",tmp$)
			LET achBANK=TMP$
			IF NOT(achBANK)
				let returnstatus=0
				let message$="Invalid ACH Bank Number Submitted"
				goto endapselrel:
			ENDIF
		endif
	endif
	CALL DXGET("PAYTOVENDOPT",tmp$) ! STAY
	let paytovendflag=0
	if UCASE$(rtrim$(tmp$))="Y" let paytovendflag=99
	let chan=ch_oi
	let ch_sort=0
	if paytovendflag<>0
		if searchtype$="EXACT"
			Call verifyvendor()
			if vendid<>vend.PayToVendorCode let vendid=vend.PayToVendorCode
		endif
		ch_sort=buildsort(e$,25,0)\ if ch_sort<0 error 42 ! create a sort file
		LET keyoi$=" ",keyoi$ 
		!let keyoi$[1,6]=vend[0] using "######"
		do
			search #ch_oi,3,1;keyoi$,rec_oi,e
			if e<>0
				exit do
			endif
			
				let tmp3=keyoi$[1,6] !
				keyvend$=" ",keyvend$
				keyvend$=tmp3 using "######"
				mode$="=" ! search mode 2
				dir=1
				clear vend.
				Rec_vend=filegeta80vm(e$,ch_vend,mode$,dir,keyvend$,vend.)
				if rec_vend<0
					let returnstatus=0
					let message$="Vendor "+str$(vendid)+" Not On File. "
				endif
				if searchtype$="EXACT"
					if vend.paytovendorcode=vendid
						read record#ch_oi,rec_oi;oi.;
						if oi.statuscode$>"0" and oi.statuscode$<"4"
							let keysort$=" ",keysort$
							let keysort$[1,6]=vend.paytovendorcode using "######"
							let keysort$[7]=keyoi$
							search #ch_sort,2,1;keysort$,rec_oi,e
							if e=1
								search #ch_sort,4,1;keysort$,rec_oi,e
							endif
						endif
					else
					let keyoi$[7,20]="zzzzzzzzzzzzzzzzzzzzzzzz"
				endif
			else
				if vend.paytovendorcode>=vend[0] and vend.paytovendorcode<=vend[1] ! add to the sort
					read record#ch_oi,rec_oi;oi.;
					if oi.statuscode$>"0" and oi.statuscode$<"4"
						let keysort$=" ",keysort$
						let keysort$[1,6]=vend.paytovendorcode using "######"
						let keysort$[7]=keyoi$
						search #ch_sort,2,1;keysort$,rec_oi,e
						if e=1
							search #ch_sort,4,1;keysort$,rec_oi,e
						endif
					endif
				else
					let keyoi$[7,20]="zzzzzzzzzzzzzzzzzzzzzzzz"
				endif
			endif
		loop
		let chan=ch_sort
	endif
	if searchtype$="EXACT"
		Call verifyvendor()
		If Not(ReturnStatus) Goto endapselrel:
		if vend.VendorOnHold<>0 ! vendor is on hold
			let returnstatus=0
			let message$="Vendor "+str$(vendid)+" Is On Hold "
			! let keyoi$[7,20]="zzzzzzzzzzzzzz"! bypass this vendor
			goto endapselrel:
		endif
		if p61$[99,99]="Y" and achflag<>0
			let keyvbnk$=vendid using "######"
			search #ch_vbnk,2,1;keyvbnk$,rec_vbnk,e
			If not(e)
				read record #ch_vbnk,rec_vbnk;vbnk.;
			else
				clear vbnk.
			endif
			if achbank<>vbnk.bank
				! let keyoi$[7,20]="zzzzzzzzzzzzzz"! bypass this vendor
				let returnstatus=0
				let message$="Vendor is not set-up for this ACH Bank "
				goto endapselrel:
			endif
			if rtrim$(vbnk.routing$)=""
				!let keyoi$[7,20]="zzzzzzzzzzzzzz"! bypass this vendor
				let returnstatus=0
				let message$="Vendor Routing is not set-up  "
				goto endapselrel:
			endif
			if rtrim$(vbnk.BankAcctId$)=""
				! let keyoi$[7,20]="zzzzzzzzzzzzzz"! bypass this vendor
				let returnstatus=0
				let message$="Vendor Bank Account is not set-up  "
				goto endapselrel:
			endif
		endif
		let chkvend=vendid
		let keyoi$=" ",keyoi$
		let keyoi$[1,6]=vendid using "######"
		do ! check if vendor has open items
			search #chan,3,1;keyoi$,rec_oi,e
			if (e)
				let returnstatus=0
				let message$="No Transactions Available for Payment for Vendor "+str$(vendid)
				goto endapselrel:
			endif
			let tmp3=keyoi$[1,6]
			if tmp3<>vendid
				let returnstatus=0
				let message$="No Transactions Available for Payment for Vendor "+str$(vendid)
				goto endapselrel:
			endif
			if p61$[99,99]="Y"
				if achflag<>0
					if achbank<>vbnk.bank goto endapselrel:
					if rtrim$(vbnk.routing$)="" goto endapselrel:
					if rtrim$(vbnk.BankAcctId$)="" goto endapselrel:
				!else
				!	if vbnk.bank<>0 goto endapselrel:
				!	if rtrim$(vbnk.routing$)<>"" goto endapselrel:
				!	if rtrim$(vbnk.BankAcctId$)<>"" goto endapselrel:
				endif
			endif
			read record#ch_oi,rec_oi;oi.;
			if oi.documentcode$<"3" or oi.documentcode$>"7"
				if oi.statuscode$>"0" and oi.statuscode$<"4"
					if jduedate<>0
						goto processduedate:
					else
						goto processopenitem:
					endif
				endif
			endif
			if oi.statuscode$>"0" and oi.statuscode$<"4"
				goto processopenitem: 
			endif
		loop ! check if vendor has open items
	endif
	LET keyoi$=" ",keyoi$
	let keyoi$[1,6]=vendid using "######"
	mode=3
	let totrec=0
	if searchtype$="NEXT"
		let chkvend=0
		let keyoi$=" ",keyoi$
		let keyoi$[1,6]=(vendid+1) using "######"
		! let keyoi$[7,20]="zzzzzzzzzzzzzz"
	endif
	if searchtype$="PREV"
		let chkvend=0
		let mode=6
		if (vendid-1)>0 
			let keyoi$=" ",keyoi$
			let keyoi$[1,6]=(vendid-1) using "######"
			let keyoi$[7,20]="zzzzzzzzzzzzzz"
		endif
	endif
	                      
	creditnum = 0                     
	payamt = 0;paydisc = 0;paychk = 0 
	ProcessDueDate: ! 
	do   ! release items by due date ~                                                                           
		search #chan,mode,1;keyoi$,rec_oi,e                                       
		if e<>0 exit do
		let tmp3=keyoi$[1,6]
		if p61$[99,99]="Y" and achflag<>0
			let keyvbnk$=tmp3 using "######"
			search #ch_vbnk,2,1;keyvbnk$,rec_vbnk,e
			If not(e)
				read record #ch_vbnk,rec_vbnk;vbnk.;
			else
				clear vbnk.
			endif
			if achbank<>vbnk.bank
				let keyoi$[7,20]="zzzzzzzzzzzzzz"! bypass this vendor
				goto nxtapselrel:
			endif
			if rtrim$(vbnk.routing$)=""
				let keyoi$[7,20]="zzzzzzzzzzzzzz"! bypass this vendor
				goto nxtapselrel:
			endif
			if rtrim$(vbnk.BankAcctId$)=""
				let keyoi$[7,20]="zzzzzzzzzzzzzz"! bypass this vendor
				goto nxtapselrel:
			endif
		endif
		if chkvend<>0 and tmp3<>chkvend
			If paychk > 0 And uncrflag <> 0 And totcred <> 0                 
				KEYCROI$ = " ",KEYCROI$                                         
				KEYCROI$[1,6] = chkvend Using "######" 
				srchcrselrel: ! Do     ! credits release                                                       
				Search #chan,3,1;KEYCROI$,rec_croi,e                         
				If e > 0 goto endcrselrel:                                            
				tmp3 = KEYCROI$[1,6]                                          
				If tmp3 <> chkvend goto endcrselrel:          
				Read Record #ch_oi,rec_croi;croi.;                            
				If croi.statuscode$ = "1" And croi.transactiontype = 2        
					tmp3 = (croi.grossinvoiceamount - croi.paymentcurrentperi - croi.paymentnextmo - croi.discountamount)                                       
					If paychk + tmp3 >= 0                                       
						If DIVFLAG                                                
							If croi.Division < DIV[0] Goto nxtcrselrel              
							If oi.Division > DIV[1] Goto nxtcrselrel                
						End If                                                    
						croi.paymentcurrentrun = croi.grossinvoiceamount - croi.paymentcurrentperi - croi.paymentnextmo                                           
						paychk = paychk + croi.paymentcurrentrun - croi.discountamount
                         IF CRoi.paymentcurrentRun=CRoi.grossinvoiceamount
						 LET CRoi.DocumentCode$="4"
						else
						let CRoi.DocumentCode$="6" ! part pay take discount
							endif                                                
						croi.statuscode$ = "3"                                    
						Write Record #ch_oi,rec_croi;croi.; 
						If paychk <= 0 Goto endcrselrel     
					End If                                
				End If                                  
				nxtcrselrel: !                                      
				goto srchcrselrel: ! 
			endif
			endcrselrel: ! end this                                              
			paychk = 0                                  
			totcred = 0                                                        
			exit do ! vendor <>
		endif
		read record #ch_oi,rec_oi;oi.;  
		if oi.statuscode$<"1" or oi.statuscode$>"3" goto nxtapselrel:
		If oi.documentcode$ = "3"
			if oi.statuscode$ <> "1"  goto nxtapselrel                
			If Not(manchkflag)                                                
				Goto nxtapselrel                                                
			Else                                                              
				If c0[8] <> 0                                                   
					If bank <> oi.banknumber Goto nxtapselrel                     
				End If  
				
				oi.statuscode$ = "3"                                            
				oi.paymentcurrentrun = oi.grossinvoiceamount - oi.paymentcurrentperi-oi.paymentnextmo                                                         
			        Write Record #ch_oi,rec_oi;oi.; 
				goto nxtapselrel:
			End If                                                            
		End If 
		IF DIVFLAG 
			IF oi.Division<DIV[0] GOTO nxtapselrel:                                         
			IF oi.Division>DIV[1] GOTO nxtapselrel:
		endif                                               
		IF oi.DocumentCode$>"7" GOTO nxtapselrel:
		if paytovendflag<>0 and ch_sort<>0
			let chkvend=keyoi$[1,6] ! checking by payto
		else
			chkvend=oi.vendorcode
		endif
		if oi.statusCode$="2" or oi.statuscode$="3"
			if oi.documentcode$<>"3"
				if oi.paymentcurrentrun<>0
					paychk = paychk + oi.paymentcurrentrun - oi.discountamount
					if paytovendflag<>0 and ch_sort<>0
						let chkvend=keyoi$[1,6] ! checking by payto
					else
						chkvend=oi.vendorcode
					endif
				endif
			endif
			!paychk = paychk + croi.paymentcurrentrun - croi.discountamount
			goto relpay: ! already released
		endif
		IF oi.StatusCode$<>"1" GOTO nxtapselrel: 
		!IF oi.DocumentCode$="3" and oi. GOTO nxtapselrel:    ! manual check 
		
		if oi.transactiontype=2 
			let totcred=totcred+1
			let uncrflag=uncrflag+1
			goto nxtapselrel:
		endif
		if jduedate<>0
			xdate$ = oi.duedate Using "&&&&&&"                
			Call DateToJulian(5,xdate$,xdate$,errflag)
			if errflag<>0 goto nxtapselrel:
			let japduedate=xdate$
			xdate$ = oi.discountdate Using "&&&&&&"                
			Call DateToJulian(5,xdate$,xdate$,errflag)
			if errflag<>0 goto nxtapselrel:
			let japdiscdate=xdate$
		
			! what is discountplus                                          
			if not(jdiscdate)
				IF japduedate>jduedate GOTO nxtapselrel: 
			else
				if not(discflag) ! release ineligle discount is no
					IF japdiscdate<jdiscdate AND japduedate>jduedate GOTO nxtapselrel:
				endif
				if oi.discountamount<>0 and discountplus<>0	
					IF japdiscdate>jdiscdate IF japdiscdate<=(jdiscdate+DISCOUNTPLUS) goto relpay:
				endif
				IF japduedate>jduedate IF japdiscdate>jdiscdate GOTO nxtapselrel: 
			endif
		endif
		relpay: ! release for payment
		let tmpvend=oi.vendorcode
		if paytovendflag<>0 and ch_sort<>0
			let tmpvend=oi.paytovendorcode
		endif
		if chkvend<>tmpvend
			keyvend$ = tmpvend Using "######" 
			mode$="="
			dir=1
			rec_vend = filegeta80vm(e$,ch_vend,mode$,dir,keyvend$,vend.)
			if rec_vend<0 ! invalid vendor
				let keyoi$[7,20]="zzzzzzzzzzzzzz"! bypass this vendor
				GOTO nxtapselrel:
			endif
			if vend.VendorOnHold<>0 ! vendor is on hold
				let keyoi$[7,20]="zzzzzzzzzzzzzz"! bypass this vendor
				GOTO nxtapselrel:
			endif
			if c0[8]
				if bank<>vend.bank
					let keyoi$[7,20]="zzzzzzzzzzzzzz"! bypass this vendor
					GOTO nxtapselrel:
				endif
			endif
			chkvend=tmpvend
		endif
		if oi.statuscode$="1"   
			! if jduedate=0 and jdiscdate=0 goto nxtapselrel:! no release if not due/disc date ! mary
			LET oi.paymentcurrentRun=oi.grossinvoiceamount-oi.paymentcurrentPeri-oi.paymentnextmo                                        
			IF oi.paymentcurrentRun=oi.grossinvoiceamount
				LET oi.DocumentCode$="4"
			else
				let oi.DocumentCode$="6" ! part pay take discount
			endif
			if jdiscdate<>0 and oi.discountamount<>0
				if not(discflag) ! take ineligible discounts = no                        
					IF jdiscdate>japdiscdate
						IF oi.paymentcurrentRun=oi.grossinvoiceamount
							LET oi.DocumentCode$="5"
						else
							LET oi.DocumentCode$="7"
						endif
						LET oi.discountamount=0
					endif
			
				endif
			endif
		        LET oi.StatusCode$="2" 
			if oi.transactiontype=2
				 LET oi.StatusCode$="3"     ! credit memo 
				 totcred=totcred-1
				 if totcred<0 let totcred=0
			endif
			IF SGN(oi.paymentcurrentRun)<>SGN(oi.grossinvoiceamount) GOTO nxtapselrel:
			if oi.paymentcurrentrun<>0
				paychk = paychk + oi.paymentcurrentrun - oi.discountamount
			endif
			write record #ch_oi,rec_oi;oi.;
		endif
		
		nxtapselrel: ! get next tran for release
	loop !  release items by due date 
	processopenitem: ! process open items
	if not(chkvend)
		let returnstatus=0
		let message$="No Transactions Available"
	else
		keyvend$ = chkvend Using "######" 
		mode$="="
		dir=1
		rec_vend = filegeta80vm(e$,ch_vend,mode$,dir,keyvend$,vend.)
		if rec_vend<0
			let returnstatus=0
			let message$="Vendor "+str$(chkvend)+" Not On File"
		endif
		!if paychk<0
			! need to release the payments
	endif
	call vendpayhdr() ! print the vendor heading
	LET KEYOI$=" ",KEYOI$
	let keyoi$[1,6]=chkvend using "######"
	totrec=0
	 
	do  ! process open item section
		search #chan,3,1;keyoi$,rec_oi,e
		if e<>0 exit do
		let tmp3=keyoi$[1,6]
		if tmp3<>chkvend exit do
		read record #ch_oi,rec_oi;oi.;
		if divflag<>0
			If oi.Division < Div[0] Goto nxtvendaptran: 
			If oi.Division > Div[1] Goto nxtvendaptran:
		endif
		if bank<>0
			If bank <> oi.BankNumber Goto nxtvendaptran:
		endif 
		if oi.statuscode$>"0" and oi.statuscode$<"4" ! accepted on purchase journal and not on check
			if oi.transactiontype<>3 ! 
				if not(totrec)
					call vendaptranhdr()
				endif
				call vendaptrandet()
				totrec=totrec+1
			endif
		endif
		nxtvendaptran: ! get next vendor ap transaction
	loop ! process open item section
	endapselrel: ! endaprel: 
	If not (chkvend) or returnstatus=0 OR totrec=0
		call vendpayhdr()
	endif
	if not(totrec)
		clear list$[]
		call vendaptranhdr()
	endif
	list$[row]=esdel$
	Call AddToStr(e$,rstr$,List$[])
	! check total section
	clear list$[]
	list$[0]=bsdel$,"CheckTotal",fdel$
	list$[1]="GrossAmount",fdel$,"DiscountAmount",fdel$,"CheckAmount",fdel$
	webstr$=""
	webstr$=(payamt using "-----------.##"),fdel$
	webstr$=webstr$+(paydisc using "-----------.##"),fdel$
	webstr$=webstr$+(paychk using "-----------.##"),fdel$
	list$[2]=webstr$
	list$[3]=esdel$
	call AddToStr(e$,rstr$,List$[])

	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! apselrel

!!!===========================================================================================================
Sub VENDPAYHDR()! Get Vendor Payment Heading - 520
Try
	Clear List$[]
	List$[0]=bsdel$,"VendorInfo",fdel$
	WebStr$="VendId",fdel$,"VendName",fdel$,"TermsDesc",fdel$
	Webstr$=Webstr$,"TermsPct",fdel$,"PayVendId",fdel$,"PayVendName",fdel$,"PayAddr1",fdel$
	Webstr$=Webstr$,"PayAddr2",fdel$,"PayAddr3",fdel$,"WarnNegChk",fdel$
        List$[1]=WebStr$
	row=2   
	if returnstatus<>0
		webstr$=""
		webstr$=str$(vend.VendorCode),fdel$
		webstr$=webstr$,rtrim$(vend.Name$),fdel$
		webstr$=webstr$,rtrim$(vend.TermsAlpha$),fdel$
		webstr$=webstr$,(vend.Terms using "##.##"),fdel$
		if not(vend.paytovendorcode) let vend.paytovendorcode=vend.vendorcode
		webstr$=webstr$,str$(vend.paytovendorcode),fdel$
		webstr$=webstr$,rtrim$(vend.PayToName$),fdel$
		webstr$=webstr$,rtrim$(vend.PayToAddress$),fdel$
		if rtrim$(vend.PayToOptAddress$)<>""
			webstr$=webstr$,rtrim$(vend.PayToOptAddress$),fdel$
			let tmp$=""
			let tmp$=rtrim$(vend.paytocity$)+" "+rtrim$(vend.paytostate$)," "+rtrim$(vend.paytozip$)
			webstr$=webstr$,rtrim$(tmp$),fdel$
		else
			let tmp$=""
			let tmp$=rtrim$(vend.paytocity$)+" "+rtrim$(vend.paytostate$)," "+rtrim$(vend.paytozip$)
			webstr$=webstr$,rtrim$(tmp$),fdel$
			let tmp$=""
			webstr$=webstr$,tmp$,fdel$
		endif
		let warnflag=0
		if Vend.VendorCode<>vend.paytovendorcode
			If paytovendflag=0 let warnflag=99 ! displaying by payto vendor
		else
			let keyapdh$[1,6]=Vend.Paytovendorcode using "######"
			Do
				search #ch_apdh,3,3;keyapdh$,rec_apdh,e
				if e<>0 exit do
				let tmp3=keyapdh$[1,6]\if tmp3<>Vend.Paytovendorcode exit do
				let tmp3=keyapdh$[7,12]
				if tmp3<>Vend.PaytoVendorCode
					let warnflag=99
					exit do
				else
					let tmp3=tmp3+1
					if tmp3>999999 exit do
					let keyapdh$=" ",keyapdh$
					let keyapdh$[1,6]=Vend.Paytovendorcode using "######"
					let keyapdh$[7,12]=tmp3 using "######"
				endif
			Loop
		endif
		let tmp$="N"
		if warnflag<>0 let tmp$="Y"
		webstr$=webstr$,tmp$,fdel$			
		
		list$[row]=webstr$
		row=row+1
	endif
	list$[row]=esdel$
	call AddToStr(e$,rstr$,List$[])
else
    include "src/callsuberr.inc"
end try
end sub ! VendPayHdr


!==========================================================================
!! Vendor a/p transaction hdr for payment
Sub VENDAPTRANHDR()! Get Vendor Payment Heading - 520
Try
	clear list$[]
	list$[0]=bsdel$+"VENDAPTRANHDR",fdel$! secto
	webstr$=""
	Webstr$="Transaction",fdel$
	Webstr$=webstr$,"Type",fdel$
	Webstr$=webstr$,"TranDate",fdel$
	Webstr$=webstr$,"DueDate",fdel$
	Webstr$=webstr$,"DiscDate",fdel$
	Webstr$=webstr$,"AmtDue",fdel$
	Webstr$=webstr$,"DiscPct",fdel$
	Webstr$=webstr$,"Discount",fdel$
	Webstr$=webstr$,"NetPayment",fdel$
	Webstr$=webstr$,"Hold",fdel$
	Webstr$=webstr$,"CheckNumber",fdel$
	webstr$=webstr$,"CheckDate",fdel$
	webstr$=webstr$,"Paid",fdel$
	webstr$=webstr$,"BankId",fdel$
	!if action$="APTRANSELREL"
		Webstr$=Webstr$,"TVENDID",fdel$,"TVENDNAME",fdel$
	! endif
	List$[1]=webstr$
	row=2
	tmpcnt=maxcnt	
else
    include "src/callsuberr.inc"
end try
end sub ! VendaptranHdr

!==========================================================================
!! Vendor a/p transaction hdr for payment
Sub VENDAPTRANDET()! Get Vendor Payment Heading - 520
Try
	
	
	
	webstr$=""                                                                 
			webstr$=webstr$,rtrim$(oi.InvoiceCode$),fdel$
			let tmp$="INV"
			if oi.TransactionType=2 let tmp$="C/M"
			if oi.TransactionType=3 let tmp$="M/C"
			if oi.StatusCode$="9" let tmp$="DEL"
			webstr$=webstr$,rtrim$(tmp$),fdel$
			If oi.InvoiceDate<>0 
				xdate$ = pdate$(oi.InvoiceDate)   
			Else                               
				xdate$ = "01/01/1900"                                             	
			endif
			webstr$=webstr$,rtrim$(xdate$),fdel$
			If oi.DueDate<>0 
				xdate$ = pdate$(oi.DueDate)   
			Else                               
				xdate$ = "01/01/1900"                                             	
			endif
			webstr$=webstr$,rtrim$(xdate$),fdel$ ! due date
			If oi.DiscountDate<>0 
				xdate$ = pdate$(oi.DiscountDate)   
			Else                               
				xdate$ = "01/01/1900"                                             	
			endif
			webstr$=webstr$,rtrim$(xdate$),fdel$ ! due date
			webstr$=webstr$,((oi.grossinvoiceamount-oi.paymentcurrentPeri-oi.paymentnextmo) USING "--------.##"),fdel$
			webstr$=webstr$,((oi.Terms/100) using "##.##"),fdel$
			webstr$=webstr$,(oi.DiscountAmount using "-------.##"),fdel$
			let tmp3=0
			if oi.PaymentCurrentRun<>0 let tmp3=(oi.paymentcurrentrun-oi.discountamount)
			webstr$=webstr$,(tmp3 USING "--------.##"),fdel$
			tmp$="N"
			if oi.DocumentCode$="8" let tmp$="Y" ! hold permanent
			if oi.DocumentCode$="9" let tmp$="C" ! hold for current check run
			webstr$=webstr$,tmp$,fdel$
            if oi.documentcode$="3"       
				webstr$=webstr$,(oi.checknumber using "######"),fdel$
				If oi.CheckDate<>0 
					xdate$ = pdate$(oi.CheckDate)   
				Else                               
					xdate$ = ""                                             	
				endif
				webstr$=webstr$,xdate$,fdel$
			else
				webstr$=webstr$,"",fdel$
				webstr$=webstr$,"",fdel$
				
			endif
			let tmp$="N"
			if oi.documentcode$>"3" and oi.documentcode$<"8"
				let tmp$="Y"
			endif
			let webstr$=webstr$,tmp$,fdel$
			if oi.documentcode$<>"3" and oi.paymentcurrentrun<>0
				let payamt=payamt+oi.paymentcurrentrun
				let paydisc=paydisc+oi.discountamount
				let paychk=paychk+oi.paymentcurrentrun-oi.discountamount
			endif
			if oi.documentcode$="3" 
				webstr$=webstr$,str$(oi.BankNumber),fdel$
			else
				webstr$=webstr$,"",fdel$
			endif
			!if action$="APTRANSELREL"
				Webstr$=Webstr$,str$(oi.vendorcode),fdel$
				let vendname$=" ",vendname$
				let keyvend$=" ",keyvend$
				let keyvend$[1,6]=oi.vendorcode using "######"
				search #ch_vend,2,1;keyvend$,rec_vend,e
				if not(e)
					mat read #ch_vend,rec_vend,0;vendname$;
				endif
				let webstr$=webstr$,rtrim$(vendname$),fdel$
			!endif
			!!! mtg need tvendid and tvendname
			list$[row]=webstr$
			row = row + 1                                         
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
else
    include "src/callsuberr.inc"
end try
end sub ! VendaptraNDET

!==========================================================================
!!! SUBMIT ITEMS FOR PAYMENT
Sub SUBMITAPRELEASE()! Get Vendor Payment Heading - 520
Try
	dim keycash$[30],3%,rec_cash
	eflag=0
    Call dxget("VENDID",tmp$)                              
	vendid = tmp$                                          
	Call verifyvendor()                                    
  	if not(returnstatus) Goto endsubaprelease:
    Call dxget("TOTREC",tmp$)                              
	totrec = tmp$                                          
	If totrec <= 0                                         
		Message$ = "Invalid Number of Records for Submission"
		returnstatus = 0                                     
		Goto endsubaprelease:                                  
	End If
	Message$=""
	For CTR=1 TO TOTREC
		Call dxget("TRANSACTION"+STR$(CTR),tmp$)                         
		If RTrim$(tmp$) = ""                                   
			Message$ = Message$+" Invalid Transaction Id Submitted "       
			returnstatus = 0
			eflag=eflag+1
			Goto nxtsubrel:                                    
		End If                                                 
		transid$ = RTrim$(tmp$) + blank$                       
		Call dxget("TRANSTYPE"+str$(ctr),tmp$)                           
		transtype = 0                                          
		If UCase$(RTrim$(tmp$)) = "INV" Let transtype = 1      
		If UCase$(RTrim$(tmp$)) = "C/M" Let transtype = 2      
		If UCase$(RTrim$(tmp$)) = "M/C" Let transtype = 3      
		If Not(transtype)                                      
			Message$ = Message$+" Invalid Trans Type Submitted For Trans"+rtrim$(transid$)
			let returnstatus=0
			eflag=eflag+1
			goto nxtsubrel:
		endif
		Call dxget("TVENDID"+str$(ctr),tmp$)                           
		tvendid = vendid
		if rtrim$(tmp$)<>"" let tvendid=tmp$
		if tvendid<=0 or tvendid>999999
			let tvendid=vendid
		endif
		keyoi$ = " ",keyoi$                                                       
		keyoi$[1,6] = tvendid Using "######"                                       
		keyoi$[7,18] = transid$                                                   
		keyoi$[19,20] = transtype Using "##"                                      
		Search #ch_oi,2,1;keyoi$,rec_oi,e
		if e>0
			message$=Message$+" Transaction "+rtrim$(transid$)+" Not On File"
			returnstatus=0
			let eflag=eflag+1
			goto nxtsubrel:
		endif
		read record#ch_oi,rec_oi;oi.;
		if oi.statuscode$<="0" or oi.statuscode$>="4"
			message$=Message$+" Transaction "+rtrim$(transid$)+" Has Invalid Status Code"
			returnstatus=0
			let eflag=eflag+1
			goto nxtsubrel:
		endif
		if oi.transactiontype=3
			message$=Message$+" Transaction "+rtrim$(transid$)+" already Manual Check"
			returnstatus=0
			let eflag=eflag+1
			goto nxtsubrel:	
		endif
		Call dxget("HOLD"+STR$(CTR),tmp$)
		If ucase$(rtrim$(tmp$))="C"
			let oi.paymentcurrentrun=0
			let oi.documentcode$="9" ! hold current period
			let oi.statuscode$="1" 
			write record #ch_oi,rec_oi;oi.;
			goto nxtsubrel:
		else
			If ucase$(rtrim$(tmp$))="Y"
				let oi.paymentcurrentrun=0
				let oi.documentcode$="8" ! hold permanent
				let oi.statuscode$="1" 
				write record #ch_oi,rec_oi;oi.;
				goto nxtsubrel:
			endif
		endif
		let oi.statuscode$="1"
		let oi.paymentcurrentrun=0
		let oi.documentcode$=oi.transactiontype using "#"
		if oi.paymentcurrentperi<>0 or oi.paymentnextmo<>0
			let oi.documentcode$="0"
		endif
		Call dxget("NETPAYMENT"+STR$(CTR),tmp$)
		LET OI.PAYMENTCURRENTRUN=TMP$
		if fra(oi.paymentcurrentrun*100)<>0
			returnstatus = 0                         
			Message$=mESSAGE$+" Invalid Pay Amt For "+rtrim$(transid$)
			eflag=eflag+1
			goto nxtsubrel
		endif
		
		Call DXGET("PAID"+STR$(CTR),tmp$)
		let payflag=0
		if rtrim$(tmp$)="Y"
			if oi.GrossInvoiceAmount=0 let payflag=99
		endif
		if oi.paymentcurrentrun<>0 let payflag=99
		if payflag<>0
			if oi.paymentcurrentrun<>0
				Call dxget("DISCOUNT"+STR$(CTR),tmp$)
				let oi.discountamount=tmp$
				if fra(oi.discountamount*100)<>0
					returnstatus = 0                         
					Message$=mESSAGE$+" Invalid Disc Amt For "+rtrim$(transid$)
					eflag=eflag+1
					goto nxtsubrel
				endif
				if oi.transactiontype<>2
					if oi.discountamount<0
						returnstatus = 0 
						Message$=mESSAGE$+" Invalid Disc Amt For "+rtrim$(transid$)
						eflag=eflag+1
						goto nxtsubrel
					endif
				else
					if oi.discountamount>0
						returnstatus = 0 
						Message$=mESSAGE$+" Invalid Disc Amt For "+rtrim$(transid$)
						eflag=eflag+1
						goto nxtsubrel
					endif
				endif
				if oi.discountamount<>0
					let oi.paymentcurrentrun=oi.paymentcurrentrun+oi.discountamount
					Call dxget("DISCPCT"+STR$(CTR),tmp$)
					LET TMP3=TMP$
					oi.Terms = (TMP3 * 100)
					if oi.transactiontype<>2
						! verify if amount paying with discount is greater the invoice
						if (oi.paymentcurrentrun-oi.discountamount)>=oi.grossinvoiceamount
							returnstatus=0
							Message$=mESSAGE$+" Invalid Disc Amt For "+rtrim$(transid$)
							eflag=eflag+1
							goto nxtsubrel
						endif
						if oi.paymentcurrentrun>(oi.grossinvoiceamount-oi.paymentnextmo-oi.paymentcurrentperi)
							returnstatus=0
							Message$=mESSAGE$+" Invalid Disc Amt For "+rtrim$(transid$)
							eflag=eflag+1
							goto nxtsubrel
						endif
					else ! credit memo
						if oi.paymentcurrentrun<(oi.grossinvoiceamount-oi.paymentnextmo-oi.paymentcurrentperi)
							returnstatus=0
							Message$=mESSAGE$+" Invalid Disc Amt For "+rtrim$(transid$)
							eflag=eflag+1
							goto nxtsubrel
						endif
						if (oi.paymentcurrentrun-oi.discountamount)<=oi.grossinvoiceamount
							returnstatus=0
							Message$=mESSAGE$+" Invalid Disc Amt For "+rtrim$(transid$)
							eflag=eflag+1
							goto nxtsubrel
						endif
					endif
				endif
			! rem		
		    endif
			! SET DOCUMENT CODE
			iF OI.PAYMENTCURRENTRUN<>0
				LET OI.DOCUMENTCODE$="4"
				IF NOT (oi.discountamount) LET OI.DOCUMENTCODE$="5"
				IF ABS(OI.PAYMENTCURRENTRUN+oi.discountamount)<ABS(oi.grossinvoiceamount)
					LET OI.DOCUMENTCODE$="6"
					IF NOT(oi.discountamount) LET OI.DOCUMENTCODE$="7"
				ENDIF
			ENDIF			
			let oi.statuscode$="2"
			if oi.transactiontype=2 let oi.statuscode$="3"
			Call dxget("CHECKNUMBER"+STR$(CTR),tmp$)
			tmp3=0
			If rtrim$(tmp$)<>""
				let tmp3=tmp$
				if tmp3<1 or tmp3>999999
					returnstatus = 0                         
					Message$=mESSAGE$+" Invalid Check Number For "+rtrim$(transid$)
					eflag=eflag+1
					goto nxtsubrel
				endif
				! need to see if check number has already been issued for this vendor  -- mgd
				let keyapdh$=" ",keyapdh$
				let keyapdh$[1,6]=vendid using "######"
				let keyapdh$[7,12]=tmp3 using "######"
				let keyapdh$[19,20]=" 9"
				search #ch_apdh,2,1;keyapdh$,rec_apdh,e
				If not(e)
					returnstatus=0
					Message$=Message$+" Check Number "+str$(tmp3)+" has already been issued to this vendor. "
					let eflag=eflag+1
					goto endsubaprelease:
				endif
			endif
			if tmp3<>0 ! check number
				let oi.checknumber=tmp3
				let oi.documentcode$="3"
				let oi.statuscode$="3"
				Call dxget("CHECKDATE"+STR$(CTR),tmp$)                 
				If RTrim$(tmp$) = ""                       
					returnstatus = 0                         
					Message$=mESSAGE$+" Invalid Check Date For "+rtrim$(transid$)
					eflag=eflag+1
					goto nxtsubrel:	
				endif
				xdate$ = formatdate2$(tmp$)                
				tmp3 = xdate$[3,8] ! yymmdd format         
				If Not(tmp3) 
					returnstatus = 0                         
					Message$=mESSAGE$+" Invalid Check Date For "+rtrim$(transid$)
					eflag=eflag+1
					goto nxtsubrel:	
				endif
				let oi.checkdate=tmp3
				Call dxget("BANK"+STR$(CTR),tmp$)
				let tmp3=tmp$
				if tmp3<=0 or tmp3>99
					returnstatus = 0                         
					Message$=mESSAGE$+" Invalid Bank For "+rtrim$(transid$)
					eflag=eflag+1
					goto nxtsubrel:	
				endif
				oi.banknumber=tmp$
				if p61$[136,136]="Y"
					let keycash$=" ",keycash$
					let keycash$[1,2]=tmp3 using "##"
					search #ch_cash,2,1;keycash$,rec_cash,e
					if e<>0
						let message$=message$+" Bank "+str$(tmp3)+" Not On File "
						returnstatus=0
						eflag=eflag+1
						goto nxtsubrel:
					endif
					read record #ch_cash,rec_cash;apcash.;	
					if apcash.currid<>0
						if apcash.currid<>oi.currid
							let message$=message$+"Bank "+str$(tmp3)+" Currency does not match AP Transaction "
							let returnstatus=0
							eflag=eflag+1
							goto nxtsubrel:
						endif
						if apcash.currid<>vend.currid
							let message$="Bank "+str$(tmp3)+" Currency does not match Vendor's Currency "
							let returstatus=0
							eflag=eflag+1
							goto nxtsubrel:
						endif
					endif					
				endif
			endif
		endif		
		write record #ch_oi,rec_oi;oi.;
		nxtsubrel: ! get next items to release/unrelease
       	next ctr
	endsubaprelease: ! end releasing transactions
	if returnstatus<>0 and eflag=0 let message$="Submitted"	
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else	
	 include "src/callsuberr.inc"
end try
end sub ! SubmitApRelease
!--------------------------------------------------------------------
Sub StartReport()! startReport
 Try
	ReturnStatus=1
	Message$="OK"
	Call dxget("SOURCE",tmp$)
	LET SOURCE=TMP$
	Call GetAcctPer()
	clear list$[]
	List$[0]=bsdel$,"AccountPeriod",fdel$
	WebStr$="Name",fdel$,"Period",fdel$
	list$[1]=webstr$
	Webstr$="Current Month",fdel$,currper$[1,5],fdel$
	list$[2]=webstr$
	Webstr$="Next Month",fdel$,nxtper$[1,5],fdel$
	list$[3]=webstr$
	If source=518! list
		webstr$="All",fdel$,"0",fdel$
		list$[4]=webstr$
	endif
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section	
	! get control flags
	Call GetClient()
	Clear List$[]
	List$[0]=bsdel$,"APControl",fdel$
	Webstr$=""
	webstr$="ClientId",fdel$
	webstr$=webstr$,"ClientName",fdel$
	webstr$=webstr$,"APPOFlag",fdel$
	webstr$=webstr$,"DivFlag",fdel$
	webstr$=webstr$,"DefaultDiv",fdel$
	webstr$=webstr$,"BankFlag",fdel$
	List$[1]=webstr$
	webstr$=str$(clientid),fdel$
	webstr$=webstr$,rtrim$(clientname$),fdel$
	let tmp$="N"
	if c0[4]<>0 AND spo<>0 let tmp$="Y"
	webstr$=webstr$,tmp$,fdel$
	let tmp$="N"
	if c0[6]<>0 let tmp$="Y"
	webstr$=webstr$,tmp$,fdel$
	if c0[6]<>0 !and prt.div>0 
		if prt.div<=0 let prt.div=1 ! default to 1
		webstr$=webstr$,str$(prt.div),fdel$
	else
		webstr$=webstr$,"",fdel$
	endif
	tmp$="N"
	if c0[8] let tmp$="Y" ! bank flag
	webstr$=webstr$,tmp$,fdel$
	List$[2]=webstr$
	

	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! print section
	clear list$[]
	list$[0]=bsdel$,"Printers",fdel$
	List$[1]="Name",fdel$,"Id",fdel$,"Default",fdel$
	call AddToStr(e$,rstr$,List$[])
	pdfoption=1 ! pdf
	xmloption=0 ! BROWSER
	Call dxget("SOURCE",tmp$)
	LET SOURCE=TMP$
	! CHECK SOURCE 
	if source=512 let pdfoption=0 ! pdf not allowed
	If source=519 let pdfoption=0  ! pdf not allowed
	If source=540 let pdfoption=0 ! pdf not allowed *mtg
        Call blockPrintersDropList(rstr$,xmloption,pdfoption)
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! StartReport

!=========================================================================================================
Sub Start511Report()! startReport
 Try
	dim uacname$[20]
	ch_uac=OpenFile(-9988, intCo)
	ReturnStatus=1
	Message$="OK"
	Keyapc$ = " 0"
	Search #ch_apc,2,1;Keyapc$,Rec_apc,E
	if e>0
		let returstatus=0
		message$=message$+"RECORD '0' NOT FOUND IN A00AP"
		goto end511report:
	else

		Mat Read #ch_apc,rec_apc,2;apR$;
		If apR$[61,61] =" " 
			returnstatus=0
			message$=message$+"PURCHASE JOURNAL IS IN PROCESS ELSEWHERE...PLEASE TRY AGAIN LATER..."
			Goto end511report
		endif
	endif
	! open printer
	try Close #0 Else Rem
	onchannelno=0 ! zero for channel 
	printchan = openprinter(e$,onchannelno) 
	Call dxget("REPORTOPT",tmp$) \ repopt= tmp$ !! print vendor code or entered by
	if repopt<1 or repopt>3
		returnstatus=0
		message$=message$+"Invalid Report Print Option Submitted"
		Goto end511report
	endif
	Call Dxget ("ACCTPER",tmp$) ! MM/YY
	if rtrim$(tmp$)=""
		let returnstatus=0
		message$="Invalid Accounting Period" 
		goto end511report:
	endif
	if tmp$[3,3]<>"/"
		let returnstatus="Invalid Accounting Period Format Submitted"
		goto end511report:
	endif
	let period$=tmp$[4,5],tmp$[1,2]
	let acctper=period$
	Call Dxget ("BATCHID",tmp$) ! 
	let batchid=tmp$
	if batchid<=0 or batchid>999999
		let returnstatus=0
		let message$="Invalid Batch Id Submitted"
		goto end511report:
	endif
	if batchid<>0	
		let keybatch$=" ",keybatch$
		LET keybatch$[1,4]=acctper using "####"
		let keybatch$[5,10]=batchid using "######"
		search #ch_bth,2,1;keybatch$,rec_bth,e
		if e<>0 
			let returnstatus=0
			let message$="Batch Id "+str$(batchid)+" Not On File" 
			goto end511report:
		endif
		Clear List$[]
		read record #ch_bth,rec_bth;apbth.;
		if apbth.status=0 
			returnstatus=0                                                    
			message$="Batch is in Process"
			if apbth.uarec<>0
				try
					read #ch_uac,apbth.uarec,280;UACNAME$;
					let message$=message$+" by "+rtrim$(uacname$)+". Please have user reset this batch. "
				else
					rem
				end try
			endif
			goto end511report:
		endif
		if apbth.status=2 and apbth.UARec<>rec_uac
			returnstatus=0
			message$="Data Entry List in Process"
			if apbth.uarec<>0
				try
					read #ch_uac,apbth.uarec,280;UACNAME$;
					let message$=message$+" by "+rtrim$(uacname$)+". Please have user reset this batch. "
					
				else
					rem
				end try
			endif
			goto end511report:
		endif                                                     
                if apbth.status=3
			let returnstatus=2
			message$="DATA ENTRY LIST HAS BEEN ACCEPTED!!!"
		endif
		if apbth.status=4
			returnstatus=0
			message$="Purchase Journal is in Process"
			if apbth.uarec<>0
				try
					read #ch_uac,apbth.uarec,280;UACNAME$;
					let message$=message$+" by "+rtrim$(uacname$)+"Please have user complete purchase journal process."
				else
					rem
				end try
			endif
			goto end511report:
		endif                                                         
		IF apbth.status=6
			message$="BATCH HAS ALREADY BEEN ACCEPTED!!!"
			returnstatus=0
			goto end511report:
                endif                                                         
		IF apbth.status=9 
			let message$="BATCH HAS BEEN DELETED!!!"
			returnstatus=0
			goto end511report:
		endif
	
	endif
	let apbth.status=2 ! set to inprocess data enetyr list
	let apbth.UARec=rec_uac
	write record #ch_bth,rec_bth;apbth.;
	Call dxget("PRPRT",tmp$) ! (NOT ADDED?)     
	audonly = 0
	If UCASE$(RTRIM$(tmp$))="Y" Let audonly = 1
	! set up parameters for call
	clear spec[]
	spec[0]=intco ! company #
	spec[1]=repopt ! 1= vendor Code, 2 = entered
	spec[2]=Audonly
	spec[3]=batchid
	spec[4]=Acctper
	Call dxget("PRINTER",tmp$)
	IF RTRIM$(UCASE$(TMP$))="P" let spec[5]=99
	spec[8]=rec_uac
	spec[9]=returnstatus
	clear chan[]
	chan[20]=ctlc                          
	if c0[4]                      
		chan[0]=ch_appoh         
		chan[1]=ch_appol                  
		if spo<>0             
			chan[2]=ch_poc
                endif         
		chan[3]=ch_poh                     
		chan[4]=Ch_pol                    
		chan[9]=ch_prod                
		chan[10]=ch_wh        
		chan[12]=ch_nstk      
		chan[18]=ch_ccode           
        endif                        
	chan[5]= ch_di! a20di                  
	chan[6]= ch_oi! a20oi =CH_OI            
	chan[7]= ch_apdh! apdeth=CH_APD 
	chan[8]= ch_bth
	chan[11]=ch_misc ! pomisc            
	chan[14]=ch_vend !  vendor      
	chan[15]=ch_apc ! aooap file  
	chan[17]=ch_vl                           
	if c0[6]<>0              
		chan[19]=ch_apdiv
	endif   
	chan[21]=ch_acf
	try
		close #ch_apda
	else
	end try
	chan[22]=0 ! ch_apda open at the time of report
	message$=""
	Call "la511.dl4",CHAN[],SPEC[],MESSAGE$,rstr$
	LET returnstatus=spec[9]
	if returnstatus<>0 and message$="" let message$="Report Complete"
	end511report: ! 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! Start511

!=========================================================================================================
Sub Start512Report()! startReport
 Try
	dim uacname$[20]
	ch_uac=OpenFile(-9988, intCo)
	ReturnStatus=1
	Message$="OK"
	Keyapc$ = " 0"
	Search #ch_apc,2,1;Keyapc$,Rec_apc,E
	if e>0
		let returstatus=0
		message$=message$+"RECORD '0' NOT FOUND IN A00AP"
		goto end512report:
	else

		Mat Read #ch_apc,rec_apc,2;apR$;
		If apR$[61,61] =" " 
			returnstatus=0
			message$=message$+"PURCHASE JOURNAL IS IN PROCESS ELSEWHERE...PLEASE TRY AGAIN LATER..."
			Goto end512report
		endif
	endif
	! open printer
	try Close #0 Else Rem
	onchannelno=0 ! zero for channel 
	printchan = openprinter(e$,onchannelno) 
	LET PAGEBRK=0
	IF C0[4]<>0
		Call dxget("PAGEBREAK",tmp$) ! page break for purchase orders
		IF uCASE$(RTRIM$(TMP$))="Y" let pagebrk=1
	endif
	Call Dxget ("ACCTPER",tmp$) ! MM/YY
	if rtrim$(tmp$)=""
		let returnstatus=0
		message$="Invalid Accounting Period" 
		goto end512report:
	endif
	if tmp$[3,3]<>"/"
		let returnstatus=0
		message$="Invalid Accounting Period Format Submitted"
		goto end512report:
	endif
	let period$=tmp$[4,5],tmp$[1,2]
	let acctper=period$
	Call GetAcctPer()
	if acctper=currper
		let spec1[5]=0
	else
		if acctper=nxtper
			spec1[5]=1 
		else
			let returnstatus=0
			message$="Accounting Period Must Be Current or Next Month"
			goto end512report:
		endif
	endif
	!Call Dxget("POSTDAY",tmp$)
	Call Dxget("POSTDATE",tmp$)
	let tmp3=tmp$
	if tmp3<=0 or tmp3>31
		let returnstatus=0
		message$="Invalid Posting Day Submitted"
		goto end512report:
	endif
	let tmp$=tmp3 using "&&"
	let xdate$=period$,tmp$[1,2]
	tmpdate$=xdate$[3,4],"/",xdate$[5,6],"/20",xdate$[1,2] ! tmpdate$="mm/dd/yyyy"
	Call VerifyDate(tmpDate$,tmp$,errflag,1) ! returns in yyyymmd
	if errflag<>0
		let returnstatus=0
		let message$="Invalid Posting Day Submitted "
		goto end512report:
	endif
	!xdate$ = formatdate2$(tmp$)
	POSTDATE =  xdate$! [3,8]  
	LET TMP3=XDATE$[1,4]
	IF TMP3<>ACCTPER
		let returnstatus=0
		message$="Posting Date Must Match Accounting Period Selected"
		goto end512report:	
	endif
	Call Dxget ("BATCHID",tmp$) ! 
	let batchid=tmp$
	if batchid<=0 or batchid>999999
		let returnstatus=0
		let message$="Invalid Batch Id Submitted"
		goto end512report:
	endif
	if batchid<>0	
		let keybatch$=" ",keybatch$
		LET keybatch$[1,4]=acctper using "####"
		let keybatch$[5,10]=batchid using "######"
		search #ch_bth,2,1;keybatch$,rec_bth,e
		if e<>0 
			let returnstatus=0
			let message$="Batch Id "+str$(batchid)+" Not On File" 
			goto end512report:
		endif
		Clear List$[]
		read record #ch_bth,rec_bth;apbth.;
		if apbth.status=0 
			returnstatus=0                                                    
			message$="Batch is in Entry Process"
			if apbth.uarec<>0
					try
						read #ch_uac,apbth.uarec,280;UACNAME$;
						let message$=message$+" by "+rtrim$(uacname$)+". Please have user reset this batch. "
					else
						rem
					end try
				endif
			goto end512report:
		endif
		if apbth.status=1 
			returnstatus=0
			message$="Data Entry List Needs To Be Accepted. Please Run Data Entry List, review and accept." 
			
			goto end512report:
		endif                                          
		if apbth.status=2 
			returnstatus=0
			message$="Data Entry List is in Process" 
			if apbth.uarec<>0
				try
					read #ch_uac,apbth.uarec,280;UACNAME$;
					let message$=message$+" by "+rtrim$(uacname$)+". Please have user reset this batch. "
				else
					rem
				end try
			endif
			goto end512report:
		endif                                                     
                
		if apbth.status=4
			returnstatus=0
			!message$="PURCHASE JOURNAL IS IN PROCESS!!!"
			if apbth.uarec<>0
				try
					read #ch_uac,apbth.uarec,280;UACNAME$;
					let message$=message$+" by "+rtrim$(uacname$)+". Please have user complete purchase journal process. "
				else
					rem
				end try
			endif
			goto end512report:
		endif                                                         
		IF apbth.status=6
			message$="BATCH HAS ALREADY BEEN ACCEPTED!!!"
			returnstatus=0
			goto end512report:
                endif                                                         
		IF apbth.status=9 
			let message$="BATCH HAS BEEN DELETED!!!"
			returnstatus=0
			goto end512report:
		endif
		if apbth.status<>3
			let message$="Error in Batch Status!!!"
			returnstatus=0
			goto end512report:
		endif
	endif
	let apbth.status=4 ! set to inprocess Purchase Journal
	let apbth.UARec=rec_uac
	write record #ch_bth,rec_bth;apbth.;
	Call dxget("PRPRT",tmp$) ! (NOT ADDED?)     
	audonly = 0 ! \ If tmp$ <> "" Let audonly = 1
	If UCASE$(RTRIM$(tmp$))="Y" Let audonly = 1
	! set up parameters for call
	clear spec1[]
	spec1[0]=intco ! company #
	spec1[1]=PAGEBRK ! 1= PAGEBREAK
	spec1[2]=Audonly
	spec1[3]=batchid
	spec1[4]=Acctper
	spec1[5]=0 ! current or next month
	if nxtper=acctper let spec1[5]=1 ! flag as next month
	spec1[6]=postdate ! yymmdd format
	spec1[8]=rec_uac
	spec1[9]=returnstatus
	Call "la512.dl4",SPEC1[],MESSAGE$,rstr$
	LET returnstatus=spec1[9]
	end512report: ! 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! Start512Report

!=================================================================================
Sub GETDELAPTRANS() ! gets the ap transaction to delete
Try
	DIM DELMSG$[50]
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	! section 1
	Call GetAPVendDet()
	if not (returnstatus) goto endgetdelaptran:
	Call ValidateBatch() ! checks acct per & batch id
	if not(returnstatus) goto endgetdelaptran:
	Call Dxget("INVOICECODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto endgetdelaptran:
	endif
	let transid$=rtrim$(tmp$)+blank$
	Call Dxget("TRANSTYPE",tmp$)
	let transtype=0
	if ucase$(rtrim$(Tmp$))="INV" let transtype=1
	if ucase$(rtrim$(Tmp$))="C/M" let transtype=2
	if ucase$(rtrim$(Tmp$))="M/C" let transtype=3
	IF not(transtype)
		let message$="Invalid Transaction Type Submitted"
		let returnstatus=0
		goto EndGetDelApTran:
	endif
	newtrans=0 ! no
	let keyoi$=" ",keyoi$
	let keyoi$[1,6]=vendid using "######"
	let keyoi$[7,18]=transid$
	let keyoi$[19,20]=transtype using "##"
	search #ch_oi,2,1;keyoi$,rec_oi,e
	if e>1
		let message$="Error In A/P Open Item File. May Not Create Transaction "+str$(e)
		returnstatus=0
		goto EndGetDelApTran:
	endif
	if e=1 ! new record !
		let returnstatus=0
		let message$="Transaction "+rtrim$(transid$)+" Not on File for Vendor "+str$(VendId)
		goto EndGetDelApTran:	                                              	
	else ! existing record
		NEWTRANS=0
		read record #ch_oi,rec_oi;oi.;
		IF oi.StatusCode$>"1" and oi.StatusCode$<="6"
			let returnstatus=0
			let message$="Transaction "+rtrim$(transid$)+" Already Paid or in Payment Process "+str$(VendId)
			goto EndGetDelApTran:
		endif
		IF oi.StatusCode$>="9" 
			let returnstatus=0
			let message$="Transaction "+rtrim$(transid$)+" Already Deleted "+str$(VendId)
			goto EndGetDelApTran:
		endif
		if oi.StatusCode$="0" ! in entry process
			if oi.BatchNumber<>batchid or oi.PostingPeriod<>acctper
				let returnstatus=0
				let message$="Transaction "+rtrim$(transid$)+" Already Entered in Batch "+str$(oi.BatchNumber)
				goto EndGetDelApTran:
			endif
			Message$="Transaction Has Not Been Accepted "
			DelMsg$="Transaction Has Not Been Accepted "
		else
			if oi.StatusCode$<>"1"
				let returnstatus=0
				let message$="Transaction "+rtrim$(transid$)+" Not Available for Delete"
				goto EndGetDelApTran:
			else
				if (oi.PaymentCurrentRun)<>0 or (oi.PaymentCurrentPeri)<>0 or (oi.PaymentNextMo)<>0
					let returnstatus=0
					let message$="Transaction "+rtrim$(transid$)+" Already Has Payments Applied. May Not Delete."
					goto EndGetDelApTran:
				else
					Message$="Transaction Accepted on Purchase Journal"
					Delmsg$="Transaction Accepted on Journal"
					        
				endif
			endif
		endif
	endif
	EndGetDelApTran: !
	 
	! section 2
	clear list$[]
	list$[0]=bsdel$,"APTransaction",fdel$
	webstr$=""
	webstr$="VendId",fdel$
	webstr$=webstr$,"InvoiceCode",fdel$
	Webstr$=webstr$,"TranType",fdel$
	webstr$=webstr$,"InvoiceDate",fdel$
	webstr$=webstr$,"DiscountDate",fdel$
	webstr$=webstr$,"DueDate",fdel$
	webstr$=webstr$,"GrossInvAmt",fdel$
	webstr$=webstr$,"DiscountableAmt",fdel$
	webstr$=webstr$,"TermsPct",fdel$
	webstr$=webstr$,"DiscountAmt",fdel$
	webstr$=webstr$,"PONumber",fdel$
	webstr$=webstr$,"Division",fdel$
	webstr$=webstr$,"CheckNumber",fdel$
	webstr$=webstr$,"CheckDate",fdel$
	webstr$=webstr$,"BankNumber",fdel$
	webstr$=webstr$,"NewRecord",fdel$
	webstr$=webstr$,"CalcTermDate",fdel$
	webstr$=webstr$,"SetDiscountable",fdel$
	webstr$=webstr$,"DELMSG",fdel$
	list$[1]=webstr$
	row=2
	if returnstatus=1 ! no errors
		if oi.transactiontype=2 ! need to reverse sign on display items
			oi.GrossInvoiceAmount=oi.GrossInvoiceAmount*(-1)
			oi.DiscountableAmount=oi.DiscountableAmount*(-1)
			oi.DiscountAmount=oi.DiscountAmount*(-1)
		endif
		let webstr$=""
		webstr$=str$(vendid),fdel$
		webstr$=webstr$,rtrim$(transid$),fdel$
		let tmp$="INV"
		if transtype=2 let tmp$="C/M"
		if transtype=3 let tmp$="M/C"
		WebStr$ = WebStr$,RTrim$(tmp$),fdel$
		xdate$=""
		If oi.InvoiceDate <> 0                
			 xdate$ = pdate$(oi.InvoiceDate)     
		endif                         
		WebStr$ = WebStr$,RTrim$(xdate$),fdel$
		xdate$=""
		If oi.DiscountDate <> 0                
			 xdate$ = pdate$(oi.DiscountDate)     
		endif                         
		WebStr$ = WebStr$,RTrim$(xdate$),fdel$
		xdate$=""
		If oi.DueDate <> 0                
			 xdate$ = pdate$(oi.DueDate)     
		endif                         
		WebStr$ = WebStr$,RTrim$(xdate$),fdel$
		webstr$=webstr$,(oi.GrossInvoiceAmount using "###########.##"),fdel$
		webstr$=webstr$,(oi.DiscountableAmount using "###########.##"),fdel$
		webstr$=webstr$,((Oi.Terms/100) using "##.##"),fdel$
		webstr$=webstr$,(oi.DiscountAmount using "###########.##"),fdel$
		Webstr$=webstr$,(oi.PONumber using "######"),fdel$
		If c0[6] 
			webstr$=webstr$,(oi.Division using"##"),fdel$
		else
			webstr$=webstr$,"",fdel$
		endif
		if transtype=3
			webstr$=webstr$,str$(oi.CheckNumber),fdel$
			If oi.CheckDate <> 0                
				 xdate$ = pdate$(oi.CheckDate)     
			endif                         
			WebStr$ = WebStr$,RTrim$(xdate$),fdel$ ! check date
			webstr$=webstr$,str$(oi.BankNumber),fdel$
		else
			webstr$=webstr$,"",fdel$
			webstr$=webstr$,"",fdel$
			webstr$=webstr$,"",fdel$
		endif
		let tmp$="N"
		if newtrans<>0 let tmp$="Y"
		webstr$=webstr$,tmp$,fdel$ ! new record
		Let tmp$="Y"
		if transtype=2 and c0[7]=0 let tmp$="N"
		if vend.DiscountDays=0 and vend.NetPaymentDays=0
			let tmp$="N"
		endif
		webstr$=webstr$,tmp$,fdel$ ! calcTermDate
		let tmp$="N"
		if c0[5] let tmp$="Y"
		if transtype=2 and c0[7]=0 let tmp$="N" ! no calc disc /
		webstr$=webstr$,tmp$,fdel$
		webstr$=webstr$,rtrim$(delmsg$),fdel$
		let list$[row]=webstr$
		row=row+1
	endif
	list$[row]=esdel$ ! end of section
	call AddToStr(e$,rstr$,List$[])
	
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)	! let send over the data

else
    include "src/callsuberr.inc"
end try
end sub ! GETDELAPTRANS


!=================================================================================
Sub submitDELAPTRANS() ! gets the ap transaction to delete
Try
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto EndSubDelApTran:
	Call ValidateBatch() ! checks acct per & batch id
	if not(returnstatus) goto EndSubDelApTran:
	Call Dxget("INVOICECODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto EndSubDelApTran:
	endif
	let transid$=rtrim$(tmp$)+blank$
	Call Dxget("TRANSTYPE",tmp$)
	let transtype=0
	if ucase$(rtrim$(Tmp$))="INV" let transtype=1
	if ucase$(rtrim$(Tmp$))="C/M" let transtype=2
	if ucase$(rtrim$(Tmp$))="M/C" let transtype=3
	IF not(transtype)
		let message$="Invalid Transaction Type Submitted"
		let returnstatus=0
		goto EndSubDelApTran:
	endif
	newtrans=0 ! no
	let keyoi$=" ",keyoi$
	let keyoi$[1,6]=vendid using "######"
	let keyoi$[7,18]=transid$
	let keyoi$[19,20]=transtype using "##"
	search #ch_oi,2,1;keyoi$,rec_oi,e
	if e>1
		let message$="Error In A/P Open Item File. May Not Create Transaction "+str$(e)
		returnstatus=0
		goto EndSubDelApTran:
	endif
	if e=1 ! new record !
		let returnstatus=0
		let message$="Transaction "+rtrim$(transid$)+" Not on File for Vendor "+str$(VendId)
		goto EndSubDelApTran:	                                              	
	else ! existing record
		NEWTRANS=0
		read record #ch_oi,rec_oi;oi.;
		IF oi.StatusCode$>"1" and oi.StatusCode$<="6"
			let returnstatus=0
			let message$="Transaction "+rtrim$(transid$)+" Already Paid or in Payment Process "+str$(VendId)
			goto EndSubDelApTran:
		endif
		IF oi.StatusCode$>="9" 
			let returnstatus=0
			let message$="Transaction "+rtrim$(transid$)+" Already Deleted "+str$(VendId)
			goto EndSubDelApTran:
		endif
		if oi.StatusCode$="0" ! in entry process
			if oi.BatchNumber<>batchid or oi.PostingPeriod<>acctper
				let returnstatus=0
				let message$="Transaction "+rtrim$(transid$)+" Already Entered in Batch "+str$(oi.BatchNumber)
				goto EndSubDelApTran:
			endif
			! reduce from the batch info
			Read Record #ch_bth,rec_bth;apbth.
			let apbth.TotRec=apbth.TotRec-1
			let amount=oi.GrossInvoiceAmount
			if p61$[136,136]="Y"
				if oi.currfact<>apbth.currfact
					if oi.currfact<>0 and apbth.currfact<>0
						let cnvcu[0]=1
						let cnvca[0]=amount
						let cnvca[1]=oi.currfact
						let CNVCU[1]=1 ! no rounding
						call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
						let amount=cnvca[0]
						let cnvcu[0]=2
						let cnvca[0]=amount
						let cnvca[1]=apbth.currfact
						let CNVCU[1]=1
						call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
						let amount=fnr(cnvca[0])
					endif
				endif
			endif
			if oi.transactiontype=1
				apbth.TotInv=apbth.TotInv-amount ! oi.GrossInvoiceAmount
			else
				if oi.TransactionType=2
					apbth.TotCM=apbth.TotCM+ amount ! oi.GrossInvoiceAmount 
				else
					if oi.TransactionType=3
						apbth.TotMC=apbth.TotMC-amount ! oi.GrossInvoiceAmount
					endif
				endif
			endif
			write Record #ch_bth,rec_bth;apbth.;
			if c0[4]<>0 ! ap po delete
				let ponum=0
				clear chan[]
				chan[0]=ctlc
				chan[1]=ch_oi
				chan[2]=ch_appoh
				chan[3]=ch_appol
				chan[4]=ch_poh
				chan[5]=ch_pol
				chan[6]=ch_poc
				Call "la510d.dl4",chan[],ponum,rec_oi,message$,IntCo,rstr$,e$
			endif
			Call OiDelete(vendid,transid$,transtype) ! delete open item         
			If eflag <> 0                                                       
				ReturnStatus = 0                                                  
				Goto endSubDelaptran                                             
			End If                                                              
			Call AphDelete(vendid,transid$,transtype) ! delete ap history item  
			If eflag <> 0                                                       
				ReturnStatus = 0                                                  
				goto endSubDelaptran                                             
			End If                                                              
			Message$="Transaction Has Been Deleted"
			goto endsubdelaptran
		else ! already accepted
			if oi.StatusCode$<>"1"
				let returnstatus=0
				let message$="Transaction "+rtrim$(transid$)+" Not Available for Delete"
				goto EndSubDelApTran:
			else
				if (oi.PaymentCurrentRun)<>0 or (oi.PaymentCurrentPeri)<>0 or (oi.PaymentNextMo)<>0
					let returnstatus=0
					let message$="Transaction "+rtrim$(transid$)+" Already Has Payments Applied. May Not Delete."
					goto EndSubDelApTran:
				else
					Message$="Transaction Already Accepted on Purchase Journal"
				endif
			endif
			! update the batch	
			Read Record #ch_bth,rec_bth;apbth.
			let apbth.TotRec=apbth.TotRec+1
			apbth.TotDel=apbth.TotDel+oi.GrossInvoiceAmount
			write Record #ch_bth,rec_bth;apbth.;
		        oi.BatchNumber = batchid
			oi.PostingPeriod = acctper
			! get entry #
			Mat Read #ctlc,51,44;E1 
			E1 = E1 + 1
			If E1 > 999999 Let E1 = 1 
			If E1 <= 0 Let E1 = 1                                             
			oi.PurchJournEntry = E1                                           
			Mat Write #ctlc,51,44;E1;                                         
			LET oi.statuscode$="9"
			LET oi.DataEntryStatus$="1" ! set open item to delete status
			write record #ch_oi,rec_oi;oi.;
			If c0[4]<>0 ! get po allocations
				clear chan[]
				chan[0]=ctlc
				chan[1]=ch_oi
				chan[2]=ch_appoh
				chan[3]=ch_appol
				chan[4]=ch_poh
				chan[5]=ch_pol
				chan[6]=ch_poc
				chan[7]=ch_prod
				! Enter chan[],rec_oi,message$,IntCo,rstr$,e$
				Call "la513csp.dl4",chan[],rec_oi,message$,IntCo,rstr$,e$
			endif! get appoh/appol detail from history
			let keydi$=" ",keydi$                                                   
			let keydi$[1,5]=rec_oi using "#####"                                    
			search #ch_di,3,1;keydi$,rec_di,e                                       
			if not(e)                                                               
				let tmp3=keydi$[1,5]                                            
				if tmp3=rec_oi goto endchkdeldist:! check if apgl dist  exists  
			endif                                                                   
			!if e>2 goto endchkdeldist: !  
			keyapdh$=" ",keyapdh$
			let keyapdh$[1,6]=vendid using "######"
			let keyapdh$[7,18]=transid$[1,12]
			let keyapdh$[19,20]=transtype using "##"
			SEARCH #ch_apdh,2,1;Keyapdh$,rec_apdh,E 
			if e<>0 goto endchkdeldist:
			let keyapda$=" ",keyapda$                                               
			let keyapda$[1,6]=rec_apdh using "######"                               
			let totrec=1                                                            
			do                                                                      
				 search #ch_apda,3,1;keyapda$,rec_apda,e                         
				 If e <>0 goto endchkdeldist:                                    
				 let tmp3=keyapda$[1,6]                                          
				 if tmp3<>rec_apdh goto endchkdeldist:                           
				 read record #ch_apda,rec_apda;apda.;                           
				! now create gl distribution                                    
				 clear apdi.                                                     
				apdi.OIRec=rec_oi                                               
				apdi.VendId=vendid                                              
				apdi.InvCode$=transid$+blank$                                   
				apdi.AcctId=apda.GLAccount 
				apdi.Amount=(apda.Amount*(-1))    
				apdi.ItemNum=totrec
				let totrec=totrec+1
				apdi.Type=transtype     
				apdi.Auto=0 
				mode$ = "a" ! add                                                 
				UpdStatus = fileupdateapa20di(e$,ch_di,mode$,rec_di,apdi.)
			loop
			endchkdeldist: ! 
			Call AphDelete(vendid,transid$,transtype) ! delete ap history item 
			let postingamt=0
			let keydi$=" ",keydi$
			let keydi$[1,5]=rec_oi using "#####"
			do
				search #ch_di,3,1;keydi$,rec_di,e
				if e>0 exit do
				let tmp3=keydi$[1,5]
				if tmp3<>rec_oi exit do
				read record #ch_di,rec_di;apdi.;
			
				let postingamt=postingamt+apdi.amount
	                                        
			Loop 
			
			if returnstatus=1 
				if (postingamt*(-1))<>oi.grossinvoiceamount 
					let returnstatus=2 ! need to ask for gl distributions
				else
					let message$="Transaction Deleted" 
				endif
			endif

		endif
	endif
	EndSubDelApTran: !
	 
	
	
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)	! let send over the data

else
    include "src/callsuberr.inc"
end try
end sub ! submitDELAPTRANS
!========================================================================================
!=================================================================================
Sub GETDATEAPTRANS() ! gets the ap transaction to delete
Try
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	! section 1
	Call GetAPVendDet()
	if not (returnstatus) goto endgetdateaptran:
	Call Dxget("INVOICECODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto endgetdateaptran:
	endif
	let transid$=rtrim$(tmp$)+blank$
	Call Dxget("TRANSTYPE",tmp$)
	let transtype=0
	if ucase$(rtrim$(Tmp$))="INV" let transtype=1
	if ucase$(rtrim$(Tmp$))="C/M" let transtype=2
	if ucase$(rtrim$(Tmp$))="M/C" let transtype=3
	IF not(transtype)
		let message$="Invalid Transaction Type Submitted"
		let returnstatus=0
		goto Endgetdateaptran:
	endif
	newtrans=0 ! no
	let keyoi$=" ",keyoi$
	let keyoi$[1,6]=vendid using "######"
	let keyoi$[7,18]=transid$
	let keyoi$[19,20]=transtype using "##"
	search #ch_oi,2,1;keyoi$,rec_oi,e
	if e<>0
		let message$="Transaction "+rtrim$(transid$)+" Not on File for Vendor "+str$(VendId)
		returnstatus=0
		goto Endgetdateaptran:
	endif
	read record #ch_oi,rec_oi;oi.;
	IF oi.StatusCode$>"1" and oi.StatusCode$<="6"
			let returnstatus=0
			let message$="Transaction "+rtrim$(transid$)+" Already Paid or in Payment Process "+str$(VendId)
			goto Endgetdateaptran:
	endif
	IF oi.StatusCode$>="9" 
		let returnstatus=0
		let message$="Transaction "+rtrim$(transid$)+" Already Deleted "+str$(VendId)
		goto Endgetdateaptran:
	endif
	if oi.StatusCode$="0" ! in entry process
		let returnstatus=0
		let message$="Transaction "+rtrim$(transid$)+" In Entry Process "
		goto Endgetdateaptran:
	endif
	if oi.StatusCode$<>"1"
		let returnstatus=0
		let message$="Transaction "+rtrim$(transid$)+" Not Available for Date Edit. Invalid Status."
		goto Endgetdateaptran:
	endif
	let apmsg$=" ",apmsg$
	let apchkmsg$=" ",apchkmsg$
	let keyapdm$=" ",keyapdm$
	let keyapdm$[1,6]=vendid using "######"
	let keyapdm$[7,18]=transid$
	let keyapdm$[19,20]=transtype using "##"
	do
		search #ch_apdm,3,1;keyapdm$,rec_apdm,e
		if e<>0 exit do
		if keyapdm$[7,18]<>transid$[1,12] exit do
		let tmp3=keyapdm$[1,6]\if tmp3<>vendid exit do
		let tmp3=keyapdm$[19,20]\if tmp3<>transtype exit do
		read record #ch_apdm,rec_apdm;apdm.;
		let apmsg$=apdm.message$
		let apchkmsg$=apdm.chkmsg$
		exit do
	loop
	Endgetdateaptran: !
	! section 2
	clear list$[]
	list$[0]=bsdel$,"APTransaction",fdel$
	webstr$=""
	webstr$="VendId",fdel$
	webstr$=webstr$,"InvoiceCode",fdel$
	Webstr$=webstr$,"TranType",fdel$
	webstr$=webstr$,"InvoiceDate",fdel$
	webstr$=webstr$,"DiscountDate",fdel$
	webstr$=webstr$,"DueDate",fdel$
	webstr$=webstr$,"GrossInvAmt",fdel$
	webstr$=webstr$,"DiscountableAmt",fdel$
	webstr$=webstr$,"TermsPct",fdel$
	webstr$=webstr$,"DiscountAmt",fdel$
	webstr$=webstr$,"PONumber",fdel$
	webstr$=webstr$,"Division",fdel$
	webstr$=webstr$,"CheckNumber",fdel$
	webstr$=webstr$,"CheckDate",fdel$
	webstr$=webstr$,"BankNumber",fdel$
	webstr$=webstr$,"Message",fdel$
	webstr$=webstr$,"CheckMessage",fdel$
	
	list$[1]=webstr$
	row=2
	if returnstatus=1 ! no errors
		if oi.transactiontype=2 ! need to reverse sign on display items
			oi.GrossInvoiceAmount=oi.GrossInvoiceAmount*(-1)
			oi.DiscountableAmount=oi.DiscountableAmount*(-1)
			oi.DiscountAmount=oi.DiscountAmount*(-1)
		endif
		let webstr$=""
		webstr$=str$(vendid),fdel$
		webstr$=webstr$,rtrim$(transid$),fdel$
		let tmp$="INV"
		if transtype=2 let tmp$="C/M"
		if transtype=3 let tmp$="M/C"
		WebStr$ = WebStr$,RTrim$(tmp$),fdel$
		xdate$=""
		If oi.InvoiceDate <> 0                
			 xdate$ = pdate$(oi.InvoiceDate)     
		endif                         
		WebStr$ = WebStr$,RTrim$(xdate$),fdel$
		xdate$=""
		If oi.DiscountDate <> 0                
			 xdate$ = pdate$(oi.DiscountDate)     
		endif                         
		WebStr$ = WebStr$,RTrim$(xdate$),fdel$
		xdate$=""
		If oi.DueDate <> 0                
			 xdate$ = pdate$(oi.DueDate)     
		endif                         
		WebStr$ = WebStr$,RTrim$(xdate$),fdel$
		webstr$=webstr$,(oi.GrossInvoiceAmount using "###########.##"),fdel$
		webstr$=webstr$,(oi.DiscountableAmount using "###########.##"),fdel$
		webstr$=webstr$,((Oi.Terms/100) using "##.##"),fdel$
		webstr$=webstr$,(oi.DiscountAmount using "###########.##"),fdel$
		Webstr$=webstr$,(oi.PONumber using "######"),fdel$
		If c0[6] 
			webstr$=webstr$,(oi.Division using"##"),fdel$
		else
			webstr$=webstr$,"",fdel$
		endif
		if transtype=3
			webstr$=webstr$,str$(oi.CheckNumber),fdel$
			If oi.CheckDate <> 0                
				 xdate$ = pdate$(oi.CheckDate)     
			endif                         
			WebStr$ = WebStr$,RTrim$(xdate$),fdel$ ! check date
			webstr$=webstr$,str$(oi.BankNumber),fdel$
		else
			webstr$=webstr$,"",fdel$
			webstr$=webstr$,"",fdel$
			webstr$=webstr$,"",fdel$
		endif
		webstr$=webstr$,rtrim$(apmsg$),fdel$
		webstr$=webstr$,rtrim$(apchkmsg$),fdel$
		let list$[row]=webstr$
		row=row+1
	endif
	list$[row]=esdel$ ! end of section
	call AddToStr(e$,rstr$,List$[])
	
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)	! let send over the data

else
    include "src/callsuberr.inc"
end try
end sub ! GETDateAPTRANS

!=====================================================================================
Sub SubmitDateAptrans() ! gets the ap transaction or creates a new one
Try
	
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto endsubdateaptran:
	Call Dxget("INVOICECODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto endsubdateaptran:
	endif
	let transid$=rtrim$(tmp$)+blank$
	Call Dxget("TRANSTYPE",tmp$)
	let transtype=0
	if ucase$(rtrim$(Tmp$))="INV" let transtype=1
	if ucase$(rtrim$(Tmp$))="C/M" let transtype=2
	if ucase$(rtrim$(Tmp$))="M/C" let transtype=3
	IF not(transtype)
		let message$="Invalid Transaction Type Submitted"
		let returnstatus=0
		goto endsubdateaptran:
	endif
	let keyoi$=" ",keyoi$
	let keyoi$[1,6]=vendid using "######"
	let keyoi$[7,18]=transid$
	let keyoi$[19,20]=transtype using "##"
	search #ch_oi,2,1;keyoi$,rec_oi,e
	if e<>0
		let message$="Error A/P Transaction "+rtrim$(transid$)+" Not On File. "
		returnstatus=0
		goto endsubdateaptran:
	endif
	read record #ch_oi,rec_oi;oi.
	If oi.StatusCode$<> "1"
		let message$="A/P Transaction "+rtrim$(transid$)+" Is Invalid Status. May Not Submit."
		returnstatus=0
		goto endsubdateaptran:
	endif  
	Call Dxget("Message",tmp$)
	let apmsg$=rtrim$(tmp$)+blank$
	strgok=chkbadchars(e$,apmsg$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Internal Message Line"
		goto endsubdateaptran
	Endif
	Call Dxget("CheckMessage",tmp$)
	let apchkmsg$=rtrim$(tmp$)+blank$
	strgok=chkbadchars(e$,apchkmsg$)
	if not(strgok)
		returnstatus=0
		Message$="Invalid Characters in Check Message Line"
		goto endsubdateaptran
	Endif
	let keyapdh$[1,6]=vendid using "######"
	let keyapdh$[7,18]=transid$[1,12]
	let keyapdh$[19,20]=transtype using "##"
	search #ch_apdh,2,1;keyapdh$,rec_apdh,e
	if e<>0
		let message$="Error A/P Transaction "+rtrim$(transid$)+" Not In History File. "
		returnstatus=0
		goto endsubdateaptran:
	endif
	read record #ch_apdh,rec_apdh;apdh.
	Call Dxget("DiscountDate",tmp$)
	xdate$ = formatdate2$(tmp$)
	oi.DiscountDate =  xdate$[3,8]  
	Call Dxget("DueDate",tmp$)
	xdate$ = formatdate2$(tmp$)
	oi.DueDate =  xdate$[3,8]  
	Write Record #ch_oi,rec_oi;oi.;	      
	apdh.DueDate=oi.DueDate                        
	apdh.DiscountDate=oi.DiscountDate
	write record #ch_apdh,rec_apdh;apdh.; 
	! ap message
	let keyapdm$[1,6]=vendid using "######"
	let keyapdm$[7,18]=transid$[1,12]
	let keyapdm$[19,20]=transtype using "##"
	do
		search #ch_apdm,2,1;keyapdm$,rec_apdm,e
		if e<>0 exit do
		if keyapdm$[7,18]<>transid$[1,12] exit do
		let tmp3=keyapdm$[1,6]\if tmp3<>vendid exit do
		let tmp3=keyapdm$[19,20]\if tmp3<>transtype exit do
		search #ch_apdm,5,1;keyapdm$,rec_apdm,e \IF E<>0 Error( 10000+e)
		let e=3\search #ch_apdm,1,0;keyapdm$,rec_apdm,e\IF E<>0 Error( 10000+e)
		exit do
	loop
	if rtrim$(apmsg$)<>"" or rtrim$(apchkmsg$)<>""
		clear apdm.
		apdm.VendID=vendid                           
		apdm.TransType=transtype                          
		apdm.MsgType=1 ! message only type                                           
		apdm.MsgLine=1 ! only one line                                               
		apdm.TransID$=transid$[1,12]                          
		apdm.SPARE1$=" ",apdm.SPARE1$                            
		apdm.Message$=rtrim$(apmsg$)+blank$  
		apdm.ChkMsg$=rtriM$(apchkmsg$)+blank$
		apdm.SPARE2$=" ",apdm.SPARE2$                             
		apdm.SPARE3$=" "                   
		let keyapdm$=" ",keyapdm$
		let keyapdm$[1,6]=apdm.vendid using "######"
		let keyapdm$[7,18]=apdm.Transid$[1,12]
		let keyapdm$[19,20]=apdm.TransType using "##"
		let keyapdm$[21,22]=apdm.msgtype using "##"
		let keyapdm$[23,26]=apdm.msgline using "####"
		search #ch_apdm,2,1;keyapdm$,rec_apdm,e\IF E >1 Error( 10000+e)
		if e=1
			let e=2\search #ch_apdm,1,0;keyapdm$,rec_apdm,e \IF E<>0 Error( 10000+e)
			write record #ch_apdm,rec_apdm;apdm.;
			search #ch_apdm,4,1;keyapdm$,rec_apdm,e\IF E<>0 Error( 10000+e)
		else
			write record #ch_apdm,rec_apdm;apdm.;
		endif
	endif				
	endsubdateaptran: !
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)	! let send over the data

else
    include "src/callsuberr.inc"
end try
end sub ! submitdateaptrans

!=========================================================================================================
Sub Start518Report()! Recurring Entry List
 Try
	dim 2%,vend[1],expired,expper,nextper
	ReturnStatus=1
	Message$="OK"	
	! open printer
	try Close #0 Else Rem
	onchannelno=0 ! zero for channel 
	printchan = openprinter(e$,onchannelno) 
	Call dxget("SVEND",tmp$) \ VEND[0] = tmp$ !!STARTING VENDOR CODE 
	If VEND[0] < 0 Or VEND[0] > 999999
		RETURNSTATUS=0
		Let MESSAGe$ = "Invalid starting vendor code"
		Goto end518report
	ENDIF         
	call dxget("EVEND",tmp$) \ If tmp$ = "" Let VEND[1] = 999999 Else Let VEND[1]=TMP$
	If VEND[1] < 0 Or VEND[1] > 999999
		RETURNSTATUS=0
		Let MESSAGe$ = "Invalid ending vendor code"
		Goto end518report
	ENDIF                                   
	If vend[1]<vend[0]
		returnstatus=0
		message$=message$+"Starting Vendor Must Be Less Than Ending Vendor."
		Goto end518report
	endif
	let expired=0
	let expper=0
	let nextper=0
	Call dxget("PRNTEXPIRED",tmp$)
	If ucase$(rtrim$(tmp$))="Y"
		Call dxget ("EXPPER",TMP$)
		if rtrim$(tmp$)=""
			let returnstatus=0
			message$="Invalid Expired Period" 
			goto end518report:
		endif
		if tmp$[3,3]<>"/"
			let returnstatus=0
			message$="Invalid Expired Period Format Submitted"
			goto end518report:
		endif
		let period$=tmp$[4,5],tmp$[1,2]
		let expper=period$
	else
		Call dxget ("NEXTPER",TMP$)
		if rtrim$(tmp$)<>"" and rtrim$(tmp$)<>"0" ! next period may be on
			if tmp$[3,3]<>"/"
				let returnstatus=0
				message$="Invalid Next Accounting Period Format Submitted"
				goto end518report:
			endif
			let period$=tmp$[4,5],tmp$[1,2]
			let nextper=period$
		endif
	endif		
	LET DIV=0
	IF C0[6]<>0
		Call dxget("DIVISION",tmp$) ! page break for purchase orders
		LET DIV=TMP$
		IF DIV<0 OR DIV>99
			returnstatus=0
			message$=message$+"Invalid Division Submitted."
			Goto end518report
		endif
	endif
	

	! set up parameters for call
	clear spec1[]
	spec1[0]=intco ! company #
	spec1[1]=NextPer ! next accounting period or 0 for all
	spec1[2]=ExpPer ! expired Transaction or 0 for none
	spec1[3]=Vend[0] ! starting Vendor
	spec1[4]=Vend[1]  ! ending vendor
	spec1[5]=0 ! current or next month
	spec1[7]=div
	spec1[8]=rec_uac
	spec1[9]=returnstatus
	Call "la518.dl4",SPEC1[],MESSAGE$,rstr$
	LET returnstatus=spec1[9]
	end518report: ! 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! Start518Report


!=========================================================================================================
Sub Start519Report()! Recurring Entry Journal
 Try
	ReturnStatus=1
	Message$="OK"
	Keyapc$ = " 0"
	Search #ch_apc,2,1;Keyapc$,Rec_apc,E
	if e>0
		let returstatus=0
		message$=message$+"RECORD '0' NOT FOUND IN A00AP"
		goto end519report:
	else

		Mat Read #ch_apc,rec_apc,2;apR$;
		If apR$[61,61] =" " 
			returnstatus=0
			message$=message$+"JOURNAL IS IN PROCESS ELSEWHERE...PLEASE TRY AGAIN LATER..."
			Goto end519report
		endif
	endif
	! open printer
	try Close #0 Else Rem
	onchannelno=0 ! zero for channel 
	printchan = openprinter(e$,onchannelno) 
	LET DIV=0
	IF C0[6]<>0
		Call dxget("DIVISION",tmp$) ! page break for purchase orders
		LET DIV=TMP$
		IF DIV<0 OR DIV>99
			returnstatus=0
			message$=message$+"Invalid Division Submitted."
			Goto end519report
		endif
	endif
	Call Dxget ("ACCTPER",tmp$) ! MM/YY
	if rtrim$(tmp$)=""
		let returnstatus=0
		message$="Invalid Accounting Period" 
		goto end519report:
	endif
	if tmp$[3,3]<>"/"
		let returnstatus=0
		message$="Invalid Accounting Period Format Submitted"
		goto end519report:
	endif
	let period$=tmp$[4,5],tmp$[1,2]
	let acctper=period$
	Call GetAcctPer()
	if acctper=currper
		let spec1[5]=0
	else
		if acctper=nxtper
			spec1[5]=1 
		else
			let returnstatus=0
			message$="Accounting Period Must Be Current or Next Month"
			goto end519report:
		endif
	endif
	Call Dxget("POSTDAY",tmp$)	
	let tmp3=tmp$
	if tmp3=0 or tmp3>31
		let returnstatus=0
		message$="Invalid Posting Day Submitted"
		goto end519report:
	endif
	let tmp$=tmp3 using "&&"
	let xdate$=period$,tmp$[1,2]
     tmpdate$=xdate$[3,4],"/",xdate$[5,6],"/20",xdate$[1,2] ! tmpdate$="mm/dd/yyyy"
	Call VerifyDate(tmpDate$,tmp$,errflag,1) ! returns in yyyymmd
	if errflag<>0
		let returnstatus=0
		let message$="Invalid Posting Day Submitted "
		goto end519report:
	endif
	!xdate$ = formatdate2$(tmp$)
	POSTDATE =  xdate$! [3,8]  
	LET TMP3=XDATE$[1,4]
	IF TMP3<>ACCTPER
		let returnstatus=0
		message$="Posting Date Must Match Accounting Period Selected"
		goto end519report:	
	endif
	Call dxget("PRPRT",tmp$) ! (NOT ADDED?)     
	audonly = 0 ! \ If tmp$ <> "" Let audonly = 1
	If UCASE$(RTRIM$(tmp$))="Y" Let audonly = 1
	! set up parameters for call
	clear spec1[]
	spec1[0]=intco ! company #
	spec1[1]=0 ! 1= PAGEBREAK
	spec1[2]=Audonly
	spec1[3]=batchid
	spec1[4]=Acctper
	spec1[5]=0 ! current or next month
	if nxtper=acctper let spec1[5]=1 ! flag as next month
	spec1[6]=postdate ! yymmdd format
	spec1[7]=div
	spec1[8]=rec_uac
	spec1[9]=returnstatus
	Call "la519.dl4",SPEC1[],MESSAGE$,rstr$
	LET returnstatus=spec1[9]
	if rtrim$(message$)="" let message$="Complete"
	end519report: ! 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! Start519Report
!================================================================================================================
!=================================================================================
Sub GetRetrans() ! gets the recurring Entry Transaction 517
Try
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto endgetretran:
	Call Dxget("TRANCODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto endgetretran:
	endif
	let transid$=rtrim$(tmp$)+blank$
	Let Transtype=1
	newtrans=0 ! no
	let keyrec$=" ",keyrec$
	let keyrec$[1,6]=vendid using "######"
	let keyrec$[7,14]=transid$
	let keyrec$[15,16]=transtype using "##"
	search #ch_aprec,2,1;keyrec$,rec_aprec,e
	if e>1
		let message$="Error In A/P Recurring Entry File. May Not Create Transaction "+str$(e)
		returnstatus=0
		goto endgetretran:
	endif
	if e=1 ! new record   
		newtrans=99
		clear rec.
		rec.Vend=Vendid
		MAT  READ #1,0,134;apdate;     ! yymmdd                             
		LET tmp$=apdate USING "&&&&&&"                               
		LET currper=tmp$[1,4] ! yymm
		rec.NextPer=currper !!
		rec.div=0
		If C0[6]<>0
			if prt.div<=0 let prt.div=1
			if prt.div > 0 Let rec.Div = prt.div 
		endif
		rec.status=99
		rec.transtype=transtype
		rec.type=transtype
		rec.transid$=transid$	
		let mode$="a"
		UpdStatus = fileupdateaprec(e$,ch_aprec,mode$,rec_aprec,rec.)
		rec_aprec=updStatus
		
		read record #ch_aprec,rec_aprec;rec.;                                                 	
	else ! existing record
		read record #ch_aprec,rec_aprec;rec.;
		NEWTRANS=0	
		IF rec.Status<>0
			let returnstatus=0
			let message$="Transaction "+rtrim$(transid$)+" for Vendor "+str$(VendId)+" In Process Elsewhere"
			goto endgetretran:
		endif
		let rec.status=99
		write record #ch_aprec,rec_aprec;rec.;
	endif
	endgetretran: !
	clear list$[]
	list$[0]=bsdel$,"RETransaction",fdel$
	webstr$=""
	webstr$="VendId",fdel$
	webstr$=webstr$,"TranCode",fdel$
	Webstr$=webstr$,"TranType",fdel$
	webstr$=webstr$,"TranDay",fdel$
	webstr$=webstr$,"PayDay",fdel$
	webstr$=webstr$,"ExpirationPer",fdel$
	webstr$=webstr$,"TransAmt",fdel$
	webstr$=webstr$,"NextPer",fdel$
	webstr$=webstr$,"Description",fdel$
	webstr$=webstr$,"Division",fdel$
	webstr$=webstr$,"NewRecord",fdel$
	list$[1]=webstr$
	row=2
	if returnstatus=1 ! no errors
		let webstr$=""
		webstr$=str$(vendid),fdel$
		webstr$=webstr$,rtrim$(transid$),fdel$
		let tmp$="INV"
		if transtype=2 let tmp$="C/M"
		if transtype=3 let tmp$="M/C"
		WebStr$ = WebStr$,RTrim$(tmp$),fdel$
		tmp$=""
		If rec.Transday<> 0                
			 Tmp$=rec.transday using "--#"     
		endif                         
		WebStr$ = WebStr$,RTrim$(tmp$),fdel$
		tmp$=""
		If rec.DueDay<>0
			Tmp$=rec.dueday using "--#" 
		endif
		WebStr$ = WebStr$,RTrim$(tmp$),fdel$
		let tmp$=""
		if rec.ExpPer<>0
			let xdate$=rec.ExpPer using "&&&&"
			let tmp$=xdate$[3,4]+xdate$[1,2]
		endif
		WebStr$ = WebStr$,RTrim$(tmp$),fdel$
		webstr$=webstr$,(rec.TransAmt using "###########.##"),fdel$
		let tmp$=""
		if rec.NextPer<>0
			let xdate$=rec.NextPer using "&&&&"
			let tmp$=xdate$[3,4]+xdate$[1,2]
		endif
		WebStr$ = WebStr$,RTrim$(tmp$),fdel$
		Webstr$=webstr$,rtrim$(rec.Description$),fdel$
		If c0[6] 
			webstr$=webstr$,(rec.Div using"##"),fdel$
		else
			webstr$=webstr$,"",fdel$
		endif
		
		let tmp$="N"
		if newtrans<>0 let tmp$="Y"
		webstr$=webstr$,tmp$,fdel$ ! new record
		let list$[row]=webstr$
		row=row+1
	endif
	list$[row]=esdel$ ! end of section
	call AddToStr(e$,rstr$,List$[])
	
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)	! let send over the data

else
    include "src/callsuberr.inc"
end try
end sub ! getretrans
!=====================================================================================
Sub SubmitRetrans() ! gets the recurring entry transaction or creates a new one 517
Try
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto endsubmitretran:
	Call Dxget("TRANCODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto endsubmitretran:
	endif
	let transid$=rtrim$(tmp$)+blank$
	transtype=1
	let keyrec$=" ",keyrec$
	let keyrec$[1,6]=vendid using "######"
	let keyrec$[7,14]=transid$
	let keyrec$[15,16]=transtype using "##"
	search #ch_aprec,2,1;keyrec$,rec_aprec,e
	if e<>0
		let message$="Error Recurring Entry Transaction "+rtrim$(transid$)+" Not On File. "
		returnstatus=0
		goto endsubmitretran:
	endif
	read record #ch_aprec,rec_aprec;rec.
	If rec.Status=0
		let message$="Recurring Entry Transaction "+rtrim$(transid$)+" Is Invalid Status. May Not Submit."
		returnstatus=0
		goto endsubmitretran:
	endif   
	Call Dxget("TranDay",tmp$)
	let tmp3=tmp$
	if tmp3<=0 or tmp3>31
		let message$="Invalid Transaction Day Submitted"
		returnstatus=0
		goto endsubmitretran:	
	endif
	let rec.transday=tmp3
	Call Dxget("PayDay",tmp$)
	let tmp3=tmp$
	if abs(tmp3)=0 or abs(tmp3)>31
		let message$="Invalid Payment/Due Day Submitted"
		returnstatus=0
		goto endsubmitretran:	
	endif
	if tmp3>0 and rec.transday>tmp3
		let message$="Due Day Must Be Greater than or equal to Transaction Day "
		returnstatus=0
		goto endsubmitretran:	
	endif
	rec.dueday=tmp3
	
	Call Dxget("ExpirationPer",tmp$)
	if rtrim$(tmp$)=""
		let returnstatus=0
		message$="Invalid Expiration Period" 
		goto endsubmitretran:
	endif
	!if tmp$[3,3]<>"/"
	!	let returnstatus=0
	!	message$="Invalid Expiration Period Format Submitted"
	!	goto endsubmitretran:
	!endif
	let tmp3=tmp$
	let tmp$=tmp3 using "&&&&"
	let period$=tmp$[3,4],tmp$[1,2]
	let rec.Expper=period$
	if rec.Expper<>9999
		if tmp$[1,2]<"01" or tmp$[1,2]>"12"
			let returnstatus=0
			message$="Invalid Expiration Period Submitted"
			goto endsubmitretran:	
		endif
	endif
	Call Dxget ("TransAmt",tmp$)
	let tmp3=tmp$
	if tmp3<0
		let returnstatus=0
		message$="Invalid Transaction Amount Submitted"
		goto endsubmitretran:
	endif
	if fra(tmp3*100)<>0
		let returnstatus=0
		message$="Invalid Transaction Amount Submitted"
		goto endsubmitretran:
	endif
	rec.Transamt=tmp3
	Call Dxget("NextPer",tmp$)
	if rtrim$(tmp$)=""
		let returnstatus=0
		message$="Invalid Next Process Period" 
		goto endsubmitretran:
	endif
	!if tmp$[3,3]<>"/"
	!	let returnstatus=0
	!	message$="Invalid Next Process Period Format Submitted"
	!	goto endsubmitretran:
	!endif
	let tmp3=tmp$
	let tmp$=tmp3 using "&&&&"
	let period$=tmp$[3,4],tmp$[1,2]
	Call GetAcctPer()
	let rec.Nextper=period$
	if rec.Nextper<currper
		let returnstatus=0
		message$="Next Process Period is Prior to Current Accounting Period"
		goto endsubmitretran:
	endif
	Call Dxget("DESCRIPTION",tmp$)
	let rec.description$=rtrim$(tmp$)+blank$
	if c0[6]<>0
		Call Dxget("Division",tmp$)
		rec.Div=tmp$
	endif
	rec.status=0
	Write Record #ch_aprec,rec_aprec;rec.;
	! update the batch           
        Let message$="Transaction Submitted" 
	endsubmitretran: !
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)	! let send over the data
else
    include "src/callsuberr.inc"
end try
end sub ! submitretrans

!=====================================================================================
Sub DeleteRetrans() ! deletes an existing recurring entry  transaction 517
Try
	
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto enddeleteretran:
	Call Dxget("TRANCODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto enddeleteretran:
	endif
	let transid$=rtrim$(tmp$)+blank$
	Transtype=1
	let keyrec$=" ",keyrec$
	let keyrec$[1,6]=vendid using "######"
	let keyrec$[7,14]=transid$
	let keyrec$[15,16]=transtype using "##"
	search #ch_aprec,2,1;keyrec$,rec_aprec,e
	if e<>0
		let message$="Error Recurring Entry Transaction "+rtrim$(transid$)+" Not On File. "
		returnstatus=0
		goto enddeleteretran:
	endif
	read record #ch_aprec,rec_aprec;rec.
	!If rec.Status=0
	!	let message$="Recurring Entry Transaction "+rtrim$(transid$)+" Is Invalid Status. May Not Delete."
	!	returnstatus=0
	!	goto enddeleteretran:
	!endif   
	keyred$=" ",keyred$
	keyred$[1,5]=rec_aprec using "#####"
	do
		search #ch_apred,3,1;keyred$,rec_apred,e
		if e<>0 exit do
		let tmp3=keyred$[1,5]
		if tmp3<>rec_aprec exit do
		search #ch_apred,5,1;keyred$,rec_apred,e \If e > 0 Error (10000 + e) 
		let e=3\search #ch_apred,1,0;keyred$,rec_apred,e\If e > 0 Error (10000 + e)
	loop
	search #ch_aprec,5,1;keyrec$,rec_aprec,e\If e > 0 Error (10000 + e) 
	let e=3\search #ch_aprec,1,0;keyrec$,rec_aprec,e\If e > 0 Error (10000 + e) 
        let message$="Deleted"     
	enddeleteretran: !
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)	! let send over the data

else
    include "src/callsuberr.inc"
end try
end sub ! Deleteretrans

!--------------------------------------------------------------------
Sub getregldist() ! recurring entries g/l  distributions 517
Try
	dim 3%,postingamt
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto endgetregldist:
	Call Dxget("TRANCODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto endgetregldist:
	endif
	let transid$=rtrim$(tmp$)+blank$
	Transtype=1
	let keyrec$=" ",keyrec$
	let keyrec$[1,6]=vendid using "######"
	let keyrec$[7,14]=transid$
	let keyrec$[15,16]=transtype using "##"
	search #ch_aprec,2,1;keyrec$,rec_aprec,e
	if e<>0
		let message$="Error Recurring Entry Transaction "+rtrim$(transid$)+" Not On File. "
		returnstatus=0
		goto endgetregldist:
	endif
	read record #ch_aprec,rec_aprec;rec.
	If rec.Status<>0
		let message$="Recurring Entry Transaction "+rtrim$(transid$)+" Is Invalid Status."
		returnstatus=0
		goto endgetregldist:
	endif   
	let eflag=0
	LET dfltacctid=vend.GLAccountNumber$
	if not(dfltacctid) goto endgetregldist:
	IF C0[6]<>0 AND DEPT<>0 ! AP DIVISIONS SET UP WITH GL DEPARTMENT
		keyvl$=" ",keyvl$
		keyvl$[2,9]=dfltacctid using "########"
		keyvl$[8,9]=rec.div using "&&"
		search #ch_vl,2,1;keyvl$,rec_vl,e
		if e=0
			let dfltacctid=keyvl$[2,9]
			goto checkredrec:
		endif
	endif
	keyvl$=" ",keyvl$
	keyvl$[2,9]=dfltacctid using "########"
	search #ch_vl,2,1;keyvl$,rec_vl,e
	if e<>0 goto endgetregldist:
	checkredrec: ! check to see if ap gl records exists
	! check if gl transactions already exists
	let keyred$=" ",keyred$
	let keyred$[1,5]=rec_aprec using "#####"
	search #ch_apred,3,1;keyred$,rec_apred,e
	if not(e)
		let tmp3=keyred$[1,5]
		if tmp3=rec_aprec goto endgetregldist:! need to check if apgl dist already exists
	endif 
	! now create gl distribution
	clear red.
	red.ApRecNum=rec_aprec 
	red.Vend=VENDID                     
	red.TransId$=Transid$               
	red.AcctId=dfltacctid                       
	red.Amount=rec.Transamt                       
	red.Item=1                        
	red.LineNum=1  
	red.Status=0  
	mode$ = "a" ! add                                                 
	UpdStatus = fileupdateapred(e$,ch_apred,mode$,rec_apred,red.)
	! get gl acct # in vendor file
	! check if division and department and 
	endgetregldist: ! 
	clear list$[]
	list$[0]=bsdel$,"REGLDIST",fdel$
	webstr$=""
	webstr$=webstr$,"GLACCTID",fdel$
	webstr$=webstr$,"GLACCTNAME",fdel$
	webstr$=webstr$,"GLAMOUNT",fdel$
	
	list$[1]=webstr$
	let row=2
	let tmpcnt=maxcnt
	let postingamt=0
	if returnstatus=1
		let keyred$=" ",keyred$
		let keyred$[1,5]=rec_aprec using "#####"
		do
			search #ch_apred,3,1;keyred$,rec_apred,e
			if e>0 exit do
			let tmp3=keyred$[1,5]
			if tmp3<>rec_aprec exit do
			read record #ch_apred,rec_apred;red.;
			webstr$=(red.AcctId using "########"),fdel$
			keyvl$=" ",keyvl$
			keyvl$[2,9]=red.AcctId using "########"
			clear apvl.
			search #ch_vl,2,1;keyvl$,rec_vl,e
			if not(e)
				read record #ch_vl,rec_vl;apvl.;
			else
				apvl.desc$="Not on File!!!"
			endif
			webstr$=webstr$,rtrim$(apvl.desc$),fdel$ ! account name
			if transtype=2
				let red.Amount=red.Amount *(-1)
			endif
			webstr$=webstr$,(red.Amount using "-----------.##"),fdel$
			let postingamt=postingamt+red.amount
			list$[row]=webstr$
			row=row+1                                       
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])                                        
		Loop                                                      
	End If                                                      
	List$[row] = esdel$                                         
	Call AddToStr(e$,rstr$,List$[]) 
	clear list$[]
	list$[0]=bsdel$,"POSTAMT",fdel$
	webstr$=""
	webstr$=webstr$,"POSTINGAMOUNT",fdel$
	list$[1]=webstr$
	row=2
	if returnstatus=1
		webstr$=(postingamt using "-----------.##"),fdel$
		list$[row]=webstr$
		row=row+1
	endif
	List$[row] = esdel$                                         
	Call AddToStr(e$,rstr$,List$[])
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
  end try
end sub ! getregldist

!--------------------------------------------------------------------
Sub submitregldist() ! recurring entries g/l  distributions 517
Try
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) Goto endsubregldist
	Call Dxget("TRANCODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		Goto endsubregldist 
	endif
	let transid$=rtrim$(tmp$)+blank$
	Transtype=1
	let keyrec$=" ",keyrec$
	let keyrec$[1,6]=vendid using "######"
	let keyrec$[7,14]=transid$
	let keyrec$[15,16]=transtype using "##"
	search #ch_aprec,2,1;keyrec$,rec_aprec,e
	if e<>0
		let message$="Error Recurring Entry Transaction "+rtrim$(transid$)+" Not On File. "
		returnstatus=0
		Goto endsubregldist 
	endif
	read record #ch_aprec,rec_aprec;rec.
	If rec.Status<>0
		let message$="Recurring Entry Transaction "+rtrim$(transid$)+" Is Invalid Status. May Not Updated."
		returnstatus=0
		Goto endsubregldist
	endif   
	! delete existing acct distributions
	let keyred$=" ",keyred$
	let keyred$[1,5]=rec_aprec using "#####"
	do
		search #ch_apred,3,1;keyred$,rec_apred,e
		if e>0 exit do
		let tmp3=keyred$[1,5]
		if tmp3<>rec_aprec exit do
		mode$ = "d" ! delete transaction                                               
		UpdStatus = fileupdateapred(e$,ch_apred,mode$,rec_apred,red.)
	loop
	                                               
	let postingamt=0
	Call Dxget("TOTREC",tmp$)                                         
	totrec = tmp$                                                     
	If totrec < 0                                       
		message$ = "Invalid Number of Records for Submission"
		returnstatus = 0                                                
	        Goto endsubregldist                                         
	EndIf 
	if totrec=0 and rec.transAmt<>0
		message$ = "No Records Submitted for G/L Account Distributions"
		returnstatus = 0                                                
	        Goto endsubregldist                                         
	EndIf 
	For ctr = 1 To totrec                    
		Call Dxget("GLACCTID" + Str$(ctr),tmp$) 
		dfltacctid=TMp$
		keyvl$=" ",keyvl$
		keyvl$[2,9]=dfltacctid using "########"
		search #ch_vl,2,1;keyvl$,rec_vl,e
		if e<>0
			message$ = "G/L Account "+str$(dfltacctid)+" Not on File. May Not Update."
			returnstatus = 0                                                
			Goto endsubregldist
		endif

		clear red.
		red.ApRecNum=rec_aprec 
		red.Vend=VENDID                     
		red.TransId$=Transid$               
		red.AcctId=dfltacctid                                            
		red.Item=ctr                       
		red.LineNum=ctr 
		red.Status=0  
		Call Dxget("GLAMOUNT" + Str$(ctr),tmp$)
		let tmp3=tmp$
		if fra(tmp3*100)<>0
			let returnstatus=0
			message$="Invalid Transaction Amount Submitted"
			goto endsubregldist:
		endif
		if transtype=2 let tmp3=tmp3*(-1)
		let red.Amount=tmp3
		let postingamt=postingamt+red.Amount
		mode$ = "a" ! add                                                 
		UpdStatus = fileupdateapred(e$,ch_apred,mode$,rec_apred,red.)
	next ctr
	endsubregldist: ! 
	if postingamt<>rec.Transamt
		returnstatus = 0                                                
		message$ = "G/L Posting Amount "+str$(postingamt)+" Not Equal to Transaction "+str$(rec.Transamt)
	endif
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
  end try
end sub ! submitregldist 517


!=========================================================================================================
Sub Start516Report()! Recurring Entry Journal
 Try
	ReturnStatus=1
	Message$="OK"
	Keyapc$ = " 0"
	Search #ch_apc,2,1;Keyapc$,Rec_apc,E
	if e>0
		let returstatus=0
		message$=message$+"RECORD '0' NOT FOUND IN A00AP"
		goto end516report:
	endif
	! open printer
	try Close #0 Else Rem
	onchannelno=0 ! zero for channel 
	printchan = openprinter(e$,onchannelno) 
	
	Call Dxget ("ACCTPER",tmp$) ! MM/YY
	if rtrim$(tmp$)=""
		let returnstatus=0
		message$="Invalid Accounting Period" 
		goto end516report:
	endif
	if tmp$[3,3]<>"/"
		let returnstatus=0
		message$="Invalid Accounting Period Format Submitted"
		goto end516report:
	endif
	let period$=tmp$[4,5],tmp$[1,2]
	let acctper=period$
	Call GetAcctPer()
	if acctper=currper
		let spec1[5]=0
	else
		if acctper=nxtper
			spec1[5]=1 
		else
			let returnstatus=0
			message$="Accounting Period Must Be Current or Next Month"
			goto end516report:
		endif
	endif
	Call Dxget("POSTDAY",tmp$)	
	let tmp3=tmp$
	if tmp3=0 or tmp3>31
		let returnstatus=0
		message$="Invalid Posting Day Submitted"
		goto end516report:
	endif
	let tmp$=tmp3 using "&&"
	let xdate$=period$,tmp$[1,2]
	tmpdate$=xdate$[3,4],"/",xdate$[5,6],"/20",xdate$[1,2] ! tmpdate$="mm/dd/yyyy"
	Call VerifyDate(tmpDate$,tmp$,errflag,1) ! returns in yyyymmd
	if errflag<>0
		let returnstatus=0
		let message$="Invalid Posting Day Submitted "
		goto end516report:
	endif
	!xdate$ = formatdate2$(tmp$)
	POSTDATE =  xdate$! [3,8]  
	LET TMP3=XDATE$[1,4]
	IF TMP3<>ACCTPER
		let returnstatus=0
		message$="Posting Date Must Match Accounting Period Selected"
		goto end516report:	
	endif
	Call dxget("PRPRT",tmp$) ! (NOT ADDED?)     
	audonly = 0 ! \ If tmp$ <> "" Let audonly = 1
	If UCASE$(RTRIM$(tmp$))="Y" Let audonly = 1
	! set up parameters for call
	clear spec1[]
	spec1[0]=intco ! company #
	spec1[1]=0 ! 1= PAGEBREAK
	spec1[2]=Audonly
	spec1[3]=batchid
	spec1[4]=Acctper
	spec1[5]=0 ! current or next month
	if nxtper=acctper let spec1[5]=1 ! flag as next month
	spec1[6]=postdate ! yymmdd format
	spec1[7]=0 
	spec1[8]=rec_uac
	spec1[9]=returnstatus
	Call "la516.dl4",SPEC1[],MESSAGE$,rstr$
	LET returnstatus=spec1[9]
	end516report: ! 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! Start516Report
!=========================================================================================================
Sub Start515Report()! Recurring Entry Journal
 Try
	ReturnStatus=1
	Message$="OK"
	Keyapc$ = " 0"
	Search #ch_apc,2,1;Keyapc$,Rec_apc,E
	if e>0
		let returstatus=0
		message$=message$+"RECORD '0' NOT FOUND IN A00AP"
		goto end515report:
	endif
	! open printer
	try Close #0 Else Rem
	onchannelno=0 ! zero for channel 
	printchan = openprinter(e$,onchannelno) 
	
	Call Dxget ("ACCTPER",tmp$) ! MM/YY
	if rtrim$(tmp$)=""
		let returnstatus=0
		message$="Invalid Accounting Period" 
		goto end515report:
	endif
	if tmp$[3,3]<>"/"
		let returnstatus=0
		message$="Invalid Accounting Period Format Submitted"
		goto end515report:
	endif
	let period$=tmp$[4,5],tmp$[1,2]
	let acctper=period$
	Call GetAcctPer()
	if acctper=currper
		let spec1[5]=0
	else
		if acctper=nxtper
			spec1[5]=1 
		else
			let returnstatus=0
			message$="Accounting Period Must Be Current or Next Month"
			goto end515report:
		endif
	endif
	Call dxget("PRPRT",tmp$) ! (NOT ADDED?)     
	audonly = 0 ! \ If tmp$ <> "" Let audonly = 1
	If UCASE$(RTRIM$(tmp$))="Y" Let audonly = 1
	! set up parameters for call
	clear spec1[]
	spec1[0]=intco ! company #
	spec1[1]=Acctper
	spec1[2]=audonly
	spec1[8]=rec_uac
	spec1[9]=returnstatus
	Call "la515.dl4",SPEC1[],MESSAGE$,rstr$
	LET returnstatus=spec1[9]
	end515report: ! 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! Start515Report
!--------------------------------------------------------------------
Sub getadjgldist() ! monthly adjustments entries g/l  distributions 515
Try
	
	dim 3%,postingamt
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto endgetadjgldist:
	Call Dxget("TRANSCODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto endgetadjgldist:
	endif
	let transid$=rtrim$(tmp$)+blank$
	Call Dxget("TRANSTYPE",tmp$)
	let transtype=0
	if ucase$(rtrim$(Tmp$))="INV" let transtype=1
	if ucase$(rtrim$(Tmp$))="C/M" let transtype=2
	if ucase$(rtrim$(Tmp$))="M/C" let transtype=3
	IF not(transtype)
		let message$="Invalid Transaction Type Submitted"
		let returnstatus=0
		goto endgetadjgldist:
	endif
	let keyadj$=" ",keyadj$
	let keyadj$[1,6]=vendid using "######"
	let keyadj$[7,18]=transid$
	let keyadj$[19,20]=transtype using "##"
	search #ch_adj,2,1;keyadj$,rec_adj,e
	if e<>0
		let message$="Error Adjustment Transaction "+rtrim$(transid$)+" Not On File. "
		returnstatus=0
		goto endgetadjgldist:
	endif
	read record #ch_adj,rec_adj;adj.
	If adj.Status<>0
		let message$="Adjustment Transaction "+rtrim$(transid$)+" Is Invalid Status."
		returnstatus=0
		goto endgetadjgldist:
	endif   
	let eflag=0
	
	endgetadjgldist: ! 
	clear list$[]
	list$[0]=bsdel$,"ADJGLDIST",fdel$
	webstr$=""
	webstr$=webstr$,"GLACCTID",fdel$
	webstr$=webstr$,"GLACCTNAME",fdel$
	webstr$=webstr$,"GLAMOUNT",fdel$
	
	list$[1]=webstr$
	let row=2
	let tmpcnt=maxcnt
	let postingamt=0
	if returnstatus=1
		let keyadg$=" ",keyadg$
		let keyadg$[1,5]=rec_adj using "#####"
		do
			search #ch_adg,3,1;keyadg$,rec_adg,e
			if e>0 exit do
			let tmp3=keyadg$[1,5]
			if tmp3<>rec_adj exit do
			read record #ch_adg,rec_adg;adg.;
			let tmp3=adg.acctid$
			webstr$=(tmp3 using "########"),fdel$
			keyvl$=" ",keyvl$
			keyvl$[2,9]=tmp3 using "########"
			clear apvl.
			search #ch_vl,2,1;keyvl$,rec_vl,e
			if not(e)
				read record #ch_vl,rec_vl;apvl.;
			else
				apvl.desc$="Not on File!!!"
			endif
			webstr$=webstr$,rtrim$(apvl.desc$),fdel$ ! account name
			if transtype=2
				let adg.Amount=adg.Amount *(-1)
			endif
			webstr$=webstr$,(adg.Amount using "-----------.##"),fdel$
			let postingamt=postingamt+adg.amount
			list$[row]=webstr$
			row=row+1                                       
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])                                        
		Loop                                                      
	End If                                                      
	List$[row] = esdel$                                         
	Call AddToStr(e$,rstr$,List$[]) 
	clear list$[]
	list$[0]=bsdel$,"POSTAMT",fdel$
	webstr$=""
	webstr$=webstr$,"POSTINGAMOUNT",fdel$
	list$[1]=webstr$
	row=2
	if returnstatus=1
		webstr$=(postingamt using "-----------.##"),fdel$
		list$[row]=webstr$
		row=row+1
	endif
	List$[row] = esdel$                                         
	Call AddToStr(e$,rstr$,List$[])
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
  end try
end sub ! getadjgldist

!--------------------------------------------------------------------
Sub submitadjgldist() ! recurring entries g/l  distributions 517
Try
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) Goto endsubadjgldist
	Call Dxget("TRANSCODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		Goto endsubadjgldist 
	endif
	let transid$=rtrim$(tmp$)+blank$
	Call Dxget("TRANSTYPE",tmp$)
	let transtype=0
	if ucase$(rtrim$(Tmp$))="INV" let transtype=1
	if ucase$(rtrim$(Tmp$))="C/M" let transtype=2
	if ucase$(rtrim$(Tmp$))="M/C" let transtype=3
	IF not(transtype)
		let message$="Invalid Transaction Type Submitted"
		let returnstatus=0
		goto endsubadjgldist:
	endif
	let keyadj$=" ",keyadj$
	let keyadj$[1,6]=vendid using "######"
	let keyadj$[7,18]=transid$
	let keyadj$[19,20]=transtype using "##"
	search #ch_adj,2,1;keyadj$,rec_adj,e
	if e<>0
		let message$="Error Adjustment Transaction "+rtrim$(transid$)+" Not On File. "
		returnstatus=0
		Goto endsubadjgldist 
	endif
	read record #ch_adj,rec_adj;adj.;
	If adj.Status<>0
		let message$="Adjustment Transaction "+rtrim$(transid$)+" Is Invalid Status. May Not Updated."
		returnstatus=0
		Goto endsubadjgldist
	endif   
	! delete existing acct distributions
	let keyadg$=" ",keyadg$
	let keyadg$[1,5]=rec_adj using "#####"
	do
		search #ch_adg,3,1;keyadg$,rec_adg,e
		if e>0 exit do
		let tmp3=keyadg$[1,5]
		if tmp3<>rec_adj exit do
		read record #ch_adg,rec_adg;adg.;
		!mode$ = "d" ! delete transaction                                               
		!UpdStatus = fileupdateapa10ad(e$,ch_adg,mode$,rec_adg,adg.)
		
		let keyadg2$=" ",keyadg2$
		let keyadg2$[1,8]=adg.acctid$[1,8]
		let keyadg2$[9,12]=adg.adrecnum using "####"
		search #ch_adg,5,2;keyadg2$,rec_adg,e
		search #ch_adg,5,1;keyadg$,rec_adg,e\If e <> 0 Error (10000 + e)
		let e=3\search #ch_adg,1,0;keyadg$,rec_adg,e
	loop
	                                               
	let postingamt=0
	Call Dxget("TOTREC",tmp$)                                         
	totrec = tmp$                                                     
	If totrec < 0                                       
		message$ = "Invalid Number of Records for Submission"
		returnstatus = 0                                                
	        Goto endsubadjgldist                                         
	EndIf 
	if totrec=0 
		message$ = "No Records Submitted for G/L Account Distributions"
		returnstatus = 0                                                
	        Goto endsubadjgldist                                         
	EndIf 
	For ctr = 1 To totrec                    
		Call Dxget("GLACCTID" + Str$(ctr),tmp$) 
		dfltacctid=TMp$
		keyvl$=" ",keyvl$
		keyvl$[2,9]=dfltacctid using "########"
		search #ch_vl,2,1;keyvl$,rec_vl,e
		if e<>0
			message$ = "G/L Account "+str$(dfltacctid)+" Not on File. May Not Update."
			returnstatus = 0                                                
			Goto endsubadjgldist
		endif

		clear adg.
		adg.AJRecNum=rec_adj 
		adg.Vend=VENDID                     
		adg.TransId$=Transid$ 
		adg.div=modo.div
		adg.space$=" "
		adg.acctid$=" ",adg.acctid$
		adg.AcctId$[1,8]=dfltacctid using "########"
		adg.space1$="   "
		adg.Item=ctr                       
		Call Dxget("GLAMOUNT" + Str$(ctr),tmp$)
		let tmp3=tmp$
		if fra(tmp3*100)<>0
			let returnstatus=0
			let message$="Amount exceeds 2 decimals places"
			goto endsubadjgldist:
		endif
		!if transtype=2 let tmp3=tmp3*(-1)
		let adg.Amount=tmp3
		let postingamt=postingamt+adg.Amount
		let keyadg$=" ",keyadg$
		let e=2\search #ch_adg,1,0;keyadg$,rec_adg,e\ If e <> 0 Error (10000 + e)
		LET adg.adrecnum=rec_adg
		write record #ch_adg,rec_adg;adg.;
		let keyadg$=" ",keyadg$
		let keyadg$[1,5]=adg.ajrecnum using "#####"
		let keyadg$[6,8]=adg.item using "###"
		search #ch_adg,4,1;keyadg$,rec_adg,e\If e <> 0 Error (10000 + e)
		let keyadg$=" ",keyadg$
		let keyadg$[1,8]=adg.acctid$[1,8]
		let keyadg$[9,12]=adg.adrecnum using "####"
		search #ch_adg,4,2;keyadg$,rec_adg,e\If e <> 0 Error (10000 + e)
	next ctr
	if postingamt<>0
			returnstatus = 0                                                
		    message$ = "Total G/L Posting Amounts "+str$(postingamt)+". Should Equal to Zero "
	endif
	endsubadjgldist: ! 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
  end try
end sub ! submitadjgldist 515
!=================================================================================
Sub getadjtrans() ! gets the ap transaction or creates a new one
Try
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto endgetadjtran:
	Call Dxget ("ACCTPER",tmp$) ! MM/YY
	if rtrim$(tmp$)=""
		let returnstatus=0
		message$="Invalid Accounting Period" 
		goto endgetadjtran:
		
	endif
	if tmp$[3,3]<>"/"
		let returnstatus="Invalid Accounting Period Format Submitted"
		goto endgetadjtran: 
	endif
	let period$=tmp$[4,5],tmp$[1,2]
	let acctper=period$
	Call GetAcctPer()
	if acctper=currper
		! ok
	else
		if acctper=nxtper
			! ok
		else
			let returnstatus=0
			message$="Accounting Period Must Be Current or Next Month"
			goto endgetadjtran:
		endif
	endif
	if not (returnstatus) goto endgetadjtran:
	Call Dxget("TRANSCODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto endgetadjtran:
	endif
	let transid$=rtrim$(tmp$)+blank$
	Call Dxget("TRANSTYPE",tmp$)
	let transtype=0
	if ucase$(rtrim$(Tmp$))="INV" let transtype=1
	if ucase$(rtrim$(Tmp$))="C/M" let transtype=2
	if ucase$(rtrim$(Tmp$))="M/C" let transtype=3
	IF not(transtype)
		let message$="Invalid Transaction Type Submitted"
		let returnstatus=0
		goto endgetadjtran:
	endif
	keyadj$[1,6]=vendid using "######"
	keyadj$[7,18]=transid$[1,12]
	keyadj$[19,20]=transtype using "##"
	search #ch_adj,2,1;keyadj$,rec_adj,e\if e>1 Error (10000 + e)
	if not(e)
		read record #ch_adj,rec_adj,0;adj.;
		if acctper<>adj.postper
			let tmp$=adj.postper using "&&&&"
			let message$="Transaction Already on File for Accounting Period "+tmp$[3,4]+"/"+tmp$[1,2]
			let returnstatus=0
			goto endgetadjtran:
		endif
	else
		LET TMP$=ACCTPER USING "&&&&"
		G8$[1,1] = IntCo Using "#"                  
		Call dxget("u_group",groupid$)              
		If RTrim$(groupid$) = "" Let groupid$ = "0" 
		G8$[2,2] = groupid$                         
		FNAME$="2/AM0DO"+G8$[1,2]+tmp$
		Call FindF(Fname$,tmp3)
		if not(tmp3)
			let returnstatus=0
			let message$="Transactions Adjustment are not available for this Accounting Period"
			goto endgetadjtran:
		endif
		CH_modo = FindChannel()
		ropen #ch_modo,fname$
		let keymodo$=" ",keymodo$
		let keymodo$[1,18]=keyadj$[1,18]
		DO
			search #ch_modo,3,1;keymodo$,rec_modo,e
			if e<>0
				let returnstatus=0
				let message$="Transaction Not Found for this Accounting Period"
				goto endgetadjtran:
			endif
			if keymodo$[1,18]<>keyadj$[1,18]
				let returnstatus=0
				let message$="Transaction Not Found for this Accounting Period"
				goto endgetadjtran:
			endif
			Read record #ch_modo,rec_modo,0;modo.;
			if modo.DocCode=transtype exit do
		LOOP
		clear adj.
		adj.vend=vendid
		adj.div=modo.div
		adj.amdorecnum=rec_modo
		adj.status=0
		adj.transtype=transtype
		adj.postper=acctper
		adj.transid$=transid$
		mode$ = "a"                                                      
		UpdStatus = fileupdateapa10aj(e$,ch_adj,mode$,rec_adj,adj.) !
		let rec_adj=updstatus
	endif
	endgetadjtran: !
	clear list$[]
	list$[0]=bsdel$,"AdjTransaction",fdel$
	webstr$=""
	webstr$="VendId",fdel$
	webstr$=webstr$,"TransCode",fdel$
	Webstr$=webstr$,"TransType",fdel$
	webstr$=webstr$,"AdjustDate",fdel$
	list$[1]=webstr$
	row=2
	if returnstatus=1 ! no errors
		let webstr$=""
		webstr$=str$(vendid),fdel$
		webstr$=webstr$,rtrim$(transid$),fdel$
		let tmp$="INV"
		if transtype=2 let tmp$="C/M"
		if transtype=3 let tmp$="M/C"
		WebStr$ = WebStr$,RTrim$(tmp$),fdel$
		xdate$=""
		If adj.AdjDate <> 0                
			 xdate$ = pdate$(adj.AdjDate)     
		endif                         
		WebStr$ = WebStr$,RTrim$(xdate$),fdel$
		let list$[row]=webstr$
		row=row+1
	endif
	list$[row]=esdel$ ! end of section
	call AddToStr(e$,rstr$,List$[])
	
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)	! let send over the data

else
    include "src/callsuberr.inc"
end try
end sub ! getadjtrans


!=================================================================================
Sub submitadjtrans() ! gets the ap transaction or creates a new one
Try
	 Dim tmpDate$[20]
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto endsubadjtran:
	Call Dxget ("ACCTPER",tmp$) ! MM/YY
	if rtrim$(tmp$)=""
		let returnstatus=0
		message$="Invalid Accounting Period" 
		goto endsubadjtran:
		
	endif
	if tmp$[3,3]<>"/"
		let returnstatus="Invalid Accounting Period Format Submitted"
		goto endsubadjtran: 
	endif
	let period$=tmp$[4,5],tmp$[1,2]
	let acctper=period$
	Call GetAcctPer()
	if acctper=currper
		! ok
	else
		if acctper=nxtper
			! ok
		else
			let returnstatus=0
			message$="Accounting Period Must Be Current or Next Month"
			goto endsubadjtran:
		endif
	endif
	if not (returnstatus) goto endsubadjtran:
	Call Dxget("TRANSCODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto endsubadjtran:
	endif
	let transid$=rtrim$(tmp$)+blank$
	Call Dxget("TRANSTYPE",tmp$)
	let transtype=0
	if ucase$(rtrim$(Tmp$))="INV" let transtype=1
	if ucase$(rtrim$(Tmp$))="C/M" let transtype=2
	if ucase$(rtrim$(Tmp$))="M/C" let transtype=3
	IF not(transtype)
		let message$="Invalid Transaction Type Submitted"
		let returnstatus=0
		goto endsubadjtran:
	endif
	keyadj$[1,6]=vendid using "######"
	keyadj$[7,18]=transid$[1,12]
	keyadj$[19,20]=transtype using "##"
	search #ch_adj,2,1;keyadj$,rec_adj,e\if e>1 Error (10000 + e)
	if not(e)
		read record #ch_adj,rec_adj,0;adj.;
		if acctper<>adj.postper
			let tmp$=adj.postper using "&&&&"
			let message$="Transaction Already on File for Accounting Period "+tmp$[3,4]+"/"+tmp$[1,2]
			let returnstatus=0
			goto endsubadjtran:
		endif
	else	
		let message$="Transaction Not On File"
		let returnstatus=0
		goto endsubadjtran:
	endif
	Call Dxget("ADJDATE",tmpDate$) !                                   
	Call VerifyDate(tmpDate$,tmp$,errflag,1) ! returns in yyyymmdd 
	If errflag <> 0                                                        
		ReturnStatus = 0                                                     
		Message$ = "Invalid Adjustment Date Submitted "                         
		Goto endsubadjtran:                                                 
	End If                 
	ADJ.Adjdate = tmp$[3,8] ! yymmdd                                          
	write record #ch_adj,rec_adj,0;adj.;                                         	                                                                                                                                                         
	endsubadjtran: !	
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)	! let send over the data

else
    include "src/callsuberr.inc"
end try
end sub ! subadjtrans


!=================================================================================
Sub deleteadjtrans() ! gets the adjustment transaction and delete it
Try
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto enddeladjtran:
	Call Dxget ("ACCTPER",tmp$) ! MM/YY
	if rtrim$(tmp$)=""
		let returnstatus=0
		message$="Invalid Accounting Period" 
		goto enddeladjtran:
		
	endif
	if tmp$[3,3]<>"/"
		let returnstatus="Invalid Accounting Period Format Submitted"
		goto enddeladjtran: 
	endif
	let period$=tmp$[4,5],tmp$[1,2]
	let acctper=period$
	Call GetAcctPer()
	if acctper=currper
		! ok
	else
		if acctper=nxtper
			! ok
		else
			let returnstatus=0
			message$="Accounting Period Must Be Current or Next Month"
			goto enddeladjtran:
		endif
	endif
	if not (returnstatus) goto enddeladjtran:
	Call Dxget("TRANSCODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto enddeladjtran:
	endif
	let transid$=rtrim$(tmp$)+blank$
	Call Dxget("TRANSTYPE",tmp$)
	let transtype=0
	if ucase$(rtrim$(Tmp$))="INV" let transtype=1
	if ucase$(rtrim$(Tmp$))="C/M" let transtype=2
	if ucase$(rtrim$(Tmp$))="M/C" let transtype=3
	IF not(transtype)
		let message$="Invalid Transaction Type Submitted"
		let returnstatus=0
		goto enddeladjtran:
	endif
	keyadj$[1,6]=vendid using "######"
	keyadj$[7,18]=transid$[1,12]
	keyadj$[19,20]=transtype using "##"
	search #ch_adj,2,1;keyadj$,rec_adj,e\if e>1 Error (10000 + e)
	if e<>0
		let message$="Transaction Not On File"
		let returnstatus=0
		goto enddeladjtran:
	endif
	read record #ch_adj,rec_adj,0;adj.;
	if acctper<>adj.postper
		let tmp$=adj.postper using "&&&&"
		let message$="Transaction Already on File for Accounting Period "+tmp$[3,4]+"/"+tmp$[1,2]
		let returnstatus=0
		goto enddeladjtran:
	endif
	If adj.Status<>0
		let message$="Adjustment Transaction "+rtrim$(transid$)+" Is Invalid Status. May Not Updated."
		returnstatus=0
		goto enddeladjtran:
	endif   
	! delete existing acct distributions
	let keyadg$=" ",keyadg$
	let keyadg$[1,5]=rec_adj using "#####"
	do
		search #ch_adg,3,1;keyadg$,rec_adg,e
		if e>0 exit do
		let tmp3=keyadg$[1,5]
		if tmp3<>rec_adj exit do
		read record #ch_adg,rec_adg;adg.;
		!mode$ = "d" ! delete transaction                                               
		!UpdStatus = fileupdateapa10ad(e$,ch_adg,mode$,rec_adg,adg.)
		
		let keyadg2$=" ",keyadg2$
		let keyadg2$[1,8]=adg.acctid$[1,8]
		let keyadg2$[9,12]=adg.adrecnum using "####"
		search #ch_adg,5,2;keyadg2$,rec_adg,e
		search #ch_adg,5,1;keyadg$,rec_adg,e\If e <> 0 Error (10000 + e)
		let e=3\search #ch_adg,1,0;keyadg$,rec_adg,e
	loop
	mode$ = "d" ! delete transaction                                               
	UpdStatus = fileupdateapa10aj(e$,ch_adj,mode$,rec_adj,adj.)                                                                                     	                                                                                                                                                         
	enddeladjtran: !	
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)	! let send over the data

else
    include "src/callsuberr.inc"
end try
end sub ! deleteadjtrans


! start calls for direct disbursements

!--------------------------------------------------------------------
Sub getddgldist() ! direct disbursement entries g/l  distributions 522
Try
	
	dim 3%,postingamt
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	if vendid<>0
		call verifyvendor()
		if not (returnstatus) goto endgetddgldist:
	endif
	Call Dxget("TRANCODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto endgetddgldist:
	endif
	let transid$=rtrim$(tmp$)+blank$
	
	let keydb$=" ",keydb$
	let keydb$[1,6]=vendid using "######"
	let keydb$[7,18]=transid$
	search #ch_db,2,1;keydb$,rec_db,e
	if e<>0
		let message$="Error Direct Disbursement Transaction "+rtrim$(transid$)+" Not On File. "
		returnstatus=0
		goto endgetddgldist:
	endif
	read record #ch_db,rec_db;db.
	If db.Status<>0
		let message$="Direct Disbursement Transaction "+rtrim$(transid$)+" Is Invalid Status."
		returnstatus=0
		goto endgetddgldist:
	endif   
	IF Vendid<>0 
		! find default gl acct
		LET dfltacctid=vend.GLAccountNumber$
		if not(dfltacctid) goto endgetddgldist:
		IF C0[6]<>0 AND DEPT<>0 ! AP DIVISIONS SET UP WITH GL DEPARTMENT
			keyvl$=" ",keyvl$
			keyvl$[2,9]=dfltacctid using "########"
			keyvl$[8,9]=db.div using "&&"
			search #ch_vl,2,1;keyvl$,rec_vl,e
			if e=0
				let dfltacctid=keyvl$[2,9]
				goto checkddrec:
			endif
		endif
		keyvl$=" ",keyvl$
		keyvl$[2,9]=dfltacctid using "########"
		search #ch_vl,2,1;keyvl$,rec_vl,e
		if e<>0 goto endgetddgldist:
		checkddrec: ! check to see if ap gl records exists
		! check if gl transactions already exists
		let keydd$=" ",keydd$
		let keydd$[1,5]=rec_db using "#####"
		search #ch_dd,3,1;keydd$,rec_dd,e
		if not(e)
			let tmp3=keydd$[1,5]
			if tmp3=rec_db goto endgetddgldist:! need to check if apgl dist already exists
		endif 
		! now create gl distribution
		clear dd.
		dd.dbrecnum=rec_db 
		dd.Vend=VENDID
		dd.name$=db.name$
		dd.AcctId$=dfltacctid using "########"

		dd.Amount=db.GrossAmt 
		
		dd.Item=1         
		dd.TransId$=Transid$
		mode$ = "a" ! add                                                 
		UpdStatus = fileupdateapa50dd(e$,ch_dd,mode$,rec_dd,dd.)
		! get gl acct # in vendor file
		! check if division and department and 
	endif
	
	endgetddgldist: ! 
	clear list$[]
	list$[0]=bsdel$,"DDGLDIST",fdel$
	webstr$=""
	webstr$=webstr$,"GLACCTID",fdel$
	webstr$=webstr$,"GLACCTNAME",fdel$
	webstr$=webstr$,"GLAMOUNT",fdel$
	
	list$[1]=webstr$
	let row=2
	let tmpcnt=maxcnt
	let postingamt=0
	if returnstatus=1
		let keydd$=" ",keydd$
		let keydd$[1,5]=rec_db using "#####"
		do
			search #ch_dd,3,1;keydd$,rec_dd,e
			if e>0 exit do
			let tmp3=keydd$[1,5]
			if tmp3<>rec_db exit do
			read record #ch_dd,rec_dd;dd.;
			let tmp3=dd.acctid$
			webstr$=(tmp3 using "########"),fdel$
			keyvl$=" ",keyvl$
			keyvl$[2,9]=tmp3 using "########"
			clear apvl.
			search #ch_vl,2,1;keyvl$,rec_vl,e
			if not(e)
				read record #ch_vl,rec_vl;apvl.;
			else
				apvl.desc$="Not on File!!!"
			endif
			webstr$=webstr$,rtrim$(apvl.desc$),fdel$ ! account name
			if db.transtype=2
				let dd.Amount=dd.Amount *(-1)
			endif
			webstr$=webstr$,(dd.Amount using "-----------.##"),fdel$
			let postingamt=postingamt+dd.amount
			list$[row]=webstr$
			row=row+1                                       
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])                                        
		Loop                                                      
	End If                                                      
	List$[row] = esdel$                                         
	Call AddToStr(e$,rstr$,List$[]) 
	clear list$[]
	list$[0]=bsdel$,"POSTAMT",fdel$
	webstr$=""
	webstr$=webstr$,"POSTINGAMOUNT",fdel$
	list$[1]=webstr$
	row=2
	if returnstatus=1
		webstr$=(postingamt using "-----------.##"),fdel$
		list$[row]=webstr$
		row=row+1
	endif
	List$[row] = esdel$                                         
	Call AddToStr(e$,rstr$,List$[])
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
  end try
end sub ! getddgldist


!--------------------------------------------------------------------
Sub submitddgldist() ! direct disbursements entry 515
Try
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	if vendid<>0
		call verifyvendor()
		if not (returnstatus) goto endsubddgldist:
	endif
	Call Dxget("TRANCODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto endsubddgldist:
	endif
	let transid$=rtrim$(tmp$)+blank$
	
	let keydb$=" ",keydb$
	let keydb$[1,6]=vendid using "######"
	let keydb$[7,18]=transid$
	search #ch_db,2,1;keydb$,rec_db,e
	if e<>0
		let message$="Error Direct Disbursement Transaction "+rtrim$(transid$)+" Not On File. "
		returnstatus=0
		goto endsubddgldist:
	endif
	read record #ch_db,rec_db;db.
	If db.Status<>0
		let message$="Direct Disbursement Transaction "+rtrim$(transid$)+" Is Invalid Status."
		returnstatus=0
		goto endsubddgldist:
	endif   
	! delete existing acct distributions
	let keydd$=" ",keydd$
	let keydd$[1,5]=rec_db using "#####"
	do
		search #ch_dd,3,1;keydd$,rec_dd,e
		if e>0 exit do
		let tmp3=keydd$[1,5]
		if tmp3<>rec_db exit do
		mode$ = "d" ! delete transaction                                               
		UpdStatus = fileupdateapa50dd(e$,ch_dd,mode$,rec_dd,dd.)
	loop
	                                               
	let postingamt=0
	Call Dxget("TOTREC",tmp$)                                         
	totrec = tmp$                                                     
	If totrec < 0                                       
		message$ = "Invalid Number of Records for Submission"
		returnstatus = 0                                                
	        Goto endsubddgldist                                         
	EndIf 
	if totrec=0 and db.grossAmt<>0
		message$ = "No Records Submitted for G/L Account Distributions"
		returnstatus = 0                                                
	        Goto endsubddgldist                                         
	EndIf 
	For ctr = 1 To totrec                    
		Call Dxget("GLACCTID" + Str$(ctr),tmp$) 
		dfltacctid=TMp$
		keyvl$=" ",keyvl$
		keyvl$[2,9]=dfltacctid using "########"
		search #ch_vl,2,1;keyvl$,rec_vl,e
		if e<>0
			message$ = "G/L Account "+str$(dfltacctid)+" Not on File. May Not Update."
			returnstatus = 0                                                
			Goto endsubddgldist
		endif
		clear dd.                                                    
		dd.Item=ctr    
		dd.dbrecnum=rec_db 
		dd.Vend=VENDID
		dd.name$=db.name$
		dd.AcctId$=dfltacctid using "########"
		dd.Amount=0                      
		dd.Item=ctr      
		dd.TransId$=Transid$
		Call Dxget("GLAMOUNT" + Str$(ctr),tmp$)
		let tmp3=tmp$
		if fra(tmp3*100)<>0
			let returnstatus=0
			let message$="Amount exceeds 2 decimals places"
			goto endsubddgldist:
		endif
		if transtype=2 let tmp3=tmp3*(-1)
		let dd.Amount=tmp3
		let postingamt=postingamt+dd.Amount
		mode$ = "a" ! add                                                 
		UpdStatus = fileupdateapa50dd(e$,ch_dd,mode$,rec_dd,dd.)
	next ctr
	If postingamt<>db.grossamt
			returnstatus = 0                                                
		    message$ = "G/L Posting Amount "+str$(postingamt)+" Not Equal to Transaction "+str$(db.grossamt)
	endif
	endsubddgldist: ! 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
  end try
end sub ! submitddgldist 522

!=================================================================================
Sub getddtrans() ! gets the direct disbursement Transaction 522
Try
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	if vendid<>0
		call verifyvendor()
	endif
	if not (returnstatus) goto endgetddtran:
	Call Dxget("TRANCODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto endgetddtran:
	endif
	let transid$=rtrim$(tmp$)+blank$
	

	newtrans=0 ! no
	let keydb$=" ",keydb$
	let keydb$[1,6]=vendid using "######"
	let keydb$[7,18]=transid$
	search #ch_db,2,1;keydb$,rec_db,e
	if e>1
		let message$="Error In A/P Direct Disbursement Entry File. May Not Create Transaction "
		returnstatus=0
		goto endgetddtran:
	endif
	if e=1 ! new record   
		newtrans=99
		clear db.
		db.Vend=Vendid
		if vendid<>0 and rec_vend>0
			db.name$=vend.PayToName$                     
			db.addr1$=vend.PayToAddress$                  
			db.addr2$=vend.PayToOptAddress$                             
			db.city$= vend.paytocity$
			db.state$=vend.paytostate$
			db.zip$= vend.paytozip$
		endif

		db.div=0
		If C0[6]
			if prt.div<=0 let prt.div=1
			if prt.div > 0 Let db.Div = prt.div 
		endif
		db.status=99
		db.transtype=1 ! default transaction type
		db.transid$=transid$	
		let mode$="a"
		UpdStatus = fileupdateapa50db(e$,ch_db,mode$,rec_db,db.)
		rec_db=updStatus
		read record #ch_db,rec_db;db.;                                                 	
	else ! existing record
		read record #ch_db,rec_db;db.;
		NEWTRANS=0	
		IF db.Status<>0
			let returnstatus=0
			let message$="Transaction "+rtrim$(transid$)+" for Vendor "+str$(VendId)+" In Process Elsewhere"
			goto endgetddtran:
		endif	
	endif
	endgetddtran: !
	clear list$[]
	list$[0]=bsdel$,"DDTransaction",fdel$
	webstr$=""
	webstr$="VendId",fdel$
	webstr$=webstr$,"Name",fdel$
	webstr$=webstr$,"Addr1",fdel$
	webstr$=webstr$,"Addr2",fdel$
	webstr$=webstr$,"City",fdel$
	webstr$=webstr$,"State",fdel$
	webstr$=webstr$,"Zip",fdel$
	webstr$=webstr$,"TranCode",fdel$
	Webstr$=webstr$,"TranType",fdel$
	webstr$=webstr$,"TranDate",fdel$
	webstr$=webstr$,"TranAmt",fdel$
	webstr$=webstr$,"DiscountAmt",fdel$
	webstr$=webstr$,"Decription",fdel$
	webstr$=webstr$,"Division",fdel$
	webstr$=webstr$,"CheckNumber",fdel$
	webstr$=webstr$,"CheckDate",fdel$
	webstr$=webstr$,"BankNumber",fdel$
	webstr$=webstr$,"NewRecord",fdel$
	list$[1]=webstr$
	row=2
	if returnstatus=1 ! no errors
		let webstr$=""
		webstr$=str$(vendid),fdel$
		webstr$=webstr$+rtrim$(db.name$)+fdel$
		webstr$=webstr$+rtrim$(db.addr1$)+fdel$
		webstr$=webstr$+rtrim$(db.addr2$)+fdel$
		webstr$=webstr$+rtrim$(db.city$)+fdel$
		webstr$=webstr$+rtrim$(db.state$)+fdel$
		webstr$=webstr$+rtrim$(db.zip$)+fdel$
		webstr$=webstr$,rtrim$(transid$),fdel$
		let transtype=db.Transtype
		let tmp$="INV"
		if transtype=2 let tmp$="C/M"
		if transtype=3 let tmp$="M/C"
		WebStr$ = WebStr$,RTrim$(tmp$),fdel$
		xdate$=""
		If db.trandate <> 0                              
			xdate$ = pdate$(db.trandate)                   
		End If                                       
		WebStr$ = WebStr$ + RTrim$(xdate$) + fdel$
		if db.TransType=2
			let db.grossamt=db.grossamt*(-1)
			let db.discamt=db.discamt*(-1)
		endif
		webstr$=webstr$,(db.GrossAmt using "###########.##"),fdel$
		webstr$=webstr$,(db.DiscAmt using "###########.##"),fdel$
		Webstr$=webstr$,rtrim$(db.Desc$),fdel$
		If c0[6] 
			webstr$=webstr$,(db.Div using"##"),fdel$
		else
			webstr$=webstr$,"",fdel$
		endif
		If transtype = 3                                     
			 WebStr$ = WebStr$,(db.CheckNum using "######"),fdel$       
			 If db.CheckDate <> 0 ! was oi.checkdate
				xdate$ = pdate$(db.CheckDate)                    
			 End If  ! if no date - same as trandate?                                           
			 WebStr$ = WebStr$,RTrim$(xdate$),fdel$ ! check date
			 WebStr$ = WebStr$,Str$(db.BankNum),fdel$        
		Else                                                 
			WebStr$ = WebStr$,"",fdel$                         
			WebStr$ = WebStr$,"",fdel$                         
			WebStr$ = WebStr$,"",fdel$                         
		End If                                               
		let tmp$="N"
		if newtrans<>0 let tmp$="Y"
		webstr$=webstr$,tmp$,fdel$ ! new record
		let list$[row]=webstr$
		row=row+1
	endif
	list$[row]=esdel$ ! end of section
	call AddToStr(e$,rstr$,List$[])
	
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)	! let send over the data

else
    include "src/callsuberr.inc"
end try
end sub ! getddtrans  -- 522
!=====================================================================================
Sub Deleteddtrans() ! deletes an existing direct disbursement entry  transaction 523
Try
	
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	if vendid<>0
		call verifyvendor()
	endif
	if not (returnstatus) goto enddeleteddtran:
	Call Dxget("TRANCODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto enddeleteddtran:
	endif
	let transid$=rtrim$(tmp$)+blank$
	let keydb$=" ",keydb$
	let keydb$[1,6]=vendid using "######"
	let keydb$[7,18]=transid$
	search #ch_db,2,1;keydb$,rec_db,e
	if e<>0
		let message$="Direct Disbursement Transaction "+rtrim$(transid$)+" Not On File. "
		returnstatus=0
		goto enddeleteddtran:
	endif
	read record #ch_db,rec_db;db.
	if db.status<>0 and db.status<>99
		let message$="Direct Disbursement Transaction "+rtrim$(transid$)+" Is Invalid Status. May Not Delete."
		returnstatus=0
		goto enddeleteddtran:
	endif   
	keydd$=" ",keyred$
	keydd$[1,5]=rec_db using "#####"
	do
		search #ch_dd,3,1;keydd$,rec_dd,e
		if e<>0 exit do
		let tmp3=keydd$[1,5]
		if tmp3<>rec_db exit do
		mode$ = "d" ! delete transaction                                                                   
		UpdStatus = fileupdateapa50dd(e$,ch_dd,mode$,rec_dd,dd.)
	loop
	mode$ = "d" ! delete transaction                                                                   
	UpdStatus = fileupdateapa50db(e$,ch_db,mode$,rec_db,db.) 
        let message$="Deleted"     
	enddeleteddtran: !
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)	! let send over the data

else
    include "src/callsuberr.inc"
end try
end sub ! Deleteddtrans
!=====================================================================================
Sub Submitddtrans() ! gets the recurring entry transaction or creates a new one 522

Try
	dim tmpdate$[20]
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	if vendid<>0
		call verifyvendor()
		if not (returnstatus) goto endsubmitddtran:
	endif
	Call Dxget("TRANCODE",tmp$)
	if rtrim$(tmp$)=""
		let message$="Invalid Transaction Id Submitted "
		returnstatus=0
		goto endsubmitddtran:
	endif
	let transid$=rtrim$(tmp$)+blank$
	transtype=1
	let keydb$=" ",keydb$
	let keydb$[1,6]=vendid using "######"
	let keydb$[7,18]=transid$
	search #ch_db,2,1;keydb$,rec_db,e
	if e<>0
		let message$="Direct Disbursement Transaction "+rtrim$(transid$)+" Not On File. "
		returnstatus=0
		goto endsubmitddtran:
	endif
	read record #ch_db,rec_db;db.
	If db.Status=0
		let message$="Direct Disbursement Transaction "+rtrim$(transid$)+" Is Invalid Status. May Not Submit."
		returnstatus=0
		goto endsubmitddtran:
	endif 
	db.Status=0
        Call Dxget("TRANTYPE",tmp$)                     
	Transtype = 0                                    
	If UCase$(RTrim$(tmp$)) = "INV" Let Transtype = 1
	If UCase$(RTrim$(tmp$)) = "C/M" Let Transtype = 2
	If UCase$(RTrim$(tmp$)) = "M/C" Let Transtype = 3
	If Not(Transtype)                                
		Message$ = "Invalid Transaction Type Submitted"
		ReturnStatus = 0                               
		goto endsubmitddtran:                              
	End If    
	let db.transtype=transtype
	let db.vend=vendid
	let db.transid$=transid$
	
	Call Dxget("NAME",tmp$)
	let db.name$=rtrim$(tmp$)+blank$
	Call Dxget("ADDR1",tmp$)
	let db.addr1$=rtrim$(tmp$)+blank$
	Call Dxget("ADDR2",tmp$)
	let db.addr2$=rtrim$(tmp$)+blank$
	Call Dxget("CITY",tmp$)
	let db.CITY$=rtrim$(tmp$)+blank$
	Call Dxget("STATE",tmp$)
	let db.STATE$=rtrim$(tmp$)+blank$
	Call Dxget("ZIP",tmp$)
	let db.Zip$=rtrim$(tmp$)+blank$
	
	
	Call Dxget ("TranAmt",tmp$)
	let tmp3=tmp$
	if fra(tmp3*100)<>0
		returnstatus = 0                         
		Message$=mESSAGE$+" Invalid Transaction Amt Submitted "
		goto endsubmitddtran:
	endif
	if tmp3<0 and transtype<>3 ! negative amount and it's not a manual check
		let returnstatus=0
		message$="Invalid Transaction Amount Submitted"
		goto endsubmitddtran:
	endif
	db.Grossamt=tmp3
	Call Dxget ("DiscountAmt",tmp$)
	let tmp3=tmp$
	if fra(tmp3*100)<>0
		returnstatus = 0                         
		Message$=mESSAGE$+" Invalid Disc Amt Submitted "
		goto endsubmitddtran:
	endif
	if tmp3<0 and transtype<>3 ! negative amount and it's not a manual check
		let returnstatus=0
		message$="Invalid Transaction Amount Submitted"
		goto endsubmitddtran:
	endif
	db.Discamt=tmp3
	if transtype=2
		let db.discamt=-db.discamt
		let db.grossamt=-db.grossamt
	endif
	let db.netamt=db.grossamt-db.discamt
	if db.discamt<>0
		if db.netamt>=db.grossamt
			let returnstatus=0
			message$="Invalid Discount Amount Submitted"
			goto endsubmitddtran:
		endif
	endif
	Call Dxget("TRANDATE",tmpDate$) !                                   
	Call VerifyDate(tmpDate$,tmp$,errflag,1) ! returns in yyyymmdd         
	db.trandate = tmp$[3,8] ! yymmdd                                          
	If errflag <> 0                                                        
		ReturnStatus = 0                                                     
		Message$ = "Invalid Transaction Date Submitted "                                             
	End If                                                                 
	
	Call Dxget("DESCRIPTION",tmp$)
	let db.desc$=rtrim$(tmp$)+blank$
	if c0[6]<>0
		Call Dxget("Division",tmp$)
		db.Div=tmp$
	endif
	If Transtype = 3                     
		Call Dxget("CheckNumber",tmp$)     
		db.CheckNum = tmp$              
		Call Dxget("CheckDate",tmp$)       
		xdate$ = formatdate2$(tmp$)        
		db.CheckDate = xdate$[3,8]         
		Call Dxget("BankNumber",tmp$)      
		db.BankNum = tmp$               
	End If                               
	Write Record #ch_db,rec_db;db.;
	! update the batch           
        Let message$="Transaction Submitted" 
	endsubmitddtran: !
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)	! let send over the data
else
    include "src/callsuberr.inc"
end try
end sub ! submitddtrans

!=====================================================================================
!=========================================================================================================
Sub Start525Report()! startReport
 Try
	ReturnStatus=1
	Message$="OK"
	Keyapc$ = " 0"
	Search #ch_apc,2,1;Keyapc$,Rec_apc,E
	if e>0
		let returstatus=0
		message$=message$+"RECORD '0' NOT FOUND IN A00AP"
		goto end525report:
	endif
	! open printer
	try Close #0 Else Rem
	onchannelno=0 ! zero for channel 
	printchan = openprinter(e$,onchannelno) 
	Call Dxget ("ACCTPER",tmp$) ! MM/YY
	if rtrim$(tmp$)=""
		let returnstatus=0
		message$="Invalid Accounting Period" 
		goto end525report:
	endif
	if tmp$[3,3]<>"/"
		let returnstatus=0
		message$="Invalid Accounting Period Format Submitted"
		goto end525report:
	endif
	let period$=tmp$[4,5],tmp$[1,2]
	let acctper=period$
	Call GetAcctPer()
	if acctper=currper
		let spec1[5]=0
	else
		if acctper=nxtper
			spec1[5]=1 
		else
			let returnstatus=0
			message$="Accounting Period Must Be Current or Next Month"
			goto end525report:
		endif
	endif
	Call Dxget("POSTDAY",tmp$)	
	let tmp3=tmp$
	if tmp3=0 or tmp3>31
		let returnstatus=0
		message$="Invalid Posting Day Submitted"
		goto end525report:
	endif
	let tmp$=tmp3 using "&&"
	let xdate$=period$,tmp$[1,2]
	!xdate$ = formatdate2$(tmp$)
	POSTDATE =  xdate$! [3,8] 
	tmpdate$=xdate$[3,4],"/",xdate$[5,6],"/20",xdate$[1,2] ! tmpdate$="mm/dd/yyyy"
	Call VerifyDate(tmpDate$,tmp$,errflag,1) ! returns in yyyymmd
	if errflag<>0
		let returnstatus=0
		let message$="Invalid Posting Day Submitted "
		goto end525report:
	endif
	LET TMP3=XDATE$[1,4]
	IF TMP3<>ACCTPER
		let returnstatus=0
		message$="Posting Date Must Match Accounting Period Selected"
		goto end525report:	
	endif
	
	
	Call dxget("PRPRT",tmp$)     
	audonly = 0 ! \ If tmp$ <> "" Let audonly = 1
	If UCASE$(RTRIM$(tmp$))="Y" Let audonly = 1
	! set up parameters for call
	clear spec1[]
	spec1[0]=intco ! company #
	spec1[1]=0 ! not used
	spec1[2]=Audonly
	spec1[3]=0 ! not used
	spec1[4]=Acctper
	spec1[5]=0 ! current or next month
	if nxtper=acctper let spec1[5]=1 ! flag as next month
	spec1[6]=postdate ! yymmdd format
	spec1[8]=rec_uac
	spec1[9]=returnstatus
	Call "la525.dl4",SPEC1[],MESSAGE$,rstr$
	LET returnstatus=spec1[9]
	end525report: ! 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! Start525Report

!--------------------------------------------------------------------
Sub StartChkRec()! send droplist and flags for check reconciliation
 Try
	ReturnStatus=1
	Message$="OK"
	! filedroplistapcash
	Clear list$[]
	Call filedroplistapcash(e$,List$[],maxcnt,ch_cash)  
	Call AddToStr(e$,rstr$,List$[])
	! get control flags
	Call GetClient()
	Clear List$[]
	List$[0]=bsdel$,"APControl",fdel$
	Webstr$=""
	webstr$="ClientId",fdel$
	webstr$=webstr$,"ClientName",fdel$
	List$[1]=webstr$
	webstr$=str$(clientid),fdel$
	webstr$=webstr$,rtrim$(clientname$),fdel$
	List$[2]=webstr$
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! check and set in process status
	Keyapc$ = " 0"                                              
	Search #ch_apc,2,1;Keyapc$,Rec_apc,e                        
	If e > 0                                                    
		returstatus = 0                                           
		Message$ = Message$ + "RECORD '0' NOT FOUND IN A00AP"     
		Goto endstartchkrec:                                        
	endif
	Mat Read #ch_apc,Rec_apc,2;apR$;
	If apR$[51,51] = " "                                                    
		ReturnStatus = 0                                                      
		Message$ =  "CHECK REGISTER IS IN PROCESS ELSEWHERE. PLEASE TRY AGAIN LATER." 
		goto endstartchkrec:
	Endif
	Keyapc$ = "20"                                              
	Search #ch_apc,2,1;Keyapc$,Rec_apc,e                        
	If e > 0                                                    
		returnstatus = 0                                           
		Message$ =  "RECORD '20' NOT FOUND IN A00AP"     
		Goto endstartchkrec:                                        
	endif
	Mat Read #ch_apc,Rec_apc,10;apR$;                     
	IF apR$[3,3]<>"0"  
		returnstatus = 0                                           
		Message$ =  "CHECK REGISTER MUST BE ACCEPTED"  
		Goto endstartchkrec:      
	endif                                  
	dim 1%,chkrecflag
	read #ctlc,51,4;chkrecflag;
	if chkrecflag>1
		returnstatus = 0                                           
		Message$ =  "Check Reconciliation in Process Elsewhere"  
		Goto endstartchkrec:
	else
		let chkrecflag=4
		write #ctlc,51,4;chkrecflag;
	endif
	endstartchkrec: ! 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! StartCheckRec

!--------------------------------------------------------------------
Sub ExitChkRec()! send droplist and flags for check reconciliation
 Try
	ReturnStatus=1
	Message$="OK"
	
	              
	dim 1%,chkrecflag
	read #ctlc,51,4;chkrecflag;
	if chkrecflag=4
		let chkrecflag=0
		write #ctlc,51,4;chkrecflag;    
	endif
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! ExitCheckRec
!--------------------------------------------------------------------
Sub getchkrectrans() ! get list of checks for reconciliation 561
Try
	dim 3%,tottrans,totamt,totrec,totopen,rec_cr
	dim keycr$[50],keycash$[30],3%,rec_cash
	Call Dxget("BANKID",tmp$)
	bankid=tmp$
	if bankid<=0 or bankid>99
		let message$="Invalid Bank Id Submitted "
		returnstatus=0
		goto endgetchkrectrans:	
	endif 
	let keycash$=" ",keycash$
	let keycash$[1,2]=bankid using "##"
	search #ch_cash,2,1;keycash$,rec_cash,e
	if e<>0
		let message$="Bank "+str$(bankid)+" Not On File "
		returnstatus=0
		goto endgetchkrectrans:
	endif
	read record #ch_cash,rec_cash;apcash.;
	endgetchkrectrans: ! 
	clear list$[]
	list$[0]=bsdel$,"CheckRecList",fdel$
	webstr$=""
	webstr$=webstr$,"TransId",fdel$
	webstr$=webstr$,"TransType",fdel$
	webstr$=webstr$,"TransDate",fdel$
	webstr$=webstr$,"VendorID",fdel$
	webstr$=webstr$,"Name/Desc",fdel$
	webstr$=webstr$,"Amount",fdel$
	Webstr$=webstr$,"Reconciled",fdel$
	webstr$=webstr$,"Tie",fdel$
	list$[1]=webstr$
	let row=2
	let tmpcnt=maxcnt
	if returnstatus=1
		let keycr$=" ",keycr$
		let keycr$[1,2]=bankid using "##"
		do
			search #ch_cr,3,1;keycr$,rec_cr,e
			if e>0 exit do
			let tmp3=keycr$[1,2]
			if tmp3<>bankid exit do
			read record #ch_cr,rec_cr;cr.;
			if cr.currid<>0 and p61$[136,136]="Y"
				if cr.currfact<>0				
					let cnvcu[0]=1
					let cnvcu[1]=1
					let cnvca[0]=cr.tranamt
					let cnvca[1]=cr.currfact
					! let CNVCU[1]=1 ! no rounding
					call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
					let cr.tranamt=fns(cnvca[0]) ! fnr(cnvca[0])
				endif
			endif
			tottrans=totTrans+1
			totamt=totamt+cr.Tranamt
			If cr.statflag<>0
				totrec=totrec+cr.tranamt
			else
				totopen=totopen+cr.tranamt
			endif
			webstr$=(cr.tranid using "########"),fdel$ ! transid
			webstr$=webstr$,"Check",fdel$ ! for future use
			xdate$=""
			If cr.TranDate <> 0                    
				XDATE$ = cr.trandate Using "&&&&&&" 
				Call JulianToDate(1,XDATE$,XDATE$,errflag)
			End If                                
			WebStr$ = WebStr$,RTrim$(XDATE$),fdel$
			Webstr$ = Webstr$,(cr.Vend using "######"),fdel$
			webstr$ = Webstr$,rtrim$(cr.Name$),fdel$
			webstr$=webstr$,(cr.TranAmt using "-----------.##"),fdel$
			let tmp$="N"
			if cr.StatFlag<>0 let tmp$="Y"
			webstr$=webstr$,tmp$,fdel$
			Webstr$=webstr$,(cr.tie using "##"),fdel$	
			list$[row]=webstr$
			row=row+1                                       
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
			if tottrans>4999 exit do
		Loop                                                      
	End If                                                      
	List$[row] = esdel$                                         
	Call AddToStr(e$,rstr$,List$[]) 
	clear list$[]
	list$[0]=bsdel$,"CheckRecTotal",fdel$
	webstr$=""
	webstr$=webstr$,"TotalTrans",fdel$
	webstr$=webstr$,"TotalAmt",fdel$
	webstr$=webstr$,"TotalOpenAmt",fdel$
	webstr$=webstr$,"TotalRecAmt",fdel$
	list$[1]=webstr$
	row=2
	if returnstatus=1
		webstr$=(tottrans using "----------#"),fdel$
		webstr$=webstr$,(totamt using "-----------.##"),fdel$
		webstr$=webstr$,(totopen using "-----------.##"),fdel$
		webstr$=webstr$,(totrec using "-----------.##"),fdel$
		list$[row]=webstr$
		row=row+1
	endif
	List$[row] = esdel$                                         
	Call AddToStr(e$,rstr$,List$[])
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
  end try
end sub ! getchkrectrans
!--------------------------------------------------------------------
Sub submitchkrectrans() ! check reconciliation #561
Try
	dim 3%,rec_cr
	dim keycr$[50]
	Call Dxget("BANKID",tmp$)
	bankid=tmp$
	if bankid<=0 or bankid>99
		let message$="Invalid Bank Id Submitted "
		returnstatus=0
		goto endsubchkrectrans:	
	endif 
	Call Dxget("TOTREC",tmp$)                                         
	totrec = tmp$                                                     
	If totrec <0                                       
		message$ = "Invalid Number of Records for Submission"
		returnstatus = 0                                                
	        Goto EndSubChkrecTrans:                                     
	EndIf 
	If totrec =0                                       
		message$ = "No Additional Checks were submitted to be Reconciled or Unreconciled"
		returnstatus = 0                                                
	    Goto EndSubChkrecTrans:                                     
	EndIf 
	eflag=0
	message$=""
	For ctr = 1 To totrec    
		cr.bank=bankid
		Call Dxget("TRANSID" + Str$(ctr),tmp$) 
		Cr.Tranid=TMp$
		Call Dxget("TIE" + Str$(ctr),tmp$)
		let Cr.tie=tmp$
		let keycr$=" ",keycr$
		let keycr$[1,2]=cr.bank using "##"
		let keycr$[3,8]=cr.tranid using "######"
		let keycr$[9,10]=cr.tie using "##"
		search #ch_cr,2,1;keycr$,rec_cr,e
		if e<>0
			let eflag=eflag+1
			let message$=message$+" Error TransId "+str$(cr.tranid)+" "
		else
			read record #ch_cr,rec_cr;cr.;
			Call Dxget("RECONCILE" + Str$(ctr),tmp$)
			let cr.StatFlag=0
			if ucase$(rtrim$(tmp$))="Y" let cr.StatFlag=1
			write record #ch_cr,rec_cr;cr.;
		endif
		let Cr.tie=tmp$
	next ctr
	if eflag<>0
		let returnstatus=0 ! to give a message
	endif
	endsubchkrectrans: ! 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
  end try
end sub ! submitchkrectrans
!--------------------------------------------------------------------
Sub getvoidcheck() ! 
Try
	dim 1%,currrow,currcnt
	dim 3%,totgramt,totdiscamt,totchkamt,rec_cr,rec_vc,checkid,rec_apdl
	dim keyvc$[50],keycr$[50],keyapdl$[50]
	dim keycash$[30],3%,rec_cash
	Dim currlist$[500,500],3%,originalamount,discounttaken,netamount,rec_capdt,keycapdt$[30],3%,tmpcurrfact
	dim capdt. as apdett !  ap detail tag file
	currrow=0
	currcnt=500
	Clear currlist$[]

	RETURNSTATUS=1
	MESSAGE$="OK"
	Call Dxget("BANKID",tmp$)
	bankid=tmp$
	if bankid<=0 or bankid>99
		let message$="Invalid Bank Id Submitted "
		returnstatus=0
		goto endgetvoidcheck:	
	endif
	let keycash$=" ",keycash$
	let keycash$[1,2]=bankid using "##"
	search #ch_cash,2,1;keycash$,rec_cash,e
	if e<>0
		let message$="Bank "+str$(bankid)+" Not On File "
		returnstatus=0
		goto endgetvoidcheck:
	endif
	read record #ch_cash,rec_cash;apcash.;!
	Call Dxget("CHECKID",tmp$)
	checkid=tmp$
	if checkid<=0 or checkid>999999
		let message$="Invalid Check Id Submitted "
		returnstatus=0
		goto endgetvoidcheck:	
	endif
	let keyvc$=" ",keyvc$
	let keyvc$[1,2]=bankid using "##"
	let keyvc$[3,8]=checkid using "######"
	search #ch_vc,2,1;keyvc$,rec_vc,e
	if not(e)	
		read record #ch_vc,rec_vc;vc.;
		mode$ = "d" ! delete transaction                                                                   
		UpdStatus = fileupdateapa10vc(e$,ch_vc,mode$,rec_vc,vc.)
	endif
	Call Dxget("TIE",tmp$)
	tieflag=tmp$
	let keycr$[1,2]=bankid using "##"
	let keycr$[3,8]=checkid using "######"
	if tieflag>0 
		let keycr$[9,10]=tieflag using "##"
	endif
	search #ch_cr,3,1;keycr$,rec_cr,e
	if e<>0
		let message$="Check Number "+str$(checkid)+" For Bank "+str$(bankid)+" Not on File "
		returnstatus=0
		goto endgetvoidcheck:
	endif
	let tmp3=keycr$[1,2]
	if tmp3<>bankid
		let message$="Check Number "+str$(checkid)+" For Bank "+str$(bankid)+" Not on File "
		returnstatus=0
		goto endgetvoidcheck:
	endif	
	let tmp3=keycr$[3,8]
	if tmp3<>checkid
		let message$="Check Number "+str$(checkid)+" For Bank "+str$(bankid)+" Not on File "
		returnstatus=0
		goto endgetvoidcheck:
	endif
	FindChkInHist: ! 
	errflag=0
	if not(tieflag) let multichk=0
	read record #ch_cr,rec_cr;cr.;
	let keyapdh$=" ",keyapdh$
	let keyapdh$[1,6]=cr.vend using "######"
	let keyapdh$[7,12]=cr.tranid using "######"
	let keyapdh$[20,20]="9"
	clear apdt.
	IF P61$[136,136]="Y" and apcash.currid<>0
		search #ch_apdt,2,1;keyapdh$,rec_apdt,e
		if not(e)
			read record #ch_apdt,rec_apdt;apdt.;
		endif
	endif
	search #ch_apdh,2,1;keyapdh$,rec_apdh,e
	if e<>0
		if not(multichk)and not(tieflag)
			errflag=0
			search #ch_cr,3,1;keycr$,rec_cr,e
			if e=2
				let errflag=99
			else
				let tmp3=keycr$[1,2]
				if tmp3<>bankid
					let errflag=99
				else
					tmp3=keycr$[3,8]
					if tmp3<>checkid
						let errflag=99
					endif
				endif
			endif
			if not(errflag)
				read record #ch_cr,rec_cr;cr.;
				let keyapdh$=" ",keyapdh$
				let keyapdh$[1,6]=cr.vend using "######"
				let keyapdh$[7,12]=cr.tranid using "######"
				let keyapdh$[20,20]="9"
				search #ch_apdh,2,1;keyapdh$,rec_apdh,e
				if e<>0 let errflag=99
				if p61$[136,136]="Y" and apcash.currid<>0
					search #ch_apdt,2,1;keyapdt$,rec_apdt,e
					if e<>0
						clear apdt.
					else
						read record #ch_apdt,rec_apdt;apdt.;
					endif
				endif
			endif
		endif
		if errflag<>0
			let message$="Check Number "+str$(checkid)+" For Bank "+str$(bankid)+" Not in A/P History File "
			returnstatus=0
			goto endgetvoidcheck:	
		endif
	endif
	let tieflag=keycr$[9,10]
	read record #ch_apdh,rec_apdh;apdh.;
	! verify if another check exists
	let multichk=0
	search #ch_cr,3,1;keycr$,rec_cr,e
	if e<>0 goto endgetvoidcheck:
	let tmp3=keycr$[1,2]
	if tmp3<>bankid goto endgetvoidcheck:
	let tmp3=keycr$[3,8]
	if tmp3<>checkid goto endgetvoidcheck:
	let multichk=99		
	endgetvoidcheck: ! end the looking up void check
	Clear currlist$[]
	Let tmpcurrfact=apdt.currfact
	OriginalAmount=0
	Discounttaken=0
	Currrow=0
	If p61$[136,136]="Y" and apcash.currid<>0 and apdt.currfact<>0 and returnstatus=1
		clear currlist$[]
		currlist$[0]=bsdel$,"CheckTranList",fdel$
		webstr$=""
		webstr$=webstr$,"Transaction",fdel$
		webstr$=webstr$,"Type",fdel$
		webstr$=webstr$,"GrossAmt",fdel$
		webstr$=webstr$,"DiscAmt",fdel$
		webstr$=webstr$,"NetAmt",fdel$
		currlist$[1]=webstr$
		currrow=2
		let keyapdl$=" ",keyapdl$
		let keyapdl$[1,6]=rec_apdh using "######"
		do
			search  #ch_apdl,3,1;keyapdl$,rec_apdl,e
			if e<>0 exit do
			let tmp3=keyapdl$[1,6]\if tmp3<>rec_apdh exit do
			read record #ch_apdl,rec_apdl;apdl.;
			if apdl.appliedtotype>0 and apdl.appliedtotype<4
				let keycapdt$=" ",keycapdt$
				let keycapdt$[1,6]=apdl.VendorCode using "######"
				let keycapdt$[7,18]= apdl.AppliedToInvoice$[1,12]
				let keycapdt$[19,20]=apdl.Appliedtotype using "##"
				search #ch_apdt,2,1;keycapdt$,rec_capdt,e
				if not(e)
					Read record #ch_apdt,rec_capdt;capdt.;
					If not (capdt.currfact) let capdt.currfact=apdt.currfact
				Else
					clear capdt.
					Let capdt.currfact=apdt.currfact					
				endif
				webstr$=rtrim$(apdl.AppliedToInvoice$),fdel$
				let tmp$=""
				if apdl.appliedtotype=1 let tmp$="INV"
				if apdl.appliedtotype=2 let tmp$="C/M"
				if apdl.appliedtotype=3 let tmp$="M/C"
				webstr$=webstr$,tmp$,fdel$
				if capdt.currfact<>0
					let cnvcu[0]=1
					let cnvcu[1]=1
					let cnvca[0]= apdl.amount
					let cnvca[1]=capdt.currfact
					call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$ ! bring up to bank currency based on open item
					let apdl.amount =fnr(cnvca[0])
					let cnvcu[0]=1
					let cnvcu[1]=1
					let cnvca[0]= apdl.discount
					let cnvca[1]=capdt.currfact
					call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$ ! bring up to bank currency based on open item
					let apdl.discount=fnr(cnvca[0])
				endif
				webstr$=webstr$,(apdl.amount using "-----------.##"),fdel$
				webstr$=webstr$,(apdl.discount using "-----------.##"),fdel$
				webstr$=webstr$,((apdl.amount-apdl.discount) using "-----------.##"),fdel$
				currlist$[currrow]=webstr$
				currrow=currrow+1                                       
				If currrow > currcnt Let currcnt = expandarray(e$,currList$[]) 
				OriginalAmount=OriginalAmount+apdl.amount
				Discounttaken=Discounttaken+apdl.discount	
			endif
		loop
		apdh.OriginalAmount=OriginalAmount
		apdh.discounttaken=DiscountTaken
	endif
	currList$[currrow] = esdel$                                         
	clear list$[]
	list$[0]=bsdel$,"VoidCheck",fdel$
	webstr$=""
	webstr$=webstr$,"CheckId",fdel$
	webstr$=webstr$,"CheckDate",fdel$
	webstr$=webstr$,"VendorID",fdel$
	webstr$=webstr$,"Name",fdel$
	webstr$=webstr$,"GrossAmount",fdel$
	Webstr$=webstr$,"DiscountAmount",fdel$
	webstr$=webstr$,"CheckAmount",fdel$
	webstr$=webstr$,"TIE",fdel$
	webstr$=webstr$,"More",fdel$
	list$[1]=webstr$
	let row=2	
	if returnstatus=1
		webstr$=""
		webstr$=(checkid using "########"),fdel$ ! transid
		xdate$=""
		If cr.TranDate <> 0                    
			XDATE$ = cr.trandate Using "&&&&&&" 
			Call JulianToDate(1,XDATE$,XDATE$,errflag)
		End If                                
		WebStr$ = WebStr$,RTrim$(XDATE$),fdel$
		Webstr$ = Webstr$,(cr.Vend using "######"),fdel$
		webstr$ = Webstr$,rtrim$(cr.Name$),fdel$
		let amount=apdh.OriginalAmount
		webstr$ = Webstr$,(apdh.OriginalAmount using "-----------.##"),fdel$ ! apdh.OriginalAmount
		let amount=apdh.discounttaken
		webstr$ = Webstr$,(apdh.discounttaken using "-----------.##"),fdel$ ! apdh.discounttaken
		let amount=cr.TranAmt
		if p61$[136,136]="Y" and APCASH.CURRID<>0 and apdt.currfact<>0
			let cnvcu[0]=1
			let cnvcu[1]=1
			let cnvca[0]=amount
			let cnvca[1]=apdt.currfact
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$ ! bring up to bank currency based on open item
			let amount=FNS(cnvca[0])
		endif
		webstr$=webstr$,(amount using "-----------.##"),fdel$  ! cr.TranAmt
		webstr$=webstr$,str$(tieflag),fdel$
		let tmp$="N" 
		if multichk<>0 let tmp$="Y"
		webstr$=webstr$,tmp$,fdel$
		LIST$[ROW]=WEBSTR$
		LET ROW=ROW+1
	End If                                                      
	List$[row] = esdel$                                         
	Call AddToStr(e$,rstr$,List$[]) 
	IF P61$[136,136]="Y" and currrow<>0
		Call AddToStr(e$,rstr$,currList$[])
		goto endvctranlist:
	endif
	clear list$[]
	list$[0]=bsdel$,"CheckTranList",fdel$
	webstr$=""
	webstr$=webstr$,"Transaction",fdel$
	webstr$=webstr$,"Type",fdel$
	webstr$=webstr$,"GrossAmt",fdel$
	webstr$=webstr$,"DiscAmt",fdel$
	webstr$=webstr$,"NetAmt",fdel$
	list$[1]=webstr$
	row=2
	let tmpcnt=maxcnt
	if returnstatus=1
		let keyapdl$=" ",keyapdl$
		let keyapdl$[1,6]=rec_apdh using "######"
		do
			search  #ch_apdl,3,1;keyapdl$,rec_apdl,e
			if e<>0 exit do
			let tmp3=keyapdl$[1,6]\if tmp3<>rec_apdh exit do
			read record #ch_apdl,rec_apdl;apdl.;
			if apdl.appliedtotype>0 and apdl.appliedtotype<4
				webstr$=rtrim$(apdl.AppliedToInvoice$),fdel$
				let tmp$=""
				if apdl.appliedtotype=1 let tmp$="INV"
				if apdl.appliedtotype=2 let tmp$="C/M"
				if apdl.appliedtotype=3 let tmp$="M/C"
				webstr$=webstr$,tmp$,fdel$
				webstr$=webstr$,(apdl.amount using "-----------.##"),fdel$
				webstr$=webstr$,(apdl.discount using "-----------.##"),fdel$
				webstr$=webstr$,((apdl.amount-apdl.discount) using "-----------.##"),fdel$
				list$[row]=webstr$
				row=row+1                                       
				If row > tmpcnt Let tmpcnt = expandarray(e$,List$[]) 
			endif
		loop
	endif
	List$[row] = esdel$                                         
	Call AddToStr(e$,rstr$,List$[])
	endvctranlist: ! 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
  end try
end sub ! getvoidcheck
!--------------------------------------------------------------------
!--------------------------------------------------------------------
Sub submitvoidcheck() ! 
Try
	dim 3%,totgramt,totdiscamt,totchkamt,rec_cr,rec_vc,checkid,rec_apdl
	dim keyvc$[50],keycr$[50],keyapdl$[50]
	RETURNSTATUS=1
	MESSAGE$="OK"
	Call Dxget("BANKID",tmp$)
	bankid=tmp$
	if bankid<=0 or bankid>99
		let message$="Invalid Bank Id Submitted "
		returnstatus=0
		goto endsubmitvoidcheck:	
	endif
	Call Dxget("CHECKID",tmp$)
	checkid=tmp$
	if checkid<=0 or checkid>999999
		let message$="Invalid Check Id Submitted "
		returnstatus=0
		goto endsubmitvoidcheck:	
	endif
	let keyvc$=" ",keyvc$
	let keyvc$[1,2]=bankid using "##"
	let keyvc$[3,8]=checkid using "######"
	
	search #ch_vc,2,1;keyvc$,rec_vc,e
	if not(e)
		read record #ch_vc,rec_vc;vc.;
		mode$ = "d" ! delete transaction                                                                   
		UpdStatus = fileupdateapa10vc(e$,ch_vc,mode$,rec_vc,vc.)
	endif
	
	call dxget ("DELETEFLAG",tmp$)
	if ucase$(rtrim$(tmp$))="Y" ! DELETE RECORD
		let message$="Check "+str$(checkid)+" No Longer Voided "
		goto endsubmitvoidcheck:
	endif
	clear vc.
	vc.chknum=checkid
	vc.bank=bankid
	Call Dxget("VENDORID",tmp$)
	vc.vend=tmp$
	if vc.vend<=0 or vc.vend>999999
		let message$="Invalid Vendor Id Submitted "
		returnstatus=0
		goto endsubmitvoidcheck:	
	endif
	let keyapdh$=" ",keyapdh$
	let keyapdh$[1,6]=vc.vend using "######"
	let keyapdh$[7,12]=vc.chknum using "######"
	let keyapdh$[20,20]="9"
	search #ch_apdh,2,1;keyapdh$,rec_apdh,e
	if e<>0
		let message$="Check Number "+str$(checkid)+" For Bank "+str$(bankid)+" Not in A/P History File "
		returnstatus=0
		goto endsubmitvoidcheck:	
	endif
	read record #ch_apdh,rec_apdh;apdh.;
	Call Dxget("CHECKDATE",tmp$)                
	If RTrim$(tmp$) = ""                          
		ReturnStatus = 0                            
		Message$ = "Invalid Check Date Submitted"     
		Goto endsubmitvoidcheck:                           
	End If                                        
	XDATE$ = formatdate2$(tmp$)                   
	tmp3 = XDATE$[3,8] ! yymmdd format            
	If Not(tmp3)                                  
		 ReturnStatus = 0                            
		 Message$ = "Invalid Due Date Submitted"     
		 Goto endsubmitvoidcheck:                         
	End If 
	let vc.chkdate=tmp3
	Call DXGET("NAME",tmp$)
	let vc.name$=rtrim$(tmp$)+blank$
	let vc.tie=0
	let vc.grossamt=apdh.OriginalAmount
	let vc.discamt=apdh.discounttaken
	let vc.chkamt=apdh.OriginalAmount-apdh.discounttaken
	mode$ = "a" ! delete transaction                                                                   
	UpdStatus = fileupdateapa10vc(e$,ch_vc,mode$,rec_vc,vc.)
	endsubmitvoidcheck: ! 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
  end try
end sub ! submitvoidcheck
!--------------------------------------------------------------------
!=========================================================================================================
Sub getclosecntrl() ! get cntrl # for 543
Try
	dim 3%,lastrec
	let multicntrl=-1
	if not(c0[4]) 
		returnstatus=0
		message$="A/P - P/O Interface is not available "
		goto endgetappoclsd:
	endif
	Mat Read #ctlc,51,88;poglflag;
	if poglflag<>0
		Returnstatus=0
		message$="Close Control Option is Not Available with PO-GL Interface"
		goto endgetappoclsd:
	endif
	message$=""
	returnstatus=1 ! set to ok
	Call Dxget("WHID",tmp$)
	tmp3=tmp$
	if tmp3<=0 or tmp3>99
		returnstatus=0
		message$="Invalid Warehouse Submitted "
		goto endgetappoclsd:
	endif
	let whse=tmp3
	Call Dxget("CNTRLID",tmp$)
	let CNTRLID=tmp$
	if CNTRLID<=0 or CNTRLID>999999
		let message$="Invalid Control Number Submitted"
		returnstatus=0
		goto endgetappoclsd:
	endif
	Call Dxget("POID",tmp$)
	let poid=tmp$
	if poid<0 or poid>999999
		let message$="Invalid Purchase Order Number Submitted"
		returnstatus=0
		goto endgetappoclsd:
	endif
	let multicntrl=-1
	let keypoc$=" ",keypoc$
	let keypoc$[1,6]=cntrlid using "######"
	let keypoc$[7,8]=whse using "##"
	if poid>0
		let keypoc$[9,14]=poid using "######"
	endif
	do
		search #ch_poc,3,2;keypoc$,rec_poc,e
		if e> 0 exit do
		let tmp3=keypoc$[1,6]
		if tmp3<>cntrlid exit do
		let tmp3=keypoc$[7,8]
		if whse<>tmp3 exit do
		if poid>0
			let tmp3=keypoc$[9,14]
			if poid<>tmp3 exit do
		endif
		let multicntrl=multicntrl+1
		let lastrec=rec_poc
	loop
	if multicntrl<0
		let returnstatus=0
		let message$="Control Number Is Not On File"
		returnstatus=0
		goto endgetappoclsd:
	endif
	if not(lastrec)
		let returnstatus=0
		let message$="Control Number Is Not On File"
		returnstatus=0
		goto endgetappoclsd:
	endif
	endgetappoclsd: !  end get appoline
	if not(returnstatus) let multicntrl=-1
	! SECTION 0
	Clear List$[]                                                         
	List$[0] = bsdel$ + "PoCntrlClose" + fdel$ ! section name
	webstr$="Grid",fdel$
	List$[1]=webstr$
	let tmp$="N"
	if multicntrl>0 let tmp$="Y"
	webstr$=tmp$,fdel$
	list$[2]=webstr$
	list$[3]=esdel$
	call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string

	if multicntrl<=0 ! not a grid
		! SECTION 1 - NO GRID
		Clear List$[]                                                         
		List$[0] = bsdel$ + "POCntrlInfo" + fdel$ ! section name
		webstr$=""
		webstr$="WHID",fdel$ 
		webstr$=webstr$,"CntrlID",fdel$
		webstr$=webstr$,"POID",fdel$
		webstr$=webstr$,"VendId",fdel$
		webstr$=webstr$,"VendName",fdel$
		WebStr$=webstr$,"LineId",fdel$
		WebStr$=WebStr$,"ProdID",fdel$
		Webstr$=webstr$,"Desc1",fdel$
		webstr$=webstr$,"Desc2",fdel$
		webstr$=webstr$,"VendProdId",fdel$
		webstr$=webstr$,"LastRcvdDate",fdel$
		Webstr$=Webstr$,"CostUm",fdel$
		Webstr$=Webstr$,"QtyUm",fdel$
		WebStr$=WebStr$,"POQty",fdel$
		Webstr$=Webstr$,"POUnitCost",fdel$
		webstr$=webstr$,"POExtCost",fdel$
		WebStr$=WebStr$,"PrevQty",fdel$
		webstr$=webstr$,"PrevExtCost",fdel$
		webstr$=webstr$,"Close",fdel$
		Webstr$=webstr$,"Message",fdel$
		webstr$=webstr$,"DebitFlag",fdel$
		let list$[1]=webstr$
		row=2
		if returnstatus<>0 ! no errors send over the data
			let rec_poc=lastrec
			read record #ch_poc,rec_poc;poc.;                
 			let keypol$=" ",keypol$
			let keypol$[1,6]=poc.poid using "######"
			let keypol$[7,9]=poc.LineNum using "###"
			let keypol$[10]=""
			rec_pol = filegetpoline(e$,ch_pol,"=",1,keypol$,pol.)
			if rec_pol<=0 
				let message$="PO Line Not on File "
				let returnstatus=0
				goto endgetappoclsd1:
			endif
		
			X2 = POL.flags ! ! REM UNPACK pol.Flags TO FLAGS[x]
			For K = 0 To 11                                    
				flags[K] = Sgn(Fra(X2 / 2)) \ X2 = Int(X2 / 2)   
			Next K                                             
			NonStk = flags[0]                                  
			Closedshort = flags[1]                             
			Zline = flags[2]                                    
			IF zline<>0
				let message$="PO Line is a Message"
				let returnstatus=0
				goto endgetappoclsd1:
			endif
			let vendid=poc.vendid
			call verifyvendor()
			! Find product/nonstock
			If Not(NonStk) ! it's a prod
				rec_prod=pol.ProdDescRec
				Read record #ch_prod,rec_prod,0;PR.;
			else		
				Read Record #ch_nstk,pol.ProdDescRec;nstk.;
			endif
			Call SetPRtoPol() !!! 
			LET QTYUMid=pol.QtyUm                       
			IF poc.CWFlag LET QTYUMid=-3  ! catch weight item qty in lbs
			COSTUMID=pol.CostUm
			!------quantity conversions-----------
			! poqty, prevqty                          
			if not (poc.CWFlag)    ! not catchweight by lb item
				let poqty=0
				LET CNVTA=poc.PoQtyRcvd
				if cnvta<>0
					LET CNVTU[0]=0 \ LET CNVTU[1]=qtyumid \ LET CNVTU[2]=1
					amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
					let poqty=amount ! po qty received
				endif
				let prevqty=0                    
				let cnvta=poc.ApQtyRcvd+(poc.ApQtyAppl)
				if cnvta<>0
					 LET CNVTU[0]=0 \ LET CNVTU[1]=qtyumid \ LET CNVTU[2]=1
					 amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
					 let prevqty=amount ! previous ap qty applied 
				endif
				let currqty=0                            
				     
			else  
				! catchweight by lbs --- qty is in lbs
				let poqty=PoQtyRcvd                                                        
				let prevqty=poc.ApQtyRcvd+(poc.ApQtyAppl)                                          
				                                                        
			endif
			!------cost conversions-------
			! pocost, currcost --- no prevcost is retained  ! mtg cost from base to costing um
			let pocost=0
			LET CNVTA=poc.PoCost 
			if cnvta<>0
				lET CNVTU[0]=0 \ LET CNVTU[1]=costumid \ LET CNVTU[2]=2                                      
				amount = ConvProdAmount(e$,CNVTU[],CNVTA,ctlc,FLAG,PR.)
				let pocost=amount
				if p61$[136,136]="Y" and poc.currfact<>0 and amount<>0 and oi.currfact<>0 ! going for base to costing um
					let cnvcu[0]=1
					let cnvca[0]=amount
					let cnvca[1]=poc.currfact
					let CNVCU[1]=1 ! no rounding
					call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
					let pocost=cnvca[0]
				endif
			End If                              
			currcost=0		                            
			!------extended amount conversions-------
			let poextcost=0;currextcost=0;prevextcost=0
			if not(poc.CWFlag)
				lineqty=poc.PoQtyRcvd !pol.qtyship
				lineum=costumid
				linecost=poc.PoCost !pol.unitcost
				lineextamt=0
				lbsunit=poc.LbsUnit
				lbsfact=poc.lbsfact
				prodfact=PR.LbsFact;prodlbs=PR.LbsUnit ! save product weight factors
				let currfact=poc.currfact
				let PR.LbsFact=poc.LbsFact;PR.LbsUnit=poc.LbsUnit
				call calcextamt(lineqty,lineum,linecost,lineextamt,lbsunit,lbsfact,currfact)
				let PR.LbsFact=prodfact;PR.LbsUnit=prodlbs
				let poextcost=lineextamt
				
			else
				! lb for lb 
				poextcost=fnr(poc.PoQtyRcvd*poc.PoCost)
				amount=poextcost
				if p61$[136,136]="Y" and poc.currfact<>0 and amount<>0  and oi.currfact<>0! going for base to costing um
					poextcost=(poc.PoQtyRcvd*poc.PoCost)
					amount=poextcost
					let cnvcu[0]=1
					let cnvca[0]=amount
					let cnvca[1]=poc.currfact
					let CNVCU[1]=1 ! no rounding
					call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
					let poextcost=fnr(cnvca[0])
				endif
			endif
			let prevextcost=poc.ApAmtRcvd
            amount=prevextcost
			if p61$[136,136]="Y" and poc.currfact<>0 and amount<>0 and oi.currfact<>0 ! going for base to costing um
					let cnvcu[0]=1
					let cnvca[0]=amount
					let cnvca[1]=poc.currfact
					let CNVCU[1]=1 
					call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
					let prevextcost=fnr(cnvca[0])
			endif
			QTYUM$=xunit$(QTYUMID,ch_ccode) ! u/m
			COSTUM$=xunit$(COSTUMID,ch_ccode) 
			webstr$=(poc.whse using "##"),fdel$
			webstr$=webstr$,(poc.CntrlNum using "######"),fdel$ ! cntrl #
			WebStr$=webstr$,(poc.poid),fdel$
			webstr$=webstr$,(poc.vendid),fdel$
			webstr$=webstr$,rtrim$(vend.name$),fdel$
			WebStr$=webstr$,(poc.LineNum),fdel$
			WebStr$=webstr$,pol.prodcode$,fdel$ ! prodid
			Webstr$=webstr$,RTrim$(pol.desc1$),fdel$  ! desc1
			WebStr$=WebStr$,RTrim$(pol.desc2$),fdel$  ! desc 2
			webstr$=webstr$,rtrim$(pol.VendProdCode$),fdel$
			if poc.RcvdDate<>0
				let xdate$=pdate$(poc.RcvdDate)
			else
				let xdate$=""
			endif
			webstr$=webstr$,xdate$,fdel$ !"LastRcvdDat
			x3=umtofactor(costumid) ! get um for factor
			Webstr$=Webstr$,rtrim$(CostUm$),fdel$
			X3 = UMtoFactor(qtyumid) ! get qty um factor
			Webstr$=Webstr$,rtrim$(QtyUm$),fdel$
			WebStr$=WebStr$,(POQty Using QMask$),fdel$
			Webstr$=Webstr$,(POCost  Using PMask$),fdel$
			webstr$=webstr$,(POExtCost   using "----------.##"),fdel$
			WebStr$=WebStr$,(PrevQty Using QMask$) ,fdel$	
			webstr$=webstr$,(PrevExtCost using "----------.##"),fdel$			
			let tmp$="N" 
			IF poc.apclose<>0 let tmp$="Y"
			webstr$=webstr$,tmp$,fdel$ ! close
			tmp$=""
			IF poc.apclose=87 OR poc.apclose=88 OR poc.apclose=89 
				returnstatus=0	
				IF POC.APCLOSE=89                                               
					 tmp$="Control # has been Unreceived. May Not Close."
					 message$=tmp$
				ELSE                                                        
					tmp$="Control # is in Unreceive Process. May Not Close. "
					message$=tmp$
				ENDIF 
			else
				if poc.apqtyappl<>0
					Tmp$="A/P in process for this control number. May Not Close. "  
					message$=tmp$
					let returnstatus=0
				endif
				IF pol.status <>3 TMP$="Line is not closed for receipts. " 
				IF pol.TotApExtCost=0 TMP$=TMP$+"A/P has not been applied."         
				IF poc.apclose<>0
					tmp$=tmp$+"A.P. control number already closed. "
				endif
			endif
			webstr$=webstr$,tmp$,fdel$ ! message
			Mat Read #ctlc,51,88;poglflag; 
			if poglflag<>0 	
				IF POC.APCLOSE=99 
					 returnstatus=0
					 tmp$="Control # has already been closed and accepted. May Not Close."
					 message$=tmp$
				endif                                                       
				! check if exists in close file
				! if exist check if acct period matches
				 Call Dxget("ACCTPER",tmp$) ! MM/YY                            
				 If RTrim$(tmp$) = ""                                          
					ReturnStatus = 0                                            
					Message$ = "Invalid Accounting Period"                      
                                           
				 End If                                                        
				If tmp$[3,3] <> "/"                                           
					ReturnStatus =0
					Message$="Invalid Accounting Period Format Submitted" 	
				End If                                                        
				period$ = tmp$[4,5],tmp$[1,2]                                 
				acctper = period$                                             
			endif
			let tmp$="N"
			if poc.DMFlag<>0 let tmp$="Y"
			webstr$=webstr$,tmp$,fdel$
			list$[row]=webstr$
			row=row+1
			If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
		endif ! RETURNSTATUS
		endgetappoclsd1: !
		let list$[row]=esdel$
		call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string
	else
		Clear List$[]                                                         
		List$[0] = bsdel$ + "POCntrlList" + fdel$ ! section name
		webstr$=""
		webstr$="WHID",fdel$ 
		webstr$=webstr$,"CntrlID",fdel$
		webstr$=webstr$,"POID",fdel$
		webstr$=webstr$,"VendId",fdel$
		webstr$=webstr$,"VendName",fdel$
		WebStr$=webstr$,"LineId",fdel$
		WebStr$=WebStr$,"ProdID",fdel$
		Webstr$=webstr$,"Desc",fdel$
		webstr$=webstr$,"LastRcvdDate",fdel$
		webstr$=webstr$,"POExtCost",fdel$
		webstr$=webstr$,"Close",fdel$
		let list$[1]=webstr$
		row=2
		if returnstatus<>0 ! no errors send over the data      
			let keypoc$=" ",keypoc$
			let keypoc$[1,6]=cntrlid using "######"
			let keypoc$[7,8]=whse using "##"
			if poid>0
				let keypoc$[9,14]=poid using "######"
			endif
			do
				search #ch_poc,3,2;keypoc$,rec_poc,e
				if e> 0 exit do
				let tmp3=keypoc$[1,6]
				if tmp3<>cntrlid exit do
				let tmp3=keypoc$[7,8]
				if whse<>tmp3 exit do
				if poid>0
					let tmp3=keypoc$[9,14]
					if poid<>tmp3 exit do
				endif
				read record #ch_poc,rec_poc;poc.; 
				                
 				let keypol$=" ",keypol$
				let keypol$[1,6]=poc.poid using "######"
				let keypol$[7,9]=poc.LineNum using "###"
				let keypol$[10]=""
				rec_pol = filegetpoline(e$,ch_pol,"=",1,keypol$,pol.)
				if rec_pol<=0 
					let message$="PO Line Not on File "
					let returnstatus=0
					goto endgetappoclsd2:
				endif
		
				X2 = POL.flags ! ! REM UNPACK pol.Flags TO FLAGS[x]
				For K = 0 To 11                                    
					flags[K] = Sgn(Fra(X2 / 2)) \ X2 = Int(X2 / 2)   
				Next K                                             
				NonStk = flags[0]                                  
				Closedshort = flags[1]                             
				Zline = flags[2]                                    
				let vendid=poc.vendid
				call verifyvendor()
				! Find product/nonstock
				If Not(NonStk) ! it's a prod
					rec_prod=pol.ProdDescRec
					Read record #ch_prod,rec_prod,0;PR.;
				else		
					Read Record #ch_nstk,pol.ProdDescRec;nstk.;
				endif
				Call SetPRtoPol() !!! 
				COSTUMID=pol.CostUm
				!------extended amount conversions-------
				let poextcost=0;currextcost=0;prevextcost=0
				if not(poc.CWFlag)
					lineqty=poc.PoQtyRcvd !pol.qtyship
					lineum=costumid
					linecost=poc.PoCost !pol.unitcost
					lineextamt=0
					lbsunit=poc.LbsUnit
					lbsfact=poc.lbsfact
					prodfact=PR.LbsFact;prodlbs=PR.LbsUnit ! save product weight factors
					let currfact=poc.currfact
					let PR.LbsFact=poc.LbsFact;PR.LbsUnit=poc.LbsUnit
					call calcextamt(lineqty,lineum,linecost,lineextamt,lbsunit,lbsfact,currfact)
					let PR.LbsFact=prodfact;PR.LbsUnit=prodlbs
					let poextcost=lineextamt
				
				else
					! lb for lb 
					poextcost=fnr(poc.PoQtyRcvd*poc.PoCost)
					let amount=poextcost
					if p61$[136,136]="Y" and poc.currfact<>0 and amount<>0 and oi.currfact<>0
						poextcost=(poc.PoQtyRcvd*poc.PoCost)
						let amount=poextcost
						let cnvcu[0]=1
						let cnvca[0]=amount
						let cnvca[1]=oi.currfact
						let CNVCU[1]=1
						call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
						poextcost=fnr(cnvca[0])
					endif
				endif
				webstr$=(poc.whse using "##"),fdel$
				webstr$=webstr$,(poc.CntrlNum using "######"),fdel$ ! cntrl #
				WebStr$=webstr$,(poc.poid),fdel$
				webstr$=webstr$,(poc.vendid),fdel$
				webstr$=webstr$,rtrim$(vend.name$),fdel$
				WebStr$=webstr$,(poc.LineNum),fdel$
				WebStr$=webstr$,poC.prodid$,fdel$ ! prodid
				webstr$=webstr$,rtrim$(pol.desc1$),fdel$! desc
				if poc.RcvdDate<>0
					let xdate$=pdate$(poc.RcvdDate)
				else
					let xdate$=""
				endif
				webstr$=webstr$,xdate$,fdel$ !"LastRcvdDat
				webstr$=webstr$,(POExtCost   using "----------.##"),fdel$			
				let tmp$="N" 
				IF poc.apclose<>0 let tmp$="Y"
				webstr$=webstr$,tmp$,fdel$ ! close
			
				list$[row]=webstr$
				row=row+1
				If row > tmpcnt Let tmpcnt = expandarray(e$,List$[])
				endgetappoclsd2: ! 
			loop
		endif
		list$[row]=esdel$
		call AddToStr(e$,rstr$,List$[]) ! "add the list from subs to string

	endif! SECTION 1 - NO GRID! grid = Y
	
	! status section
	If returnstatus=1 let message$="OK"
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
  end try
end sub ! getclosecntrl
!=========================================================================================================
!--------------------------------------------------------------------
Sub StartCloseCntrl()! send droplist - 543
 Try
	ReturnStatus=1
	Message$="OK"
	Call GetAcctPer()
	clear list$[]
	List$[0]=bsdel$,"AccountPeriod",fdel$
	WebStr$="Name",fdel$,"Period",fdel$
	list$[1]=webstr$
	Webstr$="Current Month",fdel$,currper$[1,5],fdel$
	list$[2]=webstr$
	Webstr$="Next Month",fdel$,nxtper$[1,5],fdel$
	list$[3]=webstr$
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section
	! warehouse list
	clear whlist$[]
	 Call FileDropListWhinfoz(e$,whList$[],100,ch_wh)   
	Call AddToStr(e$,rstr$,whList$[])                  
	! get control flags
	Call GetClient()
	Clear List$[]
	List$[0]=bsdel$,"APControl",fdel$
	Webstr$=""
	webstr$="ClientId",fdel$
	webstr$=webstr$,"ClientName",fdel$
	webstr$=webstr$,"APPOFlag",fdel$
	webstr$=webstr$,"POGLFlag",fdel$
	List$[1]=webstr$
	webstr$=str$(clientid),fdel$
	webstr$=webstr$,rtrim$(clientname$),fdel$
	let tmp$="N"
	if c0[4]<>0 AND spo<>0 let tmp$="Y"
	webstr$=webstr$,tmp$,fdel$ ! APPOFLAG
	let tmp$="N"
	 Mat Read #ctlc,51,88;poglflag;                                     
	If c0[4] <> 0 And spo <> 0 And poglflag <> 0 And p9$[17,17] = "Y"
		let tmp$="Y"
	endif
	webstr$=webstr$,tmp$,fdel$
	List$[2]=webstr$
	LIST$[3]=esdel$
	call AddToStr(e$,rstr$,List$[])
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! StartClsCntrl
!=========================================================================================================
Sub submitclosecntrl() ! get cntrl # for 543
Try
	dim 3%,lineid
	if not(c0[4]) 
		returnstatus=0
		message$="A/P - P/O Interface is not available "
		goto endsubmitclscntrl:
	endif
	Mat Read #ctlc,51,88;poglflag;
	if poglflag<>0
		Returnstatus=0
		message$="Close Control Option is Not Available with PO-GL Interface"
		goto endsubmitclscntrl:
	endif
	message$=""
	returnstatus=1 ! set to ok
	Call Dxget("WHID",tmp$)
	tmp3=tmp$
	if tmp3<=0 or tmp3>99
		returnstatus=0
		message$="Invalid Warehouse Submitted "
		goto endsubmitclscntrl:
	endif
	let whse=tmp3
	Call Dxget("CNTRLID",tmp$)
	let CNTRLID=tmp$
	if CNTRLID<=0 or CNTRLID>999999
		let message$="Invalid Control Number Submitted"
		returnstatus=0
		goto endsubmitclscntrl:
	endif
	Call Dxget("POID",tmp$)
	let poid=tmp$
	if poid<=0 or poid>999999
		let message$="Invalid Purchase Order Number Submitted"
		returnstatus=0
		goto endsubmitclscntrl:
	endif
	Call Dxget("LineID",tmp$)
	let lineid=tmp$
	if lineid<0 or lineid>999
		let message$="Invalid Line Number Submitted"
		returnstatus=0
		goto endsubmitclscntrl:
	endif
	let keypoc$=" ",keypoc$
	let keypoc$[1,6]=cntrlid using "######"
	let keypoc$[7,8]=whse using "##"
	let keypoc$[9,14]=poid using "######"
	let keypoc$[15,18]=lineid using "####"
	search #ch_poc,2,2;keypoc$,rec_poc,e
	if e<>0
		let message$="Control Number Not on File"
		returnstatus=0
		goto endsubmitclscntrl:	
	endif	
	read record #ch_poc,rec_poc;poc.;
	Mat Read #ctlc,51,88;poglflag;
	if poglflag<>0
		Call Dxget("ACCTPER",tmp$) ! MM/YY                            
		If RTrim$(tmp$) = ""                                          
			ReturnStatus = 0                                            
			Message$ = "Invalid Accounting Period"  
			goto endsubmitclscntrl:                   
		End If                                                        
		If tmp$[3,3] <> "/"                                           
			ReturnStatus =0
			Message$="Invalid Accounting Period Format Submitted"
			goto endsubmitclscntrl:
		End If                                                        
		period$ = tmp$[4,5],tmp$[1,2]                                 
		acctper = period$ 
	endif
	Call Dxget("CLOSE",tmp$) ! Y or N
	let tmp3=0 ! no
	if ucase$(rtrim$(tmp$))="Y"
		if poglflag<>0 let tmp3=97 else let tmp3=99
	endif
	if poc.apclose=tmp3 goto endsubmitclscntrl: ! no change
	IF poc.apclose=87 OR poc.apclose=88 OR poc.apclose=89 
		returnstatus=0	
		IF POC.APCLOSE=89                                               
			 message$="Control # has been Unreceived. May Not Close or Re-Open."
		ELSE                                                        
			message$="Control # is in Unreceive Process. May Not Close or Re-Open. "
		endif
		goto endsubmitclscntrl:
	ENDIF 
	if poc.apqtyappl<>0 and tmp3<>0
		message$="A/P in process for this control number. May Not Close. "  
		let returnstatus=0
		goto endsubmitclscntrl:
	endif
	if poglflag<>0 	
		IF POC.APCLOSE=99 
			 returnstatus=0
			 message$="Control # has already been closed and accepted. May Not Close."
			 goto endsubmitclscntrl:
		endif 
	endif
	let poc.apclose=tmp3
	write record #ch_poc,rec_poc,0;poc.;
	endsubmitclscntrl: !
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutput(e$,rstr$)
else
    include "src/callsuberr.inc"
  end try
end sub ! submitclosecntrl
!==========================================================
!--------------------------------------------------------------------
Sub StartPerEnd()! 540 End of Month/End of Year
 Try
	DIM 2%,lasteopdate,3%
	ReturnStatus=1
	Message$="OK"
	Call GetAcctPer()
	! get control flags
	Call GetClient()
	Clear List$[]
	List$[0]=bsdel$,"APEndPer",fdel$
	Webstr$=""
	webstr$="ClientId",fdel$
	webstr$=webstr$,"ClientName",fdel$
	Webstr$=Webstr$,"AcctPer",fdel$
	webstr$=webstr$,"DefaultEOPopt",fdel$
	List$[1]=webstr$
	webstr$=str$(clientid),fdel$
	webstr$=webstr$,rtrim$(clientname$),fdel$
	webstr$=webstr$,currper$[1,5],fdel$
	let tmp$="1" ! end of month
	Mat Read #ctlc,51,86;APFORCE540;
	let acctper=currper$[1,2]
	warneoy=0
	if apforce540>0 and apforce540<13
		if apforce540=acctper
			let tmp$="2"  ! end of year
		endif
	else
		Tmp$="0"
		Keyapc$ = "10"                                                
		Search #ch_apc,2,1;Keyapc$,Rec_apc,e            
		If Not(e)                                       
			Mat Read #ch_apc,Rec_apc,2;R2$;                                              
			Keyacf$ = " ",Keyacf$ \ Keyacf$[3,6] = R2$    
			Search #ch_acf,2,1;Keyacf$,Rec_acf,e          
			If Not(e)                                     
				Mat Read #ch_acf,Rec_acf,10;g9$;    
			End If                                        
		End If  
		fye=g9$[118,119]
		if fye=12 
			if acctper=12
				let tmp$="3" ! end of year
			else
				let tmp$="1" ! end of month
			endif
		else
			if acctper=12
				let tmp$="0"
				warneoy=99
			else
				if fye=acctper
					let tmp$="0"
					warneoy=99
				endif
			endif
		endif
	endif
	! 
	webstr$=webstr$,tmp$,fdel$ ! default end of month or end of year close
	List$[2]=webstr$
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! warning section
	Clear List$[]
	List$[0]=bsdel$,"APEndPerWarn",fdel$
	Webstr$=""
	webstr$="LastEoP",fdel$
	webstr$=webstr$,"LastEoPMsg",fdel$
	Webstr$=Webstr$,"EndYear",fdel$
	webstr$=webstr$,"EndYearMsg",fdel$
	List$[1]=webstr$
	tmp$="N"
	Mat Read #ctlc,51,68;lasteopdate;
	if lasteopdate<>0
		let xdate$=lasteopdate using "&&&&&&"
		Call DateToJulian(5,XDATE$,XDATE$,errflag) 
		if not(errFlag)
			let jtmpdate=xdate$
			TMP3=tim(6)-jtmpdate
			if tmp3<20
				let tmp$="Y"
			endif
		endif
	endif
	webstr$=tmp$,fdel$
	if tmp$="N"
		let tmp$=""
	else
		Tmp$="Warning: End of Period Was Just Performed Within the Past Few Days "
	endif
	webstr$=webstr$,rtrim$(tmp$),fdel$ ! 
	let tmp$="N" ! verify Year Close
	webstr$=webstr$,tmp$,fdel$
	if warneoy=0
		let tmp$=""
	else
		let tmp$="Please Verify End of Year/End of Month Selection"
	endif
	webstr$=webstr$,Rtrim$(tmp$),fdel$
	List$[2]=webstr$
	call AddToStr(e$,rstr$,List$[])
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	! print section
	clear list$[]
	list$[0]=bsdel$,"Printers",fdel$
	List$[1]="Name",fdel$,"Id",fdel$,"Default",fdel$
	call AddToStr(e$,rstr$,List$[])
	pdfoption=1
	xmloption=0 ! BROWSER
	! set pdf option to 0
        Call blockPrintersDropList(rstr$,xmloption,pdfoption)
	Call AddToStr(e$,rstr$,esdel$) ! end of section 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! StartPerEnd ! StartReport
!=========================================================================================================
Sub Start540Report()! End of Month/Year
 Try
	ReturnStatus=1
	Message$="OK"
	
	! open printer
	try Close #0 Else Rem
	onchannelno=0 ! zero for channel 
	printchan = openprinter(e$,onchannelno) 
	
	Call Dxget ("ACCTPER",tmp$) ! MM/YY
	if rtrim$(tmp$)=""
		let returnstatus=0
		message$="Invalid Accounting Period" 
		goto end540report:
	endif
	if tmp$[3,3]<>"/"
		let returnstatus=0
		message$="Invalid Accounting Period Format Submitted"
		goto end540report:
	endif
	let period$=tmp$[4,5],tmp$[1,2]
	let acctper=period$
	
	Call Dxget ("EOPOPT",tmp$) ! 
	let tmp3=tmp$
	if tmp3<=0 or tmp3>2
		let returnstatus=0
		let message$="Invalid End of Period Selection Submitted"
		goto end540report:
	endif
	
	Call dxget("PRPRT",tmp$) ! (NOT ADDED?)     
	audonly = 0 ! \ If tmp$ <> "" Let audonly = 1
	If UCASE$(RTRIM$(tmp$))="Y" Let audonly = 1
	! set up parameters for call
	clear spec1[]
	spec1[0]=intco ! company #
	spec1[1]=tmp3 ! 1= PAGEBREAK
	spec1[2]=Audonly
	spec1[4]=Acctper
	spec1[8]=rec_uac
	spec1[9]=returnstatus
	message$=""
	Call "la540.dl4",SPEC1[],MESSAGE$,rstr$
	LET returnstatus=spec1[9]
	!if returnstatus=1 ! no errors
	!	if not(audonly) ! no audonly
	Call dxget("S_USER.AppID",tmp$) !company #               
                                                         
	Try Let intCo = Val(tmp$) Else Let intCo = 1 !company #  
	ctlc = OpenFile(9999,intCo) \ If ctlc = -1 Error 42
	Read #ctlc,0,134;apdate; !current ap date yymmdd format                   
	tmp$ = apdate Using "&&&&&&" \ tmp1$ = tmp$[3,4],"/",tmp$[1,2] !mm/yy
	Call dxget("u_apdate",tmp$)
	if rtrim$(tmp$)<>rtrim$(tmp1$) 
			Call dxset("u_apdate",tmp1$)                                              
			yy = tmp1$[4,5] \ mm = tmp1$[1,2] \ mm = mm + 1 
			If mm > 12
				Let mm = 1 \ yy = yy + 1
			endif                                                                       
			tmp1$ = mm Using "&&","/",yy Using "&&"                                   
			Call dxset("u_nextapdate",tmp1$)
	endif
	!	endif
	!endif
	end540report: ! 
	if message$="" let message$="Process Complete"
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! Start540Report
!=========================================================================================================
Sub GetAPDiv()! Get Ap Division for division maintenance 509
 Try
	ReturnStatus=1
	Message$="OK"                                                            
        dim 3%,rec_apdiv,keyapdiv$[30]                            
        dim 3%,divid                                                                             
        Call Dxget("DIVID",tmp$)                                  
        let divid=tmp$                                            
        if divid<=0 or divid>99                                   
               let returnstatus=0                                
               let message$="Invalid Division Code ",str$(divid) 
	       goto endgetapdiv: 
        endif 
        let keyapdiv$=" ",keyapdiv$                                             
        let keyapdiv$[1,2]=divid using "##"                                     
        search #ch_apdiv,2,1;keyapdiv$,rec_apdiv,e                              
        if e<>0                                                                 
                let returnstatus=0                                              
                let message$="Division Code ",str$(divid)," Not on File "       
                goto endgetapdiv:                                               
        endif                                                                   
        read record #ch_apdiv,rec_apdiv,0;apdiv.;                               
        endgetapdiv: ! end of apdiv                                             
        Clear List$[]                                                           
        List$[0]=bsdel$,"APDivInfo",fdel$                                       
        WebStr$="DIVID",fdel$,"DIVDESC",fdel$                                   
        webstr$=webstr$,"APGLACCTID",FDEL$,"APGLDESC",FDEL$                             
        webstr$=webstr$,"CMGLACCTID",FDEL$,"CMGLDESC",FDEL$                             
        webstr$=webstr$,"DISCGLACCTID",FDEL$,"DISCGLACCTDESC",FDEL$                     
        List$[1]=WebStr$
	row=2
        if returnstatus<>0                                                      
                Webstr$=str$(divid),fdel$                                       
                WebStr$ = WebStr$ + RTrim$(apdiv.divname$),fdel$                
                ! ap account                                                    
                let dfltacctid=apdiv.apacct$                                    
                webstr$=webstr$+str$(dfltacctid),fdel$
                keyvl$=" ",keyvl$                                       
                keyvl$[2,9]=dfltacctid using "########"                 
                search #ch_vl,2,1;keyvl$,rec_vl,e                       
                if not(e)                                               
                        read record #ch_vl,rec_vl;apvl.;                
                else                                                    
                                apvl.desc$="Not on File!!!"             
                endif                                                   
                webstr$=webstr$,rtrim$(apvl.desc$),fdel$ ! account name 
                ! credit memo account                                   
                let dfltacctid=apdiv.cmacct$                            
                webstr$=webstr$+str$(dfltacctid),fdel$                  
                keyvl$=" ",keyvl$                                       
                keyvl$[2,9]=dfltacctid using "########"                 
                search #ch_vl,2,1;keyvl$,rec_vl,e                       
                if not(e)                                               
                        read record #ch_vl,rec_vl;apvl.;                
                else                                                    
                         apvl.desc$="Not on File!!!"                    
                endif                                                   
                webstr$=webstr$,rtrim$(apvl.desc$),fdel$ ! account name 
                ! discount account                                      
                let dfltacctid=apdiv.discacct$                                 
                webstr$=webstr$+str$(dfltacctid),fdel$                         
                keyvl$=" ",keyvl$                                              
                keyvl$[2,9]=dfltacctid using "########"                        
                search #ch_vl,2,1;keyvl$,rec_vl,e                              
                if not(e)                                                      
                        read record #ch_vl,rec_vl;apvl.;                       
                else                                                           
                         apvl.desc$="Not on File!!!"                           
                endif                                                          
                webstr$=webstr$,rtrim$(apvl.desc$),fdel$ ! account name        
                let list$[2]=webstr$
		row=3
        endif  
	list$[row]=esdel$
        call AddToStr(e$,rstr$,List$[])                                        
                       
                                                                               
        call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)                 
        call AddToStr(e$,rstr$,WebStr$)                                        
        call SetOutPut(e$,rstr$)                                               
else                                                                           
    include "src/callsuberr.inc"                                               
end try                                                                        
end sub ! getapdiv   


!=========================================================================================================
Sub SubmitAPDiv()! Get Ap Division for division maintenance 509
 Try
	ReturnStatus=1
	Message$="OK"                                                            
        dim 3%,rec_apdiv,keyapdiv$[30]                            
        dim 3%,divid 
	call dxget ("NEWRECORD",tmp$)
	let newrecord=0
	if ucase$(rtrim$(tmp$))="Y" let newrecord=99
	Call Dxget("DIVID",tmp$)                                  
        let divid=tmp$                                            
        if divid<=0 or divid>99                                   
               let returnstatus=0                                
               let message$="Invalid Division Code ",str$(divid) 
	       goto endsubmitapdiv: 
        endif 
        let keyapdiv$=" ",keyapdiv$                                             
        let keyapdiv$[1,2]=divid using "##"                                     
        search #ch_apdiv,2,1;keyapdiv$,rec_apdiv,e                                                                                    		
	if e>1
		let returnstatus=0
		let Message$="Error in obtaining Division Information From File"
		goto endsubmitapdiv:
	endif
	if e=1
		if newrecord=0 ! not new record -- not on file                                                               
			let returnstatus=0                                              
			let message$="Division Code ",str$(divid)," Not on File "       
			goto endsubmitapdiv:                                               
		endif                 
		if newrecord=99	  ! new record
			call dxget ("DELETEFLAG",tmp$)
			if ucase$(rtrim$(tmp$))="Y" ! DELETE RECORD
				let message$="AP Division "+str$(divid)+" Not Added to File "
				goto endsubmitapdiv
			endif
		endif
		clear apdiv.
		let apdiv.divid=divid
		let apdiv.apspare1$=blank$
		let apdiv.apspare2$=blank$
		let apdiv.cmspare1$=blank$
		let apdiv.cmspare2$=blank$
		let apdiv.discspare1$=blank$
		let apdiv.discspare2$=blank$
	endif
	
	if e=0 ! record exists
 		if newrecord=99	 ! ad
			let returnstatus=0
			Message$="AP Division "+str$(divid)+" Already on File "
			goto endsubmitapdiv:
		endif
		read record #ch_apdiv,rec_apdiv,0;apdiv.; 
		call dxget ("DELETEFLAG",tmp$)
		if ucase$(rtrim$(tmp$))="Y" ! DELETE RECORD
			if newrecord=99
				let message$="Division "+str$(divid)+" Not Added to File "
				goto endsubmitapdiv:
			endif
			
			search #ch_apdiv,5,1;keyapdiv$,rec_apdiv,e
			if e<>0
				returnstatus=0
				Message$="Error Deleting Key for Division"+str$(divid)
				goto endsubmitapdiv:	
			endif
			let e=3\search #ch_apdiv,1,0;keyapdiv$,rec_apdiv,e
			if e<>0
				returnstatus=0
				Message$="Search Error "+str$(e)+" Deleting Record for Division "+str$(divid)
				goto endsubmitapdiv:
			endif
			Message$="Division"+str$(divid)+" Deleted "
			goto endsubmitapdiv:
		endif ! delete section
	endif ! record exist
	Call Dxget("DIVDESC",tmp$)
	let apdiv.divname$=ucase$(rtrim$(tmp$))+blank$
	Call Dxget("APGLACCTID",tmp$) 
	let dfltacctid=tmp$                            
        keyvl$=" ",keyvl$                                       
        keyvl$[2,9]=dfltacctid using "########"                 
        search #ch_vl,2,1;keyvl$,rec_vl,e                       
        if e<>0
		let returnstatus=0
		let message$="AP GL Account Number "+str$(dfltacctid)+" Not on File. "
		goto endsubmitapdiv:
	endif
	let apdiv.APAcct$=dfltacctid using "########" 

	Call Dxget("CMGLACCTID",tmp$) 
	let dfltacctid=tmp$                            
        keyvl$=" ",keyvl$                                       
        keyvl$[2,9]=dfltacctid using "########"                 
        search #ch_vl,2,1;keyvl$,rec_vl,e                       
        if e<>0
		let returnstatus=0
		let message$="CM GL Account Number "+str$(dfltacctid)+" Not on File. "
		goto endsubmitapdiv:
	endif
	let apdiv.CmAcct$=dfltacctid using "########" 
       
	Call Dxget("DISCGLACCTID",tmp$) 
	let dfltacctid=tmp$                            
        keyvl$=" ",keyvl$                                       
        keyvl$[2,9]=dfltacctid using "########"                 
        search #ch_vl,2,1;keyvl$,rec_vl,e                       
        if e<>0
		let returnstatus=0
		let message$="Discount GL Account Number "+str$(dfltacctid)+" Not on File. "
		goto endsubmitapdiv:
	endif
	let apdiv.DiscAcct$=dfltacctid using "########" 
	
	IF NEWRECORD<>0
		LET E=2\SEARCH #CH_apdiv,1,0;KEYapdiv$,rec_apdiv,E
		if e<>0
			returnstatus=0
			Message$="Search Error "+str$(e)+" Adding Record for Division "+str$(divid)
			goto endsubmitapdiv:
		endif
		write record #ch_apdiv,rec_apdiv;apdiv.;
		search #ch_apdiv,4,1;keyapdiv$,rec_apdiv,e
		if e<>0
			returnstatus=0
			Message$="Error Adding Key for Division "+str$(divid)
			goto endsubmitapdiv:	
		endif
	Endif
	Write Record #ch_apdiv,rec_apdiv;apdiv.;
	
	endsubmitapdiv: ! end submiting 
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)                 
        call AddToStr(e$,rstr$,WebStr$)                                        
        call SetOutPut(e$,rstr$)                                               
else                                                                           
    include "src/callsuberr.inc"                                               
end try                                                                        
end sub ! submitapdiv   

!============================================================================================================
Sub VERIFYAPBATCH()! Verifyapbatch
Try
	dim uacname$[20]
	ch_uac=OpenFile(-9988, intCo)
	newbatch=0
	Call Dxget ("ACCTPER",tmp$) ! MM/YY
	if rtrim$(tmp$)=""
		let returnstatus=0
		message$="Invalid Accounting Period" 
		goto endverifybatch:
	endif
	if tmp$[3,3]<>"/"
		let returnstatus="Invalid Accounting Period Format Submitted"
		goto endverifybatch:
	endif
	let period$=tmp$[4,5],tmp$[1,2]
	let acctper=period$
	Call Dxget ("BATCHID",tmp$) ! 
	let batchid=tmp$
	if batchid=0 and rtrim$(tmp$)<>"0"
		let returnstatus=0
		let message$="Invalid Batch Id Submitted"
		goto endverifybatch:
	endif
	if batchid<1 or batchid>999999
		let returnstatus=0
		let message$="Invalid Batch Id Submitted"
		goto endverifybatch:
	endif
	if batchid<>0	
		let keybatch$=" ",keybatch$
		LET keybatch$[1,4]=acctper using "####"
		let keybatch$[5,10]=batchid using "######"
		search #ch_bth,2,1;keybatch$,rec_bth,e
		if e<>0 
			let returnstatus=0
			let message$="Batch Id "+str$(batchid)+" Not On File" 
			goto endverifybatch:
		endif
		Clear List$[]
		read record #ch_bth,rec_bth;apbth.;
		if apbth.status=0 and apbth.UARec<>rec_uac
			returnstatus=0   
			
			message$="Batch is in Process Elsewhere"
			if apbth.uarec<>0
				try
					read #ch_uac,apbth.uarec,280;UACNAME$;
					let message$=message$+" by "+rtrim$(uacname$)+". Please have this user reset batch."
				else
					rem
				end try
			endif
			goto endverifybatch:
		endif
		if apbth.status=2
			returnstatus=0
			message$="Data Entry List is in Process " 
			if apbth.uarec<>0 and apbth.UARec<>rec_uac
				try
					read #ch_uac,apbth.uarec,280;UACNAME$;
					let message$=message$+" by "+rtrim$(uacname$)+". Please have this user reset batch."
				else
					rem
				end try
			endif
			goto endverifybatch:
		endif                                                     
                if apbth.status=3
			let returnstatus=2
			message$="DATA ENTRY LIST HAS BEEN ACCEPTED!!!"
		endif
		if apbth.status=4
			returnstatus=0
			message$="PURCHASE JOURNAL IS IN PROCESS!!!"
			if apbth.uarec<>0
				try
					read #ch_uac,apbth.uarec,280;UACNAME$;
					let message$=message$+" by "+rtrim$(uacname$)+"Please have user complete purchase journal process."
				else
					rem
				end try
			endif
			goto endverifybatch:
		endif                                                         
		IF apbth.status=6
			message$="BATCH HAS ALREADY BEEN ACCEPTED!!!"
			returnstatus=0
			goto endverifybatch:
                endif                                                         
		IF apbth.status=9 
			let message$="BATCH HAS BEEN DELETED!!!"
			returnstatus=0
			goto endverifybatch:
		endif
	endif
	endverifybatch: ! end verify the batch
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)	
else
    include "src/callsuberr.inc"
end try
end sub ! VERIFYAPBATCH
!===========================================================
!============================================================================================================
Sub RELMANCHK()! Release Manual Checks Items for payments
Try
	let manchkflag=0
	Call dxget("MANCHKRELEASE",tmp$)
	if UCASE$(rtrim$(tmp$))="Y" let manchkflag=99
	if not (manchkflag)
		let returnstatus=0
		let message$="Manual Check Release Not Submitted "
	endif
	if manchkflag<>0
		let divflag=0;div[0]=0;div[1]=99 
		do                                                                              
			search #ch_oi,3,1;keyoi$,rec_oi,e                                       
			if e<>0 
				exit do
			endif	
			read record #ch_oi,rec_oi;oi.;                                               
			IF oi.StatusCode$<"1" GOTO nxtmanchkrel:
			if oi.statusCode$>"3" goto nxtmanchkrel:
			IF oi.DocumentCode$>"7" GOTO nxtmanchkrel: 
			if oi.DocumentCode$="3" and oi.statuscode$="1"	
				let oi.statuscode$="3"
				LET oi.paymentcurrentRun=oi.grossinvoiceamount-oi.paymentcurrentPeri-oi.paymentnextmo  
				write record #ch_oi,rec_oi;oi.;
				GOTO nxtmanchkrel:
			endif
			nxtmanchkrel: ! get next tran for release
		loop
	endif
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
else
    include "src/callsuberr.inc"
end try
end sub ! apinvrel


!=======================================================================================
Sub GETAPVENDPO()! find purc
Try
	Call Dxget("VENDID",tmp$)
	vendid=tmp$
	call verifyvendor()
	if not (returnstatus) goto endgetapvendpo:
	let foundvendpo=0
	Call Dxget("PONUMBER",tmp$)
	let poid=tmp$
	if poid<0 or poid>999999
		let message$="Invalid Purchase Order Number Submitted"
		returnstatus=0
		goto endgetapvendpo:
	endif
	oi.Terms=(vend.Terms*100) 
	foundpovend=0
	call findvendpo (vendid,poid,foundpovend)
	If foundpovend=0
		let returnstatus=0
		let Message$="Purchase Order Is Not On File "
		goto endgetapvendpo:
	endif
	! Foundvendpo: ! 
	Read Record #ch_poh,rec_poh;poh.;
	let oi.division=0
	if c0[6] <>0
		let oi.division=poh.warehouse
	endif  
	let currid=0
	IF P61$[136,136]="Y"
		Call Dxget("CURRID",tmp$)
		let  currid=tmp$
		! IF NOT(CURRID) and vend.currid=517 let currid=517
		if currid<>vend.currid
			let returnstatus=0
			let message$="Vendor is assigned to another currency. "
		endif
	endif
	let transtype=1
	if poh.status>10 and poh.status=2 let transtype=2
	if poh.status=97 let transtype=2
	let oi.grossinvoiceAmount=0
	let oi.discountableAmount=0
	IF P61$[136,136]="Y" and currid<>0 
		let amount = poh.TotPoRcvd
		if poh.currfact<>0 and amount<>0  ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=poh.currfact
			let CNVCU[1]=1
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let poh.TotPoRcvd=fnr(cnvca[0])
		endif
		let amount = POH.TotApMerchAppl
		if poh.currfact<>0 and amount<>0  ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=poh.currfact
			let CNVCU[1]=1
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let POH.TotApMerchAppl=fnr(cnvca[0])
		endif
		let amount = POH.TotPoFreightRec
		if poh.currfact<>0 and amount<>0  ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=poh.currfact
			let CNVCU[1]=1
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let POH.TotPoFreightRec=fnr(cnvca[0])
		endif
		!!!! stop here !!!!
		let amount = POH.TotFreightAppl
		if poh.currfact<>0 and amount<>0  ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=poh.currfact
			let CNVCU[1]=1
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let POH.TotFreightAppl=fnr(cnvca[0])
		endif
		let amount = POH.TotMiscCharges
		if poh.currfact<>0 and amount<>0  ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=poh.currfact
			let CNVCU[1]=1
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let POH.TotMiscCharges=fnr(cnvca[0])
		endif
		let amount = POH.TotMiscAppl
		if poh.currfact<>0 and amount<>0  ! going for base to costing um
			let cnvcu[0]=1
			let cnvca[0]=amount
			let cnvca[1]=poh.currfact
			let CNVCU[1]=1
			call "mxcurrconv.dl4",cnvcu[],cnvca[],e$,rstr$
			let POH.TotMiscAppl=fnr(cnvca[0])
		endif
	endif
	If foundpovend=99
		!let oi.grossinvoiceAmount=poh.TotPoRcvd+poh.TotPoFreightRec-poh.TotApAppl-poh.ApAmtPend
		let oi.grossinvoiceamount=0
		If (POH.TotPoRcvd-POH.TotApMerchAppl)>0
			let oi.grossinvoiceamount=oi.grossinvoiceamount+(POH.TotPoRcvd-POH.TotApMerchAppl)
		endif
		if (POH.TotPoFreightRec-POH.TotFreightAppl)>0
			let oi.grossinvoiceamount=oi.grossinvoiceamount+(POH.TotPoFreightRec-POH.TotFreightAppl)
		endif
		if (POH.TotMiscCharges-POH.TotMiscAppl)
			let oi.grossinvoiceamount=oi.grossinvoiceamount+(POH.TotMiscCharges-POH.TotMiscAppl)
		endif
		if oi.grossinvoiceAmount<0 let oi.grossinvoiceAmount=0
		if c0[5]<>0 
			let oi.discountableAmount=oi.grossinvoiceAmount
			if transtype=2 and c0[7]=0 let oi.discountableAmount=0
		endif
	endif
	let oi.discountamount=0
	if oi.discountableamount<>0 and oi.terms<>0
		let oi.discountamount=fnr((oi.discountableamount*(oi.terms/100))/100)
	endif
	endgetapvendpo: ! 
	clear list$[]
	list$[0]=bsdel$,"APVENDPO",fdel$
	webstr$=""
	webstr$="VendId",fdel$
	webstr$=webstr$,"PONUMBER",fdel$
	Webstr$=webstr$,"TranType",fdel$
	webstr$=webstr$,"GrossInvAmt",fdel$
	webstr$=webstr$,"DiscountableAmt",fdel$
	webstr$=webstr$,"Division",fdel$
	webstr$=webstr$,"Discount",fdel$
	list$[1]=webstr$
	row=2
	if returnstatus=1 ! no errors
		let webstr$=""
		webstr$=str$(vendid),fdel$
		Webstr$=webstr$,(poid using "######"),fdel$
		let tmp$="INV"
		if transtype=2 let tmp$="C/M"	
		WebStr$ = WebStr$,RTrim$(tmp$),fdel$
		webstr$=webstr$,(oi.GrossInvoiceAmount using "###########.##"),fdel$
		webstr$=webstr$,(oi.DiscountableAmount using "###########.##"),fdel$
		If c0[6] 
			webstr$=webstr$,(oi.Division using"##"),fdel$
		else
			webstr$=webstr$,"",fdel$
		endif
		webstr$=webstr$,(oi.DiscountAmount using "###########.##"),fdel$
		let list$[row]=webstr$
		row=row+1
	endif
	list$[row]=esdel$ ! end of section
	call AddToStr(e$,rstr$,List$[])
	
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)	! let send over the data

else
    include "src/callsuberr.inc"
end try
end sub ! getapvendpo






Sub GETPAYTOVEND()! find payto vendor info
Try
	dim keypayto$[20]
	dim payvend. as a80vm
	dim 3%,rec_payto
	let keypayto$=vend.paytovendorcode using "######"
	search #ch_vend,2,1;keypayto$,rec_payto,e
	if not(e)
			read record #ch_vend,rec_payto;payvend.;
			vend.PayToName$=payvend.PayToName$
			vend.PayToAddress$=payvend.PayToAddress$
			vend.PayToOptAddress$=payvend.PayToOptAddress$
			vend.paytocity$=payvend.paytocity$
			vend.paytostate$=payvend.paytostate$
			vend.paytozip$=payvend.paytozip$
	endif
else
    include "src/callsuberr.inc"
end try
end sub ! getpaytovend
