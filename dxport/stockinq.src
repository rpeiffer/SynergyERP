! --- stockinq.dl4 
! description 218 product inquiry called from prodm.dl4 & prodwh.dl4
!  also from serp218.dl4
!
! loadsave -w -n 100,10 -o prog/dxport/stockinq.dl4 src/stockinq.src
! 1.0 mm/dd/yyyy change??
!
!include copyright, common libs, common intrinsics
include "src/copyright.inc"
!
!
!
!include structure,filehandler libs & default structure dims
Include "src/ubsprod.inc"
Include "src/ubswhse.inc"
Include "src/ubspo.inc"
Include "src/ubsorder.inc"

!
!
! *declare additional dl4 intrinsic subs & functions
Declare Intrinsic Sub env
!
! *declare additional external libs & subs & functions
External Lib "ubsprconv.dl4"
Declare External Function XAmount, Xunit$
!
External Lib "libgeneral.lib"
Declare External Sub SubErr


!External Lib "sffiles.lib"
!Declare External Function getprod

External Lib "ubsfunc.dl4"
Declare External Function OpenFile,formatdate$

Declare sub OpenFiles,CalcTotals,GET_OT15TOT,Get_OT16RQ
Declare Sub GetProdLot,Section7, GETONPO,GetOrders
Declare External Function UMDropList$, GetUMFactor
Declare Function chk_prd_loc
!
! **main procedure
!
!
! dim variables used by program
!
dim e$[500],buttonlist$[5,50],nextlist$[5,100] !error handling variables
!
try

option string redim is legal

 dim action$[30],options$[30],userid$[8],b$[200],3%
 dim bsdel$[20],esdel$[20],rdel$[20],fdel$[20],rstr$[10000] ! .net delimiters
 dim s6$[1000],s7$[2000]


DEF FNR(X)=SGN(X)*(INT(ABS(X)*100+.5)*.01)

Dim WHK$[20],PRK$[20],CMK$[20],VNK$[20],PLK$[50]
Dim SLK$[60],PDK$[20],PHK$[20]
Dim OHK$[20],ODK$[20],k9$[60]

Dim PR. As Prod
Dim CM. As CommCode
Dim WH. As WHSE
Dim PL. As SPRODLOT
Dim PH. As POHDR
Dim PD. As PODet
Dim SL. As SORDLOT
Dim OH. As ORDH
Dim OD. As ORDD

Dim 1%,debugDetail,wh
! Variables for Channel#'s
Dim 2%,WHC,PRC,VNC,CMC,CTC,CCC,PLC,SLC,PHC,PDC,OHC,ODC
! Variables for Search Record#
Dim 3%,WHR,PRR,VNR,CMR,CTR,PLR,SLR,PHR,PDR,OHR,ODR
! Variables for Search Error
Dim 2%,WHE,PRE,VNE,CME,CTE,PLE,SLE,PHE,PDE,OHE,ODE

Dim Msg$[256],pgmName$[20]
Dim P9$[50],P60$[50],P61$[256],VEND$[30],CATD$[24],unt$[14]
Dim Temp$[100],Space$[100],SLS$[3],Sales$[30],CO$[2]
Dim QMASK$[20],PMASK$[20],EMASK$[20],DEC$[8],work$[50]
Dim WHSE$[2],SUPER$[12],VENDITEM$[20],POSTATUS$[100,20],ORDSTATUS$[100,20]
Dim NOF$[10],TName$[30]
DIM 1%,DEFAULTUM
Dim 1%,baseunit,stockunit,sellunit,purchunit,costunit,priceunit,whatunit
Dim 1%,nonstock,zline,FCHANS[9],whw0[3]
Dim 1%,ARMONTH,BOYMONTH,MTHDAYSi,MaxWhse,MaxVar,ARYear
Let MaxVar=20
Dim col$[maxvar,30]
Dim 2%,BDAYS[24],AR_DATE
Dim 2%,Q0[1],D9[5]
Dim 2%,ErrStat,X1,X2
Dim 3%,ARS[5],UnitsMTD,UnitsYTD,GPMTD,GPYTD
Dim 3%,pocost,netcost,cost,ontr,qbo
DIM 3%,WGTOH,WGTOR,totrecv,R[99]
Dim 3%,qty[maxvar],onpo,prec[1],OTYPTOT[2],powh[99]
dim defum$[4]
  Dim prod$[12],P1$[156],whse$[2],tmp$[1000]
  dim mergedir$[60],action1$[20],hold$[60]
  dim Company$[2],UserID$[8],tmp1$[100]


Space$=" ",Space$
ErrStat = 0
ii=0

 b$=" ",b$
 !
 ! Try call dxopen() else rem
 !
 call getsession(e$,CTLC,options$,action$,userid$,intCO,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$)
 !
 ! open files
 Call OpenFiles()
 !
	! Start Prog.
	Read #CTLC,19,50;P9$; 
	Read #CTLC,60,50;P60$; 
	Read #CTLC,61,0;P61$;
	Read #CTLC,0,120;ARMONTH; 
	Read #CTLC,0,108;AR_DATE;
	Mat Read #CTLC,51,74;BOYMONTH;
	Mat Read #CTLC,11,0;BDAYS;     
	Mat Read #CTLC,115;D9;  
	Mat Read #CTLC,115,40;Q0; 

	let MTHDAYS=BDAYS[ARMONTH]   
	If MTHDAYS<=0 LET MTHDAYS=21

	If not(Q0[1]) let Q0[1]=2                                                       
	Let Dec$="#",Dec$;Qmask$="----------#"                                         
	If Q0[0] Let Qmask$="----------#.",Dec$[1,Q0[0]]         !qty mask      
	If Q0[1] Let Pmask$="------------.",Dec$[1,Q0[1]]     !price mask        
	Let Emask$="-$$$$$$$$$$$$.##"                         !ext. price mask  
	Let NOF$="-NOF-"
	FCHANS[0]=PRC ! PROD CHAN
	FCHANS[5]=PDC ! PO LINE
 ! get product record
 Call DXGet("prodid",prod$)
 prod$ = UCase$(prod$)+"            "
 hold$=prod$
 Search #PRC,2,1;hold$,r,e                              
  If Trim$(prod$) <> Trim$(hold$) Let e = 2               
  If e = 0                                             
     Read Record #prc,r;pr.;                           
  Else                                                 
	  r = e * -1                                         
  End If             
 prr = R !  getprod(e$,PRC,prod$,PR.)
 defaultum=pr.pfu1[8] !	! CALL DXSAVE(0,"tmp/jssinq.txt!")
	!Call DXGet("option",pgmName$) \ pgmName$=UCase$(pgmName$)
	pgmname$=UCase$(RTrim$(options$))
	Warehouse=0;OTYPE=0
	If pgmName$="PRODWH" ! from prodwh
	  Call DXGet("warehouse",whse$) \ warehouse=whse$ ! passed a warehouse!
	Endif
	if pgmname$="OEMENU" ! from a menu
		let pgmname$=UCASE$(RTRIM$(ACTION$)) ! switch to action
		! note: will = STKSTATUS if from serp218
		if pgmname$="STKSTATUS" ! from 218
			call dxget("WHSE",whse$) \ warehouse=whse$
			call dxget("OTYPE",tmp$) \ otype=tmp$
			call dxget("UM",tmp$)\defum$=rtrim$(tmp$)+space$
			if rtrim$(defum$)<>""		
				For x2 = 0 to 12
					UNT$=" ",UNT$
					let unt=pr.pfu1[x2]
					IF UNT=-1 LET UNT$="CWT "
					IF UNT=-2 LET UNT$="LOT "
					IF UNT=-3 LET UNT$="LB  "
					IF UNT>0
						MAT READ #CCC,UNT,0;UNT$;
					ENDIF
					IF UNT$[11,14]=DEFUM$
						LET defaultum=pr.pfu1[x2]
						unit=x2
						goto foundum:
					endif
				next x2
				let defaultum=pr.pfu1[8]
				let unit=8
				foundum: !
			ELSE
				let defaultum=pr.pfu1[8]
				let unit=8
			endif
		Endif
	Endif

	! Section 1   Default UM for display
	tmp$=bsdel$+"Default UM"+fdel$+rdel$
	! tmp$=tmp$+RTrim$(Xunit$(PR.Pfu1[8],CCC))+fdel$+rdel$+esdel$	! stock UM default?  
	tmp$=tmp$+"UMFactor"+fdel$+"SHOWLVL"+fdel$

		TMP$=TMP$+rdel$+Str$(GETUMFactor(defaultum,PR.pfu1[],PR.pfu2[]))+fdel$
	
	tmp$=tmp$+P60$[26,26]+fdel$+rdel$+esdel$	! stock UM default?  
	Call AddToStr(e$,rstr$,tmp$)

	! Section 2   UMDropList$(e$,product$,type$,PRC,CCC)
	tmp$=UMDropList$(e$,prod$,"",PRC,CCC)
	Call AddToStr(e$,rstr$,tmp$)

 !etc for all files needed
 If Warehouse let wh=warehouse
 !
 tmp$="LEVEL1"
 select case tmp$
   case "LEVEL1" ! go to various options based on optionid,
   ! or break into separate main programs per optionid 
    if action$="input"   !initial action
     ! call subname(e$,chan0)
    end if
	Call CalcTotals(wh)  ! whse=0
	!
	! Section 3   
	tmp$=bsdel$+"Header Data"+fdel$+rdel$
	tmp$=tmp$+"Pack Size"+fdel$+"TotalsForFuture"+fdel$+"TotalsForAllOrder"+fdel$
	if pgmname$="STKSTATUS" 
		tmp$=tmp$+"TotalsforBHOLD"+fdel$
	endif
	tmp$=tmp$+rdel$
	! tmp$=tmp$+RTrim$(PR.PR_A2$[13,27])+fdel$+"0"+fdel$+"0"+fdel$+rdel$+esdel$
	tmp$=tmp$+RTrim$(PR.PR_A2$[13,27])+fdel$+Str$(Otyptot[1])+fdel$+Str$(Otyptot[0])+fdel$
	if pgmname$="STKSTATUS"
		tmp$=tmp$+Str$(OT15TOT)+fdel$ ! add B&H
	endif
	tmp$=tmp$+rdel$+esdel$
	Call AddToStr(e$,rstr$,tmp$)

	! Section 4
	tmp$=bsdel$+"WarehouseTotals"+fdel$+rdel$
	tmp$=tmp$+"OnHand"+fdel$+"Level1Commit"+fdel$+"ShelfCount"+fdel$+"Level2Commit"+fdel$
	tmp$=tmp$+"AvailabletoSell"+fdel$+"QtyOnBO"+fdel$+"QtyOnPO"+fdel$+"QTYCOMMIT"+fdel$
	!if pgmname$="STKSTATUS" tmp$=tmp$+"LBSOnHand"+fdel$+"LBSOnOrd"+fdel$+"INRECV"+FDEL$
	tmp$=tmp$+"LBSOnHand"+fdel$+"LBSOnOrd"+fdel$+"INRECV"+FDEL$
	tmp$=tmp$+rdel$ 
	tmp$=tmp$+str$(totoh)+fdel$+str$(lev1)+fdel$+str$(totoh-lev1)+fdel$+str$(lev2)+fdel$
	tmp$=tmp$+str$(totavl)+fdel$+str$(totbo)+fdel$+str$(totpo)+fdel$+Str$(totor)+fdel$
	!if pgmname$="STKSTATUS" tmp$=tmp$+Str$(WGTOH)+fdel$+Str$(WGTOR)+fdel$+Str$(totrecv)+fdel$
	tmp$=tmp$+Str$(WGTOH)+fdel$+Str$(WGTOR)+fdel$+Str$(totrecv)+fdel$
	tmp$=tmp$+rdel$
	Call AddToStr(e$,rstr$,tmp$+esdel$)

	! section 5 header
	tmp$=bsdel$+"WarehouseList"+fdel$+rdel$
	tmp$=tmp$+"WHID"+fdel$+"WarehouseName"+fdel$+"QtyOH"+fdel$+"Level1Commit"+fdel$+"ShelfCount"+fdel$
	tmp$=tmp$+"Level2Commit"+fdel$+"QtyAvailable"+fdel$+"QtyOnBO"+fdel$+"QtyOnPO"+fdel$
	tmp$=tmp$+"QtyOnTran"+fdel$+"QTYCOMMIT"+fdel$
	!if pgmname$="STKSTATUS" 
		tmp$=tmp$+"LBSOnHand"+fdel$+"LBSOnOrd"+fdel$+"INRECV"+FDEL$
		tmp$=tmp$+"DoNotReOrder"+fdel$
	!endif
	tmp$=tmp$+rdel$
	Call AddToStr(e$,rstr$,tmp$)

	WHK$[1,12] = prod$
	WHK$[13,14] = wh Using "##"
	If Warehouse let WHK$[13,14]=wh-1 Using "##" ! as its mode 3
	Do
	  Search #WHC,3,1;WHK$,WHR,WHE
	  if WHK$[1,12]<>prod$[1,12] let WHE=11
	  If Warehouse ! only one the one warehouse!
	    X1=Whk$[13,14]
		if x1<>Warehouse let WHE=22
	  Endif
	  if not(WHE)
		Mat Read #WHC,whr,0;WH.W1$
		Mat Read #WHC,whr,32;WH.W1
		Mat Read #WHC,whr,78;WH.W3
		Mat Read #WHC,whr,384;WH.WHPARC
		Mat Read #whc,whr,420;whw0
		Mat Read #WHC,whr,842;WH.WHLM
		Mat Read #WHC,whr,780;WH.WHLV
		Mat Read #WHC,whr,980;WH.WHLBS;
		Call CalcTotals(Val(WHK$[13,14]))

		! Section 5 detail
		powh[Val(WHK$[13,14])]=totpo
		tmp$=WHK$[13,14]+fdel$+"WHSE "+WHK$[13,14]+fdel$+str$(totoh)+fdel$+str$(lev1)+fdel$
		tmp$=tmp$+str$(totoh-lev1)+fdel$+str$(lev2)+fdel$+str$(totavl)+fdel$+str$(totbo)+fdel$
		tmp$=tmp$+str$(totpo)+fdel$+str$(totot)+fdel$+Str$(totor)+fdel$
		!if pgmname$="STKSTATUS"
			tmp$=tmp$+Str$(WGTOH)+fdel$+Str$(WGTOR)+fdel$+Str$(totrecv)+fdel$
			let work$="N"
			if whw0=1 let work$="Y"
			tmp$=tmp$+work$+fdel$
		!endif
		tmp$=tmp$+rdel$
		Call AddToStr(e$,rstr$,tmp$)

		! section 6 detail - Product Lots(1st chk 4 polines)
		tmp$="";chk4po=1;numpos=0;whichwhse=whk$[13,14]
		Call GetONPO(PDC,PHC,PRR,whichwhse,qmask$,s7$,chk4po)
		tmp$="";chk4po=0;WH.W3[1]=ONPO
		if numpos ! WH.W3[1] ! NOTE: IF 0 AND ACTUALLY PO'S - WEB SHOWS NOTHING AT ALL!
			tmp$="UNAPO"+Trim$(WHK$[13,14])+fdel$+"UNA"+fdel$+"PO"+fdel$+WHK$[13,14]+fdel$
			tmp$=tmp$+" "+fdel$+"0"+fdel$+"0"+fdel$+"0"+fdel$
			! on po
			CNVTA = WH.W3[1]
			x3 = XAMOUNT(CNVTU[],CNVTA,PR.PFU1[],PR.PFU2[],PR.A[],ctlc,FLAG)
			!tmp$=tmp$+Str$(WH.W3[1])+fdel$
			tmp$=tmp$+Str$(x3)+fdel$
			tmp$=tmp$+"0"+fdel$
			tmp$=tmp$+"N"+fdel$+rdel$
		Endif
		if tmp$ Call AddToStr(e$,s6$,tmp$)
		Call GetProdLot(Val(WHK$[13,14]))	! section 6 uses s6$

		! section 7 detail
		Call Section7(Val(WHK$[13,14]))	! section 7 uses s7$

	  end if
	loop until WHE>0
	Call AddToStr(e$,rstr$,esdel$)

	! section 6 header
	tmp$=bsdel$+"WarehouseDetails"+fdel$+rdel$
	tmp$=tmp$+"LotID"+fdel$+"Lot"+fdel$+"Src"+fdel$+"WHID"+fdel$+"Location"+fdel$+"QtyOH"+fdel$
	tmp$=tmp$+"QtyAvailable"+fdel$+"QtyOnBO"+fdel$+"QtyOnPO"+fdel$+"QtyOnTran"+fdel$+"Primary"+fdel$
	tmp$=tmp$+rdel$
	Call AddToStr(e$,rstr$,tmp$+s6$+esdel$)  ! we already have the entire section 6 in s6$
	
	! section 7 header
	tmp$=bsdel$+"LotDetails"+fdel$+rdel$
	tmp$=tmp$+"LotId"+fdel$+"HD"+fdel$+"SOPO"+fdel$+"CustVend"+fdel$+"QtyOnOrder"+fdel$+"ShipRecv"+fdel$
	tmp$=tmp$+"Status"+fdel$+"ShipDateDueDate"+fdel$+"QtyOnBO"+fdel$
	if pgmname$="STKSTATUS"
		let tmp$=tmp$+"ORTYPE"+fdel$ ! add order type
	endif
	let tmp$=tmp$+"Highlight"+fdel$
	
	tmp$=tmp$+rdel$  !need record end
	Call AddToStr(e$,rstr$,tmp$+s7$+esdel$)  ! we already have the entire section 7 in s7$

	!
    ! done with LEVEL1
    ! if action$="other" call internalsubname() !
    !
   case "LEVEL2" !
    !if action$="search" call custsearch(e$,chan0) !search customers
	! done with LEVEL2
 end select  !options
 Call SetOutput(e$,rstr$)
 ! call dxclose()
else
 include "src/callmainerrnet.inc"
end try
end
!---------------- done with main -----------------------------------------

Sub CalcTotals(wh)
! internal subroutine description (shares variables)
Declare Function GetQtyBo,GetqtyTrans
Declare Function SetDftCost
 try
  !
  if not(wh)
	  TOTOH = PR.A[0]
	  If PR.A$[127,127] = "Y" Let WGTOH = PR.PRPARC[3];WGTOR = PR.LBSORD
	  TOTOR = PR.A[3] + PR.A[1]
	  TOTPO = PR.A[2]
	  LEV1 = PR.PLV[0];TOTOT=0
	  LEV2 = PR.PLV[1]
	  WH.W1$ = ""
	  TOTRECV=0
	  !iF pgmname$="STKSTATUS"
		CALL "QTYINRECV.DL4",PROD$,WH,FCHANS[],TOTRECV,Intco,rstr$
	  !Endif
  Else
	  WHK$[1,12] = prod$
	  WHK$[13,14] = wh Using "##"
	  Search #WHC,2,1;WHK$,R12,E
	  If E
		TOTOH = 0;WGTOH = 0
		TOTPO = 0;TOTOT = 0
		TOTOR = 0;WGTOR = 0
		LEV1 = 0
		LEV2 = 0;TOTRECV=0
	  Else 
		Mat Read #WHC,R12,0;WH.W1$
		Mat Read #WHC,R12,78;WH.W3
		Mat Read #WHC,R12,384;WH.WHPARC
		Mat Read #WHC,R12,842;WH.WHLM
		Mat Read #WHC,R12,780;WH.WHLV
		Mat Read #WHC,R12,980;WH.WHLBS;
		If WHEADFLAG Return
		
		TOTOH = WH.W3[0]
		If PR.A$[127,127] = "Y" Let WGTOH = WH.WHLBS[0];WGTOR = WH.WHLBS[1]
		TOTOR = WH.W3[2]
		TOTPO = WH.W3[1]
		LEV1 = WH.WHLV[0]
		LEV2 = WH.WHLV[1]
		PREC[0] = R3
		WHSE = wh
		LTBL = WH.WHLM[0]
		CNVTA = 0
		! If LTBL Gosub CALC_LOAD \ WH.W3[17] = CNVTA
		CNVTA = 0
		LTBL = WH.WHLM[1]
		! If LTBL Gosub CALC_LOAD \ WH.W3[14] = CNVTA
		totot=getqtytrans(wh,prr) ! qty on transfer
		!iF pgmname$="STKSTATUS"
			CALL "QTYINRECV.DL4",PROD$,WH,FCHANS[],TOTRECV,Intco,rstr$
		!Else
		!	totrecv=0
		!Endif
	  End If 
	  ! If P9$[32,32] = "Y" Gosub CHECK_PRODWHSE
  End If	! if not(wh)


	CNVTU[0] = 0
	CNVTU[1] = PR.PFU1[UNIT]
	IF DEFAULTUM<>0 LET CNVTU[1]=DEFAULTUM
	CNVTU[2] = 1

	CNVTA = TOTOH
	TOTOH = XAMOUNT(CNVTU[],CNVTA,PR.PFU1[],PR.PFU2[],PR.A[],ctlc,FLAG)

	CNVTA = TOTOR
	TOTOR = XAMOUNT(CNVTU[],CNVTA,PR.PFU1[],PR.PFU2[],PR.A[],ctlc,FLAG)

	CNVTA = TOTPO
	TOTPO = XAMOUNT(CNVTU[],CNVTA,PR.PFU1[],PR.PFU2[],PR.A[],ctlc,FLAG)
	
	CNVTA = TOTOT
	TOTOT = XAMOUNT(CNVTU[],CNVTA,PR.PFU1[],PR.PFU2[],PR.A[],ctlc,FLAG)

	!OTYPTOT = LEV1 + LEV2
	If P60$[26,26] = "Y"
	  CNVTA = LEV1
	  LEV1 = XAMOUNT(CNVTU[],CNVTA,PR.PFU1[],PR.PFU2[],PR.A[],ctlc,FLAG)
	  CNVTA = LEV2
	  LEV2 = XAMOUNT(CNVTU[],CNVTA,PR.PFU1[],PR.PFU2[],PR.A[],ctlc,FLAG)
	End If 

	CALL GET_OT15TOT(WH,PRR,OTYPTOT[])
	CNVTA = OTYPTOT[0] ! all
	OTYPTOT[0] = XAMOUNT(CNVTU[],CNVTA,PR.PFU1[],PR.PFU2[],PR.A[],ctlc,FLAG)

	CNVTA = OTYPTOT[1] ! futures
	OTYPTOT[1] = XAMOUNT(CNVTU[],CNVTA,PR.PFU1[],PR.PFU2[],PR.A[],ctlc,FLAG)

	CNVTA = OTYPTOT[2] ! B & H
 	OT15TOT = XAMOUNT(CNVTU[],CNVTA,PR.PFU1[],PR.PFU2[],PR.A[],ctlc,FLAG)

	LC=SetDftCost()

	CNVTA = GetQtyBo(PLC,prod$,wh)
	!QTYBO = XAMOUNT(CNVTU[],CNVTA,PR.PFU1[],PR.PFU2[],PR.A[],ctlc,FLAG) ! qtybo not used
	TOTBO = XAMOUNT(CNVTU[],CNVTA,PR.PFU1[],PR.PFU2[],PR.A[],ctlc,FLAG)

	TOTAVL = TOTOH - TOTOR
	If P9$[28,28] = "Y" Let TOTAVL = TOTAVL + TOTPO
	CNVTA=TOTRECV
	TOTRECV=XAMOUNT(CNVTU[],CNVTA,PR.PFU1[],PR.PFU2[],PR.A[],ctlc,FLAG)
  call dxset("output",mergedir$+"netscr.html")

 else
  include "src/callsuberr.inc"
 end try
end sub !CalcTotals

!--------------------------------------------------------------------
Function GetQtyBo(PLC,prod$,wh)
 Try
	Dim K16$[50]
	Dim 3%,P3[4],QTYBO
	QTYBO = 0                              
	K16$ = " ",K16$                        
	K16$[1,12] = prod$              
	K16$[13,14] = wh Using "##"

	QTYBO_LOOP: Rem
	Search #PLC,3,4;K16$,R16,E      
	If Not(E) And K16$[1,12] = prod$
	  SCR = Val(K16$[13,14])               
	  If Not(WH) Or SCR = WH   
		Mat Read #PLC,R16,82;P3;    
		QTYBO = QTYBO + P3[4]              
		Goto QTYBO_LOOP                    
	  End If                               
	End If
 else
  include "src/callsuberr.inc"
 end try
End Function QTYBO
!--------------------------------------------------------------------
Function SetDftCost()
 Try
	SET_DFT_COST: Rem DEFAULT COST                  
	DFT_COST = P60$[29,29]                          
	If DFT_COST = 0 Or DFT_COST > 5 Let DFT_COST = 1
	LC = 0                                          
	If P9$[32,32] = "Y"                             
	  If DFT_COST = 1 Let LC = WH.W3[17]               
	  If DFT_COST = 2 Let LC = WH.W3[14]               
	  If DFT_COST = 3 Let LC = WH.W3[15]               
	  If DFT_COST = 4 Let LC = WH.W3[16]               
	  If DFT_COST = 5 Let LC = WH.W3[18]               
	End If                                          
	If LC = 0                                       
	  If DFT_COST = 1 Let LC = PR.B[8]                 
	  If DFT_COST = 2 Let LC = PR.PF_LOAD2             
	  If DFT_COST = 3 Let LC = PR.B[21]                
	  If DFT_COST = 4 Let LC = PR.B[10]                
	  If DFT_COST = 5 Let LC = PR.PR_C4[4]                
	End If
 else
  include "src/callsuberr.inc"
 end try
End Function LC

!--------------------------------------------------------------------
sub OpenFiles()
  !
  ! Open files for cash receipts
  !
  Try
    !
	CTLC= OpenFile(-9999,intCo) \ If CTLC=-1 Error 42    !control
	WHC= OpenFile(-1744,intCo)  \ If WHC=-1  Error 42    !prodwhse
	PRC=OpenFile(-1792,intCo)   \ If PRC=-1  Error 42    !prod
	VNC= OpenFile(-2400,intCo)  \ If VNC=-1  Error 42    !vendor
	CMC= OpenFile(-2288,intCo)  \ If CMC=-1  Error 42    !commodity
	CTC= OpenFile(-1984,intCo)  \ If CTC=-1  Error 42    !category
	CCC= OpenFile(-1728,intCo)  \ If CCC=-1  Error 42    !ccodes
	PLC= OpenFile(-2528,intCo)  \ If PLC=-1  Error 42    !prodlot
	SLC= OpenFile(-2320,intCo)  \ If SLC=-1  Error 42    !sordlot
	PHC= OpenFile(-2416,intCo)  \ If PHC=-1  Error 42    !pohead
	PDC= OpenFile(-2432,intCo)  \ If PDC=-1  Error 42    !poline
	OHC= OpenFile(-1840,intCo)  \ If OHC=-1  Error 42    !roh
	ODC= OpenFile(-1888,intCo)  \ If ODC=-1  Error 42    !rolnew
	BDC= Openfile(-208,IntCo) \ if bdc=-1 Error 42 ! product location
	CMC= Openfile(-1808,IntCo) \ if cmc=-1 Error 42		! customer
    !
  else
    include "src/callsuberr.inc"
  end try
end sub ! openfiles
! --------------------------------------------------------------
! 
External function UMDropList$(e$,product$,type$,PRC,CCC)

! creates drop down list of product's allowed UMs
Declare External Function XUM$
 try
  dim ums$[500],tmp$[10],um$[4],pum$[4],sum$[4],k$[12],hold$[12],e$[500]
  dim pr. as prod
  dim 1%,baseunit,stockunit,sellunit,purchunit,costunit,priceunit 
  dim 1%,um1,um2,um3,um4,um5,um6,um7     
  dim 4%,r

    dim bsdel$[20],esdel$[20],rdel$[20],fdel$[20],rstr$[200]
	!
    !
	call env(1,"BSDEL",bsdel$)
    call env(1,"ESDEL",esdel$)
    call env(1,"RDEL",rdel$)
    call env(1,"FDEL",fdel$)

  ums$=bsdel$+"UM DropList"+fdel$+rdel$
  ums$=ums$+"UM"+fdel$+"Description"+fdel$+"UM Factor"+fdel$+rdel$
  k$ = product$                                        
  hold$ = k$                                                            
  Search #PRC,2,1;k$,r,e                                               
  If Trim$(k$) <> Trim$(hold$) Let e = 2                                  
  If e = 0                                                              
	 Read Record #PRC,r;pr.; 
	 baseunit = PR.PFU1[0]         
	 um1 = PR.PFU1[1]         
	 um2 = PR.PFU1[2]        
	 um3 = PR.PFU1[3]         
	 um4 = PR.PFU1[4]       
	 um5 = PR.PFU1[5]        
	 um6 = PR.PFU1[6]  
	 um7 = PR.PFU1[7]  
	 stockunit = PR.PFU1[8]        
	 sellunit = PR.PFU1[9]         
	 purchunit = PR.PFU1[10]       
	 costunit = PR.PFU1[11]        
	 priceunit = PR.PFU1[12]
	 
	 ums$=ums$+XUM$(baseunit,CCC,fdel$)+fdel$+"1"+fdel$+rdel$  
	 If um1 ums$=ums$+XUM$(um1,CCC,fdel$)+fdel$+Str$(PR.Pfu2[0])+fdel$+rdel$    
	 If um2 ums$=ums$+XUM$(um2,CCC,fdel$)+fdel$+Str$(PR.Pfu2[1])+fdel$+rdel$
	 If um3 ums$=ums$+XUM$(um3,CCC,fdel$)+fdel$+Str$(PR.Pfu2[2])+fdel$+rdel$   
	 If um4 ums$=ums$+XUM$(um4,CCC,fdel$)+fdel$+Str$(PR.Pfu2[3])+fdel$+rdel$  
	 If um5 ums$=ums$+XUM$(um5,CCC,fdel$)+fdel$+Str$(PR.Pfu2[4])+fdel$+rdel$   
	 If um6 ums$=ums$+XUM$(um6,CCC,fdel$)+fdel$+Str$(PR.Pfu2[5])+fdel$+rdel$   
	 If um7 ums$=ums$+XUM$(um7,CCC,fdel$)+fdel$+Str$(PR.Pfu2[6])+fdel$+rdel$ 
  Else                                                                  
	 r = e * -1 
	 ums$=ums$,"EA"+fdel$+"EACH"+fdel$+"1"+fdel$+rdel$ !only default if not on file
  End If         
  ums$=ums$+esdel$
 else
	 Call suberr(e$,Spc(8),Spc(10),Msc$(2))
 end try
end function ums$ !getumhtml

!--------------------------------------------------------------------

EXTERNAL FUNCTION XUM$(UNIT, CCHAN, fdel$)
Try 
 DIM UNIT$[14],e$[500]

 unit$ = " ",unit$
 
 IF UNIT=-1 LET UNIT$="CWT "; umfactor=1
 IF UNIT=-2 LET UNIT$="LOT "; umfactor=1
 IF UNIT=-3 LET UNIT$="LB  "; umfactor=1

 IF UNIT>0 THEN
   MAT READ #CCHAN,UNIT,0;UNIT$;
 END IF
Else
	Call suberr(e$,Spc(8),Spc(10),Msc$(2))
end Try
END FUNCTION RTrim$(UNIT$[11,14])+fdel$+RTrim$(Unit$[1,10])

!--------------------------------------------------------------------

Sub GetProdLot(whichwhse)
! as "STOCK" should be there - send it
Try
	Declare Function GetqtyTrans
	dim src$[6]
	Nostkloc=1 ! no stock loc sent
	ONOT16TRANS=getqtytrans(whichwhse,prr) ! qty on transfer
	getSprodlot: !==========================================================
	Let PLK$=" ",PLK$;PLK$[1,12]=RTrim$(Prod$);PLK$[13,14]=whichwhse using "##"
	nextSprodlot: ! ===========================
	Search #PLC,3,4;PLK$,PLR,PLE
	If PLK$[1,12]<>Prod$[1,12] then let PLE=22
	If Val(PLK$[13,14])<>whichwhse then let PLE=22
	If PLE goto GPLDone ! then Exit Sub

	If PLE
	   Clear PL.
	Else
	   Read Record #PLC,PLR; PL.;
	Endif

	Select Case PL.P1[1]
		Case 0
			src$="NA"
		Case 1
			src$="PO"
		Case 2
			src$="WO"
		Case 3
			src$="Oth"
		Case 4
			src$="Cons"
		Case 5
			src$="Trns"

	End Select
	if len(PL.P1$)<6 LET PL.P1$=PL.P1$+"      "
	If UCase$(PL.P1$[1,6])="STOCK " let nostkloc=0 ! did send it
	! section 6 header
	!tmp$=bsdel$+"WarehouseDetails"+fdel$+rdel$
	!tmp$=tmp$+"LotID"+fdel$+"Lot"+fdel$+"Src"+fdel$+"WHID"+fdel$+"Location"+fdel$+"QtyOH"+fdel$
	!tmp$=tmp$+"QtyAvailable"+fdel$+"QtyOnBO"+fdel$+"QtyOnPO"+fdel$+"QtyOnTran"+fdel$+rdel$
	tmp$=Rtrim$(PL.P0$[13,24])+RTrim$(PL.P1$[1,6])+fdel$	! lotid
	tmp$=tmp$+Rtrim$(PL.P0$[13,24])+fdel$	! lot
	tmp$=tmp$+src$+fdel$	! src 
	tmp$=tmp$+WHK$[13,14]+fdel$
	tmp$=tmp$+PL.P1$[1,6]+fdel$

	! on hand 
	CNVTA = PL.P3[0]-PL.P3[1]
	x3 = XAMOUNT(CNVTU[],CNVTA,PR.PFU1[],PR.PFU2[],PR.A[],ctlc,FLAG)
	! tmp$=tmp$+LTrim$(PL.P3[0]-PL.P3[1] using QMask$) +fdel$				! onhand
	tmp$=tmp$+LTrim$(x3 using QMask$) +fdel$				! onhand

	! avail
	CNVTA = PL.P3[0]-PL.P3[1]-PL.P3[3]
	x3 = XAMOUNT(CNVTU[],CNVTA,PR.PFU1[],PR.PFU2[],PR.A[],ctlc,FLAG)
	!tmp$=tmp$+LTrim$(PL.P3[0]-PL.P3[1]-PL.P3[3] using QMask$) +fdel$	! avail
	tmp$=tmp$+LTrim$(x3 using QMask$) +fdel$	! avail

	! on bo 
	CNVTA = PL.P3[4]
	x3 = XAMOUNT(CNVTU[],CNVTA,PR.PFU1[],PR.PFU2[],PR.A[],ctlc,FLAG)
	!tmp$=tmp$+LTrim$(PL.P3[4] using QMask$) +fdel$						! onbo
	tmp$=tmp$+LTrim$(x3 using QMask$) +fdel$							! onbo

	! onpo??????
	tmp$=tmp$+LTrim$(0 using QMask$) +fdel$								! onpo

    ! on transfers
! 	If PL.P1$[1,6] = "STOCK " Let PL.PLTR = PL.PLTR + ONOT16TRANS;ONOT16TRANS = 0
	Let PL.PLTR = PL.PLTR + ONOT16TRANS;ONOT16TRANS = 0 ! 1st one gets it
	CNVTA = PL.PLTR
	x3 = XAMOUNT(CNVTU[],CNVTA,PR.PFU1[],PR.PFU2[],PR.A[],ctlc,FLAG)
	!tmp$=tmp$+LTrim$(PL.PLTR using QMask$) +fdel$
	tmp$=tmp$+LTrim$(X3 using QMask$) +fdel$

	! check/send if primary
	Prim_loc=chk_prd_loc(whichwhse,prod$,PL.P1$[1,6])
	if prim_loc=1 let tmp$=tmp$+"Y"+fdel$  Else let tmp$=tmp$+"N"+fdel$ ! primary Y/N
	tmp$=tmp$+rdel$
	Call AddToStr(e$,s6$,tmp$)	 ! start building in s6

	goto nextSprodlot
	GPLDone: ! get prodlot done
	if nostkloc ! no stock loc sent - send a dummy one
		Clear PL.
		TMP$=WHICHWHSE USING "&&"
		PL.P0$[13]="STOCK"+tmp$+"            "
		PL.P1$[1,6]="STOCK ";src$="Oth"
		tmp$=Rtrim$(PL.P0$[13,24])+RTrim$(PL.P1$[1,6])+fdel$	! lotid
		tmp$=tmp$+Rtrim$(PL.P0$[13,24])+fdel$	! lot
		tmp$=tmp$+src$+fdel$	! src 
		tmp$=tmp$+WHK$[13,14]+fdel$
		tmp$=tmp$+PL.P1$[1,6]+fdel$
		tmp$=tmp$+LTrim$(PL.P3[0]-PL.P3[1] using QMask$) +fdel$				! onhand
		tmp$=tmp$+LTrim$(PL.P3[0]-PL.P3[1]-PL.P3[3] using QMask$) +fdel$	! avail
		tmp$=tmp$+LTrim$(PL.P3[4] using QMask$) +fdel$						! onbo
		tmp$=tmp$+LTrim$(0 using QMask$) +fdel$								! onpo

	! 	If PL.P1$[1,6] = "STOCK " Let PL.PLTR = PL.PLTR + ONOT16TRANS;ONOT16TRANS = 0
		Let PL.PLTR = PL.PLTR + ONOT16TRANS;ONOT16TRANS = 0 ! 1st one gets it

		tmp$=tmp$+LTrim$(PL.PLTR using QMask$) +fdel$+"N"+fdel$+rdel$
		Call AddToStr(e$,s6$,tmp$)	 ! start building in s6
	endif
Else
	Call suberr(e$,Spc(8),Spc(10),Msc$(2))
end Try

End Sub
!--------------------------------------------------------------------

Sub GetONPO(PDC,PHC,PRR,whichwhse,qmask$,s7$,chk4po)
! 2 modes - 1. chk4po checks if any po's for whse
! 2. get actual pos
Dim PH. As POHDR
Dim PD. As PODet
Dim S7tmp$[5000],3%

Try
Declare External Function PDate$

Dim PDK$[20],PHK$[20],POSTATUS$[100,20],e$[500]

dim bsdel$[20],esdel$[20],rdel$[20],fdel$[20] ! ,rstr$[100]
!
call env(1,"BSDEL",bsdel$)
call env(1,"ESDEL",esdel$)
call env(1,"RDEL",rdel$)
call env(1,"FDEL",fdel$)
!
poStatus$[1] ="PO ENTERED"
poStatus$[2] ="PO PRINTED"
poStatus$[3] ="PO REGISTERED"
poStatus$[4] ="PO OPEN"
poStatus$[5] ="RECEIPTS IN PROC"
poStatus$[6] ="RECEIPTS REGISTERED"
poStatus$[7] ="PO CLOSED"
poStatus$[91]="PO IN PROCESS"
postatus$[95]="PO SERP IN PROCESS"
postatus$[96]="PO RTS IN PROCESS"
postatus$[97]="DM SERP IN PROCESS"
!
Let ONPO=0;S7tmp$=""
Let PDK$=" ",PDK$;PDK$[1,6]=PRR using "######"  

getPoline: !=============================================================
Search #PDC,3,2;PDK$,PDR,PDE
If Val(PDK$[1,6])<>PRR then let PDE=22 
If PDE then Exit Sub ! " Exit Function S7tmp$

!If debugDetail                                                               
!   msg$="doing...Search #PDC: PDK$="+PDK$+" PDR="+PDR \ Call updatelog(debug)
!   If PDE msg$="error...Search error "+PDE  \ Call updatelog(debug)          
!Endif                                                                        

If PDE                        
   Clear PD.                  
Else                          
   Read Record #PDC,PDR; PD.; 
Endif


!check
!Call $LOGIC,1,2^0,PD.L1[3],nonstock                                  
If nonstock then       goto getPoline:    !nonstock          
If PD.L1[0]=3 then     goto getPoline:    !line closed/filled 
If PD.L1[1]<>whichwhse goto getPoline:    !check whse
If PD.L1[0]>5 then     goto getPoline:    ! ??
If PD.L3[3]>=PD.L3[2]  goto getPoline:    !

PHR=PD.L3[0]
If PHR                        
   Read Record #PHC,PHR; PH.; 
Else
   Clear PH.
Endif                         

!more check
If Val(PDK$[7,12])<>PH.H0[2]   goto getPoline:  !po# don't match     
If PH.H0[0]>=7 and PH.H0[0]<91 goto getPoline:  !status check                 
If not(PD.POMISC[0])           goto getPoline:  !no stock update/ignore 
numpos=numpos+1
LET ONPO=ONPO+(PD.L3[2]+PD.PL4[1]-(PD.L3[3])) 
if chk4po goto getPoline ! just checking - not sending yet
let tname$=" ",tname$
If PH.H3[3]
	let k9$=PH.H3[3] using "######"
	Search #vnc,2,1;k9$,R[9],E
	if not(e)
		mat read #vnc,r[9],0;tname$;
	endif
Endif
!"LotId"+fdel$+"HD"+fdel$+"SOPO"+fdel$+"CustVend"+fdel$+"QtyOnOrder"+fdel$+"ShipRecv"+fdel$+"Status"+fdel$+"ShipDateDueDate"+fdel$+"QtyOnBO"+fdel$+rdel$
S7tmp$="UNAPO"+Trim$(Str$(whichwhse))+fdel$+" PO"+fdel$
S7tmp$=S7tmp$+RTrim$(Str$(PH.H0[2]))+"-"+Str$(PD.L1[2]) +fdel$
S7tmp$=S7tmp$+LTrim$(PH.H3[3] using "######")
if pgmname$<>"STKSTATUS" ! add vendname
	s7tmp$=s7tmp$+" "+RTrim$(TName$)
Endif 
s7tmp$=s7tmp$+fdel$	! Vend
if pgmname$<>"STKSTATUS" 
	S7tmp$=S7tmp$+LTrim$(PD.L3[2] using Qmask$)+fdel$	! qty ord
	S7tmp$=S7tmp$+LTrim$(PD.L3[3] using Qmask$)+fdel$	! qty rcv
ELSE
	CNVTA = PD.L3[2]
	x3 = XAMOUNT(CNVTU[],CNVTA,PR.PFU1[],PR.PFU2[],PR.A[],ctlc,FLAG)
	S7tmp$=S7tmp$+LTrim$( X3 using Qmask$)+fdel$	! qty ord
	CNVTA = PD.L3[3] 
	x3 = XAMOUNT(CNVTU[],CNVTA,PR.PFU1[],PR.PFU2[],PR.A[],ctlc,FLAG)
	S7tmp$=S7tmp$+LTrim$( X3 using Qmask$)+fdel$	! qty rcv
ENDIF
S7tmp$=S7tmp$+poStatus$[PH.H0[0]]
if pgmname$="STKSTATUS" ! add in status (as bombs after #)
	s7tmp$=s7tmp$+" - "+RTrim$(TName$)
Endif
s7tmp$=s7tmp$+ fdel$			! status / name
if pd.l2[2]
	S7tmp$=S7tmp$+Pdate$(PD.l2[2])+fdel$				! due date from poline
else
	S7tmp$=S7tmp$+Pdate$(PH.H0[4])+fdel$				! due date
endif
S7tmp$=S7tmp$+LTrim$(PD.PL4[4] using Qmask$)+fdel$	! qty bo
if pgmname$="STKSTATUS" 
	let S7tmp$=s7tmp$+Str$(ph.h4[0])+fdel$ ! order type (would be 0 for whse?)
endif
let tmp1$="N"
if ph.delvtime1>0 let tmp1$="Y"
let s7tmp$=s7tmp$+tmp1$+fdel$


S7tmp$=S7tmp$+rdel$ ! add eor
Call AddToStr(e$,s7$,S7tmp$)	 ! start building in s7
Goto getPoline: ! get next (can be >1!)

Else
	Call suberr(e$,Spc(8),Spc(10),Msc$(2))
end Try

End Sub ! " Function S7tmp$

!--------------------------------------------------------------------

Sub GetOrders(ODC,OHC,PRR,SLC,prod$,whichwhse,qmask$,S7$)

Dim OH. As ORDH
Dim OD. As ORDD
Dim SL. As SORDLOT

Dim SLK$[60],OHK$[20],ODK$[20],ORDSTATUS$[100,20],whse$[2],temp$[20]
Dim S7tmp$[1000],src$[10],3%

Try
Declare External Function PDate$

dim bsdel$[20],esdel$[20],rdel$[20],fdel$[20],e$[500] ! rstr$[100],e$[500]
!
call env(1,"BSDEL",bsdel$)
call env(1,"ESDEL",esdel$)
call env(1,"RDEL",rdel$)
call env(1,"FDEL",fdel$)
!
ordStatus$[1] ="ORD ENTERED"            
ordStatus$[2] ="ORD PRINTED"            
ordStatus$[3] ="ORD REGISTERED"         
ordStatus$[4] ="READY TO INVOICE"               
ordStatus$[5] ="INV ENTERED"  
ordStatus$[6] ="INV PRINTED"
ordStatus$[7] ="INV REGISTERED" 
ordStatus$[9] ="CM ENTERED"
ordStatus$[10]="CM PRINTED"
ordStatus$[11]="CM REGISTERED"
ordstatus$[40]="WORK ORDER"
OrdStatus$[41]="DEBIT MEMO"
OrdStatus$[42]="IntCo Transfer"
Ordstatus$[58]="POS BEING PKT"
OrdStatus$[59]="POS ON HOLD"
ordStatus$[90]="ORD IN PROCESS"
ordStatus$[91]="ORD IN EDIT"         
ordStatus$[92]="ORD IN JOURNAL"
ordStatus$[93]="CM IN JOURNAL"
ORDSTATUS$[94]="POS IN PROCESS"
ordstatus$[95]="SERP IN PROCESS"
ORDSTATUS$[97]="CM IN PROCESS"
S7tmp$=""
whse$=whichwhse using "##"
Let SLK$=" ",SLK$;SLK$[1,12]=prod$
nextSordlot: !========================================================== 
Search #SLC,3,1;SLK$,SLR,SLE                                                    
If SLK$[1,12]<>prod$[1,12] then let SLE=22                     
If SLE Goto GODone ! " Exit Function S7tmp$

If SLK$[22,23]<>WHSE$ then goto nextSordlot:

If SLE                                                                          
   Clear SL.                                                                    
Else                                                                            
   Read Record #SLC,SLR; SL.;                                                   
Endif                                 

If SL.OL1[1]<>2 and SL.OL1[1]<>3 and SL.OL1[1]<>5 ! NOT ORDER TYPES
	! if it's in sordlot - lets show it!! - set up oh. vars used
	IF SL.OL1[1]=1 LET OH.H0[0]=40
	if sl.ol1[1]=4 let oh.h0[0]=41
	if sl.ol1[1]=6 let oh.h0[0]=42
	let oh.H0[10]=sl.ol2[3]
	if sl.ol2[3]=0 let oh.h0[10]=sl.ol2[1]
	oh.h5[7]=1
	goto BPOrds ! nextSordlot:
Endif
Let OHK$=" ",OHK$
Let OHK$[1,6]=SL.OL2[2] using "######"
Let OHK$[7,12]=SL.OL2[0] using "######" 
Let Temp$=" ",Temp$;Temp$=OHK$                                                  
getRoh: !==========================================================        
Search #OHC,2,2;OHK$,OHR,OHE                                                    
If OHK$[1,12]<>Temp$[1,12] then let OHE=22                                      
! If OHE then goto nextSordlot: ! doesn't on 218!                                                  
If OHE ! could be non-order (DM/WO/XFER)                                                                         
   Clear OH.
   IF SL.OL1[1]=1 LET OH.H0[0]=40
	if sl.ol1[1]=4 let oh.h0[0]=41
	if sl.ol1[1]=6 let oh.h0[0]=42
	let oh.H0[10]=sl.ol2[3]
	if sl.ol2[3]=0 let oh.h0[10]=sl.ol2[1]
	oh.h5[7]=1
Else                                                                            
   Read Record #OHC,OHR; OH.;                                                   
Endif                                                                           

If OH.H5[7]=16 and SL.OL1[2]=OH.H5[11] then goto nextSordlot:
if otype and oh.h5[7]<>Otype goto nextSordlot ! only that order type
Let ODK$=SLK$[13,21]
Let Temp$=" ",Temp$;Temp$=SLK$[13,21]
getRol: !===========================================================
Search #ODC,2,1;ODK$,ODR,ODE                                                    
If ODK$[1,9]<>Temp$[1,9] then let ODE=22                                 
!If ODE Goto getRoh: ! nothing on order lines is used!(and could be DM/WO/XFER
iF ode
	CLEAR OD.
ELSE
	Read Record #ODC,ODR,0;OD.;
	if val(odk$[1,6])<>od.L2[1] goto nextSordlot ! diff order
	x1=odk$[7,9]
	if x1<>od.l3[2] goto nextSordlot ! diff line
	if sl.ol2$[1,3]<>"KIT" ! kit sordlots not same prod!
		if od.L1$[1,12]<>Prod$ goto nextSordlot ! prod diff
	endif
ENDIF
BPOrds: ! bypass order data
If SL.OL1[1]=1 then src$="WO "
If SL.OL1[1]=3 then src$="CM "
If SL.OL1[1]=4 then src$="DM "
IF SL.OL1[1]=5 then src$="AV "
if SL.OL1[1]=6 then src$="IT "
If SL.OL1[1]=2 
	If SL.OL3[4]=0 
		If OH.H5[7]<>16 
			src$="SO "
		Else ! = 16
			src$="TR "
			IF SL.OL1[2]=OH.H5[11] src$="TR+"
			IF SL.OL1[2]<>OH.H5[11] src$="TR-"
		Endif
	Else ! L3[4]<>0
		src$="TR "
		IF SL.OL1[2]=OH.H5[11] src$="TR+"
		IF SL.OL1[2]<>OH.H5[11] src$="TR-"
	Endif
Endif
Let tname$=" ",tname$
if SL.OL2[2] ! customer - get name
  if SL.OL1[1]<>4
	let k9$=SL.OL2[2] using "######"
	search #CMC,2,1;k9$,r[8],E
	if not(e)
		mat read #cmc,r[8],30;tname$;
	Endif
  Endif
  if SL.OL1[1]=4 ! dm
	let k9$=SL.OL2[2] using "######"
	search #VNC,2,1;k9$,r[8],E
	if not(e)
		mat read #vnc,r[8],0;tname$;
	Endif
  Endif
Endif
! if pgmname$="STKSTATUS" clear tname$ ! can't handle it?
!col$[2]=Str$(SL.OL2[0])                               !ord#
!col$[3]=Str$(SL.OL1[0])                               !line#
!col$[4]=Str$(SL.OL2[2])                               !cust
!col$[5]=Str$(SL.OL1[2])                               !whse
!col$[6]=SL.OL3[0] using Qmask$                        !qty required
!col$[7]=SL.OL3[0]-(SL.OL3[0]-SL.OL3[1]) using Qmask$  !qty fulfilled 
!col$[8]=SL.OL3[0]-SL.OL3[1] using Qmask$              !b/o     
!col$[9]=Pdate$(OH.H0[10])                             !shipdate 
!col$[10]=ordStatus$[OH.H0[0]]                         !status
!col$[11]=" "                             !reserved for PO (pohead rec#) 
!col$[13]=Str$(SL.OL2[2])                 !reserved for SO (cust#)
!
!"LotId"+fdel$+"HD"+fdel$+"SOPO"+fdel$+"CustVend"+fdel$+"QtyOnOrder"+fdel$+"ShipRecv"+fdel$+"Status"+fdel$+"ShipDateDueDate"+fdel$+"QtyOnBO"+fdel$+rdel$
S7tmp$=RTrim$(SL.S0$[13,24])+RTrim$(SL.OL2$[11,16])+fdel$+src$+fdel$
S7tmp$=S7tmp$+Rtrim$(Str$(SL.OL2[0]))+"-"+Str$(SL.OL1[0])+fdel$			! ord# line
S7tmp$=S7tmp$+LTrim$(SL.OL2[2] using "######") ! cust#
if pgmname$<>"STKSTATUS"
	S7tmp$=S7tmp$+" "+RTrim$(TName$)	! Cust name
Endif
S7tmp$=S7tmp$+fdel$ ! cust / name
if pgmname$<>"STKSTATUS"
	S7tmp$=S7tmp$+LTrim$(SL.OL3[0] using Qmask$)+fdel$	! qty ord
	!S7tmp$=S7tmp$+LTrim$(SL.OL3[0]-(SL.OL3[0]-SL.OL3[1]) using Qmask$)+fdel$	! qty rcv
	S7tmp$=S7tmp$+LTrim$(SL.OL3[1] using Qmask$)+fdel$	! qty SHP'D (ACTUAL!)
ELSE
	CNVTA = SL.OL3[0]
	x3 = XAMOUNT(CNVTU[],CNVTA,PR.PFU1[],PR.PFU2[],PR.A[],ctlc,FLAG)
	S7tmp$=S7tmp$+LTrim$(X3 using Qmask$)+fdel$	! qty ord
	CNVTA = SL.OL3[1]
	x3 = XAMOUNT(CNVTU[],CNVTA,PR.PFU1[],PR.PFU2[],PR.A[],ctlc,FLAG)
	S7tmp$=S7tmp$+LTrim$(X3 using Qmask$)+fdel$	! qty SHP'D (ACTUAL!)
ENDIF
IF OH.H0[0] let tmp1$=ordStatus$[OH.H0[0]] Else tmp1$=" "
if oh.h0[0]>=9 and oh.h0[0]<=12
	if oh.h3[1]=6 let tmp1$[1,2]="PU" ! change from CM per ERG 239551
Endif
if oh.h5[7]=16 and oh.OWHT[0]=1 let tmp1$="To Whse: "+OH.H5[11]
S7tmp$=S7tmp$+RTrim$(tmp1$) !status
if pgmname$="STKSTATUS"
	S7tmp$=S7tmp$+" - "+RTrim$(TName$)	! Cust name
Endif
S7tmp$=s7Tmp$+ fdel$			! status / name
S7tmp$=S7tmp$+Pdate$(OH.H0[10])+fdel$				! ship date
CNVTA = SL.OL3[3]  
x3 = XAMOUNT(CNVTU[],CNVTA,PR.pfu1[],PR.pfu2[],PR.A[],ctlc,FLAG)  
!S7tmp$=S7tmp$+LTrim$(SL.OL3[0]-SL.OL3[1] using Qmask$)+fdel$	! qty bo
!S7tmp$=S7tmp$+LTrim$(SL.OL3[3] using Qmask$)+fdel$	! qty bo (ACTUAL)
S7tmp$ = S7tmp$ + LTrim$(x3 Using Qmask$) + fdel$ ! qty bo (ACTUAL!) 

if pgmname$="STKSTATUS" 
	let S7tmp$=S7tmp$+Str$(OH.H5[7])+fdel$		! ORDER TYPE
endif
let s7tmp$=s7tmp$+"N"+fdel$ ! highlight not used on order yet
S7tmp$=S7tmp$+rdel$ ! add end of record
Call AddToStr(e$,s7$,S7tmp$)	 ! start building in s7
goto nextSordlot: ! get next sordlot(can be >1!)
GODone: ! finished
!If s7tmp$="" ! none found
	! evidently to show po's a line needs to be sent
!	S7tmp$="STOCK"+whichwhse using "&&"+"STOCK"+Fdel$
!	s7tmp$=s7tmp$+"SO"+fdel$+"0"+fdel$+"0"+fdel$+"0"+fdel$+"0"+fdel$ ! src,ord,cust,qo,qs
!	s7tmp$=s7tmp$+fdel$+"01/01/0000"+fdel$+"0"+fdel$ ! stat,date,qbo
!	if pgmname$="STKSTATUS" let S7tmp$=S7tmp$+"0"+fdel$ ! 
!	S7tmp$=S7tmp$+rdel$ ! add end of record
!	Call AddToStr(e$,s7$,S7tmp$)	 ! start building in s7
!Endif
Else
	Call suberr(e$,Spc(8),Spc(10),Msc$(2))
end Try

End Sub

!--------------------------------------------------------------------
Sub Section7(whichwhse)

Try
    chk4po=0 ! make sure
	Call GetONPO(PDC,PHC,PRR,whichwhse,qmask$,s7$,CHK4PO)
	
	! Call AddToStr(e$,s7$,tmp$)	 ! start building in s7
	
	call Get_OT16RQ(ODC,OHC,PRR,SLC,prod$,whichwhse,qmask$,S7$)
	
	Call GetOrders(ODC,OHC,PRR,SLC,prod$,whichwhse,qmask$,S7$)
	
	! Call AddToStr(e$,s7$,tmp$)	 ! start building in s7
	

	!"LotId"+fdel$+"HD"+fdel$+"SOPO"+fdel$+"CustVend"+fdel$+"QtyOnOrder"+fdel$+"ShipRecv"+fdel$+"Status"+fdel$+"ShipDateDueDate"+fdel$+"QtyOnBO"+fdel$+rdel$

Else
	Call suberr(e$,Spc(8),Spc(10),Msc$(2))
end Try

End Sub
!--------------------------------------------------------------------
Sub Get_OT16RQ(ODC,OHC,PRR,SLC,prod$,whichwhse,qmask$,S7$)
! we get unauth ot16 requests and auth to whse ot16
Dim OH. As ORDH
Dim OD. As ORDD
Dim SL. As SORDLOT

Dim SLK$[60],OHK$[20],ODK$[20],ORDSTATUS$[100,20],whse$[2],temp$[20]
Dim S7tmp$[1000],src$[10],3%

Try
Declare External Function PDate$

dim bsdel$[20],esdel$[20],rdel$[20],fdel$[20],e$[500] ! rstr$[100],e$[500]
!
call env(1,"BSDEL",bsdel$)
call env(1,"ESDEL",esdel$)
call env(1,"RDEL",rdel$)
call env(1,"FDEL",fdel$)
!
ordStatus$[1] ="ORD ENTERED"            
ordStatus$[2] ="ORD PRINTED"            
ordStatus$[3] ="ORD REGISTERED"         
ordStatus$[4] ="READY TO INVOICE"               
ordStatus$[5] ="INV ENTERED"  
ordStatus$[6] ="INV PRINTED"
ordStatus$[7] ="INV REGISTERED" 
ordStatus$[9] ="CM ENTERED"
ordStatus$[10]="CM PRINTED"
ordStatus$[11]="CM REGISTERED"
ordstatus$[40]="WORK ORDER"
OrdStatus$[41]="DEBIT MEMO"
OrdStatus$[42]="IntCo Transfer"
Ordstatus$[58]="POS BEING PKT"
OrdStatus$[59]="POS ON HOLD"
ordStatus$[90]="ORD IN PROCESS"
ordStatus$[91]="ORD IN EDIT"         
ordStatus$[92]="ORD IN JOURNAL"
ordStatus$[93]="CM IN JOURNAL"
ORDSTATUS$[94]="POS IN PROCESS"
ordstatus$[95]="SERP IN PROCESS"
ORDSTATUS$[97]="CM IN PROCESS"
Slk$=" ",slk$
SLK$=PRR Using "######"
rol16_loop: ! loop thru prod
Search #ODC,3,2;slk$,OLR,E
if E goto OT16GDone
X3=slk$[1,6] \ if x3<>PRR goto OT16GDone ! 
read record #ODC,OLR,0;od.;
! try for header
for st=1 to 7
       let OHK$[1,2]=st using "##"
	   let OHK$[3,8]=od.l2[1] using "######"
	   search #OHC,2,1;ohk$,ohr,e
	   if not(e) ! found it
		read record #OHC,OHR,0;OH.;
		if oh.h5[7]<>16 goto ROL16_Loop ! only ot 16!!
		! so we need any req same whse and auth to whse only
		If OD.L4[3]<1 Or OD.L4[3]>99 Let OD.L4[3]=OH.H4[2]
		if od.l4[3]<>whichwhse and whichwhse<>oh.h5[11] goto ROL16_loop ! not whse we want
		if OH.OWHT[0]=0 or (OH.OWHT[0]=1 and whichwhse=OH.H5[11]) ! not auth or auth & = to
		let tname$=" ",tname$
		if OH.H0[4]>0
			let k9$=OH.H0[4] using "######"
			search #cmc,2,1;k9$,r[7],E
			if not(e)
				mat read #cmc,r[7],30;tname$;
			Endif
		Endif
		! if pgmname$="STKSTATUS" clear tname$ ! can't handle it?
		! send as po type
		!"LotId"+fdel$+"HD"+fdel$+"SOPO"+fdel$+"CustVend"+fdel$+"QtyOnOrder"+fdel$+"ShipRecv"+fdel$+"Status"+fdel$+"ShipDateDueDate"+fdel$+"QtyOnBO"+fdel$+rdel$
		!S7tmp$="UNAPO"+Trim$(Str$(whichwhse))+fdel$
		let s7tmp$="STOCK"+whichwhse using "&&"+"STOCK"+Fdel$
		!if oh.owht[0]=1 let s7tmp$="STOCK"+whichwhse using "&&"+"STOCK"+Fdel$
		if oh.owht[0]=0 let temp$="RQ" Else let temp$="TR"
		if whichwhse=oh.h5[11] let temp$=temp$+"+" else let temp$=temp$+"-"
		s7tmp$=s7tmp$+temp$+fdel$
		S7tmp$=S7tmp$+RTrim$(Str$(OH.H0[7]))+"-"+Str$(OD.L3[2]) +fdel$
		S7tmp$=S7tmp$+LTrim$(OH.H0[4] using "######") ! cust #
		if pgmname$<>"STKSTATUS" ! on stockstatus causes a web error?
			S7tmp$=S7tmp$+" "+RTrim$(TName$)
		Endif
		S7tmp$=S7tmp$+fdel$	! cust / name
		S7tmp$=S7tmp$+LTrim$(OD.L7[2] using Qmask$)+fdel$	! qty ord
		S7tmp$=S7tmp$+LTrim$(OD.L7[4] using Qmask$)+fdel$	! qty rcv
		if whichwhse=od.l4[3] let temp$="To Whse: "+Str$(oh.h5[11])
		if whichwhse=oh.h5[11] let temp$="From Whse: "+str$(od.l4[3])
		S7tmp$=S7tmp$+temp$ ! + fdel$			! status
		if pgmname$="STKSTATUS" ! on stockstatus causes a web error?
			S7tmp$=S7tmp$+" - "+RTrim$(TName$)
		Endif
		S7tmp$=S7tmp$+fdel$	! status / name
		S7tmp$=S7tmp$+Pdate$(OH.H0[10])+fdel$				! due date
		S7tmp$=S7tmp$+LTrim$(OD.L7[3] using Qmask$)+fdel$	! qty bo
		if pgmname$="STKSTATUS" 
			let S7tmp$=s7tmp$+Str$(oh.h5[7])+fdel$ ! order type (would be 0 for whse?)
		rem	LET S7TMP$=S7TMP$+"N"+fdel$
		endif
		let tmp1$="N" ! highlight - not used for warehouse orders
		let s7tmp$=s7tmp$+tmp1$+fdel$
		S7tmp$=S7tmp$+rdel$ ! add eor
		Call AddToStr(e$,s7$,S7tmp$)	 ! start building in s7
		Endif ! of is what we want
		St=99 ! so loop is done
	   Endif ! of found order
Next St
goto ROL16_loop
OT16GDone: ! not found or diff - we're done
Else
	Call suberr(e$,Spc(8),Spc(10),Msc$(2))
end Try

End Sub
!--------------------------------------------------------------------

External Function GetUMFactor(unit,PFU1[],PFU2[])
! using um recs - try for factor of um
Declare External Sub suberr
Try
	Dim 3%,factor,x,e$[500]
	factor=1  ! default for base ! and start at 0
	Do Until pfu1[x]=unit or x>7 ! >6 means not found!
		x=x+1
	Loop
	If x>=1 and x<=7 let factor=pfu2[x-1] ! limit is 0-6
Else
	Call suberr(e$,Spc(8),Spc(10),Msc$(2))
end Try
End Function factor
!--------------------------------------------------------------------
Sub GET_OT15TOT(whichwhse,PRR,OTYPTOT[])

Try
	DIM S1$[60],TMPK1$[60]
	OTYPTOT[0]=0;OTYPTOT[1]=0;otyptot[2]=0
	whse=whichwhse
	IF PRR>0 ! can't on bad prod
		S1$=" ",S1$
		S1$[1,6]=PRR using "######"
		do
			search #ODC,3,2;s1$,ODR,E
			if e exit do
			x2=s1$[1,6] \ if x2<>prr exit do
			Read Record #ODC,ODR,0;OD.;
			!if od.L3[1]=1 and od.l2[0]=11
			  for x1=1 to 99
				if x1>10 and x1<50 let x1=50
				tmpk1$=" ",tmpk1$
				tmpk1$[1,2]=x1 using "##"
				tmpk1$[3]=od.l2[1] using "######"
				search #ohc,2,1;tmpk1$,OHR,E
				if not(e)
					Read Record #OHC,OHR; OH.;
					if whse if whse<>oh.h4[2] goto rolnloop ! diff whse
					if oh.h5[7]=15 and not(oh.h0[5]) ! ot 15
						otyptot[2]=otyptot[2]+(od.L7[2]-od.L7[4]-od.L7[0])
					endif
					IF od.l3[1]=1 and od.l2[0]=11 otyptot[0]=otyptot[0]+od.l7[4] ! all otypes
					if oh.h5[7]=5 ! futures
						otyptot[1]=otyptot[1]+(od.L7[2]-od.L7[0])
					endif
				Else
			  next x1			
				endif
			!endif ! update stk=Y
		rolnloop: ! 
		loop
	endif ! of only valid prodrecs
	! done 
Else
	Call suberr(e$,Spc(8),Spc(10),Msc$(2))
end Try

End Sub
!--------------------------------------------------------------------
FUNCTION getqtytrans(whichwhse,prr)
! get total qty on transfer for whse / product - we'll ignore tranh / TRANL files
 Try
	qtytrans=0
	Dim OH. As ORDH
	Dim OD. As ORDD
	Dim SL. As SORDLOT

	Dim SLK$[60],OHK$[20],ODK$[20],ORDSTATUS$[100,20],whse$[2],temp$[20]
	Dim S7tmp$[1000],src$[10],3%
	Slk$=" ",slk$
	SLK$=PRR Using "######"
	gtrol16_loop: ! loop thru prod
	Search #ODC,3,2;slk$,OLR,E
	if E goto GTOT16GDone
	X3=slk$[1,6] \ if x3<>PRR goto GTOT16GDone ! 
	read record #ODC,OLR,0;od.;
	! try for header
	for st=1 to 7
       let OHK$[1,2]=st using "##"
	   let OHK$[3,8]=od.l2[1] using "######"
	   search #OHC,2,1;ohk$,ohr,e
	   if not(e) ! found it
		read record #OHC,OHR,0;OH.;
		if oh.h5[7]<>16 goto GTROL16_Loop ! only ot 16!!
		! so we need any req same whse and auth to whse only
		If OD.L4[3]<1 Or OD.L4[3]>99 Let OD.L4[3]=OH.H4[2]
		if od.l4[3]<>whichwhse and whichwhse<>oh.h5[11] goto GTROL16_loop ! not whse we want
		if (OH.OWHT[0]=1 and whichwhse=OH.H5[11]) ! was OH.OWHT[0]=0 or ! not auth or auth & = to
			x1=-1 \ if whichwhse=OH.H5[11] let x1=1
			qtytrans=qtytrans+(X1*(OD.L7[2]-OD.L7[0])) ! as 369/397 do it
		Endif
		st=9
	   Endif ! of found header
	Next st
	goto GTROL16_loop
	GTOT16Gdone: ! finished
 Else
	Call suberr(e$,Spc(8),Spc(10),Msc$(2))
end Try
End Function qtytrans
!-----------------------------------------------------------------------------
Function chk_prd_loc(whichwhse,prod$,loc$)
! return 0 or 1 for if its primary
  Try
	Dim k20$[40]
	Dim 1%,PL1[1]
	Dim 3%,Rec_prodloc
	LET K20$=" ",K20$
	LET K20$[1,12]=prod$
	LET K20$[13,14]=whichwhse USING "##"
	LET K20$[15,20]=LOC$[1,6]
	LET PRIM_LOC=0
	SEARCH #BDC,2,1;K20$,REC_PRODLOC,E
	IF NOT(E)
	  MAT  READ #BDC,REC_PRODLOC,18;PL1;
	  IF PL1[1] LET PRIM_LOC=1 ELSE  LET PRIM_LOC=0
	ENDIF

  Else
	Call suberr(e$,Spc(8),Spc(10),Msc$(2))
end Try
End Function prim_loc
!-----------------------------------------------------------------------------
