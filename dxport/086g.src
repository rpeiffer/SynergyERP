! >>> Program 086g
!
! description 086g - PRODUCT CONTRACT LISTING
! loadsave -w -n 100,10 -o prog/dxport/086g.dl4 src/086g.src
!
! 1.0 mm/dd/yyyy change??
!
include "src/copyright.inc" ! dx

Rem BEDIT Version: 2.3 OBJECT CODE     Created: MAR 13, 2012  17:18:23
Rem /w2/papermaster/r2005//usr/acct/dave/work/custom/xrev9/mx086g.src (univ2) [dave] {18343}
Rem  Copyright (c) 2012 Universal Business Systems, Inc.
Rem    **** ALL CHANGES MUST BE MADE IN SOURCE!!! ****
Rem
!
Declare Intrinsic Sub DateToJulian,FindF,InpBuf,String,VerifyDate,Time,Logic
Declare Intrinsic Sub FormatDate
Declare Intrinsic Sub JulianToDate
Declare Intrinsic Sub dxopen,dxget,dxset,dxclose,dxsave,getglobals
!Option Default Dialect IRIS1
Declare Intrinsic sub programdump,env
Declare Intrinsic function findchannel
! external libs for subs/functions
External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus
Declare External Function getmsg$,expandarray
External Lib "ubsfunc.dl4"
Declare External Sub UTMonths
Declare External Function getuidrec,getuidinfo$
Declare External Function OpenFile
External Lib "libprice.lib"       
Declare External Sub SysPriceCalc 
External Lib "librebates.lib"  
Declare External Sub rebates   

!
!!Option Default Dialect IRIS1
Try 
Rem task 10386 GTI customer contract listing
Com A$[156],HZ$[90],PR_A2$[30],C1$[32],PSN$[20],U3$[60]
Com PRFLG$[10],PRMKUPTYP$[4],PIC$[50],PRIML$[12]
Com 1%,LLC,PFTB[3],PFU1[20],LM[1],UPCT,PR_PO[1]
Com 1%,PRBASE,PRPARC2[3],PRD1[4],AGEDAY
Com 2%,A2,A3[2],B[24],PR_C4[10],PFCO[3],PLC[3],PSN[1],U2,U4[1]
Com 2%,STK[2],FDT[1],PRMKUP[3],PRD0[2]
Com 3%,A1[7],A[33],PF_LOAD2,PFU2[6],PLV[1],PRPARC[3],U3,PFN[1]
Com 3%,LBSORD,FUT[1],PRREDI[1],PRD2[3],PRD3
!If Err 0 Gosub ERR_ESCAPE
Dim A3$[22],BT$[20],U2$[60],A2$[30],A1$[142]
Dim 2%,A0[3],C1[12],REC,CSC3[1]
Dim 1%,S0[20],SUB_,SZN,C7[4],C0,C2[2],C8,C11[2]
Dim 3%,C4[6],C10[5],CFIN[8],U1,C9,C5[5],C6[9],C12[1]
Dim 1%,RCN$[70],cpi
Dim 3%,RCN3[3]
Dim 3%,S1[12,3]
Dim 1%,RB$[12],SPUDA2$[30]
Dim 1%,RBUM[1],RB[2],RBWH,RBL1[1]
Dim 2%,RB1[5],RBMIN,RBCOM
Dim 3%,RB3[6],RBN,RB5[2]
Dim 1%,P$[12],SPUDA2$[30]
Dim 1%,SPCUM[1],C3[2],SPWH,SPBRK[1]
Dim 2%,SPC1[5],SPMIN,SPCOM
Dim 3%,SPC4[6],SPCN,SPC5[4]
Dim 1%,SPC6[4],APTYPE[8],ABTYPE[8],AMTYPE[8],3%,APFACT[8],AMQTY[8]
Dim 1%,M5[3],B3,PM5[5,4]
Dim 2%,M6[3]
Dim 3%,B1[9,2],REBATE_ARGS[10,4],PM6[5,3]
Dim BRD$[100]
Dim 1%,CCD$[14],outflag
Dim 1%,CNVTU[2],PT[37]
Dim J$[70],J0$[18],J1$[70],J2$[20],J3$[40],J4$[60],J5$[80],J7$[80],J9$[70]
Dim X$[100],1%,J0,J2,J3,J4,J5,J6[1],J7[2],J8,X1[9],U5$[50]
Dim 2%,J9[9],X2[9],4%,J1
Dim K2$[50],K3$[50],K4$[50],K5$[50],K6$[50],HOLD_PROD$[12]
Dim K9$[50],FILE$[16],F1$[80],F2$[80],K$[50],K99$[50]
Dim DBASE$[10],DCOST$[10],DDESC$[75],DTYPE$[75],P61$[256],P60$[50],P9$[50]
Dim CUSTOM_CUSTOMER$[30],UNIT$[4]
Dim 2%,RPT[5],SYSDATE,Q0[1],CST[2],BPROD$[12],EPROD$[12],PRTEXP,STATUS
Dim 3%,CNVTA,AMOUNT,LCO[1],3%,FLEPTR[20,1],SPECS[30],MSGDESC$[150]
Dim 3%,COID,CONM$[30],DATE$[8],TME$[30],DATE1$[10],DATE2$[10],TYPE$[5]
Dim PMASK$[12],MASK5$[5],UNIT$[4],K13$[50],HOLD13$[50],RETVAL$[512],COMM$[50]
DIM DLOG$[50],DBLOG$[50]
Dim 3%!
Dim DEV$[20],HM$[30],nextblockid$[8],Message$[600],WebStr$[600]
Dim e$[500],buttonlist$[5,50],nextlist$[5,100] ! dx error handling variables
Dim tmp$[1500],tmp1$[200],blockid$[100],msg$[100],rstr$[2000]
Dim action$[30],options$[30],userid$[8],3%,fdel$[10],bsdel$[10],esdel$[10],rdel$[10]
dim groupid$[1]
!!! check this
Dim b$[200]!

!call dxopen() ! needed?
! Call getsession(e$,CTLC,options$,action$,userid$,intCO,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$)
 Call getglobals("blockx",0,blockid$,CTLC,options$,action$,userid$,intCO,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$)!

COID = intCO ! Int((Spc(5) - Int(Spc(5) / 16384) * 16384) / 64)
Def FNR(H) = Int(Abs(H) * 100 + .5) * .01 * Sgn(H)
Def FNN(H) = Int(Abs(H) * 10 ^ Q0[1] + .5) * 10 ^ - Q0[1] * Sgn(H)
Def FNT(H) = Int(Abs(H) * 10 ^ Q0[1]) * 10 ^ - Q0[1] * Sgn(H)
Def FNV(H) = Int(Abs(H) * 10 ^ Q0[1] + .9999999) * 10 ^ - Q0[1] * Sgn(H)
Def FNU(H) = Int(Abs(H) + Sgn(Fra(Abs(H)))) * Sgn(H)
Def FNF(H) = Int((Abs(H) * 20 + .5) * Sgn(H)) / 20

! printer or browser
j8 = 0
If Err 0 Let j8 = Spc(8)
try
	J9 = Chf(0) 
else
	let j8=99
end try
!If Err 0 Gosub ERR_TRAP
RPT[1] = 60;RPT[2] = 0;SCRN = 0 ! page len/lines/scrn 
for ctr=1 to 99
	If ctr<>9
		Try Close #ctr Else Rem
	endif
next ctr
COID=IntCo 
tRY Close #1 eLSE rEM ! getsession open cntrl# as READONLY
J$="cntrl/cntrl"+Str$(COID)
Open #1,J$
eflag=0
returnstatus=1


For K = 2 To 19
  Read K1 \ If K1 = -1 Goto L_280
  Read #1,88,Abs(K1);FILE$;
  Ropen #K,FILE$
L_280: Next K
Data "1808","1792","2880","1936","1728","1712","1952","-1","-1","304","320","2016","1744","1120","752"
Data "1376","1744","2288"
LET FILE$="2/SPRICEMARK"+STR$(COID)
ropen #10,file$
Mat Read #1,3,0;CONM$;
Mat Read #1,3,172;SYSDATE;
Mat Read #1,19,50;P9$; \ Mat Read #1,60,50;P60$;
Mat Read #1,61,0;P61$;
Mat Read #1,115,40;Q0; \ If Not(Q0[1]) Let Q0[1] = 2
Mat Read #1,115,60;CUSTOM_CUSTOMER$;
MASK5$ = "#####";PMASK$ = "-----#.",MASK5$[1,Q0[1]]


! Customer Range
call dxget("scust",tmp$) \cst[1]=tmp$ ! starting salesman
Call dxget("ecust",tmp$)
if rtrim$(tmp$)=""
	let cst[2]=999999
else
	let cst[2]=tmp$ ! ending customer
endif
if cst[1]>cst[2]
	let message$=message$+"Ending Customer must be greater than Starting. "
	let eflag=eflag+1
endif
!!PRODUCT RANGE
call dxget("SPROD",tmp$)
let bprod$=ucase$(rtrim$(tmp$))+"            "
call dxget("EPROD",tmp$)
If tmp$ = ""
	Let eprod$ ="z",eprod$
else
	let eprod$=ucase$(rtrim$(tmp$))+"zzzzzzzzzzzz"
endif
if bprod$>eprod$
	let message$=message$+"Ending Product must be greater than Starting. "
	let eflag=eflag+1
endif
! print expired contracts

PRTEXP= 0
Call dxget("EXPIRED",tmp$)
if rtrim$(tmp$)<>"" 
	LET PRTEXP=1
endif
If j8<>0 ! browser
	! reserve for browser option 
	 tmp$="",fdel$,"",fdel$
	 tmp$=tmp$,rdel$
	Call addtostr(e$,rstr$,tmp$)
Endif
if eflag<>0 
	goto outend: ! errors have occured
endif

!!!! set channels
CH_SPECPRICE = 5
CH_CONTRACTH = 4
CH_PROD = 3
CH_CUST = 2
CH_CCODES = 6
CH_PRODMARK = 7
CH_BRKTBL = 8
CH_PMARK = 10
CH_RCONTRACTH = 11
CH_REBATEDTL = 12
CH_SLSCUR = 13
CH_PRWH = 14
CH_VENDTAG = 15
CH_PRTYPE = 16
CH_LASTPRICE = 17
CH_PRODWH = 18
CH_COMM = 19

BLD2NDSORT: Rem
try
	close #9
else
	! rem not openned
end try
If KSIZE < 20 Let KSIZE = 20
F1$ = Spc(6) Using "files/6/sortwork&&&#"
Call FindF(F1$,H1)
If H1<>0
	try
		Kill F1$
	else
		let eflag=eflag+1
		let message$="Error in Building Sort File "
		goto outend:
	end try
endif
F2$ = "[1:64] ",F1$
Try
	Build #9,F2$
else
	let eflag=eflag+1
	let message$="Error in Building Sort File "
	goto outend:
end TRY
Search #9,0,1;K$,KSIZE,E \ If E Gosub ERR_SEARCH
L1 = 1000 \ Search #9,0,0;K$,L1,E \ If E Gosub ERR_SEARCH
close #9
open #9,f1$
SORTCONTRACTS: Rem sort contracts by product by customer


STRTSORT: Rem GO
K5$ = " ",K5$
K4$ = " ",K4$
K9$ = " ",K9$
CONTRACTSORTLOOP: Rem
Search #CH_SPECPRICE,3,2;K5$,REC_SPECPRICE,E
If E Goto SORTDONE
If K5$[1,1] = "*" Goto CONTRACTSORTLOOP
If K5$[1,1] = "&" Goto CONTRACTSORTLOOP
If K5$[1,1] = "#" Goto CONTRACTSORTLOOP
IF K5$[1,1]="-" GOTO contractsortloop:
If K5$[13,13] <> "C" Goto CONTRACTSORTLOOP
Mat Read #CH_SPECPRICE,REC_SPECPRICE,0;P$
Mat Read #CH_SPECPRICE,REC_SPECPRICE,12;SPC1
Mat Read #CH_SPECPRICE,REC_SPECPRICE,36;SPCUM
Mat Read #CH_SPECPRICE,REC_SPECPRICE,40;C3
Mat Read #CH_SPECPRICE,REC_SPECPRICE,46;SPC4
Mat Read #CH_SPECPRICE,REC_SPECPRICE,88;SPUDA2$
Mat Read #CH_SPECPRICE,REC_SPECPRICE,118;SPWH
Mat Read #CH_SPECPRICE,REC_SPECPRICE,120;SPCN
Mat Read #CH_SPECPRICE,REC_SPECPRICE,126;SPBRK
Mat Read #CH_SPECPRICE,REC_SPECPRICE,130;SPMIN
Mat Read #CH_SPECPRICE,REC_SPECPRICE,134;SPCOM
Mat Read #CH_SPECPRICE,REC_SPECPRICE,138;SPC5
K4$ = " ",K4$
If P$ < BPROD$ Goto CONTRACTSORTLOOP
If P$ > EPROD$ Goto CONTRACTSORTLOOP
If PRTEXP = 0
  If SYSDATE < SPC1[2] Goto CONTRACTSORTLOOP
  If SPC1[4]<>0 AND SYSDATE > SPC1[4] Goto CONTRACTSORTLOOP
End If 
CONTACTNO = K5$[14,18]
K4$[1,6] = CONTACTNO Using "C#####"
CONTHEADERLOOP: Rem
Search #CH_CONTRACTH,3,3;K4$,REC_CONTRACTH,E
If E Goto CONTRACTSORTLOOP
mat read #CH_Contracth,Rec_Contracth,50;cpi;
if cpi goto contractsortloop:
If K5$[13,18] <> K4$[1,6] Goto CONTRACTSORTLOOP
CUSTCODE = K4$[7,12]
If CUSTCODE < CST[1] Goto CONTHEADERLOOP
If CUSTCODE > CST[2] Goto CONTHEADERLOOP
K9$ = " ",K9$
K9$[1,12] = P$[1,12]
K9$[13,18] = CUSTCODE Using "######"
K9$[19,24] = CONTACTNO Using "######"
Search #9,4,1;K9$,REC_SPECPRICE,E
If E Gosub ERR_SEARCH
let sortrec=sortrec+1
if not(outflag) and sortrec>50000
	Call addtostr(e$,rstr$,esdel$) !end section
	 Message$="Report is still processing.  Check myreports later. "
	 call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	 call addToStr(e$,rstr$,webstr$)
	 call setoutput(e$,rstr$)
  ! Call setoutput(e$,rstr$,2) !2 fl
	let outflag=99
endif
Goto CONTHEADERLOOP
SORTDONE: Rem
PRNT_REPORT: Rem print report
! Print @0,22;'CE';"PRINTING, PLEASE WAIT  "
RPT[2] = 0;RPT[0] = 90
K9$ = " ",K9$
FIRST = 1
PRNT_ITEM = 1
HOLD_PROD$ = " ",HOLD_PROD$
MAIN_LOOP: Rem loopy
Search #9,3,1;K9$,REC_SPECPRICE,E
If E<>0
   Goto OUTEND
End If 
Mat Read #CH_SPECPRICE,REC_SPECPRICE,0;P$
Mat Read #CH_SPECPRICE,REC_SPECPRICE,12;SPC1
Mat Read #CH_SPECPRICE,REC_SPECPRICE,36;SPCUM
Mat Read #CH_SPECPRICE,REC_SPECPRICE,40;C3
Mat Read #CH_SPECPRICE,REC_SPECPRICE,46;SPC4
Mat Read #CH_SPECPRICE,REC_SPECPRICE,88;SPUDA2$
Mat Read #CH_SPECPRICE,REC_SPECPRICE,118;SPWH
Mat Read #CH_SPECPRICE,REC_SPECPRICE,120;SPCN
Mat Read #CH_SPECPRICE,REC_SPECPRICE,126;SPBRK
Mat Read #CH_SPECPRICE,REC_SPECPRICE,130;SPMIN
Mat Read #CH_SPECPRICE,REC_SPECPRICE,134;SPCOM
Mat Read #CH_SPECPRICE,REC_SPECPRICE,138;SPC5
Mat Read #CH_SPECPRICE,REC_SPECPRICE,168;SPC6;
Mat Read #CH_SPECPRICE,REC_SPECPRICE,178;APTYPE;
Mat Read #CH_SPECPRICE,REC_SPECPRICE,196;ABTYPE;
Mat Read #CH_SPECPRICE,REC_SPECPRICE,214;AMTYPE;
Mat Read #CH_SPECPRICE,REC_SPECPRICE,232;APFACT;
Mat Read #CH_SPECPRICE,REC_SPECPRICE,286;AMQTY;
If PRNT_ITEM = 0
  If HOLD_PROD$[1,12] <> P$[1,12] Let PRNT_ITEM = 1
End If 
HOLD_PROD$[1,12] = P$[1,12]
K3$ = " ",K3$
K3$[1,12] = P$[1,12]
Search #3,2,1;K3$,REC_PROD,E
If E = 1 Goto MAIN_LOOP
If E Gosub ERR_SEARCH
Mat Read #CH_PROD,REC_PROD,0;A$
Mat Read #CH_PROD,REC_PROD,156;B
Mat Read #CH_PROD,REC_PROD,256;A
Mat Read #CH_PROD,REC_PROD,460;A1
Mat Read #CH_PROD,REC_PROD,508;A2
Mat Read #CH_PROD,REC_PROD,512;PFU1
Mat Read #CH_PROD,REC_PROD,554;PFU2
Mat Read #CH_PROD,REC_PROD,596;PRPARC
Mat Read #CH_PROD,REC_PROD,620;LM
Mat Read #CH_PROD,REC_PROD,624;PR_PO
Mat Read #CH_PROD,REC_PROD,628;AGEDAY
Read #CH_PROD,REC_PROD,630;LLC
Mat Read #CH_PROD,REC_PROD,632;PSN$
Mat Read #CH_PROD,REC_PROD,652;PSN
Mat Read #CH_PROD,REC_PROD,660;U2
Mat Read #CH_PROD,REC_PROD,664;LBSORD
Mat Read #CH_PROD,REC_PROD,670;U4
Read #CH_PROD,REC_PROD,678;U3
Mat Read #CH_PROD,REC_PROD,684;U3$
Mat Read #CH_PROD,REC_PROD,744;HZ$
Mat Read #CH_PROD,REC_PROD,834;A3
Mat Read #CH_PROD,REC_PROD,846;PFTB
Read #CH_PROD,REC_PROD,854;UPCT
Mat Read #CH_PROD,REC_PROD,856;C1$
Mat Read #CH_PROD,REC_PROD,894;PR_C4
Read #CH_PROD,REC_PROD,938;PF_LOAD2
Mat Read #CH_PROD,REC_PROD,944;PR_A2$
Mat Read #CH_PROD,REC_PROD,974;PFCO
Mat Read #CH_PROD,REC_PROD,990;PLV
Mat Read #CH_PROD,REC_PROD,1002;PLC
Mat Read #CH_PROD,REC_PROD,1018;PFN
Mat Read #CH_PROD,REC_PROD,1030;STK
Mat Read #CH_PROD,REC_PROD,1048;FDT
Mat Read #CH_PROD,REC_PROD,1056;PRFLG$
Mat Read #CH_PROD,REC_PROD,1066;PRBASE
Mat Read #CH_PROD,REC_PROD,1068;PRMKUP
Mat Read #CH_PROD,REC_PROD,1084;PRMKUPTYP$
Mat Read #CH_PROD,REC_PROD,1088;FUT
Mat Read #CH_PROD,REC_PROD,1100;PRPARC2
Mat Read #CH_PROD,REC_PROD,1108;PRREDI
Mat Read #CH_PROD,REC_PROD,1120;PIC$
Mat Read #CH_PROD,REC_PROD,1270;PRD0
Mat Read #CH_PROD,REC_PROD,1282;PRIML$
Mat Read #CH_PROD,REC_PROD,1294;PRD1
Mat Read #CH_PROD,REC_PROD,1304;PRD2
Mat Read #CH_PROD,REC_PROD,1428;PRD3
COMM$ = A$[152,155]
Search #CH_COMM,2,1;COMM$,REC_COMM,E \ If E Gosub ERR_SEARCH
PTYPE = C1[7]
DFT_COST = 0
If PTYPE
  Mat Read #5,PTYPE,28;PT;
  DFT_COST = PT[0]
End If 
If Not(DFT_COST) Let DFT_COST = P60$[29,29]
K2$ = " ",K2$
K2$[1,6] = K9$[13,18]
Search #2,2,1;K2$,REC_CUST,E
If E Gosub ERR_SEARCH
Mat Read #CH_CUST,REC_CUST,0;A1$
Mat Read #CH_CUST,REC_CUST,142;C1
Mat Read #CH_CUST,REC_CUST,194;C2
Mat Read #CH_CUST,REC_CUST,200;CSC3
Mat Read #CH_CUST,REC_CUST,208;C0
Mat Read #CH_CUST,REC_CUST,210;C4
Mat Read #CH_CUST,REC_CUST,252;C5
Mat Read #CH_CUST,REC_CUST,288;C6
Mat Read #CH_CUST,REC_CUST,348;A2$
Mat Read #CH_CUST,REC_CUST,378;C7
Mat Read #CH_CUST,REC_CUST,388;A3$
Mat Read #CH_CUST,REC_CUST,410;C8
Mat Read #CH_CUST,REC_CUST,412;C9
Mat Read #CH_CUST,REC_CUST,418;SUB_
Mat Read #CH_CUST,REC_CUST,420;U1
Mat Read #CH_CUST,REC_CUST,426;U2$
Mat Read #CH_CUST,REC_CUST,486;A0
Mat Read #CH_CUST,REC_CUST,502;S0
Mat Read #CH_CUST,REC_CUST,544;CFIN
Mat Read #CH_CUST,REC_CUST,598;SZN
Mat Read #CH_CUST,REC_CUST,600;BT$
Mat Read #CH_CUST,REC_CUST,620;REC
Mat Read #CH_CUST,REC_CUST,624;C10
Mat Read #CH_CUST,REC_CUST,660;C11
Mat Read #CH_CUST,REC_CUST,668;C12
RBCOST = 0
RB1[2] = 0
UNITPRICE = 0
SPSLCOST = 0
COST = 0
PTYPE = C1[7]
DFT_COST = 0
If PTYPE
  Mat Read #5,PTYPE,28;PT;
  DFT_COST = PT[0]
End If 
If Not(DFT_COST) Let DFT_COST = P60$[29,29]
Gosub SETCOST
Gosub CALCPRICE
Gosub GETPRICE
If UN[1] = 0 Let UN[1] = PFU1[11]
CNVTU[0] = 0;CNVTU[1] = UN[1];CNVTU[2] = 2;CNVTA = PCALL_COST
Gosub CONVERT
COST = AMOUNT
CNVTU[0] = 0;CNVTU[1] = UN[2];CNVTU[2] = 2;CNVTA = UNITPRICE
Gosub CONVERT
UNITPRICE = AMOUNT
CNVTU[0] = 0;CNVTU[1] = UN[1];CNVTU[2] = 2;CNVTA = SPSLCOST
Gosub CONVERT
SPSLCOST = AMOUNT
Gosub PRNT_LINE
Goto MAIN_LOOP
PRNT_LINE: Rem
if j8<>0 return !!!!! no browser option set-up
let totrec=totrec+1
if not(outflag) and (totrec+sortrec)>15000
	Call addtostr(e$,rstr$,esdel$) !end section
	 Message$="Report is still processing.  Check myreports later. "
	 call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	 call addToStr(e$,rstr$,webstr$)
	 call setoutput(e$,rstr$)
  ! Call setoutput(e$,rstr$,2) !2 fl
	let outflag=99
endif
Gosub PRNT_HEADER
If PRNT_ITEM
  If Not(FIRST)
    Print #0;" "
    RPT[0] = RPT[0] + 1
  End If 
  FIRST = 0
  Print #0; Tab 5;P$[1,12];
  Print #0; Tab 20;A$[9,38];" ";A$[63,92]
  RPT[0] = RPT[0] + 1
  PRNT_ITEM = 0
End If 
TYPE$ = " ",TYPE$
If UNITPRICE
  If COSTORG = 10 Or COSTORG = 11
    TYPE$ = "B"
  End If 
End If 
If UNITPRICE<>0
	If COSTORG <> 10 And COSTORG <> 11
		TYPE$ = "P"
  End If 
End If 
If Not(UNITPRICE)
  If COSTORG = 10 Or COSTORG = 11
    TYPE$ = "C"
  End If 
End If 
If Not(UNITPRICE)
  !If COSTORG <> 10 And COSTORG <> 11
  IF C3[0]=7 ! if costorg<>10 and costorg<>11 
    TYPE$ = "F"
  End If 
End If 
Print #0; Tab 0;TYPE$[1,1];
Print #0; Using "######.## "; Tab 5;COST;
UNIT$ = "ERR!"
If UN[1] > 0
  Mat Read #CH_CCODES,UN[1],10;UNIT$;
End If 
If UN[1] = -1 Let UNIT$ = "CWT "
If SPSLCOST Print #0;UNIT$;
If SPC5[4] = 4 Or COSTORG = 10
  DATE1$ = RB1[2] Using "&&&&&#"
Else 
  DATE1$ = SPC1[2] Using "&&&&&#"
End If 
Call FormatDate(DATE1$,DATE2$,E,0)
If SPSLCOST Print #0; Tab 18;DATE2$;
Print #0; Using "######.## "; Tab 27;UNITPRICE;
UNIT$ = "ERR!"
If UN[2] > 0
  Mat Read #CH_CCODES,UN[2],10;UNIT$;
End If 
If UN[2] = -1 Let UNIT$ = "CWT "
If UNITPRICE Print #0;UNIT$;
DATE1$ = SPC1[2] Using "&&&&&#"
Call FormatDate(DATE1$,DATE2$,E,0)
Print #0; Tab 42;DATE2$;
If SPC1[4] = 0 Or SPC1[4] = 999999
  DATE2$ = "None"
Else 
  DATE1$ = SPC1[4] Using "&&&&&#"
  Call FormatDate(DATE1$,DATE2$,E,0)
End If 
Print #0; Tab 51;DATE2$;
Gosub GETSALES
Print #0; Using "######"; Tab 60;QYTD;
Print #0; Using "-----#.##"; Tab 67;DYTD;
Print #0; Using "###### "; Tab 77;C1[1];A1$[31,60];
Print #0; Using "### "; Tab 115;C1[2];
Print #0; Using "######";SPC1[0];
Print #0;" "
RPT[0] = RPT[0] + 1
Return 
PRNT_HEADER: Rem "report header
if j8<>0 return !!!!! no browser option set-up
let totrec=totrec+1
If RPT < RPT[1] Return 
If RPT[2] ! "after page 1
    Print #0;"\14\";
End If 
Print #0;""
RPT[2] = RPT[2] + 1
Print #0; Tab 1;"DATE: ";DATE$;
Print #0; Tab (Int(64 - (Len(CONM$) / 2)));CONM$;
Print #0; Tab 120;"PAGE: ";RPT[2]
Print #0;" -086G- ";
TME$ = "" \ Call Time(TME$)
Print #0;TME$;
Print #0; Tab 45;"P R O D U C T   C O N T R A C T   L I S T";
Print #0;" "
Print #0; Tab 19;"START"; Tab 42;"START"; Tab 52;" END"; Tab 62;"YTD"; Tab 70;"YTD"
Print #0; Tab 1;"TYPE"; Tab 9;"COST"; Tab 19;"DATE"; Tab 27;"PRICE "; Tab 43;"DATE"; Tab 52;"DATE";
Print #0; Tab 62;"QTY"; Tab 71;"SALES"; Tab 77;"CUSTOMER CODE NAME "; Tab 114;"SLSM";
Print #0; Tab 119;"CONTRACT"
RPT[0] = 5
Return 
CALCCOST: Rem
If WHSEPR ! "set cost to use
  If SPC5[4] = 1 Let BASE = W3[18]
  If SPC5[4] = 2 Let BASE = W3[17]
  If SPC5[4] = 3 Let BASE = W3[16]
  If SPC5[4] = 4 Let BASE = RBCOST
  If SPC5[4] = 5 Let BASE = W3[14]
Else 
  If SPC5[4] = 1 Let BASE = PR_C4[4]
  If SPC5[4] = 2 Let BASE = B[8]
  If SPC5[4] = 3 Let BASE = B[10]
  If SPC5[4] = 4 Let BASE = RBCOST
  If SPC5[4] = 5 Let BASE = PF_LOAD2
End If 
If SPC5[3] = 1 And BASE
  SPSLCOST = (BASE * ((100 + SPC5[1]) / 100))
End If 
If SPC5[3] = 2
  AMOUNT = 0
  If BASE
    CNVTU[0] = 0;CNVTU[1] = SPCUM[1];CNVTU[2] = 2;CNVTA = BASE
    Gosub CONVERT
  End If 
  If AMOUNT
    CNVTU[0] = SPCUM[1];CNVTU[1] = 0;CNVTU[2] = 2;CNVTA = (AMOUNT + SPC5[1])
    Gosub CONVERT
  End If 
  If AMOUNT Let SPSLCOST = AMOUNT
End If 
If SPC5[3] = 3 And SPC5[1]
  SPSLCOST = SPC5[1]
End If 
Return 
CALCPRICE: Rem calc price
Gosub SP_CHKREBATE
PROD = 99
REM FORCE QTY TO MIN
LET CNVTU[0]=c3[2];CNVTU[1]=0;CNVTU[2]=1;CNVTA= spc4[0]
GOSUB CONVERT:              
l7[2]=amount
SPNOTVALID = 0
If WHSEPR And SPWH And SPWH <> WHSE Let SPNOTVALID = 1
If SPNOTVALID Goto SP_EXIT
If SPC6[1] <> 1 And SPC6[1] <> 2 Let SPC6[1] = 1
MLVL = 0
For X = 0 To 8 \ If APTYPE[X] Let MLVL = 1 \ Next X
If MLVL ! has levels - find right one - if not use main (orig)
  Gosub MLVL_SPR
End If 
If SPC6[1] <> 1 And SPC6[1] <> 2 Let SPC6[1] = 1
If (C3[0] = 4 Or C3[0] = 5) And PR_C4[2] <> 2 Let SPNOTVALID = 1
If C3[2]
  UNIT = C3[2]
  Gosub CHECKUNIT
  If Not(UNIT) Let C3[2] = 0
  If SPC4[0] > 0 And SPC6[1] = 1 And Not(C3[2]) Let SPNOTVALID = 1
End If 
If PROD And SPC4[0] > 0 ! check min
  If SPC6[1] = 1 And C3[2] ! qty
    CNVTU[0] = 0;CNVTU[1] = C3[2];CNVTU[2] = 1;CNVTA = L7[2]
    Gosub CONVERT
    If AMOUNT < SPC4[0] Let SPNOTVALID = 1
  End If 
  If SPC6[1] = 2 And S3[4] < SPC4[0] Let SPNOTVALID = 1
End If 
If (Not(PROD)) And (Not(C3[2]))
  CNVTU[0] = 0;CNVTU[1] = PFU1[9];CNVTU[2] = 1;CNVTA = L7[2]
  Gosub CONVERT
  If SPC6[1] = 1 And AMOUNT < SPC4[0] Let SPNOTVALID = 1
  If SPC6[1] = 2 And S3[4] < SPC4[0] Let SPNOTVALID = 1
End If 
If SPNOTVALID Goto SP_EXIT
UNITPRICE = 0
SPJUMP = 0
UNIT = SPCUM[0]
Gosub CHECKUNIT
If Not(UNIT) Let SPCUM[0] = UN[1]
If Not(PROD) Let SPCUM[0] = PFU1[12]
UNIT = SPCUM[1]
Gosub CHECKUNIT
If Not(UNIT) Let SPCUM[1] = UN[2]
If Not(PROD) Let SPCUM[1] = PFU1[11]
If WHSEPR ! "set cost to use
  If SPC5[4] = 1 Let BASE = W3[18]
  If SPC5[4] = 2 Let BASE = W3[17]
  If SPC5[4] = 3 Let BASE = W3[16]
  If SPC5[4] = 4 Let BASE = RBCOST
  If SPC5[4] = 5 Let BASE = W3[14]
  If SPC5[4] = 6 Let BASE = WHMISC[2]
Else 
  If SPC5[4] = 1 Let BASE = PR_C4[4]
  If SPC5[4] = 2 Let BASE = B[8]
  If SPC5[4] = 3 Let BASE = B[10]
  If SPC5[4] = 4 Let BASE = RBCOST
  If SPC5[4] = 5 Let BASE = PF_LOAD2
  If SPC5[4] = 6 Let BASE = PRPARC[2]
End If 
If SPC5[3] = 1 And BASE
  SPSLCOST = (BASE * ((100 + SPC5[1]) / 100))
End If 
If SPC5[3] = 2
  AMOUNT = 0
  If BASE
    CNVTU[0] = 0;CNVTU[1] = SPCUM[1];CNVTU[2] = 2;CNVTA = BASE
    Gosub CONVERT
  End If 
  If AMOUNT
    CNVTU[0] = SPCUM[1];CNVTU[1] = 0;CNVTU[2] = 2;CNVTA = (AMOUNT + SPC5[1])
    Gosub CONVERT
  End If 
  If AMOUNT Let SPSLCOST = AMOUNT
End If 
If SPC5[3] = 3 And SPC5[1]
  SPSLCOST = SPC5[1]
  If Not(PROD)
    CNVTU[0] = SPCUM[1];CNVTU[1] = 0;CNVTU[2] = 2;CNVTA = SPSLCOST
    Gosub CONVERT
    SPSLCOST = AMOUNT
  End If 
End If 
If SPSLCOST And (Not(L5[1]) Or SPSLCOST < L5[1] Or P61$[21,21] = "Y" Or SPC1[1] = 1)
  COSTHOLD = SPSLCOST
Else 
  COSTHOLD = L5[1]
End If 
If SPC5[3] = 5
  SPSLCOST = 0;COSTHOLD = 0;L5[1] = 0;LCO[0] = 11
End If 
If COST2RBT And SPC5[2] And SPC5[2] < CST Let CST = SPC5[2]
OLM[4] = SPCOM
UNITPRICE = SPC5[0];BASEHOLD = UNITPRICE;DTYPE$ = "S/P "
If MLVL Let DTYPE$ = DTYPE$ + Str$(MLVL) + " "
DTYPE$ = DTYPE$ + "fixed price"
If PROD ! "single product s/p
  If Not(UNITSEQUAL)
    UN[1] = SPCUM[0];UNIT = UN[1]
  End If 
  UN[2] = SPCUM[1];UNIT = UN[2]
End If 
If Not(PROD) And C3[0] = 3 ! "fixed price for class
  CNVTU[0] = SPCUM[0];CNVTU[1] = 0;CNVTU[2] = 2;CNVTA = UNITPRICE
  If CNTRCHK <> 0
    If CUSTOM_CUSTOMER$[1,5] = "OMAHA" !
      CNVTU[0] = SPCUM[1]
    End If 
  End If 
  Gosub CONVERT
  UNITPRICE = AMOUNT;BASEHOLD = UNITPRICE
End If 
If Not(SPC5[0]) And (C3[0] = 4 Or C3[0] = 5) ! "jump
  UNITPRICE = -1;BASEHOLD = 0
  DTYPE$ = "S/P "
  If MLVL Let DTYPE$ = DTYPE$ + Str$(MLVL) + " "
  DTYPE$ = DTYPE$ + "10 bracket/"
  If C3[0] = 4
    DTYPE$ = DTYPE$,C3[1] Using "fixed level ##"," (table"
    DTYPE$ = DTYPE$,PR_C4[3] Using "###",")"
  Else 
    DTYPE$ = DTYPE$,C3[1] Using "## level jump"," (table"
    DTYPE$ = DTYPE$,PR_C4[3] Using "###",")"
  End If 
  Goto SP_EXIT
End If 
If C3[0] = 6 ! "jump
  UNITPRICE = -2;BASEHOLD = 0;SPJUMP = 9
  DTYPE$ = "S/P "
  If MLVL Let DTYPE$ = DTYPE$ + Str$(MLVL) + " "
  DTYPE$ = DTYPE$ + "matrix/",C3[1] Using "## level jump"
  DTYPE$ = DTYPE$," (table",B[22] Using "###",")"
  If SPC5[0] ! "plus markup/down
    DTYPE$ = DTYPE$,SPC5[0] Using " +###.###%"
  End If 
  Goto SP_EXIT
End If 
If (C3[0] = 1 Or C3[0] = 2 Or C3[0] = 8) Gosub GETBASE
If C3[0] <> 3 If C3[0] <> 7 ! "not a fixed price or free good
  If SPC5[0] And (C3[0] = 4 Or C3[0] = 5)
    Gosub GETTENBPRICE
    BASE = UNITPRICE;BASEHOLD = BASE;UNITPRICE = (BASE * ((100 + SPC5[0]) / 100))
    If UNITPRICE
      DTYPE$ = "S/P "
      If MLVL Let DTYPE$ = DTYPE$ + Str$(MLVL) + " "
      DTYPE$ = DTYPE$ + "10 bracket with markup (table"
      DTYPE$ = DTYPE$,PR_C4[3] Using "###",", bracket",BRACKET Using "##",")"
      DDESC$ = DDESC$,SPC5[0] Using " +###%"
    End If 
  End If 
  If C3[0] = 1
    UNITPRICE = (BASE * ((100 + SPC5[0]) / 100))
    CNVTU[0] = 0;CNVTU[1] = UN[1];CNVTU[2] = 2;CNVTA = BASEHOLD
    Gosub CONVERT
    DTYPE$ = "S/P " \ If MLVL Let DTYPE$ = DTYPE$ + Str$(MLVL) + " "
    DTYPE$ = DTYPE$ + "with % markup/markdown"
    If C3[1] <> 12
      DDESC$ = AMOUNT Using PMASK$," [",DBASE$,"]",SPC5[0] Using " +###.###%"
    Else 
      DDESC$ = DDESC$,SPC5[0] Using " +###.###%"
    End If 
  End If 
  If C3[0] = 2
    If SPC5[0] = 100 Let SPC5[0] = 0
    UNITPRICE = (BASE / ((100 - SPC5[0]) / 100))
    CNVTU[0] = 0;CNVTU[1] = UN[1];CNVTU[2] = 2;CNVTA = BASEHOLD
    Gosub CONVERT
    DTYPE$ = "S/P " \ If MLVL Let DTYPE$ = DTYPE$ + Str$(MLVL) + " "
    DTYPE$ = DTYPE$ + "with margin"
    If C3[1] <> 12
      DDESC$ = AMOUNT Using PMASK$," [",DBASE$,"]",SPC5[0] Using " +###.###% g/p"
    Else 
      DDESC$ = DDESC$,SPC5[0] Using " +###.###% g/p"
    End If 
  End If 
  If C3[0] = 8 ! $markup/markdown
    UNITPRICE = BASE
    AMOUNT = 0
    If BASE ! up to price um
      CNVTU[0] = 0;CNVTU[1] = UN[1];CNVTU[2] = 2;CNVTA = BASE
      Gosub CONVERT
    End If 
    UNITPRICE = AMOUNT + SPC5[0]
    If UNITPRICE ! back 2 base
      CNVTU[0] = UN[1];CNVTU[1] = 0;CNVTU[2] = 2;CNVTA = UNITPRICE
      Gosub CONVERT
      UNITPRICE = AMOUNT
    End If 
    AMOUNT = 0
    If BASEHOLD
      CNVTU[0] = 0;CNVTU[1] = UN[1];CNVTU[2] = 2;CNVTA = BASEHOLD
      Gosub CONVERT
    End If 
    DTYPE$ = "S/P " \ If MLVL Let DTYPE$ = DTYPE$ + Str$(MLVL) + " "
    DTYPE$ = DTYPE$ + "with $ markup/markdown"
    If SPC5[0] >= 0
      DDESC$ = AMOUNT Using PMASK$," [",DBASE$,"]",SPC5[0] Using " +$$$.### "
    Else 
      DDESC$ = AMOUNT Using PMASK$," [",DBASE$,"]",SPC5[0] Using " -$$$.### "
    End If 
  End If 
End If 
If C3[0] = 7 Let UNITPRICE = 0 ! -3
SP_EXIT: Rem get out, but check price and cost first so l5[1] gets assigned
If UNITPRICE ! "have a price
  If C3[0] = 3 And (L9[0] = 2 Or L9[0] = 4 Or L9[0] = 6 Or L9[0] = 12 Or L9[0] = 15)
    L9[0] = 13
  End If 
  If SPSLCOST And (Not(L5[1]) Or SPSLCOST < L5[1] Or P61$[21,21] = "Y" Or SPC1[1] = 1)
    L5[1] = SPSLCOST
    DCOST$ = "spec."
    DBASE$ = "spec. cost"
    LCO = 11
  End If 
Else 
  SPC5[0] = 0;SPC5[1] = 0;BASEHOLD = 0
  DTYPE$ = " ",DTYPE$;DBASE$ = " ",DBASE$;DDESC$ = " ",DDESC$
End If 
Return 
CHECKUNIT: Rem "check if valid unit
For X1 = 0 To 7
  If UNIT = PFU1[X1] Return 
Next X1
UNIT = 0
Return 
MLVL_SPR: Rem multi level - return mlvl 1-10 (1 default)
If C3[2] ! qty um check
  UNIT = C3[2]
  Gosub CHECKUNIT
  If Not(UNIT) Let C3[2] = 0
End If 
AMOUNT = L7[2]
If PROD And C3[2]
  CNVTU[0] = 0;CNVTU[1] = C3[2];CNVTU[2] = 1;CNVTA = L7[2]
  Gosub CONVERT
End If 
If Not(PROD) And Not(C3[2])
  CNVTU[0] = 0;CNVTU[1] = PFU1[9];CNVTU[2] = 1;CNVTA = L7[2]
  Gosub CONVERT
End If 
ORDQTY = AMOUNT
X2[1] = 0;X2[2] = 0;X2[3] = 0;X2[4] = 0
If SPC6[1] = 1 ! main (price 1) - set the bar
  If ORDQTY >= SPC4[0] And X2[1] <= SPC4[0] Let X2[1] = SPC4[0];MLVL = 1
End If 
If SPC6[1] = 2 ! main (price 1) - set the bar
  If S3[4] >= SPC4[0] And X2[2] <= SPC4[0] Let X2[2] = SPC4[0];MLVL = 1
End If 
For X = 0 To 8
  If APTYPE[X] > 0 And APTYPE[X] < 9 ! prctype determines used
    If AMTYPE[X] <> 2 Let AMTYPE[X] = 1
    If AMTYPE[X] = 1 ! qty
      If ORDQTY >= AMQTY[X] And X2[1] <= AMQTY[X] Let X2[1] = AMQTY[X];X2[3] = X + 2
    End If 
    If AMTYPE[X] = 2 ! wgt
      If S3[4] >= AMQTY[X] And X2[2] <= AMQTY[X] Let X2[2] = AMQTY[X];X2[4] = X + 2
    End If 
  End If 
Next X
If X2[3] = 0 And X2[4] = 0 Return 
If X2[1] = ORDQTY And X2[2] = S3[4] ! tie goes to wgt per specs
  If X2[4]
    MLVL = X2[4]
    Goto MLSPRDONE
  End If ! no wgt lvl - continue
End If 
MLVL = X2[4];X2[9] = 0
If ORDQTY Let X2[9] = S3[4] / ORDQTY
If (X2[9] * X2[1]) > X2[2] Let MLVL = X2[3]
If X2[1] And X2[2] = 0 And X2[3] <> 0 Let MLVL = X2[3]
If X2[1] = 0 And X2[2] = 0 And X2[4] <> 0 Let MLVL = X2[4]
If MLVL = 0 And X2[3] <> 0 Let MLVL = X2[3]
MLSPRDONE: Rem done
If MLVL > 1 ! from price 2-10 - move to standard vars
  X = MLVL - 2
  C3[0] = APTYPE[X];C3[1] = ABTYPE[X]
  SPC4[0] = AMQTY[X];SPC6[1] = AMTYPE[X]
  SPC5[0] = APFACT[X]
End If 
If MLVL < 1 Let MLVL = 1
Return 
GETBASE: Rem "get base to use for special price
!If DEBUG Let DBG$ = " Getting base for special price..." \ Gosub DBG
LET BASE=0;FIELD=0
IF C3[1]=2 LET FIELD=0
IF C3[1]>3 AND C3[1]<10 LET FIELD=C3[1]-3
IF C3[1]=13 LET FIELD=8
IF WHSEPR
  if field and field<7 and pr_c4[2]=1 and pr_c4[3]
     LET BASE=W3[18]
     GOSUB GETMATPRICE:
     IF FIELD>0 AND FIELD<7 LET W3[18+FIELD]=X4
   ENDIF 
  If C3[1] = 1 Let BASE = W3[18];DBASE$ = "base cost"
  If C3[1] = 2 Let BASE = W3[17];DBASE$ = "load cost"
  If C3[1] = 3 Let BASE = W3[16];DBASE$ = "last cost"
  If C3[1] = 4 Let BASE = W3[19];DBASE$ = "list 1"
  If C3[1] = 5 Let BASE = W3[20];DBASE$ = "list 2"
  If C3[1] = 6 Let BASE = W3[21];DBASE$ = "list 3"
  If C3[1] = 7 Let BASE = W3[22];DBASE$ = "list 4"
  If C3[1] = 8 Let BASE = W3[23];DBASE$ = "list 5"
  If C3[1] = 9 Let BASE = W3[24];DBASE$ = "list 6"
  If C3[1] = 10 Let BASE = SPSLCOST;DBASE$ = "s/p cost"
  If C3[1] = 10 And SPC5[3] = 4 And L5[1]
    BASE = L5[1];DBASE$ = "std cost"
  End If 
  If C3[1] = 11 Let BASE = COSTHOLD;DBASE$ = DCOST$," cost"
  If C3[1] = 12
    If PERM[0]
      UNITPRICE = PERM[0]
      DDESC$ = " ",DDESC$ \ DDESC$ = "([Perm] "
      DDESC$ = DDESC$,UNITPRICE Using PMASK$ \ DDESC$ = DDESC$,") "
      Goto MOVE_ON1
    End If 
    If PR_C4[2] = 1 Gosub MATPSETUP
    If PR_C4[2] = 2 Gosub GETTENBPRICE
MOVE_ON1: BASE = UNITPRICE;UNITPRICE = 0;DBASE$ = "calc price"
  End If 
  If C3[1] = 13 Let BASE = W3[14];DBASE$ = "redi cost"
  If C3[1] = 14 Let BASE = RBCOST;DBASE$ = "rebate cst"
  If C3[1] = 15 Let BASE = WHMISC[2];DBASE$ = "netpo cost"
Else
if field and field<7 and pr_c4[2]=1 and pr_c4[3]
     LET BASE=PR_C4[4] \ GOSUB GETMATPRICE:
     IF FIELD>0 AND FIELD<7 LET A[19+FIELD]=X4
   ENDIF 
  If C3[1] = 1 Let BASE = PR_C4[4];DBASE$ = "base cost"
  If C3[1] = 2 Let BASE = B[8];DBASE$ = "load cost"
  If C3[1] = 3 Let BASE = B[10];DBASE$ = "last cost"
  If C3[1] = 4 Let BASE = A[20];DBASE$ = "list 1"
  If C3[1] = 5 Let BASE = A[21];DBASE$ = "list 2"
  If C3[1] = 6 Let BASE = A[22];DBASE$ = "list 3"
  If C3[1] = 7 Let BASE = A[23];DBASE$ = "list 4"
  If C3[1] = 8 Let BASE = A[24];DBASE$ = "list 5"
  If C3[1] = 9 Let BASE = A[25];DBASE$ = "list 6"
  If C3[1] = 10 Let BASE = SPSLCOST;DBASE$ = "s/p cost"
  If C3[1] = 10 And SPC5[3] = 4 And L5[1]
    BASE = L5[1];DBASE$ = "std cost"
  End If 
  If C3[1] = 11 Let BASE = COSTHOLD;DBASE$ = DCOST$," cost"
  If C3[1] = 12
    If PERM[0]
      UNITPRICE = PERM[0]
      DDESC$ = " ",DDESC$ \ DDESC$ = "([Perm] "
      DDESC$ = DDESC$,UNITPRICE Using PMASK$ \ DDESC$ = DDESC$,") "
      Goto MOVE_ON2
    End If 
    If PR_C4[2] = 1 Gosub MATPSETUP
    If PR_C4[2] = 2 Gosub GETTENBPRICE
MOVE_ON2: BASE = UNITPRICE;UNITPRICE = 0;DBASE$ = "calc price"
  End If 
  If C3[1] = 13 Let BASE = PF_LOAD2;DBASE$ = "redi cost"
  If C3[1] = 14 Let BASE = RBCOST;DBASE$ = "rebate cst"
  If C3[1] = 15 Let BASE = PRPARC[2];DBASE$ = "netpo cost"
End If 
BASEHOLD = BASE
Return 
GETMATPRICE: Rem "calculate matrix price from markup table
IF FIELD>0 AND FIELD<7 ! "don't do loads here
  LET REC_PMARK=pr_c4[3] ! (FIELD*1000)-1000+PR_C4[3]
  IF REC_PMARK>0 and rec_pmark<chf(ch_pmark) ! "get table
	mat read #CH_PMark,Rec_PMark,18;pm5;
	mat read #CH_PMark,Rec_PMark,78;pm6;
	Let X1[5]=Field-1 ! "so ends as 0-5
	If PM5[x1[5],4]=1
		Let Base=B[10] \ if WhsePr Let Base=W3[16] ! "last
	Endif
	If PM5[x1[5],4]=2 ! "load cost
		Let Base=B[8] \ if WhsePr Let Base=W3[17]
	Endif
	if PM5[x1[5],4]=3 ! "load2 cost
		Let Base=PF_Load2 \ if WHSEPR Let Base=W3[14]
	Endif
	If PM5[x1[5],4]=4 ! "average cost
		Let Base=B[21] \ if WHSEPR Let Base=W3[15]
	Endif
	If PM5[x1[5],4]=5 ! "NET PO
		 Let Base=PRPARC[2] \ if WhsePr Let Base=WHMISC[2]
	Endif
    CNVTA = BASE;CNVTU[0] = 0;CNVTU[1] = PFU1[11];CNVTU[2] = 2
    Gosub CONVERT
    M7 = AMOUNT
    CNVTA = BASE;CNVTU[0] = 0;CNVTU[1] = UN[1];CNVTU[2] = 2
    Gosub CONVERT
    BASEHOLD = AMOUNT
    DDESC$ = "([",DBASE$,"] ",BASEHOLD Using PMASK$
    X1 = 0
MARKLOOP1: Rem "calculate price
if (mode=0 or mode=1) and pm6[x1[5],0]=0 and pm6[x1[5],1]=0 and pm6[x1[5],2]=0 and pm6[x1[5],3]=0 
    LET M7=0
ENDIF 
if pm6[x1[5],x1] ! "have a factor
	let cnvtu[0]=pfu1[11];cnvtu[1]=un[1];cnvtu[2]=2
	if not (pm5[X1[5],x1])
		let ddesc$=ddesc$,pm6[X1[5],x1] using " +###.##%"
		let m7=m7+(m7*(pm6[X1[5],x1]/100)) ! "%
	endif						
	if pm5[X1[5],x1]=1
		let cnvta=pm6[X1[5],x1] \ gosub Convert:
		if pm6[X1[5],x1]>=0 let ddesc$=ddesc$," +" else let ddesc$=ddesc$," "
			let ddesc$=ddesc$,amount using pmask$
			let m7=m7+pm6[X1[5],x1] ! "$
		endif																											
		if pm5[X1[5],x1]=2
			let ddesc$=ddesc$,pm6[X1[5],x1] using " +###.##% g/p"
			let m7=(m7/(100-pm6[X1[5],x1]))*100 ! "margin
		endif
		!If Debug Let DBG$="Val="+Str$(X1)+" NV="+Str$(M7) !\ gosub dbg:
			if x1<3 let x1=x1+1 \ goto MarkLoop1: ! "next
		endif
		let ddesc$=ddesc$,")"
		let cnvtu[0]=pfu1[11];cnvtu[1]=0;cnvtu[2]=2;cnvta=m7
		gosub Convert:
		let x4=amount ! "calculated price in base
	endif
endif
Return 
GETTENBPRICE: Rem "calculate 10 bracket price from tables
UNITPRICE = 0
If (PR_C4[3] > 0 And B[22])
  BRACKET = 0
  If C3[0] = 4
    BRACKET = C3[1]
  Else 
    REC_BRKTBL = B[22]
    Mat Read #CH_BRKTBL,REC_BRKTBL,0;B1;
    Read #CH_BRKTBL,REC_BRKTBL,200;B3;
    Mat Read #CH_BRKTBL,REC_BRKTBL,202;BRD$;
    If B3 = 2 ! "right type
      CNVTA = Abs(UWORK[0]);CNVTU[0] = UN[0];CNVTU[1] = PFU1[8];CNVTU[2] = 1
      Gosub CONVERT
      UWORK[5] = AMOUNT
      For X1 = 9 To 0 Step -1
        X2 = Abs(B1[X1,0])
        If (B1[X1,0] < 0 And S3[4] >= X2) Or (B1[X1,0] >= 0 And UWORK[5] >= X2)
          BRACKET = X1 + 1;X1 = -99
        End If 
      Next X1
      If C3[0] = 5 Let BRACKET = BRACKET + C3[1]
    End If 
  End If 
  If BRACKET > 10 Let BRACKET = 10
  If BRACKET
GET_PRODMARK_REC: Rem "get record number
    REC_PRODMARK = (BRACKET * 1000) - 1000 + PR_C4[3]
    If REC_PRODMARK > 0 ! "get table
      Mat Read #CH_PRODMARK,REC_PRODMARK,0;M5;
      Mat Read #CH_PRODMARK,REC_PRODMARK,10;M6;
      If BRACKET > 1 And Not(M6[0]) Let BRACKET = BRACKET - 1 \ Goto GET_PRODMARK_REC
      CNVTA = PR_C4[4] \ If P9$[32,32] = "Y" Let CNVTA = W3[18]
      CNVTU[0] = 0;CNVTU[1] = PFU1[11];CNVTU[2] = 2
      Gosub CONVERT
      M7 = AMOUNT
      CNVTU[0] = 0;CNVTU[1] = UN[1];CNVTU[2] = 2
      CNVTA = PR_C4[4] \ If P9$[32,32] = "Y" Let CNVTA = W3[18]
      Gosub CONVERT
      BASEHOLD = AMOUNT
      DDESC$ = "(",BASEHOLD Using PMASK$
      X1 = 0
MARKLOOP2: Rem "calculate price
      If M6[X1] ! "have a factor
        CNVTU[0] = PFU1[11];CNVTU[1] = UN[1];CNVTU[2] = 2
        If Not(M5[X1])
          DDESC$ = DDESC$,M6[X1] Using " +###.##%"
          M7 = M7 + (M7 * (M6[X1] / 100))
        End If 
        If M5[X1] = 1
          CNVTA = M6[X1] \ Gosub CONVERT
          If M6[X1] >= 0 Let DDESC$ = DDESC$," +" Else Let DDESC$ = DDESC$," "
          DDESC$ = DDESC$,AMOUNT Using PMASK$
          M7 = M7 + M6[X1]
        End If 
        If M5[X1] = 2
          DDESC$ = DDESC$,M6[X1] Using " +###.##% g/p"
          M7 = (M7 / (100 - M6[X1])) * 100
        End If 
        If X1 < 3 Let X1 = X1 + 1 \ Goto MARKLOOP2
      End If 
      DDESC$ = DDESC$,")"
      If P60$[18,18] = "Y" And PFU1[11] = -1 Let M7 = FNF(M7)
      CNVTU[0] = PFU1[11];CNVTU[1] = 0;CNVTU[2] = 2;CNVTA = M7
      Gosub CONVERT
      UNITPRICE = AMOUNT
    End If 
  End If 
End If 
If UNITPRICE And Not(L9[0]) Let L9[0] = 5;OLM[2] = 0
Return 
MATPSETUP: Rem "setup for matrix price calculation
DBASE$ = " ",DBASE$
If Not(CMDTYBASE) Let CMDTYBASE = CMDTYMULTI + 2;CMDTYMULTI = 1
If CMDTYBASE = 1 Let DBASE$ = "load cost"
If CMDTYBASE = 2 Let DBASE$ = "last cost"
!If CMDTYBASE >= 3 And CMDTYBASE <= 8 Let FIELD = CMDTYBASE - 1;DBASE$ = CMDTYBASE - 2 Using "list #"
IF CMDTYBASE>=3 AND CMDTYBASE<=8 LET FIELD=CMDTYBASE-2;DBASE$=CMDTYBASE-2 USING "list #"
If CMDTYBASE = 9 Let DBASE$ = "base cost"
If CMDTYBASE = 10 Let DBASE$ = "redi cost"
If CMDTYBASE >= 3 And CMDTYBASE <= 8 And PR_C4[3] ! "get base to use
  If WHSEPR
    BASE = W3[18]
    Gosub GETMATPRICE
    !If FIELD > 1 And FIELD < 8 Let W3[17 + FIELD] = X4
	IF FIELD>0 AND FIELD<7 LET W3[17+FIELD]=X4
  Else 
    BASE = PR_C4[4]
    Gosub GETMATPRICE
    !If FIELD > 1 And FIELD < 8 Let A[18 + FIELD] = X4
	 IF FIELD>0 AND FIELD<7 LET A[18+FIELD]=X4
  End If 
End If 
If WHSEPR ! "set price now
  If CMDTYBASE = 1 Let UNITPRICE = W3[17]
  If CMDTYBASE = 2 Let UNITPRICE = W3[16]
  If CMDTYBASE >= 3 And CMDTYBASE <= 8 Let UNITPRICE = W3[16 + CMDTYBASE]
  If CMDTYBASE = 9 Let UNITPRICE = W3[18]
  If CMDTYBASE = 10 Let UNITPRICE = W3[14]
Else 
  If CMDTYBASE = 1 Let UNITPRICE = B[8]
  If CMDTYBASE = 2 Let UNITPRICE = B[10]
  If CMDTYBASE >= 3 And CMDTYBASE <= 8 Let UNITPRICE = A[17 + CMDTYBASE]
  If CMDTYBASE = 9 Let UNITPRICE = PR_C4[4]
  If CMDTYBASE = 10 Let UNITPRICE = PF_LOAD2
End If 
If UNITPRICE And (CMDTYBASE = 1 Or CMDTYBASE = 2 Or CMDTYBASE = 9 Or CMDTYBASE = 10 Or Not(PR_C4[3]))
  CNVTU[0] = 0;CNVTU[1] = UN[1];CNVTU[2] = 2;CNVTA = UNITPRICE
  Gosub CONVERT
  DDESC$ = "([",DBASE$,"] ",AMOUNT Using PMASK$,")"
End If 
If Not(CMDTYMULTI) Let CMDTYMULTI = 1
UNITPRICE = UNITPRICE * CMDTYMULTI
If CMDTYMULTI <> 1 Let DDESC$ = DDESC$,CMDTYMULTI Using " x##.### factor"
If UNITPRICE And Not(L9[0]) Let L9[0] = 1;OLM[2] = 0
Return 
CHECKBREAK: Rem "check break table for discount
If AMALG Or L9[0] = 10 Or PR_C4[2] <> 1 Or (Not(CMDTYBRKFLAG) And MATPR) Return 
L6[0] = 0;L6[1] = 0;UWORK[11] = 0;PPBREAK = 0
If L9[0] = 1 Or L9[0] = 9 Or JUMP_ ! "check for break
  L7[9] = 0
  L5[0] = FNR(L7[2] * UNITPRICE)
  If UN[1] = -2 Let L5[0] = FNR(UNITPRICE)
  If P60$[50,50] = "Y" And CMDTYBRKTBL > 0 And CMDTYBRKTBL <= Chf(CH_BRKTBL)
    REC_BRKTBL = CMDTYBRKTBL
  Else 
    REC_BRKTBL = B[22]
    If REC_BRKTBL <= 0 Or REC_BRKTBL > Chf(CH_BRKTBL) Goto ENDBREAK
  End If 
  Mat Read #CH_BRKTBL,REC_BRKTBL,0;B1;
  Read #CH_BRKTBL,REC_BRKTBL,200;B3;
  Mat Read #CH_BRKTBL,REC_BRKTBL,202;BRD$;
  If (B3 = 1 Or B3 = 3) ! "valid type
    If JUMP_ < 0 ! "manual level
      L7[9] = REC_BRKTBL + (Abs(JUMP_) / 100)
      JUMP_ = 0
    End If 
    I = -1
    If L7[9] And Not(JUMP_)
      I = Int(Fra(L7[9]) * 100) - 1
      L7[9] = 0
    End If 
    If (I >= 0 And I <= 9) ! "fixed level
      X4 = B1[I,2];T0 = B1[I,1];PPBREAK = 1
    Else 
      X4 = 0;T0 = 99;I1 = 9
      CNVTU[0] = UN[0];CNVTU[1] = PFU1[8];CNVTU[2] = 5
      CNVTA = UWORK[0] \ Gosub CONVERT
      STOCK = AMOUNT
      If B3 = 1 Let BRKAMT = Abs(STOCK)
      If B3 = 3 Let BRKAMT = Abs(L5[0])
      For I = I1 To 0 Step -1
        If B1[I,0] < 0 Goto ENDBREAK
        If (B1[I,0] Or Not(I)) And BRKAMT >= B1[I,0] Goto GOTBREAK
      Next I
      If B3 = 1 If JUMP_ !if the qty is too low still use the special price
        I = -1
        Goto GOTBREAK
      End If 
      Goto ENDBREAK
GOTBREAK: Rem "found a valid level
      If JUMP_ Let I = I + JUMP_;PPBREAK = 1 \ If I > 9 Let I = 9
      X4 = B1[I,2];T0 = B1[I,1]
    End If 
CHECKVALID: Rem "see if any amount
    If Not(X4) And I > 0 ! "try again
      I = I - 1
      X4 = B1[I,2];T0 = B1[I,1]
      Goto CHECKVALID
    End If 
    If X4 ! "have one
      If Not(T0)
        L6[0] = X4
        If L6[0] Let DDESC$ = DDESC$," -",L6[0] Using "###.##% break"
      Else 
        L6[1] = X4
        CNVTU[0] = PFU1[8];CNVTU[1] = 0;CNVTU[2] = 2
        CNVTA = L6[1] \ Gosub CONVERT
        L6[1] = AMOUNT;X4 = AMOUNT
      End If 
      L7[9] = REC_BRKTBL + ((I + 1) / 100);JUMP_ = 0
    End If 
  End If 
ENDBREAK: Rem "continue on
  If L6[1] > UNITPRICE Let L6[1] = UNITPRICE;X4 = UNITPRICE
End If 
If L6[0] Or L6[1]
  L9[0] = 9
  If Not(PPBREAK)
    DTYPE$ = DTYPE$," less break (table",REC_BRKTBL Using "###",", level",I + 1 Using "##"
    If BRD$[(I + 1) * 10 - 9,(I + 1) * 10 - 8] <> "  " Let DTYPE$ = DTYPE$,"-",BRD$[(I + 1) * 10 - 9,(I + 1) * 10]
    DTYPE$ = DTYPE$,")"
  End If 
Else 
  L7[9] = 0
End If 
If L6[1]
  CNVTU[0] = 0;CNVTU[1] = UN[1];CNVTU[2] = 2;CNVTA = L6[1]
  Gosub CONVERT
  UWORK[11] = AMOUNT
  DDESC$ = DDESC$," -",UWORK[11] Using "###.##"," break"
Else 
  UWORK[11] = 0
End If 
If L9[0] = 9 Let OLM[2] = 0
Return 
SP_CHKREBATE: Rem "check for any rebate
Gosub CDATE
Gosub PDATE
CURDATE = X2
Mat REBATE_ARGS = Zer
REBATE_ARGS[1,0] = CH_PROD
REBATE_ARGS[2,0] = CH_PRWH
REBATE_ARGS[3,0] = CH_VENDTAG
REBATE_ARGS[4,0] = CH_RCONTRACTH
REBATE_ARGS[5,0] = CH_REBATEDTL
REBATE_ARGS[1,1] = REC_PROD
REBATE_ARGS[2,1] = REC_PRWH
REBATE_ARGS[1,2] = WHSE
REBATE_ARGS[2,2] = C1[1]
REBATE_ARGS[3,2] = 0
REBATE_ARGS[4,2] = CURDATE
REBATE_ARGS[5,2] = P3
If CUSTOM_CUSTOMER$ = "HTBERRY" ! "cct230337
  If H5[7] = 2 ! do not look for rebates for OT 2
    STATUS = 1
    Goto SKIPREBATECALL
  End If 
End If 
! Call "rebates",REBATE_ARGS[],A$[140,151],STATUS
Call rebates(e$,REBATE_ARGS[],A$[140,151],STATUS,debug,dlog$,rstr$)
SKIPREBATECALL: Rem jump the call for ot 2 ( custom for HTBERRY )
If Not(STATUS) !"indicates call was successful in finding rebate
  RBCOST = REBATE_ARGS[1,3]
  RBSLCOST = REBATE_ARGS[2,3]
  RB_BASECOST = REBATE_ARGS[4,3]
  REBATE_TYPE = REBATE_ARGS[7,3]
  REC_REBATEDTL = REBATE_ARGS[5,1]
  Mat Read #CH_REBATEDTL,REC_REBATEDTL,12;RB1
  Mat Read #CH_REBATEDTL,REC_REBATEDTL,36;RBUM
  Mat Read #CH_REBATEDTL,REC_REBATEDTL,40;RB
  Mat Read #CH_REBATEDTL,REC_REBATEDTL,118;RBWH
  Mat Read #CH_REBATEDTL,REC_REBATEDTL,126;RBL1
  Mat Read #CH_REBATEDTL,REC_REBATEDTL,138;RB5
  LCO[1] = RB1[0]
  If COST2RBT !"use lower of default 2nd line cost and rebate cost
    If RBCOST And RBCOST < CST
      CST = RBCOST
      LCO[1] = RB1[0]
    End If 
  End If 
  If COST2 = 6
    CST = RBCOST
    LCO[1] = RB1[0]
  End If 
  If RBSLCOST And (Not(L5[1]) Or RBSLCOST < L5[1])
    L5[1] = RBSLCOST;DCOST$ = "rebate"
    LCO[1] = RB1[0]
    LCO = 10
  End If 
Else 
  RBCOST = 0;RBSLCOST = 0
  LCO[1] = RB1[0]
End If 
Return 
GETSALES: Rem
QYTD = 0
DYTD = 0
K13$ = " ",K13$
K13$[1,6] = C1[1] Using "######"
K13$[7,18] = P$[1,12]
HOLD13$ = K13$
SLSLOOP: Rem
Search #CH_SLSCUR,3,1;K13$,REC_SLSCUR,E
If E Goto GOTSLS
Mat Read #CH_SLSCUR,REC_SLSCUR,16;S1;
If K13$[1,18] <> HOLD13$[1,18] Goto GOTSLS
QYTD = QYTD + S1[0,0]
DYTD = DYTD + S1[0,1]
Goto SLSLOOP
GOTSLS: Rem
CNVTU[0] = 0;CNVTU[1] = UN[2];CNVTU[2] = 2;CNVTA = QYTD
Gosub CONVERT
QYTD = AMOUNT
Return 
PDATE: Rem
X2 = X$[4,5] \ X1 = X$[1,2] \ X2 = X2 + X1 * 10 ^ 2
X1 = X$[7,8] \ X2 = X2 + X1 * 10 ^ 4
Return 
CDATE: Rem
U5$ = ""
J4$ = "JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC"
Call Time(U5$)
For K1 = 1 To 12
  If U5$[1,3] = J4$[K1 * 3 - 2,K1 * 3] Goto GET_X
Next K1
Print "\15\DATE ERROR - STOP AT ";Spc(9) \ Stop 
GET_X: Rem
X$ = "/",X$
X$[1,2] = K1 Using "##"
X$[4,5] = U5$[5,6]
X$[7,8] = U5$[11,12]
For K1 = 1 To 8
  If X$[K1,K1] = " " Let X$[K1,K1] = "0"
Next K1
Return 
SETCOST: Rem "get default cost
If WHSEPR ! "set loads
  COST = W3[17];LCO = 2;DCOST$ = "load"
  If DFT_COST = 2
    COST = W3[14];LCO = 5;DCOST$ = "redi"
  Else 
    If DFT_COST = 3
      COST = W3[15];LCO = 4;DCOST$ = "average"
    Else 
      If DFT_COST = 4
        COST = W3[16];LCO = 3;DCOST$ = "last"
      Else 
        If DFT_COST = 5
          COST = W3[18];LCO = 1;DCOST$ = "base"
        End If 
      End If 
    End If 
  End If 
Else 
  COST = B[8];LCO = 2;DCOST$ = "load"
  If DFT_COST = 2
    COST = PF_LOAD2;LCO = 5;DCOST$ = "redi"
  Else 
    If DFT_COST = 3
      COST = B[21];LCO = 4;DCOST$ = "average"
    Else 
      If DFT_COST = 4
        COST = B[10];LCO = 3;DCOST$ = "last"
      Else 
        If DFT_COST = 5
          COST = PR_C4[4];LCO = 1;DCOST$ = "base"
        End If 
      End If 
    End If 
  End If 
End If 
Return 
GETPRICE: Rem need to call price to get current cost
COSTORG = 0
RBCONTRACT = 0
PCALL_COST = 0
FLEPTR[1,0] = CH_PROD
FLEPTR[1,1] = REC_PROD
FLEPTR[2,0] = CH_PRODWH
FLEPTR[3,0] = CH_COMM
FLEPTR[3,1] = REC_COMM
FLEPTR[4,0] = CH_LASTPRICE
FLEPTR[5,0] = CH_SPECPRICE
FLEPTR[6,0] = CH_CONTRACTH
FLEPTR[7,0] = CH_CCODES
FLEPTR[8,0] = CH_BRKTBL
SPECS[3] = C1[1]
SPECS[4] = WH
SPECS[5] = SYSDATE
SPECS[6] = 0
SPECS[7] = PTYPE
SPECS[8] = 1
SPECS[9] = DFT_COST
SPECS[10] = 0
SPECS[11] = 0
SPECS[12] = 0
SPECS[13] = UN[2]
SPECS[14] = UN[2]
SPECS[15] = UN[1]
SPECS[16] = 0
SPECS[17] = 0
SPECS[18] = 0
SPECS[19] = 0
Let dbg=debug;dlog$=dblog$ ! pass what this program uses
Call SysPriceCalc(e$,FLEPTR[],SPECS[],MSGDESC$,dbg,dlog$)
!Call "price",FLEPTR[],SPECS[],MSGDESC$
COSTORG = SPECS[26]
RBCONTRACT = SPECS[24]
PCALL_COST = SPECS[17]
Return 



Rem {begin rtn.convert.s}
CONVERT: Rem "UNIT CONVERSION RETURNS AMOUNT  (rev 01/07/1992)   ! 20040 REM
If CNVTU[2] = 3 Or CNVTU[2] = 4 Goto CVTSTARTA
If CNVTU[2] = 1 And CNVTU[1] = CNVTU[0] Let AMOUNT = CNVTA \ Goto CVTDONE
If CNVTU[0] = -2 Or CNVTU[1] = -2 Let AMOUNT = CNVTA \ Goto CVTDONE
If CNVTU[2] = 0 Goto CVTSTARTA
If Not(CNVTA) Let AMOUNT = 0 \ Goto CVTDONE
CVTSTARTA: Rem ALL UB 5+!!  IF SPC 4>1280 GOTO cvtstartb: ! "unibasic 5+
CVTSTARTB: Rem "====== unibasic 5+ logic
Call "MXPRCONV5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
If CNVTU[2] = 0 Goto CVTDONE
If FLAG Let E = FLAG \ Gosub ERR_SEARCH
AMOUNT = CNVTA
CVTDONE: Return 
Rem {end rtn.convert.s}

ERR_SEARCH: Rem
ENUM = E ;ELINE = Spc(16);CTERR = 0
If E = 5 Let CTERR = Err(8)
msg$ = "RETURN STATUS",(E + (CTERR * .001))
msg$ = msg$,"/ STATEMENT",ELINE," IN PROGRAM "
E$=msg$ \ Error 10000
Return ! End



ERR_TRAP: Rem *Error routine (escape trap)   V3.1 8/94 G.DOSCHER/REK
!
! dx replace entire error routine
include "src/callmainerrnet.inc"
End 

OUTEND: Rem EXIT PROGRAM
if not(outflag)
	If not(j8)
		Call addtostr(e$,rstr$,esdel$) !end section -- DXBLOCK 
		let returnstatus=0
		If Eflag>0
			ReturnStatus=1 ! ALWAYS - OTHERWISE NO DISPLAY 1=issues
			tmp$=""
		Endif
		if not(eflag)
			if not(totrec)
				returnstatus=1
				let message$=message$+"There are no transactions to print"
				message$=message$+"."
			else
				Let message$=message$+" "+str$(totrec)+" Transaction(s) Printed"
			endif
		endif
		call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
		call AddToStr(e$,rstr$,WebStr$)
		call SetOutPut(e$,rstr$)
	else
		Call addtostr(e$,rstr$,esdel$) !end section
		Call setoutput(e$,rstr$,1) !1 flag puts 0 status seciton in, puts </page> in
	End If
endif
!try Call dxclose() else rem
Else
!
	include "src/callmainerrnet.inc"
	end try
End ! the whole program