!>>> Program 059
!
! description  set up LAST PRICE for Supersedes
!
! loadsave -w -n 100,10 -o prog/dxport/059.dl4 src/059.src
!
include "src/copyright.inc" ! dx
!
Rem mx059 - Supersede Item Pricing Update
Rem cct 186023 - Per CJR/HTB Specs
Rem Last Update:
! can be run from 671 for a single product (See SnglProd$) FUTURE CHG? (not on r9/devl)
! If it is a single product run - IT IS NOT AN AUDIT
! "the rev 9 changes to lastprice for 4 digit dept are included(rem'd out)
!
Rem BEDIT Version: 2.2 OBJECT CODE     Created: NOV 19, 2008  14:42:35
Rem /w2/papermaster/r2005//usr/acct/txc/work/r2005/mx0/mx059.src (univ2) [txc] {63537}
Rem  Copyright (c) 2008 Universal Business Systems, Inc.
Rem    **** ALL CHANGES MUST BE MADE IN SOURCE!!! ****
Rem  task #14255 - update ship list last price file
External Lib "libprice.lib"
Declare External Sub SysPriceCalc
External Lib "libprodwh.lib"
Declare External Sub mxwhcreate
External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus
Declare Intrinsic Sub FindF,FormatDate,InpBuf,JulianToDate,String,Time,VerifyDate
Declare Intrinsic Sub programdump
Declare Intrinsic Function findchannel
!Option Default Dialect IRIS1

! the below is the link to 671 (origprod/newprod)! If Err 0 Gosub ERR_TRAP
If Err 0 Rem
Enter SNGLPROD$
If Err 0 Gosub ERR_TRAP
Rem {begin src/inc/dim.lastpr.i ! "use include as we need ALL}
dim 1%,ch_sllp,4%,rec_sllp
Dim LP$[12],LP2$[84],LPMT$[2],B4Key$[8],toWH3$[24]
Dim 1%,LPC3[4],AI,LPEUN[2],LPWH,LPCPT,PPPUSERID
Dim 2%,LPDF,LPC1[2],LPR1[3],LPC5[3],LPPCDATE,LPCSDT,LPDEPT,PPPCID[1]
Dim 2%,PRVOD[2],3%,PRVOQ[3]
Dim 3%,LPC2[2],LPC4[3],LPR[4],LPUNF[6],PERM[1],LPLPERM,LPCURR[1]
Dim 3%,LPFPERM[1],LPUNIT[1],w5[25],tow5[25],tOWH9[25]
Rem {end dim.lastpr.i ! "use include as we need ALL fields}
Rem {begin src/inc/dim.getchan.i}
Dim 1%,CHNL
Dim 3%,CHNLSCR,CHNLFREE
Rem {end dim.getchan.i}
Dim J$[70],J0$[18],J1$[70],J2$[20],J3$[40],J4$[60],J5$[80],J7$[80],J9$[70]
Dim X$[100],1%,J0,J2,J3,J4,J5,J6,J7[2],J8,X1[9]
Dim 2%,J9[9],X2[9],4%,J1
Dim K1$[60],K2$[60],K3$[60],K4$[60],K5$[50],K55$[60],K6$[60]
Dim SPROD$[12],NPROD$[12],FLE$[16],P9$[50],P60$[50],P61$[256]
Dim A$[156],PR_A2$[30],PUM$[4],BPROD$[12],EPROD$[12],MSGDESC$[150]
Dim RETVAL$[512],PUM2$[4],NA$[156],CONM$[30],C1$[142]
Dim 1%,CH_CNTRL,CH_CCODE,CH_PROD,CH_LASTPR,CH_CUST,CH_PTYPE
Dim 1%,PFU1[20],CNVTU[2],FLAG[9],SORTBY,COID,WHSERNG[2]
Dim 1%,CH_PRWH,CH_SPCP,CH_CONT,CH_BRKT,CH_SORT,CH_LPT
Dim 1%,PT[37],DFT_COST,CH_COMD,CH_PTYP,CH_TEMP,AUDIT,URECFLAG
Dim 1%,FLD,FOUND,CALC
Dim 2%,B[24],CUSTRNG[2],SLSMRNG[2],LRDATE,RLDATE,C1[12]
Dim 2%,DEPT,PRLINE[5],WHBLD[4]
Dim 3%,A[33],A1[7],OLDSELL,NEWSELL,OLDMARG,NEWMARG,PFU2[6]
Dim 3%,FLEPTR[20,1],SPECS[50],CNVTA,AMOUNT,R[99],LPDIR5
! ship last price file      
dim oldprod$[12],newprod$[12],custom_customer$[30]
dim slkey$[50],slkey1$[50],slkey2$[50],slkey3$[50],slkey4$[50]                  
dim slp$[12], slp2$[84], slpmt$[2]                                              
dim 1%, slpc3[4], sai, slpeun[2], slpwh, slpcpt, sPPPUserID                     
dim 2%, slpdf,slpc1[2],slpr1[3],slpc5[3],slpPCDate,slpCSDT,sLPDept,sPPPCID[1]   
dim 3%, slpc2[2], slpc4[3], slpr[4], slpunf[6], sperm[1], slpLPerm, slpcurr[1]  
dim 3%, slpfperm[1],slpunit[1],sppermcst                                        
dim 3%, rec_tmp                                                                 

Def FNT(X) = Sgn(X) * (Int(Abs(X) * 1000) / 1000)
dim e$[500],buttonlist$[5,50],nextlist$[5,100] ! dx error handling variables
Dim tmp$[1000],tmp1$[1000],message$[200],webstr$[500],msg$[200]
Dim action$[30],options$[30],userid$[8],blank$[200],3%,fdel$[10],rstr$[200],bsdel$[10],esdel$[10],rdel$[10]
!
blank$=" ",blank$
call getsession(e$,CTLC,options$,action$,userid$,intCO,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$)
Rem {end dim.rtn.input}
! call dxsave(0,"tmp/059in.txt!")
COID = IntCo ! Int((Spc(5) - Int(Spc(5) / 16384) * 16384) / 64)
CH_CNTRL = 1;CH_LPT = 0
Mat Read #1,3,0;CONM$;
Mat Read #1,19,50;P9$;
Mat Read #1,60,50;P60$;
Mat Read #1,61,0;P61$;
mat read #ctlc,115,60;custom_customer$;
custom_customer$=UCase$(Trim$(custom_customer$))
LRDATE = Tim(6)
X$ = LRDATE Using "#####"
Call JulianToDate(1,X$,X$,E) \ If E Gosub ERR_SEARCH
Call VerifyDate(X$,X$,E) \ If E Gosub ERR_SEARCH
LRDATE = X$
If Err 0 Rem ! "in case nothing sent
SPROD$ = SNGLPROD$[1,12]
NPROD$ = SNGLPROD$[13,24]
If Err 0 Gosub ERR_TRAP
If P60$[33,33] <> "Y" ! "NO PERM PRICING!
  If SPROD$ <> "" Goto OUTEND ! came from call - no message - just leave
  !Print 'CS ED';@0,0;"-MX059-";@20,0;"SUPERSEDE PERMANENT PRICE UPDATE"
  Message$="YOU ARE NOT FLAGGED FOR PERMANENT PRICING!"
  !Print @0,22;"PRESS <CR> TO EXIT  ";
  !Input Len 16384 + 1;""X$

  Goto Err_Msg ! OUTEND
End If 
! question: does 671 send printer or it's to the screen - which can't happen on erp!
! erp not programmed for the 671 update - needs work to use (as no xml available)
Try
	x3=chf(0)
Else
	j8=49
End try
if j8 ! no xml available
	message$="Can not print to browser!"
	goto err_msg
Endif
CHAN = 90 \ Gosub GETCHAN
Read #CH_CNTRL,88,1792;FLE$;
CH_PROD = CHNL \ Ropen #CH_PROD,FLE$
CHAN = 90 \ Gosub GETCHAN
Read #CH_CNTRL,88,1744;FLE$;
CH_PRWH = CHNL \ open #CH_PRWH,FLE$ ! NOT ROPEN!
CHAN = 90 \ Gosub GETCHAN
Read #CH_CNTRL,88,1808;FLE$;
CH_CUST = CHNL \ Ropen #CH_CUST,FLE$
CHAN = 90 \ Gosub GETCHAN
Read #CH_CNTRL,88,2288;FLE$;
CH_COMD = CHNL \ Ropen #CH_COMD,FLE$
CHAN = 90 \ Gosub GETCHAN
Read #CH_CNTRL,88,1376;FLE$;
CH_LASTPR = CHNL \ Open #CH_LASTPR,FLE$
CHAN = 90 \ Gosub GETCHAN
Read #CH_CNTRL,88,1728;FLE$;
CH_CCODE = CHNL \ Ropen #CH_CCODE,FLE$
CHAN = 90 \ Gosub GETCHAN
Read #CH_CNTRL,88,1936;FLE$;
CH_SPCP = CHNL \ Ropen #CH_SPCP,FLE$
CHAN = 90 \ Gosub GETCHAN
Read #CH_CNTRL,88,2880;FLE$;
CH_CONT = CHNL \ Ropen #CH_CONT,FLE$
CHAN = 90 \ Gosub GETCHAN
Read #CH_CNTRL,88,1952;FLE$;
CH_BRKT = CHNL \ Ropen #CH_BRKT,FLE$
CHAN = 90 \ Gosub GETCHAN
Read #CH_CNTRL,88,752;FLE$;
CH_PTYP = CHNL \ Ropen #CH_PTYP,FLE$
let ch_sllp=0
MAT  READ #1,61,0;P61$;                                            
IF P61$[64,64]="Y"                   
  LET fle$="3/SLLSTPRC"+STR$(COID)                              
  Call FindF(FLE$,E)
  if e<>0                                        
    chnl=90\ gosub getchan:
    let ch_sllp=chnl
    open #ch_sllp,fle$  
	! determine if sllp has a 5th dir
	Search #ch_sllp,1,5;K1$,SLPDIR5,E
	If E = 0 Let SLPDIR5 = 1
	If E <> 0 Let SLPDIR5 = 0
  ENDIF                                                            
ENDIF                    
CHAN = 70 \ Gosub GETCHAN
CH_TEMP = CHNL
Rem DETERMINE IF LAST PRICE FILE HAS A 5TH DIRECTORY
LPDIR5 = 0
K1$ = " ",K1$
Search #CH_LASTPR,1,5;K1$,LPDIR5,E
If E = 0 Let LPDIR5 = 1
If E <> 0 Let LPDIR5 = 0
K1$ = " ",K1$
FLEPTR[1,0] = CH_PROD;FLEPTR[2,0] = CH_PRWH
FLEPTR[3,0] = CH_COMD;FLEPTR[4,0] = CH_LASTPR
FLEPTR[5,0] = CH_SPCP;FLEPTR[6,0] = CH_CONT
FLEPTR[7,0] = CH_CCODE;FLEPTR[8,0] = CH_BRKT
FLEPTR[18,0] = CH_CUST
WHSEPRC = 0 \ If P9$[32,32] = "Y" Let WHSEPRC = 1
If P9$[33,33] = "N" Let WHSEPRC = 0
CUSTRNG[1] = 0;CUSTRNG[2] = 999999
SLSMRNG[1] = 0;SLSMRNG[2] = 999
WHSERNG[1] = 0;WHSERNG[2] = 99
SORTBY = 3
BPROD$ = " ",BPROD$;EPROD$ = "}",EPROD$
If SPROD$ <> "" ! "sent one
  BPROD$ = SPROD$;EPROD$ = SPROD$
  AUDIT = 0;eflag=0
  Goto STARTUPDATE
End If 
!Call "ProgDflt","059DLR","",CH_TEMP,X$
!If X$[1,5] <> "@@@@@" Let RLDATE = X$[1,6]
!Call "ProgDflt","059","",CH_TEMP,RETVAL$
!If RETVAL$[1,5] = "@@@@@" !"nothing saved yet
!  RETVAL$[1,6] = CUSTRNG[1] Using "######"
!  RETVAL$[7,12] = CUSTRNG[2] Using "######"
!  RETVAL$[13,15] = SLSMRNG[1] Using "###"
!  RETVAL$[16,18] = SLSMRNG[2] Using "###"
!  RETVAL$[19,30] = BPROD$;RETVAL$[31,42] = EPROD$
!  RETVAL$[43,44] = WHSERNG[1] Using "##"
!  RETVAL$[45,46] = WHSERNG[2] Using "##"
!  RETVAL$[47,47] = Str$(SORTBY)
!End If 
!CUSTRNG[1] = RETVAL$[1,6];CUSTRNG[2] = RETVAL$[7,12]
!SLSMRNG[1] = RETVAL$[13,15];SLSMRNG[2] = RETVAL$[16,18]
!BPROD$ = RETVAL$[19,30];EPROD$ = RETVAL$[31,42]
!WHSERNG[1] = RETVAL$[43,44];WHSERNG[2] = RETVAL$[45,46]
!SORTBY = RETVAL$[47,47]
STARTDISPLAY: Rem "
!Print 'CS ED';@0,0;"-MX059-";@20,0;"SUPERSEDE PERMANENT PRICE UPDATE"
!Print @22,2;"STARTING";@42,2;"ENDING"
!Print 'BD';@4,4;"ITEM CODES";
!Print @4,5;"CUSTOMERS";
!Print @4,6;"SALESPERSONS";
!Print @4,7;"WAREHOUSES";
!Print @4,9;"SORT REPORT BY:";
!Print 'ED';
X2 = RLDATE \ Gosub ISDUNPACK
!Print @5,14;"LAST RUN: ";X$;
!Print @1,4;"1>";@1,5;"2>";@1,6;"3>";@1,7;"4>";@1,9;"5>";
!Print @15,10;"Sorts: 1=slsm/cust/prod  2=cust/prod  3=prod/cust  4=wh/prod/cust"
!Print @20,4;BPROD$;@40,4;EPROD$
!Print @20,5;RETVAL$[1,6];@40,5;RETVAL$[7,12]
!Print @20,6;RETVAL$[13,15];@40,6;RETVAL$[16,18]
!Print @20,7;RETVAL$[43,44];@40,7;RETVAL$[45,46]
!Print @20,9;Str$(SORTBY)
EDT_ALL: Rem Change all
!For FLD = 1 To 5
!  Gosub EDT_FLDS
!Next FLD
message$=Blank$
message$="";eflag=0 ! add all issues - eflag>0 - no go
!Goto FINALQ
EDT_FLDS: Rem "where fields may lie
!On FLD Gosub EDT_FLD1,EDT_FLD2,EDT_FLD3,EDT_FLD4,EDT_FLD5
!Return 
EDT_FLD1: Rem "field one - Products
!J5$ = "Enter the Starting ORIGINAL PRODUCT to check for Supersedes"
!J0$ = "2 00122004";J1$ = BPROD$
!Gosub ISINPUT
call dxget("SPROD",tmp$)
if tmp$="" let tmp$=BPROD$
J$=UCase$(RTrim$(tmp$))+Blank$
BPROD$ = J$[1,12]
!J5$ = "Enter the Ending ORIGINAL PRODUCT to check for Supersedes"
!J0$ = "2 00124004";J1$ = EPROD$
!Gosub ISINPUT
call dxget("EPROD",tmp$)
if tmp$="" let tmp$=EProd$
J$=UCase$(RTrim$(tmp$))+EProd$ ! fill end
If J$ < BPROD$
  Message$ = Message$+"ENDING MUST BE GREATER THAN STARTING PRODUCT CODE  "
  !Gosub ISERRMSG
  Eflag=eflag+1 ! Goto Err_Msg ! EDT_FLD1
End If 
EPROD$ = J$[1,12]
RETVAL$[19,30] = BPROD$;RETVAL$[31,42] = EPROD$
!Return 
EDT_FLD2: Rem "field 2 - Customer Range
!J5$ = "Enter the starting Customer Number"
!J0$ = "3000062005";J1 = CUSTRNG[1]
!Gosub ISINPUT
call dxget("SCUST",tmp$)
if tmp$="" let tmp$=Str$(CUSTRNG[1])
CUSTRNG[1] = tmp$ ! J1
!J5$ = "Enter the ending Customer Number"
!J0$ = "3000064005";J1 = CUSTRNG[2]
!Gosub ISINPUT
call dxget("ECUST",tmp$)
if tmp$="" let tmp$=Str$(CUSTRNG[2])
j1=tmp$
If J1 < CUSTRNG[1]
  Message$ = Message$+"ENDING MUST BE GREATER THAN STARTING CUSTOMER CODE  "
  !Gosub ISERRMSG
  eflag=eflag+1 ! Goto Err_msg ! EDT_FLD2
End If 
CUSTRNG[2] = J1
RETVAL$[1,6] = CUSTRNG[1] Using "######"
RETVAL$[7,12] = CUSTRNG[2] Using "######"
!Return 
EDT_FLD3: Rem "field 3 - Slsm Range
!J5$ = "Enter the starting Salesperson Number - Customer Main"
!J0$ = "3000032006";J1 = SLSMRNG[1]
!Gosub ISINPUT
call dxget("SSLSM",tmp$)
if tmp$="" let tmp$=Str$(SLSMRNG[1])
j1=tmp$
SLSMRNG[1] = J1
!J5$ = "Enter the ending Salesperson Number - Customer Main"
!J0$ = "3000034006";J1 = SLSMRNG[2]
!Gosub ISINPUT
call dxget("ESLSM",tmp$)
if tmp$="" let tmp$=Str$(SLSMRNG[2])
j1=tmp$
If J1 < SLSMRNG[1]
  message$ = Message$+"ENDING MUST BE GREATER THAN STARTING SALESPERSON CODE  "
  !Gosub ISERRMSG
  eflag=eflag+1 ! Goto err_msg ! EDT_FLD3
End If 
SLSMRNG[2] = J1
RETVAL$[13,15] = SLSMRNG[1] Using "###"
RETVAL$[16,18] = SLSMRNG[2] Using "###"
!Return 
EDT_FLD4: Rem "field 4 - Whse Range
!J5$ = "Enter the starting Warehouse Number (0-99)"
!J0$ = "3000022007";J1 = WHSERNG[1]
!Gosub ISINPUT
Call dxget("SWHSE",tmp$)
if tmp$="" let tmp$=Str$(WHSERNG[1])
j1=tmp$
WHSERNG[1] = J1
!J5$ = "Enter the ending Warehouse Number"
!J0$ = "3000024007";J1$ = WHSERNG[2]
!Gosub ISINPUT
Call dxget("EWHSE",tmp$)
if tmp$="" let tmp$=Str$(WHSERNG[2])
j1=tmp$
If J1 < WHSERNG[1]
  Message$ = Message$+"ENDING MUST BE GREATER THAN STARTING WHSE  "
  !Gosub ISERRMSG
  eflag=eflag+1 ! Goto Err_msg ! EDT_FLD4
End If 
WHSERNG[2] = J1
RETVAL$[43,44] = WHSERNG[1] Using "##"
RETVAL$[45,46] = WHSERNG[2] Using "##"
!Return 
EDT_FLD5: Rem "field 5 - Sort Order
!J5$ = "Enter the Number for Report Print Order (1-4)"
!J0$ = "3000012009";J1 = SORTBY
!Gosub ISINPUT
call dxget("SORTBY",tmp$)
if tmp$="" let tmp$=Str$(SortBy)
j1=tmp$
If J1 < 1 Or J1 > 4 ! Goto EDT_FLD5
	Message$="INVALID SORT SELECTION  "
	eflag=eflag+1
Endif
SORTBY = J1
RETVAL$[47,47] = Str$(SORTBY)
!Return 
!! added on task 39434 - 24 mo usage?
Call dxget("UPDWUSG",tmp$) ! do update of 24 month rolling whse usage also
mw24u=0 \ if ucase$(RTrim$(tmp$))="Y" let mw24u=1
if mw24u ! then additional related questions
	Call dxget("CLRACP",tmp$) ! clr orig prod after copy
	clroacp=0 \ if ucase$(RTrim$(tmp$))="Y" let clroacp=1
	Call dxget("EAOROW",tmp$) ! existing - add or overwrite
	exwow=0 \ if ucase$(RTrim$(tmp$))="O" let exwow=1
endif
FINALQ: Rem "final question
AUDIT = 0
!Print @0,22;'CE';"ENTER:   #: field  R: all fields  S: save defaults  A: audit only  U: update";
!Print @0,23;" E: exit  ";
!Input Len 16384 + 2;""X$ \ Call String(1,X$)
call dxget("AUDONLY",tmp$)
x$="U" \ if UCase$(RTrim$(tmp$))="Y" let X$="A"
!If X$ = "E" Goto OUTEND
If X$ = "A" Let AUDIT = 1;X$ = "U"
if audit let mw24u=0 ! NO UPDATE ON AUDIT
If X$ = "U" Goto STARTUPDATE
!If X$ = "S" ! "save these defaults
!ASK_SAVE: Print @0,22;'CL';"Save for  A: all or  U: user access only, <CR>: do not save  ";
!  Input Len 16384 + 1;""J1$ \ Call String(1,J1$)
!  If J1$ = "" Print @0,22;'CL'; \ Goto FINALQ
!  If J1$ <> "A" And J1$ <> "U" Goto ASK_SAVE
!  If J1$ = "A" Let URECFLAG = 0 Else Let URECFLAG = 1
!  Call "Progdfltw","059","",CH_TEMP,RETVAL$,URECFLAG
!  Print @0,22;'CL';
!  Goto FINALQ
!End If 
!If X$ = "R" Goto EDT_ALL
!FLD = X$
!Gosub EDT_FLDS
!Goto FINALQ

STARTUPDATE: Rem "and we're off through the LastPrice file
if eflag>0 goto err_msg ! bad entry somewhere

If Not(AUDIT) ! "if not audit - save last run date
  X$ = " ",X$;URECFLAG = 0
  X$[1,6] = LRDATE Using "######"
  Call "Progdfltw","059DLR","",CH_TEMP,X$,URECFLAG
End If 
CHAN = 90 \ Gosub GETCHAN
CH_SORT = CHNL
FLE$ = "6/SORTWORK" + Str$(Spc(6))
Call FindF(FLE$,FOUND)
If FOUND Kill FLE$
J$ = " [2:64] " + FLE$
Build #CH_SORT,J$
J1 = 20;E = 0 ! keylen=20w/40C
Search #CH_SORT,0,1;K1$,J1,E \ If E Gosub ERR_SEARCH
J1 = 5;E = 0
Search #CH_SORT,0,0;K1$,J1,E \ If E Gosub ERR_SEARCH
If Not(AUDIT)
  !Print @0,22;'CE';"UPDATING LAST PRICE, PLEASE WAIT ";
Else 
  !Print @0,22;'CE';"SEARCHING LAST PRICE, PLEASE WAIT ";
End If
!If J8 = 0 !if pdf or print, new method, after edits,setouput,dxclose
  Call setoutput(e$,rstr$,2) !2 flag puts 0 status section in w/print in process msg, puts </page> in
!End If
NOREC[0] = 0;NOREC[1] = 0
K1$ = " ",K1$
K1$ = CUSTRNG[1] Using "######"
LP_LOOP: Rem "
Search #CH_LASTPR,3,1;K1$,R[CH_LASTPR],E \ If E = 2 Goto PRNTFLE
If E Gosub ERR_SEARCH
X2 = K1$[1,6] \ If X2 > CUSTRNG[2] Goto PRNTFLE
NOREC[0] = NOREC[0] + 1
!If Not(Fra(NOREC[0] / 250)) Print @40,22;'CL';"S=";NOREC[0];" F=";NOREC[1]
REC_LASTPR = R[CH_LASTPR]
Rem {begin src/inc/read.lastpr.i}
Mat Read #CH_LASTPR,REC_LASTPR,0;LP$
Read #CH_LASTPR,REC_LASTPR,12;LPDF
Mat Read #CH_LASTPR,REC_LASTPR,16;LPC1
Mat Read #CH_LASTPR,REC_LASTPR,28;LPC2
Mat Read #CH_LASTPR,REC_LASTPR,46;LPC3
Mat Read #CH_LASTPR,REC_LASTPR,56;LP2$
Mat Read #CH_LASTPR,REC_LASTPR,140;LPC4
Mat Read #CH_LASTPR,REC_LASTPR,164;LPMT$
Read #CH_LASTPR,REC_LASTPR,166;AI
Mat Read #CH_LASTPR,REC_LASTPR,168;LPR
Mat Read #CH_LASTPR,REC_LASTPR,198;LPR1
Mat Read #CH_LASTPR,REC_LASTPR,214;LPEUN
Mat Read #CH_LASTPR,REC_LASTPR,220;LPUNF
Mat Read #CH_LASTPR,REC_LASTPR,262;PERM
Read #CH_LASTPR,REC_LASTPR,274;LPWH
Mat Read #CH_LASTPR,REC_LASTPR,276;LPC5
Read #CH_LASTPR,REC_LASTPR,292;LPPCDATE
Read #CH_LASTPR,REC_LASTPR,296;LPLPERM
Mat Read #CH_LASTPR,REC_LASTPR,302;LPCURR
Read #CH_LASTPR,REC_LASTPR,314;LPCPT
Read #CH_LASTPR,REC_LASTPR,316;LPCSDT
Read #CH_LASTPR,REC_LASTPR,320;LPDEPT
Mat Read #CH_LASTPR,REC_LASTPR,324;LPFPERM
Mat Read #CH_LASTPR,REC_LASTPR,336;PPPUSERID
Mat Read #CH_LASTPR,REC_LASTPR,340;LPUNIT
Mat Read #CH_LASTPR,REC_LASTPR,352;PPPCID
Mat Read #CH_LASTPR,REC_LASTPR,424;PRVOD
Mat Read #CH_LASTPR,REC_LASTPR,436;PRVOQ
Rem {end read.lastpr.i}
Unlock #CH_LASTPR
If LPC4[3] Goto LP_LOOP
Rem CHECK ANY ITEM IN 117 THAT HAS A RECORD FOR RANGE/SUPERSEDE
If LP$ < BPROD$ Or LP$ > EPROD$ Goto LP_LOOP
If LPWH < WHSERNG[1] Or LPWH > WHSERNG[2] Goto LP_LOOP
K2$ = LPC1[0] Using "######"
Search #CH_CUST,2,1;K2$,R[CH_CUST],E \ If E > 1 Gosub ERR_SEARCH
If E = 1 Goto LP_LOOP
Mat Read #CH_CUST,R[CH_CUST],142;C1;
If C1[2] < SLSMRNG[1] Or C1[2] > SLSMRNG[2] Goto LP_LOOP
K3$ = LP$
Search #CH_PROD,2,1;K3$,R[CH_PROD],E \ If E > 1 Gosub ERR_SEARCH
If E = 1 Goto LP_LOOP
Mat Read #CH_PROD,R[CH_PROD],944;PR_A2$;
If SPROD$ ! "passed in
  PR_A2$[1,12] = NPROD$
End If 
If PR_A2$[1,1] = "" Or PR_A2$[1,6] = "      " Goto LP_LOOP
REC_OPROD = R[CH_PROD]
K4$ = PR_A2$[1,12]
Search #CH_PROD,2,1;K4$,R[CH_PROD],E \ If E > 1 Gosub ERR_SEARCH
If E = 1 Goto LP_LOOP
REC_NPROD = R[CH_PROD]
Mat Read #CH_PROD,R[CH_PROD],0;A$;
Rem see if we do anything with this supersede (N=no update
CALC = 0
If A$[128,128] = "F" Let CALC = 1
If A$[128,128] = "M" Let CALC = 2
If Not(CALC) Goto LP_LOOP
REC_PROD = R[CH_PROD] \ Gosub READ_PROD ! new prod
K5$ = " ",K5$;K5$ = K1$
Rem Let K5$[10]=K4$ ! "cust/dept(3)/prod - rest null
K5$[11] = K4$
Rem Let Dept=K5$[7,9] ! "dept (3)
DEPT = K5$[7,10]
!Search #CH_LASTPR,2,1;K5$,R[1],E \ If E > 1 Gosub ERR_SEARCH
gosub check_existing  !! check lp rec txc 235104
If Not(E) Goto LP_LOOP
NOREC[1] = NOREC[1] + 1
! If Not(Fra(NOREC[1] / 200)) Print @40,22;'CL';"S=";NOREC[0];" F=";NOREC[1]
Gosub GET_OPRODPRICE
If PERM[0] = 0 And LPC2[1] Let PERM[0] = LPC2[1]
If PERM[1] = 0 And LPC2[2] Let PERM[1] = LPC2[2]
Rem okay now - need stuff to call to "price" for getting cost!
REC_PROD = REC_NPROD \ Gosub READ_PROD
Mat Read #CH_PROD,REC_PROD,0;A$;
R[CH_PROD] = REC_NPROD;R[CH_PRWH] = 0
If WHSEPRC ! "whse pricing on
  K3$ = " ",K3$;K3$[1,12] = PR_A2$[1,12]
  K3$[13] = LPWH Using "##"
  Search #CH_PRWH,2,1;K3$,R[CH_PRWH],E \ If E > 1 Gosub ERR_SEARCH
  If E Let R[CH_PRWH] = 0
End If 
K3$ = " ",K3$;K3$ = A$[152,155]
Search #CH_COMD,2,1;K3$,R[CH_COMD],E \ If E > 1 Gosub ERR_SEARCH
If E Let R[CH_COMD] = 0
If E Goto LP_LOOP
PTYPE = C1[7]
Mat Read #CH_PTYP,PTYPE,28;PT;
DFT_COST = PT[0]
If Not(DFT_COST) Let DFT_COST = P60$[29,29]
Rem Do The Setup and Call
FLEPTR[1,1] = R[CH_PROD];FLEPTR[2,1] = R[CH_PRWH]
FLEPTR[3,1] = R[CH_COMD];FLEPTR[18,1] = R[CH_CUST]
Mat SPECS = Zer
SPECS[0] = 4
SPECS[3] = C1[1]
SPECS[4] = LPWH
SPECS[5] = LRDATE
SPECS[6] = DEPT
SPECS[7] = PTYPE
SPECS[8] = 1
SPECS[9] = DFT_COST
SPECS[13] = PFU1[9]
SPECS[14] = PFU1[12]
SPECS[15] = PFU1[11]
!Call "PRICE",FLEPTR[],SPECS[],MSGDESC$
Call SysPriceCalc(e$,FLEPTR[],SPECS[],MSGDESC$,0,"",rstr$)
If SPECS[0] Goto LP_LOOP
Rem Set up for report
X3 = 0
If PERM[0] <> 0 Let X3 = (PERM[0] - PERM[1]) * 100 / PERM[0]
OLDMARG = X3
REC_PROD = REC_OPROD \ Gosub READ_PROD
CNVTU[0] = 0;CNVTU[1] = PFU1[12];CNVTU[2] = 2
CNVTA = PERM[0] \ Gosub CONVERT
OLDSELL = AMOUNT
REC_PROD = REC_NPROD \ Gosub READ_PROD
PERM[1] = SPECS[17]
If CALC = 1 ! move flat price to new
  CNVTU[0] = PFU1[12];CNVTU[1] = 0;CNVTU[2] = 2
  CNVTA = OLDSELL \ Gosub CONVERT
  PERM[0] = AMOUNT
End If 
If CALC = 2 ! "keep margin (how do we do it? - using Mxline version)
  X3 = PERM[1]
  If OLDMARG <> 100 Let X3 = (PERM[1] / ((100 - OLDMARG) / 100))
  PERM[0] = X3
End If 
CNVTU[0] = 0;CNVTU[1] = PFU1[12];CNVTU[2] = 2
CNVTA = PERM[0] \ Gosub CONVERT
NEWSELL = AMOUNT
X3 = 0
If PERM[0] <> 0 Let X3 = (PERM[0] - PERM[1]) * 100 / PERM[0]
NEWMARG = X3
K6$ = " ",K6$
If SORTBY = 1 ! "by slsm/cust/prod
  K6$[1,4] = C1[2] Using "####"
  K6$[5,10] = C1[1] Using "######"
  K6$[11,22] = LP$
  K6$[23,24] = LPWH Using "##"
  K6$[25,28] = DEPT Using "####"
End If 
If SORTBY = 2 ! "by cust/product
  K6$[1,4] = C1[1] Using "######"
  K6$[5,16] = LP$
  K6$[17,18] = LPWH Using "##"
  K6$[19,22] = DEPT Using "####"
End If 
If SORTBY = 3 ! "by product/customer
  K6$[1,12] = LP$
  K6$[13,18] = C1[1] Using "######"
  K6$[19,20] = LPWH Using "##"
  K6$[21,22] = DEPT Using "####"
End If 
If SORTBY = 4 ! "by wh/prod/cust
  K6$[1,2] = LPWH Using "##"
  K6$[3,14] = LP$
  K6$[15,20] = C1[1] Using "######"
  K6$[21,24] = DEPT Using "####"
End If 
Search #CH_SORT,2,1;K6$,R[CH_SORT],E \ If E > 1 Gosub ERR_SEARCH
If Not(E) Goto LP_LOOP
E = 2;R[0] = 0
Search #CH_SORT,1,0;K6$,R[0],E \ If E Gosub ERR_SEARCH
R[CH_SORT] = R[0]
Mat Write #CH_SORT,R[CH_SORT],0;LPWH;
Write #CH_SORT,R[CH_SORT],2;C1[1];
Write #CH_SORT,R[CH_SORT],6;C1[2];
Mat Write #CH_SORT,R[CH_SORT],12;DEPT;
Mat Write #CH_SORT,R[CH_SORT],16;LP$;
let oldprod$[1,12]=lp$[1,12]
let newprod$[1,12]=pr_a2$[1,12]
LP$ = PR_A2$[1,12]
Mat Write #CH_SORT,R[CH_SORT],28;LP$;
Mat Write #CH_SORT,R[CH_SORT],40;OLDSELL;
Mat Write #CH_SORT,R[CH_SORT],46;OLDMARG;
Mat Write #CH_SORT,R[CH_SORT],52;NEWSELL;
Mat Write #CH_SORT,R[CH_SORT],58;NEWMARG;
Write #CH_SORT,R[CH_SORT],64;CALC;
Search #CH_SORT,4,1;K6$,R[CH_SORT],E \ If E Gosub ERR_SEARCH
If AUDIT Goto LP_LOOP
Rem now clear / set up for new product
E = 2;R[0] = 0
Search #CH_LASTPR,1,0;K2$,R[0],E \ If E Gosub ERR_SEARCH
R[CH_LASTPR] = R[0]
LPDF = 0
LPC1[1] = 0;LPC1[2] = 0
LPC2[0] = 0;LPC2[1] = 0;LPC2[2] = 0
LPC3[0] = 0
LPC3[2] = PFU1[9];LPC3[3] = PFU1[12];LPC3[4] = PFU1[11]
LP2$[1,20] = A$[93,112];LP2$[21,50] = A$[9,38];LP2$[51,80] = A$[63,92]
LP2$[81,84] = A$[152,155]
LPC4[0] = 0;LPC4[1] = B[24];LPC4[2] = B[11]
LPMT$ = A$[156,156]
AI = 1
LPR[0] = 0;LPR[1] = 0;LPR[2] = 0;LPR[3] = 0;LPR[4] = 0
LPR1[0] = A[6];LPR1[1] = B[23]
LPR1[2] = 0
LPEUN[0] = PFU1[0];LPEUN[1] = PFU1[10]
LPEUN[2] = -7
Gosub GET_FACTORS
LPUNF[6] = 0;LPC5[0] = 0;LPC5[1] = 0
LPC5[2] = SPECS[26]
! LPC5[3] = 0;
LPPCDATE = Tim(6);LPLPERM = 0
LPCURR[0] = 0;LPCURR[1] = 0
LPCPT = 0;LPCSDT = 0
LPFPERM[0] = 0;LPFPERM[1] = 0
PPPUSERID = 0;LPUNIT[0] = 0;LPUNIT[1] = 0
PPPCID[0] = 0;PPPCID[1] = 0
REC_LASTPR = R[CH_LASTPR]
for x=0 to 2 \ let prvod[x]=0 \ next x
for x=0 to 3 \ let prvoq[x]=0 \ next x
B4Key$=" ",B4Key$
Rem {begin src/inc/write.lastpr.i}
Mat Write #CH_LASTPR,REC_LASTPR,0;LP$
Write #CH_LASTPR,REC_LASTPR,12;LPDF
Mat Write #CH_LASTPR,REC_LASTPR,16;LPC1
Mat Write #CH_LASTPR,REC_LASTPR,28;LPC2
Mat Write #CH_LASTPR,REC_LASTPR,46;LPC3
Mat Write #CH_LASTPR,REC_LASTPR,56;LP2$
Mat Write #CH_LASTPR,REC_LASTPR,140;LPC4
Mat Write #CH_LASTPR,REC_LASTPR,164;LPMT$
Write #CH_LASTPR,REC_LASTPR,166;AI
Mat Write #CH_LASTPR,REC_LASTPR,168;LPR
Mat Write #CH_LASTPR,REC_LASTPR,198;LPR1
Mat Write #CH_LASTPR,REC_LASTPR,214;LPEUN
Mat Write #CH_LASTPR,REC_LASTPR,220;LPUNF
Mat Write #CH_LASTPR,REC_LASTPR,262;PERM
Write #CH_LASTPR,REC_LASTPR,274;LPWH
Mat Write #CH_LASTPR,REC_LASTPR,276;LPC5
Write #CH_LASTPR,REC_LASTPR,292;LPPCDATE
Write #CH_LASTPR,REC_LASTPR,296;LPLPERM
Mat Write #CH_LASTPR,REC_LASTPR,302;LPCURR
Write #CH_LASTPR,REC_LASTPR,314;LPCPT
Write #CH_LASTPR,REC_LASTPR,316;LPCSDT
Write #CH_LASTPR,REC_LASTPR,320;LPDEPT
Mat Write #CH_LASTPR,REC_LASTPR,324;LPFPERM
Mat Write #CH_LASTPR,REC_LASTPR,336;PPPUSERID
Mat Write #CH_LASTPR,REC_LASTPR,340;LPUNIT
Mat Write #CH_LASTPR,REC_LASTPR,352;PPPCID;
Mat Write #CH_LASTPR,REC_LASTPR,424;PRVOD;
Mat Write #CH_LASTPR,REC_LASTPR,436;PRVOQ;
Mat Write #CH_LASTPR,REC_LASTPR,460;B4Key$;
Rem {end write.lastpr.i}
K2$ = " ",K2$
K2$[1,6] = LPC1[0] Using "######"
Rem Let K2$[7,9]=LPc3[1] Using "###" ! "dept # (3)
Rem Let K2$[10,21]=LP$[1,12] ! "product code (12 of 20)
Rem Let K2$[30,35]=LPC4[1] Using "######" ! "vendor #
Rem Let K2$[36,39]=LP2$[81,84] ! "commcode
K2$[7,10] = LPDEPT Using "####"
K2$[11,22] = LP$[1,12]
K2$[23,30] = "        "
K2$[31,36] = LPC4[1] Using "######"
K2$[37,40] = LP2$[81,84]
Search #CH_LASTPR,4,1;K2$,R[CH_LASTPR],E \ If E Gosub ERR_SEARCH
K3$ = " ",K3$
Rem Let K3$[1,9]=K2$[1,9] ! "cust/dept
Rem Let K3$[10,13]=K2$[36,39] ! "commcode
Rem Let K3$[14,33]=K2$[10,29] ! "item code
Rem Let K3$[34,39]=K2$[30,35] ! "vendor
K3$[1,10] = K2$[1,10]
K3$[11,14] = K2$[37,40]
K3$[15,34] = K2$[11,30]
K3$[35,40] = K2$[31,36]
Search #CH_LASTPR,4,2;K3$,R[CH_LASTPR],E \ If E Gosub ERR_SEARCH
K4$ = " ",K4$
Rem Let K4$[1,9]=K2$[1,9] ! "cust/dept
Rem Let K4$[10,15]=(999999-LPR1[2]) Using "######" ! "reverse freq
Rem Let K4$[16,45]=K2$[10,39] ! "prod/vend/commd
K4$[1,10] = K2$[1,10]
K4$[11,16] = (999999 - LPR1[2]) Using "######"
K4$[17,46] = K2$[11,40]
Search #CH_LASTPR,4,3;K4$,R[CH_LASTPR],E \ If E Gosub ERR_SEARCH
K5$ = " ",K5$
Rem Let K5$[1,6]=K2$[30,35] ! "vendor #
Rem Let K5$[7,10]=K2$[36,39] ! "commcode
Rem Let K5$[11,30]=K2$[10,29] ! "item code
Rem Let K5$[31,39]=K2$[1,9] ! "cust/dept (3)
K5$[1,10] = K2$[31,40]
K5$[11,30] = K2$[11,30]
K5$[31,40] = K2$[1,10]
Search #CH_LASTPR,4,4;K5$,R[CH_LASTPR],E \ If E Gosub ERR_SEARCH
If LPDIR5 !NEW FOR REV9(SOMETIMES) DIRCETORY 5 - LASTPRICE FILE
  K55$ = " ",K55$
  K55$[1,30] = K5$[11,40]
  K55$[31,40] = K5$[1,10]
  Search #CH_LASTPR,4,5;K55$,R[CH_LASTPR],E
  If E Gosub ERR_SEARCH
End If 
if ch_sllp<>0 gosub updsllp: ! thru cust/all sl for old prod - add new prod
!
if mw24u gosub mwuupdt ! not audit + copy 24 mo usage too
!
Goto LP_LOOP
READ_PROD: Rem "read fields for convert
Mat Read #CH_PROD,REC_PROD,156;B;
Mat Read #CH_PROD,REC_PROD,256;A;
Mat Read #CH_PROD,REC_PROD,460;A1;
Mat Read #CH_PROD,REC_PROD,512;PFU1;
Mat Read #CH_PROD,REC_PROD,554;PFU2;
Return 
GET_FACTORS: Rem "need the factor for U/M's
For X1 = 0 To 3
  If X1 < 3 Let UNIT = LPC3[X1 + 2] Else Let UNIT = PFU1[10]
  If X1 And UNIT <= 0 Let LPUNF[X1] = 0 \ Goto L_30165
  For X2 = 0 To 7
    If PFU1[X2] = UNIT Goto L_30140
  Next X2
L_30140: If X2
    LPUNF[X1] = PFU2[X2 - 1]
  Else 
    LPUNF[X1] = 1
  End If 
L_30165: Next X1
LPUNF[4] = A1[3] \ If Not(LPUNF[4]) Let LPUNF[4] = 1
LPUNF[5] = A[5] \ If Not(LPUNF[5]) Let LPUNF[5] = 1
Return 
CNVTU[0] = 0;CNVTU[1] = LPC3[2];CNVTU[2] = 1
CNVTA = 1 \ Gosub CONVERT
LPUNF[0] = AMOUNT
CNVTU[0] = 0;CNVTU[1] = LPC3[3];CNVTU[2] = 2
CNVTA = 1 \ Gosub CONVERT
LPUNF[1] = AMOUNT
CNVTU[0] = 0;CNVTU[1] = LPC3[4];CNVTU[2] = 2
CNVTA = 1 \ Gosub CONVERT
LPUNF[2] = AMOUNT
CNVTU[0] = 0;CNVTU[1] = LPEUN[1];CNVTU[2] = 1
CNVTA = 1 \ Gosub CONVERT
LPUNF[3] = AMOUNT
Return 

Get_SLFactors: ! "need the factor for U/M's - SHIPLIST FILE
FOR X1=0 TO 3 ! "how mxline does it! 0=sell,1=prc,2=cost,3=purch
	IF X1<3 LET UNIT=SLPC3[X1+2] ELSE  LET UNIT=PFU1[10]
	IF X1 AND UNIT<=0 LET SLPUNF[X1]=0 \ GOTO getnextx1: ! "lot or cwt
	FOR X2=0 TO 7
		IF PFU1[X2]=UNIT GOTO ummatch:
	NEXT X2
ummatch: IF X2<>0
		LET SLPUNF[X1]=PFU2[X2-1] ! "not base
	ELSE 
		LET SLPUNF[X1]=1 ! "base
	ENDIF 
getnextx1: NEXT X1
LET SLPUNF[4]=A1[3] \ IF NOT (SLPUNF[4]) LET SLPUNF[4]=1 ! "cube factor
LET SLPUNF[5]=A[5] \ IF NOT (SLPUNF[5]) LET SLPUNF[5]=1 ! "weight factor
Return 

GET_OPRODPRICE: Rem "get price/cost for Original Item?
REC_PROD = REC_OPROD \ Gosub READ_PROD
Mat Read #CH_PROD,REC_PROD,0;A$;
R[CH_PRWH] = 0
If WHSEPRC ! "whse pricing on
  K3$ = " ",K3$;K3$[1,12] = LP$[1,12]
  K3$[13] = LPWH Using "##"
  Search #CH_PRWH,2,1;K3$,R[CH_PRWH],E \ If E > 1 Gosub ERR_SEARCH
  If E Let R[CH_PRWH] = 0
End If 
K3$ = " ",K3$;K3$ = A$[152,155]
Search #CH_COMD,2,1;K3$,R[CH_COMD],E \ If E > 1 Gosub ERR_SEARCH
If E Let R[CH_COMD] = 0
If E Return 
PTYPE = C1[7]
Mat Read #CH_PTYP,PTYPE,28;PT;
DFT_COST = PT[0]
If Not(DFT_COST) Let DFT_COST = P60$[29,29]
Rem Do The Setup and Call
FLEPTR[1,1] = REC_PROD;FLEPTR[2,1] = R[CH_PRWH]
FLEPTR[3,1] = R[CH_COMD];FLEPTR[18,1] = R[CH_CUST]
FLEPTR[4,1] = R[CH_LASTPR]
Mat SPECS = Zer
SPECS[0] = 0
SPECS[3] = C1[1]
SPECS[4] = LPWH
SPECS[5] = LRDATE
SPECS[6] = DEPT
SPECS[7] = PTYPE
SPECS[8] = 1
SPECS[9] = DFT_COST
SPECS[13] = PFU1[9]
SPECS[14] = PFU1[12]
SPECS[15] = PFU1[11]
!Call "PRICE",FLEPTR[],SPECS[],MSGDESC$
Call SysPriceCalc(e$,FLEPTR[],SPECS[],MSGDESC$,0,"",rstr$)
If SPECS[0] ! "somekind of error - NO PRICE/COST UPDATE
  SPECS[20] = 0;SPECS[17] = 0
End If 
If SPECS[20] Let PERM[0] = SPECS[20]
If SPECS[17] Let PERM[1] = SPECS[17]
If PERM[0] = 0 And LPC2[1] Let PERM[0] = LPC2[1]
If PERM[1] = 0 And LPC2[2] Let PERM[1] = LPC2[2]
Return 
check_existing: rem see if new cust prod record has odd dept key fields
k5$[7,10]="   0"
check_exist_loop: search #ch_lastpr,3,1;k5$,r[1],e \ if e>2 gosub err_search
if e=2 return ! got to eof, no exists
if k5$[1,6]<>k1$[1,6] then e=1 \ return  ! no match
if k5$[11,22]=k4$[1,12] then e=0 \ return !matched prod
if p9$[44,44]<>"Y" then e=1 \ return  ! no match if dept off
goto check_exist_loop:
return
PRNTFLE: Rem "print the sorted list
!Print @0,22;'CE';"COMPLETE, RECORDS SEARCHED=";NOREC[0];" FOUND=";NOREC[1];
!Signal 3,15
!Print @0,23;"PRINTING, PLEASE WAIT. . .";
NOREC = 0;NPROD$ = ""
K1$ = " ",K1$
PRLINE = 99;PRLINE[1] = 60;PRLINE[2] = 0
PRLINE[3] = -99;PRLINE[4] = -99
SF_LOOP: Rem "
Search #CH_SORT,3,1;K1$,R[CH_SORT],E \ If E = 2 Goto PRNTDONE
If E Gosub ERR_SEARCH
if k1$[1,2]="}}" goto sf_loop ! into whse usage keys!
NOREC = NOREC + 1
!If Not(Fra(NOREC / 200)) Print @40,23;NOREC;K1$[1,10];
If SORTBY = 1 ! "by slsm/cust/prod
  X2 = K1$[1,4] \ If X2 <> PRLINE[3] Let PRLINE = 99
  X2 = K1$[5,10]
  If X2 <> PRLINE[4] And PRLINE[4] <> -99 ! "don't do for first one
    Print #CH_LPT;"\15\" \ PRLINE = PRLINE + 2
  End If 
  PRLINE[3] = K1$[1,4];PRLINE[4] = K1$[5,10]
End If 
If SORTBY = 2 ! "by cust/product
  X2 = K1$[1,6]
  If X2 <> PRLINE[3] And PRLINE[3] <> -99 ! "don't do for first one
    Print #CH_LPT;"\15\" \ PRLINE = PRLINE + 2
  End If 
  PRLINE[3] = K1$[1,6]
End If 
If SORTBY = 3 ! "by prod/cust
  If K1$[1,12] <> NPROD$ And NPROD$ <> "" ! "don't do on first one
    Print #CH_LPT;"\15\" \ PRLINE = PRLINE + 2
  End If 
  NPROD$ = K1$[1,12]
End If 
If SORTBY = 4 ! "by whse/prod
  X2 = K1$[1,2]
  If X2 <> PRLINE[3] And PRLINE[3] <> -99 !"don't do on first one
    Print #CH_LPT;"\15\" \ PRLINE = PRLINE + 2
  End If 
  PRLINE[3] = K1$[1,2]
End If 
Mat Read #CH_SORT,R[CH_SORT],0;LPWH;
Read #CH_SORT,R[CH_SORT],2;C1[1];
Read #CH_SORT,R[CH_SORT],6;C1[2];
Mat Read #CH_SORT,R[CH_SORT],12;DEPT;
Mat Read #CH_SORT,R[CH_SORT],16;BPROD$;
Mat Read #CH_SORT,R[CH_SORT],28;EPROD$;
Mat Read #CH_SORT,R[CH_SORT],40;OLDSELL;
Mat Read #CH_SORT,R[CH_SORT],46;OLDMARG;
Mat Read #CH_SORT,R[CH_SORT],52;NEWSELL;
Mat Read #CH_SORT,R[CH_SORT],58;NEWMARG;
Read #CH_SORT,R[CH_SORT],64;CALC;
K2$ = " ",K2$;K2$ = C1[1] Using "######"
Search #CH_CUST,2,1;K2$,R[CH_CUST],E
If E
  C1$ = " ",C1$;C1$[31,50] = "CUSTOMER NOT FOUND!"
Else 
  Mat Read #CH_CUST,R[CH_CUST],0;C1$;
End If 
K2$ = " ",K2$;K2$ = BPROD$
Search #CH_PROD,2,1;K2$,R[CH_PROD],E \ If E Gosub ERR_SEARCH
REC_PROD = R[CH_PROD] \ Gosub READ_PROD
Mat Read #CH_PROD,R[CH_PROD],0;A$;
PUM$ = "    "
If PFU1[12] = -1 Let PUM$ = "CWT "
If PFU1[12] = -2 Let PUM$ = "LOT "
If PFU1[12] = -3 Let PUM$ = "LB  "
If PFU1[12] > 0 Read #CH_CCODE,PFU1[12],10;PUM$;
K2$ = " ",K2$;K2$ = EPROD$
Search #CH_PROD,2,1;K2$,R[CH_PROD],E \ If E Gosub ERR_SEARCH
REC_PROD = R[CH_PROD] \ Gosub READ_PROD
Mat Read #CH_PROD,R[CH_PROD],0;NA$;
PUM2$ = "    "
If PFU1[12] = -1 Let PUM2$ = "CWT "
If PFU1[12] = -2 Let PUM2$ = "LOT "
If PFU1[12] = -3 Let PUM2$ = "LB  "
If PFU1[12] > 0 Read #CH_CCODE,PFU1[12],10;PUM2$;
Gosub PRNT_HEADER
Gosub PRNT_DETAIL
Goto SF_LOOP
PRNT_DETAIL: Rem "Record Detail (NO SPECS ON WHAT SHOULD PRINT!)
Print #CH_LPT; Using "######"; Tab 1;C1[1];
Print #CH_LPT; Tab 9;C1$[31,60];
Print #CH_LPT; Using "###"; Tab 42;C1[2];
Print #CH_LPT; Using "####"; Tab 56;DEPT;
Print #CH_LPT; Tab 61;BPROD$;
Print #CH_LPT; Tab 74;A$[9,38];
Print #CH_LPT; Using "######.####"; Tab 105;OLDSELL;" ";PUM$;
Print #CH_LPT; Using "----#.###"; Tab 122;FNT(OLDMARG)
If CALC = 1 Print #CH_LPT; Tab 40;"KEEP SAME PRICE";
If CALC = 2 Print #CH_LPT; Tab 40;"KEEP SAME MARGIN";
Print #CH_LPT; Using "##"; Tab 58;LPWH;
Print #CH_LPT; Tab 61;EPROD$;
Print #CH_LPT; Tab 74;NA$[9,38];
Print #CH_LPT; Using "######.####"; Tab 105;NEWSELL;" ";PUM2$;
Print #CH_LPT; Using "----#.###"; Tab 122;FNT(NEWMARG)
Print #CH_LPT;""
PRLINE = PRLINE + 3
Return 
PRNT_HEADER: Rem "report header here - assume never screen print
If PRLINE < PRLINE[1] Return 
If PRLINE[2] ! "on page 1+
  Print #CH_LPT;"\14\";
  Print #CH_LPT;""
End If 
PRLINE[2] = PRLINE[2] + 1
X$ = LRDATE Using "&&&&&&" \ Call FormatDate(X$,X$,E)
Print #CH_LPT;" DATE: ";X$;
Print #CH_LPT; Tab 51;CONM$;
Print #CH_LPT; Tab 118;"PAGE";PRLINE[2]
X$ = "" \ Call Time(X$)
Print #CH_LPT;"-059- ";X$[1,26];
Print #CH_LPT; Tab 47;"SUPERSEDE ITEM PERMANENT PRICE CREATE";
If AUDIT Print #CH_LPT;" - AUDIT";
Print #0;""
Print #0;""
Print #0; Tab 1;"CUST #"; Tab 9;"CUSTOMER NAME"; Tab 41;"SLSM";
Print #0; Tab 56;"DEPT"; Tab 61;"ORIG ITEM"; Tab 74;"DESCRIPTION";
Print #0; Tab 105;"PERM PRICE"; Tab 117;"U/M"; Tab 125;"MARGIN"
Print #0; Tab 58;"WH"; Tab 61;"SUPERSEDE"
Print #0;""
PRLINE = 7
Return 
PRNTDONE: Rem "done - over and out
If CH_SORT Close #CH_SORT
FLE$ = "6/SORTWORK" + Str$(Spc(6))
Call FindF(FLE$,FOUND)
If FOUND Try Kill FLE$ Else Rem
Goto OUTEND
mwuupdt: ! do the whse usage update
! 1st check to see if orig product has been done
K6$=" ",k6$;K6$[1,2]="}}";k6$[3]=oldprod$ ! if did old prod once - skip
search #ch_sort,2,1;k6$,r[6],e
if not(e) return 
if e>1 gosub err_search
! ok - didn't update before - now is Base Same UM? (ex:no CS base to EA Base!!!)
Mat Read #CH_PROD,REC_OPROD,512;PFU1;
HBSUM=pfu1[0] ! orig prod base
Mat Read #CH_PROD,REC_NPROD,512;PFU1; ! new(supersede) prod
if pfu1[0]<>HBSUM goto OPRDDone ! per SPECS - BASE DIFFERENT - NO GO!
K3$=" ",k3$;K3$[1,12]=oldprod$
nxtpwr: ! next prodwhse rec
search #ch_prwh,3,1;k3$,Rec_PrWh,e \ if e goto OPRDDone
if k3$[1,12]<>oldprod$ goto OPRDDone
x2=k3$[13,14] \ if x2<WHSERNG[1] or x2>WHSERNG[2] goto nxtpwr ! whse range
Mat Read #CH_PrWh,Rec_PrWh,228;W5
k4$=" ",k4$;k4$=k3$
k4$[1,12]=newprod$ ! the supersede prod - same whse
search #ch_prwh,2,1;k4$,R[ch_prwh],e \ if e>1 gosub err_search
if e ! need to build record!
	LET towhse=k4$[13,14] 
	LET WHBLD[0]=ch_prwh;WHBLD[1]=towhse;WHBLD[2]=B[24] ! "chanel/whse/vnd/re
	! LET X1[6]=k4$[13,14]
	!CALL "MXWHCREATE",to_prod$,WHBLD[]
	call mxwhcreate(e$,IntCo,NewPROD$,WHBLD[])
	! prodwhsecreated=prodwhsecreated+1
	R[ch_prwh]=whbld[2] ! new rec #
Endif
mat read #ch_prwh,R[ch_prwh],228;tOW5
  mat read #ch_prwh,R[ch_prwh],540;tOWH9
  Mat Read #CH_PrWh,R[ch_prwh],756;toWH3$      
  for mth=1 to 24 ! was 12 ! ? only 12 months?? task mentions 24!
	  if not(exwow) let tow5[mth]=tow5[mth]+w5[mth] ! add
	  if exwow let tow5[mth]=w5[mth] ! overwrite
	  w5[mth]=0
	  towh9[mth]=0 ! clear new adj's
	  towh3$[mth,mth]=" " ! only has [24]
  next mth
  if not(exwow) let tow5[25]=tow5[25]+w5[25] ! get to [25]
  if exwow let tow5[25]=w5[25] ! overwrite
  w5[25]=0;towh9[25]=0 ! 
  mat write #ch_prwh,R[ch_prwh],228;tOW5;
  mat write #ch_prwh,R[ch_prwh],540;tOWH9; 
  Mat write #CH_PrWh,R[ch_prwh],756;toWH3$;  
  if clroacp Mat write #CH_PrWh,Rec_PrWh,228; W5; ! clr orig pwh
  if not(clroacp) Unlock #CH_PRWH ! just in case
goto nxtpwr
OPRDDone: ! done
K6$=" ",k6$;k6$[1,2]="}}";k6$[3]=oldprod$ ! record we've done it
search #ch_sort,4,1;k6$,Rec_PrWh,e \ if e>1 gosub err_search
return
Rem {begin call.input.i}
ISINPUT: Rem  Drop-in change to Call Input   G.Doscher  10/29/96
!Call "Input",J1,J$,J0$,J1$,J4$,J5$
Return 
ISERRMSG: !X1 = Len(J7$)
!Window Open @(38 - X1 / 2),(Msc(34) / 2 - 2); Size (X1 + 6),3; Using ""
!Print @0,0;" ";'K0 BR RB';" ";J7$;" ";'ER'; \ Signal 3,X1 / 2 + 10
!Print 'K1'; \ Window Close \ Return 
Return
ISDUNPACK: Rem  *UNPACK DATE  X2 TO X$      V1.0  4/04/84  G.DOSCHER
X$ = " ",X$ \ X$[10] = ""
X$[1,3] = Int(X2 / 10 ^ 2 - Int(X2 / 10 ^ 4) * 10 ^ 2) + 10 ^ 2 Using "###"
X$[4,6] = Fra(X2 / 10 ^ 2) * 10 ^ 2 + 10 ^ 2 Using "###"
X$[7,9] = Int(X2 / 10 ^ 4) + 10 ^ 2 Using "###"
X$[4,4] = "/" \ X$[7,7] = "/" \ X$ = X$[2]
If Not(X2) Let X$ = "        "
Return 
ISDPACK: Rem  *PACK DATE    X$ TO X2      V1.0  4/04/84  G.DOSCHER
X2 = X$[4,5] \ X1 = X$[1,2] \ X2 = X2 + X1 * 10 ^ 2
X1 = X$[7,8] \ X2 = X2 + X1 * 10 ^ 4
Return 
Rem {end call.input.i}
Rem {begin src/inc/rtn.getchan.i}
GETCHAN: Rem search for open channel (counts down from supplied chnl #)
CHNL=findchannel()
Return 
CHNLFREE: Rem check to see if a channel is being used
!If Err 0 Let CHNLFREE = Spc(8)
!CHNLFREE = 0
!CHNLSCR = Chf(CHNL)
!If Err 0 Gosub ERR_ESCAPE
!If CHNLFREE And CHNLFREE <> 49 Gosub ERR_TRAP
!END_CHNLFREE: Rem
Return 
Rem {end rtn.getchan.i}
Rem {begin rtn.convert.s}
CONVERT: Rem "UNIT CONVERSION RETURNS AMOUNT  (rev 01/07/1992)   ! 20040 REM
If CNVTU[2] = 3 Or CNVTU[2] = 4 Goto CVTSTARTA
If CNVTU[2] = 1 And CNVTU[1] = CNVTU[0] Let AMOUNT = CNVTA \ Goto CVTDONE
If CNVTU[0] = -2 Or CNVTU[1] = -2 Let AMOUNT = CNVTA \ Goto CVTDONE
If CNVTU[2] = 0 Goto CVTSTARTA
If Not(CNVTA) Let AMOUNT = 0 \ Goto CVTDONE
CVTSTARTA: Rem ALL UB 5+!!  IF SPC 4>1280 GOTO cvtstartb: ! "unibasic 5+
Rem REM "======= unibasic <5 logic
Rem SWAP 1,"MXPRCONV"
Rem IF CNVTU[2]=3 or CNVTU[2]=4 GOTO cvtdone: ! "um window
Rem cvttry: ! "this is a remark
Rem SIGNAL 2,X1,AMOUNT,FLAG \ IF X1=-1 LET E=0 \ GOSUB err_search:
Rem IF X1<>SPC(6) GOTO cvttry:
Rem IF CNVTU[2]=0 GOTO cvtdone: !!TEST IF VALID CONVERSION
Rem IF FLAG LET E=FLAG \ GOSUB err_search:
Rem GOTO cvtdone:
CVTSTARTB: Rem "====== unibasic 5+ logic
!Call "MXPRCONV5",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG
Call "MXPRCONV5.dl4",PFU1[],PFU2[],A[],CNVTU[],CNVTA,SC,SR,FLAG,e$,rstr$
If CNVTU[2] = 0 Goto CVTDONE
If FLAG Let E = FLAG \ Gosub ERR_SEARCH
AMOUNT = CNVTA
CVTDONE: Return 
Rem {end rtn.convert.s}
Rem {begin rtn.error.s}
ERR_MSG: ! something is awry
Returnstatus=1 ! on blk id - means no good
call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
  call AddToStr(e$,rstr$,WebStr$)
  call SetOutPut(e$,rstr$)
End
ERR_SEARCH: Rem
ENUM = E + 1000;ELINE = Spc(16);CTERR = 0
If E = 5 Let CTERR = Err(8)
msg$ = "RETURN STATUS",(E + (CTERR * .001))
msg$ = msg$,"/ STATEMENT",ELINE," IN PROGRAM "+Msc$(4)
Message$=Msg$
Call programdump("tmp/059se!","")
goto Err_Msg:
! start new
!!!!! --- Shiplist Last Price ------
updsllp: ! Update Last Price Shiplist File
if not(ch_sllp) return !! now clear / set up for new product
let slkey$=" ",slkey$
let slkey$[1,6]=lpc1[0] using "######" ! customer code
srchslp: ! search shiplist file
search #ch_sllp,3,1;slkey$,rec_tmp,e
if e=2 return ! end of file
if e<>0 gosub err_search:
let tmp3=slkey$[1,6]\if tmp3<>lpc1[0] return ! end of customer
mat read #ch_sllp,rec_tmp,0;slp$;
if slp$[1,12]<> oldprod$[1,12] goto srchslp:
! read old ship list last price file 
    Read #CH_Sllp,rec_tmp, 12;slpDF   
Mat Read #CH_Sllp,rec_tmp, 16;slpC1   
Mat Read #CH_Sllp,rec_tmp, 28;slpC2   
Mat Read #CH_Sllp,rec_tmp, 46;slpC3       
Mat Read #CH_Sllp,rec_tmp, 56;slp2$       
Mat Read #CH_Sllp,rec_tmp,140;slpC4       
Mat Read #CH_Sllp,rec_tmp,164;slpMT$      
    Read #CH_Sllp,rec_tmp,166;sAI         
Mat Read #CH_Sllp,rec_tmp,168;slpR        
Mat Read #CH_Sllp,rec_tmp,198;slpR1       
Mat Read #CH_Sllp,rec_tmp,214;slpEUN      
Mat Read #CH_Sllp,rec_tmp,220;slpUNF      
Mat Read #CH_Sllp,rec_tmp,262;sPERM       
    Read #CH_Sllp,rec_tmp,274;slpWH       
Mat Read #CH_Sllp,rec_tmp,276;slpC5       
    Read #CH_Sllp,rec_tmp,292;slpPCDate   
    Read #CH_Sllp,rec_tmp,296;slpLPerm    
Mat Read #CH_Sllp,rec_tmp,302;slpCurr     
    Read #CH_Sllp,rec_tmp,314;slpCPT      
    Read #CH_Sllp,rec_tmp,316;slpCSDT   
    Read #CH_Sllp,Rec_tmp,320;slpDept
Mat Read #CH_Sllp,rec_tmp,324;slpFPerm    
Mat Read #CH_Sllp,rec_tmp,336;sppPUserId  
Mat Read #CH_Sllp,rec_tmp,340;slpUnit     
Mat Read #CH_Sllp,rec_tmp,352;sppPCID     
! Mat Read #CH_Sllp,rec_tmp,372;sppermcst;
Mat Read #CH_Sllp,rec_tmp,424;PRVOD;
Mat Read #CH_Sllp,rec_tmp,436;PRVOQ;
! Mat Read #CH_Sllp,rec_tmp,460;B4Key$;
let slp$[1,12]=newprod$[1,12]
!Let SLPDf=0 - shiplist code save as is
Let SLPC1[1]=0;SLPC1[2]=0 ! "order # / Date
Let SLPC2[0]=0;SLPC2[1]=0;SLPC2[2]=0 ! "order qty/price/cost ! "IT'S NEW!!
Let SLPC3[0]=0 ! "price type?
Let SLPC3[2]=PFU1[9];SLPC3[3]=PFU1[12];SLPC3[4]=PFU1[11] ! "sell/price/cost
Let SLP2$[1,20]=A$[93,112];SLP2$[21,50]=A$[9,38];SLP2$[51,80]=A$[63,92] ! "vi/desc
Let SLP2$[81,84]=A$[152,155] ! "new commod code
Let SLPC4[0]=0;SLPC4[1]=B[24];SLPC4[2]=B[11] ! "ordline#,vendor,ctgy
Let SLPMt$=A$[156,156] ! "new mat code
Let SAI=1 ! "set as ALT ITEM
Let SLPR[0]=0;SLPR[1]=0;SLPR[2]=0;SLPr[3]=0;SLPR[4]=0 ! "brk,contr,prvord,m&ytd sls
Let SLPR1[0]=A[6];SLPR1[1]=B[23] ! "weight/cube unit
Let SLPR1[2]=0 ! "frequency kenneth
Let SLPEUN[0]=PFU1[0];SLPEUN[1]=PFU1[10] ! "base/purch u/m
Let SLPEUN[2]=-7 ! "Manual Perm Price
Gosub Get_SLFactors: ! "NEED U/M Factors in LASTPRICE!!(or 0 price/cost!)
Let SLPUNF[6]=0;SLPC5[0]=0;SLPC5[1]=0 ! "lyr sls,lastcost,rebt
Let SLPC5[2]=Specs[26] ! "cost origin (Permanent)
!Let SLPC5[3]=0 -- Keep Tax Code as is
Let SLPPCDate=Tim(6);SLPLPERM=0 ! "tax,chgdate,prev
Let SLPCURR[0]=0;SLPCURR[1]=0 ! "curr sys price/cost
Let SLPCPT=0;SLPCSDT=0 ! "curr sys price type/calc date
Let SLPFPERM[0]=0;SLPFPERM[1]=0 ! "future perm price/date
Let SPPPUSERID=0;SLPUNIT[0]=0;SLPUNIT[1]=0 ! "perm prc chg by,SLP unit price/cost
Let SPPPCID[0]=0;SPPPCID[1]=0 ! "pend perm chg date/time
! "the last few may not be on rev 8 - so include shouldn't have them
for x=0 to 2 \ let prvod[x]=0 \ next x
for x=0 to 3 \ let prvoq[x]=0 \ next x
B4Key$=" ",B4Key$
! Let Rec_LastPr=R[ch_lastpr]
! directory 1                                                      
Let slkey1$=" ",slkey1$                                            
Let slkey1$[1,6]=sLPc1[0] Using "######" ! "cust #                 
let slkey1$[7,12]=slpdf using "&&&&&&"                             
Let slkey1$[13,16]=sLPDept Using "####" ! "dept (4) (rev 9!)       
Let slkey1$[17,28]=sLP$[1,12] ! "prod code (12 of 20)              
Let slkey1$[29,36]="        "                                      
Let slkey1$[37,40]=sLP2$[81,84] ! "comm code                       
Search #ch_sllp,2,1;slkey1$,R[ch_sllp],E\if e>1 gosub err_search:   
if not(e) goto srchslp: ! already on file
let e=2 \Search #ch_sllp,1,0;slkey1$,rec_sllp,E \ if e gosub err_search:     
Let R[ch_sllp]=Rec_sllp! "new record for new key                             
Mat Write #CH_Sllp,rec_sllp,  0;slp$  
    Write #CH_Sllp,rec_sllp, 12;slpDF 
Mat Write #CH_Sllp,rec_sllp, 16;slpC1 
Mat Write #CH_Sllp,rec_sllp, 28;slpC2 
Mat Write #CH_Sllp,rec_sllp, 46;slpC3      
Mat Write #CH_Sllp,rec_sllp, 56;slp2$      
Mat Write #CH_Sllp,rec_sllp,140;slpC4      
Mat Write #CH_Sllp,rec_sllp,164;slpMT$     
    Write #CH_Sllp,rec_sllp,166;sAI        
Mat Write #CH_Sllp,rec_sllp,168;slpR       
Mat Write #CH_Sllp,rec_sllp,198;slpR1      
Mat Write #CH_Sllp,rec_sllp,214;slpEUN     
Mat Write #CH_Sllp,rec_sllp,220;slpUNF     
Mat Write #CH_Sllp,rec_sllp,262;sPERM      
    Write #CH_Sllp,rec_sllp,274;slpWH      
Mat Write #CH_Sllp,rec_sllp,276;slpC5      
    Write #CH_Sllp,rec_sllp,292;slpPCDate  
    Write #CH_Sllp,rec_sllp,296;slpLPerm   
Mat Write #CH_Sllp,rec_sllp,302;slpCurr    
    Write #CH_Sllp,rec_sllp,314;slpCPT     
    Write #CH_Sllp,rec_sllp,316;slpCSDT  
    Write #CH_Sllp,rec_sllp,320;slpDept
Mat Write #CH_Sllp,rec_sllp,324;slpFPerm   
Mat Write #CH_Sllp,rec_sllp,336;sppPUserId 
Mat Write #CH_Sllp,rec_sllp,340;slpUnit    
Mat Write #CH_Sllp,rec_sllp,352;sppPCID    
!Mat Write #CH_Sllp,rec_sllp,372;sppermcst; 
Mat Write #CH_SLLP,rec_sllp,424;PRVOD;
Mat Write #CH_SLLP,rec_sllp,436;PRVOQ;
Mat Write #CH_SLLP,rec_sllp,460;B4Key$;
! directory 1
Search #ch_sllp,4,1;slkey1$,R[ch_sllp],E \ if e gosub err_search:
! direcotory 2
Let slkey2$=" ",slkey2$
Let slkey2$[1,6]=sLPc1[0] Using "######" ! "cust #
let slkey2$[7,12]=slpdf using "&&&&&&" ! SHIP LIEST
Let slkey2$[13,16]=sLPDept Using "####" ! "dept (4) (rev 9!)
Let slkey2$[17,20]=sLP2$[81,84] ! "commcode
Let slkey2$[21,32]=slp$[1,12]! "prod code (12)
Search #ch_sllp,4,2;slkey2$,R[ch_sllp],E \ if e gosub err_search:
! directory 3
Let slkey3$=" ",slkey3$
Let slkey3$[1,6]=sLPc1[0] Using "######" ! "cust #
let slkey3$[7,12]=slpdf using "&&&&&&" ! SHIP LIEST
Let slkey3$[13,16]=sLPDept Using "####" ! "dept (4) (rev 9!)
Let slkey3$[17,22]=(999999-sLPR1[2]) Using "######" ! "rev freq
let slkey3$[23,34]=slp$[1,12] ! product code
let slkey3$[35,42]="        " 
let slkey3$[43,46]=slp2$[81,84] ! 
Search #ch_sllp,4,3;slkey3$,R[ch_sllp],e \ if e gosub err_search:
! directory 4
Let slkey4$=" ",slkey4$
Let slkey4$[1,6]=sLPc1[0] Using "######" ! "cust #
Let slkey4$[7,10]=sLPDept Using "####" ! "dept (4) (rev 9!)
Let slkey4$[11,22]=slp$[1,12] ! product code
let slkey4$[23,30]="        " 
Let slkey4$[31,36]=slpdf using "&&&&&&"
let slkey4$[37,40]=sLP2$[81,84] ! "comm code
Search #ch_sllp,4,4;slkey4$,R[ch_sllp],E \ if e gosub err_search:
If SLPDIR5 !NEW FOR REV10(SOMETIMES) DIRCETORY 5 - SLLASTPRICE FILE
  K55$ = " ",K55$
  K55$[1,20] = slkey1$[17,36] ! prod
  K55$[21,36] = slkey1$[1,16];K55$[37] = slkey1$[37] ! cust/sl/dpt;commod
  Search #ch_sllp,4,5;K55$,R[ch_sllp],E
  If E Gosub ERR_SEARCH
End If 
goto srchslp: ! search shiplist file
Return

OUTEND: Rem "good bye
If Err 0 Rem
If CH_PROD Close #CH_PROD
If CH_PRWH Close #CH_PRWH
If CH_COMD Close #CH_COMD
If CH_CUST Close #CH_CUST
If CH_CCODE Close #CH_CCODE
If CH_LASTPR Close #CH_LASTPR
If CH_SPCP Close #CH_SPCP
If CH_CONT Close #CH_CONT
If CH_BRKT Close #CH_BRKT
If CH_CUST Close #CH_CUST
if ch_sllp<>0 close #ch_sllp
Close #CH_LPT
If Err 0 Gosub ERR_TRAP
If SPROD$<>"" ! "used a single prod (from 671?)
  End 
End If 
!Chain "MX000"
End
ERR_TRAP: Rem *Error routine (escape trap)   V3.1 8/94 G.DOSCHER/REK
!
!!Rem {end rtn.error.s}
include "src/callmainerrnet.inc"
End 