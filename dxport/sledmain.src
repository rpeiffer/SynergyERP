Rem     SLEDMAIN   SALES LEAD VERSION 2.0  MAIN MODULE
Rem     GEORGE DOSCHER  FEB-1992
!
! loadsave -w -n 100,10 -o prog/dxport/sledmain.dl4 src/sledmain.src
!
Rem BEDIT Version: 2.2 OBJECT CODE     Created: APR 17, 2002  12:03:49
Rem /usr/acct/r97//usr/acct/zyc/work/r97/sled/sledmain.src (univ2) [zyc] {51121}
Rem  Copyright (c) 2002 Universal Business Systems, Inc.
Rem    **** ALL CHANGES MUST BE MADE IN SOURCE!!! ****
Rem
include "src/copyright.inc" ! dx
Include "src/inc/fileprtdefault.inc" ! port defaults
External Lib "libgeneral.lib"
Declare External Sub GetSession,AddToStr,SetOutput,CreateNetStatus
External Lib "ubsfunc.dl4"
Declare External Function OpenFile,JDate$,PDate$,formatdate2$
Declare External Sub UserCntrl,GetPortDefault
Declare Intrinsic Sub DateToJulian,FindF,InpBuf,JulianToDate,String,VerifyDate
Declare Function chkDateFrmt$
! Option Default Dialect IRIS1
Try 
Dim 1%,SALESMAN,TSSLSM,SC,SR,Z9[9] ! was com
Dim 3%,PORTNUM ! was com
Dim J4$[70],TSKEY$[16],CUSTNAME$[30],ZMODE$[8] ! was com
Dim prt. as prtdefault
Dim tmp$[200],tmp1$[200],UserId$[10],WebStr$[1500],Blank$[128],Message$[200]
dim e$[500],buttonlist$[5,50],nextlist$[5,100] !error handling variables
dim action$[30],options$[30],b$[200],action1$[30],msg$[256],action2$[30]
Dim bsdel$[10],esdel$[10],rdel$[10],fdel$[10],rstr$[2000]
Dim J$[70],J0$[12],J1$[70],J2$[20],J3$[40],J5$[80],J7$[80],J9$[70],P9$[50]
Dim K2$[25],K3$[20],K3H$[20],LP$[20],TFILE$[20],U5$[80],2%,K9,K1
Dim DAYS$[22],SLM$[360],SLM1$[8],KD3$[20],KD3H$[20],SLD$[68],SLDD$[80]
Dim CSTAT$[20],SC$[174],SCODE$[20],X$[20],DFLAG$[1],PM$[60],F9$[60]
Dim PH$[60],CDESC$[40],HldNm$[30]
Dim 1%,UREC,IntCo,Ctlc
Dim 2%,maxcnt \ maxcnt=50 ! init max records in arrays for list
dim List$[maxcnt,1500] ! for .net (larger size - LOTSA DATA)
Dim 1%,SC1[9],SLM3[6],SLMA[4],WF,X1[9]
Dim 2%,FR,G4[6],SC2[7],SLD[5],SLDD[1],SLM2[13],SA[12],X2[9],CUSTSEC[1]
Dim 3%,J9[9],X3[9]
Dim 4%,J1,SLM1[5]
Dim SC$[174],SCA$[16],SCB$[16],SCC$[16],SCD$[16],SCE$[16],SCF$[11]
Dim SCG$[14],SCH$[14],SCI$[14],SCZ$[10]
Def FNH(X) = Int(X / 100)
Def FNM(X) = Fra(X / 100) * 100
Blank$=" ",Blank$
! call dxopen() - done in pomenu
!Try Let intCo = Val(tmp$) Else Let intCo = 1 !company #  
!ctlc = OpenFile(9999,intCo) \ If ctlc = -1 Error 42 !control   ! openning with read/write
call GetSession(e$,CTLC,options$,action$,UserID$,intCo,intSls,fdel$,rstr$,bsdel$,esdel$,rdel$,action1$,action2$)
! OPTIONS$ & ACTION$ used in SLMENU.dl4 for routing
COID = IntCo
X1 = COID
!J$ = X1 Using "CNTRL#" \ If X1 > 9 Let J$ = X1 Using "CNTRL##"
!Close \ Open #1,J$ ! done as ro in getsession
UserId$=UCase$(Userid$)+Blank$
Call GetPortDefault(e$,IntCO,UserID$,portnum,rec_uac,prt.)
Mat Read #1,19,50;P9$;
! PORTNUM=25 ! ================  REMOVE UPON FLIGHT =============================================
! Open #78,"USERPORT"
! Mat Read #78,Spc(6),10;PORTNUM;
! Close #78  ! FOR ERP PORT NUMBERS CHANGE EVERY TIME IN & ARE 4000+
If Not(PORTNUM) ! HAVE TO HAVE IT!
	!Let PORTNUM = Rec_Uac ! Spc(6)
	Let returnstatus=0
	Message$="NO DEFAULT PORT FOR USER ID "+Userid$
	Goto OutDone
Endif

Read #1,88,1072;J$[1,16];  ! Sledcntrl
X1=j$[1,1]
if x1=0 ! no lu
	tmp$="files/1/"+J$
	Open #5,tmp$
Else ! has lu
Open #5,J$[1,16] ! sledcntrl
Endif
J$ = "2/APPTMGR"+Str$(COID)
! Call FindF(J$,APPTFLG) (web uses equivalent) NOTE: does not Update PM APPT MGR!
J$ = "##########" \ Search #5,2,1;J$,FCR,E
If E ! Gosub ERR_SEARCH
	ReturnStatus=0
	Message$="FILE CONTROL KEY NOT FOUND!"
	Goto OutDone
Endif
For X1 = 2 To 6
  Read X2
  If X2 <> -1
    If Abs(X2) < 10 ^ 4
      Read #1,88,Abs(X2);J$[1,16];
    Else 
      Read #5,FCR,(Abs(X2) - 10 ^ 4);J$[1,16];
    End If 
	tmp$="files/"+J$[1,16] ! need this??
    If X2 > 0 Open #X1,J$[1,16] Else Ropen #X1,J$[1,16]
  End If 
Next X1
Data "10016","10032","10048","-1","1824"
Read #1,88,1552;J$[1,16]; \ J$[17] = "" \ Call FindF(J$,X1)
WF = 0 ! \ If X1 Open #10,J$ \ WF = 1 ! NO WINDOWWORK USED!
DAYS$ = "SunMonTueWedThuFriSat"
! TFILE$ = PORTNUM Using "SLEDTMP&&&&" ! NO LONGER USED!
CSTAT$ = "CANCELACTIVE comp "
SLMA[0] = 2 \ SLMA[1] = 4 \ SLMA[2] = 1 ! offset of filter dates 
Gosub L_7900 ! current date/time (for filters)
! check filter master
J$ = PORTNUM Using "@###      "
Search #5,2,1;J$,R5,E
If E
  If E=1
	E = 2 \ Search #5,1,0;J$,R5,E \ If E Gosub ERR_SEARCH
	FR = 0 \ Write #5,R5;FR;
	Search #5,4,1;J$,R5,E \ If E Gosub ERR_SEARCH
  Else
	gosub ERR_SEARCH ! bomb 
  Endif
Endif
R5D=R5 ! master record for port
! FOR ACTUAL FILTERS - THE KEY IS FFFFFFPPPP  (filterid, port)
! Gosub GETFILTER ! current filter (ONLY DO WHEN NEEDED!)

Action1$=UCase$(Action1$) ! upper case
Action1$=RTrim$(Action1$) ! trim
Action2$=UCase$(Action2$)
Action2$=RTrim$(Action2$) ! make sure UPPERCASE and No blanks at end
ReturnStatus=0
Message$="ACTION1 NOT FOUND"
Select Case Action1$
	
	Case "SHOFILTER" ! Start off						doc=SL-ShowFilter.doc
		Gosub GETFILTER ! current filter
		Clear List$[]
		List$[0]=bsdel$,"CURRFILTER",fdel$
		List$[1]="ID",fdel$,"NAME",fdel$
		If SC$[1,6] = "      "
			List$[2]="  ",fdel$,"no filters in effect",fdel$
		Else 
			List$[2]=SC$[1,6],fdel$,RTrim$(SC$[7,26]),fdel$
		End If 
		List$[3]=esdel$
		call AddToStr(e$,rstr$,List$[]) ! add droplist to string
		! needs a end of section
		ReturnStatus=1
		Message$="OK"
		!end of start
	
	Case "GETFILTER" ! get filter for edit				doc=SL-GetFilter.doc
		ReturnStatus=1
		message$="OK"
		Call DXGet("ID",tmp$) ! just id
		tmp$=UCase$(Trim$(tmp$)) ! UC & trim
		If tmp$="" goto OutDone
		J$=tmp$+Blank$
		LET K2$=PORTNUM USING "####" \ LET K2$[5]=J$
		SEARCH #5,2,1;K2$,R5,E
		IF E ! none to get 
			R5=0 ! will pass back blanks
		Endif
		FR=R5 ! uses FR?
		Gosub L_8445 ! read existing
		R5=FR
		Clear List$[]
		tmpcnt=maxcnt
		List$[0]=bsdel$,"FILTERDATA",fdel$
		WebStr$="ID",fdel$,"DESC",fdel$
		WebStr$=WebStr$,"BC1",fdel$,"COMPANY",fdel$
		WebStr$=WebStr$,"BC2",fdel$,"ADDRESS",fdel$
		WebStr$=WebStr$,"BC3",fdel$,"CITY",fdel$
		WebStr$=WebStr$,"BC4",fdel$,"STATE",fdel$
		WebStr$=WebStr$,"BC5",fdel$,"ZIPCODE",fdel$
		WebStr$=WebStr$,"BC6",fdel$,"CONTACT",fdel$
		WebStr$=WebStr$,"BC7",fdel$,"REMARKS",fdel$
		WebStr$=WebStr$,"BC8",fdel$,"PHONE",fdel$
		WebStr$=WebStr$,"MC1",FDEL$,"CALLBACK",fdel$
		WebStr$=WebStr$,"MC2",fdel$,"LASTCALL",fdel$
		WebStr$=WebStr$,"MC3",fdel$,"CREATE",fdel$
		WebStr$=WebStr$,"MC4",fdel$,"SLSVOL",fdel$
		WebStr$=WebStr$,"MC5",fdel$,"PROJSLS",fdel$
		WebStr$=WebStr$,"MC6",fdel$,"LOCS",fdel$
		WebStr$=WebStr$,"SLSM",fdel$,"NAME",fdel$
		WebStr$=WebStr$,"CTGY",fdel$,"CATDESC",fdel$
		WebStr$=WebStr$,"SIC1",fdel$,"SIC2",fdel$,"SIC3",fdel$
		WebStr$=WebStr$,"REFER",fdel$,"REFDESC",fdel$
		WebStr$=WebStr$,"QLTY",fdel$,"QLDESC",fdel$
		WebStr$=WebStr$,"COMPT",fdel$,"CPDESC",fdel$
		List$[1]=WebStr$
		Row=2
		WebStr$=SC$[1,6],fdel$,RTrim$(SC$[7,26]),fdel$
		WebStr$=WebStr$,SC$[27,27],fdel$,RTrim$(SC$[28,42]),fdel$
		WebStr$=WebStr$,SC$[43,43],fdel$,RTrim$(SC$[44,58]),fdel$
		WebStr$=WebStr$,SC$[59,59],fdel$,RTrim$(SC$[60,74]),fdel$
		IF SC$[75,76]<>"  " tmp$="=" ELSE  tmp$=" "
		WebStr$=WebStr$,tmp$,fdel$,SC$[75,76],fdel$
		IF SC$[77,77]<>" " tmp$="B" ELSE  tmp$=" "
		WebStr$=WebStr$,tmp$,fdel$,RTrim$(SC$[77,81]),fdel$
		WebStr$=WebStr$,SC$[82,82],fdel$,RTrim$(SC$[83,97]),fdel$
		WebStr$=WebStr$,SC$[98,98],fdel$,RTrim$(SC$[99,113]),fdel$
		WebStr$=WebStr$,SC$[114,114],fdel$,RTrim$(SC$[115,124]),fdel$
		FOR IPS=0 TO 2
			LET IPY=IPS+2 \ LET X2=SC2[IPS] \ GOSUB L_5500
		NEXT IPS
		WebStr$=WebStr$,SC$[172,172],fdel$,Str$(SC2[6]),fdel$
		WebStr$=WebStr$,SC$[173,173],fdel$,Str$(SC2[7]),fdel$
		WebStr$=WebStr$,SC$[174,174],fdel$,Str$(SC1[6]),fdel$
		SLM2[9]=SC1[1] \ gosub getslsm
		WebStr$=WebStr$,Str$(SC1[1]),fdel$,RTrim$(J$),fdel$
		LET NCODE=SC1[2] \ gosub PRINTCODE
		WebStr$=WebStr$,SCODE$[17,20],fdel$,RTrim$(SCODE$[1,15]),fdel$
		For X1=0 to 2
			LET J4$="    "
			IF SC2[3+X1]
				!LET J$=SC2[3+X1] \ LET J4$="____" \ LET J4$[1,LEN(J$)-2]=J$[2]
				J4$=Str$(SC2[3+X1])
			ENDIF 
			WebStr$=WebStr$,J4$,fdel$
		Next X1
		LET NCODE=SC1[3] \ gosub PRINTCODE
		WebStr$=WebStr$,SCODE$[17,20],fdel$,RTrim$(SCODE$[1,15]),fdel$
		LET NCODE=SC1[4] \ gosub PRINTCODE
		WebStr$=WebStr$,SCODE$[17,20],fdel$,RTrim$(SCODE$[1,15]),fdel$
		LET NCODE=SC1[5] \ gosub PRINTCODE
		WebStr$=WebStr$,SCODE$[17,20],fdel$,RTrim$(SCODE$[1,15]),fdel$
		List$[row]=WebStr$
		row=row+1
		if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
		List$[row]=esdel$
		call AddToStr(e$,rstr$,List$[]) ! add droplist to string
		!end of get filter
	Case "SVFILTER" ! retain filter data				doc=SL-SaveFilter.doc
		ReturnStatus=1
		Message$="OK"
		! have to stuff it ALL back in
		Call DXGet("ID",tmp$)
		if tmp$="" goto outdone ! nothing there
		tmp$=UCASE$(RTRIM$(tmp$))
		SC$[1,6]=tmp$+blank$
		Call DXGet("DESC",tmp$)
		SC$[7,26]=tmp$+blank$
		Call DXGet("BC1",tmp$) \ tmp$=UCASE$(tmp$)
		if tmp$<>"B" and tmp$<>"C"  let tmp$=""
		SC$[27,27]=tmp$+blank$
		Call DXGet("COMPANY",tmp$)
		if sc$[27,27]=" " let tmp$="" ! no operator - no data
		if tmp$="" let sc$[27,27]=" " ! no data - no operator
		SC$[28,42]=tmp$+blank$
		Call DXGet("BC2",tmp$) \ tmp$=UCASE$(tmp$)
		if tmp$<>"B" and tmp$<>"C"  let tmp$=""
		SC$[43,43]=tmp$+blank$
		Call DXGet("ADDRESS",tmp$)
		if sc$[43,43]=" " let tmp$="" ! no operator - no data
		if tmp$="" let sc$[43,43]=" " ! no data - no operator
		SC$[44,58]=tmp$+blank$
		Call DXGet("BC3",tmp$) \ tmp$=UCASE$(tmp$)
		if tmp$<>"B" and tmp$<>"C"  let tmp$=""
		SC$[59,59]=tmp$+blank$
		Call DXGet("CITY",tmp$)
		if sc$[59,59]=" " let tmp$="" ! no operator - no data
		if tmp$="" let sc$[59,59]=" " ! no data - no operator
		SC$[60,74]=tmp$+blank$
		Call DXGet("BC4",tmp$) ! not used (always "=")
		Call DXGet("STATE",tmp$)
		SC$[75,76]=tmp$+blank$
		Call DXGet("BC5",tmp$) ! not used (always "B")
		Call DXGet("ZIPCODE",tmp$)
		SC$[77,81]=tmp$+blank$
		Call DXGet("BC6",tmp$) \ tmp$=UCASE$(tmp$)
		if tmp$<>"B" and tmp$<>"C"  let tmp$=""
		SC$[82,82]=tmp$+blank$
		Call DXGet("CONTACT",tmp$)
		if sc$[82,82]=" " let tmp$="" ! no operator - no data
		if tmp$="" let sc$[82,82]=" " ! no data - no operator
		SC$[83,97]=tmp$+blank$
		Call DXGet("BC7",tmp$)  \ tmp$=UCASE$(tmp$)
		if tmp$<>"B" and tmp$<>"C"  let tmp$=""
		SC$[98,98]=tmp$+blank$
		Call DXGet("REMARKS",tmp$)
		if sc$[98,98]=" " let tmp$="" ! no operator - no data
		if tmp$="" let sc$[98,98]=" " ! no data - no operator
		SC$[99,113]=tmp$+blank$
		Call DXGet("BC8",tmp$) \ tmp$=UCASE$(tmp$)
		if tmp$<>"B" and tmp$<>"C"  let tmp$=""
		SC$[114,114]=tmp$+blank$
		Call DXGet("PHONE",tmp$)
		if sc$[114,114]=" " let tmp$="" ! no operator - no data
		if tmp$="" let sc$[114,114]=" " ! no data - no operator
		SC$[115,124]=tmp$+blank$
		Call DXGet("MC1",tmp$)
		if tmp$<>">" and tmp$<>"=" and tmp$<>"<" let tmp$=""
		SC$[169,169]=tmp$+blank$ ! 0
		Call DXGet("CALLBACK",tmp$)
		if sc$[169,169]=" " let tmp$="" ! no operator - no data
		if tmp$="" let sc$[169,169]=" " ! no data - no operator
		X2=9999
		If Len(tmp$)<4 let X2=tmp$
		If ABS(X2)<101 ! # Days
			SC2[0]=X2
		Else ! date
			tmp$=chkDateFrmt$(tmp$)
			tmp1$=formatdate2$(tmp$) ! mm/dd/yyyy or mm/dd/yy to yyyymmdd
			SC2[0]=tmp1$[3,8] ! drop century
		Endif
		Call DXGet("MC2",tmp$)
		if tmp$<>">" and tmp$<>"=" and tmp$<>"<" let tmp$=""
		SC$[170,170]=tmp$+blank$ ! 1
		Call DXGet("LASTCALL",tmp$)
		if sc$[170,170]=" " let tmp$="" ! no operator - no data
		if tmp$="" let sc$[170,170]=" " ! no data - no operator
		X2=9999
		If Len(tmp$)<4 let X2=tmp$
		If ABS(X2)<101 ! # Days
			SC2[1]=X2
		Else ! date
			tmp$=chkDateFrmt$(tmp$)
			tmp1$=formatdate2$(tmp$) ! mm/dd/yyyy or mm/dd/yy to yyyymmdd
			SC2[1]=tmp1$[3,8] ! drop century
		Endif
		Call DXGet("MC3",tmp$)
		if tmp$<>">" and tmp$<>"=" and tmp$<>"<" let tmp$=""
		SC$[171,171]=tmp$+blank$ ! 2
		Call DXGet("CREATE",tmp$)
		if sc$[171,171]=" " let tmp$="" ! no operator - no data
		if tmp$="" let sc$[171,171]=" " ! no data - no operator
		X2=9999
		If Len(tmp$)<4 let X2=tmp$
		If ABS(X2)<101 ! # Days
			SC2[2]=X2
		Else ! date
			tmp$=chkDateFrmt$(tmp$)
			tmp1$=formatdate2$(tmp$) ! mm/dd/yyyy or mm/dd/yy to yyyymmdd
			SC2[2]=tmp1$[3,8] ! drop century
		Endif
		Call DXGet("MC4",tmp$)
		if tmp$<>">" and tmp$<>"=" and tmp$<>"<" let tmp$=""
		SC$[172,172]=tmp$+blank$
		Call DXGet("SLSVOL",tmp$)
		if sc$[172,172]=" " let tmp$="" ! no operator - no data
		if tmp$="" let sc$[172,172]=" " ! no data - no operator
		SC2[6]=tmp$
		Call DXGet("MC5",tmp$)
		if tmp$<>">" and tmp$<>"=" and tmp$<>"<" let tmp$=""
		SC$[173,173]=tmp$
		Call DXGet("PROJSLS",tmp$)
		if sc$[173,173]=" " let tmp$="" ! no operator - no data
		if tmp$="" let sc$[173,173]=" " ! no data - no operator
		SC2[7]=tmp$
		Call DXGet("MC6",tmp$)
		if tmp$<>">" and tmp$<>"=" and tmp$<>"<" let tmp$=""
		SC$[174,174]=tmp$
		Call DXGet("LOCS",tmp$)
		if sc$[174,174]=" " let tmp$="" ! no operator - no data
		if tmp$="" let sc$[174,174]=" " ! no data - no operator
		SC1[6]=tmp$
		Call DXGet("SLSM",tmp$)
		SC1[1]=tmp$
		Call DXGet("CTGY",tmp$)
		j$=tmp$+Blank$;j$[5]="";z9=1
		Gosub GetCode \ NCode=0
		SC1[2]=Ncode
		Call DXGet("SIC1",tmp$)
		SC2[3]=tmp$ ! 0
		Call DXGet("SIC2",tmp$)
		SC2[4]=tmp$ ! 1
		Call DXGet("SIC3",tmp$)
		SC2[5]=tmp$ ! 2
		Call DXGet("REFER",tmp$)
		j$=tmp$+Blank$;j$[5]="";z9=2
		Gosub GetCode \ NCode=0
		SC1[3]=NCode
		Call DXGet("QLTY",tmp$)
		j$=tmp$+Blank$;j$[5]="";z9=3
		Gosub GetCode \ NCode=0
		SC1[4]=NCode
		Call DXGet("COMPT",tmp$)
		j$=tmp$+Blank$;j$[5]="";z9=4
		Gosub GetCode \ NCode=0
		SC1[5]=NCODE
		! okay - none get record
		LET K2$=PORTNUM USING "####" \ LET K2$[5]=SC$[1,6]
		SEARCH #5,2,1;K2$,R5,E
		IF E ! none to get 
			If E=1
				Let E=2;R5=0
				Search #5,1,0;k2$,R5,E
				if e
					returnstatus=0
					message$="ERROR "+STR$(E)+" ADDING RECORD"
					Goto OutDone
				Endif
				MAT  WRITE #5,R5;SC$;
				MAT  WRITE #5,R5,224;SC1;
				MAT  WRITE #5,R5,244;SC2;
				SEARCH #5,4,1;K2$,R5,E
				IF E !!GOSUB Err_Search:
					returnstatus=0
					message$="ERROR "+STR$(E)+" ADDING KEY1"
					Goto OutDone
				Endif
				LET J4$=K2$[5,10],K2$[1,4]
				SEARCH #5,4,2;J4$,R5,E
				IF E !!GOSUB Err_Search:
					returnstatus=0
					message$="ERROR "+STR$(E)+" ADDING KEY2"
					Goto OutDone
				Endif
			Else ! search error
				returnstatus=0
				message$="ERROR "+STR$(E)+" CHECKING FILE"
				Goto OutDone
			Endif
		Endif
		! okay write file
		MAT  WRITE #5,R5;SC$;
		MAT  WRITE #5,R5,224;SC1;
		MAT  WRITE #5,R5,244;SC2;
		!end of save filter
	Case "DELFILTER" ! delete filter					doc=SL-DeleteFilter.doc
		ReturnStatus=1
		message$="OK"
		Call DXGet("ID",tmp$) ! just id
		tmp$=UCase$(Trim$(tmp$)) ! UC & trim
		If tmp$="" goto OutDone
		J$=tmp$+Blank$
		LET K2$=PORTNUM USING "####" \ LET K2$[5]=J$
		SEARCH #5,2,1;K2$,R5,E
		IF E ! none to get 
			Goto OutDone
		Endif
		SEARCH #5,5,1;K2$,R5,E
		IF E !!GOSUB Err_Search:
			returnstatus=0
			message$="ERROR "+STR$(E)+" DELETING KEY1"
			Goto OutDone
		Endif
		LET U5$=K2$[5,10],K2$[1,4]
		SEARCH #5,5,2;U5$,R5,E
		IF E !!GOSUB Err_Search:
			returnstatus=0
			message$="ERROR "+STR$(E)+" DELETING KEY2"
			Goto OutDone
		Endif
		LET E=3 \ SEARCH #5,1,0;K2$,R5,E
		IF E !!GOSUB Err_Search:
			returnstatus=0
			message$="ERROR "+STR$(E)+" RETURNING RECORD"
			Goto OutDone
		Endif
		! end of delete filter
	Case "SELFILTER" ! save selected filter				doc=SL-SelectFilter.doc
		! selected a filter
		ReturnStatus=1
		Message$="OK"
		LET J$=PORTNUM USING "@###      " ! must be master rec for port
		SEARCH #5,2,1;J$,R5D,E \ IF E GOSUB Err_Search:
		Call DXGet("ID",tmp$)
		tmp$=UCase$(Trim$(tmp$)) ! UC & trim
		f9$=PORTNUM USING "####"+tmp$+Blank$
		LET FR=0
		IF F9$[5,8]<>"    "
			SEARCH #5,2,1;F9$,FR,E
			IF E
				ReturnStatus=0
				Message$="FILTER ID NOT FOUND! CHANGING TO NO FILTER"
				Let FR=0 ! GOSUB Err_Search:
			Endif
		ENDIF 
		WRITE #5,R5D;FR; ! write filter rec to master
		! Gosub GetFilter (Not Needed here!)
		
		!end of select filter
	Case "CPFILTER" ! copy old to new					doc=SL-CopyFilter.doc
		ReturnStatus=1
		Message$="OK"
		! check if from exists first
		Call DXGET("CPFLKEY",tmp$)
		tmp$=UCase$(Trim$(tmp$)) ! UC & trim
		j1$=tmp$+Blank$
		J1$[11]="" ! 10 is limit
		!LET K2$=PORTNUM USING "####" \ LET K2$[5]=J1$
		K3$=J1$ ! sending full key (could copy diff port filter)
		if k3$=K2$ ! copy itself - no way!
			ReturnStatus=0
			Message$="COPY TO AND FROM ARE THE SAME!"
			Goto OutDone ! say its ok
		Endif
		SEARCH #5,2,1;K2$,R5,E
		IF E ! none to get 
			ReturnStatus=0
			Message$="COPY FROM FILTER "+J1$+" NOT FOUND"
			Goto OutDone
		Endif
		Try ! as sled has problems with BE 52
		Mat Read #5,r5;SC$;
		Mat Read #5,R5,224;SC1;
		Mat Read #5,R5,244;SC2; ! read existing
		Else
			ReturnStatus=0
			Message$="COPY FROM FILTER "+J1$+" NOT FOUND"
			Goto OutDone
		End try
		Call DXGet("ID",tmp$) ! now read & check to
		tmp$=UCase$(Trim$(tmp$)) ! UC & trim
		J$=tmp$+Blank$
		J$[7]="" ! cut at limit
		LET K2$=PORTNUM USING "####" \ LET K2$[5]=J$
		SEARCH #5,2,1;K2$,FR,E
		If E
			If E=1
				Let E=2;FR=0
				Search #5,1,0;k2$,FR,E
				If E
					returnstatus=0
					message$="ERROR "+STR$(E)+" ADDING RECORD"
					Goto OutDone
				Endif
				LET SC1[0]=PORTNUM \ LET SC$[1,6]=J$ ! new port/name
				Mat Write #5,FR;SC$;
				Mat write #5,FR,224;SC1;
				Mat write #5,FR,244;SC2;
				R5=FR
				SEARCH #5,4,1;K2$,R5,E
				IF E !!GOSUB Err_Search:
					returnstatus=0
					message$="ERROR "+STR$(E)+" ADDING KEY1"
					Goto OutDone
				Endif
				LET J4$=K2$[5,10],K2$[1,4]
				r5=FR
				SEARCH #5,4,2;J4$,R5,E
				IF E !!GOSUB Err_Search:
					returnstatus=0
					message$="ERROR "+STR$(E)+" ADDING KEY2"
					Goto OutDone
				Endif
			Else ! bad news
				returnstatus=0
				message$="ERROR "+STR$(E)+" CHECKING FILE"
				Goto OutDone
			Endif ! not found
		! if exists - write new to old
		Endif
		LET SC1[0]=PORTNUM \ LET SC$[1,6]=J$
		Mat Write #5,FR;SC$;
		Mat write #5,FR,224;SC1;
		Mat write #5,FR,244;SC2;
		!end of filter copy
	Case "CUSTCLLIST" ! Cust list w/callback			doc=SL-CUSTCLLIST.doc
		ReturnStatus=1
		Message$="OK"
		Clear List$[]
		tmpcnt=maxcnt
		Gosub GETFILTER ! current filter
		Call DXGet("STRTID",tmp$)
		J4$=tmp$
		List$[0]=bsdel$,"CUSTCALLLIST",fdel$
		List$[1]="CUSTID",fdel$,"NAME",fdel$,"CALLBACK",fdel$,"DAY",fdel$,"TIME",fdel$
		Row=2
		Gosub L_2800 ! should filter(it says)
		List$[row]=esdel$
		call AddToStr(e$,rstr$,List$[]) ! add droplist to string
		!end of get call list
	Case "CALLLIST" ! list customer's calls				doc=SL-CALLLIST.doc
		ReturnStatus=1
		Message$="OK"
		Call DXGet("CUSTID",tmp$)
		If tmp$="" goto OutDone
		J$=UCase$(tmp$)
		K2$ = J$+Blank$
		K2$[9]=""
		Search #2,2,1;K2$,K1,E
		If E 
			ReturnStatus=0
			Message$="ID WAS NOT FOUND!"
			goto OutDone
		Endif
		Clear List$[]
		SLM1$=K2$
		K3$ = SLM1$[1,8] \ K3$[9] = "~" 
		Gosub L_4400 ! CALL NOTES
		call AddToStr(e$,rstr$,List$[]) ! add droplist to string
		!end of customer call list
	Case "GETCALL" ! get call data						doc=SL-GETCALL.doc
		ReturnStatus=1
		Message$="OK"
		Call DXGet("CUSTID",tmp$)
		If tmp$="" goto OutDone
		J$=UCase$(tmp$)
		K2$ = J$+Blank$
		K2$[9]=""
		Search #2,2,1;K2$,K1,E
		If E 
			ReturnStatus=0
			Message$="ID WAS NOT FOUND!"
			goto OutDone
		Endif
		Call DXGet("CALLID",tmp$)
		If tmp$="" goto OutDone
		J$=UCase$(tmp$)
		K3$ = J$
		Search #3,2,1;K3$,R3,E
		If E 
			ReturnStatus=0
			Message$="CALL ID WAS NOT FOUND!"
			goto OutDone
		Endif
		Gosub READDETAIL
		KD3$ = K3$ \ KD3H$ = KD3$
		Clear List$[]
		List$[0]=bsdel$,"CALLDETAIL",fdel$
		List$[1]="CALLID",fdel$,"CALLDATE",fdel$,"CDAY",fdel$,"CTIME",fdel$,"FOLLOWUP",fdel$,"FDAY",fdel$,"FTIME",fdel$,"REMARK",fdel$,"STATUS",fdel$
		Row=2
		Gosub CALLSCREEN
		Row=row+1 \ if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
		List$[row]=esdel$
		call AddToStr(e$,rstr$,List$[]) ! add droplist to string
		Clear List$[]
		KD3$ = K3$ \ KD3H$ = KD3$
		List$[0]=bsdel$,"CALLNOTES",fdel$
		List$[1]="TEXT",fdel$
		Row=2
		Gosub L_4300 ! notes (free text)
		List$[row]=esdel$
		call AddToStr(e$,rstr$,List$[]) ! add droplist to string
		!end of get a call
	Case "SVCALL" ! change call							doc=SL-SaveCall.doc
		ReturnStatus=1
		Message$="OK"
		Call DXGet("CUSTID",tmp$)
		If tmp$="" goto OutDone
		J$=UCase$(tmp$)
		K2$ = J$+Blank$
		K2$[9]=""
		Search #2,2,1;K2$,R[2],E
		If E 
			ReturnStatus=0
			Message$="ID WAS NOT FOUND!"
			goto OutDone
		Endif
		K1=R[2] \ Gosub ReadMain
		Call DXGet("CALLID",tmp$)
		Nwcall=0
		If Len(tmp$)=0  ! means new call 
			! use L_4000 for setup
			NwCall=1
			Gosub L_7900 ! today date/time
			SLD[0] = CDATE \ SLD[1] = 0 \ SLD[2] = CTIME
			SLD[3] = CDATE + 7 \ SLD[4] = CTIME \ SLD[5] = 1
			SLD$ = " ",SLD$ \ SLD$[1,8] = SLM1$[1,8]
			K3$ = " ",K3$ \ K3$ = SLD$[1,8]
			L4060: K3$[9,13] = SLD[0] Using "#####" \ K3$[14,16] = SLD[1] Using "#00"
			Search #3,2,1;K3$,X3,E
			If E > 1 ! Gosub ERR_SEARCH
				ReturnStatus=0
				Message$="SEARCH ERROR "+Str$(E)+" CHECKING KEY1"
				Goto OutDone
			Endif
			If Not(E)
				SLD[1] = SLD[1] + 1
				If SLD[1] > 9
					Message$ = "EXCEEDED MAXIMUM 9 CALL ENTIRES / DAY" \ ReturnStatus=0
					Goto OUTDone ! 
				End If 
				Goto L4060
			End If 
			E = 2 \ Search #3,1,0;K3$,R3,E 
			If E ! Gosub ERR_SEARCH
				ReturnStatus=0
				Message$="S ERROR "+Str$(E)+" GETTING CALL RECORD"
				Goto OutDone
			Endif
			Gosub WRITEDETAIL
			Search #3,4,1;K3$,R3,E 
			If E ! Gosub ERR_SEARCH
				ReturnStatus=0
				Message$="S ERROR "+Str$(E)+" ADDING CALL KEY1"
				Goto OutDone
			Endif
			!Gosub CALLWIN \ Gosub CALLSCREEN \ Gosub FLD_REMARK \ Gosub FLD_FUDATE
			!SLM2[4] = CDATE;SLM2[5] = CTIME ! update cust
			!come back with tmp$
			tmp$=K3$
		Endif
		J$=UCase$(tmp$)
		K3$ = J$
		Search #3,2,1;K3$,R3,E
		If E ! not found 
			ReturnStatus=0
			Message$="CALL ID WAS NOT FOUND!"
			goto OutDone
		Endif
		! L_4000 or L_4200
		Gosub ReadDetail
		Call DXGet("FUDATE",tmp$)
		tmp$=RTrim$(tmp$)
		tmp$=ChkDateFrmt$(tmp$)
		tmp1$=formatdate2$(tmp$) ! mm/dd/yyyy or mm/dd/yy to yyyymmdd
		X2=tmp1$[3,8] ! drop century
		J1$=X2 Using "&&&&&&"
		if x2 Call DateToJulian(1,J1$,J$) \ SLD[3] = J$
		if x2=0 let SLD[3]=0
		Call DXGet("FUTIME",tmp$) ! what format?? looking for HHMM
		If len(tmp$)>2 ! it could also be HH:MM or H:MM?
			for x=1 to len(tmp$)
				if tmp$[x,x]=":" let tmp$[x]=tmp$[x+1]
			Next X
		Endif
		J1=tmp$
		If FNH(J1) < 24 If FNM(J1) < 60
			SLD[4] = J1
		Else 
			Message$ = "INVALID TIME" \ ReturnStatus=0
			SLD[4]=0
		End If 
		Call DXGet("REMARKS",tmp$)
		tmp$=RTrim$(tmp$)
		sld$[9,67]=tmp$+Blank$
		Call DXGet("STATUS",tmp$)
		If tmp$[1,1]="A" let SLD[5]=1
		if tmp$[1,1]="C" let SLD[5]=2
		if tmp$[1,1]="X" let SLD[5]=0
		Gosub WRITEDETAIL ! save main call
		Call DXGet("TTLNTE",tmp$) ! number note lines
		Let ntttl=tmp$
		KD3$ = K3$ \ KD3$[15] = "00"
		k3h$=KD3$ ! WE MUST DELETE PREVIOUS NOTES FIRST
		L4860: Search #3,3,1;KD3$,RD3,E
		If E > 2 ! Gosub ERR_SEARCH
			ReturnStatus=0
			Message$="S ERROR "+Str$(E)+" GETTING NOTES KEY1"
			goto OutDone
		Endif
		If KD3$[1,14] <> K3H$[1,14] Let E = 2
		If Not(E)
			Search #3,5,1;KD3$,RD3,E
			If E ! Gosub ERR_SEARCH
				ReturnStatus=0
				Message$="S ERROR "+Str$(E)+" DELETING NOTES KEY1"
				!goto OutDone
			Endif
			E = 3 \ Search #3,1,0;KD3$,RD3,E 
			If E ! Gosub ERR_SEARCH
				ReturnStatus=0
				Message$="S ERROR "+Str$(E)+" RETURNING NOTES RECORD"
				goto OutDone
			Endif
			Goto L4860
		End If 
		If ntttl>0 ! sent one +
			SLDD[0] = SLD[0] \ LD1 = 1 \ KD3$ = KD3H$
			For X1=1 to ntttl
				Call DXGET("NOTE"+Str$(X1),tmp$)
				tmp$=RTRIM$(tmp$)
				If tmp$<>""
					SLDD$=tmp$+Blank$
					SLDD[1] = SLD[1] + LD1 / 100
					KD3$=K3$
					KD3$[15,16] = LD1 Using "&&"
					E = 2 \ Search #3,1,0;KD3$,RD3,E
					If E ! Gosub ERR_SEARCH
						ReturnStatus=0
						Message$="S ERROR "+Str$(E)+" GETTING NEW NOTES RECORD"
						goto OutDone
					Endif
					Mat Write #3,RD3;SLDD
					Mat Write #3,RD3,8;SLDD$;
					Search #3,4,1;KD3$,RD3,E
					If E ! Gosub ERR_SEARCH
						ReturnStatus=0
						Message$="S ERROR "+Str$(E)+" INSERTING NEW NOTES KEY1"
						goto OutDone
					Endif
					LD1 = LD1 + 1 \ If LD1 < 100 Goto L4900
					Message$ = "TOO MANY LINES.(>99)  FILE TRUNCATED" \ ReturnStatus=0
					GOTO L4920
				End If ! of notes not null
			L4900: ! notes done	
			NEXT X1	
		L4920: ! end of notes
		Endif
		! needs a status check? (sld[5])
		If SLD[5]=1 let SLM2[4] = CDATE;SLM2[5] = CTIME ! update cust last call date/time
		gosub NextCall ! update next call on prospect also?
		K1=R[2] \ gosub writemain
		Clear List$[]
		List$[0]=bsdel$,"SAVECALL",fdel$
		List$[1]="CUSTID",fdel$,"CALLID",fdel$,"NEW",fdel$
		tmp$="N" \ if NwCall let tmp$="Y"
		List$[2]=K2$,fdel$,k3$,fdel$,tmp$,fdel$
		List$[3]=esdel$
		call AddToStr(e$,rstr$,List$[]) ! add droplist to string
		!end of save call
	Case "SVAPPT" ! add appt Info
		! need to save appt info
		ReturnStatus=1
		Message$="OK"
		Call DXGet("CUSTID",tmp$)
		If tmp$="" goto OutDone
		J$=UCase$(tmp$)
		K2$ = J$+Blank$
		K2$[9]=""
		Search #2,2,1;K2$,R[2],E
		If E 
			ReturnStatus=0
			Message$="ID WAS NOT FOUND!"
			goto OutDone
		Endif
		K1=R[2] \ Gosub ReadMain
		Call DXGet("CALLID",tmp$)
		Nwcall=0
		If Len(tmp$)=0  ! means new call 
			! use L_4000 for setup
			NwCall=1
			Gosub L_7900 ! today date/time
			SLD[0] = CDATE \ SLD[1] = 0 \ SLD[2] = CTIME
			SLD[3] = CDATE + 7 \ SLD[4] = CTIME \ SLD[5] = 1
			SLD$ = " ",SLD$ \ SLD$[1,8] = SLM1$[1,8]
			K3$ = " ",K3$ \ K3$ = SLD$[1,8]
			S4060: K3$[9,13] = SLD[0] Using "#####" \ K3$[14,16] = SLD[1] Using "#00"
			Search #3,2,1;K3$,X3,E
			If E > 1 ! Gosub ERR_SEARCH
				ReturnStatus=0
				Message$="SEARCH ERROR "+Str$(E)+" CHECKING KEY1"
				Goto OutDone
			Endif
			If Not(E)
				SLD[1] = SLD[1] + 1
				If SLD[1] > 9
					Message$ = "EXCEEDED MAXIMUM 9 CALL ENTIRES / DAY" \ ReturnStatus=0
					Goto OUTDone ! 
				End If 
				Goto S4060
			End If 
			E = 2 \ Search #3,1,0;K3$,R3,E 
			If E ! Gosub ERR_SEARCH
				ReturnStatus=0
				Message$="S ERROR "+Str$(E)+" GETTING CALL RECORD"
				Goto OutDone
			Endif
			Gosub WRITEDETAIL
			Search #3,4,1;K3$,R3,E 
			If E ! Gosub ERR_SEARCH
				ReturnStatus=0
				Message$="S ERROR "+Str$(E)+" ADDING CALL KEY1"
				Goto OutDone
			Endif
			!Gosub CALLWIN \ Gosub CALLSCREEN \ Gosub FLD_REMARK \ Gosub FLD_FUDATE
			!SLM2[4] = CDATE;SLM2[5] = CTIME ! update cust
			!come back with tmp$
			tmp$=K3$
		Endif
		J$=UCase$(tmp$)
		K3$ = J$
		Search #3,2,1;K3$,R3,E
		If E ! not found 
			ReturnStatus=0
			Message$="CALL ID WAS NOT FOUND!"
			goto OutDone
		Endif
		! L_4000 or L_4200
		Gosub ReadDetail
		Call DXGet("FUDATE",tmp$)
		tmp$=RTrim$(tmp$)
		tmp$=ChkDateFrmt$(tmp$)
		tmp1$=formatdate2$(tmp$) ! mm/dd/yyyy or mm/dd/yy to yyyymmdd
		X2=tmp1$[3,8] ! drop century
		J1$=X2 Using "&&&&&&"
		if x2 Call DateToJulian(1,J1$,J$) \ SLD[3] = J$
		if x2=0 let SLD[3]=0
		Call DXGet("FUTIME",tmp$) ! what format?? looking for HHMM
		If len(tmp$)>2 ! it could also be HH:MM or H:MM?
			for x=1 to len(tmp$)
				if tmp$[x,x]=":" let tmp$[x]=tmp$[x+1]
			Next X
		Endif
		J1=tmp$
		If FNH(J1) < 24 If FNM(J1) < 60
			SLD[4] = J1
		Else 
			Message$ = "INVALID TIME" \ ReturnStatus=0
			SLD[4]=0
		End If 
		Call DXGet("REMARKS",tmp$)
		tmp$=RTrim$(tmp$)
		sld$[9,67]=tmp$+Blank$
		!Call DXGet("STATUS",tmp$)
		if sld[5]<=1 let tmp$="A"
		if sld[5]=2 let tmp$="C"
		If tmp$[1,1]="A" let SLD[5]=1
		if tmp$[1,1]="C" let SLD[5]=2
		if tmp$[1,1]="X" let SLD[5]=0
		Gosub WRITEDETAIL ! save main detail
		If SLD[5]=1 let SLM2[4] = CDATE;SLM2[5] = CTIME ! update cust last call date/time
		gosub NextCall ! update next call on prospect also?
		K1=R[2] \ gosub writemain
		Clear List$[]
		List$[0]=bsdel$,"SAVECALL",fdel$
		List$[1]="CUSTID",fdel$,"CALLID",fdel$,"NEW",fdel$
		tmp$="N" \ if NwCall let tmp$="Y"
		List$[2]=K2$,fdel$,k3$,fdel$,tmp$,fdel$
		List$[3]=esdel$
		call AddToStr(e$,rstr$,List$[]) ! add droplist to string
		
		!end of save appt
	Case "DELCALL" ! delete call						doc=SL-DELCALL.doc
		ReturnStatus=1
		Message$="OK"
		Call DXGet("CALLID",tmp$)
		If tmp$="" goto OutDone
		J$=UCase$(tmp$)
		K3$ = J$
		Search #3,2,1;K3$,R3,E
		If E 
			ReturnStatus=0
			Message$="CALL ID WAS NOT FOUND!"
			goto OutDone
		Endif
		Gosub READDETAIL
		! zoomcall / CALLDELETE
		Gosub CALLDELETE ! detail & text Notes
		! end of delete call
	Case "CUSTLIST" ! customer list						doc=SL-CUSTLIST.doc
		! taken from sledmastlu
		ReturnStatus=1
		Message$="OK"
		Call DXGet("STRTNAME",tmp$)
		tmp$=RTrim$(tmp$) ! NO UPPERCASE?
		K2$=tmp$
		Clear List$[]
		tmpcnt=maxcnt
		List$[0]=bsdel$,"CUSTLIST",fdel$
		List$[1]="CUSTID",fdel$,"NAME",fdel$
		Row=2
		Do
			Search #2,3,2;k2$,R2,e \ if e exit do
			Try
			Mat read #2,R2,0;SLM$;
			Mat Read #2,R2,360;SLM1$
			List$[row]=SLM1$,fdel$,RTrim$(SLM$[1,30]),fdel$
			row=row+1
			if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
			Else
				REM
			End try
		loop
		List$[row]=esdel$
		call AddToStr(e$,rstr$,List$[]) ! add droplist to string
		!end of customer list
	Case "GETCUST" ! selected Cust						doc=SL-GETCUST.doc
		! also calls for cust (4400)
		ReturnStatus=1
		Message$="OK"
		Clear List$[]
		Gosub GETFILTER ! current filter
		Call DXGet("CUSTID",tmp$)
		If tmp$="" goto OutDone
		J$=UCase$(tmp$)
		K2$ = J$+Blank$
		K2$[9]=""
		Search #2,2,1;K2$,K1,E
		If E 
			! ReturnStatus=0
			!Message$="ID WAS NOT FOUND!"
			! goto OutDone
			Gosub L_1180 ! do a next
		Else
			Gosub L_1600 ! get/read (may not return above Customer- uses filter?)
		Endif
		! Gosub L_1600 ! get/read (may not return above Customer- uses filter?)
		call AddToStr(e$,rstr$,List$[]) ! add droplist to string
		!end of get cust
	Case "GETNXTCUST" ! selected next Cust				doc=SL-GETNextCUST.doc
		! also calls for cust (4400)
		ReturnStatus=1
		Message$="OK"
		Clear List$[]
		Gosub GETFILTER ! current filter
		Call DXGet("CUSTID",tmp$)
		! If tmp$="" goto OutDone ! can start at none
		J$=UCase$(tmp$)
		K2$ = J$+Blank$
		K2$[9]=""
		U5$="N"
		Gosub L_2605 ! gets n/p and then L_1615
		call AddToStr(e$,rstr$,List$[]) ! add droplist to string
		!end of get next cust
	Case "GETPRVCUST" ! selected previous Cust			doc=SL-GETPrevCUST.doc
		! also calls for cust (4400)
		ReturnStatus=1
		Message$="OK"
		Clear List$[]
		Gosub GETFILTER ! current filter
		Call DXGet("CUSTID",tmp$)
		If tmp$="" let tmp$="ZZZ" ! goto OutDone
		J$=UCase$(tmp$)
		K2$ = J$+Blank$
		K2$[9]=""
		U5$="P"
		Gosub L_2605 ! gets n/p and then L_1615
		call AddToStr(e$,rstr$,List$[]) ! add droplist to string
		!end of get previous cust
	Case "SVCUST" ! changed customer					doc=SL-SaveCust.doc
		ReturnStatus=1
		Message$="OK"
		Call DXGET("NAME",tmp$)
		SLM$[1,30]=tmp$+Blank$
		HldNm$=SLM$[1,30]
		Call DXGet("CUSTID",tmp$)
		tmp$=RTrim$(tmp$) ! clear spaces
		If tmp$<>"" ! goto OutDone
			J$=UCase$(tmp$)
			K2$[1,8] = J$+Blank$
			Search #2,2,1;K2$,R[2],E
		Else ! not sent
			E=1
		Endif
		If E ! new Customer?
			Let X1[9]=9;j$=hLDNM$ ! (USES J$ INSTEAD OF SLM$)
			if tmp$=""	Gosub L_1400 ! generate key as not sent
			E = 2;R[2]=0
			Search #2,1,0;K2$,R[2],E
			If E or R[2]<=0 !Gosub ERR_SEARCH
				ReturnStatus=0
				Message$="S ERROR "+Str$(E)+" GETTING NEW RECORD"
				Goto OutDone
			Endif
			J$ = SLM$[1,30] ! set so insert know new name
			Gosub L_8000 \ SLM1$ = K2$ \ SLM2[1] = CDATE ! clr vars - setup id/date
			Let SLM$[1,30]=HldNm$ ! reset to entered name
			K1=R[2] \ Gosub WRITEMAIN  ! ALWAYS WRITE BEFORE KEY ADD!!!!
			If ReturnStatus=0 goto outdone
			HldNm$=SLM$[1,30] ! for check below
			Search #2,4,1;K2$,K1,E
			If E !Gosub ERR_SEARCH
				ReturnStatus=0
				Message$="S ERROR "+Str$(E)+" INSERTING NEW KEY1"
				Goto OutDone
			Endif
			! J$ = SLM$[1,30] ! set so insert know new name
			! Gosub L_8000 \ SLM1$ = K2$ \ SLM2[1] = CDATE ! clr vars - setup id/date
			Gosub L_8100 ! insert Dir 2 (with name cleared)
			! Let SLM$[1,30]=HldNm$ ! reset to entered name
			! Gosub WRITEMAIN ! ALWAYS WRITE BEFORE KEY ADD!!!!
			! HldNm$=SLM$[1,30] ! for check below
		Else
			K1=R[2] \ Gosub ReadMain
		Endif ! end of get new cust record
		If SLM$[1,16] <> HldNm$[1,16] ! name different
			J$=HLdNm$ ! this is new name
			Gosub L_8100 ! del/add dir 2
			SLM$[1,30]=HldNm$ ! reset to entry
		Endif ! on name changed
		Call DXGet("ADDR1",tmp$)
		SLM$[31,60]=tmp$+Blank$
		Call DXGET("ADDR2",tmp$)
		SLM$[61,90]=tmp$+Blank$
		Call DXGet("CITY",tmp$)
		SLM$[91,105]=tmp$+Blank$
		Call DXGet("ST",tmp$)
		SLM$[106,107]=tmp$+Blank$
		Call DXGet("ZIPCODE",tmp$)
		SLM$[108,117]=tmp$+Blank$
		Call DXGet("PHONE",tmp$)
		SLM1[0]=tmp$
		Call DXGet("CONTACT",tmp$)
		SLM$[128,147]=tmp$+Blank$
		Call DXGet("TITLE",tmp$)
		SLM$[148,163]=tmp$+Blank$
		Call DXGet("REMARK1",tmp$)
		SLM$[164,203]=tmp$+Blank$
		Call DXGet("REMARK2",tmp$)
		SLM$[204,243]=tmp$+Blank$
		Call DXGet("REMARK3",tmp$)
		SLM$[244,283]=tmp$+Blank$
		Call DXGet("SLSM",tmp$)
		SLM2[9]=tmp$ \ gosub getslsm
		If E let SLM2[9]=0
		Call DXGet("CTGY",tmp$)
		U5$=tmp$+Blank$
		J$=U5$[1,5];Z9=1;X1[1]=1
		gosub GetCode \ NCode=0
		SLM3[0]=NCODE
		Call DXGet("PHONE2",tmp$)
		SLM1[1]=tmp$
		Call DXGet("FAXNO",tmp$)
		SLM1[2]=tmp$
		Call DXGet("SALUTE",tmp$)
		SLM$[284,299]=tmp$+Blank$
		Call DXGet("ALTCONT",tmp$)
		SLM$[320,339]=tmp$+Blank$
		Call DXGet("ALTTITLE",tmp$)
		SLM$[340,355]=tmp$+Blank$
		Call DXGet("ALTPHONE",tmp$)
		SLM1[3]=tmp$
		Call DXGet("REFBY1",tmp$)
		U5$=tmp$+Blank$
		J$=U5$[1,5];Z9=2;X1[1]=1
		gosub GetCode \ NCode=0
		SLM3[1]=NCODE
		Call DXGet("REFBY2",tmp$)
		U5$=tmp$+Blank$
		J$=U5$[1,5];Z9=2;X1[1]=1
		gosub GetCode \ NCode=0
		SLM3[2]=NCODE
		Call DXGet("REFBY3",tmp$)
		U5$=tmp$+Blank$
		J$=U5$[1,5];Z9=2;X1[1]=1
		gosub GetCode \ NCode=0
		SLM3[3]=NCODE
		Call DXGet("QUALITY",tmp$)
		U5$=tmp$+Blank$
		J$=U5$[1,5];Z9=3;X1[1]=1
		gosub GetCode \ NCode=0
		SLM3[4]=NCODE
		Call DXGet("COMPET",tmp$)
		U5$=tmp$+Blank$
		J$=U5$[1,5];Z9=4;X1[1]=1
		gosub GetCode \ NCode=0
		SLM3[5]=NCODE
		Call DXGet("PARCOMP",tmp$)
		SLM$[300,319]=tmp$+Blank$
		Call DXGet("SIC1",tmp$)
		SLM2[6]=tmp$
		Call DXGet("SIC2",tmp$)
		SLM2[7]=tmp$
		Call DXGet("SLSVOL",tmp$)
		SLM2[8]=tmp$
		Call DXGet("PROJSLS",tmp$)
		SLM2[10]=tmp$
		Call DXGet("NUMLOC",tmp$)
		SLM3[6]=tmp$
		K1=R[2] \ Gosub WriteMain
		If ReturnStatus=1 ! ok-get next or prev?
			Let X1=0
			If Action2$="NEXT" let X1=3;U5$="N"	!		doc=SL-SaveCustgetnext.doc
			If action2$="PREV" let X1=6;U5$="P" !		doc=SL-SaveCustgetprev.doc
			If X1 ! want n/p
				! status section of submit
				call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
				call AddToStr(e$,rstr$,WebStr$)
				Clear List$[]
				Gosub GETFILTER ! current filter
				Gosub L_2600 ! gets n/p and then L_1615
				call AddToStr(e$,rstr$,List$[]) ! add droplist to string
			Endif
		Endif
		!end of save cust
	Case "DELCUST" ! delete customer					doc=SL-DELCUST.doc
		ReturnStatus=1
		Message$="OK"
		Call DXGet("CUSTID",tmp$)
		If tmp$="" goto OutDone
		J$=UCase$(tmp$)
		K2$ = J$+Blank$
		K2$[9]=""
		Search #2,2,1;K2$,K1,E
		If E 
			ReturnStatus=0
			Message$="ID WAS NOT FOUND!"
			goto OutDone
		Endif
		Gosub readmain ! need to read it!
		SLM1$=k2$
		Gosub L_8900
		!end of delete cust
	Case "EDTREFER" ! add/chng referred					doc=SL-EDTREFER.doc
		ReturnStatus=1
		Message$="OK"
		Call DXGet("ID",tmp$)
		tmp$=UCASE$(RTRIM$(tmp$))
		If tmp$="" goto OutDone
		K2$=tmp$+Blank$
		Call DXGet("DESC",tmp$)
		J1$=tmp$+Blank$
		J1$[16]=""
		K2$[5]="" ! limit 4
		Search #4,2,2;K2$,R4,E
		If E=0
			Write #4,r4,0;J1$[1,15];
		Else
			If E=1
				Let E=2;r4=0
				Search #4,1,0;k2$,R4,E
				If E
					returnstatus=0
					message$="ERROR "+STR$(E)+" ADDING RECORD"
				Else
					SCODE$=" ",SCODE$
					SCODE$[1,15]=J1$
					SCODE$[17,20]=k2$
					Mat write #4,r4,0;SCode$;
					Search #4,4,2;k2$,r4,E
					If E
						returnstatus=0
						message$="ERROR "+STR$(E)+" INSERTING KEY"
					Endif
				Endif
			Else
				returnstatus=0
				message$="ERROR "+STR$(E)+" CHECKING KEY"
			Endif
		Endif
		!end EDTREFER
	Case "EDTCTGY" ! add/chg category					doc=SL-EDTCTGY.doc
		ReturnStatus=1
		Message$="OK"
		Call DXGet("ID",tmp$)
		tmp$=UCASE$(RTRIM$(tmp$))
		If tmp$="" goto OutDone
		K2$=tmp$+Blank$
		Call DXGet("DESC",tmp$)
		J1$=tmp$+Blank$
		J1$[16]=""
		K2$[5]="" ! limit 4
		Search #4,2,1;K2$,R4,E
		If E=0
			Write #4,r4,0;J1$[1,15];
		Else
			If E=1
				Let E=2;r4=0
				Search #4,1,0;k2$,R4,E
				If E
					returnstatus=0
					message$="ERROR "+STR$(E)+" ADDING RECORD"
				Else
					SCODE$=" ",SCODE$
					SCODE$[1,15]=J1$
					SCODE$[17,20]=k2$
					Mat write #4,r4,0;SCode$;
					Search #4,4,1;k2$,r4,E
					If E
						returnstatus=0
						message$="ERROR "+STR$(E)+" INSERTING KEY"
					Endif
				Endif
			Else
				returnstatus=0
				message$="ERROR "+STR$(E)+" CHECKING KEY"
			Endif
		Endif
		!end EDTCTGY
	Case "EDTQLTY" ! add/chg Quality					doc=SL-EDTQLTY.doc
		ReturnStatus=1
		Message$="OK"
		Call DXGet("ID",tmp$)
		tmp$=UCASE$(RTRIM$(tmp$))
		If tmp$="" goto OutDone
		K2$=tmp$+Blank$
		Call DXGet("DESC",tmp$)
		J1$=tmp$+Blank$
		J1$[16]=""
		K2$[5]="" ! limit 4
		Search #4,2,3;K2$,R4,E
		If E=0
			Write #4,r4,0;J1$[1,15];
		Else
			If E=1
				Let E=2;r4=0
				Search #4,1,0;k2$,R4,E
				If E
					returnstatus=0
					message$="ERROR "+STR$(E)+" ADDING RECORD"
				Else
					SCODE$=" ",SCODE$
					SCODE$[1,15]=J1$
					SCODE$[17,20]=k2$
					Mat write #4,r4,0;SCode$;
					Search #4,4,3;k2$,r4,E
					If E
						returnstatus=0
						message$="ERROR "+STR$(E)+" INSERTING KEY"
					Endif
				Endif
			Else
				returnstatus=0
				message$="ERROR "+STR$(E)+" CHECKING KEY"
			Endif
		Endif
		!end EDTQLTY
	Case "EDTCOMPT" ! add/chg competition				doc=SL-EDTCOMPT.doc
		ReturnStatus=1
		Message$="OK"
		Call DXGet("ID",tmp$)
		tmp$=UCASE$(RTRIM$(tmp$))
		If tmp$="" goto OutDone
		K2$=tmp$+Blank$
		Call DXGet("DESC",tmp$)
		J1$=tmp$+Blank$
		J1$[16]=""
		K2$[5]="" ! limit 4
		Search #4,2,4;K2$,R4,E
		If E=0
			Write #4,r4,0;J1$[1,15];
		Else
			If E=1
				Let E=2;r4=0
				Search #4,1,0;k2$,R4,E
				If E
					returnstatus=0
					message$="ERROR "+STR$(E)+" ADDING RECORD"
				Else
					SCODE$=" ",SCODE$
					SCODE$[1,15]=J1$
					SCODE$[17,20]=k2$
					Mat write #4,r4,0;SCode$;
					Search #4,4,4;k2$,r4,E
					If E
						returnstatus=0
						message$="ERROR "+STR$(E)+" INSERTING KEY"
					Endif
				Endif
			Else
				returnstatus=0
				message$="ERROR "+STR$(E)+" CHECKING KEY"
			Endif
		Endif
		!end EDTCOMPT
	Case "DELREFER" !									doc=SL-DELREFER.doc
		ReturnStatus=1
		Message$="OK"
		Call DXGet("ID",tmp$)
		tmp$=UCASE$(RTRIM$(tmp$))
		If tmp$="" goto OutDone
		K2$=tmp$+Blank$
		K2$[5]="" ! limit 4
		Z9=2 ! directory
		Search #4,2,Z9;K2$,R4,E
		If E=0
			! see if any Custs yet
			LET K3$=" ",K3$ \ LET F9[4]=0
			SEARCH #3,3,1;K3$,R3,E \ IF E GOTO DELCODE2
			! SCAN FILE FOR CODE ! READ #3,R3,???;D2; \  IF D2<>R2 GOTO L_8430:
			LET F9[4]=9 ! at least one - so just remove key
			DELCODE2: !delete 
			SEARCH #4,5,Z9;K2$,R9,E
			IF E ! GOSUB Err_Search:
				returnstatus=0
				message$="ERROR "+STR$(E)+" DELETING KEY"
			Endif
			IF R9<>R4 ! GOSUB Err_Search:
				returnstatus=0;E=1 ! CALL IT NOT FOUND
				message$="ERROR "+STR$(E)+" DELETING KEY"
			Endif
			IF Not(F9[4]) !   NOT IN USE - CAN FREE RECORD
				LET E=3 \ SEARCH #4,1,0;K2$,R4,E
				IF E ! GOSUB Err_Search:
					returnstatus=0
					message$="ERROR "+STR$(E)+" RETURNING RECORD"
				Endif
			Endif
		Endif
		! end of delete DELREFER
	Case "DELCTGY" !									doc=SL-DELCTGY.doc
		ReturnStatus=1
		Message$="OK"
		Call DXGet("ID",tmp$)
		tmp$=UCASE$(RTRIM$(tmp$))
		If tmp$="" goto OutDone
		K2$=tmp$+Blank$
		K2$[5]="" ! limit 4
		Z9=1 ! directory
		Search #4,2,Z9;K2$,R4,E
		If E=0
			! see if any Custs yet
			LET K3$=" ",K3$ \ LET F9[4]=0
			SEARCH #3,3,1;K3$,R3,E \ IF E GOTO DELCODE1
			! SCAN FILE FOR CODE ! READ #3,R3,???;D2; \  IF D2<>R2 GOTO L_8430:
			LET F9[4]=9 ! at least one - so just remove key
			DELCODE1: !delete 
			SEARCH #4,5,Z9;K2$,R9,E
			IF E ! GOSUB Err_Search:
				returnstatus=0
				message$="ERROR "+STR$(E)+" DELETING KEY"
			Endif
			IF R9<>R4 ! GOSUB Err_Search:
				returnstatus=0;E=1 ! CALL IT NOT FOUND
				message$="ERROR "+STR$(E)+" DELETING KEY"
			Endif
			IF Not(F9[4]) !   NOT IN USE - CAN FREE RECORD
				LET E=3 \ SEARCH #4,1,0;K2$,R4,E
				IF E ! GOSUB Err_Search:
					returnstatus=0
					message$="ERROR "+STR$(E)+" RETURNING RECORD"
				Endif
			Endif
		Endif
		! end of delete DELCTGY
	Case "DELQLTY" !									doc=SL-DELQLTY.doc
		ReturnStatus=1
		Message$="OK"
		Call DXGet("ID",tmp$)
		tmp$=UCASE$(RTRIM$(tmp$))
		If tmp$="" goto OutDone
		K2$=tmp$+Blank$
		K2$[5]="" ! limit 4
		Z9=3 ! directory
		Search #4,2,Z9;K2$,R4,E
		If E=0
			! see if any Custs yet
			LET K3$=" ",K3$ \ LET F9[4]=0
			SEARCH #3,3,1;K3$,R3,E \ IF E GOTO DELCODE3
			! SCAN FILE FOR CODE ! READ #3,R3,???;D2; \  IF D2<>R2 GOTO L_8430:
			LET F9[4]=9 ! at least one - so just remove key
			DELCODE3: !delete 
			SEARCH #4,5,Z9;K2$,R9,E
			IF E ! GOSUB Err_Search:
				returnstatus=0
				message$="ERROR "+STR$(E)+" DELETING KEY"
			Endif
			IF R9<>R4 ! GOSUB Err_Search:
				returnstatus=0;E=1 ! CALL IT NOT FOUND
				message$="ERROR "+STR$(E)+" DELETING KEY"
			Endif
			IF Not(F9[4]) !   NOT IN USE - CAN FREE RECORD
				LET E=3 \ SEARCH #4,1,0;K2$,R4,E
				IF E ! GOSUB Err_Search:
					returnstatus=0
					message$="ERROR "+STR$(E)+" RETURNING RECORD"
				Endif
			Endif
		Endif
		! end of delete DELQLTY
	Case "DELCOMPT" !									doc=SL-DELCOMPT.doc
		ReturnStatus=1
		Message$="OK"
		Call DXGet("ID",tmp$)
		tmp$=UCASE$(RTRIM$(tmp$))
		If tmp$="" goto OutDone
		K2$=tmp$+Blank$
		K2$[5]="" ! limit 4
		Z9=4 ! directory
		Search #4,2,Z9;K2$,R4,E
		If E=0
			! see if any Custs yet
			LET K3$=" ",K3$ \ LET F9[4]=0
			SEARCH #3,3,1;K3$,R3,E \ IF E GOTO DELCODE4
			! SCAN FILE FOR CODE ! READ #3,R3,???;D2; \  IF D2<>R2 GOTO L_8430:
			LET F9[4]=9 ! at least one - so just remove key
			DELCODE4: !delete 
			SEARCH #4,5,Z9;K2$,R9,E
			IF E ! GOSUB Err_Search:
				returnstatus=0
				message$="ERROR "+STR$(E)+" DELETING KEY"
			Endif
			IF R9<>R4 ! GOSUB Err_Search:
				returnstatus=0;E=1 ! CALL IT NOT FOUND
				message$="ERROR "+STR$(E)+" DELETING KEY"
			Endif
			IF Not(F9[4]) !   NOT IN USE - CAN FREE RECORD
				LET E=3 \ SEARCH #4,1,0;K2$,R4,E
				IF E ! GOSUB Err_Search:
					returnstatus=0
					message$="ERROR "+STR$(E)+" RETURNING RECORD"
				Endif
			Endif
		Endif
		! end of delete DELCOMPT
	Case "DROPLIST" ! droplists
		ReturnStatus=0
		Message$="ACTION2 NOT FOUND"
		If action2$="CTGYLIST"	!						doc=SL-CTGYLIST.doc
			ReturnStatus=1
			Message$="OK"
			!taken from sledcodes
			Clear List$[]
			tmpcnt=maxcnt
			List$[0]=bsdel$,"CTGYLIST",fdel$
			List$[1]="ID",fdel$,"DESC",fdel$
			Row=2
			J$=" ",j$
			do
				Search #4,3,1;J$,r4,E \ if e exit do
				Try
				Mat read #4,r4,0;J1$;
				List$[row]=J$,fdel$,RTrim$(j1$[1,15]),fdel$
				row=row+1
				if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
				Else
					REM
				End try
			loop
			List$[row]=esdel$
			call AddToStr(e$,rstr$,List$[]) ! add droplist to string
		Endif ! of CTGYLIST
		If action2$="REFERLIST"	!						doc=SL-REFERLIST.doc
			!taken from sledcodes
			ReturnStatus=1
			Message$="OK"
			Clear List$[]
			tmpcnt=maxcnt
			List$[0]=bsdel$,"REFERLIST",fdel$
			List$[1]="ID",fdel$,"DESC",fdel$
			Row=2
			J$=" ",j$
			do
				Search #4,3,2;J$,r4,E \ if e exit do
				Try
				Mat read #4,r4,0;J1$;
				List$[row]=J$,fdel$,RTrim$(j1$[1,15]),fdel$
				row=row+1
				if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
				Else
					REM
				End try
			loop
			List$[row]=esdel$
			call AddToStr(e$,rstr$,List$[]) ! add droplist to string
		Endif ! of REFERLIST
		If action2$="QUALITYLIST"	!					doc=SL-QUALITYLIST.doc
			!taken from sledcodes
			ReturnStatus=1
			Message$="OK"
			Clear List$[]
			tmpcnt=maxcnt
			List$[0]=bsdel$,"QUALITYLIST",fdel$
			List$[1]="ID",fdel$,"DESC",fdel$
			Row=2
			J$=" ",j$
			do
				Search #4,3,3;J$,r4,E \ if e exit do
				Try
				Mat read #4,r4,0;J1$;
				List$[row]=J$,fdel$,RTrim$(j1$[1,15]),fdel$
				row=row+1
				if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
				Else
					REM
				End try
			loop
			List$[row]=esdel$
			call AddToStr(e$,rstr$,List$[]) ! add droplist to string
		Endif ! of QUALITYLIST
		If action2$="COMPETLIST"	!					doc=SL-COMPETLIST.doc
			!taken from sledcodes
			ReturnStatus=1
			Message$="OK"
			Clear List$[]
			tmpcnt=maxcnt
			List$[0]=bsdel$,"COMPETLIST",fdel$
			List$[1]="ID",fdel$,"DESC",fdel$
			Row=2
			J$=" ",j$
			do
				Search #4,3,4;J$,r4,E \ if e exit do
				Try
				Mat read #4,r4,0;J1$;
				List$[row]=J$,fdel$,RTrim$(j1$[1,15]),fdel$
				row=row+1
				if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
				Else
					REM
				End try
			loop
			List$[row]=esdel$
			call AddToStr(e$,rstr$,List$[]) ! add droplist to string
		Endif ! of COMPETLIST
		If Action2$="FILTERLIST"	!					doc=SL-FILTERLIST.doc
			! taken from sledfset
			ReturnStatus=1
			Message$="OK"
			Clear List$[]
			List$[0]=bsdel$,"FILTERLIST",fdel$
			List$[1]="ID",fdel$,"NAME",fdel$
			Row=2;tmpcnt=maxcnt
			LET PM$=PORTNUM USING "####"
			LET F9$=PM$
			LET J$=PORTNUM USING "@###      "
			SEARCH #5,2,1;J$,R5D,E \ IF E GOSUB Err_Search:
			L_5515: LET PH$=F9$ \ SEARCH #5,3,1;F9$,F9,E \ IF E GOTO L_5590:
			IF F9$[1,4]<>PM$ LET F9$=PH$ \ GOTO L_5590:
			Try
				READ #5,F9,6;CDESC$[1,20];
			Else
				goto L_5515
			end try
			List$[row]=F9$[5,10],fdel$,RTrim$(CDESC$[1,20]),fdel$
			row=row+1
			if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
			GOTO L_5515: ! "screen full?
			L_5590: ! done
			List$[row]=esdel$
			call AddToStr(e$,rstr$,List$[]) ! add droplist to string
		Endif ! of FILTERLIST
		If Action2$="CPFLTLIST"		!					doc=SL-CPFLTLIST.doc
			! taken from sledfset
			ReturnStatus=1
			Message$="OK"
			Clear List$[]
			List$[0]=bsdel$,"ALLFILTERLIST",fdel$
			List$[1]="FLKEY",fdel$,"ID",fdel$,"NAME",fdel$,"PORT",fdel$
			Row=2;tmpcnt=maxcnt
			LET F9$=" ",f9$
			
			CP5515: !file dir 2 loop (filter/port)
			SEARCH #5,3,2;F9$,F9,E \ IF E GOTO CP5590:
			!IF F9$[1,4]<>PM$ LET F9$=PH$ \ GOTO CP5590: ! SEND ALL
			Try
				READ #5,F9,6;CDESC$[1,20];
			Else
				Goto CP5515
			End try
			List$[row]=f9$,fdel$,F9$[1,6],fdel$,RTrim$(CDESC$[1,20]),fdel$,F9$[7,10],fdel$
			row=row+1
			if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
			GOTO CP5515: ! "screen full?
			CP5590: ! done
			List$[row]=esdel$
			call AddToStr(e$,rstr$,List$[]) ! add droplist to string
		Endif ! of CPFLTLIST
		If Action2$="SLSMLIST"	!						doc=SL-SLSMLIST.doc
			!taken from sledslsm
			ReturnStatus=1
			Message$="OK"
			Clear List$[]
			tmpcnt=maxcnt
			List$[0]=bsdel$,"SLSMLIST",fdel$
			List$[1]="ID",fdel$,"NAME",fdel$
			Row=2
			J$=" ",j$
			do
				Search #6,3,1;J$,r6,E \ if e exit do
				Try
				Mat read #6,r6,0;J1$;
				List$[row]=J$,fdel$,RTrim$(j1$[1,30]),fdel$
				row=row+1
				if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
				Else
					REM
				End try
			loop
			List$[row]=esdel$
			call AddToStr(e$,rstr$,List$[]) ! add droplist to string
		Endif ! of SLSMLIST
		If Action2$="ALLDLISTS" ! new - ALL DROPLISTS SENT
			ReturnStatus=1
			Message$="OK"
			Clear List$[]
			List$[0]=bsdel$,"FILTERLIST",fdel$
			List$[1]="ID",fdel$,"NAME",fdel$
			Row=2;tmpcnt=maxcnt
			LET PM$=PORTNUM USING "####"
			LET F9$=PM$
			LET J$=PORTNUM USING "@###      "
			SEARCH #5,2,1;J$,R5D,E \ IF E GOSUB Err_Search:
			AL_5515: LET PH$=F9$ \ SEARCH #5,3,1;F9$,F9,E \ IF E GOTO AL_5590:
			IF F9$[1,4]<>PM$ LET F9$=PH$ \ GOTO AL_5590:
			Try
				READ #5,F9,6;CDESC$[1,20];
			Else
				goto AL_5515
			end try
			List$[row]=F9$[5,10],fdel$,RTrim$(CDESC$[1,20]),fdel$
			row=row+1
			if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
			GOTO AL_5515: ! "screen full?
			AL_5590: ! done
			List$[row]=esdel$
			call AddToStr(e$,rstr$,List$[]) ! add droplist to string
			! next all filters on system
			Clear List$[]
			List$[0]=bsdel$,"ALLFILTERLIST",fdel$
			List$[1]="FLKEY",fdel$,"ID",fdel$,"NAME",fdel$,"PORT",fdel$
			Row=2;tmpcnt=maxcnt
			LET F9$=" ",f9$
			
			ACP5515: !file dir 2 loop (filter/port)
			SEARCH #5,3,2;F9$,F9,E \ IF E GOTO ACP5590:
			!IF F9$[1,4]<>PM$ LET F9$=PH$ \ GOTO ACP5590: ! SEND ALL
			Try
				READ #5,F9,6;CDESC$[1,20];
			Else
				Goto ACP5515
			End try
			List$[row]=f9$,fdel$,F9$[1,6],fdel$,RTrim$(CDESC$[1,20]),fdel$,F9$[7,10],fdel$
			row=row+1
			if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
			GOTO ACP5515: ! "screen full?
			ACP5590: ! done
			List$[row]=esdel$
			call AddToStr(e$,rstr$,List$[]) ! add droplist to string
			! next - referred by
			Clear List$[]
			tmpcnt=maxcnt
			List$[0]=bsdel$,"REFERLIST",fdel$
			List$[1]="ID",fdel$,"DESC",fdel$
			Row=2
			J$=" ",j$
			do
				Search #4,3,2;J$,r4,E \ if e exit do
				Try
				Mat read #4,r4,0;J1$;
				List$[row]=J$,fdel$,RTrim$(j1$[1,15]),fdel$
				row=row+1
				if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
				Else
					REM
				End try
			loop
			List$[row]=esdel$
			call AddToStr(e$,rstr$,List$[]) ! add droplist to string
			! next slsm list
			Clear List$[]
			tmpcnt=maxcnt
			List$[0]=bsdel$,"SLSMLIST",fdel$
			List$[1]="ID",fdel$,"NAME",fdel$
			Row=2
			J$=" ",j$
			do
				Search #6,3,1;J$,r6,E \ if e exit do
				Try
				Mat read #6,r6,0;J1$;
				List$[row]=J$,fdel$,RTrim$(j1$[1,30]),fdel$
				row=row+1
				if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
				Else
					REM
				End try
			loop
			List$[row]=esdel$
			call AddToStr(e$,rstr$,List$[]) ! add droplist to string
			! next ctgy list
			Clear List$[]
			tmpcnt=maxcnt
			List$[0]=bsdel$,"CTGYLIST",fdel$
			List$[1]="ID",fdel$,"DESC",fdel$
			Row=2
			J$=" ",j$
			do
				Search #4,3,1;J$,r4,E \ if e exit do
				Try
				Mat read #4,r4,0;J1$;
				List$[row]=J$,fdel$,RTrim$(j1$[1,15]),fdel$
				row=row+1
				if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
				Else
					REM
				End try
			loop
			List$[row]=esdel$
			call AddToStr(e$,rstr$,List$[]) ! add droplist to string
			! next compet list
			Clear List$[]
			tmpcnt=maxcnt
			List$[0]=bsdel$,"COMPETLIST",fdel$
			List$[1]="ID",fdel$,"DESC",fdel$
			Row=2
			J$=" ",j$
			do
				Search #4,3,4;J$,r4,E \ if e exit do
				Try
				Mat read #4,r4,0;J1$;
				List$[row]=J$,fdel$,RTrim$(j1$[1,15]),fdel$
				row=row+1
				if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
				Else
					REM
				End try
			loop
			List$[row]=esdel$
			call AddToStr(e$,rstr$,List$[]) ! add droplist to string
			! and last Quality list
			Clear List$[]
			tmpcnt=maxcnt
			List$[0]=bsdel$,"QUALITYLIST",fdel$
			List$[1]="ID",fdel$,"DESC",fdel$
			Row=2
			J$=" ",j$
			do
				Search #4,3,3;J$,r4,E \ if e exit do
				Try
				Mat read #4,r4,0;J1$;
				List$[row]=J$,fdel$,RTrim$(j1$[1,15]),fdel$
				row=row+1
				if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
				Else
					REM
				End try
			loop
			List$[row]=esdel$
			call AddToStr(e$,rstr$,List$[]) ! add droplist to string
		Endif
		!end of droplists
	! next case
	
	! end of main select
	
End Select
	OutDone: ! finished
	! status section
	call CreateNetStatus(e$,ReturnStatus,Message$,WebStr$)
	call AddToStr(e$,rstr$,WebStr$)
	call SetOutPut(e$,rstr$)
Else
	include "src/callmainerrnet.inc"
end try
End ! the whole program

L_1180: ! try next custid - IF using filter on custlookup
Search #2,3,1;K2$,K1,E
  If E
    !J7$ = "END OF FILE"
	ReturnStatus=0
	Message$="END OF FILE"
    Return ! Goto L_1130
  End If 
!End If 
Goto L_1600

L_1400: Rem GEN SORT CODE
J1$ = " ",J1$ !\ J5$ = "Company name" \ J0$ = "2 003011 2"
! SLM$[1,30] = J$ \ X1[9] = 9 
J5$ = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" \ J1$ = " ",J1$
J$ = SLM$[1,30] \ J$=UCASE$(J$)
If J$[1,4] = "THE " Let J$ = J$[5]
Gosub L_1510
K2$ = J$[1,7],J1$ \ K2$[9] = ""
For X = 1 To 8 \ X1[X] = 0 \ Next X
L_1440: Search #2,2,1;K2$,X3,E
If Not(E)
  X1 = 8
L_1455: X1[X1] = X1[X1] + 1
  If X1[X1] > Len(J5$)
    X1[X1] = 1 \ X1 = X1 - 1
    If X1 < 1 Let ReturnStatus=0;Message$="TOO MANY DUPLICATE NAMES" \ Return
    K2$[X1,X1] = J5$[X1[X1],X1[X1]]
    Goto L_1455
  End If 
  K2$[8,8] = J5$[X1[8],X1[8]]
  Goto L_1440
End If 
Return ! Print @6,0;K2$; \ Return 
L_1510: ! parse down
J4$ = ""
For X2 = 1 To Len(J$)
  If J$[X2,X2] >= "A" If J$[X2,X2] <= "Z"
    J4$ = J4$,J$[X2,X2]
  End If 
  If J$[X2,X2] >= "0" If J$[X2,X2] <= "9"
    J4$ = J4$,J$[X2,X2]
  End If 
Next X2
J$ = J4$
Return 
L_1600: Rem EXISTING RECORD
Gosub READMAIN
! Gosub L_10000 \ Goto L_1180 ! filter / fail to next
! don't filter, as they specifically asked for this one
L_1615: Gosub L_5000 ! cust data
! If WF Write #10,PORTNUM,0;SLM2[0];
call AddToStr(e$,rstr$,List$[]) ! add droplist to string
K3$ = SLM1$[1,8] \ K3$[9] = "~" \ Gosub L_4400 ! CALL NOTES
Return ! 

L_2600: Rem PREV/NEXT PROSP
! Gosub WRITEMAIN \ X3[2] = K1
K2$ = SLM1$
L_2605: X1 = 3 \ If U5$ = "P" Let X1 = 6
Search #2,X1,1;K2$,K1,E 
If E > 2 !Gosub ERR_SEARCH
	ReturnStatus=0
	Message$="S ERROR "+Str$(E)+" GETTING NEXT CUSTID!"
	Return
Endif
If E
  If X1 = 3 Let Message$ = "END OF FILE" Else Let Message$ = "BEGINNING OF FILE"
  ! K1 = X3[2] \ Gosub READMAIN ! \ Goto L_2400
  ReturnStatus=0
  Return
End If 
Gosub READMAIN \ Gosub L_10000 \ Goto L_2605
Goto L_1615
L_2800: Rem CALL LIST
For X1 = 1 To 12 \ SA[X1] = 0 \ Next X1 \ L1 = 0
K2$ = J4$ \ K2$=UCASE$(K2$)
L_2830: Search #2,3,1;K2$,K1,E
If E Goto L_2980
Gosub READMAIN \ Gosub L_10000 \ Goto L_2830
!L1 = L1 + 1 \ SA[L1] = K1
!Print Using "##. ";@0,L1;L1;SLM$[1,30];"  ";
WebStr$=k2$,fdel$,SLM$[1,30],fdel$
X2[1] = SLM2[2] \ X2[2] = SLM2[3] \ Gosub SHWDATE
WebStr$=WebStr$,tmp$,fdel$
List$[row]=WebStr$
row=row+1
if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
Goto L_2830
L_2980: ! Window Close 
!If K1 Goto L_1600 Else Goto L_1130
Return 

L_4300: Rem LIST NOTE TEXT
! LD1 = 1 \ Print @0,3;'CE';
L_4310: Search #3,3,1;KD3$,RD3,E \ If E > 2 Gosub ERR_SEARCH
If KD3$[1,14] <> KD3H$[1,14] Let E = 2 \ KD3$ = KD3H$[1,14],"00"
If Not(E)
  Try
  Read #3,RD3,8;SLDD$;
  Else
	SLDD$=""
  End try
  If Trim$(SLDD$[1,76])="" goto L_4310
  List$[row]=RTrim$(SLDD$[1,76]),fdel$
  row=row+1
  if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
  Goto L_4310
  
End If 
Return 
L_4400: Rem LIST NOTE HEADERS
LP$ = K3$ \ L1 = 1
Clear List$[]
tmpcnt=maxcnt
List$[0]=bsdel$,"CALLLIST",fdel$
List$[1]="CALLID",fdel$,"CALL",fdel$,"FOLLUP",fdel$,"FDAY",fdel$,"FTIME",fdel$,"REMARK",fdel$,"STATUS",fdel$
Row=2
L_4415: ! BACKWARD THRU CALLS
Search #3,6,1;K3$,R3,E
If E > 2 ! Gosub ERR_SEARCH
	ReturnStatus=0
	Message$="S ERROR "+Str$(E)+" GOING THROUGH FILE"
Endif
If K3$[1,8] <> SLM1$[1,8] Let E = 2
If Not(E)
  If K3$[15,16] = "00"
    Gosub READDETAIL ! \ SA[L1] = R3
    WebStr$=K3$,fdel$ 
	X2=SLD[0] \ J$=JDate$(X2)
	WebStr$=WebStr$,J$,fdel$
    If SLD[5] = 0 WebStr$=WebStr$," canceled",fdel$ \ Goto L_4450
    ! If SLD[5] = 2 Print 'BD';
    X2[1] = SLD[3] \ X2[2] = SLD[4] \ Gosub SHWDATE ! \ Print 'ED';"  ";
	WebStr$=WebStr$,tmp$,fdel$
L_4450: WebStr$=WebStr$,RTrim$(SLD$[9,67]),fdel$
	WebStr$=WebStr$,CSTAT$[SLD[5] * 6 + 1,SLD[5] * 6 + 6],fdel$
    List$[row]=WebStr$ ! L1 = L1 + 1 \ If L1 > 9 Return 
	row=row+1
	if row>tmpcnt let tmpcnt=expandarray(e$,List$[])
  End If 
  Goto L_4415
End If 
List$[row]=esdel$ ! end of section
Return 

L_5000: Rem SCREEN VARIABLES & and also redisplay
List$[0]=bsdel$,"MASTERCUST",fdel$
WebStr$="CUSTID",fdel$,"PMCUST",fdel$,"NAME",fdel$,"ADDR1",fdel$,"ADDR2",fdel$
WebStr$=WebStr$,"CITY",fdel$,"ST",fdel$,"ZIPCODE",fdel$,"CALLBACK",fdel$,"CDAY",fdel$,"CTIME",fdel$
WebStr$=WebStr$,"LASTCALL",fdel$,"LDAY",fdel$,"LTIME",fdel$,"PHONE",fdel$,"CONTACT",fdel$,"TITLE",fdel$
WebStr$=WebStr$,"REMARK1",fdel$,"REMARK2",fdel$,"REMARK3",fdel$,"CREATE",fdel$
WebStr$=WebStr$,"SLSM",fdel$,"SLSMNAME",fdel$,"CTGY",fdel$,"CTGYDESC",fdel$
WebStr$=WebStr$,"PHONE2",fdel$,"FAXNO",fdel$,"SALUTE",fdel$,"ALTCONT",fdel$
WebStr$=WebStr$,"ALTTITLE",fdel$,"ALTPHONE",fdel$,"REFBY1",fdel$,"RB1DESC",fdel$
WebStr$=WebStr$,"REFBY2",fdel$,"RB2DESC",fdel$,"REFBY3",fdel$,"RB3DESC",fdel$
WebStr$=WebStr$,"QUALITY",fdel$,"QDESC",fdel$,"COMPET",fdel$,"CMDESC",fdel$,"PARCOMP",fdel$
WebStr$=WebStr$,"SIC1",fdel$,"SIC2",fdel$,"SLSVOL",fdel$,"PROJSLS",fdel$
WebStr$=WebStr$,"NUMLOC",fdel$
List$[1]=WebStr$
WebStr$=SLM1$[1,8],fdel$ ! ID
If SLM2[0] WebStr$=WebStr$,Str$(SLM2[0]),fdel$ Else WebStr$=WebStr$," none ",fdel$
WebStr$=WebStr$,RTrim$(SLM$[1,30]),fdel$,RTrim$(SLM$[31,60]),fdel$,RTrim$(SLM$[61,90]),fdel$
WebStr$=WebStr$,RTrim$(SLM$[91,105]),fdel$,RTrim$(SLM$[106,107]),fdel$,RTrim$(SLM$[108,117]),fdel$
Gosub L_5250 ! calls Next/last
J4 = 35 \ J5 = 0 \ J1 = SLM1[0] \ Gosub L_7520
WebStr$=WebStr$,tmp$,fdel$ ! phone
WebStr$=WebStr$,RTrim$(SLM$[128,147]),fdel$,RTrim$(SLM$[148,163]),fdel$,RTrim$(SLM$[164,203]),fdel$
WebStr$=WebStr$,RTrim$(SLM$[204,243]),fdel$,RTrim$(SLM$[244,283]),fdel$
!X$ = SLM2[1] \ Call JulianToDate(1,X$,J$,E)
X2=SLM2[1] \ j$=JDate$(x2)
WebStr$=WebStr$,J$,fdel$
WebStr$=WebStr$,SLM2[9] Using "###",fdel$ \ Gosub GETSLSM
WebStr$=WebStr$,RTrim$(j$[1,30]),fdel$
NCODE = SLM3[0] \ Gosub PRINTCODE
WebStr$=WebStr$,SCODE$[17,20],fdel$,RTrim$(SCODE$[1,15]),fdel$
! Return 
! L_5100: Rem SCRN PT.2 (ALL IN ONE AND ONE FOR ALL)
J4 = 9 \ J5 = 12 \ J1 = SLM1[1] \ Gosub L_7520
WebStr$=WebStr$,tmp$,fdel$
J4 = 9 \ J5 = 13 \ J1 = SLM1[2] \ Gosub L_7520
WebStr$=WebStr$,tmp$,fdel$
WebStr$=WebStr$,RTrim$(SLM$[284,299]),fdel$,RTrim$(SLM$[320,339]),fdel$,RTrim$(SLM$[340,355]),fdel$
J4 = 50 \ J5 = 14 \ J1 = SLM1[3] \ Gosub L_7520
WebStr$=WebStr$,tmp$,fdel$
For X1[3] = 1 To 3
  NCODE = SLM3[X1[3]] \ Gosub PRINTCODE
  WebStr$=WebStr$,SCODE$[17,20],fdel$,RTrim$(SCODE$[1,15]),fdel$
Next X1[3]
NCODE = SLM3[4] \ Gosub PRINTCODE
WebStr$=WebStr$,SCODE$[17,20],fdel$,RTrim$(SCODE$[1,15]),fdel$
NCODE = SLM3[5] \ Gosub PRINTCODE
WebStr$=WebStr$,SCODE$[17,20],fdel$,RTrim$(SCODE$[1,15]),fdel$
WebStr$=WebStr$,RTrim$(SLM$[300,319]),fdel$
WebStr$=WebStr$,SLM2[6] Using "####",fdel$ !@56,17;SLM2[6];@62,17;SLM2[7];
WebStr$=WebStr$,SLM2[7] Using "####",fdel$
WebStr$=WebStr$,SLM2[8] Using "#######",fdel$ ! ;@56,18;SLM2[8];@56,19;SLM2[10];
WebStr$=WebStr$,SLM2[10] Using "#######",fdel$
WebStr$=WebStr$,SLM3[6] Using "####",fdel$
List$[2]=WebStr$
List$[3]=esdel$
Return 

L_5250: Rem LAST/NEXT CALL
!Gosub L_7900 \ If SLM2[2] <= CDATE If SLM[3] <= CTIME Print 'BB';
X2[1] = SLM2[2] \ X2[2] = SLM2[3] \ Gosub SHWDATE !  \ Print 'EB';
WebStr$=WebStr$,tmp$,fdel$
X2[1] = SLM2[4] \ X2[2] = SLM2[5] \ Gosub SHWDATE
WebStr$=WebStr$,tmp$,fdel$
Return 

CALLSCREEN: Rem CALL SCREEN
WebStr$=K3$,fdel$ ! should be key
X2[1] = SLD[0] \ X2[2] = SLD[2] \ Gosub SHWDATE
WebStr$=WebStr$,tmp$,fdel$
X2[1] = SLD[3] \ X2[2] = SLD[4] \ Gosub SHWDATE
WebStr$=WebStr$,tmp$,fdel$
WebStr$=WebStr$,RTrim$(SLD$[9,67]),fdel$
!If SLD$[68,68] = "A"
!  Print @68,1;'BU';"ApptCal";'EU';
!Else 
!  Print @68,1;"       ";
!End If 
WebStr$=WebStr$,CSTAT$[SLD[5] * 6 + 1,SLD[5] * 6 + 6],fdel$
List$[row]=WebStr$
Return 

READMAIN: Rem READ SLEDMAIN
Try
Mat Read #2,K1;SLM$
Mat Read #2,K1,360;SLM1$
Mat Read #2,K1,368;SLM1
Mat Read #2,K1,416;SLM2
Mat Read #2,K1,472;SLM3;
Else
	ReturnStatus=0
	Message$="ERROR READING SLEDMAIN "+STR$(K1)
End try
Return 
WRITEMAIN: Rem WRITE SLEDMAIN
Try
! Read #2,K1;DFLAG$ ! (CANNOT READ BEFORE WRITING !!!! CAUSES BE 52!!!!) RECORD NOT WRITTEN!!!
!  \ If Asc(DFLAG$[1,1]) = 255 Let E = 0 \ Gosub ERR_SEARCH (DELETED CHECK?)
Mat Write #2,K1;SLM$
Mat Write #2,K1,360;SLM1$;
Mat Write #2,K1,368;SLM1
Mat Write #2,K1,416;SLM2
Mat Write #2,K1,472;SLM3;
Else
	ReturnStatus=0
	Message$="ERROR "+Str$(SPC(8))+" WRITING SLEDMAIN REC "+Str$(K1)
End try
Return 
READDETAIL: Rem READ DETAIL
Try
Mat Read #3,R3;SLD
Mat Read #3,R3,24;SLD$;
Else
	ReturnStatus=0
	Message$="ERROR "+STR$(SPC(8))+" READING SLEDDETAIL REC "+Str$(R3)
End try
Return 
WRITEDETAIL: Rem WRITE DETAIL
Try
! Read #3,R3;DFLAG$ ! ! (CANNOT READ BEFORE WRITING !!!! CAUSES BE 52!!!!) RECORD NOT WRITTEN!!!
! \ If Asc(DFLAG$[1,1]) = 255 Let E = 0 \ Gosub ERR_SEARCH (DELETED RECORD CHECK?)
Mat Write #3,R3;SLD
Mat Write #3,R3,24;SLD$;
Else
	ReturnStatus=0
	Message$="ERROR "+STR$(SPC(8))+" WRITING SLEDDETAIL REC "+Str$(R3)
End try
Return 
CALLDELETE: Rem DELETE CALL
X1 = 0
KD3$ = SLD$[1,8] \ KD3$[9] = SLD[0] Using "#####"
KD3$[14,16] = SLD[1] Using "#  " \ KD3H$ = KD3$
L_6415: Search #3,3,1;KD3$,RD3,E
If E > 2 ! Gosub ERR_SEARCH
	ReturnStatus=0
	Message$="SEARCH ERROR "+Str$(E)+" GETTING CALLS"
	Return
Endif
If KD3$[1,14] <> KD3H$[1,14] Let E = 2
If Not(E)
  Search #3,5,1;KD3$,RD3,E 
  If E ! Gosub ERR_SEARCH
	ReturnStatus=0
	Message$="SEARCH ERROR "+Str$(E)+" DELETING CALL KEY1"
	Return
  Endif
  E = 3 \ Search #3,1,0;KD3$,RD3,E
  If E ! Gosub ERR_SEARCH
	ReturnStatus=0
	Message$="SEARCH ERROR "+Str$(E)+" RETURNING CALL RECORD"
	Return
  Endif
  Goto L_6415
End If 
Return
NEXTCALL: Rem GET NEXT CALL#/DATE
U5$ = SLM1$[1,8],"" \ NDATE = 99999 \ NTIME = 9999
NCLOOP: Search #3,3,1;U5$,R3,E \ If E > 2 Gosub ERR_SEARCH
If U5$[1,8] <> SLM1$[1,8] Let E = 2
If Not(E)
  Gosub READDETAIL
  If SLD[5] = 1
    If NDATE > SLD[3] If NTIME > SLD[4]
      NDATE = SLD[3] \ NTIME = SLD[4]
      EREC = R3
    End If 
  End If 
  Goto NCLOOP
End If 
SLM2[2] = 0 \ SLM2[3] = 0
If NDATE <> 99999 If NTIME <> 9999
  SLM2[2] = NDATE \ SLM2[3] = NTIME
End If 
Gosub L_5250
Return 
GETCODE: Rem GET CODE
U5$ = J$ \ NCODE = 0 \ SCODE$ = "    "
U5$[5]="" ! trim to 4
If U5$ <> "    "
  Search #4,2,Z9;U5$,NCODE,E
  If E > 1 ! Gosub ERR_SEARCH
	ReturnStatus=0
	Message$="S ERROR "+Str$(E)+" GETTING CODE "+Str$(Z9)
  Endif
  If E
    If X1[1] Let Message$ = "SELECTED CODE "+u5$+" NOT ON FILE";returnStatus=0 
    Return 
  Else
	Try
	Mat Read #4,NCODE;SCODE$;
	Else
		ReturnStatus=0
		Message$="ERROR READING SLEDCODE "+U5$
	End try
  End If 
End If 
Return 1 ! good= return + 1  nogood=return

PRINTCODE: ! get code from record
SCODE$ = " not foundERR "
If NCODE = 0 Let SCODE$ = " ",SCODE$ \ Goto L_6840
If NCODE >= 0 If NCODE < Chf(4)
	Try
		Mat Read #4,NCODE;SCODE$;
	Else
		ReturnStatus=0
		Message$="ERROR READING SLEDCODE "+Str$(NCODE)
	End try
Endif
L_6840: ! Print SCODE$[17,20];" ";SCODE$[1,15];
Return 

GETSLSM: J$ = " ",J$
If SLM2[9]
  J4$ = SLM2[9] Using "###"
  Search #6,2,1;J4$,X2,E
  If E > 1 ! Gosub ERR_SEARCH
	ReturnStatus=0
	Message$="S ERROR "+Str$(E)+" GETTING SALESMAN KEY"
  Endif
  J$[1,12] = " not on file "
  If Not(E)
	Try
		Read #6,X2;J$[1,30];
	Else
		ReturnStatus=0
		Message$="ERROR READING SLSM "+J4$
	End try
  Endif
End If 
Return 

SHWDATE: Rem PRINT DATE/TIME (we send as 3 fields DATE,DAY,TIME
If X2[1]
  U5$=""
  !X$ = X2[1] \ Call JulianToDate(1,X$,J$,E) \ 
  X2=X2[1] \ J$=JDate$(x2)
  U5$=J$+fdel$ ! +" "
  X1 = X2[1] - Int(X2[1] / 7) * 7 \ U5$=U5$+DAYS$[X1 * 3 + 1,X1 * 3 + 3]+fdel$ !+" "
  X$ = "am" \ X1[1] = FNH(X2[2]) \ If X1[1] > 11 Let X$ = "pm"
  If X1[1] > 12 Let X1[1] = X1[1] - 12
  If Not(X1[1]) Let X1[1] = 12
  U5$=U5$+X1[1] Using "&&"+":"
  U5$=U5$+FNM(X2[2]) Using "&&"+" "+X$
Else 
  U5$ = " ",fdel$," ",fdel$," " ! ,U5$ ! \ Print U5$[1,21];
End If 
tmp$=U5$
Return 

L_7520: Rem PRINT PHONE#
U5$ = " ",U5$ ! \ Print @J4,J5;U5$[1,20];@J4,J5;
tmp$=""
If J1
  U5$ = J1 \ U5$ = U5$[2,Len(U5$) - 1]
  If Len(U5$) = 7
    tmp$=U5$[1,3]+"-"+U5$[4]
  Else 
    tmp$="("+U5$[1,3]+") "+U5$[4,6]+"-"+U5$[7,10]
  End If 
  If Len(U5$) > 10 tmp$=Tmp$+" x"+U5$[11]
End If 
tmp$=RTrim$(tmp$)
Return 
L_7900: Rem GET CURRENT DATE/TIME
J$ = Msc$(0) \ J1$ = J$[15,16],J$[18,19] \ J$[12] = ""
Call VerifyDate(J$) \ Call DateToJulian(1,J$) \ CDATE = J$ \ CTIME = J1$
Return 
L_8000: ! clear all master vars
SLM$ = " ",SLM$
SLM1$ = " ",SLM1$
For K9 = 0 To 13
  If K9 <= 5 Let SLM1[K9] = 0
  SLM2[K9] = 0
  If K9 <= 6 Let SLM3[K9] = 0
Next K9
Return 
L_8100: Rem DIR 2
J4$ = SLM$[1,16] \ J4$[17] = SLM1$[1,8]
J4$=UCASE$(J4$) \ Search #2,5,2;J4$,X2,E
J4$[1,16] = J$[1,16] \ X2 = K1
J4$=UCASE$(J4$) \ Search #2,4,2;J4$,X2,E
Return 

GETFILTER: ! get & set up filter
J$ = PORTNUM Using "@###      "
Search #5,2,1;J$,R5,E
If E
  E = 2 \ Search #5,1,0;J$,R5,E
  If E ! Gosub ERR_SEARCH
	ReturnStatus=0
	Message$="S ERROR "+Str$(E)+" GETTING NEW RECORD"
	Return
  Endif
  FR = 0 \ Write #5,R5;FR;
  Search #5,4,1;J$,R5,E
  If E ! Gosub ERR_SEARCH
	ReturnStatus=0
	Message$="S ERROR "+Str$(E)+" INSERTING NEW KEY1"
	Return
  Endif
Else 
	Try
	  Read #5,R5;FR;
	Else
		ReturnStatus=0
		Message$="ERROR READING MAIN FILTER FOR PORT "+Str$(PORTNUM)
	End try
End If 
L_8445: SC$ = " ",SC$
For X1 = 0 To 9 \ SC1[X1] = 0 \ Next X1
For X1 = 0 To 7 \ SC2[X1] = 0 \ Next X1
If FR
  Try
	Mat Read #5,FR;SC$;
	Mat Read #5,FR,224;SC1;
	Mat Read #5,FR,244;SC2;
  Else
	Let FR=0
	Goto L_8445
  End try
End If 
If SC$[1,1] = "" Or SC$[1,1] < " " Let FR = 0 \ Goto L_8445
J$ = SC$[27,42] \ Gosub L_8535 \ SCA$ = J$
J$ = SC$[43,58] \ Gosub L_8535 \ SCB$ = J$
J$ = SC$[59,74] \ Gosub L_8535 \ SCC$ = J$
J$ = SC$[77,81] \ Gosub L_8535 \ SCZ$ = J$
J$ = SC$[82,97] \ Gosub L_8535 \ SCD$ = J$
J$ = SC$[98,113] \ Gosub L_8535 \ SCE$ = J$
J$ = SC$[114,124] \ Gosub L_8535 \ SCF$ = J$
J$ = SC$[125,138] \ Gosub L_8535 \ SCG$ = J$
J$ = SC$[140,153] \ Gosub L_8535 \ SCH$ = J$
J$ = SC$[155,168] \ Gosub L_8535 \ SCI$ = J$
Goto L_8560
L_8535: ! Right Trim/UPPERCASE Entry
If J$[1,1] > " "
  J$=RTRIM$(J$)
  J$=UCASE$(J$)
End If 
Return 
L_8560: ! Date checkload
For X1 = 0 To 2
  If SC2[X1] <= 101 !   9999 (doing days check)
    SCD[X1] = CDATE + SC2[X1]
  Else ! it's a date check
    J4$ = ""
    J$ = SC2[X1] Using "&&&&&&" \ Call DateToJulian(1,J$,J$,E)
    If E !"invalid date -- let us default it to the current date
      J$ = Tim(8) * 10 ^ 4 + Tim(9) * 10 ^ 2 + Tim(10) Using "&&&&&&"
      SC2[X1] = Val(J$)
      Call DateToJulian(1,J$)
    End If 
    SCD[X1] = J$
  End If 
Next X1
Return 
L_8900: Rem DELETE RECORD
!Print @0,23;"Deleting, please wait . . . ";'CL'; \ Signal 3,0
K2$ = " ",K2$ \ K2$ = SLM1$
Search #2,5,1;K2$,K1,E 
If E ! Gosub ERR_SEARCH
	ReturnStatus=0
	Message$="SE "+Str$(E)+" DELETING KEY1"
	Return
Endif
J$ = SLM$ \ J$[17] = SLM1$
J$=UCASE$(J$)
Search #2,5,2;J$,K1,E
If E > 1 !Gosub ERR_SEARCH
	ReturnStatus=0
	Message$="SE "+Str$(E)+" DELETING KEY2"
	Return
Endif
E = 3 \ Search #2,1,0;K2$,K1,E
If E !Gosub ERR_SEARCH
  ReturnStatus=0
	Message$="SE "+Str$(E)+" RETURNING RECORD"
	Return
Endif
J$ = SLM1$[1,8],""
L_8935: Search #3,3,1;J$,K3,E 
If E > 2 ! Gosub ERR_SEARCH
	ReturnStatus=0
	Message$="SE "+Str$(E)+" GETTING CALL KEY1"
	Return
Endif
If J$[1,8] <> SLM1$[1,8] Let E = 2
If Not(E)
  Search #3,5,1;J$,K3,E
  If E ! Gosub ERR_SEARCH
	ReturnStatus=0
	Message$="SE "+Str$(E)+" DELETING CALL KEY1"
	Return
  Endif
  E = 3 \ Search #3,1,0;J$,K3,E
  If E ! Gosub ERR_SEARCH
	ReturnStatus=0
	Message$="SE "+Str$(E)+" RETURING CALL RECORD"
	Return
  Endif
  Goto L_8935
End If 
Return ! Gosub L_8000 !\ Goto RESTART

OUTEND: Rem OUT
Close
End

L_10000: Rem CHECK FILTER
If P9$[21,21] = "N" ! "check security on salesman
  CUSTSEC[0] = K1;CUSTSEC[1] = 1
  Call "PROSPSEC.dl4",CUSTSEC[]
  If CUSTSEC[0] = -1 Return 
End If 
If SALESMAN If SALESMAN <> SLM2[9] Return 
If Not(FR) Return 1 ! NO filter
If SCA$[1,1] > " "
  J$ = SCA$[2] \ J1$ = SCA$[1,1] \ J4$ = SLM$[1,30]
  Gosub L_14000 \ Return 
End If 
If SCB$[1,1] > " "
  J$ = SCB$[2] \ J1$ = SCB$[1,1] \ J4$ = SLM$[31,90]
  Gosub L_14000 \ Return 
End If 
If SCC$[1,1] > " "
  J$ = SCC$[2] \ J1$ = SCC$[1,1] \ J4$ = SLM$[91,105]
  Gosub L_14000 \ Return 
End If 
If SC$[75,76] <> "  " If SC$[75,76] <> SLM$[106,107] Return 
If SC$[77,77] > " "
  J$ = SCZ$ \ J1$ = "B" \ J4$ = SLM$[108,112]
  Gosub L_14000 \ Return 
End If 
If SCD$[1,1] > " "
  J$ = SCD$[2] \ J1$ = SCD$[1,1] \ J4$ = SLM$[128,147]
  Gosub L_14000 \ Return 
End If 
If SCE$[1,1] > " "
  J$ = SCE$[2] \ J1$ = SCE$[1,1] \ J4$ = SLM$[164,283]
  Gosub L_14000 \ Return 
End If 
If SCF$[1,1] > " "
  For X1 = 0 To 3
    J$ = SCF$[2] \ J1$ = SCF$[1,1] \ J4$ = SLM1[X1] \ J4$ = J4$[2]
    Gosub L_14000 \ Goto L_10260
    Goto L_10270
L_10260: Next X1 \ Return 
End If 
L_10270: For X1 = 0 To 2
  If SC$[X1 + 169,X1 + 169] <> " "
    X2 = SLM2[SLMA[X1]]
    If Not(X2) Return 
    If SC$[X1 + 169,X1 + 169] = "<" If SCD[X1] <= X2 Return 
    If SC$[X1 + 169,X1 + 169] = "=" If SCD[X1] <> X2 Return 
    If SC$[X1 + 169,X1 + 169] = ">" If SCD[X1] >= X2 Return 
  End If 
Next X1
If SC1[1] If SC1[1] <> SLM2[9] Return 
If SC1[2] If SC1[2] <> SLM3[0] Return 
If SC1[3]
  For X1 = 1 To 3
    If SC1[3] = SLM3[X1] Goto L_10380
  Next X1 \ Return 
L_10380: End If 
If SC1[4] If SC1[4] <> SLM3[4] Return 
If SC1[5] If SC1[5] <> SLM3[5] Return 
X1[2] = 0
For X1 = 0 To 2
  If SC2[X1 + 3]
    J$ = SC2[X1 + 3] \ J$ = J$[2,Len(J$) - 1]
    For X1[1] = 6 To 7
      J4$ = SLM2[X1[1]] \ J4$ = J4$[2,Len(J4$) - 1]
      If J4$[1,Len(J$)] = J$ Goto L_10500
    Next X1[1] \ X1[2] = 1
  End If 
Next X1
If X1[2] Return 
L_10500: For X1 = 0 To 2
  If SC$[172 + X1,172 + X1] > " "
    If X1 = 0 Let X2 = SC2[6] \ X2[1] = SLM2[8]
    If X1 = 1 Let X2 = SC2[7] \ X2[1] = SLM2[10]
    If X1 = 2 Let X2 = SC1[6] \ X2[1] = SLM3[6]
    If SC$[172 + X1,172 + X1] = "<" If X2 <= X2[1] Return 
    If SC$[172 + X1,172 + X1] = "=" If X2 <> X2[1] Return 
    If SC$[172 + X1,172 + X1] = ">" If X2 >= X2[1] Return 
  End If 
Next X1
Return 1
L_14000: ! String compare
J4$=UCASE$(J4$)
If J1$ = "B"
  If J4$[1,Len(J$)] = J$ Return 1
Else 
  Search J4$,J$,E \ If E Return 1
End If 
Return 

L_5500: ! PRINT DATE
WebStr$=WebStr$,SC$[IPS+169,IPS+169],fdel$
tmp$=""
IF SC$[IPS+169,IPS+169]<>" "
	IF SC2[IPS]<101
		tmp$="TODAY "
		IF SC2[IPS]
			LET J$=SC2[IPS] USING "++++#"
			L_5530: J$=LTrim$(J$) ! IF J$[1,1]=" " LET J$=J$[2] \ GOTO L_5530:
			tmp$=tmp$+J$
		ENDIF 
	ELSE 
		LET X2=SC2[IPS]
		tmp$=PDate$(X2)
	ENDIF 
ENDIF 
WebStr$=WebStr$,tmp$,fdel$
RETURN
!--------------------------------------------------------------------
Function chkDateFrmt$(DIn$)
! see if date in is MM/DD/YY or MM/DD/YYYY
! if not make it MM/DD/YYYY
Try
	Dim DOut$[10],X$[20]
	Dim 1%,Mth,Day
	Dim 3%,Yr
	If DIn$[1,2]="00" or UCase$(DIn$[1,4])="NONE"
	  Let DOut$=UCase$(DIn$)
	  Exit Function DOut$ ! no reformat - send back as is
	Endif
	Mth=DIn$[1,2];Day=Din$[4,5];Yr=DIn$[7]
	if Din$[2,2]="/" or DIn$[2,2]="-" ! 1 digit month
	  Let Mth=DIn$[1,1]
	  If DIn$[4,4]="/" or DIn$[4,4]="-" ! 1 digit day
	     Let Day=DIn$[3,3]
		 Let Yr=DIn$[5]
	  Else
	     Let Day=Din$[3,4] ! try 2 digit
		 Let Yr=DIn$[6]
	  Endif
	Endif
	X$=Mth Using "&&"
	X$[3,4]=Day Using "&&"
	If Yr>1000 ! 4
		X$[5]=Yr Using "&&&&"
	Else ! 2 digit
		If YR<67 let yr=2000+yr Else Let Yr=yr+1900
		X$[5]=Yr Using "####"
	Endif
	Dout$=X$[1,2]+"/"+X$[3,4]+"/"+X$[5]
 else
    include "src/callsuberr.inc"
  end try
end Function DOut$ ! chkDateFrmt$
! 
!--------------------------------------------------------------------
Rem {begin rtn.error.s}
ERR_TRAP: Rem
If Spc(8) = 123
  Escdis 
  Escclr 
  Return -1
End If 
Goto ERR_MAIN
ERR_SEARCH: Rem
ENUM = E + 1000;ELINE = Spc(16);CTERR = 0
If E = 5 Let CTERR = Err(8)
msg$ = "RETURN STATUS",(E + (CTERR * .001))
msg$ = msg$,"/ STATEMENT",ELINE," IN PROGRAM "
Goto ERR_MAIN
ERR_MAIN: Rem
! If Err 0 Rem
e$ = msg$
If Spc(8) <> 10000 Call suberr(e$,Spc(8),Spc(10),Msc$(2))
Call mainerr(e$,Spc(8),buttonlist$[],nextlist$[])
Stop 
Rem {end rtn.error.s}
